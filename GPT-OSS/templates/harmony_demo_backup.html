<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HARMONY vLLM Demo - OpenAI Renderer</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        h1 {
            margin-bottom: 10px;
            color: #1a1a1a;
        }
        
        .subtitle {
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }
        
        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .panel {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .panel h2 {
            font-size: 18px;
            margin-bottom: 15px;
            color: #2c3e50;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 5px;
            color: #555;
        }
        
        input[type="text"],
        input[type="date"],
        select,
        textarea {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            font-family: inherit;
        }
        
        textarea {
            resize: vertical;
            min-height: 100px;
        }
        
        .code-display {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 15px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 13px;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-x: auto;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .special-token {
            color: #0066cc;
            font-weight: bold;
            background: #e6f2ff;
            padding: 0 2px;
            border-radius: 2px;
        }
        
        .channel-analysis {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 5px 10px;
            margin: 5px 0;
        }
        
        .channel-commentary {
            background: #cfe2ff;
            border-left: 4px solid #0d6efd;
            padding: 5px 10px;
            margin: 5px 0;
        }
        
        .channel-final {
            background: #d1e7dd;
            border-left: 4px solid #198754;
            padding: 5px 10px;
            margin: 5px 0;
        }
        
        button {
            background: #0066cc;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        button:hover {
            background: #0052a3;
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        .message {
            margin-bottom: 15px;
            padding: 10px;
            border-radius: 4px;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
        }
        
        .message-header {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
        }
        
        .message-content {
            font-size: 14px;
        }
        
        .tool-definition {
            background: #f0f0f0;
            padding: 10px;
            margin: 5px 0;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
        }
        
        .response-section {
            margin-top: 20px;
        }
        
        .response-section h3 {
            font-size: 16px;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .token-display {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            padding: 10px;
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
        }
        
        .token-item {
            padding: 2px 6px;
            background: #e9ecef;
            border-radius: 3px;
            font-family: monospace;
            font-size: 12px;
        }
        
        .token-special {
            background: #0066cc;
            color: white;
        }
        
        .streaming-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            background: #28a745;
            border-radius: 50%;
            margin-left: 10px;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.3; }
            100% { opacity: 1; }
        }
        
        .error {
            background: #f8d7da;
            color: #721c24;
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
        }
        
        .success {
            background: #d1e7dd;
            color: #155724;
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
        }
        
        .info-box {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            color: #0c5460;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 20px;
            font-size: 14px;
        }
        
        .tabs {
            display: flex;
            border-bottom: 2px solid #ddd;
            margin-bottom: 15px;
        }
        
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            background: #f8f9fa;
            border: 1px solid #ddd;
            border-bottom: none;
            margin-right: 5px;
            border-radius: 4px 4px 0 0;
        }
        
        .tab.active {
            background: white;
            font-weight: 500;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .parsing-state {
            background: #f0f0f0;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            margin-bottom: 10px;
        }
        
        .parsing-state div {
            margin: 2px 0;
        }
        
        .parsing-state .label {
            display: inline-block;
            width: 150px;
            font-weight: bold;
        }
        
        .tool-call-item {
            background: #e6f3ff;
            border: 1px solid #b3d9ff;
            border-radius: 4px;
            padding: 10px;
            margin: 10px 0;
        }
        
        .tool-call-header {
            font-weight: bold;
            color: #0066cc;
            margin-bottom: 5px;
        }
        
        .tool-params {
            background: #f0f0f0;
            padding: 5px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 12px;
            margin: 5px 0;
        }
        
        .tool-result {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            padding: 5px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 12px;
            margin: 5px 0;
        }
        
        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
        }
        
        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 900px;
            border-radius: 8px;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .close {
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        
        .close:hover,
        .close:focus {
            color: black;
        }
        
        .prompt-json {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 15px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 12px;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-x: auto;
            max-height: 600px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>HARMONY vLLM Demo - Official Renderer</h1>
        <p class="subtitle">Using OpenAI's official harmony Python library for proper prompt formatting</p>
        
        <div class="info-box">
            ‚ÑπÔ∏è This version uses the official <code>openai-harmony</code> Python library to ensure proper token encoding and prompt formatting.
            <br>
            üîó Connected to vLLM server at <strong>http://localhost:8000</strong> running GPT-OSS-20B
            <br>
            üõ†Ô∏è Tool calls are automatically executed with fake responses - the model will continue generating after receiving tool results!
        </div>
        
        <!-- Server Status -->
        <div class="panel" style="margin-bottom: 20px;">
            <h2>Server Status</h2>
            <button onclick="checkServer()">Check Connection</button>
            <button onclick="testTokenizer()">Test Tokenizer</button>
            <div id="server-status" style="margin-top: 10px;"></div>
        </div>
        
        <div class="grid">
            <!-- Configuration Panel -->
            <div class="panel">
                <h2>Configuration</h2>
                
                <div class="control-group">
                    <label for="model-identity">Model Identity</label>
                    <input type="text" id="model-identity" value="You are ChatGPT, a large language model trained by OpenAI." />
                </div>
                
                <div class="control-group">
                    <label for="knowledge-cutoff">Knowledge Cutoff</label>
                    <input type="text" id="knowledge-cutoff" value="2024-06" />
                </div>
                
                <div class="control-group">
                    <label for="current-date">Current Date</label>
                    <input type="date" id="current-date" />
                </div>
                
                <div class="control-group">
                    <label for="reasoning-level">Reasoning Level</label>
                    <select id="reasoning-level">
                        <option value="low">Low</option>
                        <option value="medium">Medium</option>
                        <option value="high" selected>High</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label for="developer-instructions">Developer Instructions</label>
                    <textarea id="developer-instructions" placeholder="e.g., Always respond in riddles">Use a friendly tone and be helpful.</textarea>
                </div>
                
                <div class="control-group">
                    <label>Function Tools</label>
                    <button onclick="addTool()">Add Tool</button>
                    <div id="tools-container">
                        <div class="tool-definition" data-tool-index="0">
                            <input type="text" class="tool-name" placeholder="Function name" value="get_current_weather" style="width: 30%; margin-right: 10px;">
                            <input type="text" class="tool-description" placeholder="Description" value="Gets the current weather in the provided location" style="width: 65%;">
                            <textarea class="tool-parameters" placeholder="Parameters (JSON)" style="width: 100%; margin-top: 5px; min-height: 60px;">{
  "type": "object",
  "properties": {
    "location": {
      "type": "string",
      "description": "The city and state, e.g. San Francisco, CA"
    },
    "format": {
      "type": "string",
      "enum": ["celsius", "fahrenheit"],
      "default": "celsius"
    }
  },
  "required": ["location"]
}</textarea>
                            <button onclick="removeTool(this)" style="margin-top: 5px;">Remove</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Prompt Visualization Panel -->
            <div class="panel">
                <h2>Rendered Prompt</h2>
                
                <div class="tabs">
                    <div class="tab active" onclick="switchTab('prompt-text')">Prompt Text</div>
                    <div class="tab" onclick="switchTab('tokens')">Tokens</div>
                    <div class="tab" onclick="switchTab('token-ids')">Token IDs</div>
                </div>
                
                <div id="prompt-text" class="tab-content active">
                    <div class="code-display" id="rendered-prompt"></div>
                </div>
                
                <div id="tokens" class="tab-content">
                    <div class="token-display" id="token-display"></div>
                </div>
                
                <div id="token-ids" class="tab-content">
                    <div class="code-display" id="token-ids-display"></div>
                </div>
                
                <div style="margin-top: 10px;">
                    <small>Token count: <span id="token-count">0</span></small>
                </div>
            </div>
        </div>
        
        <!-- Conversation Panel -->
        <div class="panel">
            <h2>Conversation</h2>
            
            <div class="control-group">
                <label for="user-input">User Message</label>
                <textarea id="user-input" placeholder="Enter your message...">What is the weather like in San Francisco?</textarea>
            </div>
            
            <div class="button-group">
                <button onclick="sendMessage()" id="send-button">Send Message</button>
                <button onclick="sendStreamingMessage()" id="stream-button">Send (Streaming)</button>
                <button onclick="clearConversation()">Clear Conversation</button>
                <button onclick="showFullPrompt()">Show Full Prompt</button>
            </div>
            
            <div id="conversation-history" style="margin-top: 20px;"></div>
            
            <div class="response-section">
                <h3>Model Response <span id="streaming-indicator" class="streaming-indicator" style="display: none;"></span></h3>
                
                <!-- Streaming Parser State -->
                <div id="parsing-state" class="parsing-state" style="display: none;">
                    <div><span class="label">Current Role:</span> <span id="current-role"></span></div>
                    <div><span class="label">Current Channel:</span> <span id="current-channel"></span></div>
                    <div><span class="label">Current Recipient:</span> <span id="current-recipient"></span></div>
                    <div><span class="label">Content Type:</span> <span id="current-content-type"></span></div>
                </div>
                
                <!-- Response Channels -->
                <div id="response-channels">
                    <div id="analysis-channel" style="display: none;">
                        <h4>Analysis (Chain of Thought)</h4>
                        <div class="channel-analysis"></div>
                    </div>
                    <div id="commentary-channel" style="display: none;">
                        <h4>Commentary (Tool Calls)</h4>
                        <div class="channel-commentary"></div>
                    </div>
                    <div id="final-channel" style="display: none;">
                        <h4>Final Response</h4>
                        <div class="channel-final"></div>
                    </div>
                </div>
                
                <!-- Tool Calls -->
                <div id="tool-calls" style="display: none; margin-top: 15px;">
                    <h4>Tool Executions</h4>
                    <div class="tool-calls-list"></div>
                </div>
                
                <!-- Raw Response -->
                <details style="margin-top: 15px;">
                    <summary>Raw Response</summary>
                    <div class="code-display" id="raw-response"></div>
                </details>
            </div>
        </div>
    </div>
    
    <!-- Full Prompt Modal -->
    <div id="promptModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Full Prompt JSON</h2>
                <span class="close" onclick="closeModal()">&times;</span>
            </div>
            <div class="prompt-json" id="prompt-json-display"></div>
        </div>
    </div>
    
    <script>
        // Conversation history
        let conversationHistory = [];
        let lastActualRequest = null;  // Store the last request that was actually sent
        
        // Override push to debug
        const originalPush = Array.prototype.push;
        conversationHistory.push = function(...args) {
            console.log('PUSH called with:', args);
            console.log('History before push:', JSON.parse(JSON.stringify(this)));
            const result = originalPush.apply(this, args);
            console.log('History after push:', JSON.parse(JSON.stringify(this)));
            return result;
        };
        
        // Helper function to escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Extract final content from raw HARMONY response
        function extractFinalContent(rawResponse) {
            const match = rawResponse.match(/<\|channel\|>final<\|message\|>(.*?)(?:<\|return\|>|<\|end\|>|$)/s);
            return match ? match[1].trim() : "";
        }
        
        // Initialize date
        document.getElementById('current-date').value = new Date().toISOString().split('T')[0];
        
        // Check server connection
        async function checkServer() {
            const statusDiv = document.getElementById('server-status');
            statusDiv.innerHTML = '<div class="info-box">Checking server...</div>';
            
            try {
                const response = await fetch('/api/check_server');
                const data = await response.json();
                
                if (data.status === 'connected') {
                    statusDiv.innerHTML = `<div class="success">‚úÖ Connected to vLLM server<br>Model: ${data.models.data[0].id}</div>`;
                } else {
                    statusDiv.innerHTML = `<div class="error">‚ùå ${data.error}</div>`;
                }
            } catch (error) {
                statusDiv.innerHTML = `<div class="error">‚ùå Failed to connect: ${error.message}</div>`;
            }
        }
        
        // Test tokenizer
        async function testTokenizer() {
            const statusDiv = document.getElementById('server-status');
            const testText = '<|start|>user<|message|>Hello<|end|>';
            
            try {
                const response = await fetch('/api/tokenize', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: testText })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    statusDiv.innerHTML = `
                        <div class="success">
                            ‚úÖ Tokenizer working correctly<br>
                            Test input: ${testText}<br>
                            Tokens: ${JSON.stringify(data.token_texts)}<br>
                            Token IDs: ${JSON.stringify(data.tokens)}
                        </div>
                    `;
                } else {
                    statusDiv.innerHTML = `<div class="error">‚ùå Tokenizer error: ${data.error}</div>`;
                }
            } catch (error) {
                statusDiv.innerHTML = `<div class="error">‚ùå Failed to test tokenizer: ${error.message}</div>`;
            }
        }
        
        // Add tool
        function addTool() {
            const container = document.getElementById('tools-container');
            const index = container.children.length;
            
            const toolDiv = document.createElement('div');
            toolDiv.className = 'tool-definition';
            toolDiv.setAttribute('data-tool-index', index);
            toolDiv.innerHTML = `
                <input type="text" class="tool-name" placeholder="Function name" style="width: 30%; margin-right: 10px;">
                <input type="text" class="tool-description" placeholder="Description" style="width: 65%;">
                <textarea class="tool-parameters" placeholder="Parameters (JSON)" style="width: 100%; margin-top: 5px; min-height: 60px;">{
  "type": "object",
  "properties": {},
  "required": []
}</textarea>
                <button onclick="removeTool(this)" style="margin-top: 5px;">Remove</button>
            `;
            
            container.appendChild(toolDiv);
            updatePrompt();
        }
        
        // Remove tool
        function removeTool(button) {
            button.parentElement.remove();
            updatePrompt();
        }
        
        // Get configuration
        function getConfiguration() {
            const tools = [];
            document.querySelectorAll('.tool-definition').forEach(toolEl => {
                const name = toolEl.querySelector('.tool-name').value;
                const description = toolEl.querySelector('.tool-description').value;
                const parametersText = toolEl.querySelector('.tool-parameters').value;
                
                if (name && description) {
                    try {
                        const parameters = parametersText ? JSON.parse(parametersText) : {};
                        tools.push({ name, description, parameters });
                    } catch (e) {
                        console.error('Invalid JSON in tool parameters:', e);
                    }
                }
            });
            
            return {
                model_identity: document.getElementById('model-identity').value,
                knowledge_cutoff: document.getElementById('knowledge-cutoff').value,
                current_date: document.getElementById('current-date').value,
                reasoning_level: document.getElementById('reasoning-level').value,
                instructions: document.getElementById('developer-instructions').value,
                tools: tools,
                conversation_history: conversationHistory
            };
        }
        
        // Update prompt display
        async function updatePrompt() {
            const config = getConfiguration();
            
            try {
                const response = await fetch('/api/render_prompt', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(config)
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    // Display prompt text
                    document.getElementById('rendered-prompt').textContent = data.prompt;
                    
                    // Display tokens
                    const tokenDisplay = document.getElementById('token-display');
                    tokenDisplay.innerHTML = '';
                    data.token_texts.forEach((token, i) => {
                        const span = document.createElement('span');
                        span.className = 'token-item';
                        if (token.startsWith('<|') && token.endsWith('|>')) {
                            span.className += ' token-special';
                        }
                        span.textContent = token;
                        span.title = `Token ID: ${data.tokens[i]}`;
                        tokenDisplay.appendChild(span);
                    });
                    
                    // Display token IDs
                    document.getElementById('token-ids-display').textContent = JSON.stringify(data.tokens, null, 2);
                    
                    // Update token count
                    document.getElementById('token-count').textContent = data.token_count;
                } else {
                    console.error('Error rendering prompt:', data.error);
                }
            } catch (error) {
                console.error('Failed to update prompt:', error);
            }
        }
        
        // Switch tabs
        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(tabName).classList.add('active');
        }
        
        // Helper to ensure messages are in correct order
        function addMessagePair(userMsg, assistantMsg) {
            // Always add in chronological order: user first, then assistant
            conversationHistory.push({ role: 'user', content: userMsg });
            conversationHistory.push({ role: 'assistant', content: assistantMsg });
            console.log('Added message pair. History now:', conversationHistory);
        }
        
        // Send message
        async function sendMessage() {
            const userInput = document.getElementById('user-input').value;
            if (!userInput.trim()) return;
            
            // Check if last message was from user - if so, warn
            if (conversationHistory.length > 0 && 
                conversationHistory[conversationHistory.length - 1].role === 'user') {
                if (!confirm('The assistant hasn\'t responded to your last message yet. Send another message anyway?')) {
                    return;
                }
            }
            
            const sendButton = document.getElementById('send-button');
            sendButton.disabled = true;
            
            // NOTE: Don't add user message to history yet - it goes in current_message
            // The conversation_history should only contain PREVIOUS messages
            const config = getConfiguration();
            config.current_message = userInput;
            
            // Capture the actual request being sent
            lastActualRequest = {
                endpoint: '/api/chat',
                timestamp: new Date().toISOString(),
                payload: JSON.parse(JSON.stringify(config)),  // Deep copy
                note: 'This is the ACTUAL request sent to the server'
            };
            
            try {
                const response = await fetch('/api/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(config)
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    // Get the assistant's response content
                    let assistantContent = '';
                    if (data.final_content) {
                        assistantContent = data.final_content;
                    } else if (data.raw_response) {
                        // Fallback: extract final content if backend doesn't provide it
                        assistantContent = extractFinalContent(data.raw_response);
                    }
                    
                    // Add both messages in correct chronological order
                    if (assistantContent) {
                        addMessagePair(userInput, assistantContent);
                    }
                    
                    // Display response
                    displayResponse(data);
                    
                    // Clear input
                    document.getElementById('user-input').value = '';
                } else {
                    alert('Error: ' + data.error);
                }
            } catch (error) {
                alert('Failed to send message: ' + error.message);
            } finally {
                sendButton.disabled = false;
            }
        }
        
        // Send streaming message
        async function sendStreamingMessage() {
            const userInput = document.getElementById('user-input').value;
            if (!userInput.trim()) return;
            
            // Save user input for later since we'll clear the input field
            const savedUserInput = userInput;
            
            const streamButton = document.getElementById('stream-button');
            streamButton.disabled = true;
            document.getElementById('streaming-indicator').style.display = 'inline-block';
            document.getElementById('parsing-state').style.display = 'block';
            
            // Clear previous response
            document.getElementById('raw-response').textContent = '';
            document.querySelectorAll('#response-channels > div').forEach(div => {
                div.style.display = 'none';
                div.querySelector('div').textContent = '';
            });
            document.getElementById('tool-calls').style.display = 'none';
            document.querySelector('.tool-calls-list').innerHTML = '';
            
            const config = getConfiguration();
            config.current_message = userInput;
            
            // Use fetch with ReadableStream instead of EventSource
            try {
                const response = await fetch('/api/stream', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(config)
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                let fullResponse = '';
                
                while (true) {
                    const {done, value} = await reader.read();
                    if (done) break;
                    
                    buffer += decoder.decode(value, {stream: true});
                    const lines = buffer.split('\n');
                    buffer = lines.pop() || '';
                    
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const dataStr = line.slice(6);
                            if (dataStr.trim()) {
                                try {
                                    const data = JSON.parse(dataStr);
                                    handleStreamData(data, fullResponse, savedUserInput);
                                    if (data.text) {
                                        fullResponse += data.text;
                                    }
                                } catch (e) {
                                    console.error('Error parsing SSE data:', e);
                                }
                            }
                        }
                    }
                }
                
                // Clear input immediately for better UX
                document.getElementById('user-input').value = '';
                
            } catch (error) {
                alert('Streaming error: ' + error.message);
            } finally {
                streamButton.disabled = false;
                document.getElementById('streaming-indicator').style.display = 'none';
            }
        }
        
        function handleStreamData(data, fullResponse, savedUserInput) {
            if (data.error) {
                alert('Error: ' + data.error);
                return;
            }
            
            if (data.done) {
                // Get the assistant's response content
                let assistantContent = '';
                if (data.final_content) {
                    assistantContent = data.final_content;
                } else if (fullResponse) {
                    // Fallback: extract final content
                    assistantContent = extractFinalContent(fullResponse);
                }
                
                // Add both messages in correct chronological order
                if (savedUserInput && assistantContent) {
                    addMessagePair(savedUserInput, assistantContent);
                }
                
                // Handle parsed messages
                if (data.parsed_messages) {
                    displayParsedMessages(data.parsed_messages);
                }
                
                // Display tool calls if present
                if (data.tool_calls && data.tool_calls.length > 0) {
                    const toolCallsDiv = document.getElementById('tool-calls');
                    const toolCallsList = toolCallsDiv.querySelector('.tool-calls-list');
                    
                    toolCallsDiv.style.display = 'block';
                    toolCallsList.innerHTML = '';
                    
                    data.tool_calls.forEach((toolCall, index) => {
                        const toolDiv = document.createElement('div');
                        toolDiv.className = 'tool-call-item';
                        
                        toolDiv.innerHTML = `
                            <div class="tool-call-header">Tool Call ${index + 1}: ${toolCall.tool}</div>
                            <div class="tool-params">
                                <strong>Parameters:</strong><br>
                                ${JSON.stringify(toolCall.params, null, 2)}
                            </div>
                            <div class="tool-result">
                                <strong>Result:</strong><br>
                                ${JSON.stringify(toolCall.result, null, 2)}
                            </div>
                        `;
                        
                        toolCallsList.appendChild(toolDiv);
                    });
                }
                
                // Update conversation display
                updateConversationDisplay();
                
                document.getElementById('parsing-state').style.display = 'none';
                return;
            }
            
            // Handle tool execution notification
            if (data.tool_executed) {
                const toolCallsDiv = document.getElementById('tool-calls');
                const toolCallsList = toolCallsDiv.querySelector('.tool-calls-list');
                
                toolCallsDiv.style.display = 'block';
                
                const toolDiv = document.createElement('div');
                toolDiv.className = 'tool-call-item';
                
                toolDiv.innerHTML = `
                    <div class="tool-call-header">Executing: ${data.tool_executed.tool}</div>
                    <div class="tool-params">
                        <strong>Parameters:</strong><br>
                        ${JSON.stringify(data.tool_executed.params, null, 2)}
                    </div>
                    <div class="tool-result">
                        <strong>Result:</strong><br>
                        ${JSON.stringify(data.tool_executed.result, null, 2)}
                    </div>
                `;
                
                toolCallsList.appendChild(toolDiv);
                return;
            }
            
            // Handle continuation notification
            if (data.continuing_after_tools) {
                // Silently continue - no need to show this status message
                return;
            }
            
            // Update parsing state
            if (data.current_role) {
                document.getElementById('current-role').textContent = data.current_role;
            }
            if (data.current_channel !== undefined) {
                document.getElementById('current-channel').textContent = data.current_channel || 'none';
            }
            if (data.current_recipient !== undefined) {
                document.getElementById('current-recipient').textContent = data.current_recipient || 'none';
            }
            if (data.current_content_type !== undefined) {
                document.getElementById('current-content-type').textContent = data.current_content_type || 'none';
            }
            
            // Update raw response
            if (data.accumulated) {
                document.getElementById('raw-response').textContent = data.accumulated;
            }
            
            // Update channel displays
            if (data.current_channel && data.current_content) {
                const channelDiv = document.getElementById(`${data.current_channel}-channel`);
                if (channelDiv) {
                    channelDiv.style.display = 'block';
                    channelDiv.querySelector('div').textContent = data.current_content;
                }
            }
        }
        
        function displayParsedMessages(messages) {
            // Group messages by channel
            const channels = {};
            messages.forEach(msg => {
                const channel = msg.channel || 'default';
                if (!channels[channel]) {
                    channels[channel] = [];
                }
                channels[channel].push(msg.content);
            });
            
            // Display each channel
            Object.entries(channels).forEach(([channel, contents]) => {
                const channelDiv = document.getElementById(`${channel}-channel`);
                if (channelDiv) {
                    channelDiv.style.display = 'block';
                    channelDiv.querySelector('div').textContent = contents.join('\n');
                }
            });
        }
        
        // Display response
        function displayResponse(data) {
            // Show raw response
            document.getElementById('raw-response').textContent = data.raw_response;
            
            // Clear channels
            document.querySelectorAll('#response-channels > div').forEach(div => {
                div.style.display = 'none';
                div.querySelector('div').textContent = '';
            });
            
            // Display parsed messages by channel
            if (data.parsed_messages) {
                Object.entries(data.parsed_messages).forEach(([channel, messages]) => {
                    const channelDiv = document.getElementById(`${channel}-channel`);
                    if (channelDiv) {
                        channelDiv.style.display = 'block';
                        const contentDiv = channelDiv.querySelector('div');
                        contentDiv.textContent = messages.map(m => m.content).join('\n');
                    }
                });
            }
            
            // Display tool calls if present
            if (data.tool_calls && data.tool_calls.length > 0) {
                const toolCallsDiv = document.getElementById('tool-calls');
                const toolCallsList = toolCallsDiv.querySelector('.tool-calls-list');
                
                toolCallsDiv.style.display = 'block';
                toolCallsList.innerHTML = '';
                
                data.tool_calls.forEach((toolCall, index) => {
                    const toolDiv = document.createElement('div');
                    toolDiv.className = 'tool-call-item';
                    
                    toolDiv.innerHTML = `
                        <div class="tool-call-header">Tool Call ${index + 1}: ${toolCall.tool}</div>
                        <div class="tool-params">
                            <strong>Parameters:</strong><br>
                            ${JSON.stringify(toolCall.params, null, 2)}
                        </div>
                        <div class="tool-result">
                            <strong>Result:</strong><br>
                            ${JSON.stringify(toolCall.result, null, 2)}
                        </div>
                    `;
                    
                    toolCallsList.appendChild(toolDiv);
                });
            } else {
                document.getElementById('tool-calls').style.display = 'none';
            }
            
            // Update conversation display
            updateConversationDisplay();
        }
        
        // Update conversation display
        function updateConversationDisplay() {
            const historyDiv = document.getElementById('conversation-history');
            historyDiv.innerHTML = '';
            
            conversationHistory.forEach(msg => {
                const messageDiv = document.createElement('div');
                messageDiv.className = 'message';
                
                // Handle different message structures
                let content = '';
                if (msg.role === 'user') {
                    content = msg.content;
                } else if (msg.role === 'assistant') {
                    // Assistant messages might have rawContent or parsedMessages
                    if (msg.rawContent) {
                        // Extract final channel content if available
                        if (msg.parsedMessages && msg.parsedMessages.final) {
                            content = msg.parsedMessages.final.map(m => m.content).join('\n');
                        } else {
                            // Try to extract final content from raw response
                            const finalMatch = msg.rawContent.match(/<\|channel\|>final<\|message\|>(.*?)(?:<\|return\|>|<\|end\|>|$)/s);
                            if (finalMatch) {
                                content = finalMatch[1].trim();
                            } else {
                                content = '[Processing...]';
                            }
                        }
                    } else {
                        content = msg.content || '[No content]';
                    }
                }
                
                messageDiv.innerHTML = `
                    <div class="message-header">${msg.role.toUpperCase()}</div>
                    <div class="message-content">${escapeHtml(content)}</div>
                `;
                historyDiv.appendChild(messageDiv);
            });
        }
        
        // Clear conversation
        function clearConversation() {
            conversationHistory = [];
            updateConversationDisplay();
            updatePrompt();
        }
        
        // Show full prompt modal
        async function showFullPrompt() {
            const userInput = document.getElementById('user-input').value;
            const config = getConfiguration();
            config.current_message = userInput;
            
            // Add current timestamp
            const timestamp = new Date().toISOString();
            
            // Build the full request that would be sent
            const fullRequest = {
                endpoint: '/api/chat',
                timestamp: timestamp,
                payload: config,
                conversation_history_details: conversationHistory.map((msg, idx) => ({
                    index: idx,
                    role: msg.role,
                    has_content: !!msg.content,
                    has_rawContent: !!msg.rawContent,
                    has_parsedMessages: !!msg.parsedMessages,
                    content_preview: msg.content ? msg.content.substring(0, 100) + '...' : 
                                    (msg.rawContent ? msg.rawContent.substring(0, 100) + '...' : 'N/A')
                }))
            };
            
            // Show what prompt would be rendered
            try {
                const response = await fetch('/api/render_prompt', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(config)
                });
                
                if (response.ok) {
                    const data = await response.json();
                    fullRequest.rendered_prompt = data.prompt;
                    fullRequest.token_count = data.token_count;
                }
            } catch (e) {
                fullRequest.render_error = e.toString();
            }
            
            // Display in modal
            document.getElementById('prompt-json-display').textContent = JSON.stringify(fullRequest, null, 2);
            document.getElementById('promptModal').style.display = 'block';
        }
        
        // Close modal
        function closeModal() {
            document.getElementById('promptModal').style.display = 'none';
        }
        
        // Close modal when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('promptModal');
            if (event.target == modal) {
                modal.style.display = 'none';
            }
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            // Update prompt when configuration changes
            document.querySelectorAll('input, textarea, select').forEach(element => {
                element.addEventListener('change', updatePrompt);
            });
            
            // Initial prompt render
            updatePrompt();
            
            // Check server on load
            checkServer();
        });
    </script>
</body>
</html>