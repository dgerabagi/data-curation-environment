<!--
  File: flattened_repo.md
  Source Directory: C:\Projects\DCE
  Date Generated: 2025-08-25T15:56:21.274Z
  ---
  Total Files: 220
  Total Lines: 20292
  Total Characters: 980649
  Approx. Tokens: 245243
-->

<!-- Top 10 Files by Token Count -->
1. src\Artifacts\A54. starry-night-readme.md (25577 tokens)
2. src\Artifacts\A6. DCE - Initial Scaffolding Deployment Script.md (10922 tokens)
3. The-Creator-AI-main\src\common\constants\agents.constants.ts (9159 tokens)
4. src\client\views\parallel-copilot.view\view.tsx (6063 tokens)
5. src\client\views\context-chooser.view\view.tsx (5562 tokens)
6. src\Artifacts\A0. DCE Master Artifact List.md (5057 tokens)
7. src\client\components\tree-view\TreeView.tsx (4508 tokens)
8. src\Artifacts\A11. DCE - Regression Case Studies.md (4259 tokens)
9. src\backend\services\prompt.service.ts (4134 tokens)
10. src\client\views\context-chooser.view\view.scss (3638 tokens)

<!-- Full File List -->
1. .gitignore - Lines: 10 - Chars: 128 - Tokens: 32
2. .vscodeignore - Lines: 11 - Chars: 356 - Tokens: 89
3. bootstrap-flattener.js - Lines: 185 - Chars: 5834 - Tokens: 1459
4. LICENSE - Lines: 21 - Chars: 1090 - Tokens: 273
5. package.json - Lines: 139 - Chars: 4583 - Tokens: 1146
6. public\copilot.svg - Lines: 5 - Chars: 445 - Tokens: 112
7. public\spiral.svg - Lines: 8 - Chars: 459 - Tokens: 115
8. src\Artifacts\A0. DCE Master Artifact List.md - Lines: 274 - Chars: 20225 - Tokens: 5057
9. src\Artifacts\A1. DCE - Project Vision and Goals.md - Lines: 41 - Chars: 3995 - Tokens: 999
10. src\Artifacts\A10. DCE - Metadata and Statistics Display.md - Lines: 53 - Chars: 7286 - Tokens: 1822
11. src\Artifacts\A11. DCE - Regression Case Studies.md - Lines: 182 - Chars: 17035 - Tokens: 4259
12. src\Artifacts\A12. DCE - Logging and Debugging Guide.md - Lines: 80 - Chars: 5710 - Tokens: 1428
13. src\Artifacts\A13. DCE - Phase 1 - Right-Click Context Menu.md - Lines: 45 - Chars: 6068 - Tokens: 1517
14. src\Artifacts\A14. DCE - Ongoing Development Issues.md - Lines: 64 - Chars: 4324 - Tokens: 1081
15. src\Artifacts\A149. Local LLM Integration Plan.md - Lines: 99 - Chars: 6208 - Tokens: 1552
16. src\Artifacts\A15. DCE - Phase 1 - Multi-Select & Sorting Feature Plan.md - Lines: 43 - Chars: 7263 - Tokens: 1816
17. src\Artifacts\A16. DCE - Phase 1 - UI & UX Refinements Plan.md - Lines: 50 - Chars: 6421 - Tokens: 1606
18. src\Artifacts\A17. DCE - Phase 1 - Advanced Tree View Features.md - Lines: 47 - Chars: 3888 - Tokens: 972
19. src\Artifacts\A18. DCE - Phase 1 - Active File Sync Feature Plan.md - Lines: 46 - Chars: 4548 - Tokens: 1137
20. src\Artifacts\A189. Number Formatting Reference Guide.md - Lines: 118 - Chars: 4938 - Tokens: 1235
21. src\Artifacts\A19. DCE - Phase 1 - Double-Click & Quick-Remove Feature Plan.md - Lines: 42 - Chars: 4603 - Tokens: 1151
22. src\Artifacts\A2. DCE - Phase 1 - Context Chooser - Requirements & Design.md - Lines: 20 - Chars: 3329 - Tokens: 833
23. src\Artifacts\A20. DCE - Phase 1 - Advanced UX & Automation Plan.md - Lines: 47 - Chars: 7268 - Tokens: 1817
24. src\Artifacts\A21. DCE - Phase 1 - Feature Drift Analysis vs. VS Code Explorer.md - Lines: 48 - Chars: 7385 - Tokens: 1847
25. src\Artifacts\A22. DCE - Phase 1 - Search & Filter Feature Plan.md - Lines: 58 - Chars: 3663 - Tokens: 916
26. src\Artifacts\A23. DCE - Phase 1 - Advanced Interactions (Keyboard & Drag-Drop) Plan.md - Lines: 37 - Chars: 5504 - Tokens: 1376
27. src\Artifacts\A24. DCE - Selection Paradigm Terminology.md - Lines: 57 - Chars: 3330 - Tokens: 833
28. src\Artifacts\A25. DCE - Phase 1 - Git & Problems Integration Plan.md - Lines: 61 - Chars: 5871 - Tokens: 1468
29. src\Artifacts\A26. DCE - Phase 1 - File System Traversal & Caching Strategy.md - Lines: 46 - Chars: 4009 - Tokens: 1003
30. src\Artifacts\A27. DCE - Phase 1 - Undo-Redo Feature Plan.md - Lines: 50 - Chars: 4903 - Tokens: 1226
31. src\Artifacts\A28. DCE - Packaging and Distribution Guide.md - Lines: 96 - Chars: 4075 - Tokens: 1019
32. src\Artifacts\A29. DCE - Phase 1 - Binary and Image File Handling Strategy.md - Lines: 81 - Chars: 4217 - Tokens: 1055
33. src\Artifacts\A3. DCE - Technical Scaffolding Plan.md - Lines: 55 - Chars: 3684 - Tokens: 921
34. src\Artifacts\A30. DCE - Phase 1 - PDF Handling and Virtualization Strategy.md - Lines: 44 - Chars: 4431 - Tokens: 1108
35. src\Artifacts\A31. DCE - Phase 2 - Multimodal Content Extraction (PDF Images).md - Lines: 44 - Chars: 4035 - Tokens: 1009
36. src\Artifacts\A32. DCE - Phase 1 - Excel and CSV Handling Strategy.md - Lines: 44 - Chars: 4295 - Tokens: 1074
37. src\Artifacts\A33. DCE - Phase 1 - Copy-Paste Feature Plan.md - Lines: 42 - Chars: 4456 - Tokens: 1114
38. src\Artifacts\A34. DCE - Phase 2 - Parallel Co-Pilot Panel - Vision & Requirements.md - Lines: 44 - Chars: 6403 - Tokens: 1601
39. src\Artifacts\A35. DCE - Phase 2 - UI Mockups and Flow.md - Lines: 81 - Chars: 5989 - Tokens: 1498
40. src\Artifacts\A36. DCE - Phase 2 - Technical Implementation Plan.md - Lines: 77 - Chars: 4173 - Tokens: 1044
41. src\Artifacts\A37. DCE - Phase 2 - Cycle Navigator & Knowledge Graph - Vision.md - Lines: 28 - Chars: 3242 - Tokens: 811
42. src\Artifacts\A38. DCE - Phase 2 - Cycle Navigator - UI Mockup.md - Lines: 69 - Chars: 4621 - Tokens: 1156
43. src\Artifacts\A39. DCE - Phase 2 - Cycle Navigator - Technical Plan.md - Lines: 84 - Chars: 4595 - Tokens: 1149
44. src\Artifacts\A4. DCE - Analysis of The-Creator-AI Repo.md - Lines: 56 - Chars: 5722 - Tokens: 1431
45. src\Artifacts\A40. DCE - Phase 2 - Parallel Co-Pilot - Target File Structure.md - Lines: 66 - Chars: 3659 - Tokens: 915
46. src\Artifacts\A40.1. DCE - Phase 2 - Competitive Analysis & Feature Ideas.md - Lines: 43 - Chars: 4784 - Tokens: 1196
47. src\Artifacts\A41. DCE - Phase 2 - API Key Management - Feature Plan.md - Lines: 47 - Chars: 4542 - Tokens: 1136
48. src\Artifacts\A41.1. DCE - Phase 2 - Advanced Features & Integrations Plan.md - Lines: 44 - Chars: 3946 - Tokens: 987
49. src\Artifacts\A41.2. DCE - Phase 2 - Feature Ideation & Competitive Analysis.md - Lines: 40 - Chars: 4566 - Tokens: 1142
50. src\Artifacts\A42. DCE - Phase 2 - Initial Scaffolding Deployment Script.md - Lines: 246 - Chars: 8264 - Tokens: 2066
51. src\Artifacts\A43. DCE - Phase 2 - Implementation Roadmap.md - Lines: 69 - Chars: 4694 - Tokens: 1174
52. src\Artifacts\A44. DCE - Phase 1 - Word Document Handling Strategy.md - Lines: 45 - Chars: 4626 - Tokens: 1157
53. src\Artifacts\A45. DCE - Phase 2 - Pop-out Co-Pilot Window - Feature Plan.md - Lines: 49 - Chars: 4156 - Tokens: 1039
54. src\Artifacts\A46. DCE - Phase 2 - Paste and Parse Response - Feature Plan.md - Lines: 38 - Chars: 3587 - Tokens: 897
55. src\Artifacts\A47. DCE - Phase 2 - Prompt Amalgamation Feature Plan.md - Lines: 42 - Chars: 3499 - Tokens: 875
56. src\Artifacts\A48. DCE - Phase 2 - Advanced Syntax Highlighting Plan.md - Lines: 49 - Chars: 4044 - Tokens: 1011
57. src\Artifacts\A49. DCE - Phase 2 - File Association & Diffing Plan.md - Lines: 44 - Chars: 4452 - Tokens: 1113
58. src\Artifacts\A5. DCE - Target File Structure.md - Lines: 67 - Chars: 1977 - Tokens: 495
59. src\Artifacts\A50. DCE - Phase 2 - UI Component Plan (Resizable Panes & Inner Editors).md - Lines: 51 - Chars: 5128 - Tokens: 1282
60. src\Artifacts\A51. DCE - A-B-C Testing Strategy for UI Bugs.md - Lines: 81 - Chars: 5490 - Tokens: 1373
61. src\Artifacts\A52. DCE - Interaction Schema Refinement.md - Lines: 61 - Chars: 3735 - Tokens: 934
62. src\Artifacts\A53. DCE - Phase 2 - Token Count and Similarity Analysis.md - Lines: 50 - Chars: 3971 - Tokens: 993
63. src\Artifacts\A54. starry-night-readme.md - Lines: 1824 - Chars: 102305 - Tokens: 25577
64. src\Artifacts\A55. DCE - FSService Refactoring Plan.md - Lines: 77 - Chars: 4022 - Tokens: 1006
65. src\Artifacts\A56. DCE - Phase 2 - Advanced Diff Viewer Plan.md - Lines: 47 - Chars: 5687 - Tokens: 1422
66. src\Artifacts\A57. DCE - Phase 2 - Cycle Management Plan.md - Lines: 44 - Chars: 3625 - Tokens: 907
67. src\Artifacts\A58. DCE - WinMerge Source Code Analysis.md - Lines: 56 - Chars: 5322 - Tokens: 1331
68. src\Artifacts\A6. DCE - Initial Scaffolding Deployment Script.md - Lines: 1282 - Chars: 43686 - Tokens: 10922
69. src\Artifacts\A7. DCE - Development and Testing Guide.md - Lines: 47 - Chars: 3075 - Tokens: 769
70. src\Artifacts\A8. DCE - Phase 1 - Selection Sets Feature Plan.md - Lines: 65 - Chars: 6043 - Tokens: 1511
71. src\Artifacts\A9. DCE - GitHub Repository Setup Guide.md - Lines: 71 - Chars: 3094 - Tokens: 774
72. src\backend\commands\commands.ts - Lines: 97 - Chars: 4211 - Tokens: 1053
73. src\backend\commands\register-commands.ts - Lines: 11 - Chars: 456 - Tokens: 114
74. src\backend\services\action.service.ts - Lines: 60 - Chars: 1831 - Tokens: 458
75. src\backend\services\content-extraction.service.ts - Lines: 148 - Chars: 7681 - Tokens: 1921
76. src\backend\services\file-operation.service.ts - Lines: 256 - Chars: 12194 - Tokens: 3049
77. src\backend\services\file-tree.service.ts - Lines: 212 - Chars: 11447 - Tokens: 2862
78. src\backend\services\flattener.service.ts - Lines: 210 - Chars: 11271 - Tokens: 2818
79. src\backend\services\highlighting.service.ts - Lines: 58 - Chars: 2920 - Tokens: 730
80. src\backend\services\history.service.ts - Lines: 129 - Chars: 5675 - Tokens: 1419
81. src\backend\services\logger.service.ts - Lines: 38 - Chars: 1115 - Tokens: 279
82. src\backend\services\prompt.service.ts - Lines: 151 - Chars: 16535 - Tokens: 4134
83. src\backend\services\selection.service.ts - Lines: 133 - Chars: 5411 - Tokens: 1353
84. src\backend\services\services.ts - Lines: 35 - Chars: 1597 - Tokens: 400
85. src\backend\types\git.ts - Lines: 79 - Chars: 1944 - Tokens: 486
86. src\client\components\Checkbox.tsx - Lines: 25 - Chars: 814 - Tokens: 204
87. src\client\components\ContextMenu.tsx - Lines: 67 - Chars: 3083 - Tokens: 771
88. src\client\components\DiffViewer.tsx - Lines: 224 - Chars: 11386 - Tokens: 2847
89. src\client\components\file-tree\FileTree.tsx - Lines: 262 - Chars: 11897 - Tokens: 2975
90. src\client\components\file-tree\FileTree.utils.ts - Lines: 189 - Chars: 7284 - Tokens: 1821
91. src\client\components\LocationPane.tsx - Lines: 28 - Chars: 776 - Tokens: 194
92. src\client\components\SelectedFilesView.tsx - Lines: 276 - Chars: 13099 - Tokens: 3275
93. src\client\components\tree-view\TreeView.tsx - Lines: 394 - Chars: 18029 - Tokens: 4508
94. src\client\components\tree-view\TreeView.utils.ts - Lines: 13 - Chars: 333 - Tokens: 84
95. src\client\utils\logger.ts - Lines: 19 - Chars: 762 - Tokens: 191
96. src\client\utils\response-parser.ts - Lines: 81 - Chars: 3048 - Tokens: 762
97. src\client\views\context-chooser.view\index.ts - Lines: 7 - Chars: 184 - Tokens: 46
98. src\client\views\context-chooser.view\on-message.ts - Lines: 53 - Chars: 4913 - Tokens: 1229
99. src\client\views\context-chooser.view\view.scss - Lines: 591 - Chars: 14549 - Tokens: 3638
100. src\client\views\context-chooser.view\view.tsx - Lines: 435 - Chars: 22245 - Tokens: 5562
101. src\client\views\index.ts - Lines: 39 - Chars: 1890 - Tokens: 473
102. src\client\views\parallel-copilot.view\index.ts - Lines: 9 - Chars: 238 - Tokens: 60
103. src\client\views\parallel-copilot.view\on-message.ts - Lines: 51 - Chars: 2375 - Tokens: 594
104. src\client\views\parallel-copilot.view\TestPane1.tsx - Lines: 43 - Chars: 1890 - Tokens: 473
105. src\client\views\parallel-copilot.view\TestPane2.tsx - Lines: 71 - Chars: 3447 - Tokens: 862
106. src\client\views\parallel-copilot.view\TestPane3.tsx - Lines: 81 - Chars: 3827 - Tokens: 957
107. src\client\views\parallel-copilot.view\view.scss - Lines: 506 - Chars: 11806 - Tokens: 2952
108. src\client\views\parallel-copilot.view\view.tsx - Lines: 487 - Chars: 24251 - Tokens: 6063
109. src\common\ipc\channels.enum.ts - Lines: 67 - Chars: 3354 - Tokens: 839
110. src\common\ipc\channels.type.ts - Lines: 61 - Chars: 4756 - Tokens: 1189
111. src\common\ipc\client-ipc.ts - Lines: 44 - Chars: 1590 - Tokens: 398
112. src\common\ipc\get-vscode-api.ts - Lines: 12 - Chars: 239 - Tokens: 60
113. src\common\ipc\server-ipc.ts - Lines: 42 - Chars: 1562 - Tokens: 391
114. src\common\types\file-node.ts - Lines: 16 - Chars: 567 - Tokens: 142
115. src\common\types\pcpp.types.ts - Lines: 36 - Chars: 914 - Tokens: 229
116. src\common\types\vscode-webview.d.ts - Lines: 15 - Chars: 449 - Tokens: 113
117. src\common\utils\formatting.ts - Lines: 95 - Chars: 3251 - Tokens: 813
118. src\common\utils\view-html.ts - Lines: 29 - Chars: 1117 - Tokens: 280
119. src\common\view-types.ts - Lines: 8 - Chars: 182 - Tokens: 46
120. src\extension.ts - Lines: 121 - Chars: 5044 - Tokens: 1261
121. The-Creator-AI-main\.eslintrc.json - Lines: 30 - Chars: 662 - Tokens: 166
122. The-Creator-AI-main\.gitignore - Lines: 8 - Chars: 75 - Tokens: 19
123. The-Creator-AI-main\.vscode-test.mjs - Lines: 6 - Chars: 117 - Tokens: 30
124. The-Creator-AI-main\.vscodeignore - Lines: 15 - Chars: 192 - Tokens: 48
125. The-Creator-AI-main\CHANGELOG.md - Lines: 9 - Chars: 241 - Tokens: 61
126. The-Creator-AI-main\LICENSE - Lines: 22 - Chars: 1069 - Tokens: 268
127. The-Creator-AI-main\Notes.md - Lines: 2 - Chars: 67 - Tokens: 17
128. The-Creator-AI-main\package.json - Lines: 181 - Chars: 5082 - Tokens: 1271
129. The-Creator-AI-main\postcss.config.js - Lines: 7 - Chars: 82 - Tokens: 21
130. The-Creator-AI-main\public\main.css - Lines: 40 - Chars: 559 - Tokens: 140
131. The-Creator-AI-main\public\reset.css - Lines: 30 - Chars: 233 - Tokens: 59
132. The-Creator-AI-main\public\spiral.svg - Lines: 17 - Chars: 579 - Tokens: 145
133. The-Creator-AI-main\public\vscode.css - Lines: 91 - Chars: 1977 - Tokens: 495
134. The-Creator-AI-main\README.md - Lines: 44 - Chars: 1614 - Tokens: 404
135. The-Creator-AI-main\src\backend\commands\commands.ts - Lines: 138 - Chars: 4691 - Tokens: 1173
136. The-Creator-AI-main\src\backend\commands\register-commands.ts - Lines: 11 - Chars: 382 - Tokens: 96
137. The-Creator-AI-main\src\backend\repositories\chat.respository.ts - Lines: 142 - Chars: 3906 - Tokens: 977
138. The-Creator-AI-main\src\backend\repositories\persistent-store.repository.ts - Lines: 28 - Chars: 897 - Tokens: 225
139. The-Creator-AI-main\src\backend\repositories\settings.repository.ts - Lines: 62 - Chars: 1694 - Tokens: 424
140. The-Creator-AI-main\src\backend\services\code.service.ts - Lines: 344 - Chars: 10472 - Tokens: 2618
141. The-Creator-AI-main\src\backend\services\fs.service.ts - Lines: 323 - Chars: 9979 - Tokens: 2495
142. The-Creator-AI-main\src\backend\services\git.service.ts - Lines: 41 - Chars: 1411 - Tokens: 353
143. The-Creator-AI-main\src\backend\services\llm.service.ts - Lines: 264 - Chars: 8622 - Tokens: 2156
144. The-Creator-AI-main\src\backend\services\logger.service.ts - Lines: 55 - Chars: 1371 - Tokens: 343
145. The-Creator-AI-main\src\backend\services\message.service.ts - Lines: 58 - Chars: 1661 - Tokens: 416
146. The-Creator-AI-main\src\backend\services\plan-exim.service.ts - Lines: 114 - Chars: 4560 - Tokens: 1140
147. The-Creator-AI-main\src\backend\services\services.ts - Lines: 67 - Chars: 1964 - Tokens: 491
148. The-Creator-AI-main\src\backend\services\task-queue.service.ts - Lines: 128 - Chars: 3921 - Tokens: 981
149. The-Creator-AI-main\src\backend\types\llm-service.enum.ts - Lines: 6 - Chars: 94 - Tokens: 24
150. The-Creator-AI-main\src\backend\types\storage-keys.enum.ts - Lines: 6 - Chars: 202 - Tokens: 51
151. The-Creator-AI-main\src\backend\utils\handleActiveTabChange.ts - Lines: 26 - Chars: 775 - Tokens: 194
152. The-Creator-AI-main\src\backend\utils\mergeOpenEditorsWithSelectedFiles.ts - Lines: 33 - Chars: 952 - Tokens: 238
153. The-Creator-AI-main\src\backend\utils\remoteSetChangePlanViewState.ts - Lines: 26 - Chars: 989 - Tokens: 248
154. The-Creator-AI-main\src\client\components\AutoResizingTextarea.tsx - Lines: 49 - Chars: 2000 - Tokens: 500
155. The-Creator-AI-main\src\client\components\Checkbox.tsx - Lines: 26 - Chars: 815 - Tokens: 204
156. The-Creator-AI-main\src\client\components\ErrorBoundary.tsx - Lines: 44 - Chars: 1220 - Tokens: 305
157. The-Creator-AI-main\src\client\components\file-tree\FileTree.scss - Lines: 9 - Chars: 157 - Tokens: 40
158. The-Creator-AI-main\src\client\components\file-tree\FileTree.tsx - Lines: 137 - Chars: 4398 - Tokens: 1100
159. The-Creator-AI-main\src\client\components\file-tree\FileTree.utils.ts - Lines: 68 - Chars: 2214 - Tokens: 554
160. The-Creator-AI-main\src\client\components\Modal.tsx - Lines: 91 - Chars: 2649 - Tokens: 663
161. The-Creator-AI-main\src\client\components\ProgressSteps.tsx - Lines: 59 - Chars: 1648 - Tokens: 412
162. The-Creator-AI-main\src\client\components\tree-view\TreeView.tsx - Lines: 84 - Chars: 2738 - Tokens: 685
163. The-Creator-AI-main\src\client\components\tree-view\TreeView.utils.ts - Lines: 14 - Chars: 316 - Tokens: 79
164. The-Creator-AI-main\src\client\modules\api-keys-management.module\ApiKeysManagement.tsx - Lines: 150 - Chars: 6318 - Tokens: 1580
165. The-Creator-AI-main\src\client\modules\commit.module\Commit.tsx - Lines: 63 - Chars: 3218 - Tokens: 805
166. The-Creator-AI-main\src\client\modules\context.module\Context.tsx - Lines: 87 - Chars: 4052 - Tokens: 1013
167. The-Creator-AI-main\src\client\modules\plan.module\components\file-card.tsx - Lines: 93 - Chars: 4112 - Tokens: 1028
168. The-Creator-AI-main\src\client\modules\plan.module\formatted-plan-preview.tsx - Lines: 172 - Chars: 6480 - Tokens: 1620
169. The-Creator-AI-main\src\client\modules\plan.module\plan-input-box.tsx - Lines: 139 - Chars: 6410 - Tokens: 1603
170. The-Creator-AI-main\src\client\modules\plan.module\Plan.tsx - Lines: 55 - Chars: 1749 - Tokens: 438
171. The-Creator-AI-main\src\client\store\store.ts - Lines: 20 - Chars: 479 - Tokens: 120
172. The-Creator-AI-main\src\client\store\useStore.ts - Lines: 26 - Chars: 627 - Tokens: 157
173. The-Creator-AI-main\src\client\views\change-plan.view\index.ts - Lines: 9 - Chars: 221 - Tokens: 56
174. The-Creator-AI-main\src\client\views\change-plan.view\logic\commitStagedChanges.ts - Lines: 11 - Chars: 385 - Tokens: 97
175. The-Creator-AI-main\src\client\views\change-plan.view\logic\getSelectedFiles.ts - Lines: 37 - Chars: 1294 - Tokens: 324
176. The-Creator-AI-main\src\client\views\change-plan.view\logic\handleCommitMessageSuggestions.ts - Lines: 15 - Chars: 580 - Tokens: 145
177. The-Creator-AI-main\src\client\views\change-plan.view\logic\handleFileClick.ts - Lines: 24 - Chars: 665 - Tokens: 167
178. The-Creator-AI-main\src\client\views\change-plan.view\logic\handleSubmitPlanRequest.ts - Lines: 79 - Chars: 2463 - Tokens: 616
179. The-Creator-AI-main\src\client\views\change-plan.view\logic\requestCommitMessageSuggestions.ts - Lines: 15 - Chars: 511 - Tokens: 128
180. The-Creator-AI-main\src\client\views\change-plan.view\logic\setupChannelHandlers.ts - Lines: 102 - Chars: 3069 - Tokens: 768
181. The-Creator-AI-main\src\client\views\change-plan.view\logic\updateOrCreateChangePlan.ts - Lines: 51 - Chars: 1633 - Tokens: 409
182. The-Creator-AI-main\src\client\views\change-plan.view\on-mesage.ts - Lines: 271 - Chars: 9696 - Tokens: 2424
183. The-Creator-AI-main\src\client\views\change-plan.view\store\change-plan-view.initial-state.ts - Lines: 17 - Chars: 453 - Tokens: 114
184. The-Creator-AI-main\src\client\views\change-plan.view\store\change-plan-view.logic.ts - Lines: 54 - Chars: 1617 - Tokens: 405
185. The-Creator-AI-main\src\client\views\change-plan.view\store\change-plan-view.state-type.ts - Lines: 34 - Chars: 843 - Tokens: 211
186. The-Creator-AI-main\src\client\views\change-plan.view\store\change-plan-view.store.ts - Lines: 18 - Chars: 672 - Tokens: 168
187. The-Creator-AI-main\src\client\views\change-plan.view\view.constants.ts - Lines: 6 - Chars: 134 - Tokens: 34
188. The-Creator-AI-main\src\client\views\change-plan.view\view.scss - Lines: 10 - Chars: 160 - Tokens: 40
189. The-Creator-AI-main\src\client\views\change-plan.view\view.tsx - Lines: 91 - Chars: 2823 - Tokens: 706
190. The-Creator-AI-main\src\client\views\chat.view\index.ts - Lines: 9 - Chars: 208 - Tokens: 52
191. The-Creator-AI-main\src\client\views\chat.view\on-mesage.ts - Lines: 50 - Chars: 1545 - Tokens: 387
192. The-Creator-AI-main\src\client\views\chat.view\view.scss - Lines: 10 - Chars: 160 - Tokens: 40
193. The-Creator-AI-main\src\client\views\chat.view\view.tsx - Lines: 71 - Chars: 2614 - Tokens: 654
194. The-Creator-AI-main\src\client\views\file-explorer.view\index.ts - Lines: 9 - Chars: 225 - Tokens: 57
195. The-Creator-AI-main\src\client\views\file-explorer.view\on-mesage.ts - Lines: 49 - Chars: 1773 - Tokens: 444
196. The-Creator-AI-main\src\client\views\file-explorer.view\view.scss - Lines: 10 - Chars: 160 - Tokens: 40
197. The-Creator-AI-main\src\client\views\file-explorer.view\view.tsx - Lines: 62 - Chars: 2265 - Tokens: 567
198. The-Creator-AI-main\src\client\views\index.ts - Lines: 54 - Chars: 1714 - Tokens: 429
199. The-Creator-AI-main\src\common\constants\agents.constants.ts - Lines: 837 - Chars: 36635 - Tokens: 9159
200. The-Creator-AI-main\src\common\firebase.ts - Lines: 22 - Chars: 874 - Tokens: 219
201. The-Creator-AI-main\src\common\ipc\channels.enum.ts - Lines: 37 - Chars: 1831 - Tokens: 458
202. The-Creator-AI-main\src\common\ipc\channels.type.ts - Lines: 125 - Chars: 3933 - Tokens: 984
203. The-Creator-AI-main\src\common\ipc\client-ipc.ts - Lines: 42 - Chars: 1338 - Tokens: 335
204. The-Creator-AI-main\src\common\ipc\get-vscode-api.ts - Lines: 12 - Chars: 239 - Tokens: 60
205. The-Creator-AI-main\src\common\ipc\server-ipc.ts - Lines: 44 - Chars: 1522 - Tokens: 381
206. The-Creator-AI-main\src\common\types\file-node.ts - Lines: 6 - Chars: 96 - Tokens: 24
207. The-Creator-AI-main\src\common\types\vscode-webview.d.ts - Lines: 49 - Chars: 1607 - Tokens: 402
208. The-Creator-AI-main\src\common\utils\firebaseLogger.ts - Lines: 43 - Chars: 1108 - Tokens: 277
209. The-Creator-AI-main\src\common\utils\key-path.ts - Lines: 43 - Chars: 1036 - Tokens: 259
210. The-Creator-AI-main\src\common\utils\parse-json.ts - Lines: 20 - Chars: 515 - Tokens: 129
211. The-Creator-AI-main\src\common\utils\view-html.ts - Lines: 35 - Chars: 1271 - Tokens: 318
212. The-Creator-AI-main\src\common\view-types.ts - Lines: 8 - Chars: 184 - Tokens: 46
213. The-Creator-AI-main\src\extension.ts - Lines: 24 - Chars: 623 - Tokens: 156
214. The-Creator-AI-main\src\test\extension.test.ts - Lines: 16 - Chars: 459 - Tokens: 115
215. The-Creator-AI-main\tailwind.config.js - Lines: 102 - Chars: 6814 - Tokens: 1704
216. The-Creator-AI-main\tsconfig.json - Lines: 31 - Chars: 814 - Tokens: 204
217. The-Creator-AI-main\vsc-extension-quickstart.md - Lines: 49 - Chars: 2893 - Tokens: 724
218. The-Creator-AI-main\webpack.config.js - Lines: 98 - Chars: 2795 - Tokens: 699
219. tsconfig.json - Lines: 27 - Chars: 632 - Tokens: 158
220. webpack.config.js - Lines: 103 - Chars: 2830 - Tokens: 708

<file path=".gitignore">
node_modules
package-lock.json
dist
out
*.vsix
.vscode-test/
.vscode/
The-Creator-AI-main/
prompt.md
.vscode/dce_cache/
</file>

<file path=".vscodeignore">
# This file tells the VS Code packaging tool which files to ignore.
# We are removing 'node_modules' because our external dependencies (like xlsx)
# need to be included in the final package to be available at runtime.
# The `vsce` tool is smart enough to only bundle production dependencies.

src
.gitignore
webpack.config.js
tsconfig.json
**/*.map
**/*.ts
</file>

<file path="bootstrap-flattener.js">
#!/usr/bin/env node
/**
 * bootstrap-flattener.js
 *
 * This script recursively finds all files in a given directory, ignoring specified
 * patterns, and concatenates them into a single output file with a metadata header.
 *
 * Updated on: Cycle 2
 * - Added comprehensive metadata header including:
 *   - Total file, line, character, and token counts.
 *   - Top 10 files by token count.
 *   - A full list of all processed files with their stats.
 * - Added a configurable `DEFAULT_IGNORE` set to exclude common unnecessary files
 *   and directories (e.g., node_modules, .git, package-lock.json).
 * - Logic inspired by `flattenv2.js` to provide more useful output.
 */

const fs = require('fs').promises;
const path = require('path');

const OUTPUT_FILENAME = 'flattened_repo.md';

// --- Configuration ---
// Files and directories to ignore. Uses simple string matching.
const DEFAULT_IGNORE = new Set([
  'node_modules',
  '.git',
  '.vscode',
  'dist',
  'out',
  'package-lock.json',
  '.DS_Store',
  '.npm',
  '.yarn',
  'flattened_repo.md',
  'prompt.md'
]);


/**
 * Recursively gets all file paths in a directory, respecting the ignore list.
 * @param {string} dirPath The directory to start from.
 * @param {Set<string>} ignoreSet The set of directory/file names to ignore.
 * @returns {Promise<string[]>} A promise that resolves to an array of file paths.
 */
async function getFilePaths(dirPath, ignoreSet) {
  let filePaths = [];
  const entries = await fs.readdir(dirPath, { withFileTypes: true });

  for (const entry of entries) {
    if (ignoreSet.has(entry.name)) {
      continue;
    }

    const fullPath = path.join(dirPath, entry.name);
    if (entry.isDirectory()) {
      filePaths = filePaths.concat(await getFilePaths(fullPath, ignoreSet));
    } else {
      filePaths.push(fullPath);
    }
  }
  return filePaths;
}

/**
 * Gets stats and content for a single file.
 * @param {string} filePath The path to the file.
 * @returns {Promise<object>} An object with file stats and content.
 */
async function getFileStatsAndContent(filePath) {
    try {
        const content = await fs.readFile(filePath, 'utf-8');
        const lines = content.split('\n').length;
        const characters = content.length;
        const tokens = Math.ceil(characters / 4); // Simple approximation
        return { filePath, lines, characters, tokens, content, error: null };
    } catch (error) {
        console.warn(`Warning: Could not read file ${filePath}. Error: ${error.message}`);
        return { filePath, lines: 0, characters: 0, tokens: 0, content: `Error reading file: ${error.message}`, error: error.message };
    }
}


/**
 * The main function to execute the script.
 */
async function main() {
  const args = process.argv.slice(2);
  if (args.length !== 1) {
    console.error('Usage: node bootstrap-flattener.js <directory_path>');
    process.exit(1);
  }

  const rootDir = path.resolve(args[0]);
  const outputFilePath = path.join(process.cwd(), OUTPUT_FILENAME);

  try {
    await fs.access(rootDir);
  } catch (error) {
    console.error(`Error: Directory not found at ${rootDir}`);
    process.exit(1);
  }

  console.log(`Starting to flatten repository at: ${rootDir}`);
  console.log(`Ignoring: ${[...DEFAULT_IGNORE].join(', ')}`);

  const filePaths = await getFilePaths(rootDir, DEFAULT_IGNORE);
  console.log(`Found ${filePaths.length} files to process...`);

  const results = await Promise.all(filePaths.map(getFileStatsAndContent));

  let totalLines = 0;
  let totalCharacters = 0;
  let totalTokens = 0;
  let errorCount = 0;

  for (const res of results) {
      if (!res.error) {
          totalLines += res.lines;
          totalCharacters += res.characters;
          totalTokens += res.tokens;
      } else {
          errorCount++;
      }
  }

  // --- Build Metadata Header ---
  let output = `<!--\n`;
  output += `  File: ${OUTPUT_FILENAME}\n`;
  output += `  Source Directory: ${rootDir}\n`;
  output += `  Date Generated: ${new Date().toISOString()}\n`;
  output += `  ---\n`;
  output += `  Total Files: ${results.length}\n`;
  if (errorCount > 0) {
      output += `  Files with Errors: ${errorCount}\n`;
  }
  output += `  Total Lines: ${totalLines}\n`;
  output += `  Total Characters: ${totalCharacters}\n`;
  output += `  Approx. Tokens: ${totalTokens}\n`;
  output += `-->\n\n`;

  // --- Top 10 Files by Tokens ---
  const top10 = results
    .filter(r => !r.error)
    .sort((a, b) => b.tokens - a.tokens)
    .slice(0, 10);

  output += `<!-- Top 10 Files by Token Count -->\n`;
  top10.forEach((r, i) => {
     output += `${i + 1}. ${path.relative(rootDir, r.filePath)} (${r.tokens} tokens)\n`;
  });
  output += `\n`;

  // --- Full File List ---
  output += `<!-- Full File List -->\n`;
  results.forEach((r, i) => {
    const relativePath = path.relative(rootDir, r.filePath);
    if (r.error) {
        output += `${i + 1}. ${relativePath} - ERROR: ${r.error}\n`;
    } else {
        output += `${i + 1}. ${relativePath} - Lines: ${r.lines} - Chars: ${r.characters} - Tokens: ${r.tokens}\n`;
    }
  });
  output += `\n`;


  // --- File Contents ---
  for (const { filePath, content } of results) {
    const relativePath = path.relative(rootDir, filePath).replace(/\\/g, '/');
    output += `<file path="${relativePath}">\n`;
    output += content;
    if (!content.endsWith('\n')) {
      output += '\n';
    }
    output += `</file>\n\n`;
  }

  await fs.writeFile(outputFilePath, output);
  console.log(`âœ… Success! Flattened repository saved to: ${outputFilePath}`);
}

main().catch(err => {
  console.error('An unexpected error occurred:', err);
  process.exit(1);
});
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025 David Gerabagi

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="package.json">
{
    "name": "data-curation-environment",
    "publisher": "DCE-Developer",
    "displayName": "Data Curation Environment",
    "description": "A VS Code extension for curating context for Large Language Models.",
    "version": "0.0.3",
    "repository": {
        "type": "git",
        "url": "https://github.com/dgerabagi/data-curation-environment.git"
    },
    "engines": {
        "vscode": "^1.90.0"
    },
    "categories": [
        "Other"
    ],
    "activationEvents": [
        "onView:data-curation-environment",
        "onCommand:dce.showParallelCopilot"
    ],
    "main": "./dist/extension.js",
    "contributes": {
        "commands": [
            {
                "command": "dce.saveCurrentSelection",
                "title": "DCE: Save Current Selection Set",
                "category": "DCE"
            },
            {
                "command": "dce.loadSelectionSet",
                "title": "DCE: Load Selection Set",
                "category": "DCE"
            },
            {
                "command": "dce.manageSelectionSets",
                "title": "DCE: Manage Selection Sets",
                "category": "DCE"
            },
            {
                "command": "dce.refreshTree",
                "title": "DCE: Refresh Explorer",
                "category": "DCE"
            },
            {
                "command": "dce.openParallelCopilot",
                "title": "DCE: Open Parallel Co-Pilot",
                "category": "DCE",
                "icon": "$(multiple-windows)"
            },
            {
                "command": "dce.showParallelCopilot",
                "title": "DCE: Show Parallel Co-Pilot"
            }
        ],
        "viewsContainers": {
            "activitybar": [
                {
                    "id": "data-curation-environment",
                    "title": "Data Curation",
                    "icon": "public/spiral.svg"
                },
                {
                    "id": "dce-parallel-copilot-container",
                    "title": "DCE Parallel Co-Pilot",
                    "icon": "public/copilot.svg"
                }
            ]
        },
        "views": {
            "data-curation-environment": [
                {
                    "type": "webview",
                    "id": "viewType.sidebar.contextChooser",
                    "name": "Data Curation"
                }
            ]
        },
        "menus": {
            "view/title": [
                {
                    "command": "dce.openParallelCopilot",
                    "when": "view == viewType.sidebar.contextChooser",
                    "group": "navigation"
                }
            ],
            "activityBar/view/title": [
                 {
                    "command": "dce.showParallelCopilot",
                    "when": "viewContainer == dce-parallel-copilot-container"
                }
            ]
        }
    },
    "scripts": {
        "vscode:prepublish": "npm run package",
        "compile": "webpack",
        "watch": "webpack --watch",
        "package": "webpack --mode production --devtool hidden-source-map",
        "lint": "eslint src --ext ts"
    },
    "devDependencies": {
        "@types/node": "18.x",
        "@types/vscode": "^1.90.0",
        "@typescript-eslint/eslint-plugin": "^7.7.1",
        "@typescript-eslint/parser": "^7.7.1",
        "eslint": "^8.57.0",
        "ts-loader": "^9.5.1",
        "typescript": "^5.4.5",
        "webpack": "^5.91.0",
        "webpack-cli": "^5.1.4",
        "copy-webpack-plugin": "^12.0.2",
        "mini-css-extract-plugin": "^2.9.0",
        "style-loader": "^4.0.0",
        "css-loader": "^7.1.2",
        "sass-loader": "^16.0.1",
        "sass": "^1.78.0",
        "postcss-loader": "^8.1.1",
        "babel-loader": "^9.1.3",
        "@babel/preset-react": "^7.24.7",
        "@babel/preset-typescript": "^7.24.7",
        "process": "^0.11.10",
        "path-browserify": "^1.0.1"
    },
    "dependencies": {
        "@wooorm/starry-night": "^3.8.0",
        "hast-util-to-html": "^9.0.1",
        "react": "^18.3.1",
        "react-dom": "^18.3.1",
        "react-icons": "^5.3.0",
        "react-markdown": "^9.0.1",
        "rxjs": "^7.8.1",
        "reflect-metadata": "^0.2.2",
        "pdf-parse": "^1.1.1",
        "xlsx": "^0.18.5",
        "mammoth": "^1.8.0",
        "diff": "^5.2.0",
        "@types/diff": "^5.2.1"
    }
}
</file>

<file path="public/copilot.svg">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor" class="w-4 h-4">
  <path d="M6.5 3.5v8a.5.5 0 0 0 .5.5h2a.5.5 0 0 0 .5-.5v-8a.5.5 0 0 0-.5-.5h-2a.5.5 0 0 0-.5.5ZM7 4h2v7H7V4Z"/>
  <path d="M2.5 3.5v8a.5.5 0 0 0 .5.5h2a.5.5 0 0 0 .5-.5v-8a.5.5 0 0 0-.5-.5h-2a.5.5 0 0 0-.5.5ZM3 4h2v7H3V4Z"/>
  <path d="M10.5 3.5v8a.5.5 0 0 0 .5.5h2a.5.5 0 0 0 .5-.5v-8a.5.5 0 0 0-.5-.5h-2a.5.5 0 0 0-.5.5ZM11 4h2v7h-2V4Z"/>
</svg>
</file>

<file path="public/spiral.svg">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200">
    <g id="Page-1" stroke="none" fill="none" fill-rule="evenodd">
        <g id="dep" transform="translate(4, 6)">
            <path d="M100 100 m 0 -80 a 80 80 0 0 1 0 160 a 70 70 0 0 1 0 -140 a 60 60 0 0 1 0 120 a 50 50 0 0 1 0 -100 a 40 40 0 0 1 0 80 a 30 30 0 0 1 0 -60 a 20 20 0 0 1 0 40"
                fill="none" stroke="white" stroke-width="8" id="Shape" />
        </g>
    </g>
</svg>
</file>

<file path="src/Artifacts/A0. DCE Master Artifact List.md">
# Artifact A0: DCE Master Artifact List
# Date Created: C1
# Author: AI Model & Curator
# Updated on: C129 (Add A58 for WinMerge Source Code Analysis)

## 1. Purpose

# This file serves as the definitive, parseable list of all documentation artifacts for the "Data Curation Environment" (DCE) VS Code Extension project.

## 2. Formatting Rules for Parsing

# *   Lines beginning with `#` are comments and are ignored.
# *   `##` denotes a major category header and is ignored.
# *   `###` denotes an artifact entry. The text following it is the artifact's full name and ID.
# *   Lines beginning with `- **Description:**` provide context for the project.
# *   Lines beginning with `- **Tags:**` provide keywords for Inference.

## 3. Artifacts List

## I. Project Planning & Design

### A1. DCE - Project Vision and Goals
- **Description:** High-level overview of the DCE VS Code extension, its purpose, and the three-phase development plan.
- **Tags:** project vision, goals, scope, phase 1, phase 2, phase 3, vs code extension

### A2. DCE - Phase 1 - Context Chooser - Requirements & Design
- **Description:** Detailed functional and technical requirements for Phase 1, focusing on the file tree with checkboxes and the flattening functionality.
- **Tags:** requirements, design, phase 1, context chooser, tree view, checkbox, flatten, vs code api

### A3. DCE - Technical Scaffolding Plan
- **Description:** Outlines the proposed file structure, technologies, and key VS Code API components for the extension, based on the `The-Creator-AI-main` reference repo.
- **Tags:** technical plan, scaffolding, file structure, typescript, vs code extension, api

### A4. DCE - Analysis of The-Creator-AI Repo
- **Description:** Provides a detailed analysis of the `The-Creator-AI-main` reference repository, its architecture, and its mapping to the Data Curation Environment project goals.
- **Tags:** analysis, repository, architecture, vscode-extension, project-planning

### A5. DCE - Target File Structure
- **Description:** A text-based representation of the target file structure for the DCE extension, outlining the layout of directories and key files.
- **Tags:** file structure, architecture, project layout, scaffolding

### A6. DCE - Initial Scaffolding Deployment Script
- **Description:** Contains a Node.js script that, when executed, creates the entire initial directory structure and files for the DCE extension project.
- **Tags:** deployment, script, scaffolding, bootstrap, nodejs, automation

### A7. DCE - Development and Testing Guide
- **Description:** A step-by-step guide explaining how to run, debug, and test the DCE extension within VS Code using the Extension Development Host.
- **Tags:** development, testing, debugging, workflow, vs code extension, f5

### A8. DCE - Phase 1 - Selection Sets Feature Plan
- **Description:** A plan outlining the user stories, UI/UX, and technical implementation for saving, loading, and persisting different sets of selected files (selection profiles).
- **Tags:** feature plan, selection sets, profiles, context management, persistence, phase 1

### A9. DCE - GitHub Repository Setup Guide
- **Description:** A step-by-step guide with the necessary git commands to initialize the project as a local repository and push it to a new remote repository on GitHub.
- **Tags:** git, github, version control, setup, repository

### A10. DCE - Metadata and Statistics Display
- **Description:** Outlines the requirements and design for displaying live metadata (total selected files, total tokens) and for showing aggregate statistics (token and file counts) for folders in the file tree.
- **Tags:** feature plan, metadata, statistics, token count, ui, ux

### A11. DCE - Regression Case Studies
- **Description:** Documents recurring bugs, their root causes, and codified solutions to prevent future regressions during development.
- **Tags:** bugs, regression, troubleshooting, development, best practices

### A12. DCE - Logging and Debugging Guide
- **Description:** Explains how to access and use the integrated logging solution for debugging the extension's backend and frontend components.
- **Tags:** logging, debugging, troubleshooting, development, output channel

### A13. DCE - Phase 1 - Right-Click Context Menu
- **Description:** A plan for implementing standard file explorer context menu actions (e.g., Rename, Delete, Copy Path) in the custom file tree.
- **Tags:** feature plan, context menu, right-click, file operations, ux, phase 1

### A14. DCE - Ongoing Development Issues
- **Description:** A tracking document for recurring or persistent issues that need to be monitored across development cycles until they are confirmed as resolved.
- **Tags:** bugs, tracking, issues, logging, node_modules, performance

### A15. DCE - Phase 1 - Multi-Select & Sorting Feature Plan
- **Description:** Details the requirements for multi-selection (click, Ctrl, Shift) in both the main file tree and the "Selected Items" panel, and multi-level column sorting.
- **Tags:** feature plan, multi-select, sorting, list view, ux, phase 1

### A16. DCE - Phase 1 - UI & UX Refinements Plan
- **Description:** Covers visual and usability improvements like fixing panel layouts, resolving overflow bugs, adding loading indicators, and improving scrollbar visibility.
- **Tags:** feature plan, ui, ux, layout, bug fix, loading indicator, phase 1

### A17. DCE - Phase 1 - Advanced Tree View Features
- **Description:** Outlines the plan for advanced tree view interactions, specifically the implementation of scrollable, self-contained views for large, expanded folders.
- **Tags:** feature plan, tree view, ux, scrollable, phase 1

### A18. DCE - Phase 1 - Active File Sync Feature Plan
- **Description:** Details the requirements and implementation for automatically revealing and highlighting the active editor's file in the custom Data Curation file tree.
- **Tags:** feature plan, active file, sync, reveal, tree view, ux, phase 1

### A19. DCE - Phase 1 - File Interaction Plan (Click & Remove)
- **Description:** Details the requirements for opening files by single-clicking them and quickly removing single files from the selection list via a mouse-over action.
- **Tags:** feature plan, single-click, open file, quick remove, ux, phase 1

### A20. DCE - Phase 1 - Advanced UX & Automation Plan
- **Description:** Details plans for several UX enhancements, including auto-revealing the flattened file, showing selected counts in folder stats, and providing an option to auto-add new files to the selection.
- **Tags:** feature plan, ux, automation, reveal, statistics, auto-add, phase 1

### A21. DCE - Phase 1 - Feature Drift Analysis vs. VS Code Explorer
- **Description:** A comparative analysis documenting the functional and behavioral differences between the DCE custom file view and the native VS Code Explorer to guide future development and feature parity.
- **Tags:** feature plan, analysis, drift, ux, vs code explorer, parity

### A22. DCE - Phase 1 - Search & Filter Feature Plan
- **Description:** Outlines the requirements and implementation for a search bar to filter the main file tree view by file or folder name.
- **Tags:** feature plan, search, filter, tree view, ux, phase 1

### A23. DCE - Phase 1 - Advanced Interactions (Keyboard & Drag-Drop) Plan
- **Description:** Details the requirements for implementing full keyboard navigation and drag-and-drop file/folder operations within the main file tree.
- **Tags:** feature plan, keyboard navigation, drag and drop, file operations, accessibility, ux, phase 1

### A24. DCE - Selection Paradigm Terminology
- **Description:** A document to clarify the terminology used within the project to distinguish between different types of user selections (e.g., "checking" for flattening vs. "selecting" for actions).
- **Tags:** documentation, terminology, selection, checking, design

### A25. DCE - Phase 1 - Git & Problems Integration Plan
- **Description:** Outlines the user stories and technical approach for integrating Git status indicators and VS Code Problem Diagnostics into the custom file tree.
- **Tags:** feature plan, git, problems, diagnostics, ux, phase 1

### A26. DCE - Phase 1 - File System Traversal & Caching Strategy
- **Description:** Documents the root cause of the folder visibility bug and outlines the new strategy of using recursive directory traversal instead of `findFiles` to build a complete and accurate file system map.
- **Tags:** bug fix, file system, traversal, refresh, cache, architecture

### A27. DCE - Phase 1 - Undo-Redo Feature Plan
- **Description:** Details the requirements for implementing an undo/redo stack for file system operations (move, delete) performed within the DCE view, to achieve parity with the native explorer's Ctrl+Z functionality.
- **Tags:** feature plan, undo, redo, ctrl+z, file operations, ux, phase 1

### A28. DCE - Packaging and Distribution Guide
- **Description:** Provides a step-by-step guide on how to package the extension into a `.vsix` file for beta testing and distribution.
- **Tags:** packaging, distribution, vsix, vsce, deployment

### A29. DCE - Phase 1 - Binary and Image File Handling Strategy
- **Description:** Defines the strategy for handling binary files; they can be checked, but only their metadata (path, size) is included in the flattened output, not their content.
- **Tags:** feature plan, binary, image, metadata, flatten, phase 1

### A30. DCE - Phase 1 - PDF Handling and Virtualization Strategy
- **Description:** Defines the strategy for handling PDF files. Text is extracted on-demand and cached in memory for flattening, creating a "virtual" markdown file without modifying the user's workspace.
- **Tags:** feature plan, pdf, text extraction, virtualization, cache, phase 1

### A31. DCE - Phase 2 - Multimodal Content Extraction (PDF Images)
- **Description:** A plan for a future feature to extract images from PDF files and use a multimodal LLM to generate rich, textual descriptions for inclusion in the context.
- **Tags:** feature plan, multimodal, image to text, pdf, llm, phase 2

### A32. DCE - Phase 1 - Excel and CSV Handling Strategy
- **Description:** Defines the strategy for handling tabular data files (.xlsx, .xls, .csv) by converting them to Markdown tables on-demand and caching them in memory for flattening.
- **Tags:** feature plan, excel, csv, text extraction, virtualization, cache, phase 1

### A33. DCE - Phase 1 - Copy-Paste Feature Plan
- **Description:** Details the requirements and implementation for copying and pasting files and folders within the DCE file tree using standard keyboard shortcuts (Ctrl+C, Ctrl+V).
- **Tags:** feature plan, copy, paste, file operations, keyboard shortcuts, ux, phase 1

### A34. DCE - Phase 2 - Parallel Co-Pilot Panel - Vision & Requirements
- **Description:** Outlines the high-level vision and user stories for the Phase 2 multi-tabbed editor panel, designed for comparing and managing multiple AI-generated responses.
- **Tags:** feature plan, phase 2, co-pilot, multi-tab, ui, ux, requirements

### A35. DCE - Phase 2 - UI Mockups and Flow
- **Description:** Provides a detailed textual description and flow diagram for the user interface of the Parallel Co-Pilot Panel, including tab management and the "swap" interaction.
- **Tags:** feature plan, phase 2, ui, ux, mockup, workflow

### A36. DCE - Phase 2 - Technical Implementation Plan
- **Description:** Details the technical approach for building the Parallel Co-Pilot Panel, including the new webview provider, state management, IPC channels, and backend logic for file content swapping.
- **Tags:** feature plan, phase 2, technical plan, architecture, webview, ipc

### A37. DCE - Phase 2 - Cycle Navigator & Knowledge Graph - Vision
- **Description:** Outlines the vision for a cycle-based navigation system to browse the history of AI-generated responses and project states, creating a navigable knowledge graph.
- **Tags:** feature plan, phase 2, knowledge graph, history, cycle navigator, ui, ux

### A38. DCE - Phase 2 - Cycle Navigator - UI Mockup
- **Description:** Provides a textual mockup and interaction flow for the Cycle Navigator UI, including the cycle counter and navigation controls within the Parallel Co-Pilot Panel.
- **Tags:** feature plan, phase 2, ui, ux, mockup, workflow, cycle navigator

### A39. DCE - Phase 2 - Cycle Navigator - Technical Plan
- **Description:** Details the technical approach for implementing the Cycle Navigator, including data structures for storing cycle-specific responses and the state management for historical navigation.
- **Tags:** feature plan, phase 2, technical plan, architecture, state management, data model

### A40. DCE - Phase 2 - Parallel Co-Pilot - Target File Structure
- **Description:** A text-based representation of the target file structure for the new Phase 2 Parallel Co-Pilot panel, outlining the layout of new directories and key files.
- **Tags:** file structure, architecture, project layout, scaffolding, phase 2

### A40.1. DCE - Phase 2 - Competitive Analysis & Feature Ideas
- **Description:** An analysis of existing tools and extensions for managing multiple AI responses, with a list of potential features to incorporate into the Parallel Co-Pilot panel.
- **Tags:** feature plan, phase 2, research, competitive analysis, co-pilot

### A41. DCE - Phase 2 - API Key Management - Feature Plan
- **Description:** Outlines the user stories and technical plan for a settings UI where users can securely input and manage their API keys for various LLM services.
- **Tags:** feature plan, phase 2, settings, api key, configuration, security

### A41.1. DCE - Phase 2 - Advanced Features & Integrations Plan
- **Description:** Explores future enhancements for the Parallel Co-Pilot, such as applying AI responses as diff patches and integrating with Git for direct commits.
- **Tags:** feature plan, phase 2, ideation, diff, patch, git, workflow

### A41.2. DCE - Phase 2 - Feature Ideation & Competitive Analysis
- **Description:** An analysis of similar AI coding assistant tools (e.g., Cursor.sh, Copilot Chat) and a brainstorm of potential advanced features for the Parallel Co-Pilot panel.
- **Tags:** feature plan, phase 2, research, competitive analysis, ideation, roadmap

### A42. DCE - Phase 2 - Initial Scaffolding Deployment Script
- **Description:** Contains a Node.js script that, when executed, creates the file and directory structure for the Phase 2 Parallel Co-Pilot panel.
- **Tags:** deployment, script, scaffolding, bootstrap, nodejs, automation, phase 2

### A43. DCE - Phase 2 - Implementation Roadmap
- **Description:** Provides a step-by-step implementation plan for building the Phase 2 features, including the Parallel Co-Pilot panel and the integrated Diff Tool.
- **Tags:** feature plan, phase 2, roadmap, project plan, diff tool

### A44. DCE - Phase 1 - Word Document Handling Strategy
- **Description:** Defines the strategy for handling Word document files (.docx) by converting them to text on-demand and caching them in memory for flattening.
- **Tags:** feature plan, docx, text extraction, virtualization, cache, phase 1

### A45. DCE - Phase 2 - Pop-out Co-Pilot Window - Feature Plan
- **Description:** Outlines the technical strategy to allow the Parallel Co-Pilot panel to be "popped out" into a separate window by re-implementing it as a main editor WebviewPanel.
- **Tags:** feature plan, phase 2, pop-out, window, webview, ux

### A46. DCE - Phase 2 - Paste and Parse Response - Feature Plan
- **Description:** Details the plan for allowing users to paste a full AI response into a tab, which the extension will then parse to identify file paths referenced within XML tags.
- **Tags:** feature plan, phase 2, paste, parse, workflow, automation

### A47. DCE - Phase 2 - Prompt Amalgamation Feature Plan
- **Description:** Details the plan for a "Generate prompt.md" button that will assemble the static schemas, cycle history, and flattened code into a single, complete prompt file.
- **Tags:** feature plan, phase 2, prompt engineering, automation, workflow

### A48. DCE - Phase 2 - Advanced Syntax Highlighting Plan
- **Description:** Outlines the strategy to replace the plain textarea in response tabs with a proper code editor component to provide rich syntax highlighting for Markdown and embedded code.
- **Tags:** feature plan, phase 2, ui, ux, syntax highlighting, monaco, codemirror

### A49. DCE - Phase 2 - File Association & Diffing Plan
- **Description:** Plans the UI and backend logic to visually link file blocks in an AI response to workspace files and sets the stage for an integrated diff tool.
- **Tags:** feature plan, phase 2, ui, ux, diff, file association

### A50. DCE - Phase 2 - UI Component Plan (Resizable Panes & Inner Editors)
- **Description:** Documents the plan for advanced UI components like resizable panes and nested, scrollable editors within the Parallel Co-Pilot panel.
- **Tags:** feature plan, phase 2, ui, ux, resizable, scrollable, editor

### A51. DCE - A-B-C Testing Strategy for UI Bugs
- **Description:** Outlines a development pattern for creating parallel, isolated test components to diagnose and resolve persistent UI bugs, such as event handling or rendering issues.
- **Tags:** process, debugging, troubleshooting, ui, ux, react

### A52. DCE - Interaction Schema Refinement
- **Description:** Proposes a set of refined rules for the AI's output format to improve the reliability and consistency of automated parsing within the Parallel Co-Pilot Panel.
- **Tags:** documentation, process, parsing, interaction schema, roadmap

### A53. DCE - Phase 2 - Token Count and Similarity Analysis
- **Description:** Details the plan to implement token counting for raw and parsed responses, and to calculate a similarity score between AI-generated files and their workspace originals.
- **Tags:** feature plan, phase 2, token count, similarity, metrics, ui, ux

### A54. starry-night Readme
- **Description:** A copy of the readme.md file for the `@wooorm/starry-night` syntax highlighting library, providing a reference for available languages and API usage.
- **Tags:** documentation, library, syntax highlighting, starry-night

### A55. DCE - FSService Refactoring Plan
- **Description:** Outlines a strategic plan to refactor the monolithic `FSService` into smaller, more focused services to improve modularity, maintainability, and reduce token count.
- **Tags:** refactor, architecture, technical debt, services

### A56. DCE - Phase 2 - Advanced Diff Viewer Plan
- **Description:** Details the plan to enhance the integrated diff viewer with background coloring for changes and WinMerge-like navigation controls to jump between differences.
- **Tags:** feature plan, phase 2, ui, ux, diff, navigation, side-by-side

### A57. DCE - Phase 2 - Cycle Management Features
- **Description:** Details the plan for adding critical cycle management features to the Parallel Co-Pilot panel, including deleting the current cycle and resetting the entire history.
- **Tags:** feature plan, phase 2, ui, ux, history, cycle management

### A58. DCE - WinMerge Source Code Analysis
- **Description:** Documents the key files and concepts from the WinMerge source code that are relevant to building a high-quality diff viewer.
- **Tags:** research, analysis, diff, winmerge, source code

## II. Standalone Utilities & Guides

### A149. Local LLM Integration Plan
- **Description:** The technical plan for integrating a locally hosted LLM into the game via a secure backend proxy.
- **Tags:** llm, integration, plan, backend, api

### A189. Number Formatting Reference Guide
- **Description:** A standalone guide and utility script for formatting large numbers with K/M/B/T suffixes and dynamic decimal place adjustment for clean UI presentation.
- **Tags:** utility, script, formatting, numbers, ui, ux, javascript, typescript
</file>

<file path="src/Artifacts/A1. DCE - Project Vision and Goals.md">
# Artifact A1: DCE - Project Vision and Goals
# Date Created: Cycle 1
# Author: AI Model
# Updated on: C87 (Shifted Diff Tool to Phase 2, defined Phase 3 as LLM Integration)

## 1. Project Vision

The vision of the Data Curation Environment (DCE) is to create a seamless, integrated toolset within VS Code that streamlines the workflow of interacting with large language models. The core problem this project solves is the manual, cumbersome process of selecting, packaging, and managing the context (code files, documents, etc.) required for effective AI-assisted development.

## 2. High-Level Goals & Phases

The project will be developed in three distinct phases.

**Note on Reference Repository:** The discovery of the `The-Creator-AI-main` repository in Cycle 2 has provided a significant head-start, especially for Phase 1 and 2. The project's focus shifts from building these components from the ground up to adapting and extending the powerful, existing foundation.

### Phase 1: The Context Chooser

The goal of this phase is to eliminate the manual management of a `files_list.txt`. Users should be able to intuitively select files and folders for their AI context directly within the VS Code file explorer UI.

-   **Core Functionality:** Implement a file explorer view with checkboxes for every file and folder.
-   **Action:** A "Flatten Context" button will take all checked items and generate a single `flattened_repo.md` file in the project root.
-   **Outcome:** A user can curate a complex context with simple mouse clicks, completely removing the need to edit a text file.
-   **Status:** Largely complete.

### Phase 2: The Parallel Co-Pilot Panel & Integrated Diff Tool

This phase addresses the limitation of being locked into a single conversation with an AI assistant and brings the critical "diffing" workflow directly into the extension. The goal is to enable multiple, parallel interactions and to create a navigable record of the AI-driven development process.

-   **Core Functionality (Parallel Co-Pilot):** Create a custom panel within VS Code that hosts a multi-tabbed text editor. Users can manually paste or have the extension ingest different AI-generated code responses into each tab for side-by-side comparison.
-   **Key Feature ("Swap & Test"):** A button on each tab allows the user to "swap" the content of that tab with the corresponding source file in their workspace. This provides an immediate, low-friction way to test a given AI response.
-   **Core Functionality (Integrated Diff):** The panel will include a built-in diff viewer to compare the content of any two tabs, or a tab and the source file. This eliminates the need for external tools like WinMerge.
-   **Core Functionality (Cycle Navigator):** Integrate a UI element to navigate back and forth between development cycles. Each cycle will be associated with the set of AI responses generated during that cycle.
-   **Outcome:** A user can efficiently manage, compare, and test multiple AI solutions, and also review the historical evolution of the code by navigating through past cycles and their corresponding AI suggestions, creating a powerful "knowledge graph" of the project's development.

### Phase 3: Advanced AI & Local LLM Integration

This phase focuses on deeper integration with AI services and providing support for local models.

-   **Core Functionality:** Implement direct API calls to various LLM providers (e.g., Gemini, OpenAI, Anthropic) from within the Parallel Co-Pilot panel, populating the tabs automatically. This requires building a secure API key management system.
-   **Local LLM Support:** Allow users to configure an endpoint URL for a locally hosted LLM (e.g., via LM Studio, Ollama), enabling fully offline and private AI-assisted development.
-   **Outcome:** The DCE becomes a fully-featured AI interaction environment, supporting both cloud and local models, and automating the entire prompt-to-test workflow.
</file>

<file path="src/Artifacts/A10. DCE - Metadata and Statistics Display.md">
# Artifact A10: DCE - Metadata and Statistics Display
# Date Created: Cycle 14
# Author: AI Model
# Updated on: C40 (Clarify file counter label and tooltip)

- **Key/Value for A0:**
- **Description:** Outlines the requirements and design for displaying live metadata (total selected files, total tokens) and for showing aggregate statistics (token and file counts) for folders in the file tree.
- **Tags:** feature plan, metadata, statistics, token count, ui, ux

## 1. Overview & Goal

To enhance the data curation process, it is critical for the user to have immediate, quantitative feedback on their selections. This feature will provide at-a-glance statistics at both the folder level and the overall selection level. The goal is to empower the user to make informed decisions about context size and composition without needing to perform manual calculations.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| US-01 | **Folder Statistics** | As a data curator, I want to see the total token count and the total number of files contained within each folder, so I can quickly assess the size and complexity of different parts of my project. | - Next to each folder name in the file tree, a token count is displayed. <br> - This token count is the recursive sum of all tokens from all non-image files within that folder and its subfolders. <br> - Next to the token count, a file count is also displayed, formatted with commas (e.g., "1,234"). <br> - These numbers are calculated on the backend and provided with the initial file tree data. |
| US-02 | **Live Selection Summary** | As a data curator, I want to see a live summary of my total selection as I check and uncheck files, so I can monitor the total size of my context in real-time. | - A dedicated summary panel/footer is visible in the UI. <br> - This panel displays "X files" and "Y tokens". <br> - **(C40 Update)** The label for the file count is "Selected Files". The tooltip reads: "Total number of individual files selected for flattening. This does not include empty directories." <br> - "X" is the total count of all individual files included in the current selection, formatted with commas. <br> - "Y" is the sum of all token counts for those selected non-image files. <br> - These values update instantly whenever a checkbox is changed. |
| US-03 | **Readable Numbers & Icons** | As a data curator, I want large token counts to be formatted in a compact and readable way (e.g., 1,234 becomes "1.2K"), and for icons to visually represent the data, so I can easily parse the information. | - All token counts use K/M/B suffixes for numbers over 1,000. <br> - All file counts use commas for thousands separators. <br> - An icon is displayed next to the token count and file count for visual distinction. <br> - The statistics are right-justified in the file tree for better readability. |
| US-04 | **Image File Handling** | As a data curator, I want to see the file size for images instead of a token count, so I can understand their contribution to storage/transfer size rather than context length. | - The backend identifies common image file types (png, jpg, etc.). <br> - For image files, the token count is treated as 0. <br> - In the file tree, instead of a token count, the human-readable file size is displayed (e.g., "15.2 KB", "2.1 MB"). |
| US-05 | **Selected Token Count in Folders** | As a data curator, I want to see how many tokens are selected within a folder, so I can understand the composition of my selection without expanding the entire directory. | - Next to a folder's total token count, a secondary count in parentheses `(x)` appears. <br> - `x` is the recursive sum of tokens from all selected files within that folder. <br> - The display format is `TotalTokens (SelectedTokens)`, e.g., `347K (13K)`. <br> - This count only appears if selected tokens are > 0 and less than the total tokens. |
| US-06 | **Visual Cue for Selected Tokens** | As a curator, I want a clear visual indicator on the token count itself when an item is included in the selection, so I can confirm its inclusion without looking at the checkbox. | - When an individual file is checked, its token count is wrapped in parentheses, e.g., `(168)`. <br> - When a folder is checked, and *all* of its children are included in the selection, its total token count is wrapped in parentheses, e.g., `(336)`. <br> - This complements the `Total (Selected)` format for partially selected folders. |

## 3. Technical Implementation Plan

1.  **Backend (`fs.service.ts`):**
    *   The `FileNode` interface in `src/common/types/file-node.ts` will be updated to include `isImage: boolean` and `sizeInBytes: number`.
    *   The backend service will maintain a list of image file extensions.
    *   When building the tree, it will check each file's extension.
    *   If it's an image, it will use `fs.stat` to get the `sizeInBytes`, set `isImage: true`, and set `tokenCount: 0`.
    *   If it's not an image, it will calculate the `tokenCount` and get the `sizeInBytes`.
    *   The recursive sum logic for folders will aggregate `tokenCount`, `fileCount`, and `sizeInBytes` from their children.
    *   The `vscode.workspace.findFiles` call will be updated to exclude the `node_modules` directory.

2.  **Frontend - Formatting (`formatting.ts`):**
    *   A new `formatBytes(bytes)` utility will be created to convert bytes to KB, MB, etc.
    *   A new `formatNumberWithCommas(number)` utility will be created.

3.  **Frontend - File Tree (`FileTree.tsx` & `view.scss`):**
    *   The `FileTree.tsx` component will be updated to render the new data.
    *   It will conditionally display either a formatted token count (using `formatLargeNumber`) or a formatted file size (using `formatBytes`) based on the `isImage` flag.
    *   It will display folder file counts using `formatNumberWithCommas`.
    *   **Selected Token Calculation:** A new memoized, recursive function will be created within `FileTree.tsx` to calculate the selected token count for a given directory node by checking its descendants against the `selectedFiles` prop.
    *   The rendering logic will be updated to display the `(SelectedTokens)` value conditionally.
    *   **Parenthesis Logic (US-06):** The rendering logic will be further updated. For files, it will check if the file's path is in the `selectedFiles` list. For folders, it will compare the calculated `selectedTokensInDir` with the `node.tokenCount`. Based on these checks, it will conditionally wrap the output string in parentheses.
    *   It will incorporate icons from `react-icons/vsc` for tokens and file counts.
    *   The stylesheet (`view.scss`) will be updated to right-align all statistics, pushing them to the end of the file/folder row.

4.  **Frontend - Live Summary Panel (`context-chooser.view.tsx`):**
    *   The `useMemo` hook that calculates the summary will be updated to correctly sum the total number of files and total tokens from the selected items. It will continue to ignore image sizes for the token total to avoid mixing units.
    *   The rendered output will use the new formatting utilities and icons.
    *   **(C40)** The label and title attribute will be updated for clarity.
</file>

<file path="src/Artifacts/A11. DCE - Regression Case Studies.md">
# Artifact A11: DCE - Regression Case Studies
# Date Created: C16
# Author: AI Model & Curator
# Updated on: C130 (Add case for RegExp type inference errors)

- **Key/Value for A0:**
- **Description:** Documents recurring bugs, their root causes, and codified solutions to prevent future regressions during development.
- **Tags:** bugs, regression, troubleshooting, development, best practices

## 1. Purpose

This document serves as a living record of persistent or complex bugs that have recurred across multiple development cycles. By documenting the root cause analysis (RCA) and the confirmed solution for each issue, we create a "source of truth" that can be referenced to prevent the same mistakes from being reintroduced into the codebase.

## 2. Case Studies

---

### Case Study 009: TypeScript Type Inference with RegExp Results

-   **Artifacts Affected:** `src/client/utils/response-parser.ts`
-   **Cycles Observed:** 130
-   **Symptom:** TypeScript build fails with errors like `TS2339: Property 'trim' does not exist on type 'RegExpMatchArray'`. This occurs when trying to access a capture group from the result of `String.prototype.match()` or `RegExp.prototype.exec()`.
-   **Root Cause Analysis (RCA):** The TypeScript compiler, in some complex scenarios, can have difficulty inferring the precise type of a capture group within a `RegExpMatchArray` or `RegExpExecArray`. While the developer knows that `match[1]` should be a `string`, the compiler may infer a wider, incorrect type for the array element itself, leading to the erroneous belief that methods like `.trim()` or `.split()` do not exist.
-   **Codified Solution & Best Practice:**
    1.  **Use `matchAll` for Multiple Matches:** For global regular expressions, `String.prototype.matchAll()` is superior to a `while(regex.exec())` loop. It returns an iterator of `RegExpMatchArray` objects, and its type definitions are generally more robust and modern, making it easier for TypeScript to infer the correct types for capture groups.
    2.  **Use Optional Chaining and Nullish Coalescing:** For single matches (`String.prototype.match()`), the safest way to access a capture group is with optional chaining (`?.[]`) and the nullish coalescing operator (`??`). This pattern is both safe and clear to the TypeScript compiler.
-   **Example of Flawed Logic (Conceptual):**
    ```typescript
    const match = myString.match(/.../);
    const value = match ? match.trim() : ''; // This can fail if TS inference is poor
    ```
-   **Example of Correct Logic (Conceptual):**
    ```typescript
    const match = myString.match(/.../);
    const value = (match?. ?? '').trim(); // This is type-safe and robust
    ```

---

### Case Study 008: PCPP Parse/Un-Parse State Instability

-   **Artifacts Affected:** `src/client/views/parallel-copilot.view/view.tsx`
-   **Cycles Observed:** 124, 126
-   **Symptom:** The "Parse All" button exhibits unstable behavior.
    1.  Clicking it toggles the UI to the "Un-Parse All" state but immediately reverts to "Parse All". A second click is required for the state to stick.
    2.  When the UI is in the "Un-Parse All" state, selecting a file from the "Associated Files" list incorrectly toggles the mode back to "Parse All", making it impossible to view files.
-   **Root Cause Analysis (RCA):** The bug is caused by a dependency cycle in the React component's state management. The `parseAllTabs` function, which was wrapped in a `useCallback`, had a dependency on the `tabs` state. Inside the function, it called `setTabs`. This created a loop where the `useEffect` hook responsible for parsing would run, call `parseAllTabs`, which would update the `tabs` state, which would create a new `parseAllTabs` function on re-render, which would re-trigger the `useEffect`. This loop caused rapid, unpredictable state changes, leading to the observed UI flickering and instability.
-   **Codified Solution & Best Practice:**
    1.  **Break Dependency Cycle:** The `useCallback` hook for the `parseAllTabs` function was refactored. It now uses the functional update form of its `setTabs` call (e.g., `setTabs(prevTabs => ...)`).
    2.  This removes the need for the `tabs` state to be in the `useCallback` dependency array. The function is now stable across re-renders.
    3.  **Refine `useEffect`:** The `useEffect` that triggers the parsing logic can now safely depend on `parseAllTabs` without causing a loop. Its dependency array should be limited to `isParsedMode` and the raw content of the tabs, preventing it from running on unrelated UI state changes like file selection.
    4.  **Best Practice:** When a memoized callback (`useCallback`) needs to update a state that it also depends on, always use the functional update form to break the dependency cycle.

---

### Case Study 007: Corrupted or Unsupported Document Files
-   **Artifacts Affected:** `src/backend/services/content-extraction.service.ts`, `A44. DCE - Phase 1 - Word Document Handling Strategy.md`
-   **Cycles Observed:** 81
-   **Symptom:** Some `.docx` files fail to process with a `Can't find end of central directory` error in the logs, while legacy `.doc` files show an "Unsupported format" message in the UI.
-   **Root Cause Analysis (RCA):** This is not a bug, but rather the system correctly handling invalid inputs.
    1.  **Corrupted `.docx`:** The `.docx` format is a standard zip archive. The parsing library (`mammoth`, which uses `jszip`) throws the "central directory" error when a file is not a valid zip archive. This indicates the source file itself is corrupted or was saved incorrectly.
    2.  **Legacy `.doc`:** The `mammoth` library does not support the old binary `.doc` format. Our documented strategy in `A44` is to explicitly reject these files.
-   **Codified Solution & Best Practice:**
    1.  The error handling in `content-extraction.service.ts` is working as intended.
    2.  The `catch` block in `handleWordToTextRequest` should be enhanced to check for the specific "central directory" error message.
    3.  When this specific error is caught, a more user-friendly message like "File appears to be corrupted or is not a valid .docx format" should be sent to the frontend.
    4.  The system should continue to correctly identify `.doc` files and send the "Legacy .doc format not supported" message. This confirms the system is robust against invalid user inputs.

---

### Case Study 006: Special File Type Caching Fails on Initialization
-   **Artifacts Affected:** `src/client/views/context-chooser.view/view.tsx`
-   **Cycles Observed:** 65, 66, 75, 76, 78, 79, 80, 81
-   **Symptom:** When the extension loads and restores the previous selection, special file types (`.pdf`, `.xlsx`, `.docx`) have a token count of 0. When "Flatten Context" is clicked, the output shows `<!-- content not processed or cached -->`. The caching only works if the user manually un-checks and re-checks the file.
-   **Root Cause Analysis (RCA):** The frontend logic for "pre-warming" the cache was flawed. It was attempting to find the file nodes for the restored selection paths *before* the main file tree had been loaded from the backend. This race condition meant it found no files to process, so the cache was never populated on startup.
-   **Codified Solution & Best Practice:**
    1.  **Decouple and Defer Pre-warming:** The logic must be architected to handle asynchronous data arrival gracefully.
    2.  **Use a Trigger State:** In `view.tsx`, the `ApplySelectionSet` message handler should do nothing more than set two state variables: one for the `checkedFiles` (for the UI) and a separate "trigger" state (e.g., `selectionToPrewarm: string[]`).
    3.  **Use a Multi-Dependency `useEffect`:** A dedicated `useEffect` hook must be created to perform the pre-warming logic. Its dependency array **must** include both the trigger state and the file tree state (e.g., `[selectionToPrewarm, files]`).
    4.  This ensures the pre-warming code only executes when both the selection and the file tree data are guaranteed to be present, eliminating the race condition. After executing, the trigger state should be reset to `null` to prevent re-runs.

---

### Case Study 005: Spacebar De-selects Wrong Parent Folder
-   **Artifacts Affected:** `src/client/components/file-tree/FileTree.utils.ts`
-   **Cycles Observed:** 61, 68
-   **Symptom:** When a parent folder (e.g., `src`) is checked, focusing on a deeply nested descendant file (e.g., `src/components/menus/file.ts`) and pressing the spacebar causes a mid-level parent folder (e.g., `src/components`) to be de-selected instead of just the single focused file.
-   **Root Cause Analysis (RCA):** The logic for a "subtractive uncheck" in `addRemovePathInSelectedFiles` was flawed. It correctly identified the selected ancestor (e.g., `src`) but then attempted to re-add only its *direct children*, failing to handle nested structures. It would incorrectly identify which direct child to exclude based on the deep file path, leading to the removal of an entire subdirectory from the selection.
-   **Codified Solution & Best Practice:**
    1.  The `addRemovePathInSelectedFiles` function was refactored for the "subtractive uncheck" case.
    2.  The new logic is more explicit and reliable:
        *   Remove the high-level ancestor path (e.g., `src`) from the selection set.
        *   Get a list of **all descendant files** of that ancestor.
        *   Add all of these descendant files to the selection set, **except for the specific file that was the target of the uncheck action**.
    3.  This correctly translates the selection from a single high-level path (`src`) into many individual low-level file paths, minus the one the user explicitly removed, preserving their intent perfectly.

---

### Case Study 004: Spacebar De-selects Parent Folder Instead of File

-   **Artifacts Affected:** `src/client/components/file-tree/FileTree.utils.ts`
-   **Cycles Observed:** 61
-   **Symptom:** When a parent folder (e.g., `src`) is checked, focusing on a descendant file (e.g., `src/components/file.ts`) and pressing the spacebar causes the entire sub-folder (`src/components`) to be removed from the selection, rather than just the single file.
-   **Root Cause Analysis (RCA):** The logic for a "subtractive uncheck" was flawed. When attempting to uncheck a child of an already-selected parent, the utility function would correctly remove the parent from the selection set but would then re-add the parent's *direct children* except for the one containing the target file. This was too aggressive and did not correctly represent the user's intent to remove only a single file.
-   **Codified Solution & Best Practice:**
    1.  The `addRemovePathInSelectedFiles` function was refactored for the "subtractive uncheck" case.
    2.  The new logic is more explicit:
        *   Remove the ancestor path (e.g., `src`) from the selection.
        *   Get a list of **all descendant files** of that ancestor.
        *   Add all descendant files to the selection, **except for the specific file that was unchecked**.
    3.  This correctly translates the selection from a single high-level path (`src`) into many individual low-level paths, minus the one the user removed, preserving their intent.

---

### Case Study 003: Incorrect File Count in Flatten Success Message

-   **Artifacts Affected:** `src/backend/services/flattener.service.ts`
-   **Cycles Observed:** 61
-   **Symptom:** The success message after flattening (e.g., "Successfully flattened X files...") shows an incorrect count of files, often higher than what was actually selected and written.
-   **Root Cause Analysis (RCA):** The `flattener.service` was using the count of all unique file paths it was *initially given* for the success message. This list could include paths that were later filtered out (e.g., binary files before metadata handling was implemented) or files that failed to be read. The message did not reflect the final count of files successfully processed and written to the output file.
-   **Codified Solution & Best Practice:**
    1.  The `generateOutputContent` function is responsible for creating the final string to be written to disk. It already has access to the array of successfully processed file results.
    2.  The `vscode.window.showInformationMessage` call inside the `flatten` method was modified to use the `length` of this final, validated list of results (`validResults.length`) instead of the initial input list. This ensures the user is always shown the exact number of files included in the output.

---

### Case Study 002: Checkbox State Management in File Tree

-   **Artifacts Affected:** `src/client/components/file-tree/FileTree.utils.ts`, `src/client/components/file-tree/FileTree.tsx`
-   **Cycles Observed:** 14, 15, 16
-   **Symptom:** Checkbox functionality in the file tree is erratic. Only the root checkbox works as expected, but individual files or sub-folders cannot be checked or unchecked correctly. Clicking a checkbox on a child of an already-selected folder fails to deselect it.
-   **Root Cause Analysis (RCA):**
    The core issue was overly complex and flawed state management logic within the `addRemovePathInSelectedFiles` utility function. The logic attempted to handle the "unchecking a child of a selected parent" case by removing the parent and re-adding all of its other children (the "siblings"). This approach was brittle and failed to correctly calculate the new state, leading to a UI that did not update correctly. The complexity made the function difficult to debug and maintain.

-   **Codified Solution & Best Practice:**
    1.  **Simplify State Logic:** The state management logic was rewritten to be more direct and declarative, using a `Set` for efficient manipulation of selected paths.
    2.  **Handle Cases Explicitly:** The new function explicitly handles the three primary user actions:
        *   **CHECK:** When a node is checked, any of its descendants that are already in the selection are removed, and the node's own path is added. This ensures the most senior selected path is always the one stored in state.
        *   **UNCHECK (Direct):** When a node that is explicitly in the selection list is unchecked, its path and the paths of all its descendants are removed.
        *   **UNCHECK (Subtractive):** When a node is unchecked because its parent was checked, the parent is removed from the selection. Then, all of the parent's direct children *except for the one that was clicked* are added to the selection. This correctly "subtracts" the item from the parent's group selection without complex traversals.
    3.  **Robust Event Handling:** Ensure the checkbox `onChange` handler in the React component uses `event.stopPropagation()` to prevent the click event from bubbling up and triggering other actions, such as folder expansion.

-   **Example of Flawed Logic (Conceptual):**
    ```typescript
    // OLD LOGIC
    if (unchecking a child of a selected parent) {
      // 1. Remove parent from selected list.
      // 2. Traverse the entire tree from the parent.
      // 3. Add every descendant of the parent back, EXCEPT the clicked child.
      // This was inefficient and error-prone.
    }
    ```

-   **Example of Correct Logic (Conceptual):**
    ```typescript
    // NEW LOGIC
    if (unchecking a child of a selected parent) {
      // 1. Remove the parent from the selection set.
      const parentNode = findParentNode(clickedPath);
      // 2. Add all of the parent's *direct children* to the selection set,
      //    except for the clicked child itself.
      parentNode.children.forEach(child => {
        if (child.path !== clickedPath) {
          selectionSet.add(child.path);
        }
      });
    }
    ```

---

### Case Study 001: `path.sep` Usage in Frontend Components

-   **Artifacts Affected:** `src/client/components/file-tree/FileTree.tsx`
-   **Cycles Observed:** 13, 14, 16
-   **Symptom:** The webpack build process fails with TypeScript errors similar to `TS2339: Property 'sep' does not exist on type 'string'`.
-   **Root Cause Analysis (RCA):**
    The error occurs when frontend code (React components running in a webview) attempts to use `path.sep`. The `path` module is a core part of the Node.js runtime, but it does not exist in the browser-like context of a webview.
-   **Codified Solution & Best Practice:**
    1.  **Strict Environment Separation:** All file system path manipulation **must** occur in the backend (`src/backend/`).
    2.  **Normalized Paths:** The backend must normalize all paths to use forward slashes (`/`) before sending them to the frontend.
    3.  **Frontend Simplicity:** The frontend code must treat all file paths as simple strings and should never attempt to parse or join them using path-specific separators.
</file>

<file path="src/Artifacts/A12. DCE - Logging and Debugging Guide.md">
# Artifact A12: DCE - Logging and Debugging Guide
# Date Created: Cycle 19
# Author: AI Model & Curator
# Updated on: C126 (Add section on truncated logging)

- **Key/Value for A0:**
- **Description:** Explains how to access and use the integrated logging solution for debugging the extension's backend and frontend components.
- **Tags:** logging, debugging, troubleshooting, development, output channel

## 1. Purpose

This document provides instructions on how to access and use the logging features built into the Data Curation Environment (DCE) extension. Effective logging is crucial for diagnosing performance issues, tracking down bugs, and understanding the extension's behavior during development.

## 2. Two Primary Log Locations

There are two separate places to look for logs, depending on where the code is running.

### Location 1: The "Debug Console" (For `console.log`)

This is where you find logs from the **backend** (the extension's main Node.js process).

-   **What you'll see here:** `console.log()` statements from files in `src/backend/` and `src/extension.ts`. This is useful for debugging the extension's core activation and services *before* the UI is even visible.
-   **Where to find it:** In your **main development window** (the one where you press `F5`), look in the bottom panel for the **"DEBUG CONSOLE"** tab.

    ```
    -----------------------------------------------------------------------------------
    | PROBLEMS    OUTPUT    DEBUG CONSOLE    TERMINAL                                 |
    |---------------------------------------------------------------------------------|
    |                                                                                 |
    |  > Congratulations, your extension "Data Curation Environment" is now active!   |
    |  > FSService watcher initialized.                                               |
    |  ...                                                                            |
    -----------------------------------------------------------------------------------
    ```

### Location 2: The "Output" Channel (For Centralized Logging)

This is the primary, centralized log for the entire extension, including messages from the **frontend (WebView)**.

-   **What you'll see here:** Formatted log messages from both the backend (`LoggerService`) and the frontend (`logger.ts`). All messages are prefixed with a level (`[INFO]`, `[WARN]`, `[ERROR]`) and a timestamp. Frontend messages are also prefixed with `[WebView]`.
-   **Where to find it:** In the **"[Extension Development Host]" window** (the new window that opens after you press `F5`), follow these steps:
    1.  **Open the Panel:** Press `Ctrl+J` (or `Cmd+J` on Mac).
    2.  **Navigate to the "OUTPUT" Tab.**
    3.  In the dropdown menu on the right, select **`Data Curation Environment`**.

    ```
    -----------------------------------------------------------------------------------
    | PROBLEMS    OUTPUT    DEBUG CONSOLE    TERMINAL                                 |
    |---------------------------------------------------------------------------------|
    |                                                 [Data Curation Environment v]   |
    |                                                                                 |
    |  [INFO] [2:30:00 PM] Services initialized.                                      |
    |  [INFO] [2:30:01 PM] Received request for workspace files.                      |
    |  [INFO] [2:30:01 PM] [WebView] Initializing view and requesting workspace files.|
    |  [INFO] [2:30:01 PM] Scanning for files with exclusion pattern: ...             |
    |  ...                                                                            |
    -----------------------------------------------------------------------------------
    ```

## 3. Tactical Debugging with Logs (C93)

When a feature is not working as expected, especially one that involves communication between the frontend and backend, the most effective debugging technique is to add **tactical logs** at every step of the data's journey.

### Case Study: Fixing the "Associated Files" Parser (Cycle 93)

-   **Problem:** The UI was incorrectly reporting that files from a parsed AI response did not exist in the workspace.
-   **Data Flow:**
    1.  **Frontend (`view.tsx`):** User clicks "Parse All".
    2.  **Frontend (`response-parser.ts`):** Raw text is parsed into a list of relative file paths (e.g., `src/main.ts`).
    3.  **IPC (`RequestFileExistence`):** The list of relative paths is sent to the backend.
    4.  **Backend (`fs.service.ts`):** The backend receives the list and compares it against its own list of known workspace files, which are stored as absolute paths (e.g., `c:/project/src/main.ts`). The comparison fails.

## 4. Truncated Logging for Large Content (C126)

To prevent the output channel from becoming overwhelmed with large blocks of text (e.g., entire file contents), a logging utility has been implemented to truncate long strings.

-   **Behavior:** When a service logs a large piece of content (like a code block for syntax highlighting), it will use the `truncateStringForLogging` utility.
-   **Format:** If a string is longer than a set threshold (e.g., 100 characters), it will be displayed in the logs in a format like this:
    `[First 50 characters]...[Last 50 characters]`
-   **Benefit:** This keeps the logs clean and readable, allowing you to see that a large piece of data was processed without having its entire content flood the output. You can still see the beginning and end of the content to verify its identity.
</file>

<file path="src/Artifacts/A13. DCE - Phase 1 - Right-Click Context Menu.md">
# Artifact A13: DCE - Phase 1 - Right-Click Context Menu
# Date Created: C19
# Author: AI Model
# Updated on: C131 (Add Create File action for non-existent associated files)

- **Key/Value for A0:**
- **Description:** A plan for implementing standard file explorer context menu actions (e.g., Rename, Delete, Copy Path) in the custom file tree and other UI lists.
- **Tags:** feature plan, context menu, right-click, file operations, ux, phase 1

## 1. Overview & Goal

To enhance the user experience and make the Data Curation Environment a more complete replacement for the native VS Code explorer, this feature adds standard right-click context menus. The goal is to provide essential file and list management operations directly within our extension's view, reducing the need for users to switch contexts for common tasks.

This plan covers three distinct context menus: one for the main file tree, one for the "Selected Items" list, and one for the "Associated Files" list in the Parallel Co-Pilot Panel.

## 2. Main File Tree Context Menu

| ID | User Story | Acceptance Criteria |
|---|---|---|
| US-01 | **Copy Path** | As a user, I want to right-click a file or folder and copy its absolute or relative path to my clipboard, so I can easily reference it elsewhere. | - Right-clicking a node in the file tree opens a context menu. <br> - The menu contains "Copy Path" and "Copy Relative Path" options. <br> - Selecting an option copies the corresponding path string to the system clipboard. |
| US-02 | **Rename File/Folder** | As a user, I want to right-click a file or folder and rename it, so I can correct mistakes or refactor my project structure. | - The context menu contains a "Rename" option. <br> - Selecting it turns the file/folder name into an editable input field. <br> - Pressing Enter or clicking away saves the new name. <br> - The underlying file/folder is renamed on the file system. <br> - The file tree updates to reflect the change. |
| US-03 | **Delete File/Folder** | As a user, I want to right-click a file or folder and delete it, so I can remove unnecessary files from my project. | - The context menu contains a "Delete" option. <br> - Selecting it shows a confirmation dialog to prevent accidental deletion. <br> - Upon confirmation, the file or folder (and its contents, recursively) is moved to the trash/recycling bin. <br> - The file tree updates to reflect the change. |
| US-04 | **Reveal in OS Explorer** | As a user, I want to right-click a file or folder and have it revealed in the native OS file explorer, so I can interact with it outside of VS Code. | - The context menu contains a "Reveal in File Explorer" (or "Reveal in Finder" on macOS) option. <br> - Selecting it opens the parent directory of the item in the **operating system's default file manager** (e.g., Windows File Explorer) with the item selected. This should not simply switch to the VS Code Explorer tab. |
| US-05 | **New File/Folder** | As a user, I want to create new files and folders from the toolbar or context menu in the correct location, so I can build out my project structure without leaving the view. | - The header toolbar has "New File" and "New Folder" buttons. <br> - Clicking either prompts for a name. <br> - The new file/folder is created in the directory of the currently *active/highlighted* item in the tree. <br> - If the active item is a file, the new item is created in that file's parent directory. <br> - If no item is active, it defaults to the workspace root. <br> - The file tree automatically refreshes. |

## 3. "Selected Items" Panel Context Menu

| ID | User Story | Acceptance Criteria |
|---|---|---|
| US-06 | **Select All/Deselect All** | As a user, I want to right-click in the "Selected Items" panel to quickly select or deselect all items in the list, so I can perform batch removal operations more efficiently. | - Right-clicking anywhere within the list of selected files opens a context menu. <br> - The menu contains a "Select All" option. <br> - Clicking "Select All" highlights every item in the list, updating the "Remove selected" button count. <br> - The menu also contains a "Deselect All" option. <br> - Clicking "Deselect All" clears all selections in the list. |

## 4. "Associated Files" List Actions (C131)

| ID | User Story | Acceptance Criteria |
|---|---|---|
| US-07 | **Create Missing File** | As a developer, when an AI response refers to a file that doesn't exist, I want an easy way to create it directly from the "Associated Files" list, so I can quickly implement the AI's suggestion for a new file. | - In the "Associated Files" list, a file that does not exist is marked with an 'âœ—'. <br> - When I hover over this item, a "Create File" button appears next to it. <br> - Clicking the button creates a new, empty file at that path in the workspace. <br> - The file tree and the "Associated Files" list automatically refresh, and the indicator changes to a 'âœ“'. |

## 5. Technical Implementation Plan

-   **Main Tree Menu:** Implemented in `TreeView.tsx` and `ContextMenu.tsx` using an `onContextMenu` event handler and state management to control visibility and position.
-   **"Selected Items" Menu (C37):** Implemented in `SelectedFilesView.tsx` with its own context menu state and handlers for "Select All" / "Deselect All".
-   **"Create Missing File" Action (C131):**
    1.  **IPC:** Create a new `ClientToServerChannel.RequestCreateFile` channel with a payload of `{ filePath: string }`.
    2.  **Backend (`file-operation.service.ts`):** Implement `handleCreateFileRequest`. It will receive the relative path, resolve it to an absolute path, and use `vscode.workspace.fs.writeFile` with an empty `Uint8Array` to create the file. The file watcher will trigger a refresh.
    3.  **Frontend (`view.tsx`):** In the "Associated Files" list rendering logic, if a file does not exist (`!fileExistenceMap.get(file)`), render a "Create File" button. The button will be visible on hover. Its `onClick` handler will send the new IPC message.
</file>

<file path="src/Artifacts/A14. DCE - Ongoing Development Issues.md">
# Artifact A14: DCE - Ongoing Development Issues
# Date Created: C20
# Author: AI Model & Curator
# Updated on: C23 (Add issues for selection persistence and remove button)

- **Key/Value for A0:**
- **Description:** A tracking document for recurring or persistent issues that need to be monitored across development cycles until they are confirmed as resolved.
- **Tags:** bugs, tracking, issues, logging, node_modules, performance

## 1. Purpose

This artifact serves as a centralized list to track ongoing and recurring issues during the development of the Data Curation Environment (DCE) extension. This ensures that persistent problems are not forgotten and are actively monitored across cycles until a definitive solution is implemented and verified.

## 2. Active Issues

---

### Issue #5: Selection State is Not Persistent

-   **Symptom:** When the user makes selections in the "Data Curation" view, then switches to another VS Code tab and back, all selections are lost.
-   **First Reported:** Cycle 23
-   **Status (C23):** **Active.** The frontend state for `selectedFiles` is not being persisted in the VS Code `workspaceState`.
-   **Next Steps (C23):** Implement a mechanism to save the `selectedFiles` array to `workspaceState` on every change and load it when the view is initialized. This will involve both frontend (`view.tsx`) and backend (`selection.service.ts`) changes.

---

### Issue #6: "Remove selected" Button is Non-Functional

-   **Symptom:** In the "Selected Items" view, selecting one or more files and clicking the "Remove selected" button does not remove them from the list or from the main selection. It also causes the file tree in the main view to collapse.
-   **First Reported:** Cycle 23
-   **Status (C23):** **Active.** The logic in `removePathsFromSelected` or the way its result is being used to update the state is flawed. The tree collapsing indicates an improper state update is causing a major re-render.
-   **Next Steps (C23):** Debug the `removePathsFromSelected` function in `FileTree.utils.ts`. Add logging to the `onClick` handler in `SelectedFilesView.tsx` to trace the data flow. Fix the state update to prevent the side-effect of collapsing the tree.

---

### Issue #1: Logging Visibility

-   **Symptom:** The custom "Data Curation Environment" output channel is not visible in the "OUTPUT" tab's dropdown menu in the Extension Development Host window. This prevents the primary logging mechanism from being used for debugging.
-   **First Reported:** Cycle 19
-   **Status (C23):** **Resolved (C21).** The issue was caused by an early-exit error during extension activation. Adding robust `try...catch` blocks around service initializations in `extension.ts` allowed the extension to fully load, making the output channel visible.

---

### Issue #2: `node_modules` Exclusion and Performance

-   **Symptom:** The `node_modules` directory is included in file tree scans, leading to incorrect file and token counts and a significant performance delay.
-   **First Reported:** Cycle 15 (and earlier)
-   **Status (C23):** **Resolved (C20).** The `vscode.workspace.findFiles` call in `fs.service.ts` was updated with a more robust glob pattern `'{**/node_modules/**,**/dist/**,**/out/**,**/.git/**,**/flattened_repo.md}'` which now correctly excludes these directories.

---

### Issue #3: Incorrect Image Token Counting

-   **Symptom:** Image files are being assigned a token count instead of displaying their file size.
-   **First Reported:** Cycle 18
-   **Status (C23):** **Resolved (C20).** The logic in `fs.service.ts` was corrected to identify images by extension, set `tokenCount` to 0, and get their `sizeInBytes`. The frontend (`FileTree.tsx`) now uses an `isImage` flag to display the formatted byte size instead of tokens.

---

### Issue #4: File Tree Caching and Refresh Behavior

-   **Symptom:** The file tree reloaded from scratch on every tab switch and did not auto-update on file changes.
-   **First Reported:** Cycle 19
-   **Status (C23):** **Resolved (C20).** A frontend cache was implemented by changing the `useEffect` dependency array. A backend `FileSystemWatcher` was implemented in `fs.service.ts` to detect changes and push updates to the client, triggering a refresh.
</file>

<file path="src/Artifacts/A149. Local LLM Integration Plan.md">
# Artifact: A149. Local LLM Integration Plan
# Updated on: C1280 (Add documentation for REMOTE_LLM_URL environment variable.)
# Updated on: C1217 (Update architecture to reflect that @Ascentia now uses a streaming Socket.IO event.)
# Updated on: C1216 (Reflect change from /chat/completions to /completions endpoint for chatbot streaming.)
# Date Created: Cycle 1211
# Author: AI Model

## 1. Overview & Goal

This document outlines the technical plan for integrating a locally hosted Large Language Model (LLM) into the "AI Ascent" game. The goal is to create a secure and robust connection between the game client/server and a local LLM endpoint (like one provided by LM Studio) to power new, dynamic gameplay features.

This integration will enable:
1.  An in-game helper bot, `@Ascentia`, that can answer player questions about the game.
2.  Interactive sessions where players can "talk" to their own AI products.
3.  A new "Poetry Battle" PvP competition between players' chatbot products.

## 2. Core Architecture: Backend Proxy

To ensure security and control, the game client will **never** directly call the local LLM endpoint. All communication will be routed through a dedicated backend API endpoint or WebSocket handler that acts as a proxy.

### 2.1. Rationale for a Backend Proxy
*   **Security:** Prevents malicious clients from directly accessing or overloading the local LLM server. It keeps the endpoint address and any potential API keys hidden from the client.
*   **Control:** Allows the server to inject, modify, or augment prompts before they are sent to the LLM. This is critical for:
    *   Adding system prompts and context for the `@Ascentia` helper bot.
    *   Injecting parameters to simulate quality degradation for the Poetry Battle.
    *   Enforcing rate limiting and preventing abuse.
*   **Flexibility:** The client-facing API remains consistent even if the underlying LLM provider or endpoint changes in the future.
*   **State Management:** The server can access the game's database (`prisma`) to fetch context for prompts (e.g., player stats, game rules from documentation artifacts).

### 2.2. Implementation: API Handlers in `server.ts`
*   The existing Express server (`src/server.ts`) will handle all LLM-related requests.
*   **Socket.IO `'start_ascentia_stream'` event:** This event is now used for all `@Ascentia` queries. It provides a streaming response for a better user experience.
*   **Socket.IO `'start_chatbot_stream'` event:** This event will be used for all streaming requests, specifically for the "Chat with Service" feature.
*   **`/api/llm/proxy` (POST):** This endpoint now handles only non-streaming, single-turn requests for features like the Player LLM Terminal.
*   The handlers for these routes and events will:
    1.  Authenticate the user session.
    2.  Based on the request's `context`, construct a final prompt string, potentially adding system instructions, game rules, or degradation parameters.
    3.  Use a server-side `fetch` to send the final, formatted request to the appropriate local LLM endpoint specified in an environment variable.
    4.  **For streaming:** The handler will read the `ReadableStream`, parse the SSE chunks, and emit the relevant `_stream_chunk` and `_stream_end` events back to the originating client socket.
    5.  **For non-streaming:** The handler will return the full response in the JSON body.

## 3. Local LLM Server Configuration (LM Studio)

### 3.1. Environment Variables (`.env` file)

To allow for flexible connections to different LLM servers (local, remote on the same network, or even production endpoints), the `server.ts` logic will prioritize URLs in the following order:

1.  **`REMOTE_LLM_URL` (NEW):** Use this to specify the address of an LLM running on a different machine on your local network. This is ideal for a two-PC development setup.
    *   **Example:** `REMOTE_LLM_URL=http://192.168.1.85:1234`
2.  **`LOCAL_LLM_URL`:** The standard variable for an LLM running on the same machine as the game server.
    *   **Example:** `LOCAL_LLM_URL=http://127.0.0.1:1234`
3.  **Hardcoded Default:** If neither environment variable is set, the server will fall back to `http://127.0.0.1:1234`.

The server will log which URL it is using upon startup for easy debugging.

### 3.2. Recommended Model & Settings
*   **Model:**
    *   **Identifier:** `qwen/qwen3-30b-a3b`
    *   **Context Length:** 32,768
*   **Server:**
    *   **Address:** Match the address in your `.env` file (e.g., `http://192.168.1.85:1234`).
    *   **Enable "Serve on Local Network"** in LM Studio if you are using `REMOTE_LLM_URL`.
    *   **Preset:** OpenAI API
*   **Hardware & Performance:**
    *   **GPU Offload:** Max
*   **Inference Parameters (Default for Creative/Chat Tasks):**
    *   **Temperature:** 0.8
    *   **Top K Sampling:** 40
    *   **Repeat Penalty:** 1.1
    *   **Top P Sampling:** 0.95
*   **Prompt Format:** For chatbot conversations sent to the `/v1/completions` endpoint, the prompt must be manually constructed using the model's chat template.

## 4. State Management: `llmStore.ts`

A new Zustand store will be created to manage the state of LLM-related interactions.

*   **`src/state/llmStore.ts`**
*   **State:**
    *   `isPlayerLlmTerminalOpen: boolean`
    *   `isPlayerChatbotInterfaceOpen: boolean`
    *   `isPoetryBattleViewerOpen: boolean`
    *   `productIdForInteraction: string | null`
    *   `activePoetryBattle: PoetryBattleState | null`
*   **Actions:**
    *   `openLlmTerminal(productId)`
    *   `openChatbotInterface(productId)`
    *   `closeInteractions()`
    *   ...and other actions for managing poetry battles.

## 5. New Files & Components

*   **Frontend UI:**
    *   `src/components/menus/llm/PlayerLlmTerminal.tsx`
    *   `src/components/menus/llm/PlayerChatbotInterface.tsx`
    *   `src/components/menus/llm/PoetryBattleViewer.tsx`
*   **Game Logic:** `src/game/systems/PoetryBattleSystem.ts`
*   **State:** `src/state/llmStore.ts`

This plan establishes a secure and extensible foundation for integrating LLM-powered features into AI Ascent.
</file>

<file path="src/Artifacts/A15. DCE - Phase 1 - Multi-Select & Sorting Feature Plan.md">
# Artifact A15: DCE - Phase 1 - Multi-Select & Sorting Feature Plan
# Date Created: Cycle 22
# Author: AI Model
# Updated on: C40 (Documented RCA and fix for batch removal bug)

- **Key/Value for A0:**
- **Description:** Details the requirements for multi-selection (click, Ctrl, Shift) in both the main file tree and the "Selected Items" panel, and multi-level column sorting.
- **Tags:** feature plan, multi-select, sorting, list view, ux, phase 1

## 1. Overview & Goal

To elevate the Data Curation Environment beyond basic functionality, this plan introduces advanced list-interaction features common in modern applications. The goal is to provide users with powerful and intuitive tools for managing their file selections, mirroring the behavior of native operating system file explorers. This includes robust multi-selection capabilities in both the main file tree and the "Selected Items" panel, and comprehensive sorting for the "Selected Items" list.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| US-01 | **"Selected Items" Multi-Selection** | As a curator, after selecting a large folder, I want to quickly remove a small group of unwanted files from the "Selected Items" list using standard Shift-click and Ctrl-click, so I don't have to uncheck them one by one in the main tree. | - Clicking a single item in the "Selected Items" list selects it and deselects all others. <br> - Ctrl-clicking an item toggles its selection state without affecting other items. <br> - Shift-clicking an item selects the range of items between the last-clicked anchor item and the current one. The anchor is set by the last non-Shift click. <br> - A "Remove Selected" button acts on all currently selected items in this list. |
| US-02 | **"Selected Items" Column Sorting** | As a curator, I want to sort the "Selected Items" list by file name or token count, so I can easily find specific files or identify the largest contributors to my context. | - The "Selected Items" panel has a header row with clickable "File" and "Tokens" labels. <br> - Clicking a column header sorts the list by that column. <br> - Clicking the same header again reverses the sort direction (ascending/descending). <br> - A visual indicator (e.g., an arrow) shows the current sort column and direction. <br> - The default, initial sort is by Token Count, descending. |
| US-03 | **"Selected Items" Multi-Layer Sorting** | As a curator, I want to apply a secondary sort, so I can group my selected files by type and then see the largest files within each group. | - The sorting mechanism supports at least two levels of sorting. <br> - The UI provides a way to define a primary and secondary sort key (e.g., Shift-clicking a second column header). <br> - The list first organizes by the primary key, then sorts items within those groups by the secondary key. For example, sort by Type (asc), then by Token Count (desc). |
| US-04 | **Main Tree Multi-Selection** | As a user, I want to select multiple files and folders in the main "Data Curation" file tree using standard OS conventions (Ctrl/Shift click), so I can perform context menu actions (like Delete) on multiple items at once. | - Standard multi-selection is implemented in the main file tree. <br> - This selection is a separate state from the checkbox state and is used for contextual actions, not for flattening. <br> - Right-clicking on any item within a multi-selected group opens a context menu that applies its actions to all selected items. <br> - **(Bug C31):** Ctrl-click is non-functional. Shift-click is inconsistent and difficult to use. |
| US-05 | **"As-Is" Sorting** | As a user, I want to be able to revert the "Selected Items" list to its default sort order, so I can see the files as they appear in the native VS Code explorer. | - A sort option for "Default" or "As-Is" is available. <br> - Selecting it sorts the items based on their original file system order (folders first, then files, all alphabetized). |

## 3. Technical Implementation Plan

1.  **`SelectedFilesView.tsx` Refactor:**
    *   **State Management:** Introduce new state variables to manage selection, sorting, and multi-selection.
        *   `const [selection, setSelection] = useState<Set<string>>(new Set());`
        *   `const [selectionAnchor, setSelectionAnchor] = useState<string | null>(null);` // For stable shift-click
        *   `const [sortConfig, setSortConfig] = useState<{ key: string; direction: 'asc' | 'desc' }[]>([{ key: 'tokenCount', direction: 'desc' }]);`
    *   **Event Handling:** Implement a comprehensive `onClick` handler for list items that inspects `event.ctrlKey` and `event.shiftKey`. A non-modifier click will set both the `selection` and the `selectionAnchor`. A shift-click will select from the `selectionAnchor` to the current item.
    *   **Sorting Logic:** The `useMemo` hook that sorts the `selectedFileNodes` prop will be updated to handle an array of `sortConfig` objects. It will perform a stable sort, iterating through the sort criteria until a non-zero comparison result is found. A new "Type" column will be added, requiring a utility to extract the file extension.

2.  **Batch Removal Logic (`FileTree.utils.ts`):**
    *   **Root Cause of C40 Bug:** The `removePathsFromSelected` function was buggy. It iterated through the list of files to remove, calling the single-item removal utility (`addRemovePathInSelectedFiles`) on each. This created a race condition where the first removal would perform a "subtractive uncheck" (e.g., removing `src` and adding back all its other children), drastically changing the selection state that subsequent iterations of the loop were relying on.
    *   **Codified Solution (C40):** The `removePathsFromSelected` function will be rewritten to be non-iterative and set-based. It will calculate the final desired state in a single pass by determining the full set of effectively selected files, removing the unwanted files from that set, and then "compressing" the remaining set of files back into the most efficient list of parent directories and individual files. This atomic approach is more robust and avoids the state mutation bug.

3.  **`FileTree.tsx` & `TreeView.tsx` (Main Tree Multi-Select):**
    *   This is a more complex task that mirrors the `SelectedFilesView` implementation but within a recursive tree structure.
    *   A new selection state for contextual actions (`const [contextSelection, setContextSelection] = useState<Set<string>>(new Set())`) will be managed at the top level (`view.tsx`).
    *   The selection state and handler functions will need to be passed down through `FileTree` to `TreeView`.
    *   **(Fix for C31):** The `handleNodeClick` event handler in `TreeView.tsx` must be corrected. The anchor for shift-click (`lastClickedPath`) must only be updated on a click *without* the Shift key pressed. The logic for Ctrl-click must be revised to correctly toggle a path's inclusion in the selection set without clearing other selections.
    *   The `onContextMenu` handler will need to be updated to check if the right-clicked node is part of the current `contextSelection` and pass the entire selection to the backend if an action is chosen.
</file>

<file path="src/Artifacts/A16. DCE - Phase 1 - UI & UX Refinements Plan.md">
# Artifact A16: DCE - Phase 1 - UI & UX Refinements Plan
# Date Created: Cycle 22
# Author: AI Model
# Updated on: C43 (Add Expand All button)

- **Key/Value for A0:**
- **Description:** Covers visual and usability improvements like fixing panel layouts, resolving overflow bugs, adding loading indicators, and improving scrollbar visibility.
- **Tags:** feature plan, ui, ux, layout, bug fix, loading indicator, phase 1

## 1. Overview & Goal

This document outlines a series of user interface (UI) and user experience (UX) refinements identified during playtesting. The goal is to address layout bugs, provide better visual feedback to the user, and improve the overall professional feel of the extension. These changes focus on fixing immediate usability problems and making the extension more intuitive to operate.

## 2. User Stories & Issues

| ID | User Story / Issue | Acceptance Criteria |
|---|---|---|
| UI-01 | **Header Layout Bug** | As a user, I want the header of the "Data Curation" panel to be compact, without the extra vertical space between the title and the toolbar buttons, so it looks clean and professional. | - The vertical gap between the view title row and the toolbar button row is removed. <br> - The header area takes up minimal vertical space. <br> - This is a CSS fix, likely involving adjusting `padding`, `margin`, or `gap` in the flex container. |
| UI-02 | **"Selected Items" Overflow Bug** | As a user, when I select many files, I want the "Selected Items" list to scroll within its panel instead of running off the screen behind the "Flatten Context" footer, so I can see and manage all my selections. | - The "Selected Items" panel has a defined `max-height`. <br> - When the content exceeds this height, a vertical scrollbar appears. <br> - The panel never overlaps or pushes the footer out of view. <br> - This is a CSS fix involving `flex-grow`, `flex-shrink`, `min-height: 0` on the file tree container, and `overflow-y: auto` on the list container. |
| UI-03 | **Resizable "Selected Items" Panel** | As a user, I want to be able to vertically resize the "Selected Items" panel, so I can see more or fewer items as needed for my current task. | - A draggable handle or resizer element is added to the top border of the "Selected Items" panel. <br> - Clicking and dragging this handle adjusts the `height` or `max-height` of the panel. <br> - The main file tree above it resizes accordingly to fill the remaining space. |
| UI-04 | **Visible Loading State** | As a user, when I perform a slow action like renaming a file or refreshing the explorer, I want to see a loading indicator, so I have clear feedback that the system is working and not frozen. | - A loading state (e.g., `isLoading`) is added to the main view's state. <br> - This state is set to `true` when a file system scan begins (e.g., on initial load or refresh). <br> - A loading indicator (e.g., a spinning icon) is displayed in the UI (e.g., in the header toolbar) while `isLoading` is true. <br> - The state is set to `false` when the file data is received from the backend. |
| UI-05 | **Improved Scrollbar Gutter** | As a user, I find it difficult to distinguish between the extension's internal scrollbar and the main VS Code scrollbar when they are side-by-side. I want a clearer visual separation between them. | - A subtle vertical border (`border-right`) is added to the main file tree container. <br> - This creates a persistent, visible dividing line between the two scrollable areas, making it easier to position the mouse. |
| UI-06 | **Expand All Button** | As a user, I want an "Expand All" button in the toolbar, so I can quickly see all files in the project without manually clicking every folder. | - An "Expand All" button is added to the main header toolbar. <br> - Clicking it expands every collapsed folder in the file tree. <br> - The button complements the existing "Collapse All" button. |

## 3. Technical Implementation Plan

1.  **Layout Fixes (`view.scss`):**
    *   **Header:** Inspect the `.view-header` and `.toolbar` classes. Remove any unnecessary `margin` or `padding`. Consolidate into a single flex container with `justify-content: space-between` if the title is to be included, or simply adjust the container of the toolbar.
    *   **Overflow:** This is a classic flexbox problem. The main container (`.view-container`) should be `display: flex; flex-direction: column; height: 100vh;`. The content area (`.file-tree-container`) must have `flex-grow: 1;` and crucially `min-height: 0;` to allow it to shrink. The "Selected Items" panel (`.selected-files-panel`) should have `flex-shrink: 0;` and `overflow-y: auto;` on its list container.
    *   **Scrollbar Gutter:** Add `border-right: 1px solid var(--vscode-panel-border);` to the `.file-tree-container`.

2.  **Loading Indicator (`view.tsx`):**
    *   Add `const [isLoading, setIsLoading] = useState(true);`.
    *   Set `setIsLoading(true)` at the start of the `requestFiles` function.
    *   Set `setIsLoading(false)` inside the `handleFileResponse` message handler after files are received and set.
    *   In the JSX for the `.toolbar`, add conditional rendering: `{isLoading && <SpinnerComponent />}`. The spinner can be an SVG or a component using `react-icons`.

3.  **Resizable Panel:**
    *   This is the most complex part of this plan. It typically requires a custom React hook or component.
    *   An invisible `div` will be placed on the top border of the panel.
    *   `onMouseDown`, `onMouseMove`, and `onMouseUp` event listeners will be used to track the drag gesture and calculate the new height for the panel.
    *   The height will be applied as an inline style to the panel.
    *   This feature will be implemented after the more critical bug fixes are complete.

4.  **Expand All (`view.tsx`, `TreeView.tsx`):**
    *   Add an "Expand All" button to the toolbar in `view.tsx`.
    *   Add a new state trigger: `const [expandAllTrigger, setExpandAllTrigger] = useState(0);`.
    *   The button's `onClick` handler will call `setExpandAllTrigger(c => c + 1)`.
    *   Pass the trigger down as a prop to `TreeView.tsx`.
    *   In `TreeView.tsx`, a `useEffect` will listen for changes to `expandAllTrigger`. When it fires, it will recursively traverse the `data` prop, collect all directory paths, and call `setExpandedNodes` with the full list.
</file>

<file path="src/Artifacts/A17. DCE - Phase 1 - Advanced Tree View Features.md">
# Artifact A17: DCE - Phase 1 - Advanced Tree View Features
# Date Created: Cycle 22
# Author: AI Model

- **Key/Value for A0:**
- **Description:** Outlines the plan for advanced tree view interactions, specifically the implementation of scrollable, self-contained views for large, expanded folders.
- **Tags:** feature plan, tree view, ux, scrollable, phase 1

## 1. Overview & Goal

The current file tree view expands vertically, which can create a poor user experience when a folder containing hundreds of files is opened. The entire view becomes excessively long, forcing the user to scroll a great distance to see files or folders below the expanded one. The goal of this feature is to innovate on the traditional tree view by containing the contents of a large expanded folder within a scrollable, "inline" window, preventing the main view from becoming unmanageable.

## 2. User Story

| ID | User Story | Acceptance Criteria |
|---|---|---|
| TV-01 | **Contained Folder Expansion** | As a user, when I expand a folder with a large number of children, I want its contents to appear in a scrollable sub-panel within the tree instead of pushing all subsequent items down, so I can browse the folder's contents without losing my place in the main file tree. | - When a folder is expanded, the extension checks the number of direct children. <br> - If the child count exceeds a certain threshold (e.g., 50), the children are rendered inside a nested, scrollable `div`. <br> - This `div` has a fixed `max-height`. <br> - A small 'x' icon is visible within this sub-panel. Clicking it closes the sub-panel and reverts the folder to the standard, fully expanded view for that session. |

## 3. Technical Implementation Plan

This is a significant UI/UX enhancement and will require careful implementation within the React component hierarchy.

1.  **Component (`TreeView.tsx`):**
    *   The core logic will reside in the `renderTreeNodes` function.
    *   **Threshold Check:** When rendering a directory node, check `if (node.children && node.children.length > FOLDER_CONTENT_THRESHOLD)`. The threshold will be a configurable constant.
    *   **State Management:** A new state variable will be needed to track which "large" folders have been reverted to the standard view by the user clicking the 'x' button. `const [standardViewFolders, setStandardViewFolders] = useState<Set<string>>(new Set());`
    *   **Conditional Rendering:**
        *   If the folder is expanded (`isExpanded`) AND its path is **not** in `standardViewFolders` AND it exceeds the threshold, render the children inside a special container:
            ```jsx
            <div className="large-folder-container" style={{ maxHeight: '300px', overflowY: 'auto' }}>
              <button onClick={() => setStandardViewFolders(prev => new Set(prev).add(node.absolutePath))}>X</button>
              <ul>{renderTreeNodes(node.children)}</ul>
            </div>
            ```
        *   Otherwise, render the children normally as is currently done:
            ```jsx
            <ul className="treenode-children">{renderTreeNodes(node.children)}</ul>
            ```

2.  **Styling (`view.scss`):**
    *   Create styles for `.large-folder-container`.
    *   It will need `position: relative`, a subtle `border` or `background-color` to distinguish it from the rest of the tree.
    *   The close button will need to be positioned appropriately within the container.

3.  **Performance Considerations:**
    *   This approach avoids virtualizing the entire tree, which is much more complex. It only contains the content of single, large folders.
    *   Rendering hundreds of nodes within the scrollable container might still have a minor performance impact on initial render, but it will be contained and will not affect the performance of the main tree's scrolling.
</file>

<file path="src/Artifacts/A18. DCE - Phase 1 - Active File Sync Feature Plan.md">
# Artifact A18: DCE - Phase 1 - Active File Sync Feature Plan
# Date Created: Cycle 24
# Author: AI Model
# Updated on: C44 (Add logic for suppressing auto-reveal after file operations)

- **Key/Value for A0:**
- **Description:** Details the requirements and implementation for automatically revealing and highlighting the active editor's file in the custom Data Curation file tree.
- **Tags:** feature plan, active file, sync, reveal, tree view, ux, phase 1

## 1. Overview & Goal

To create a more seamless and integrated experience, the Data Curation Environment's file tree should stay in sync with the user's focus in the main editor. Currently, selecting a file in the editor does not reflect in our custom view. The goal of this feature is to replicate the behavior of the native VS Code Explorer, where the active file is automatically revealed and highlighted in the file tree.

## 2. User Story

| ID | User Story | Acceptance Criteria |
|---|---|---|
| UX-01 | **Sync with Active Editor** | As a user, when I click on a file in the VS Code editor tabs or the native Explorer, I want the "Data Curation" file tree to automatically scroll to and highlight that file, so I can easily see its location in the project hierarchy and interact with its checkbox without manually searching for it. | - When the active text editor changes in VS Code, the new file is highlighted in the "Data Curation" tree view. <br> - All parent folders of the active file are automatically expanded to ensure it is visible. <br> - The file tree view scrolls so that the active file item is visible on the screen. |
| UX-02 | **Preserve View State** | As a user, after I perform an action that collapses the tree (e.g., "Collapse All") and then perform a file operation (e.g., drag-and-drop), I do not want the tree to automatically re-expand to reveal the active file, so my intended view state is respected. | - After a file operation (move, delete, rename, new file) triggers a refresh, the "Sync with Active Editor" feature is temporarily suppressed for the next event. <br> - This prevents the tree from re-expanding against the user's will. |

## 3. Technical Implementation Plan

1.  **Backend Listener (`extension.ts`):**
    *   Utilize the `vscode.window.onDidChangeActiveTextEditor` event listener in the `activate` function.
    *   This event provides the `TextEditor` object, from which `editor.document.uri.fsPath` can be extracted.
    *   When the event fires and an editor is present, the backend will normalize the file path (to use forward slashes) and send an IPC message to the webview containing the active file's path.

2.  **IPC Channel:**
    *   The existing `ServerToClientChannel.SetActiveFile` will be used.
    *   **(C44 Update)** The `ServerToClientChannel.ForceRefresh` channel's payload is updated from `{}` to `{ reason?: 'fileOp' | 'manual' }`.

3.  **Frontend View Logic (`TreeView.tsx`):**
    *   A `useEffect` hook in the `TreeView` component triggers whenever the `activeFile` prop changes.
    *   This effect is responsible for "revealing" the file by calculating all parent directory paths, adding them to the `expandedNodes` state, and then calling `scrollIntoView()` on the file's element ref.

4.  **Auto-Reveal Suppression Logic (C44):**
    *   **Backend (`fs.service.ts`):** The file watcher, upon detecting a change, will now send the `ForceRefresh` message with a payload: `{ reason: 'fileOp' }`.
    *   **Frontend (`view.tsx`):**
        *   A `useRef` flag (`suppressActiveFileReveal`) is used to track the suppression state.
        *   The message handler for `ForceRefresh` checks for the `fileOp` reason and sets the suppression flag to `true`, with a timeout to reset it.
        *   The message handler for `SetActiveFile` checks the flag. If `true`, it ignores the event, resets the flag, and prevents the `activeFile` state from being updated, thus preventing the reveal.

## 5. Debugging Notes & Regression Prevention

-   **Root Cause of C30 Regression:** The feature failed because of a path normalization mismatch. The `editor.document.uri.fsPath` property from the VS Code API returns paths with **backslashes (`\`)** on Windows. The frontend webview components, however, exclusively use and expect **forward slashes (`/`)** for path comparisons and manipulations.
-   **Codified Solution:** The path from the `onDidChangeActiveTextEditor` event **must** be normalized to use forward slashes *before* it is sent to the frontend via the IPC channel.
</file>

<file path="src/Artifacts/A189. Number Formatting Reference Guide.md">
# Artifact A189: Number Formatting Guide (K/M Suffixes & Dynamic Decimals)
# Date Created: Cycle 14
# Author: AI Model & Curator

- **Key/Value for A0:**
- **Description:** A standalone guide and utility script for formatting large numbers with K/M/B/T suffixes and dynamic decimal place adjustment for clean UI presentation.
- **Tags:** utility, script, formatting, numbers, ui, ux, javascript, typescript

## 1. Purpose

This artifact provides a set of robust, reusable TypeScript functions for formatting numbers in a user-friendly way. The core function, `formatLargeNumber`, intelligently converts large numbers into a compact format using suffixes like 'K' (thousands), 'M' (millions), 'B' (billions), and 'T' (trillions).

The key features of this utility are:
*   **Automatic Suffixing:** Automatically scales numbers and adds the appropriate suffix.
*   **Dynamic Decimal Precision:** Adjusts the number of decimal places shown based on the magnitude of the number, ensuring a clean and consistent look in the UI (e.g., `12.3K`, `123.5K`, `1.23M`).
*   **Handling of Small Numbers:** Gracefully handles numbers below 1,000 without applying a suffix.
*   **Specialized Wrappers:** Includes helper functions like `formatCurrency` and `formatCount` for common use cases.

## 2. Core Utility Functions (from `src/utils.ts`)

Below is the complete TypeScript code. You can save this as a `formatting.ts` file in a new project's `utils` directory.

```typescript
// src/common/utils/formatting.ts

const KMBT_SUFFIXES = ['', 'K', 'M', 'B', 'T', 'Q']; // Extend as needed

/**
 * Formats a large number with appropriate K/M/B/T suffixes and dynamic decimal places.
 * Handles very small near-zero numbers gracefully to avoid scientific notation.
 *
 * @param value The number to format.
 * @param decimalPlaces The base number of decimal places to aim for.
 * @returns A formatted string.
 */
export function formatLargeNumber(value: number | undefined | null, decimalPlaces: number = 2): string {
    if (value === null || value === undefined || isNaN(value) || !Number.isFinite(value)) {
        return '---';
    }
    if (value === 0) {
        return '0';
    }

    const VERY_SMALL_THRESHOLD = 1e-6; // 0.000001
    if (Math.abs(value) < VERY_SMALL_THRESHOLD) {
        return (0).toFixed(decimalPlaces);
    }

    const isNegative = value < 0;
    const absValue = Math.abs(value);

    let unitIndex = 0;
    let scaledValue = absValue;

    if (absValue < 1000) {
        return String(Math.round(value)); // Return whole number if less than 1000
    }

    if (absValue >= 1000) {
        unitIndex = Math.floor(Math.log10(absValue) / 3);
        unitIndex = Math.min(unitIndex, KMBT_SUFFIXES.length - 1);
        scaledValue = absValue / Math.pow(1000, unitIndex);
    }

    let adjustedDecimalPlaces = decimalPlaces;
    if (unitIndex > 0) { // If a suffix is used (K, M, B, T, Q)
        if (scaledValue >= 100) adjustedDecimalPlaces = Math.max(0, decimalPlaces - 2);
        else if (scaledValue >= 10) adjustedDecimalPlaces = Math.max(0, decimalPlaces - 1);
    } else { // No unit suffix (value < 1000)
        if (Math.abs(scaledValue) < 0.01 && scaledValue !== 0) {
            adjustedDecimalPlaces = Math.max(decimalPlaces, 4);
        } else if (Number.isInteger(scaledValue)) {
             adjustedDecimalPlaces = 0;
        }
    }

    const unit = KMBT_SUFFIXES[unitIndex] ?? '';
    let formattedValue = scaledValue.toFixed(adjustedDecimalPlaces);

    // Remove trailing .00 or .0
    if (adjustedDecimalPlaces > 0 && formattedValue.endsWith('0')) {
        formattedValue = formattedValue.replace(/\.?0+$/, '');
    }


    return `${isNegative ? '-' : ''}${formattedValue}${unit}`;
}```

## 3. Usage Examples

Here is how you can use these functions in your code:

```typescript
import { formatLargeNumber } from './path/to/formatting';

// formatLargeNumber examples
console.log(formatLargeNumber(123));        // "123"
console.log(formatLargeNumber(1234));       // "1.23K"
console.log(formatLargeNumber(12345));      // "12.3K"
console.log(formatLargeNumber(123456));     // "123K"
console.log(formatLargeNumber(1234567));    // "1.23M"
console.log(formatLargeNumber(9876543210)); // "9.88B"
console.log(formatLargeNumber(-54321));     // "-54.3K"
console.log(formatLargeNumber(0.0000001));  // "0.00"
```

## 4. Integration Guide

1.  **Copy the Code:** Save the code from Section 2 into a file named `formatting.ts` inside your project's `src/common/utils` directory.
2.  **Import and Use:** Import the function into your UI components.
    ```typescript
    import { formatLargeNumber } from '@/common/utils/formatting';

    const MyComponent = () => {
      const displayValue = formatLargeNumber(123456); // "123K"
      return <div>Tokens: {displayValue}</div>;
    };
    ```
</file>

<file path="src/Artifacts/A19. DCE - Phase 1 - Double-Click & Quick-Remove Feature Plan.md">
# Artifact A19: DCE - Phase 1 - File Interaction Plan (Click & Remove)
# Date Created: Cycle 26
# Author: AI Model
# Updated on: C28 (Changed interaction model from double-click to single-click to open files)

- **Key/Value for A0:**
- **Description:** Details the requirements for opening files by single-clicking them and quickly removing single files from the selection list via a mouse-over action.
- **Tags:** feature plan, single-click, open file, quick remove, ux, phase 1

## 1. Overview & Goal

To further align the Data Curation Environment with standard, intuitive user workflows, this plan introduces two high-impact interaction enhancements. The first is the ability to **single-click** any file to open it in the main editor, mimicking the native VS Code Explorer behavior. The second is a "quick-remove" feature in the "Selected Items" panel, allowing for rapid, single-click removal of files. The goal is to reduce friction and increase the speed at which a user can curate their context.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| UX-01 | **Single-Click to Open (Main Tree)** | As a user, I want to be able to single-click on a file in the main "Data Curation" file tree and have it open in the editor, so I can quickly view its contents just like in the native Explorer. | - A single click on a file item (not a folder) in the main file tree opens that file in the main VS Code editor pane. <br> - If the file is already open in a tab, the editor switches focus to that tab. <br> - A single click on a folder still expands or collapses it. |
| UX-02 | **Single-Click to Open (Selected List)** | As a user, I want to single-click a file in the "Selected Items" list to open it, so I can easily inspect the files that are contributing the most tokens to my context. | - A single click on a file item in the "Selected Items" list opens that file in the main VS Code editor pane. <br> - If the file is already open, focus is switched to its tab. |
| UX-03 | **Quick Remove from Selection** | As a user, after selecting a large folder, I want to quickly remove a single file from the "Selected Items" list with one click, so I don't have to select it and then click the "Remove Selected" button. | - In the "Selected Items" list, when I mouse over a file row, the row number (in the `#` column) is replaced by an 'X' icon. <br> - Clicking the 'X' icon immediately removes that single file from the selection. <br> - This action is equivalent to selecting only that file and clicking "Remove Selected". <br> - The mouse leaving the row restores the row number. |

## 3. Technical Implementation Plan

1.  **IPC Channel (`channels.enum.ts`, `channels.type.ts`):**
    *   The existing `ClientToServerChannel.RequestOpenFile` is sufficient.
    *   The `ChannelBody` remains `{ path: string }`.

2.  **Backend Handler (`on-message.ts`, `fs.service.ts`):**
    *   The existing handler for `RequestOpenFile` in `fs.service.ts` is sufficient. It uses `vscode.workspace.openTextDocument` and `vscode.window.showTextDocument`.

3.  **Frontend - Single-Click (`TreeView.tsx`, `SelectedFilesView.tsx`):**
    *   In `TreeView.tsx`, the main `onClick` handler (`handleToggleNode`) will be modified. It will now check if the clicked node is a file or a directory.
        *   If it's a file, it will call `clientIpc.sendToServer(ClientToServerChannel.RequestOpenFile, ...)`.
        *   If it's a directory, it will perform the existing expand/collapse logic.
    *   In `SelectedFilesView.tsx`, the `onDoubleClick` handler will be removed and the `onClick` handler will be simplified to *only* open the file, as the multi-selection logic is handled by checking for modifier keys (`ctrlKey`, `shiftKey`).

4.  **Frontend - Quick Remove (`SelectedFilesView.tsx`, `view.scss`):**
    *   **State:** A state variable will track the hovered item's path: `const [hoveredPath, setHoveredPath] = useState<string | null>(null);`.
    *   **Event Handlers:** Add `onMouseEnter` and `onMouseLeave` to the `<li>` element to update the hover state.
    *   **Conditional Rendering:** In the JSX for the index column, render conditionally: if the row is hovered, show an 'X' icon with an `onClick` handler; otherwise, show the row number.
    *   **Styling:** Add styles for the `.quick-remove` class in `view.scss` to ensure it's clickable and has appropriate hover effects.
    *   The `onClick` handler for the 'X' icon will call the existing `onRemove` prop and use `stopPropagation` to prevent the click from also selecting the row.
</file>

<file path="src/Artifacts/A2. DCE - Phase 1 - Context Chooser - Requirements & Design.md">
# Artifact A2: DCE - Phase 1 - Context Chooser - Requirements & Design
# Date Created: Cycle 1
# Author: AI Model
# Updated on: C46 (Remove requirement for ignoring binary files, per A29)

## 1. Overview

This document outlines the requirements for Phase 1 of the Data Curation Environment (DCE) project. The primary goal of this phase is to replace the manual, error-prone process of managing context via a `files_list.txt` with an intuitive, UI-driven approach within VS Code.

**Major Update (Cycle 2):** The analysis of the `The-Creator-AI-main` repository revealed an existing, highly-functional file tree component (`src/client/components/file-tree/FileTree.tsx`) with checkbox selection. The project requirements have been updated to reflect a shift from *building* this component from scratch to *analyzing, adapting, and integrating* the existing solution.

## 2. Functional Requirements

| ID | Requirement | User Story | Acceptance Criteria | Update (Cycle 2) |
|---|---|---|---|---|
| FR-01 | **Analyze Existing File Tree** | As a developer, I want to understand the capabilities of the `FileTree.tsx` component | - Analyze the component's props and state. <br> - Document its dependencies on other frontend components and backend services (`FSService`). <br> - Determine how checkbox state is managed and communicated. | **New** |
| FR-02 | **Display File Tree in View** | As a user, I want to see a tree of all files and folders in my workspace within a dedicated VS Code view. | - The view should accurately reflect the workspace's file system structure. <br> - It should respect `.gitignore` rules to hide irrelevant files. | **Adaptation.** The `FileTree.tsx` component and `FSService` already provide this. We need to ensure it's correctly instantiated in our extension's view. |
| FR-03 | **Checkbox Selection** | As a user, I want to select and deselect files and folders for my context using checkboxes. | - Every file and folder in the tree has a checkbox. <br> - Checking a folder checks all its children. <br> - Unchecking a folder unchecks all its children. <br> - A folder shows an "indeterminate" state if only some of its children are checked. | **Adaptation.** The reference component appears to support this logic. We must verify and adapt its state management (`selectedFiles` array). |
| FR-04 | **Flatten Selected Context** | As a user, I want a single button to package all my selected files into one context file. | - A "Flatten Context" button is present in the view. <br> - Clicking it triggers a process that reads the content of all checked files. <br> - The contents are concatenated into a single `flattened_repo.md` file in the project root. | **Implementation.** The logic for this will need to be implemented, using the state from the `FileTree` component as input for our enhanced `bootstrap-flattener.js` logic. |
| FR-05 | **Handle Binary Files** | As a user, I want to be able to select binary/image files to include their metadata in the context, without including their raw content. | - All files, including binary and image files, are selectable via their checkbox. <br> - When a binary/image file is selected and flattened, only its metadata (path, size, type) is included in `flattened_repo.md`. <br> - See `A29` for the full strategy. | **Revised (C46)** |
</file>

<file path="src/Artifacts/A20. DCE - Phase 1 - Advanced UX & Automation Plan.md">
# Artifact A20: DCE - Phase 1 - Advanced UX & Automation Plan
# Date Created: C27
# Author: AI Model
# Updated on: C73 (Adjust token count color scheme to make red the highest risk)

- **Key/Value for A0:**
- **Description:** Details plans for several UX enhancements, including auto-revealing the flattened file, showing selected counts in folder stats, and providing an option to auto-add new files to the selection.
- **Tags:** feature plan, ux, automation, reveal, statistics, auto-add, phase 1

## 1. Overview & Goal

This document outlines a series of advanced user experience (UX) and automation features designed to further streamline the data curation workflow. The goal is to reduce manual steps, provide more insightful contextual information, and make the extension's UI more flexible and powerful.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| UXA-01 | **Auto-Reveal Flattened File** | As a user, after I click "Flatten Context," I want the newly created `flattened_repo.md` file to be automatically selected and revealed in the file tree, so I can immediately open it without searching. | - After the `flattened_repo.md` file is created or updated, it becomes the `activeFile` in the Data Curation view. <br> - The tree view automatically expands and scrolls to show the `flattened_repo.md` file. |
| UXA-02 | **Contextual Selected Count** | As a user, when I have files selected inside a folder, I want to see a count of how many files are selected within that folder, displayed next to the folder's total file count, so I can understand my selection density at a glance. | - Next to a folder's total file count, a secondary count in parentheses `(x)` appears. <br> - `x` represents the number of files within that folder (recursively) that are part of the current selection. <br> - This count only appears if `x` is greater than 0 and less than the folder's total file count. |
| UXA-03 | **Minimize Selection Panel** | As a user, once I've made my selection, I want to minimize the "Selected Items" list to reclaim vertical space while keeping the "Flatten Context" button accessible, so I can focus on the main file tree. | - A minimize/expand button is present in the "Selected Items" panel header. <br> - Clicking it collapses the list of selected files, but the panel's header, toolbar, and the main footer (with the Flatten button) remain visible. <br> - Clicking it again expands the list to its previous state. |
| UXA-04 | **Auto-Add New Files** | As a user, I want to enable an "auto-add" mode where any new file I create in the workspace is automatically added to my current selection, so I don't have to break my coding flow to manually check the new file. | - A toggle button or checkbox exists in the UI to enable/disable "Auto-Add New Files" mode. <br> - When enabled, any file created in the workspace is automatically added to the `selectedFiles` list. <br> - The file system watcher is responsible for detecting file creation and triggering this logic. <br> - The state of this toggle is persisted in the workspace state. |
| UXA-05 | **Resizable Panels** | As a user, I want to be able to click and drag the divider between the main file tree and the "Selected Items" panel to vertically resize them, so I can customize the layout to my needs. | - The horizontal divider between the two main panels is a draggable handle. <br> - Dragging it up or down resizes both panels accordingly, while respecting their minimum and maximum height constraints. |
| UXA-06 | **Token Count Color Coding** | As a user, I want the items in the "Selected Items" list to be color-coded based on their token count, so I can immediately identify potentially problematic large files. | - List items have a background color that corresponds to their token count. <br> - **(C73 Update)** The color scheme indicates increasing risk: <br> - **0-8k tokens:** Green (Low risk). <br> - **8k-10k tokens:** Yellow (Slight risk). <br> - **10k-12k tokens:** Orange (Moderate risk). <br> - **12k+ tokens:** Red (High risk). <br> - A tooltip explains the color coding and associated risk. |
| UXA-07 | **Auto-Uncheck Empty Folder** | As a user, when I remove the last selected file from a folder via the "Selected Items" panel, I want the parent folder to become unchecked in the main file tree, so the UI state remains consistent. | - When a file removal action is processed, the logic checks if any sibling files of the removed file are still selected. <br> - If no siblings remain selected under a parent folder that was previously checked, that parent folder is also removed from the selection. |


## 3. Technical Implementation Plan

-   **Auto-Reveal (UXA-01):**
    -   Create a new IPC channel `ServerToClientChannel.FocusFile`.
    -   Backend (`flattener.service.ts`): After writing the file, send the `FocusFile` message with the file's absolute path. A small delay might be needed to allow the file watcher to trigger a UI refresh first.
    -   Frontend (`view.tsx`): Listen for `FocusFile` and call `setActiveFile` with the received path. The existing `useEffect` in `TreeView.tsx` will handle the reveal.
-   **Selected Count (UXA-02):**
    -   Frontend (`FileTree.tsx`): Implement a memoized recursive function that traverses a `FileNode`'s children and checks against the `selectedFiles` list to calculate the selected count. Render this count conditionally in the `renderFileNodeContent` function. This is a frontend-only calculation.
-   **Minimize Panel (UXA-03):**
    -   Frontend (`view.tsx`): Add a new state, `isSelectionListMinimized`.
    -   Frontend (`SelectedFilesView.tsx`): Add a button to the header that calls a prop function to toggle this state. Conditionally render the `<ul>` based on the state.
-   **Auto-Add Files (UXA-04):**
    -   Frontend (`view.tsx`): Add a toggle button and a state for this mode. When toggled, send an IPC message to the backend to update its persisted state.
    -   Backend (`selection.service.ts`): Store the toggle's state in `workspaceState`.
    -   Backend (`fs.service.ts`): The `onDidCreate` handler in the file watcher will check this state. If true, it will get the current selection, add the new file's path, and save it back using `selection.service.ts` before triggering the UI refresh.
-   **Token Count Coloring (UXA-06):**
    -   Frontend (`SelectedFilesView.tsx`): Create a helper function `getTokenBackgroundColor(tokenCount)` that returns an HSL color string based on the specified token ranges.
    -   Apply the returned color to the `<li>` element's `style` prop.
    -   Add a `title` attribute to the `<li>` to explain the risk associated with the token count.
-   **Auto-Uncheck Folder (UXA-07):**
    -   Frontend (`FileTree.utils.ts`): The `removePathsFromSelected` function will be enhanced. After calculating the new effective selection set, it will need to perform a check. For each removed path, it can traverse up the tree to find its parent directories. For each parent, it can check if any of its other children are still in the effective selection set. If not, the parent should not be included in the final compressed path list. This is complex and requires careful state calculation.
</file>

<file path="src/Artifacts/A21. DCE - Phase 1 - Feature Drift Analysis vs. VS Code Explorer.md">
# Artifact A21: DCE - Phase 1 - Feature Drift Analysis vs. VS Code Explorer
# Date Created: C28
# Author: AI Model
# Updated on: C39 (Update Keyboard Nav status to Complete)

- **Key/Value for A0:**
- **Description:** A comparative analysis documenting the functional and behavioral differences between the DCE custom file view and the native VS Code Explorer to guide future development and feature parity.
- **Tags:** feature plan, analysis, drift, ux, vs code explorer, parity

## 1. Overview & Goal

The primary goal of the Data Curation Environment (DCE) is to enhance, not replace, the core developer workflow. To minimize friction and maximize adoption, its custom file view must achieve a high degree of feature parity with the native VS Code Explorer. This document analyzes the "drift," or the set of features present in the native Explorer that are currently missing from the DCE view. This analysis will serve as a backlog and prioritization guide for future development cycles.

## 2. Feature Comparison Matrix

| Feature Category            | Native VS Code Explorer         | DCE (as of C39)        | Status & Notes                                                                                                                                              |
| --------------------------- | ------------------------------- | ---------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **File Display**            |                                 |                        |                                                                                                                                                             |
| Hierarchical Tree           | âœ…                              | âœ…                     | **Complete.** Core functionality is present.                                                                                                                |
| File/Folder Icons           | âœ…                              | âœ…                     | **Complete.** Icons match file types.                                                                                                                       |
| Active File Highlighting    | âœ…                              | âœ…                     | **Complete.**                                                                                                                                               |
| Problems/Git Status         | âœ… (Colors, badges)             | âœ…                     | **Complete.** Displays Git status colors/badges and problem indicators.                                                                                     |
| **Selection**               |                                 |                        |                                                                                                                                                             |
| Single-Click (Files)        | âœ… Opens file                   | âœ… Opens & Selects file| **Complete.** Aligns with native behavior.                                                                                                                  |
| Single-Click (Folders)      | âœ… Expands/Collapses            | âœ… Expands/Collapses   | **Complete.** |
| Multi-Select (Ctrl)         | âœ…                              | âœ…                     | **Complete.**                                                                                                                                               |
| Multi-Select (Shift)        | âœ… (Selects rows)               | âœ… (Selects rows)      | **Complete.**                                                                                                                                               |
| Select All (Ctrl+A)         | âœ… (In focused list)            | âœ…                     | **Complete.** The focus-stealing bug is now resolved, making `Ctrl+A` in the "Selected Items" list reliable.                                           |
| **Interaction**             |                                 |                        |                                                                                                                                                             |
| Drag and Drop               | âœ… (Move files/folders)         | âœ…                     | **Complete.**                                                                                                                                               |
| Right-Click Context Menu    | âœ… (Extensive options)          | âœ… (Basic + List actions) | **Partial.** DCE has basic file ops. Added "Select All" for lists in C37. Missing advanced options like `Open in Integrated Terminal`, `Compare...`.       |
| Keyboard Navigation         | âœ… (Arrows, Enter, Space)       | âœ…                     | **Complete (C39).** Arrow keys, Enter, and Spacebar now function as expected. The focus-stealing bug has been resolved.                                   |
| Inline Rename               | âœ… (F2 or slow double-click)    | âœ…                     | **Complete.** |
| **File Operations**         |                                 |                        |                                                                                                                                                             |
| New File / Folder           | âœ…                              | âœ…                     | **Complete.** |
| Delete (to Trash)           | âœ…                              | âœ…                     | **Complete.** |
| Cut / Copy / Paste          | âœ…                              | âŒ                     | **Missing.** Standard file system operations are not yet implemented.                                                                                       |
| Undo / Redo (Ctrl+Z)        | âœ…                              | âŒ                     | **Missing.** A critical feature for parity. Requires an action stack to reverse moves/deletes. Planned in A27.                                            |
| **Search & Filter**         |                                 |                        |                                                                                                                                                             |
| Filter by Name              | âœ… (Start typing)               | âœ…                     | **Complete.**                                                                                                                                               |

## 3. High-Priority Features for Future Cycles

Based on the analysis, the following features represent the most significant gaps in user experience and should be prioritized:

1.  **Undo / Redo (Ctrl+Z):** The ability to undo a file move or deletion is a fundamental expectation for any file manager and its absence is a major point of friction.
2.  **Cut / Copy / Paste:** Adding standard clipboard operations for files is a key missing piece of basic file management.
3.  **Expanded Context Menu:** Adding more of the native right-click options, especially `Open in Integrated Terminal` and `Compare Selected`, would significantly reduce the need for users to switch back to the native Explorer.
</file>

<file path="src/Artifacts/A22. DCE - Phase 1 - Search & Filter Feature Plan.md">
# Artifact A22: DCE - Phase 1 - Search & Filter Feature Plan
# Date Created: C29
# Author: AI Model

- **Key/Value for A0:**
- **Description:** Outlines the requirements and implementation for a search bar to filter the main file tree view by file or folder name.
- **Tags:** feature plan, search, filter, tree view, ux, phase 1

## 1. Overview & Goal

To improve navigation and usability in large projects, this feature introduces a search and filter capability to the Data Curation Environment. The goal is to allow users to quickly find specific files or folders by typing a part of their name, mirroring the incremental filtering behavior of the native VS Code Explorer.

## 2. User Story

| ID | User Story | Acceptance Criteria |
|---|---|---|
| SF-01 | **Filter File Tree** | As a user working in a large repository, I want to type in a search bar to filter the file tree in real-time, so I can quickly locate the files and folders I need without extensive scrolling. | - A search icon/button is present in the main header toolbar. <br> - Clicking the icon reveals a text input field. <br> - As I type into the input field, the file tree dynamically updates to show only the files and folders whose names match the search string. <br> - All parent directories of a matching file are also shown to preserve the tree structure. <br> - The search is case-insensitive. <br> - Clearing the search input restores the full, unfiltered tree. |

## 3. Technical Implementation Plan

1.  **Frontend - UI (`view.tsx`, `view.scss`):**
    *   Add a new state variable to the main `App` component: `const [filterTerm, setFilterTerm] = useState('');`.
    *   Add a search icon (`VscSearch`) to the header toolbar. A second state, `isSearchVisible`, can be used to toggle the visibility of the input field when the icon is clicked.
    *   The search `<input>` element's `value` will be bound to `filterTerm`, and its `onChange` handler will call `setFilterTerm`.

2.  **Frontend - Filtering Logic (`FileTree.tsx`):**
    *   The `FileTree` component will receive the `filterTerm` as a new prop.
    *   A `useMemo` hook will be used to compute the filtered tree whenever the source `data` or the `filterTerm` changes.
    *   This hook will call a new recursive filtering function:
        ```typescript
        function filterTree(nodes: FileNode[], term: string): FileNode[] {
            if (!term) return nodes;
            const lowerCaseTerm = term.toLowerCase();

            return nodes.reduce((acc, node) => {
                if (node.name.toLowerCase().includes(lowerCaseTerm)) {
                    // If the node itself matches, include it and all its children
                    acc.push(node);
                    return acc;
                }

                if (node.children) {
                    // If the node is a directory, filter its children
                    const filteredChildren = filterTree(node.children, term);
                    if (filteredChildren.length > 0) {
                        // If any children match, include the parent with its filtered children
                        acc.push({ ...node, children: filteredChildren });
                    }
                }
                return acc;
            }, [] as FileNode[]);
        }
        ```
    *   The `TreeView` component will then be rendered with this new, filtered data.

3.  **State Management:**
    *   The filtering is a pure frontend operation. No backend changes or IPC communication are required for this feature.
    *   The search term is transient UI state and does not need to be persisted.
</file>

<file path="src/Artifacts/A23. DCE - Phase 1 - Advanced Interactions (Keyboard & Drag-Drop) Plan.md">
# Artifact A23: DCE - Phase 1 - Advanced Interactions (Keyboard & Drag-Drop) Plan
# Date Created: C29
# Author: AI Model
# Updated on: C71 (Add Delete key functionality)

- **Key/Value for A0:**
- **Description:** Details the requirements for implementing full keyboard navigation and drag-and-drop file/folder operations within the main file tree.
- **Tags:** feature plan, keyboard navigation, drag and drop, file operations, accessibility, ux, phase 1

## 1. Overview & Goal

To achieve true feature parity with the native VS Code Explorer and cater to power users, the Data Curation Environment must support advanced interactions. This plan outlines the requirements for two major features: full keyboard navigation for accessibility and speed, and drag-and-drop functionality for intuitive file system manipulation.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| AI-01 | **Keyboard Navigation** | As a power user, I want to navigate the file tree using only my keyboard, so I can find, select, and manage files without taking my hands off the keyboard. | - Arrow Up/Down keys move the focus between visible nodes. <br> - Arrow Right on a collapsed folder expands it. <br> - Arrow Left on an open folder collapses it. <br> - `Enter` key opens the focused file or toggles expansion. <br> - `Spacebar` toggles the checkbox of the focused node. <br> - **(Bug C68):** When a file within a checked parent folder is focused, pressing spacebar incorrectly de-selects a higher-level directory instead of just the single file. |
| AI-02 | **Internal Drag-and-Drop** | As a user, I want to be able to drag a file or folder and drop it into another folder within the DCE view to move it, so I can reorganize my project intuitively. | - Clicking and dragging a file or folder initiates a drag operation. <br> - Dragging over a folder highlights it as a potential drop target. <br> - Dropping a file/folder onto another folder moves the dragged item. <br> - **Validation:** A folder cannot be dropped into itself or one of its own descendants. |
| AI-03 | **External Drag-and-Drop** | As a user, I want to drag a file (e.g., a PDF) from my computer's file explorer or the VS Code Explorer and drop it into a folder in the DCE view to add it to my project, so I can quickly incorporate new assets. | - Dragging a file from the OS or VS Code Explorer and dropping it onto a folder in the DCE view copies that file into the target folder in the workspace. <br> - The file tree automatically refreshes to show the newly added file. |
| AI-04 | **Delete Key** | As a user, I want to press the `Delete` key on my keyboard when an item is focused in the file tree to delete it, so I can manage files quickly without using the mouse. | - Focusing an item in the main file tree and pressing `Delete` initiates the delete workflow. <br> - It uses the same backend logic as the context menu, including the confirmation dialog and moving the item to the trash. |
| AI-05 | **Copy & Paste** | As a user, I want to use `Ctrl+C` and `Ctrl+V` to copy and paste files/folders within the tree, so I can use standard keyboard shortcuts for file duplication. | - `Ctrl+C` on a focused item copies its path to an internal clipboard. <br> - `Ctrl+V` on another item pastes the copied item into that location. <br> - Handles name collisions gracefully (e.g., `file-copy.ts`). |
| AI-06 | **Hover to Expand Folder** | As a user dragging a file, when I hover over a collapsed folder for a moment, I want it to automatically expand, so I can drop the file into a nested subdirectory without having to cancel the drag operation. | - During a drag operation, hovering over a collapsed folder for ~500ms triggers its expansion. <br> - Moving the mouse away from the folder before the timer completes cancels the expansion. |

## 3. Implementation Status & Notes

### Keyboard Navigation & Internal Drag-Drop
These features are stable and complete, with the exception of the noted spacebar bug.

### External Drag and Drop (De-Prioritized as of C61)

-   **Status:** **On Hold.**
-   **Summary of Attempts:** Multiple approaches were attempted between C54 and C60 to implement file drops from outside the webview (e.g., from the OS or the native VS Code Explorer).
    1.  **Standard HTML5 API (`dataTransfer.files`):** This worked for drops from the OS but failed for drops from the VS Code Explorer, as the `files` collection is empty for security reasons.
    2.  **VS Code URI-based API (`text/uri-list`):** This approach correctly captured the URI of the file being dropped from the VS Code Explorer. The URI was passed to the backend, which then used the `vscode.workspace.fs.copy()` API.
-   **Root Cause of Failure:** Despite correctly implementing the URI-based approach, the drag-and-drop events (`onDrop`, `onDragOver`) failed to fire reliably or at all when dragging from an external source into the webview. The root cause appears to be a complex interaction with VS Code's webview security model, event propagation, and possibly the Workspace Trust feature, which could not be resolved within a reasonable number of cycles.
-   **Path Forward:** This feature is now considered a **tertiary, long-term research goal**. The core functionality of the extension is not dependent on it. For now, users can add new files using the native VS Code Explorer, the "New File..." button in the DCE toolbar, or by simply creating the file, which will then appear on refresh.
</file>

<file path="src/Artifacts/A24. DCE - Selection Paradigm Terminology.md">
# Artifact A24: DCE - Selection Paradigm Terminology
# Date Created: C29
# Author: AI Model

- **Key/Value for A0:**
- **Description:** A document to clarify the terminology used within the project to distinguish between different types of user selections (e.g., "checking" for flattening vs. "selecting" for actions).
- **Tags:** documentation, terminology, selection, checking, design

## 1. Problem Statement

During development and feedback cycles, the term "select" has been used ambiguously, leading to confusion. It has been used to describe two distinct user actions with different purposes:
1.  Clicking a checkbox to include a file/folder in the context to be flattened.
2.  Clicking a file/folder row (with optional Ctrl/Shift modifiers) to highlight it for a contextual action (e.g., Rename, Delete).

This ambiguity makes feature requests and technical discussions difficult. The goal of this document is to establish clear, consistent terminology for use in all future artifacts, code, and discussions.

## 2. Defined Terminology

Henceforth, the following terms will be used to describe user interactions with the file tree:

### **Checking / Unchecking**

*   **Action:** Clicking the `checkbox` next to a file or folder item.
*   **Purpose:** To include or exclude an item from the set of files that will be processed by the **"Flatten Context"** action.
*   **UI State:** A visible checkmark (`âœ“`), indeterminate mark (`-`), or empty state in the checkbox.
*   **State Variable (conceptual):** `checkedPaths: Set<string>`
*   **User Phrasing:** "I **checked** the `src` folder."

---

### **Selecting / Highlighting**

*   **Action:** Single-clicking a file/folder row. Using `Ctrl+Click` or `Shift+Click` to highlight multiple rows.
*   **Purpose:** To designate one or more items as the target for a contextual action, such as those in the **right-click context menu** (e.g., Rename, Delete, Copy Path). This is also used to identify the "active" item for operations like "New File".
*   **UI State:** A visual highlight on the entire row, typically matching the VS Code theme's selection color.
*   **State Variable (conceptual):** `selectedPaths: Set<string>`
*   **User Phrasing:** "I **selected** three files and then right-clicked to delete them."

---

### **Focusing**

*   **Action:** Navigating the tree with keyboard arrow keys.
*   **Purpose:** To move a visual indicator (a focus ring or subtle highlight) to an item, making it the active target for keyboard actions (`Enter` to open, `Spacebar` to check/uncheck).
*   **UI State:** A focus outline around the item row.
*   **State Variable (conceptual):** `focusedPath: string | null`
*   **User Phrasing:** "The `README.md` file is currently **focused**."

## 3. Summary Table

| Term | Action | Purpose | UI Cue | State Name |
| :--- | :--- | :--- | :--- | :--- |
| **Check** | Click checkbox | Include in Flatten Context | Checkmark | `checkedPaths` |
| **Select** | Click / Ctrl+Click / Shift+Click row | Target for Context Menu Actions | Row highlight | `selectedPaths` |
| **Focus** | Keyboard navigation | Target for Keyboard Actions | Focus ring | `focusedPath` |

By adhering to this terminology, we can ensure clarity in communication and precision in our technical implementation.
</file>

<file path="src/Artifacts/A25. DCE - Phase 1 - Git & Problems Integration Plan.md">
# Artifact A25: DCE - Phase 1 - Git & Problems Integration Plan
# Date Created: C30
# Author: AI Model
# Updated on: C33 (Refine technical plan based on debugging)

- **Key/Value for A0:**
- **Description:** Outlines the user stories and technical approach for integrating Git status indicators and VS Code Problem Diagnostics into the custom file tree.
- **Tags:** feature plan, git, problems, diagnostics, ux, phase 1

## 1. Overview & Goal

To achieve full feature parity with the native VS Code Explorer and provide critical context to the user, the Data Curation Environment (DCE) file tree must display information about a file's Git status and any associated problems (errors/warnings). The goal of this feature is to overlay this diagnostic and source control information directly onto the file tree, allowing users to make more informed decisions during context curation.

**Status (C33):** Actively debugging and refining the implementation. The core issue appears to be in the backend's data gathering from the Git API.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| GP-01 | **Git Status Coloring** | As a user, I want to see files and folders colored according to their Git status (e.g., green for new, yellow for modified, gray for ignored), so I can quickly identify changes in my workspace. | - The file/folder name text color in the tree view changes based on its Git status. <br> - Colors should align with the user's current VS Code theme for Git decorations. <br> - A new, untracked file is green. <br> - A modified file is yellow/orange. <br> - A deleted file (in some views) is red. <br> - An ignored file is gray. |
| GP-02 | **Git Status Badges** | As a user, I want to see a letter badge next to a file's name indicating its specific Git status (e.g., 'U' for untracked, 'M' for modified), so I have an unambiguous indicator of its state. | - A small, colored badge with a letter appears to the right of the file name. <br> - 'U' for Untracked. <br> - 'M' for Modified. <br> - 'D' for Deleted. <br> - 'A' for Added. <br> - 'C' for Conflicted. <br> - The badge has a tooltip explaining the status (e.g., "Modified"). |
| GP-03 | **Problem Indicator Badges** | As a user, I want to see a badge with a count of errors and warnings on files and their parent folders, so I can immediately identify parts of the codebase that have issues. | - A file with problems displays a badge with the number of errors (e.g., in red). <br> - A folder recursively aggregates the problem counts of its children and displays a summary badge. <br> - Tooltips on the badge provide a breakdown (e.g., "2 Errors, 3 Warnings"). <br> - The file name may also be colored (e.g., red for errors, yellow for warnings) to match the Problems panel. |

## 3. Technical Implementation Plan

### Phase 1: Data Gathering (Backend)

1.  **Extend `FileNode` Type:** The `FileNode` interface in `src/common/types/file-node.ts` will be extended to include optional properties:
    ```typescript
    export interface FileNode {
        // ... existing properties
        gitStatus?: string; // e.g., 'M', 'U', 'A', 'D', 'C' for Conflicted
        problemCounts?: { error: number; warning: number; };
    }
    ```

2.  **Git Status Integration (`fs.service.ts`):**
    *   **API Acquisition:** The Git extension API will be acquired in `extension.ts` and passed into the `FSService` during initialization. This ensures it's available and handles cases where the Git extension might not be ready immediately.
    *   **Centralized Status Map:** A `private getGitStatusMap()` method will be created. This method builds a `Map<string, string>` of file paths to their status character.
    *   **Critical: Path Normalization:** All file paths retrieved from the Git API (`change.uri.fsPath`) **must** be normalized to use forward slashes (`/`) immediately before being used as keys in the map. This is the root cause of many cross-platform bugs.
    *   **Comprehensive Status Check:** The map will be populated by iterating through `repository.state.workingTreeChanges`, `repository.state.indexChanges`, and `repository.state.untrackedChanges`.
    *   **Logging:** Add detailed logging to confirm the Git API was found, the number of repositories, and the number of changes detected.

3.  **Problems Integration (`fs.service.ts`):**
    *   Use the `vscode.languages.getDiagnostics()` API. This returns all diagnostics for the entire workspace.
    *   Create a `Map<string, { error: number; warning: number; }>` to store aggregated counts per file URI.
    *   Iterate through the diagnostics and populate the map based on `diagnostic.severity`.
    *   When building the `FileNode` for a file, retrieve its counts from the map and add them to the `problemCounts` property.
    *   The recursive aggregation logic for folders (`_aggregateStats`) will be updated to also sum these `problemCounts`.

### Phase 2: Rendering (Frontend)

1.  **CSS Styling (`view.scss`):**
    *   Create new CSS classes for each Git status (e.g., `.git-status-M`, `.git-status-U`).
    *   Use VS Code theme variables for the colors to ensure consistency (e.g., `var(--vscode-gitDecoration-modifiedResourceForeground)`).
    *   Create classes for problem severity colors (e.g., `.problem-error`, `.problem-warning`) and badges.

2.  **Component Logic (`FileTree.tsx`):**
    *   In `renderFileNodeContent`, add logic to conditionally apply the CSS classes to the file name and the status badge based on the `gitStatus` and `problemCounts` properties of the `FileNode`.
    *   Add a new `<span>` element to render the Git status badge. Add a `title` attribute to this span to provide a helpful tooltip.
    *   Add another `<span>` to render the problem count badge, with a `title` attribute for the tooltip breakdown.
</file>

<file path="src/Artifacts/A26. DCE - Phase 1 - File System Traversal & Caching Strategy.md">
# Artifact A26: DCE - Phase 1 - File System Traversal & Caching Strategy
# Date Created: C31
# Author: AI Model

- **Key/Value for A0:**
- **Description:** Documents the root cause of the folder visibility bug and outlines the new strategy of using recursive directory traversal instead of `findFiles` to build a complete and accurate file system map.
- **Tags:** bug fix, file system, traversal, refresh, cache, architecture

## 1. Overview & Goal

This document addresses a critical bug identified in Cycle 31 where newly created empty folders do not appear in the Data Curation file tree, even after a refresh. The goal is to document the root cause and define a new, more robust file system traversal strategy that guarantees an accurate representation of the workspace, including empty directories.

## 2. Root Cause Analysis (RCA)

-   **Symptom:** Creating a new, empty folder in the workspace does not result in that folder appearing in the DCE file tree. The file watcher correctly detects a change and triggers a full refresh, but the new folder is still missing from the rendered output.
-   **Root Cause:** The file discovery mechanism in `fs.service.ts` exclusively uses the `vscode.workspace.findFiles("**/*", ...)` API call. This API is optimized to return a flat list of **files** matching a glob pattern. It does **not** return directories, especially empty ones, as they are not considered "files".
-   **Impact:** When the file tree is reconstructed from this file-only list, any empty directories are completely invisible to the tree-building logic, making it impossible for the UI to ever display them. This is a major regression that breaks core functionality.

## 3. New Traversal Strategy

To resolve this, the reliance on `vscode.workspace.findFiles` for building the tree structure will be eliminated and replaced with a manual, recursive directory traversal.

### 3.1. Technical Implementation Plan

1.  **Primary API:** The new strategy will be centered around the `vscode.workspace.fs.readDirectory(uri)` API. This function returns an array of `[name, fileType]` tuples for all immediate children of a given directory URI. `fileType` can be `File`, `Directory`, `SymbolicLink`, or `Unknown`.

2.  **Recursive Function:** A new `private async _traverseDirectory(uri)` method will be implemented in `fs.service.ts`.
    *   **Input:** The `vscode.Uri` of the directory to scan.
    *   **Process:**
        1.  Call `vscode.workspace.fs.readDirectory(uri)` to get the contents.
        2.  Iterate through the `[name, fileType]` tuples.
        3.  Apply the exclusion logic (e.g., skip `node_modules`, `.git`).
        4.  For each entry, create a `FileNode` object.
        5.  If `fileType` is `vscode.FileType.Directory`, recursively call `_traverseDirectory` for that child and assign the result to the `children` property of its `FileNode`.
        6.  If `fileType` is `vscode.FileType.File`, calculate its stats (token count, etc.).
        7.  Return the array of `FileNode` children.

3.  **Integration (`handleWorkspaceFilesRequest`):**
    *   The main `handleWorkspaceFilesRequest` function will now initiate the process by calling `_traverseDirectory` with the workspace root URI.
    *   The result of this recursive traversal will be the complete, accurate file tree, which can then be cached and sent to the client.

## 4. Benefits of the New Approach

-   **Accuracy:** This method builds a true representation of the file system, including all directories, regardless of whether they are empty or not.
-   **Control:** It gives us full control over the traversal, allowing for more sophisticated filtering or caching logic in the future.
-   **Performance:** While potentially slower for extremely large workspaces than a highly optimized native `findFiles` call, it avoids the overhead of converting a flat path list into a tree structure, as the tree is built directly during the scan. Performance will be monitored.
</file>

<file path="src/Artifacts/A27. DCE - Phase 1 - Undo-Redo Feature Plan.md">
# Artifact A27: DCE - Phase 1 - Undo-Redo Feature Plan
# Date Created: C35
# Author: AI Model

- **Key/Value for A0:**
- **Description:** Details the requirements for implementing an undo/redo stack for file system operations (move, delete) performed within the DCE view, to achieve parity with the native explorer's Ctrl+Z functionality.
- **Tags:** feature plan, undo, redo, ctrl+z, file operations, ux, phase 1

## 1. Overview & Goal

A critical feature for achieving parity with the native VS Code Explorer is the ability to undo file system operations. Users expect to be able to press `Ctrl+Z` to revert an accidental file move or deletion. The goal of this feature is to implement a robust undo/redo stack for file operations initiated from within the Data Curation Environment view.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| UR-01 | **Undo File Move** | As a user, after I drag and drop a file to a new location, I want to be able to press `Ctrl+Z` to move it back to its original location, so I can easily correct mistakes. | - Performing a file/folder move pushes an "action" object onto an undo stack. <br> - Pressing `Ctrl+Z` while the DCE view is focused pops the last action and reverses it (moves the file back). <br> - The file tree updates to reflect the reversed move. |
| UR-02 | **Undo File Deletion** | As a user, after I delete a file or folder (to the trash), I want to be able to press `Ctrl+Z` to restore it, so I don't lose work accidentally. | - Deleting a file/folder pushes an "action" object onto the undo stack. <br> - Pressing `Ctrl+Z` reverses the deletion. Since we use `useTrash: true`, this might be handled by a native VS Code command, or we may need to implement a restore from trash mechanism if possible. |
| UR-03 | **Redo Operation** | As a user, after I undo an action, I want to be able to press `Ctrl+Y` (or `Ctrl+Shift+Z`) to redo the action, so I can toggle between states. | - Undoing an action moves it from the undo stack to a redo stack. <br> - Pressing `Ctrl+Y` pops the last action from the redo stack and re-applies it. <br> - The file tree updates accordingly. |

## 3. Technical Implementation Plan

This feature will be implemented primarily on the backend to manage the file system state and the action history.

1.  **Action Stack Service (New Backend Service):**
    *   Create a new service, `action.service.ts`, to manage the undo and redo stacks.
    *   It will contain two arrays: `undoStack: Action[]` and `redoStack: Action[]`.
    *   An `Action` will be a typed object, e.g., `{ type: 'move', payload: { from: string, to: string } }` or `{ type: 'delete', payload: { path: string } }`.
    *   It will expose methods: `push(action: Action)`, `undo()`, and `redo()`.
        *   `push`: Adds an action to `undoStack` and clears `redoStack`.
        *   `undo`: Pops from `undoStack`, performs the reverse operation, and pushes the original action to `redoStack`.
        *   `redo`: Pops from `redoStack`, performs the original operation, and pushes it back to `undoStack`.

2.  **Integrate with `fs.service.ts`:**
    *   The `handleMoveFileRequest` and `handleFileDeleteRequest` methods in `fs.service.ts` will be updated.
    *   *Before* performing the file system operation, they will create the corresponding `Action` object.
    *   *After* the operation succeeds, they will call `Services.actionService.push(action)`.

3.  **IPC Channels and Commands:**
    *   Create two new `ClientToServerChannel` entries: `RequestUndo` and `RequestRedo`.
    *   The frontend (`TreeView.tsx`) will have a top-level `onKeyDown` handler. When `Ctrl+Z` or `Ctrl+Y` is detected, it will send the appropriate IPC message to the backend.
    *   Create two new backend commands, `dce.undo` and `dce.redo`, which will be called by the message handlers. These commands will simply call `Services.actionService.undo()` and `Services.actionService.redo()`.

4.  **Reverse Operations Logic (`action.service.ts`):**
    *   The `undo()` method will contain the logic to reverse actions.
    *   **Move:** To undo a move from `A` to `B`, it calls `vscode.workspace.fs.rename(B, A)`.
    *   **Delete:** Undoing a delete is more complex. Since we use `useTrash: true`, VS Code might not expose a direct API to "un-delete". Research is needed. The simplest approach might be to leverage a built-in command like `files.restoreFromTrash` if it can be targeted, or we may need to inform the user to use the native Explorer's undo for deletions. For a first pass, we might only support undo for **move** operations.

5.  **Frontend Focus:**
    *   The main `TreeView` component needs to be focusable (`tabIndex="0"`) to capture the keyboard shortcuts. The `onKeyDown` handler will check for `event.ctrlKey` and the specific key (`z` or `y`) and then send the IPC message.
</file>

<file path="src/Artifacts/A28. DCE - Packaging and Distribution Guide.md">
# Artifact A28: DCE - Packaging and Distribution Guide
# Date Created: C43
# Author: AI Model
# Updated on: C45 (Add step to update package.json before packaging)

- **Key/Value for A0:**
- **Description:** Provides a step-by-step guide on how to package the extension into a `.vsix` file for beta testing and distribution.
- **Tags:** packaging, distribution, vsix, vsce, deployment

## 1. Overview

This document provides instructions on how to package the Data Curation Environment (DCE) extension into a single `.vsix` file. This file is the standard format for distributing and installing VS Code extensions, making it easy to share with beta testers or submit to the official marketplace.

The primary tool used for this process is `vsce` (Visual Studio Code Extensions), the official command-line tool for managing extensions.

## 2. Prerequisites

1.  **Node.js and npm:** You must have Node.js and npm installed.
2.  **Install `vsce`:** If you haven't already, install `vsce` globally by running the following command in your terminal:
    ```bash
    npm install -g @vscode/vsce
    ```

## 3. Packaging the Extension

Follow these steps in your terminal from the root directory of the DCE project (e.g., `C:\Projects\DCE`):

### Step 0: Update `package.json` (Important!)

Before packaging, ensure your `package.json` file is complete. The `vsce` tool will warn you if important fields are missing. At a minimum, make sure the following fields are present and correct:

-   `publisher`: Your publisher ID from the VS Code Marketplace.
-   `repository`: An object pointing to your source code repository (e.g., on GitHub).
-   `homepage`: A link to your project's homepage.
-   `bugs`: A link to your project's issue tracker.
-   `version`: Increment the version number for each new release.

**Example `repository` field:**
```json
"repository": {
  "type": "git",
  "url": "https://github.com/dgerabagi/data-curation-environment.git"
}
```

### Step 1: Ensure Dependencies are Installed

Make sure your project's dependencies are up to date.

```bash
npm install
```

### Step 2: Create a Production Build

Before packaging, it's essential to create an optimized production build of the extension. Our `package.json` already has a script for this.

```bash
npm run package
```

This command runs webpack in `production` mode, which minifies the code and removes source maps, resulting in a smaller and faster extension. It will update the files in the `/dist` directory.

### Step 3: Run the Packaging Command

Once the production build is complete, you can run the `vsce` packaging command.

```bash
vsce package
```

This command will:
1.  Read the `package.json` manifest file.
2.  Gather all the necessary files, respecting the rules in `.vscodeignore`.
3.  Bundle everything into a single file named `data-curation-environment-X.X.X.vsix`, where `X.X.X` is the version number from `package.json`.

You will see the `.vsix` file in the root of your project directory.

## 4. Sharing and Installing the `.vsix` File

### For Beta Testers:

1.  **Share the File:** You can send the generated `.vsix` file directly to your testers (e.g., via email, Slack, or a shared drive).

2.  **Installation Instructions:** Your testers can install it in VS Code by following these steps:
    *   Open VS Code.
    *   Go to the **Extensions** view (Ctrl+Shift+X).
    *   Click the **...** (More Actions) button at the top of the Extensions view.
    *   Select **"Install from VSIX..."**.
    *   In the file dialog that opens, navigate to and select the `.vsix` file you provided.
    *   VS Code will install the extension and prompt for a reload.

## 5. Next Steps (Future)

*   **Versioning:** Before creating a new package for distribution, remember to increment the `version` number in `package.json`.
*   **Marketplace Publishing:** Publishing to the official VS Code Marketplace involves creating a publisher identity and using `vsce publish` instead of `vsce package`.
</file>

<file path="src/Artifacts/A29. DCE - Phase 1 - Binary and Image File Handling Strategy.md">
# Artifact A29: DCE - Phase 1 - Binary and Image File Handling Strategy
# Date Created: C46
# Author: AI Model
# Updated on: C47 (Richer metadata format and JSON output)

- **Key/Value for A0:**
- **Description:** Defines the strategy for handling binary files; they can be checked, but only their metadata (path, size) is included in the flattened output, not their content.
- **Tags:** feature plan, binary, image, metadata, flatten, phase 1

## 1. Overview & Goal

During beta testing, a use case emerged for including information about binary files (like images) in the flattened context without including their raw, unreadable content. The goal of this strategy is to allow users to select *any* file, but to intelligently handle non-text files during the flattening process to prevent corrupting the output while still capturing useful metadata.

## 2. Problem Statement

-   **Initial Problem:** Flattening a folder containing images (`.png`, `.gif`) resulted in binary gibberish being written to `flattened_repo.md`.
-   **Initial Solution (C43):** Prevent selection of binary files by disabling their checkboxes.
-   **Refined Requirement (C46):** The user realized they *do* want to capture the existence and properties of these files (e.g., path, size) as part of the context, just not their content.
-   **Refined Requirement (C47):** The metadata should be richer, including name, directory, dimensions, and file type, and be presented in a structured format.

## 3. The New Strategy

The extension will now adopt a "metadata-only" approach for a predefined list of binary and image file types.

### 3.1. User Experience

1.  **Selection is Always Allowed:** All files in the file tree, regardless of type, will have an enabled checkbox. The user is free to check any file or folder.
2.  **File Opening:** Clicking on any file in the tree view will open it using VS Code's default viewer for that file type (e.g., text editor for `.ts`, image preview for `.png`).
3.  **Flattening Behavior is Differentiated:**
    *   When a **text file** is checked and the "Flatten Context" button is pressed, its full content is read and included in `flattened_repo.md`.
    *   When a **binary or image file** is checked, its content is **not** read. Instead, the flattener service will gather its metadata and include a structured, human-readable entry for it in `flattened_repo.md`.

### 3.2. Output Format for Binary Files

When a binary file is included, its entry in the `<files content>` section of `flattened_repo.md` will contain a `<metadata>` tag with a JSON object. Dimensions will be included on a best-effort basis for common formats (PNG, JPG, GIF).

**Example (with dimensions):**
```xml
<file path="public/images/logo.png">
<metadata>
{
  "name": "logo.png",
  "directory": "public/images",
  "fileType": "PNG",
  "sizeInBytes": 12345,
  "dimensions": {
    "width": 256,
    "height": 256
  }
}
</metadata>
</file>
```

**Example (without dimensions):**
```xml
<file path="assets/archive.zip">
<metadata>
{
  "name": "archive.zip",
  "directory": "assets",
  "fileType": "ZIP",
  "sizeInBytes": 102400
}
</metadata>
</file>
```

## 4. Technical Implementation Plan

1.  **File Opening (`fs.service.ts`):**
    *   The `handleOpenFileRequest` method will be updated to use `vscode.commands.executeCommand('vscode.open', uri)`. This delegates opening to VS Code, which correctly selects the appropriate viewer for any file type.

2.  **Backend Flattener Logic (`flattener.service.ts`):**
    *   A constant set of binary/image extensions will be defined.
    *   A new private method, `_parseImageMetadata`, will be added. It will read a file's buffer and attempt to parse dimensions for PNG, JPG, and GIF files, adapting logic from `flattenv2.js`.
    *   The `getFileStatsAndContent` method will be updated. When it encounters a binary file, it will:
        *   Call `_parseImageMetadata`.
        *   Collect the name, directory, type, size, and (if available) dimensions.
        *   Construct the formatted JSON string.
        *   Return a `FileStats` object where `content` is this JSON string, and `tokens` is 0.
</file>

<file path="src/Artifacts/A3. DCE - Technical Scaffolding Plan.md">
# Artifact A3: DCE - Technical Scaffolding Plan
# Date Created: Cycle 1
# Author: AI Model
# Updated on: Cycle 2 (Adopted architecture from `The-Creator-AI-main` repository)

## 1. Overview

This document outlines the technical scaffolding and file structure for the Data Curation Environment (DCE) VS Code extension.

**Major Update (Cycle 2):** The initial plan for a simple file structure has been superseded. We are officially adopting the mature and robust architecture of the `The-Creator-AI-main` reference repository as our project's blueprint. This provides a proven, scalable foundation for all three project phases.

## 2. Adopted File Structure

The project will adhere to the following directory structure, derived directly from the reference repository:

```
.
â”œâ”€â”€ public/                     # Static assets for webviews (icons, css)
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ backend/                # Extension Host code (Node.js environment)
â”‚   â”‚   â”œâ”€â”€ commands/           # Command definitions and registration
â”‚   â”‚   â”œâ”€â”€ repositories/       # Data persistence logic (workspace state)
â”‚   â”‚   â”œâ”€â”€ services/           # Core backend services (LLM, FS, Git, etc.)
â”‚   â”‚   â”œâ”€â”€ types/              # TypeScript types for the backend
â”‚   â”‚   â””â”€â”€ utils/              # Utility functions for the backend
â”‚   â”‚
â”‚   â”œâ”€â”€ client/                 # Webview code (Browser environment)
â”‚   â”‚   â”œâ”€â”€ components/         # Generic, reusable React components (FileTree, Modal)
â”‚   â”‚   â”œâ”€â”€ modules/            # Feature-specific modules (Context, Plan)
â”‚   â”‚   â”œâ”€â”€ store/              # Global state management for webviews (RxJS)
â”‚   â”‚   â””â”€â”€ views/              # Entry points for each webview panel
â”‚   â”‚
â”‚   â”œâ”€â”€ common/                 # Code shared between backend and client
â”‚   â”‚   â”œâ”€â”€ constants/
â”‚   â”‚   â”œâ”€â”€ ipc/                # IPC channel definitions and managers
â”‚   â”‚   â”œâ”€â”€ types/              # Shared TypeScript types (FileNode)
â”‚   â”‚   â””â”€â”€ utils/              # Shared utility functions (parse-json)
â”‚   â”‚
â”‚   â””â”€â”€ extension.ts            # Main entry point for the VS Code extension
â”‚
â”œâ”€â”€ package.json                # Extension manifest, dependencies, and scripts
â”œâ”€â”€ tsconfig.json               # TypeScript configuration
â”œâ”€â”€ webpack.config.js           # Webpack configuration for bundling client/server code
â””â”€â”€ ... (config files like .eslintrc.json, .gitignore)
```

## 3. Key Architectural Concepts

-   **Separation of Concerns:** The structure strictly separates backend (Node.js) logic from frontend (React/webview) logic.
-   **Shared Code:** The `src/common/` directory is critical for sharing types and IPC definitions, ensuring type safety and consistency between the extension host and the webview.
-   **Service-Oriented Backend:** The `src/backend/services/` directory promotes modularity. Each service has a single responsibility (e.g., `FSService` for file operations, `LlmService` for AI interaction), making the system easier to maintain and test.
-   **Dependency Injection:** The `Services.ts` class acts as a simple injector, managing the instantiation and provision of backend services.
-   **Modular Frontend:** The `src/client/modules/` directory allows for building complex UIs by composing smaller, feature-focused modules.
-   **Component-Based UI:** The `src/client/components/` directory holds the fundamental building blocks of the UI, promoting reusability.
-   **Typed IPC Communication:** The use of `channels.enum.ts` and `channels.type.ts` in `src/common/ipc/` provides a strongly-typed and well-documented contract for communication between the webview and the extension host, reducing runtime errors.
</file>

<file path="src/Artifacts/A30. DCE - Phase 1 - PDF Handling and Virtualization Strategy.md">
# Artifact A30: DCE - Phase 1 - PDF Handling and Virtualization Strategy
# Date Created: C49
# Author: AI Model

- **Key/Value for A0:**
- **Description:** Defines the strategy for handling PDF files. Text is extracted on-demand and cached in memory for flattening, creating a "virtual" markdown file without modifying the user's workspace.
- **Tags:** feature plan, pdf, text extraction, virtualization, cache, phase 1

## 1. Overview & Goal

Users need to include the textual content of PDF documents in their flattened context. However, creating physical `.md` files for each PDF in the user's workspace is undesirable as it clutters their project. The goal of this strategy is to implement a "virtual file" system for PDFs. The extension will extract text from PDF files on demand and hold it in an in-memory cache, using this virtual content during the flattening process without ever writing new files to the user's disk.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| PDF-01 | **Include PDF Text in Context** | As a user, when I check a `.pdf` file in the DCE view, I want its textual content to be included in the `flattened_repo.md` file, so I can use documents and papers as context. | - Checking a `.pdf` file is allowed. <br> - The token count displayed for the PDF reflects its extracted text content, not its binary size. <br> - When flattened, the text from the PDF is included within a `<file>` tag, just like a normal text file. <br> - No `.md` file is ever created in the user's workspace. |
| PDF-02 | **Drag-Drop PDF to Add** | As a user, I want to drag a PDF from my computer's file explorer and drop it into the DCE view, so I can quickly add it to my project and include it in my context. | - Dropping a PDF file into a folder in the DCE view copies the PDF into that workspace directory. <br> - The new PDF immediately appears in the file tree. <br> - The user can then check it to include its text content for flattening. |

## 3. Technical Implementation Plan

1.  **Dependency:**
    *   The `pdf-parse` library will be added as a dependency to `package.json` to handle text extraction from PDF buffers.

2.  **Backend (`fs.service.ts`):**
    *   **In-Memory Cache:** A new private cache will be added: `private pdfTextCache = new Map<string, { text: string; tokenCount: number }>();`. This will store the extracted text and calculated token count, keyed by the PDF's absolute path.
    *   **New IPC Handler (`RequestPdfToText`):**
        *   This handler will receive a file path for a PDF.
        *   It will first check the `pdfTextCache`. If the content is present, it will return the cached data.
        *   If not cached, it will read the PDF file into a buffer, use `pdf-parse` to extract the text, calculate the token count, store the result in the cache, and then return it.
        *   It will send a `UpdateNodeStats` message back to the client with the new token count.

3.  **Frontend (`view.tsx`):**
    *   **On-Demand Extraction:** The `updateCheckedFiles` function will be modified. When a path that ends in `.pdf` is being checked for the first time, it will send a `RequestPdfToText` message to the backend.
    *   **Dynamic Stats Update:** A new IPC listener for `UpdateNodeStats` will be added. When it receives a message, it will find the corresponding `FileNode` in the `files` state and update its `tokenCount` property, causing the UI to re-render with the correct information.

4.  **Backend (`flattener.service.ts`):**
    *   **Virtual Content Retrieval:** The `getFileStatsAndContent` method will be updated.
    *   If it encounters a file path ending in `.pdf`, it will **not** attempt to read the file from the disk.
    *   Instead, it will call a new method on the `FSService` (e.g., `getVirtualPdfContent(filePath)`) to retrieve the text from the `pdfTextCache`.
    *   It will then use this cached text to generate the `FileStats` object, effectively treating the PDF as if it were a markdown file. If the content is not in the cache (e.g., the file was never checked), it will be flattened with empty content.

5.  **External Drag-and-Drop:**
    *   This will be handled by the generic "External Drag-and-Drop" feature planned in `A23`. The implementation will read the file buffer and send it to the backend for creation, which works for PDFs just as it does for any other file type.
</file>

<file path="src/Artifacts/A31. DCE - Phase 2 - Multimodal Content Extraction (PDF Images).md">
# Artifact A31: DCE - Phase 2 - Multimodal Content Extraction (PDF Images)
# Date Created: C49
# Author: AI Model

- **Key/Value for A0:**
- **Description:** A plan for a future feature to extract images from PDF files and use a multimodal LLM to generate rich, textual descriptions for inclusion in the context.
- **Tags:** feature plan, multimodal, image to text, pdf, llm, phase 2

## 1. Overview & Goal

Building on the PDF text extraction in Phase 1, this plan outlines a powerful Phase 2 enhancement: making the visual information within PDFs accessible to language models. Many technical papers, reports, and documents rely on diagrams, charts, and images to convey critical information. The goal of this feature is to extract these images from a PDF and use a multimodal vision-language model (VLM) to generate rich, textual descriptions. These descriptions can then be included in the flattened context, allowing an LLM to "understand" the visual elements of the document.

## 2. User Story

| ID | User Story | Acceptance Criteria |
|---|---|---|
| MM-01 | **Understand PDF Images** | As a data curator, when I include a PDF containing charts and diagrams in my context, I want the extension to generate textual descriptions of those images, so the LLM I'm prompting can reason about the visual data. | - When a PDF is processed, the extension identifies and extracts embedded images. <br> - For each extracted image, the extension sends it to a configured multimodal LLM API (e.g., Gemini). <br> - The LLM API returns a detailed textual description of the image's content. <br> - These descriptions are inserted into the virtual markdown content of the PDF at the appropriate locations (e.g., `[Image: A bar chart showing user growth from 2022 to 2024...]`). <br> - This feature can be enabled/disabled in the extension's settings to manage API costs. |

## 3. Technical Implementation Plan (High-Level)

This is a complex feature that will require new services and dependencies, likely as part of the project's Phase 2.

1.  **PDF Image Extraction Library:**
    *   **Research:** The first step is to research and select a robust Node.js library capable of extracting raw image data (e.g., as buffers) from a PDF file. `pdf-lib` or native command-line tools like `pdfimages` (wrapped in a Node.js process) are potential candidates.
    *   **Implementation:** A new method in `fs.service.ts`, `_extractImagesFromPdf(buffer)`, will be created to handle this process.

2.  **New Service: `ImageDescriptionService`:**
    *   A new backend service, `ImageDescriptionService`, will be created.
    *   This service will be responsible for communicating with a multimodal LLM provider (e.g., Google's Gemini API).
    *   It will have a method like `describeImage(imageBuffer: Buffer): Promise<string>`.
    *   This method will handle the API request, sending the image data and receiving the text description.
    *   It will require API key management, likely extending the existing settings infrastructure.

3.  **Integration with PDF Processing:**
    *   The `RequestPdfToText` handler in `fs.service.ts` will be significantly enhanced.
    *   After parsing the text with `pdf-parse`, it would ideally also call the new image extraction method.
    *   It would then iterate through the extracted images, call the `ImageDescriptionService` for each, and intelligently weave the resulting descriptions back into the main text content to create a comprehensive markdown representation of the entire PDF.
    *   This process would be computationally expensive and time-consuming, requiring clear user feedback (e.g., progress indicators) in the UI.

4.  **Configuration:**
    *   New settings will be added to `package.json` and managed via a settings service to allow the user to:
        *   Enable/disable this feature.
        *   Configure their multimodal API provider and key.
        *   Potentially set a budget or limit on the number of images to process per document.
</file>

<file path="src/Artifacts/A32. DCE - Phase 1 - Excel and CSV Handling Strategy.md">
# Artifact A32: DCE - Phase 1 - Excel and CSV Handling Strategy
# Date Created: C62
# Author: AI Model
# Updated on: C67 (Revert to xlsx and custom Markdown converter for stability)

- **Key/Value for A0:**
- **Description:** Defines the strategy for handling tabular data files (.xlsx, .xls, .csv) by converting them to Markdown tables on-demand and caching them in memory for flattening.
- **Tags:** feature plan, excel, csv, text extraction, virtualization, cache, phase 1

## 1. Overview & Goal

Following the successful implementation of PDF virtualization, users now require a similar capability for tabular data files, specifically Microsoft Excel (`.xlsx`, `.xls`) and Comma-Separated Values (`.csv`). The goal is to extract the content from these files and represent it as clean, readable Markdown tables within the flattened context. This will be achieved using the same on-demand, in-memory caching strategy to avoid creating temporary files in the user's workspace.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| XLS-01 | **Include Tabular Data in Context** | As a user, when I check an Excel or CSV file, I want its data to be converted to Markdown tables and included in the `flattened_repo.md`, so I can use structured data as context for the LLM. | - Checking `.xlsx`, `.xls`, and `.csv` files is allowed. <br> - The token count displayed for the file reflects its Markdown table content. <br> - When flattened, the content is included within a `<file>` tag. <br> - For Excel files with multiple sheets, each sheet is converted to a separate named Markdown table. <br> - No temporary `.md` files are created in the user's workspace. |

## 3. Technical Implementation Plan (C67 Update)

1.  **Dependency:**
    *   After encountering critical parsing bugs and format limitations with `exceljs`, the project has reverted to using the more robust **`xlsx` (SheetJS)** library. This will be the sole dependency for parsing tabular data.
    *   **Vulnerability Note:** The `xlsx` package has a known high-severity vulnerability. While a direct fix from the library maintainers is not yet available, our implementation mitigates risk by using it only for its core data parsing and implementing our own logic for converting that data to Markdown, rather than using the library's more complex and less-audited utility functions.

2.  **Backend (`fs.service.ts`):**
    *   **In-Memory Cache:** A private cache will be maintained: `private excelMarkdownCache = new Map<string, { markdown: string; tokenCount: number }>();`.
    *   **IPC Handler (`RequestExcelToText`):**
        *   This handler will receive a file path. It will first check the cache.
        *   If not cached, it will read the file buffer.
        *   It will use `XLSX.read(buffer)` to parse the file into a workbook object. This works for `.xlsx`, `.xls`, and `.csv`.
        *   It will iterate through each sheet name in the `workbook.SheetNames`.
        *   For each sheet, it will call a **custom private helper method, `_sheetToMarkdown`**.
    *   **Custom Markdown Converter (`_sheetToMarkdown`):**
        *   This new function will take a worksheet object from `xlsx` as input.
        *   It will use `XLSX.utils.sheet_to_json(worksheet, { header: 1 })` to get an array-of-arrays representation of the sheet.
        *   It will then manually iterate over these arrays to construct a Markdown table string, creating the header row (`| Col1 | Col2 |`), the separator line (`|---|---|`), and all data rows.
        *   This custom implementation provides stability and avoids potential bundling issues with the library's own `sheet_to_markdown` utility.
        *   The final Markdown string (including headers for each sheet) will be concatenated, its token count calculated, and the result stored in the cache.
        *   It will then send an `UpdateNodeStats` message back to the client with the new token count.

3.  **Frontend & Flattener Integration:**
    *   The frontend (`view.tsx`) will continue to trigger the `RequestExcelToText` message on-demand.
    *   The backend (`flattener.service.ts`) will continue to retrieve the virtual Markdown content from the `FSService`'s cache. No changes are needed in these files.
</file>

<file path="src/Artifacts/A33. DCE - Phase 1 - Copy-Paste Feature Plan.md">
# Artifact A33: DCE - Phase 1 - Copy-Paste Feature Plan
# Date Created: C68
# Author: AI Model

- **Key/Value for A0:**
- **Description:** Details the requirements for implementing copy-paste functionality (Ctrl+C, Ctrl+V) for files and folders within the DCE view, including handling name collisions.
- **Tags:** feature plan, copy, paste, file operations, ux, phase 1

## 1. Overview & Goal

To achieve greater feature parity with the native VS Code Explorer and improve workflow efficiency, this plan outlines the implementation of standard copy-paste functionality for files and folders. Users expect to be able to use `Ctrl+C` and `Ctrl+V` to duplicate items within the file tree. The goal is to provide this intuitive and essential file management feature, complete with robust handling of name collisions to prevent accidental file overwrites.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| CP-01 | **Copy and Paste File/Folder** | As a user, I want to select a file or folder, press `Ctrl+C`, then select a destination folder and press `Ctrl+V` to create a duplicate, so I can quickly copy assets or boilerplate code within my project. | - `Ctrl+C` on a focused file/folder in the DCE view copies its path to an internal clipboard. <br> - `Ctrl+V` pastes the copied item into the currently focused folder. <br> - If a file is focused, the paste occurs in its parent directory. <br> - Pasting a folder also copies its entire contents recursively. |
| CP-02 | **Handle Name Collisions** | As a user, when I paste a file named `file.txt` into a folder that already contains a `file.txt`, I expect the new file to be automatically renamed to `file-copy.txt` (or similar), so I don't accidentally overwrite my work. | - If a file with the same name exists at the destination, the pasted file is renamed. <br> - The renaming scheme is `[original]-copy.[ext]`. <br> - If `[original]-copy.[ext]` also exists, the scheme becomes `[original]-copy-2.[ext]`, `[original]-copy-3.[ext]`, and so on, until a unique name is found. <br> - This applies to both files and folders. |

## 3. Technical Implementation Plan

1.  **IPC Channels (`channels.enum.ts`, `channels.type.ts`):**
    *   Create a new `ClientToServerChannel.RequestCopyFile` channel.
    *   The payload will be `{ sourcePath: string; destinationDir: string; }`.

2.  **Frontend State & Logic (`view.tsx`, `TreeView.tsx`):**
    *   **Clipboard State (`view.tsx`):** Add a new state variable to the main `App` component to act as the internal clipboard: `const [clipboard, setClipboard] = useState<{ path: string; type: 'copy' } | null>(null);`.
    *   **Keyboard Event Handler (`TreeView.tsx`):** Update the `handleKeyDown` function.
        *   It will now listen for `e.key === 'c'` and `e.key === 'v'` when `e.ctrlKey` (or `e.metaKey`) is true.
        *   **On `Ctrl+C`:** It will call a prop function (`onCopy`) passed down from `view.tsx`, which will update the `clipboard` state with the `focusedNodePath`.
        *   **On `Ctrl+V`:** It will check if the `clipboard` state is populated. If so, it will determine the destination directory from the `focusedNodePath` (if the focused node is a folder, use its path; if it's a file, use its parent's path). It will then send the `RequestCopyFile` message to the backend.

3.  **Backend File Operation (`fs.service.ts`):**
    *   **New Handler:** Create a new `async handleCopyFileRequest({ sourcePath, destinationDir })` method.
    *   **Name Collision Logic:**
        *   This handler will contain a private helper function, `private async _findAvailableCopyName(destinationPath: string): Promise<string>`.
        *   This helper will parse the `destinationPath` into its directory, base name, and extension.
        *   It will check if the original path exists using `vscode.workspace.fs.stat`.
        *   If it exists, it will enter a loop, checking for `...-copy.[ext]`, then `...-copy-2.[ext]`, `...-copy-3.[ext]`, etc., until `fs.stat` throws an `ENOENT` error, indicating a free name.
        *   It will return the first available unique path.
    *   **File Copy:** The main handler will call `_findAvailableCopyName` to get the final target path and then use `vscode.workspace.fs.copy(sourceUri, targetUri)` to perform the recursive copy.
    *   The existing file system watcher will automatically detect the new file/folder and trigger a UI refresh.
</file>

<file path="src/Artifacts/A34. DCE - Phase 2 - Parallel Co-Pilot Panel - Vision & Requirements.md">
# Artifact A34: DCE - Phase 2 - Parallel Co-Pilot Panel - Vision & Requirements
# Date Created: C69
# Author: AI Model
# Updated on: C91 (Add global parse toggle and Associated Files list)

- **Key/Value for A0:**
- **Description:** Outlines the high-level vision and user stories for the Phase 2 multi-tabbed editor panel, designed for comparing and managing multiple AI-generated responses. Includes plans for response annotation and a "Cycles Context" field.
- **Tags:** feature plan, phase 2, co-pilot, multi-tab, ui, ux, requirements, annotation, persistence, diff, parsing

## 1. Vision & Goal

Phase 2 of the Data Curation Environment aims to solve the "single-threaded" nature of interacting with AI assistants. The current workflow for developers often involves sending the same prompt to multiple models or conversations, copying the results to separate text files, and then manually integrating them into their project to test. This is inefficient and cumbersome.

The goal of the **Parallel Co-Pilot Panel** is to create an integrated, **persistent** environment within VS Code specifically for managing, comparing, diffing, and testing multiple AI-generated code responses.

**Core Workflow (C91 Update):** The primary interaction model is now **parse-centric** and **globally controlled**. The user pastes raw AI responses into simple text areas in each tab. A single, global "Parse All" button then processes the raw text in all tabs simultaneously, transforming their UIs into a structured, read-only view. This view separates the AI's plan from its code artifacts and includes a new "Associated Files" list for at-a-glance validation.

## 2. Core Concepts

1.  **Dedicated View Container:** The panel has its own icon in the Activity Bar, providing a distinct, full-height space for its UI.
2.  **Stateful & Persistent:** The content of all tabs, context fields, and the current cycle number are automatically saved. The state persists across sessions and when moving the panel to a new window.
3.  **Global Parse-on-Demand:** A single "Parse All Responses" button in the main header controls the view mode for all tabs.
4.  **Structured, Readable View:** After parsing, each tab's `textarea` is replaced by a static, read-only view that:
    *   Renders the AI's summary and plan as **formatted Markdown**.
    *   Uses **collapsible sections** for the main UI areas (Cycle Info, Summary, etc.) to manage screen real estate.
    *   Displays an **"Associated Files" list** with indicators (`âœ“`/`âœ—`) showing if the files exist in the workspace.
    *   Displays individual, **syntax-highlighted** code blocks for each file.
5.  **Live Testing via "Swap":** The core innovation is a "swap" feature. The user can, with a single click, exchange the content of a parsed file block with its corresponding source file in the workspace.
6.  **Integrated Diffing:** Users can click on a file in the "Associated Files" list to see an immediate diff view comparing the AI's suggestion against the current workspace file.
7.  **Cycle Navigator:** A UI to navigate back and forth through the history of development cycles, loading the corresponding AI responses for each cycle.
8.  **Metadata Display:** Each response tab will display key metadata, such as token counts and similarity scores, to help the user quickly evaluate the AI's output.

## 3. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| P2-US-01 | **Manage Multiple Responses** | As a developer, I want a dedicated panel with multiple tabs where I can place different AI-generated code responses, so I can keep them organized. | - A new icon in the Activity Bar opens the Parallel Co-Pilot panel. <br> - The panel contains a slider or input to select the number of visible tabs. <br> - Each tab initially contains a large text input area. |
| P2-US-02 | **Parse All Responses** | As a developer, after pasting responses into multiple tabs, I want to click a single button to parse all of them into a structured view, so I can easily review them without repetitive clicking. | - A global "Parse All Responses" button exists in the panel's header. <br> - Clicking it processes the raw text in every tab. <br> - Each tab's UI transforms to show distinct sections for summary, action plan, and file blocks. <br> - A corresponding "Un-Parse All" button reverts all tabs to their raw text view. |
| P2-US-03 | **View Formatted Text** | As a developer, I want the AI's summary and plan to be rendered as formatted Markdown, so I can easily read lists, bolded text, and other formatting. | - The summary and course of action sections correctly render Markdown syntax. |
| P2-US-04 | **Manage UI Space** | As a developer, I want to be able to collapse the main sections of the UI, so I can focus on the code blocks without excessive scrolling. | - The Cycle Info, Summary, Course of Action, and Associated Files sections have collapsible headers. |
| P2-US-05 | **Verify Response Validity** | As a developer, I want to see a list of all files an AI response intends to modify, with a clear indicator of whether those files exist in my project, so I can immediately spot hallucinations or new file suggestions. | - After parsing, a list of "Associated Files" is displayed. <br> - A checkmark (`âœ“`) appears next to files that exist in the workspace. <br> - An 'x' (`âœ—`) appears next to files that do not exist. |
| P2-US-06 | **Persistent State** | As a developer, I want all the text I've entered into the panel to be saved automatically, so I don't lose my work if I close the panel, move it, or restart VS Code. | - All raw text content is saved to a history file (`.vscode/dce_history.json`). <br> - When the panel is reopened, it loads the state from the most recent cycle. |
| P2-US-07 | **Review Changes with Diff** | As a developer, I want to click on any file in the "Associated Files" list to see a diff, so I can review the exact changes before testing. | - Clicking a file path in the list opens a diff view comparing the workspace version with the AI's version. |
| P2-US-08 | **Navigate Cycle History** | As a developer, I want to navigate backward and forward through my project's development cycles, so I can review past AI suggestions. | - UI controls exist to move between cycles. <br> - Navigating to a past cycle loads its saved raw responses into the panel. |
</file>

<file path="src/Artifacts/A35. DCE - Phase 2 - UI Mockups and Flow.md">
# Artifact A35: DCE - Phase 2 - UI Mockups and Flow
# Date Created: C69
# Author: AI Model
# Updated on: C132 (Add response-level controls and refine diff view)

## 1. Overview

This document describes the user interface (UI) and interaction flow for the Parallel Co-Pilot Panel. The design is centered around a two-stage workflow: **Input**, followed by a global **Parse** that transforms the entire panel into a **Review & Act** mode.

## 2. UI Mockup (Textual Description)

### 2.1. Main Header & Cycle Section
(No changes from C131)

### 2.2. Response Tabs
(No changes from C131)

### 2.3. Parsed View (Non-Diff Mode)

The parsed view uses a **resizable two-pane layout**. The left pane provides summary information and navigation. The right pane displays the code, now with its own header for accepting changes.

```
|-------------------------------------------------------------------------------------------------|
| [ Left Pane ]<--->[ Right Pane (Code Viewer) ]                                                 |
| |-------------||------------------------------------------------------------------------------| |
| | [v] ASSOCIATED FILES            | | [ ] Select this response [ Accept Selected Files ]               | |
| | |-------------------------------| |------------------------------------------------------------------| |
| | | [x] [âœ“] src/.../view.tsx      | | [ File: src/.../view.tsx ] [ View Diff ] [ Accept this file ]    | |
| | | [ ] [âœ—] src/.../new-file.ts   | | +------------------------------------------------------------------+ | |
| |                                   | | | [ Read-only editor with line numbers and syntax highlighting ] | | |
| | [v] THOUGHTS / RESPONSE           | | +------------------------------------------------------------------+ | |
| | | Rendered Markdown...            | |                                                                    | |
| |                                   | |                                                                    | |
| | [v] COURSE OF ACTION              | |                                                                    | |
| | | Rendered Markdown...            | |                                                                    | |
+-------------------------------------------------------------------------------------------------+
```
*   **File Checkboxes (`[x]`):** A checkbox now appears next to each file in the "Associated Files" list. This allows the user to stage individual files for a bulk "accept" operation.
*   **Response Header:** A new header bar appears above the code viewer.
    *   **`[ ] Select this response`:** A checkbox that checks or un-checks all files in the "Associated Files" list.
    *   **`[ Accept Selected Files ]`:** A button that replaces all checked workspace files with the versions from this AI response.
*   **Individual File Actions:** The "Swap" button is renamed to **"Accept this file"** for clarity.

### 2.4. Diff View

When the user clicks the "[ View Diff ]" button.

```
|-------------------------------------------------------------------------------------------------|
| [ Left Pane ]<--->[ Right Pane (Diff Viewer) ]                                                 |
| |-------------||------------------------------------------------------------------------------| |
| | [v] ASSOCIATED FILES            | | [ Back to Code View ]                                            | |
| | | ... (files list) ...          | |------------------------------------------------------------------| |
| |                                   | | [ Location Pane (visual file overview) ]                         | |
| | [v] THOUGHTS / RESPONSE           | |------------------------------------------------------------------| |
| | | ...                           | | [ Left Diff Pane ]<--->[ Right Diff Pane ]                       | |
| |                                   | | | (Scroll-locked)    | | (Scroll-locked)                     | | |
| | [v] COURSE OF ACTION              | | +--------------------||---------------------------------------+ | |
| | | ...                           | | [ Bottom Detail Pane (Original) ]                                | |
| |                                   | | [ Bottom Detail Pane (Response) ]                                | |
+-------------------------------------------------------------------------------------------------+
```
*   **`[ Back to Code View ]`:** A button to exit the diff mode and return to the single-file code viewer.
*   **Location Pane:** A new (future) component that provides a high-level, vertical map of the differences in the entire file, similar to WinMerge.

## 3. User Interaction Flow

1.  **Paste & Parse:** User pastes responses and clicks "Parse All".
2.  **Select for Replacement:**
    *   The user reviews "Resp 1". They decide they want most of it.
    *   They click the **"Select this response"** checkbox. All files in the "Associated Files" list become checked.
    *   They see one file, `config.ts`, that they don't want to change. They uncheck the box next to `config.ts`.
3.  **Accept Bulk Changes:** The user clicks the **"Accept Selected Files"** button. The extension overwrites the content of all checked workspace files with the content from "Resp 1".
4.  **View Individual Diff:**
    *   The user switches to "Resp 2" and selects `view.tsx` in the "Associated Files" list.
    *   They click **"View Diff"**. The right pane changes to the diff view.
5.  **Keyboard Navigation in Diff:**
    *   The user presses the **Down Arrow** key to jump to the first difference.
    *   They like the change, so they press the **Right Arrow** key. The change is visually applied in the right-hand (original) pane.
    *   They navigate to the next difference and repeat the process.
6.  **Exit Diff:** The user clicks **"Back to Code View"** to return to the normal code viewer.
</file>

<file path="src/Artifacts/A36. DCE - Phase 2 - Technical Implementation Plan.md">
# Artifact A36: DCE - Phase 2 - Technical Implementation Plan
# Date Created: C69
# Author: AI Model
# Updated on: C96 (Add persistent parse mode and robust new cycle logic)

- **Key/Value for A0:**
- **Description:** Details the technical approach for building the Parallel Co-Pilot Panel, including the new webview provider, state management, IPC channels, and backend logic for file content swapping.
- **Tags:** feature plan, phase 2, technical plan, architecture, webview, ipc, parsing, markdown, diff

## 1. Overview

This document outlines the technical implementation strategy for the Parallel Co-Pilot Panel. The plan is updated to reflect a two-pane UI for diffing, a smarter parser, more resilient backend path resolution, and several UI/UX fixes from Cycle 96.

## 2. Core Components

### 2.1. Frontend State Management (`view.tsx`)

The component state will be expanded to manage the new UI features.

```typescript
// State within the view.tsx component
interface PcppState {
  // ... existing state
  tabCount: number; // New: To control the number of response tabs
  isParsedMode: boolean;
  fileExistenceMap: Map<string, boolean>;
  diffTarget: ParsedFile | null;
  originalFileContent: string | null;
  // New: Separate state for each collapsible section
  isCycleCollapsed: boolean;
  isSummaryCollapsed: boolean;
  isCourseOfActionCollapsed: boolean;
  isAssociatedFilesCollapsed: boolean;
}
```
*   **`tabCount`**: A new state to control the number of tabs rendered.
*   **Collapsible States**: New booleans to manage the UI state for each collapsible section independently.

### 2.2. Persistent "Parsed Mode"

*   **Goal:** The `isParsedMode` state should be "sticky." If the user is in parsed mode and navigates to another cycle, the new cycle's content should be automatically parsed and displayed.
*   **Implementation:**
    1.  **Backend (`history.service.ts`):** The `PcppCycle` interface will be updated to include `isParsedMode: boolean`.
    2.  **Frontend (`view.tsx`):**
        *   The `saveCurrentCycleState` function will be updated to include the current `isParsedMode` in the data sent to the backend.
        *   When loading a cycle (either the latest or via navigation), the `isParsedMode` state will be restored from the loaded `cycleData`.
        *   A `useEffect` hook will listen for changes to the loaded cycle data. If `isParsedMode` is true after the data loads, it will automatically trigger the parsing logic for all tabs.

### 2.3. Robust "New Cycle" Button Logic

*   **Goal:** The `[ + ]` (New Cycle) button must be disabled if no meaningful content has been added to the current cycle.
*   **Implementation (`view.tsx`):** The `disabled` property of the button will be controlled by a memoized boolean:
    ```typescript
    const isNewCycleButtonDisabled = useMemo(() => {
        const hasTitle = cycleTitle && cycleTitle !== 'New Cycle';
        const hasContext = cycleContext || ephemeralContext;
        const hasResponseContent = Object.values(tabs).some(tab => tab.rawContent.trim());
        return !hasTitle && !hasContext && !hasResponseContent;
    }, [cycleTitle, cycleContext, ephemeralContext, tabs]);
    ```

### 2.4. Backend File Existence & Content (`fs.service.ts`)

*   **Status:** No changes required for this cycle. The existing plan for smarter path resolution and content fetching remains valid.

### 2.5. IPC Channel Updates

*   **Status:** No new channels required for this cycle.

### 2.6. Frontend UI Flow for Diffing (`view.tsx`)

*   **Goal:** Fix the non-functional diff view.
*   **Implementation:**
    1.  Add detailed `logger.log()` statements to the `handleSelectForDiff` function to confirm it is being called on click.
    2.  Log the `file.path` being sent over `RequestFileContent`.
    3.  Add logging to the `onmessage` handler for `SendFileContent` to confirm a response is received from the backend.
    4.  Log the state variables (`diffTarget`, `originalFileContent`) just before the component's `return` statement to verify they are being set correctly. This will isolate the point of failure.
</file>

<file path="src/Artifacts/A37. DCE - Phase 2 - Cycle Navigator & Knowledge Graph - Vision.md">
# Artifact A37: DCE - Phase 2 - Cycle Navigator & Knowledge Graph - Vision
# Date Created: C70
# Author: AI Model

- **Key/Value for A0:**
- **Description:** Outlines the vision for a cycle-based navigation system to browse the history of AI-generated responses and project states, creating a navigable knowledge graph.
- **Tags:** feature plan, phase 2, knowledge graph, history, cycle navigator, ui, ux

## 1. Vision & Goal

As the Data Curation Environment matures, the interaction history with the AI becomes a valuable asset in itself. Currently, this history is ephemeral, existing only within the context of a single session. The vision for the **Cycle Navigator & Knowledge Graph** is to capture this history and make it a persistent, navigable, and core feature of the development workflow.

The goal is to transform the series of AI interactions from a linear conversation into a structured, explorable history of the project's evolution. This creates a "knowledge graph" where each node is a development cycle, and the edges are the AI-generated solutions that led from one cycle to the next.

## 2. Core Concepts

1.  **Cycle-Based History:** The fundamental unit of history is the "Cycle." Every time the curator sends a prompt and receives responses, that entire transaction is associated with a unique Cycle ID (e.g., `C70`).
2.  **Persistent Response Storage:** All AI-generated responses (the content that would be pasted into the Parallel Co-Pilot tabs) are saved and tagged with their corresponding Cycle ID.
3.  **UI for Navigation:** A simple, non-intrusive UI will be added to the Parallel Co-Pilot panel, allowing the user to step backward and forward through the cycles.
4.  **Historical Context Loading:** As the user navigates to a past cycle (e.g., from `C70` to `C69`), the Parallel Co-Pilot panel will automatically load the set of AI responses that were generated during that cycle.

## 3. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| P2-US-06 | **Navigate Project History** | As a developer, I want to navigate backward and forward through my project's development cycles, so I can review past decisions and the AI suggestions that prompted them. | - A UI control (e.g., left/right arrows and a cycle number display) is present in the Parallel Co-Pilot panel. <br> - Clicking the arrows changes the currently viewed cycle. |
| P2-US-07 | **View Historical Responses** | As a developer, when I navigate to a previous cycle, I want the Parallel Co-Pilot tabs to automatically populate with the AI-generated responses from that specific cycle, so I can see exactly what options I was considering at that time. | - Navigating to a cycle loads the associated set of AI responses into the tabs. <br> - The metadata (token counts, etc.) for these historical responses is also displayed. |
| P2-US-08 | **Preserve Interaction Context** | As a developer, I want every AI response to be automatically saved and associated with the current cycle, so a complete and accurate history of the project is built over time. | - A mechanism exists to automatically persist all AI responses received. <br> - Each response is tagged with a Cycle ID and a unique response UUID. |
</file>

<file path="src/Artifacts/A38. DCE - Phase 2 - Cycle Navigator - UI Mockup.md">
# Artifact A38: DCE - Phase 2 - Cycle Navigator - UI Mockup
# Date Created: C70
# Author: AI Model

- **Key/Value for A0:**
- **Description:** Provides a textual mockup and interaction flow for the Cycle Navigator UI, including the cycle counter and navigation controls within the Parallel Co-Pilot Panel.
- **Tags:** feature plan, phase 2, ui, ux, mockup, workflow, cycle navigator

## 1. Overview

This document describes the proposed user interface (UI) for the Cycle Navigator. The design prioritizes simplicity and integration, placing the navigation controls directly within the Parallel Co-Pilot Panel, reinforcing the connection between the cycle history and the AI responses.

## 2. UI Mockup (Textual Description)

The Cycle Navigator will be a new UI element added to the top of the Parallel Co-Pilot Panel, positioned just below the main header and above the tab configuration slider.

```
+-----------------------------------------------------------------+
| [Parallel Co-Pilot] [Settings Icon]                             |
|-----------------------------------------------------------------|
| Cycle: [ < ] [ C70 ] [ > ]                                      |
|-----------------------------------------------------------------|
| Number of Tabs: [Slider: 1 to 8]  (Current: 4)                  |
|=================================================================|
| [ Tab 1 (active) ] [ Tab 2 ] [ Tab 3 ] [ Tab 4 ] [ + ]           |
|-----------------------------------------------------------------|
|                                                                 |
|   [Swap with Source]                                            |
|                                                                 |
|   Source: src/services/user.service.ts                          |
|   ------------------------------------------------------------  |
|   |          | Original Source      | This Tab (Response 1) |  |
|   | Lines    | 150                  | 165                   |  |
|   | Tokens   | 2.1K                 | 2.4K                  |  |
|   |----------|----------------------|-----------------------|  |
|   | Similarity Score: 85%                                   |  |
|   ------------------------------------------------------------  |
|                                                                 |
|   [Text editor area where user pastes AI-generated code...]     |
|   |                                                         |   |
|   | export class UserService {                              |   |
|   |   // ... AI generated code ...                           |   |
|   | }                                                       |   |
|   |                                                         |   |
|                                                                 |
+-----------------------------------------------------------------+
```

### 2.1. UI Components Breakdown

1.  **Cycle Navigator Bar:**
    *   A new horizontal bar containing the navigation controls.
    *   **Label:** "Cycle:".
    *   **Previous Button (`<`):** A button with a left-arrow icon. Clicking it navigates to the previous cycle (e.g., `C69`). The button is disabled if the user is at the very first recorded cycle.
    *   **Cycle Display (`C70`):** A read-only (or potentially editable) text field showing the ID of the currently viewed cycle.
    *   **Next Button (`>`):** A button with a right-arrow icon. Clicking it navigates to the next cycle (e.g., `C71`). The button is disabled if the user is at the most recent cycle.

## 3. User Interaction Flow

1.  **Initial State:** The user is working on Cycle 70. The Cycle Display shows `C70`. The `>` button is disabled. The Parallel Co-Pilot tabs show the AI responses generated for Cycle 70.
2.  **Navigate Back:**
    *   The user clicks the **`<`** button.
    *   **Action:** The extension's state updates to the previous cycle, `C69`.
    *   **UI Update:** The Cycle Display changes to `C69`.
    *   **Data Load:** The Parallel Co-Pilot panel fetches the historical data for Cycle 69. The tabs are cleared and re-populated with the AI responses that were generated during that cycle. The metadata and similarity scores all update to reflect this historical data. Both `<` and `>` buttons are now enabled.
3.  **Navigate Forward:**
    *   The user is viewing Cycle 69 and clicks the **`>`** button.
    *   **Action:** The state moves forward to `C70`.
    *   **UI Update & Data Load:** The UI returns to the state described in step 1. The `>` button becomes disabled again.
</file>

<file path="src/Artifacts/A39. DCE - Phase 2 - Cycle Navigator - Technical Plan.md">
# Artifact A39: DCE - Phase 2 - Cycle Navigator - Technical Plan
# Date Created: C70
# Author: AI Model
# Updated on: C92 (Revise initialization flow to fix persistence issues)

- **Key/Value for A0:**
- **Description:** Details the technical approach for implementing the Cycle Navigator, including data structures for storing cycle-specific responses and the state management for historical navigation.
- **Tags:** feature plan, phase 2, technical plan, architecture, state management, data model

## 1. Overview

This document outlines the technical strategy for implementing the Cycle Navigator and PCPP persistence. The implementation will require a structured data format for storing historical data, enhancements to the frontend state management, new IPC channels, and robust backend logic for data persistence. The key change in this revision is a new initialization flow to make the backend the single source of truth, resolving state loss on reload or window pop-out.

## 2. Data Structure and Persistence

A structured approach to storing the historical data is critical. A simple JSON file stored within the workspace's `.vscode` directory is a suitable starting point.

### 2.1. `dce_history.json` (Example)

```json
{
  "version": 1,
  "cycles": [
    {
      "cycleId": 91,
      "timestamp": "2025-08-20T12:30:00Z",
      "title": "Initial implementation",
      "cycleContext": "Long-term notes...",
      "ephemeralContext": "<console_log>...</console_log>",
      "responses": {
        "1": { "content": "<src/client/views/view.tsx>...</file>" },
        "2": { "content": "..." },
        "3": { "content": "" }
      }
    },
    {
      "cycleId": 92,
      "timestamp": "2025-08-21T10:00:00Z",
      "title": "Persistence fix",
      "cycleContext": "Focus on fixing state loss.",
      "ephemeralContext": "",
      "responses": {
        "1": { "content": "" }, "2": { "content": "" }, "3": { "content": "" }, "4": { "content": "" }
      }
    }
  ]
}
```

*   **Backend (`history.service.ts`):** This service will manage reading from and writing to `dce_history.json`. It will handle file locking to prevent race conditions and provide methods like `getCycle(cycleId)`, `saveCycle(cycleData)`, `getCycleList()`, and a new `getLatestCycle()`.

## 3. Frontend State Management & Initialization Flow (C92 Revision)

### 3.1. Initialization
1.  **Problem:** Previously, the frontend managed its own state and only requested pieces of data, leading to state loss when the webview was re-initialized (e.g., on reload or pop-out).
2.  **Solution:** The new flow makes the backend the single source of truth.
    *   On component mount, the frontend sends a single new IPC message: `RequestLatestCycleData`.
    *   The backend's `HistoryService` finds the cycle with the highest `cycleId` in `dce_history.json`. If the file is empty, it creates a default "Cycle 1" object.
    *   The backend sends this complete `PcppCycle` object back to the client via `SendLatestCycleData`.
    *   The frontend's message handler uses this single object to populate its *entire* initial state: `currentCycleId`, `maxCycleId`, `cycleTitle`, `cycleContext`, `ephemeralContext`, and all `tabs` content. This guarantees the UI always starts with the latest saved data.

### 3.2. State Management (`parallel-copilot.view.tsx`)
```typescript
interface PcppState {
  currentCycleId: number;
  maxCycleId: number;
  cycleTitle: string;
  // ... other state
}
```
*   The state remains largely the same, but it is now initialized from a single backend message.
*   A "New Cycle" button (`+`) will be added. Its handler will increment `maxCycleId`, set `currentCycleId = maxCycleId`, clear the UI fields, and trigger a `saveCycleData` call to create the new empty cycle record.

## 4. IPC Communication

*   **REMOVED:** `RequestCycleHistoryList`.
*   **NEW:** `ClientToServerChannel.RequestLatestCycleData`:
    *   **Payload:** `{}`
    *   **Action:** Frontend requests the full data object for the most recent cycle.
*   **NEW:** `ServerToClientChannel.SendLatestCycleData`:
    *   **Payload:** `{ cycleData: PcppCycle }`
    *   **Action:** Backend sends the complete, latest cycle data to the frontend for initialization.
*   `ClientToServerChannel.RequestCycleData`: Still used for navigating to *older* cycles.
*   `ClientToServerChannel.SaveCycleData`: Unchanged. It sends the entire state of the *current* cycle to the backend to be persisted. It's critical that the `cycleId` in the payload is correct.
</file>

<file path="src/Artifacts/A4. DCE - Analysis of The-Creator-AI Repo.md">
# Artifact A4: DCE - Analysis of The-Creator-AI Repo
# Date Created: Cycle 2
# Author: AI Model
- **Description:** Provides a detailed analysis of the `The-Creator-AI-main` reference repository, its architecture, and its mapping to the Data Curation Environment project goals.
- **Tags:** analysis, repository, architecture, vscode-extension, project-planning

## 1. Overview

The `The-Creator-AI-main` repository is a comprehensive and well-structured VS Code extension that functions as a sophisticated AI coding assistant. It utilizes a modern tech stack including TypeScript, React for webviews, and TailwindCSS for styling. Its architecture is service-oriented on the backend (extension host) and modular on the frontend (webview). The discovery of this repository provides a massive head-start for our project, as it contains pre-built solutions for many of our planned features.

## 2. Backend Architecture (Extension Host)

The backend, located primarily in `src/backend/`, follows a clean, service-oriented architecture.

-   **`extension.ts`**: The main entry point. It initializes services and registers the commands and webview providers.
-   **`services/`**: A directory containing distinct services for handling specific concerns:
    -   `LlmService.ts`: Manages interactions with multiple AI models (Gemini, OpenAI). It includes logic for API key management and prompt construction.
    -   `FSService.ts`: Handles all file system operations, including reading files, creating a file tree, and respecting `.gitignore`.
    -   `CodeService.ts`: Contains logic for applying code changes, parsing diffs, and generating code.
    -   `GitService.ts`: Provides an interface for Git operations, like committing changes.
    -   `MessageService.ts`: Orchestrates the flow of messages between the frontend and the LLM service.
    -   `PlanExImService.ts`: Manages exporting and importing of "Change Plans".
    -   `Services.ts`: A dependency injection container that initializes and provides access to all other services.
-   **`repositories/`**: Manages data persistence within the VS Code workspace state (e.g., `PersistentStoreRepository.ts`, `SettingsRepository.ts`).
-   **`commands/`**: Defines all the commands exposed by the extension in `package.json`.

## 3. Frontend Architecture (Webview)

The frontend, located in `src/client/`, is a React application bundled with Webpack.

-   **`views/`**: The application is divided into distinct views, each with its own entry point, state management, and logic (e.g., `change-plan.view`).
-   **`modules/`**: Contains reusable UI/logic modules that are composed into the main view, such as:
    -   `context.module/Context.tsx`: Renders the file explorer.
    -   `plan.module/Plan.tsx`: Handles displaying the AI-generated plan and user input.
-   **`components/`**: A collection of generic, reusable React components:
    -   `file-tree/FileTree.tsx`: A fully functional file tree component with checkbox selection, expansion state, and active file highlighting. This is directly applicable to our Phase 1 goal.
    -   `AutoResizingTextarea.tsx`, `Modal.tsx`, `ProgressSteps.tsx`: Other useful UI components.
-   **State Management**: Each view appears to have its own local store (`store/`), using RxJS `BehaviorSubject` for reactivity. This is a simple yet effective approach for managing state within a contained webview.
-   **IPC**: Communication with the backend is handled via a robust `ClientPostMessageManager` (`src/common/ipc/`) which defines clear channels for client-server interaction.

## 4. Mapping to DCE Project Goals

The reference repository provides solutions or strong foundations for all three of our project phases.

-   **Phase 1 (Context Chooser):** **Largely Complete.** The `FileTree.tsx` component in `src/client/components/file-tree/` combined with `FSService.ts` on the backend already provides the core functionality of a checkbox-based file explorer for context selection. Our work shifts from building this from scratch to adapting and integrating this existing, powerful component.

-   **Phase 2 (Parallel 'Co-pilot' Panel):** **Partially Complete.** The "Change Plan" view (`src/client/views/change-plan.view/`) is essentially a single "co-pilot" panel. It allows a user to describe a change, get an AI-generated plan, and interact with it. Our goal of *parallel* panels is not implemented, but the foundation for a single panel is incredibly strong.

-   **Phase 3 (Diff Tool):** **Not Present.** There is no integrated diff-viewing tool like WinMerge. However, the `CodeService.ts` *does* contain logic for parsing and applying diffs in a custom `<<<<<<< SEARCH` format, and the extension can trigger VS Code's native diff viewer (`git.openChange`).

## 5. Recommendations & Path Forward

1.  **Adopt the Architecture:** We should officially adopt the architecture of `The-Creator-AI-main` as the blueprint for our project. It is robust, scalable, and well-organized.
2.  **Focus on Adaptation:** Our immediate efforts for Phase 1 should be to isolate the `FileTree` component and its backend dependencies (`FSService.ts`) and ensure they can be used to generate the `flattened_repo.md` as originally specified.
3.  **De-risk Phase 2:** The "Change Plan" functionality is a perfect starting point for our parallel co-pilot. We should analyze its state management and IPC communication to understand how we might instantiate multiple, independent instances of it.
4.  **Update All Documentation:** All planning artifacts (`A1`, `A2`, `A3`) must be updated immediately to reflect this new context. Our plan has evolved from "build" to "analyze, adapt, and extend".
</file>

<file path="src/Artifacts/A40. DCE - Phase 2 - Parallel Co-Pilot - Target File Structure.md">
# Artifact A40: DCE - Phase 2 - Parallel Co-Pilot - Target File Structure
# Date Created: C71
# Author: AI Model

- **Key/Value for A0:**
- **Description:** A text-based representation of the new files and components required to build the Phase 2 Parallel Co-Pilot and Cycle Navigator features.
- **Tags:** file structure, architecture, project layout, scaffolding, phase 2

## 1. Overview

This document outlines the new files and directories that will be created to support the development of the Phase 2 features: the Parallel Co-Pilot Panel and the Cycle Navigator. This structure is designed to be modular and integrate cleanly with our existing architecture. This artifact also serves as the "pre-computation" plan requested in C71, allowing for a script to be created to scaffold these files when development begins.

## 2. New File Tree for Phase 2

This tree shows only the **new** files and directories to be added. Existing directories will be modified to import and use these new components.

```
src/
â”œâ”€â”€ backend/
â”‚   â””â”€â”€ services/
â”‚       â””â”€â”€ history.service.ts      # New: Manages reading/writing dce_history.json
â”‚
â””â”€â”€ client/
    â”œâ”€â”€ components/
    â”‚   â”œâ”€â”€ DiffViewer.tsx          # New (for Phase 3, but can be stubbed): A component for side-by-side text diffing.
    â”‚   â”œâ”€â”€ Slider.tsx              # New: A simple reusable slider component for the tab count.
    â”‚   â””â”€â”€ TabbedEditor.tsx        # New: The core multi-tab editor component.
    â”‚
    â”œâ”€â”€ views/
    â”‚   â””â”€â”€ parallel-copilot.view/  # New View for Phase 2
    â”‚       â”œâ”€â”€ index.ts
    â”‚       â”œâ”€â”€ on-message.ts
    â”‚       â”œâ”€â”€ view.scss
    â”‚       â””â”€â”€ view.tsx            # Main React component for the Parallel Co-Pilot panel
    â”‚
    â””â”€â”€ utils/
        â””â”€â”€ string-similarity.ts    # New: A lightweight utility for calculating string similarity scores.

.vscode/
â””â”€â”€ dce_history.json                # New (auto-generated): Stores the cycle history and AI responses.
```

## 3. Component & Service Descriptions

### Backend

-   **`src/backend/services/history.service.ts`:**
    -   **Responsibility:** Solely responsible for abstracting the file I/O for the `dce_history.json` file.
    -   **Methods:** `getCycleHistory()`, `getCycleData(cycleId)`, `saveResponseToCycle(...)`. This keeps the main `fs.service.ts` clean from business logic.

### Frontend Components

-   **`src/client/views/parallel-copilot.view/`:**
    -   This new directory will contain everything needed for the new panel, following the same structure as our existing `context-chooser.view`.
    -   `view.tsx` will be the main component, managing the state for all tabs, the current cycle, and orchestrating IPC communication.
-   **`src/client/components/TabbedEditor.tsx`:**
    -   A component that will manage the tab bar and the content of each tab editor, receiving the array of tab data as props.
-   **`src/client/components/Slider.tsx`:**
    -   A simple, reusable slider component to control the number of tabs. This extracts UI logic from the main view.
-   **`src/client/utils/string-similarity.ts`:**
    -   Will contain a function to calculate the similarity between two strings, likely implementing the Dice Coefficient or a similar algorithm. This keeps the calculation logic separate and testable.

### Root Directory

-   **`.vscode/dce_history.json`:**
    -   This file will be automatically created and managed by the `HistoryService`. Storing it in `.vscode` is standard practice for workspace-specific extension data that should not typically be checked into source control. It will be added to `.gitignore`.
</file>

<file path="src/Artifacts/A40.1. DCE - Phase 2 - Competitive Analysis & Feature Ideas.md">
# Artifact A40.1: DCE - Phase 2 - Competitive Analysis & Feature Ideas
# Date Created: C71
# Author: AI Model
# Updated on: C71 (Incorporate user feedback and consolidate ideas)

- **Key/Value for A0:**
- **Description:** An analysis of existing tools and extensions for managing multiple AI responses, with a list of potential features to incorporate into the Parallel Co-Pilot panel.
- **Tags:** feature plan, phase 2, research, competitive analysis, co-pilot

## 1. Overview

As requested in Cycle 71, this document summarizes research into existing tools that address the problem of managing and comparing multiple AI-generated code responses. The goal is to identify common features, discover innovative ideas, and ensure our Phase 2 "Parallel Co-Pilot Panel" is a best-in-class solution.

## 2. Research Summary

A search for "VS Code extensions for comparing AI responses" reveals that while many extensions integrate a single AI chat (like GitHub Copilot Chat), very few are designed for the specific workflow of managing *multiple, parallel* responses to the *same* prompt. [1, 3] This represents a significant opportunity for our project. The "AI Toolkit for Visual Studio Code" is a notable exception, offering features to run prompts against multiple models simultaneously and compare the results, validating our core concept. [1, 2]

Most developers still use a manual process involving external tools:
1.  Pasting responses into separate tabs in a text editor (Notepad++, Sublime Text).
2.  Using a dedicated diff tool (WinMerge, Beyond Compare, VS Code's native diff) to compare two responses at a time.

The key pain point is the friction of moving text between applications and the lack of an integrated testing loop, which our "swap" feature directly addresses.

## 3. Existing Tools & Inspirations

| Tool / Extension | Relevant Features | How It Inspires DCE |
| :--- | :--- | :--- |
| **AI Toolkit for VS Code** | - "Bulk Run" executes a prompt across multiple models simultaneously. [1] <br> - "Compare" view for side-by-side model responses. [2] <br> - Model evaluation with metrics like similarity and relevance. [2] | This extension is the closest conceptually to our goal. It validates the need for parallel prompting and comparison. Our "swap" feature for live testing remains a key differentiator. |
| **Cursor.sh (IDE)** | - A fork of VS Code built around an AI-first workflow. <br> - "Auto-debug" feature attempts to fix errors. <br> - Inline diffing for AI-suggested changes. | Cursor's deep integration is a long-term inspiration. An "Auto-fix TS Errors" button in our panel could be a powerful feature, where we send the code + errors back to the AI. |
| **Continue.dev** | - Open-source and customizable. <br> - Strong concept of "Context Providers," very similar to our Phase 1. | Their flexible context system is a good model. A future DCE feature could allow highlighting a specific function and sending *just that* to the Parallel Co-Pilot panel for iteration. |

## 4. New Feature Ideas for DCE Phase 2 (Refined with C71 Feedback)

Based on the analysis and our project goals, here are some new or refined feature ideas for the Parallel Co-Pilot Panel:

| Feature Idea | Description |
| :--- | :--- |
| **"Accept Response" Button** | As per user feedback, this is a more intuitive name than "Promote to Source". A button to overwrite the source file with the tab's content without swapping back. This signifies a permanent acceptance of the AI's suggestion for that cycle. |
| **One-Click Diff View** | A button that opens VS Code's native diff viewer, comparing the tab's content with the original source file. This is a great stepping stone to our fully integrated Phase 3 diff tool. |
| **AI-Powered Summary of Changes** | A button that sends the original code and the tab's code to an LLM with a prompt like "Summarize the key changes between these two code blocks." The summary would be displayed in the tab's metadata area. |
| **Response Annotation & Rating** | A feature the user liked: Allow adding thumbs up/down, tags (e.g., `refactor`, `bug-fix`), and comments to each response tab. This metadata would be saved with the cycle history, adding valuable context. |
| **Intent Buttons** | As per user feedback, instead of slash commands, provide clear buttons for common refinement tasks like "Add Documentation," "Find Bugs," or "Refactor for Readability." These would re-prompt the AI with the tab's content and the specific instruction. |
| **Ephemeral "Cycles Context" Field** | As per user feedback, add a separate text field for temporary context like error logs that are useful for the current cycle's prompt but should not be saved in the long-term cycle history to avoid token bloat. |
</file>

<file path="src/Artifacts/A41. DCE - Phase 2 - API Key Management - Feature Plan.md">
# Artifact A41: DCE - Phase 2 - API Key Management - Feature Plan
# Date Created: C71
# Author: AI Model

- **Key/Value for A0:**
- **Description:** Outlines the user stories and technical plan for a settings UI where users can securely input and manage their API keys for various LLM services or a local endpoint URL.
- **Tags:** feature plan, phase 2, settings, api key, configuration, security

## 1. Overview & Goal

As the DCE project moves into Phase 2, it will begin to make its own API calls to LLM providers. To do this securely and flexibly, the extension needs a dedicated interface for users to manage their API keys and specify a local LLM endpoint. The goal of this feature is to provide a simple, secure, and intuitive settings panel for managing these credentials.

This functionality is heavily inspired by the `ApiKeysManagement.tsx` module in the `The-Creator-AI-main` reference repository.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| P2-API-01 | **Configure API Key** | As a user, I want to add an API key for a specific cloud service (e.g., Gemini, OpenAI), so the extension can make API calls on my behalf. | - A UI is available to add a new API key. <br> - I can select the LLM provider from a dropdown list. <br> - I can paste my key into a text field. <br> - The key is stored securely using VS Code's `SecretStorage` API. |
| P2-API-02 | **Configure Local LLM Endpoint** | As a user with a local LLM (e.g., via LM Studio), I want to provide an API endpoint URL, so the extension can use my local model instead of a cloud service. | - The settings UI has a dedicated input field for a local LLM API URL. <br> - The URL is saved to the workspace settings. <br> - The extension prioritizes using this URL if it is set. |
| P2-API-03 | **View Saved Keys** | As a user, I want to see a list of my saved API keys (partially masked), so I can confirm which keys I have configured. | - The settings UI displays a list of all saved API keys. <br> - Keys are grouped by service. <br> - The key values are partially masked for security (e.g., `sk-xxxx...1234`). |
| P2-API-04 | **Delete an API Key** | As a user, I want to delete an API key that I no longer use, so I can manage my credentials. | - Each listed API key has a "Delete" button. <br> - Clicking "Delete" prompts for confirmation. <br> - Upon confirmation, the key is removed from the extension's secure storage. |
| P2-API-05 | **Secure Storage** | As a developer, I want API keys to be stored securely using VS Code's `SecretStorage` API, so sensitive user credentials are not exposed as plain text. | - API keys are not stored in plain text in `settings.json` or workspace state. <br> - The `SecretStorage` API is used to encrypt and store the keys, associating them with the extension. |

## 3. Technical Implementation Plan

1.  **New View / Command:**
    *   A new command, `dce.openApiSettings`, will be created. This command will open a new webview panel dedicated to API key management. This keeps the UI clean and separate from the main workflow panels.
    *   This can be triggered from a "Settings" icon within the Parallel Co-pilot view.

2.  **Backend (`settings.service.ts` - New):**
    *   A new `SettingsService` will be created to handle the logic for storing and retrieving secrets and settings.
    *   **API Key Storage:** It will use `vscode.ExtensionContext.secrets` (the `SecretStorage` API) for all API key operations.
    -   **Local URL Storage:** It will use the standard `vscode.workspace.getConfiguration` API to get/set the local LLM URL in the workspace `settings.json`.
    *   **Methods:** It will expose methods like `setApiKey(service: string, key: string)`, `getApiKeys()`, `deleteApiKey(service: string)`, `getLocalLlmUrl()`, and `setLocalLlmUrl(url: string)`. The `getApiKeys` method will return a structure with masked keys for the UI.

3.  **Frontend (New `api-settings.view.tsx`):**
    *   This new React view will render the UI for managing keys and the local endpoint URL.
    *   It will communicate with the backend `SettingsService` via new IPC channels.

4.  **IPC Channels:**
    *   `RequestApiKeys`: Frontend asks for the list of saved (masked) keys.
    *   `SendApiKeys`: Backend sends the list of keys.
    *   `SaveApiKey`: Frontend sends a new service and key to the backend.
    *   `DeleteApiKey`: Frontend requests the deletion of a specific key.
    *   `RequestLocalLlmUrl` / `SendLocalLlmUrl`
    *   `SaveLocalLlmUrl`
</file>

<file path="src/Artifacts/A41.1. DCE - Phase 2 - Advanced Features & Integrations Plan.md">
# Artifact A41.1: DCE - Phase 2 - Advanced Features & Integrations Plan
# Date Created: C71
# Author: AI Model

- **Key/Value for A0:**
- **Description:** Explores future enhancements for the Parallel Co-Pilot, such as applying AI responses as diff patches and integrating with Git for direct commits.
- **Tags:** feature plan, phase 2, ideation, diff, patch, git, workflow

## 1. Overview & Goal

This document explores potential high-impact features that could be built on top of the core Parallel Co-Pilot panel. The goal is to move beyond simple "swap" functionality and create a more powerful, integrated, and intelligent workflow for reviewing and applying AI-generated code. These ideas are intended for consideration and prioritization during Phase 2 development.

## 2. Proposed Advanced Features

### 2.1. Idea: Apply as Diff/Patch

-   **Problem:** The current "swap" feature is a blunt instrument. It replaces the entire file, which can be risky if the AI only intended to change a small part of it and made a mistake elsewhere. It also makes it hard to see exactly what changed.
-   **Proposed Solution:**
    1.  **Diff Generation:** When an AI response is pasted into a tab, the extension automatically generates a diff between the tab's content and the original source file.
    2.  **Inline Diff View:** The editor in the tab could be enhanced to show an inline diff view (similar to VS Code's source control view), highlighting added and removed lines.
    3.  **"Apply Patch" Button:** The "Swap" button is replaced with an "Apply Patch" button. Clicking it would attempt to apply only the identified changes to the source file, leaving the rest of the file untouched. This is a much safer and more precise way to integrate AI suggestions.
-   **Technical Notes:** This would require a diffing library (e.g., `diff-match-patch` or `jsdiff`) on the frontend or backend to generate and apply patches.

### 2.2. Idea: Integrated Git Workflow

-   **Problem:** After a developer tests and accepts an AI suggestion, the next step is almost always to commit the change. This requires leaving the co-pilot panel and using the source control view.
-   **Proposed Solution:**
    1.  **"Commit This Change" Button:** Add a new button to each tab in the Parallel Co-Pilot panel.
    2.  **Workflow:**
        *   The user swaps in the AI code and verifies it works.
        *   They click "Commit This Change".
        *   The extension automatically stages the modified file (`git add <file_path>`).
        *   The extension opens the Source Control commit input box.
        *   **Enhancement:** The commit message box could be pre-populated with a summary of the changes, potentially generated by another AI call based on the diff.
-   **Technical Notes:** This requires deeper integration with the `vscode.git` extension API to programmatically stage files and interact with the commit box.

### 2.3. Idea: Response Annotation and Rating

-   **Problem:** It's difficult to remember why a particular AI response was good or bad, especially when looking back at the history via the Cycle Navigator.
-   **Proposed Solution:**
    1.  **Rating/Annotation UI:** Add a small section to each tab allowing the user to give a thumbs up/down rating and add a short text note (e.g., "Works, but inefficient" or "Best solution, very clean"). This includes highlighting specific sections of code to associate with a comment.
    2.  **Persistence:** These annotations would be saved as part of the `dce_history.json` file, associated with that specific response.
    3.  **Benefit:** When navigating back through cycles, these notes would provide valuable context about the quality and outcome of each AI suggestion, enhancing the "knowledge graph" of the project.
-   **Technical Notes:** This requires extending the data model in `A39` and adding the corresponding UI elements and state management.
</file>

<file path="src/Artifacts/A41.2. DCE - Phase 2 - Feature Ideation & Competitive Analysis.md">
# Artifact A41.2: DCE - Phase 2 - Feature Ideation & Competitive Analysis
# Date Created: C71
# Author: AI Model
# Updated on: C71 (Incorporate user feedback from C71)

- **Key/Value for A0:**
- **Description:** An analysis of similar AI coding assistant tools (e.g., Cursor.sh, Copilot Chat) and a brainstorm of potential advanced features for the Parallel Co-Pilot panel.
- **Tags:** feature plan, phase 2, research, competitive analysis, ideation, roadmap

## 1. Overview & Goal

The core vision of the Parallel Co-Pilot panel is to solve the "single-threaded" limitation of current AI chat interfaces. As we plan its implementation, it's valuable to analyze existing tools to identify best-in-class features and brainstorm new ideas that could give our extension a unique advantage. The goal of this document is to explore this landscape and generate a backlog of potential enhancements for Phase 2 and beyond, incorporating feedback from Cycle 71.

## 2. Competitive Analysis (Incorporating Search Results [1, 2, 3, 4])

### 2.1. GitHub Copilot Chat & Similar Tools
-   **Strengths:** Deeply integrated, understands editor context, uses "slash commands" (`/fix`, `/doc`) for specific intents. [5]
-   **Weakness (Our Opportunity):** Fundamentally a linear, single-threaded chat. Comparing multiple responses to a single prompt is difficult and requires manual copy-pasting. Our parallel tabbed view is a direct solution to this.

### 2.2. Cursor.sh
-   **Strengths:** An "AI-first" fork of VS Code. Has an "AI-diff" feature that applies changes directly in the editor with an intuitive diff view.
-   **Weakness (Our Opportunity):** It's a separate application, not an extension. Users must leave their standard VS Code setup. Our tool integrates into the existing environment. The user has also specified a preference for a whole-file workflow over Cursor's chunk-based edits.

### 2.3. AI Toolkit for Visual Studio Code
-   **Strengths:** This is the most conceptually similar tool found. It explicitly supports a "Bulk Run" feature to execute prompts across multiple models simultaneously and a "Compare" view to see results side-by-side. [1, 2]
-   **Weakness (Our Opportunity):** While it excels at comparison, its workflow for *testing* the code within the user's live project is not as streamlined. Our "Swap" feature provides an immediate, integrated test loop that appears to be a unique advantage.

## 3. Brainstormed Feature Enhancements for DCE (Refined with C71 Feedback)

This is a backlog of potential features for the Parallel Co-Pilot panel, inspired by the analysis and our project's unique goals.

| Feature ID | Feature Name | Description | Priority |
| :--- | :--- | :--- | :--- |
| **P2-F01** | **Inline Diff View** | Instead of a blind "swap", clicking a button opens a diff view within the tab, comparing the AI response to the source file. The user can then accept the full change. | High |
| **P2-F02** | **AI Refinement Actions (Intent Buttons)** | Per user feedback, each tab will have a small toolbar with **buttons** like "Add Docs," "Find Bugs," or "Refactor." Clicking one sends the tab's content back to the LLM with that specific instruction, replacing the content with the refined response. | High |
| **P2-F03** | **Model Selection Per Tab** | Allow the user to select a different backend LLM (e.g., Gemini, Claude, Local URL) for each tab. This requires the API Key Management feature from `A41`. | Medium |
| **P2-F04** | **"Accept Response" Workflow** | Formalize the user's feedback. The "Swap" button is for temporary, iterative testing. A separate, explicit **"Accept Response"** button will permanently overwrite the source file, signifying the end of that iteration for that file. | High |
| **P2-F05** | **Response Annotation & Rating** | A feature the user liked: Add UI for thumbs up/down, short text notes, and tags (e.g., "works", "buggy"). This metadata is saved with the cycle history, enhancing the knowledge graph. | Medium |
| **P2-F06** | **Highlight-to-Context** | Allow a user to highlight a block of code in the main editor, right-click, and select "Send to Parallel Co-Pilot". This would open a new tab in the panel, pre-filled with the highlighted code. | Medium |
| **P2-F07** | **Ephemeral "Cycles Context" Field** | Per user feedback, add a separate text field for temporary context (e.g., error logs). This content is included in the prompt for the current cycle but is NOT saved to the permanent `dce_history.json` to prevent token bloat over time. | High |
</file>

<file path="src/Artifacts/A42. DCE - Phase 2 - Initial Scaffolding Deployment Script.md">
# Artifact A42: DCE - Phase 2 - Initial Scaffolding Deployment Script
# Date Created: C72
# Author: AI Model
# Updated on: C73 (Flesh out script with full placeholder content)

- **Key/Value for A0:**
- **Description:** Contains a Node.js script that, when executed, creates the file and directory structure for the Phase 2 Parallel Co-Pilot panel.
- **Tags:** deployment, script, scaffolding, bootstrap, nodejs, automation, phase 2

## 1. Overview

This artifact contains the `deploy_phase2_scaffold.js` script. Its purpose is to automate the creation of the new files and directories required for Phase 2, as outlined in `A40. DCE - Phase 2 - Parallel Co-Pilot - Target File Structure`. This ensures a consistent setup for starting development on the new features.

## 2. How to Use

1.  Save the code below as `deploy_phase2_scaffold.js` in your project's root directory (e.g., `C:\Projects\DCE\`).
2.  Open a terminal in that directory.
3.  Run the script using Node.js: `node deploy_phase2_scaffold.js`
4.  The script will create the new directories and placeholder files, logging its progress to the console.

## 3. Script: `deploy_phase2_scaffold.js`

```javascript
const fs = require('fs').promises;
const path = require('path');

// --- File Content Definitions ---

const filesToCreate = [
    {
        path: 'src/backend/services/history.service.ts',
        content: `// src/backend/services/history.service.ts
import * as vscode from 'vscode';
import { Services } from './services';

// Basic structure for history data
interface CycleResponse {
    responseId: string;
    model: string;
    content: string;
}

interface Cycle {
    cycleId: string;
    timestamp: string;
    prompt: string;
    responses: CycleResponse[];
}

interface HistoryFile {
    version: number;
    cycles: Cycle[];
}

export class HistoryService {
    private historyFilePath: string | undefined;

    constructor() {
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (workspaceFolders && workspaceFolders.length > 0) {
            this.historyFilePath = path.join(workspaceFolders.uri.fsPath, '.vscode', 'dce_history.json');
        }
    }

    private async _readHistoryFile(): Promise<HistoryFile> {
        if (!this.historyFilePath) return { version: 1, cycles: [] };
        try {
            const content = await vscode.workspace.fs.readFile(vscode.Uri.file(this.historyFilePath));
            return JSON.parse(Buffer.from(content).toString('utf-8'));
        } catch (error) {
            Services.loggerService.warn("dce_history.json not found or is invalid. A new one will be created.");
            return { version: 1, cycles: [] };
        }
    }

    private async _writeHistoryFile(data: HistoryFile): Promise<void> {
        if (!this.historyFilePath) return;
        const dir = path.dirname(this.historyFilePath);
        try {
            await vscode.workspace.fs.createDirectory(vscode.Uri.file(dir));
            const content = Buffer.from(JSON.stringify(data, null, 2), 'utf-8');
            await vscode.workspace.fs.writeFile(vscode.Uri.file(this.historyFilePath), content);
        } catch (error) {
            Services.loggerService.error(\`Failed to write to dce_history.json: \${error}\`);
        }
    }

    public async getCycleHistory() {
        Services.loggerService.log("HistoryService: getCycleHistory called.");
        const history = await this._readHistoryFile();
        return history.cycles.map(c => c.cycleId).sort(); // Return sorted list of cycle IDs
    }
}
`
    },
    {
        path: 'src/client/views/parallel-copilot.view/index.ts',
        content: `// src/client/views/parallel-copilot.view/index.ts
import { onMessage } from "./on-message";

export const viewConfig = {
    entry: "parallelCopilotView.js",
    type: "viewType.sidebar.parallelCopilot",
    handleMessage: onMessage,
};
`
    },
    {
        path: 'src/client/views/parallel-copilot.view/on-message.ts',
        content: `// src/client/views/parallel-copilot.view/on-message.ts
import { ServerPostMessageManager } from "@/common/ipc/server-ipc";
import { Services } from "@/backend/services/services";

export function onMessage(serverIpc: ServerPostMessageManager) {
    const loggerService = Services.loggerService;
    loggerService.log("Parallel Co-Pilot view message handler initialized.");

    // TODO: Add message handlers for Phase 2 features
    // e.g., serverIpc.onClientMessage(ClientToServerChannel.RequestSwapFileContent, ...)
}
`
    },
    {
        path: 'src/client/views/parallel-copilot.view/view.scss',
        content: `/* Styles for Parallel Co-Pilot View */
body {
    padding: 0;
    font-family: var(--vscode-font-family);
    font-size: var(--vscode-font-size);
    color: var(--vscode-editor-foreground);
    background-color: var(--vscode-sideBar-background);
}

.pc-view-container {
    padding: 8px;
    display: flex;
    flex-direction: column;
    height: 100vh;
    gap: 8px;
}

.cycle-navigator {
    display: flex;
    align-items: center;
    gap: 8px;
    padding-bottom: 8px;
    border-bottom: 1px solid var(--vscode-panel-border);
}

.tab-bar {
    display: flex;
    border-bottom: 1px solid var(--vscode-panel-border);
}

.tab {
    padding: 6px 12px;
    cursor: pointer;
    border-bottom: 2px solid transparent;
    color: var(--vscode-tab-inactiveForeground);
}

.tab.active {
    color: var(--vscode-tab-activeForeground);
    border-bottom-color: var(--vscode-tab-activeBorder);
}

.tab-content {
    padding-top: 8px;
}
`
    },
    {
        path: 'src/client/views/parallel-copilot.view/view.tsx',
        content: `// src/client/views/parallel-copilot.view/view.tsx
import * as React from 'react';
import * as ReactDOM from 'react-dom/client';
import './view.scss';
import { VscChevronLeft, VscChevronRight } from 'react-icons/vsc';

const App = () => {
    const [activeTab, setActiveTab] = React.useState(1);
    const tabCount = 4; // Example tab count

    return (
        <div className="pc-view-container">
            <div className="cycle-navigator">
                <span>Cycle:</span>
                <button><VscChevronLeft /></button>
                <span>C73</span>
                <button><VscChevronRight /></button>
            </div>
            
            <div className="tab-bar">
                {[...Array(tabCount)].map((_, i) => (
                    <div 
                        key={i} 
                        className={\`tab \${activeTab === i + 1 ? 'active' : ''}\`}
                        onClick={() => setActiveTab(i + 1)}
                    >
                        Response {i + 1}
                    </div>
                ))}
            </div>

            <div className="tab-content">
                {[...Array(tabCount)].map((_, i) => (
                    activeTab === i + 1 && <div key={i}>Content for Response {i + 1}</div>
                ))}
            </div>
        </div>
    );
};

const root = ReactDOM.createRoot(document.getElementById('root')!);
root.render(<App />);
`
    },
];

// --- Main Execution ---

async function deployScaffold() {
    console.log('Starting Phase 2 scaffold deployment...');
    const rootDir = process.cwd();

    for (const file of filesToCreate) {
        const fullPath = path.join(rootDir, file.path);
        const dir = path.dirname(fullPath);

        try {
            await fs.mkdir(dir, { recursive: true });
            await fs.writeFile(fullPath, file.content, 'utf-8');
            console.log(`âœ… Created: ${file.path}`);
        } catch (error) {
            console.error(`âŒ Failed to create ${file.path}: ${error.message}`);
        }
    }

    console.log('\\nðŸš€ Phase 2 scaffold deployment complete! ðŸš€');
    console.log('Next steps:');
    console.log('1. Review and apply changes to package.json, webpack.config.js, src/client/views/index.ts, and src/common/view-types.ts.');
    console.log('2. Update services.ts to instantiate and provide the new HistoryService.');
}

deployScaffold();
```
</file>

<file path="src/Artifacts/A43. DCE - Phase 2 - Implementation Roadmap.md">
# Artifact A43: DCE - Phase 2 - Implementation Roadmap
# Date Created: C72
# Author: AI Model
# Updated on: C87 (Promote Persistence and Diffing, defer advanced UI)

- **Key/Value for A0:**
- **Description:** Provides a step-by-step implementation plan for building the Phase 2 features, including the Parallel Co-Pilot panel and the integrated Diff Tool.
- **Tags:** feature plan, phase 2, roadmap, project plan, diff tool

## 1. Overview & Goal

This document provides a clear, step-by-step roadmap for the implementation of Phase 2. The scope of Phase 2 is now defined as the **Parallel Co-Pilot Panel with state persistence and an integrated Diff Tool**. This roadmap breaks the large feature set into smaller, manageable, and testable steps. The goal is to build the functionality incrementally, ensuring a stable foundation at each stage.

## 2. Implementation Steps

### Step 1: Foundational UI & State Persistence (Highest Priority)

-   **Goal:** Create a functional UI for the PCPP where all user input is saved and restored reliably.
-   **Tasks:**
    1.  **Scaffolding & Config:** Ensure all files from `A42` are in place and correctly configured in `package.json`, `webpack.config.js`, etc.
    2.  **UI Development (`view.tsx`):**
        *   Build the static React components for the panel based on the updated mockup in `A35`.
        *   **Crucially, re-add the "Cycle Context" and "Ephemeral Context" text areas to fix the C87 regression.**
    3.  **Backend (`history.service.ts`):** Implement the core logic to read from and write to the `.vscode/dce_history.json` file.
    4.  **State Sync Loop:** Implement the full persistence loop. Changes in the frontend UI trigger a debounced `SaveCycleData` IPC message. The backend `HistoryService` updates the JSON file.
-   **Outcome:** A visible panel where any text typed into any field is saved and restored when the panel is closed and reopened or moved to a new window.

### Step 2: Cycle Navigator

-   **Goal:** Enable navigation through the persistent history created in Step 1.
-   **Tasks:**
    1.  **IPC:** Implement the `RequestCycleHistoryList` and `RequestCycleData` channels.
    2.  **Frontend (`view.tsx`):**
        *   On load, fetch the list of all cycle IDs to determine the valid range for navigation (`1` to `maxCycleId`).
        *   Wire the `<` and `>` buttons to change the `currentCycleId` state.
        *   Create a `useEffect` hook that listens for changes to `currentCycleId` and requests the corresponding data from the backend.
        *   The handler for `SendCycleData` will update the entire panel's state with the historical data.
-   **Outcome:** The user can click the back and forward buttons to load and view the complete state of the PCPP from previous cycles.

### Step 3: File Association and Diffing

-   **Goal:** Implement the ability to see a diff for any file mentioned in an AI response.
-   **Tasks:**
    1.  **Add Dependency:** Add the `diff` library to `package.json`.
    2.  **UI (`view.tsx`):**
        *   Implement the "Associated Files" list UI element. It will be populated by the `detectedFiles` state, which is already being parsed.
        *   Make each file in the list a clickable button.
    3.  **IPC:** Create a `RequestFileContent` channel.
    4.  **Backend (`fs.service.ts`):** Implement a handler that reads a file's content and sends it back.
    5.  **Component (`DiffViewer.tsx`):** Create a new component that takes two strings and renders a side-by-side or inline diff.
    6.  **Workflow:** Clicking a file in the list sends `RequestFileContent`. When the content arrives, the frontend shows the `DiffViewer` component (e.g., in a modal) with the original content and the content from the AI response.
-   **Outcome:** The user can paste a response and immediately get a clear, color-coded view of the changes being proposed for any file.

### Step 4: Core "Swap" Functionality

-   **Goal:** Implement the "Swap with Source" feature.
-   **Tasks:**
    1.  **IPC Channels:** Implement `RequestSwapFileContent`.
    2.  **Backend (`fs.service.ts`):** Implement the `handleSwapFileContentRequest` method.
    3.  **Frontend (`view.tsx`):** Wire up the "Swap" button to trigger the IPC message.
-   **Outcome:** The user can test AI-generated code in their workspace with a single click.

### Step 5: Advanced Features (Future Cycles)

-   **Goal:** Implement remaining features from the vision.
-   **Tasks:**
    *   Annotation and Rating (Comments, Thumbs Up/Down).
    *   Live API Integration (The new Phase 3).
    *   Advanced UI from `A50` (Resizable panes, inner editors).
</file>

<file path="src/Artifacts/A44. DCE - Phase 1 - Word Document Handling Strategy.md">
# Artifact A44: DCE - Phase 1 - Word Document Handling Strategy
# Date Created: C73
# Author: AI Model
# Updated on: C81 (Add handling for corrupted .docx files)

- **Key/Value for A0:**
- **Description:** Defines the strategy for handling Word document files (.docx) by converting them to text on-demand and caching them in memory for flattening.
- **Tags:** feature plan, docx, text extraction, virtualization, cache, phase 1

## 1. Overview & Goal

To further expand the data curation capabilities of the extension, users need to be able to include the content of Microsoft Word documents (`.docx`). Following the successful virtualization pattern used for PDFs and Excel files, the goal is to extract text from Word documents on-demand and hold it in an in-memory cache. This allows their content to be included in the flattened context without creating temporary files in the user's workspace.

## 2. Supported & Unsupported Formats

-   **Supported:** This strategy focuses exclusively on the modern, XML-based **`.docx`** format.
-   **Unsupported:** The legacy binary **`.doc`** format is significantly more complex to parse and is **not supported**. The extension will identify `.doc` files and insert a placeholder in the flattened output rather than attempting to process them.

## 3. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| DOCX-01 | **Include Word Document Text in Context** | As a user, when I check a `.docx` file, I want its text content to be extracted and included in the `flattened_repo.md`, so I can use reports and documents as context for the LLM. | - Checking `.docx` files is allowed. <br> - The token count displayed for the file reflects its extracted text content. <br> - When flattened, the text from the document is included within a `<file>` tag. <br> - No temporary files are created in the user's workspace. |
| DOCX-02 | **Handle Unsupported `.doc` format** | As a user, when I check a legacy `.doc` file, I want the system to acknowledge it but inform me in the output that its content could not be processed, so I am not confused by missing data or corrupted text. | - Checking `.doc` files is allowed. <br> - The token count for `.doc` files remains 0. <br> - When flattened, a clear placeholder comment is included for the `.doc` file, stating that the format is unsupported. |
| DOCX-03 | **Handle Corrupted `.docx` files** | As a user, if I check a `.docx` file that is corrupted or invalid, I want the extension to fail gracefully and show me an error in the UI, so I know the file has a problem. | - The extension attempts to parse the `.docx` file. <br> - If parsing fails due to file corruption (e.g., it's not a valid zip archive), the token count is set to 0. <br> - An error message (e.g., "File may be corrupted") is displayed in the file's tooltip in the UI. <br> - The flattened output includes a comment indicating the failure. |

## 4. Technical Implementation Plan

1.  **Dependency:**
    *   The `mammoth` library will be added to `package.json`. It is a popular and effective library for converting `.docx` files to HTML and raw text.

2.  **Backend (`fs.service.ts`):**
    *   **In-Memory Cache:** A new private cache will be added: `private wordTextCache = new Map<string, { text: string; tokenCount: number }>();`.
    *   **New IPC Handler (`RequestWordToText`):**
        *   This handler will receive a file path. It will first check the cache.
        *   **If `.doc`:** It will cache an "Unsupported Format" message and a token count of 0, then notify the client.
        *   **If `.docx`:** It will read the file buffer and attempt to parse it with `mammoth.extractRawText()`.
        *   **Success:** On success, it will calculate the token count, store the result in the cache, and send the stats to the client.
        *   **Failure:** The `try...catch` block will inspect the error. If the error message indicates a corrupted file (e.g., from `jszip`), it will create a specific, user-friendly error message and send that to the client with a token count of 0.

3.  **Frontend (`view.tsx`):**
    *   **On-Demand Extraction:** The logic for handling checked files and restored selections will be updated to send a `RequestWordToText` message to the backend for `.docx` and `.doc` files.

4.  **Backend (`flattener.service.ts`):**
    *   **Virtual Content Retrieval:** The flattener will retrieve the text from the `wordTextCache` in the `FSService` instead of reading the binary file. It will correctly handle the "Unsupported Format" and "Corrupted File" messages from the cache.
</file>

<file path="src/Artifacts/A45. DCE - Phase 2 - Pop-out Co-Pilot Window - Feature Plan.md">
# Artifact A45: DCE - Phase 2 - Pop-out Co-Pilot Window - Feature Plan
# Date Created: C76
# Author: AI Model
# Updated on: C78 (Reflect implementation of WebviewPanel)

- **Key/Value for A0:**
- **Description:** Outlines the technical strategy to allow the Parallel Co-Pilot panel to be "popped out" into a separate window by re-implementing it as a main editor WebviewPanel.
- **Tags:** feature plan, phase 2, pop-out, window, webview, ux

## 1. Overview & Goal

The Parallel Co-Pilot panel is designed for intensive, side-by-side comparison of code, a task that benefits greatly from maximum screen real estate. Many developers use multiple monitors and would prefer to move this panel to a secondary display. The goal of this feature is to enable the user to "pop out" the Parallel Co-Pilot panel into its own floating window.

## 2. Problem & Proposed Solution

A direct `popOut()` API for a sidebar webview does not exist in the VS Code extension API. The most robust and user-friendly way to achieve this is to leverage a native VS Code feature: users can drag any editor tab into its own floating window.

Therefore, the proposed solution is to **re-architect the Parallel Co-Pilot from a sidebar view (`WebviewViewProvider`) into a main editor view (`WebviewPanel`)**.

### 2.1. User Experience Flow

1.  The user runs the `DCE: Open Parallel Co-Pilot` command from the Command Palette or clicks the icon in the Activity Bar.
2.  Instead of opening in the sidebar, the Parallel Co-Pilot panel opens as a new tab in the main editor group.
3.  The user can then click and drag this tab out of the main VS Code window, and it will become its own floating window, which can be moved to another monitor.

## 3. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| P2-WIN-01 | **Open Co-Pilot in Main Editor**| As a developer, I want a command or button to open the Parallel Co-Pilot panel in a main editor tab, so I have more horizontal space to view and compare responses. | - A command `DCE: Open Parallel Co-Pilot` exists. <br> - An icon in the activity bar triggers this command. <br> - Executing the command opens a new editor tab containing the full Co-Pilot UI. <br> - If the panel is already open, the command brings it into focus. |
| P2-WIN-02 | **Move Co-Pilot to New Window** | As a developer with multiple monitors, after opening the Co-Pilot in an editor tab, I want to drag that tab out of my main VS Code window to turn it into a separate, floating window, so I can place it on my second monitor. | - The Co-Pilot editor tab behaves like any other editor tab. <br> - It can be dragged to create new editor groups or dragged outside the main window to create a new floating window. |

## 4. Technical Implementation Plan (C78)

This is a significant architectural change that has been implemented.

1.  **Remove Sidebar Contribution (`package.json`):**
    *   The `dce-parallel-copilot` entry in `contributes.viewsContainers.activitybar` still exists to provide an entry point icon, but the view is no longer directly registered under `contributes.views`.

2.  **Create a `WebviewPanel` (`extension.ts`):**
    *   A new command, `dce.openParallelCopilot`, is registered.
    *   A module-level variable (`private static parallelCopilotPanel: vscode.WebviewPanel | undefined;`) is used to track the panel's instance, ensuring only one can exist.
    *   When the command is executed, it checks if the panel already exists. If so, it calls `panel.reveal()`.
    *   If not, it calls `vscode.window.createWebviewPanel`. This creates the webview in an editor tab.
    *   The panel's `onDidDispose` event is used to clear the static instance variable.
    *   The logic for setting the webview's HTML, options, and message handlers is now managed within this command's callback.

3.  **State Management:**
    *   Because the panel is now created on-demand, its state (tab content, cycle number) must be managed in a backend service to be restored if the panel is closed and reopened. This is a future enhancement. For now, the state is ephemeral to the panel's lifecycle.
</file>

<file path="src/Artifacts/A46. DCE - Phase 2 - Paste and Parse Response - Feature Plan.md">
# Artifact A46: DCE - Phase 2 - Paste and Parse Response - Feature Plan
# Date Created: C76
# Author: AI Model

- **Key/Value for A0:**
- **Description:** Details the plan for allowing users to paste a full AI response into a tab, which the extension will then parse to identify file paths referenced within XML tags.
- **Tags:** feature plan, phase 2, paste, parse, workflow, automation

## 1. Overview & Goal

The manual workflow for using the Parallel Co-Pilot involves copying an entire AI response and pasting it into one of the response tabs. These responses often contain multiple file updates, each wrapped in XML-like tags (e.g., `<file path="...">...</file>`). The goal of this feature is to make the extension "intelligent" about this pasted content. It should automatically parse the text, identify the files being modified, and associate them with the response tab.

## 2. User Story

| ID | User Story | Acceptance Criteria |
|---|---|---|
| P2-PARSE-01 | **Parse Pasted Content** | As a developer, when I paste a full AI response into a tab, I want the extension to automatically detect the file paths mentioned in the `<file>` tags, so I can see a list of affected files and use them for "Swap" and "Diff" operations. | - Pasting text into a response tab's editor triggers a parsing event. <br> - The extension uses a regular expression to find all occurrences of `<file path="...">`. <br> - The extracted file paths are stored in the state for that tab. <br> - The UI for the tab is updated to display the list of detected files. |
| P2-PARSE-02 | **Set Primary Source File** | As a developer, after pasting a response with multiple files, I want the first file detected to be automatically set as the primary "source file" for the "Swap" and "Diff" actions, so I don't have to select it manually. | - After parsing, if the tab's `sourceFilePath` is not already set, it is automatically populated with the path of the first file found in the pasted content. <br> - The metadata table (comparing original vs. response) updates accordingly. |

## 3. Technical Implementation Plan

1.  **Frontend Logic (`parallel-copilot.view/view.tsx`):**
    *   **Event Handler:** An `onPaste` event handler will be added to the `<textarea>` or code editor component for each tab.
    *   **Parsing Function:** A new utility function, `parseFilePathsFromResponse(text: string): string[]`, will be created.
        *   It will use a regular expression: `/<file path="([^"]+)">/g`.
        *   It will execute this regex on the input text to extract all captured file paths.
    *   **State Update:**
        *   Inside the `onPaste` handler, it will call `event.clipboardData.getData('text')` to get the pasted content.
        *   It will pass this content to the `parseFilePathsFromResponse` function.
        *   The resulting array of paths will be stored in the state for the active tab (e.g., in a new `detectedFiles: string[]` property).
        *   If the tab's primary `sourceFilePath` is empty, it will be set to the first path in the array.

2.  **UI Update (`parallel-copilot.view/view.tsx`):**
    *   A new UI element will be added to each tab's content area.
    *   It will conditionally render if `detectedFiles` has items.
    *   It will display a list of the detected file paths, perhaps as clickable links that could set the active `sourceFilePath` for the tab.

3.  **No Backend Changes:** This feature is entirely a frontend concern, involving UI event handling, string parsing, and state management within the React component.
</file>

<file path="src/Artifacts/A47. DCE - Phase 2 - Prompt Amalgamation Feature Plan.md">
# Artifact A47: DCE - Phase 2 - Prompt Amalgamation Feature Plan
# Date Created: C82
# Author: AI Model

- **Key/Value for A0:**
- **Description:** Details the plan for a "Generate prompt.md" button that will assemble the static schemas, cycle history, and flattened code into a single, complete prompt file.
- **Tags:** feature plan, phase 2, prompt engineering, automation, workflow

## 1. Overview & Goal

The process of constructing the final `prompt.md` file is a core part of the curator's workflow. It involves manually assembling several distinct pieces of content: static schemas, the cycle history, and the dynamically generated `flattened_repo.md`. This is a repetitive and error-prone task. The goal of this feature is to automate this process with a single button click, generating a complete, perfectly formatted `prompt.md` file on demand.

## 2. User Story

| ID | User Story | Acceptance Criteria |
|---|---|---|
| P2-PROMPT-01 | **Generate Complete Prompt** | As a curator, I want to click a button to generate a complete `prompt.md` file that includes all my standard schemas, the project's cycle history, and the latest flattened code, so I can start my next development cycle with zero manual setup. | - A "Generate `prompt.md`" button is available in the Parallel Co-Pilot Panel UI. <br> - A "Cycle Title" input field is available next to the cycle navigator. <br> - Clicking the button creates or overwrites `prompt.md` in the workspace root. <br> - The generated file has the correct structure: static schemas, then the dynamic cycle overview, then the content of `flattened_repo.md`. <br> - The cycle overview is built from the `dce_history.json` file and includes the title from the new input field. |

## 3. Technical Implementation Plan

1.  **UI (`parallel-copilot.view/view.tsx`):**
    *   Add a "Generate `prompt.md`" button to the main header toolbar.
    *   Add a new state variable and a corresponding `<input type="text">` element for the "Cycle Title" next to the cycle navigator.
    *   The button's `onClick` handler will send a new IPC message to the backend.

2.  **IPC Channels:**
    *   `ClientToServerChannel.RequestCreatePromptFile`: Payload will be `{ cycleTitle: string, currentCycle: number }`.

3.  **Backend (New `prompt.service.ts`):**
    *   Create a new `PromptService` to encapsulate the logic.
    *   **Static Templates:** The service will contain private string constants holding the content for `<M1. artifact schema>`, `<M3. Interaction Schema>`, and `<M4. current project scope>`.
    *   **`generatePromptFile` Method:** This method will be the core of the service.
        1.  It will receive the `cycleTitle` and `currentCycle` from the IPC message.
        2.  It will read the `dce_history.json` file (using `HistoryService`) to build the `<M2. cycle overview>` section dynamically.
        3.  It will read the entire content of `flattened_repo.md`.
        4.  It will assemble these strings in the correct order into a single, large string.
        5.  It will write this final string to `prompt.md` in the workspace root using `vscode.workspace.fs.writeFile`.
        6.  It will show a `showInformationMessage` to confirm completion.

4.  **Integration:**
    *   The new `PromptService` will be instantiated in `services.ts`.
    *   A new handler for `RequestCreatePromptFile` will be added to the `on-message.ts` for the Parallel Co-Pilot view, which will call the `PromptService`.
</file>

<file path="src/Artifacts/A48. DCE - Phase 2 - Advanced Syntax Highlighting Plan.md">
# Artifact A48: DCE - Phase 2 - Advanced Syntax Highlighting Plan
# Date Created: C82
# Author: AI Model
# Updated on: C90 (Update plan to reflect implementation)

## 1. Overview & Goal

AI-generated responses are complex documents, containing both explanatory Markdown text and code blocks in various languages. A plain `<textarea>` element does not provide any syntax highlighting, making these responses difficult to read and analyze. The goal of this feature is to significantly enhance the readability of AI responses by replacing the textareas with a proper code editor component that can provide rich, language-aware syntax highlighting.

## 2. User Story

| ID | User Story | Acceptance Criteria |
|---|---|---|
| P2-SYNTAX-01 | **View Highlighted Responses** | As a developer, I want to see AI responses with full syntax highlighting inside the Parallel Co-Pilot tabs, so I can easily distinguish between comments, keywords, and code, just like in a real editor. | - The content area of each response tab renders with syntax highlighting. <br> - Standard Markdown elements (headers, lists, bold, italics, backticks) are formatted correctly. <br> - Code blocks (e.g., ` ```typescript ... ``` `) are highlighted with the correct grammar for the specified language. <br> - The highlighting should be theme-aware, matching the user's current VS Code theme. |

## 3. Technical Implementation Strategy (C90)

### 3.1. Chosen Library: `starry-night`

After research and consideration of alternatives like `refractor`, **`@wooorm/starry-night`** is the chosen library for syntax highlighting.

-   **Rationale (C85):**
    -   **High Fidelity:** It uses the same TextMate grammars as VS Code itself. This is the most important factor, as it ensures the highlighting in our panel will be a perfect visual match to the user's native editor experience.
    -   **Backend Architecture:** Our implementation performs highlighting on the backend (in the Node.js extension host) and sends pre-rendered HTML to the frontend webview. This means the primary drawback of `starry-night`â€”its large bundle sizeâ€”is a non-issue for the client. The "heavy lifting" is done by the extension's server-side process, keeping the webview lightweight and performant.

### 3.2. Implementation Plan

1.  **Dependencies (`package.json`):**
    *   `@wooorm/starry-night` is the core backend dependency.
    *   `hast-util-to-html` is used to convert the abstract syntax tree to an HTML string.
    *   `react-markdown` is added as a frontend dependency to handle the rendering of non-code markdown content (lists, bold, etc.).

2.  **Backend (`fs.service.ts`):**
    *   The `handleSyntaxHighlightRequest({ code, lang, id })` method is implemented.
    *   It initializes `starry-night` with a set of common grammars.
    *   It uses `starryNight.highlight(code, scope)` where `scope` is determined from the language identifier (e.g., 'typescript' -> 'source.ts').
    *   It converts the resulting `hast` tree to an HTML string using `toHtml`.
    *   This HTML string is sent back to the client via the `SendSyntaxHighlight` IPC channel, including the `id` to match the request.

3.  **IPC Channels:**
    *   `ClientToServerChannel.RequestSyntaxHighlight`: Payload `{ code: string; lang: string, id: string }`.
    *   `ServerToClientChannel.SendSyntaxHighlight`: Payload `{ highlightedHtml: string, id: string }`.

4.  **Frontend (`parallel-copilot.view/view.tsx`):**
    *   After a response is parsed into `parsedContent`, the view iterates through `parsedContent.files`.
    *   For each file block, it sends a `RequestSyntaxHighlight` message to the backend.
    *   A state map (`highlightedCodeBlocks: Map<string, string>`) caches the HTML returned from the backend.
    *   The component that renders the file's code uses `dangerouslySetInnerHTML` to display the highlighted HTML.
    *   The `summary` and `courseOfAction` sections are rendered using the `<ReactMarkdown>` component to display formatted text.
</file>

<file path="src/Artifacts/A49. DCE - Phase 2 - File Association & Diffing Plan.md">
# Artifact A49: DCE - Phase 2 - File Association & Diffing Plan
# Date Created: C82
# Author: AI Model
# Updated on: C132 (Change workflow from 'swap' to 'accept/replace')

- **Key/Value for A0:**
- **Description:** Plans the UI and backend logic to visually link file blocks in an AI response to workspace files and sets the stage for an integrated diff tool.
- **Tags:** feature plan, phase 2, ui, ux, diff, file association

## 1. Overview & Goal

To make the Parallel Co-Pilot Panel's workflow trustworthy and intuitive, users need a clear visual confirmation of which local file an AI-generated code block is intended to modify. This feature introduces a "file association" mechanism that parses AI responses, verifies the existence of the mentioned files, and displays this status to the user.

The core workflow is now defined as **"accept/replace"**: a one-way copy of content from the AI response into the user's workspace files.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| P2-ASSOC-01 | **See Affected Files** | As a developer, when I parse an AI response, I want the extension to automatically show me a list of all the file paths it intends to modify, so I can understand the scope of the proposed changes. | - After parsing, a collapsible "Associated Files" section appears in the tab's UI. <br> - This section displays a list of all file paths found in the response. |
| P2-ASSOC-02 | **Verify File Existence** | As a developer, for each file listed, I want to see a visual indicator of whether that file already exists in my workspace, so I can spot potential errors or new files proposed by the AI. | - Next to each listed file path, an icon is displayed. <br> - A green checkmark (`âœ“`) indicates the file exists at that path. <br> - A red cross (`âœ—`) indicates the file does not exist. |
| P2-ASSOC-03 | **Preview AI Code** | As a developer, I want to click on a file in the "Associated Files" list to immediately see a syntax-highlighted view of the AI's proposed code, so I can review it. | - Clicking a file with a `âœ“` in the list opens a single-pane view in the right-hand panel. <br> - This view displays only the AI's proposed code, with full syntax highlighting. |
| P2-ASSOC-04 | **Preview Changes with Diff** | As a developer, I want a "View Diff" button to see a side-by-side comparison of the original file and the AI's proposed changes, so I can review the exact changes before accepting them. | - A "View Diff" button is available for the selected file. <br> - Clicking it replaces the single-pane view with a two-pane diff component. <br> - The diff view clearly shows added, removed, and common lines. |
| P2-ASSOC-05 | **Accept Changes** | As a developer, I want to be able to accept changes from the AI response into my workspace, either for a single file or for a batch of selected files. | - An "Accept this file" button replaces the content of the workspace file with the AI's version. <br> - A separate "Accept Selected Files" button performs a bulk replacement for all files checked in the "Associated Files" list. <br> - This is a one-way copy from the AI response to the workspace. |

## 3. Technical Implementation Plan

1.  **Frontend - Parsing (`response-parser.ts`):**
    *   **Status:** **Complete.**

2.  **Backend - Verification & Highlighting (`fs.service.ts`):**
    *   **Status:** **Complete.** The `handleFileExistenceRequest` and `handleSyntaxHighlightRequest` handlers are working.

3.  **Frontend - UI & State (`view.tsx`):**
    *   **Status:** **In Progress.**
    *   **File List & Diff View:** Implement the "Associated Files" list. Clicking a file fetches its content for diffing and displays the `DiffViewer` component.
    *   **Selection State:** Manage a `Set<string>` of `selectedFilesForReplacement` to track which files are checked.
    *   **Accept/Replace Logic:**
        *   The "Accept this file" button will trigger a new `RequestWriteFile` IPC message.
        *   The "Accept Selected Files" button will trigger a new `RequestBatchFileWrite` IPC message with an array of file paths and their new content.

4.  **Backend - File Writing (`file-operation.service.ts`):**
    *   **Status:** **To be implemented.**
    *   Implement `handleWriteFileRequest` and `handleBatchFileWrite` to receive new content and overwrite the corresponding files in the workspace using `vscode.workspace.fs.writeFile`.
</file>

<file path="src/Artifacts/A5. DCE - Target File Structure.md">
# Artifact A5: DCE - Target File Structure
# Date Created: Cycle 3
# Author: AI Model

- **Description:** A text-based representation of the target file structure for the DCE extension, outlining the layout of directories and key files.
- **Tags:** file structure, architecture, project layout, scaffolding

## 1. Overview

This document provides a visual representation of the file structure that the `A6. DCE - Initial Scaffolding Deployment Script` will create. It is based on the robust and scalable architecture of the `The-Creator-AI-main` reference repository, as detailed in `A3. DCE - Technical Scaffolding Plan`.

## 2. File Tree

```
DCE/
â”œâ”€â”€ .gitignore
â”œâ”€â”€ .vscodeignore
â”œâ”€â”€ package.json
â”œâ”€â”€ tsconfig.json
â”œâ”€â”€ webpack.config.js
â”œâ”€â”€ public/
â”‚   â””â”€â”€ spiral.svg
â””â”€â”€ src/
    â”œâ”€â”€ backend/
    â”‚   â”œâ”€â”€ commands/
    â”‚   â”‚   â”œâ”€â”€ commands.ts
    â”‚   â”‚   â””â”€â”€ register-commands.ts
    â”‚   â”œâ”€â”€ repositories/
    â”‚   â”‚   â””â”€â”€ persistent-store.repository.ts
    â”‚   â”œâ”€â”€ services/
    â”‚   â”‚   â”œâ”€â”€ fs.service.ts
    â”‚   â”‚   â”œâ”€â”€ services.ts
    â”‚   â”‚   â””â”€â”€ flattener.service.ts
    â”‚   â””â”€â”€ types/
    â”‚       â””â”€â”€ storage-keys.enum.ts
    â”‚
    â”œâ”€â”€ client/
    â”‚   â”œâ”€â”€ components/
    â”‚   â”‚   â””â”€â”€ file-tree/
    â”‚   â”‚       â”œâ”€â”€ FileTree.tsx
    â”‚   â”‚       â””â”€â”€ FileTree.utils.ts
    â”‚   â”œâ”€â”€ views/
    â”‚   â”‚   â”œâ”€â”€ context-chooser.view/
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ on-message.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ view.scss
    â”‚   â”‚   â”‚   â””â”€â”€ view.tsx
    â”‚   â”‚   â””â”€â”€ index.ts
    â”‚   â””â”€â”€ store/
    â”‚       â”œâ”€â”€ store.ts
    â”‚       â””â”€â”€ useStore.ts
    â”‚
    â”œâ”€â”€ common/
    â”‚   â”œâ”€â”€ ipc/
    â”‚   â”‚   â”œâ”€â”€ channels.enum.ts
    â”‚   â”‚   â”œâ”€â”€ channels.type.ts
    â”‚   â”‚   â”œâ”€â”€ client-ipc.ts
    â”‚   â”‚   â”œâ”€â”€ get-vscode-api.ts
    â”‚   â”‚   â””â”€â”€ server-ipc.ts
    â”‚   â”œâ”€â”€ types/
    â”‚   â”‚   â”œâ”€â”€ file-node.ts
    â”‚   â”‚   â””â”€â”€ vscode-webview.d.ts
    â”‚   â””â”€â”€ utils/
    â”‚       â””â”€â”€ view-html.ts
    â”‚
    â””â”€â”€ extension.ts
```
</file>

<file path="src/Artifacts/A50. DCE - Phase 2 - UI Component Plan (Resizable Panes & Inner Editors).md">
# Artifact A50: DCE - Phase 2 - UI Component Plan (Resizable Panes & Inner Editors)
# Date Created: C87
# Author: AI Model
# Updated on: C112 (Prioritize resizable panes implementation)

- **Key/Value for A0:**
- **Description:** Documents the plan for advanced UI components like resizable panes and nested, scrollable editors within the Parallel Co-Pilot panel.
- **Tags:** feature plan, phase 2, ui, ux, resizable, scrollable, editor

## 1. Overview & Goal

As the Parallel Co-Pilot Panel (PCPP) becomes more feature-rich, its UI needs to be flexible and efficient. This document outlines the plan for two advanced UI components: a **resizable pane** for the summary/code view and a system of **nested, scrollable "inner editors"** for individual file blocks within a response. The goal is to create a highly readable and customizable interface that prevents "endless scrolling" and allows users to focus on the information that matters most to them.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| P2-UI-01 | **Resizable Panes** | As a developer, I want to be able to drag the vertical divider between the summary/file list pane and the code viewer pane, so I can give more space to the view that is most important for my current task. | - A draggable handle exists on the vertical divider between the two main panes in the parsed view. <br> - Clicking and dragging the handle adjusts the relative width of the two panes. <br> - The layout is responsive and does not break during resizing. <br> - The left pane should be collapsible. |
| P2-UI-02 | **Contained File Editors** | As a developer, when viewing a large AI response with multiple files, I want each file's code to be contained within its own fixed-height, scrollable text area, so I can quickly scroll past entire files without having to scroll through all of their content. | - The extension parses the AI response and identifies individual file blocks (e.g., content within `<file>` tags). <br> - Each file block is rendered inside its own container with a fixed `max-height` and `overflow-y: auto`. <br> - This allows the user to scroll through the list of files quickly, only scrolling within a specific file's content when needed. |
| P2-UI-03 | **File-Level Action Buttons** | As a developer, I want action buttons (like "Accept", "Diff", "Comment") to be associated with each individual file block within a response, so I can act on a single file at a time. | - In the "inner editor" view, each file container has its own set of action buttons. <br> - Clicking "Accept" on one file block only affects that specific file, not the entire response. |

## 3. Technical Implementation Plan

### 3.1. Resizable Panes (Priority for C112)

-   **Strategy:** Implement a custom, lightweight resizable pane component directly within `view.tsx`.
-   **Component Logic:**
    *   The main `.parsed-view-grid` will be the flex container.
    *   A new `div` element with a `.resizer` class will be added between the left and right panes to act as the draggable handle.
    *   **State:** A new state variable, `const [leftPaneWidth, setLeftPaneWidth] = useState(33);`, will manage the width of the left pane as a percentage.
    *   **Event Handling:**
        *   The resizer `div` will have an `onMouseDown` handler.
        *   This handler will attach `onMouseMove` and `onMouseUp` listeners to the `window`.
        *   The `onMouseMove` handler will calculate the new percentage width based on `event.clientX` and update the `leftPaneWidth` state, respecting min/max width constraints.
        *   The `onMouseUp` handler will remove the `mousemove` and `mouseup` listeners from the window.
-   **Integration:** The `style` attribute of the left pane will be bound to this state (e.g., `flex-basis: `${leftPaneWidth}%`).

### 3.2. Inner Editors / Contained File Blocks (Future Cycle)

-   **Strategy:** This requires a significant change to how the response content is rendered. Instead of treating the response as a single block of text to be rendered as Markdown, it must be parsed into a structured array of objects.
-   **Parsing Logic (`view.tsx`):**
    -   A new parsing function will take the raw response string and split it into an array of segments, e.g., `[{ type: 'markdown', content: '...' }, { type: 'file', path: '...', content: '...' }, ...]`.
-   **Rendering Logic (`view.tsx`):**
    -   The main render function will map over this array of segments.
    -   If `segment.type === 'markdown'`, it renders the content as before.
    -   If `segment.type === 'file'`, it renders a new component, e.g., `FileBlock.tsx`.
-   **`FileBlock.tsx` Component:**
    -   This component will be responsible for rendering a single file from the AI response.
    -   It will have a header displaying the file path and the file-specific action buttons (Accept, Diff, etc.).
    -   The main content area will be a `div` with CSS properties `max-height: 300px;` (or similar) and `overflow-y: auto;`.
    -   The code content within this `div` will be syntax-highlighted as before.
</file>

<file path="src/Artifacts/A51. DCE - A-B-C Testing Strategy for UI Bugs.md">
# Artifact A51: DCE - A-B-C Testing Strategy for UI Bugs
# Date Created: C102
# Author: AI Model & Curator
# Updated on: C103 (Refine to "Original-A-B-C" parallel testing model)

- **Key/Value for A0:**
- **Description:** Outlines a development pattern for creating parallel, isolated test components to diagnose and resolve persistent UI bugs, such as event handling or rendering issues.
- **Tags:** process, debugging, troubleshooting, ui, ux, react

## 1. Overview & Goal

When a user interface (UI) bug, particularly related to event handling (`onClick`, `onDrop`, etc.) or component rendering, proves resistant to conventional debugging, it often indicates a complex or non-obvious root cause. Continuously attempting small, incremental fixes on the main, complex component can be inefficient and can lead to regressions.

The goal of the **"Original-A-B-C" Testing Strategy** is to break this cycle by creating a test harness that runs the original, complex component in parallel with multiple, simplified, independent test components. Each test component attempts to solve the same basic problem using a slightly different technical approach, allowing for rapid diagnosis.

## 2. The Strategy

### 2.1. Core Principles
1.  **Preserve the Original:** Never gut or remove existing, working functionality to build a test case. The original component should remain available as the "control" in the experiment.
2.  **Isolate Variables:** Each test case should be as simple as possible, designed to test a single variable (e.g., raw event handling, local state updates, prop drilling).
3.  **Run in Parallel:** The original component and all test components should be accessible from the same UI, typically via a simple tab switcher, allowing for immediate comparison.

### 2.2. Steps
1.  **Identify the Core Problem:** Isolate the most fundamental action that is failing (e.g., "A click on a list item is not being registered").
2.  **Create Test Harness:** Refactor the main view to act as a "test harness."
    *   Introduce a top-level state to control which view is active (e.g., `activeView: 'Original' | 'TestA' | 'TestB'`).
    *   Create a simple tab bar UI to switch this state.
    *   Encapsulate the existing, complex component so it can be rendered when `activeView === 'Original'`.
3.  **Lift Necessary State:** Identify the minimum state required for the test components to function (e.g., `parsedContent`). Lift this state up to the test harness level. The "Original" component can then pass data up to the harness via a callback prop.
4.  **Implement Isolated Test Components:** Create new, simple components for each test case, which receive the shared state as props.
    *   **Test A (Barebones):** The simplest possible implementation. Use raw HTML elements with inline event handlers that only `logger.log()`.
    *   **Test B (Local State):** Introduce `useState` to test the component's ability to manage its own state and re-render on an event.
    *   **Test C (Prop-Driven):** Use a child component that calls a function passed down via props, testing the prop-drilling pattern.
5.  **Analyze Results:** Interact with each tab to see which implementation succeeds, thereby isolating the architectural pattern that is failing.

## 3. Cleanup Process

Once a working pattern is identified in a test component:
1.  **Codify Findings:** Document the successful pattern and the root cause of the failure in a relevant artifact (e.g., `A11. Regression Case Studies`).
2.  **Integrate Solution:** Refactor the "Original" component to use the successful pattern.
3.  **Remove Test Artifacts:**
    *   Remove the test harness tabs and view-switching logic from the main view component.
    *   Delete the temporary `TestPane*.tsx` component files.
    *   Remove any extra styling related to the test harness from the SCSS file.

## 4. Sample Test Data for Parser

To ensure consistent testing of the PCPP parser, use the following sample raw response. Paste this into a response tab in the "Original" view and click "Parse All".

```
I've analyzed the request and the provided context. The main goal is to add a new test harness to the Parallel Co-Pilot panel without removing the existing functionality. This involves refactoring `view.tsx` to support multiple, switchable views.

### Course of Action

1.  **Update Documentation:** I will first update `A51` to reflect the new "Original-A-B-C" parallel testing strategy.
2.  **Refactor `view.tsx`:** I will refactor the main component into a test harness that can switch between the original view and the new test panes.
3.  **Re-supply Test Panes:** I will provide the code for the three isolated test panes again.

### Files Updated This Cycle:
*   `A51. DCE - A-B-C Testing Strategy for UI Bugs.md` (Updated)
*   `src/client/views/parallel-copilot.view/view.tsx` (Updated)
*   `src/client/views/parallel-copilot.view/view.scss` (Updated)

<file path="src/client/views/parallel-copilot.view/view.tsx">
// This is a sample file content block.
// It will be parsed and displayed.
import * as React from 'react';

const TestComponent = () => {
    return <div>Hello, World!</div>;
};

export default TestComponent;
</file>
<file path="src/client/views/parallel-copilot.view/view.scss">
/* This is a sample SCSS file content block. */
.test-harness-tabs {
    display: flex;
    border-bottom: 1px solid var(--vscode-panel-border);
}
```
</file>

<file path="src/Artifacts/A52. DCE - Interaction Schema Refinement.md">
# Artifact A52: DCE - Interaction Schema Refinement
# Date Created: C110
# Author: AI Model & Curator
# Updated on: C126 (Specify case-insensitive header parsing)

- **Key/Value for A0:**
- **Description:** Proposes a set of refined rules for the AI's output format to improve the reliability and consistency of automated parsing within the Parallel Co-Pilot Panel.
- **Tags:** documentation, process, parsing, interaction schema, roadmap

## 1. Overview & Goal

The Parallel Co-Pilot Panel (PCPP) relies on parsing the AI's output to provide features like file association, diffing, and syntax highlighting. Analysis of historical cycle data reveals that the AI's output format has drifted over time, using multiple conventions for headers and file blocks. This inconsistency makes the parser complex and brittle.

The goal of this artifact is to define a refined, stricter set of rules for the AI's output. By codifying a canonical format, we make the parser's job simpler and more reliable, improving the overall robustness of the PCPP. This document contains the proposed changes to be integrated into the main `M3. Interaction Schema`.

## 2. Proposed Changes to `M3. Interaction Schema`

### 2.1. Standardized Response Structure

To ensure predictable parsing, all responses must adhere to the following structure and order:

1.  **Summary/Plan:** The response must begin with a high-level summary, thoughts, or plan. This section ends at the first occurrence of a standardized header.
2.  **Course of Action Header:** This section must begin with a markdown header like `### Course of Action`. **(C126 Update)** The parser will treat this header case-insensitively (e.g., `### Course of action` is also valid).
3.  **Files Updated Header:** This section must begin with the exact markdown header: `### Files Updated This Cycle:`.
4.  **File Blocks:** The response must conclude with the code/document artifact blocks.

### 2.2. Canonical File Block Format

To eliminate ambiguity, all file and document artifacts must be enclosed in the following canonical format:

```xml
<file path="path/to/your/file.ext">
[... file content ...]
</file>
```

**Rules for File Blocks:**
*   The opening tag **must** be `<file path="...">`. The path must be a relative path from the project root, using forward slashes (`/`).
*   The closing tag **must** be `</file>`.
*   Formats where the file path is the tag name (e.g., `<src/main.ts>...`) are now deprecated and should not be used.
*   The surrounding triple-backtick code fences (e.g., ` ```xml ... ``` `) are optional but recommended for readability. The parser will handle their presence or absence.

### 2.3. Standardized "Files Updated" List Format

The list of files under the `### Files Updated This Cycle:` header must follow this format:

```
* `path/to/file.ext` (Status)
```

**Rules for Files Updated List:**
*   Each item must be a markdown list item (starting with `*` or `-`).
*   The file path **must** be enclosed in backticks (`` ` ``).
*   The status (e.g., `(Updated)`, `(New)`, `(Deleted)`) is optional but recommended. The parser will be designed to ignore it.

## 3. Rationale

By enforcing this stricter contract on the AI's output, we significantly reduce the complexity of the `response-parser.ts`. The parser no longer needs multiple, complex regular expressions to account for numerous format variations. This leads to:
*   **Increased Reliability:** Parsing is less likely to fail on subtle format changes.
*   **Improved Maintainability:** The parser code becomes simpler and easier to understand.
*   **Predictable Behavior:** The PCPP's features will behave more consistently across all responses.
</file>

<file path="src/Artifacts/A53. DCE - Phase 2 - Token Count and Similarity Analysis.md">
# Artifact A53: DCE - Phase 2 - Token Count and Similarity Analysis
# Date Created: C112
# Author: AI Model & Curator

- **Key/Value for A0:**
- **Description:** Details the plan to implement token counting for raw and parsed responses, and to calculate a similarity score between AI-generated files and their workspace originals.
- **Tags:** feature plan, phase 2, token count, similarity, metrics, ui, ux

## 1. Overview & Goal

To enhance the curator's decision-making process, the Parallel Co-Pilot Panel (PCPP) must provide quantitative metrics about the AI's responses. The goal of this feature is to display token counts for various pieces of content and a similarity score to gauge the extent of changes proposed by the AI. This allows the user to quickly assess response verbosity, parser effectiveness, and the magnitude of code modifications.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| P2-MET-01 | **Raw Response Token Count** | As a user, I want to see the total token count of the raw AI response I've pasted, so I can understand the overall size of the output. | - A token count is displayed for the raw content in each response tab. <br> - This count updates in real-time as I type or paste content. |
| P2-MET-02 | **Parsed vs. Original Token Count** | As a user, when viewing a parsed file, I want to see a comparison of the token count between the original workspace file and the AI's new version, so I can quickly see if the code is growing or shrinking. | - In the header of the code viewer pane, the token counts for both the original and new versions of the selected file are displayed (e.g., "Original: 4.1K | New: 4.2K"). |
| P2-MET-03 | **File Similarity Score** | As a user, along with the token counts, I want to see a percentage-based similarity score, so I can gauge how substantially the AI has altered the file. | - A similarity score (e.g., "Sim: 98%") is displayed in the code viewer header. <br> - A score of 100% indicates identical files. <br> - A low score indicates a major rewrite. |

## 3. Technical Implementation Plan

### Phase 1: UI Placeholders (Current Cycle)

1.  **`parallel-copilot.view/view.tsx`:**
    *   Add placeholder elements in the UI to display the token counts and similarity score.
    *   Raw response token count: Calculate and display this on the frontend via `rawContent.length / 4`.
    *   Parsed file metrics: Display static placeholder text in the code viewer header.

### Phase 2: Backend Logic & Integration (Future Cycle)

1.  **New IPC Channel:**
    *   Create `ClientToServerChannel.RequestFileComparison`.
    *   Payload: `{ filePath: string; modifiedContent: string; }`.
    *   Response channel: `ServerToClientChannel.SendFileComparison`.
    *   Payload: `{ originalTokens: number; modifiedTokens: number; similarity: number; }`.

2.  **Backend (`fs.service.ts`):**
    *   Implement `handleFileComparisonRequest`.
    *   It will read the content of the original `filePath` from the workspace.
    *   It will calculate the token count for the original content.
    *   It will calculate the token count for the `modifiedContent` received in the payload.
    *   It will compute a similarity score. A simple and effective algorithm for this is the **SÃ¸rensen-Dice coefficient** on sets of n-grams (e.g., 2-grams) from each string.
    *   It will send the results back to the client via `SendFileComparison`.

3.  **Frontend (`parallel-copilot.view/view.tsx`):**
    *   When a file is selected for viewing (`setSelectedFilePath`), send the `RequestFileComparison` message.
    *   Create new state variables to hold the comparison results: `const [comparisonMetrics, setComparisonMetrics] = useState(null);`.
    *   The message handler for `SendFileComparison` will update this state.
    *   The UI will be updated to render the live data from the `comparisonMetrics` state instead of the placeholders.
</file>

<file path="src/Artifacts/A54. starry-night-readme.md">
[![](media/cover-dark.jpg)](https://artsandculture.google.com/asset/the-starry-night/bgEuwDxel93-Pg#gh-dark-mode-only)
[![](media/cover-light.jpg#gh-dark-mode-only)](https://artsandculture.google.com/asset/the-starry-night/bgEuwDxel93-Pg#gh-light-mode-only)

<p align="center">Close up of <b>The Starry Night</b> by Vincent van Gogh (1889)<br>with examples of <code>starry-night</code> over it</p>

<br>

# starry-night

[![Build][badge-build-image]][badge-build-url]
[![Coverage][badge-coverage-image]][badge-coverage-url]
[![Downloads][badge-downloads-image]][badge-downloads-url]
[![Size][badge-size-image]][badge-size-url]

Syntax highlighting,
like what GitHub uses to highlight code,
but free and open source and JavaScript!

## Contents

* [What is this?](#what-is-this)
* [When should I use this?](#when-should-i-use-this)
* [What is `PrettyLights`?](#what-is-prettylights)
* [Install](#install)
* [Use](#use)
* [API](#api)
  * [`all`](#all)
  * [`common`](#common)
  * [`createStarryNight(grammars[, options])`](#createstarrynightgrammars-options)
  * [`starryNight.flagToScope(flag)`](#starrynightflagtoscopeflag)
  * [`starryNight.highlight(value, scope)`](#starrynighthighlightvalue-scope)
  * [`starryNight.missingScopes()`](#starrynightmissingscopes)
  * [`starryNight.register(grammars)`](#starrynightregistergrammars)
  * [`starryNight.scopes()`](#starrynightscopes)
  * [`GetOnigurumaUrl`](#getonigurumaurl)
  * [`Grammar`](#grammar)
  * [`Options`](#options)
* [Examples](#examples)
  * [Example: serializing hast as html](#example-serializing-hast-as-html)
  * [Example: using `starry-night` on the client](#example-using-starry-night-on-the-client)
  * [Example: turning hast into react nodes](#example-turning-hast-into-react-nodes)
  * [Example: adding line numbers](#example-adding-line-numbers)
  * [Example: integrate with unified, remark, and rehype](#example-integrate-with-unified-remark-and-rehype)
  * [Example: integrating with `markdown-it`](#example-integrating-with-markdown-it)
* [Syntax tree](#syntax-tree)
* [CSS](#css)
* [Languages](#languages)
* [Compatibility](#compatibility)
* [Security](#security)
* [Related](#related)
* [Contribute](#contribute)
* [License](#license)

## What is this?

This package is an open source version of GitHubâ€™s closed-source `PrettyLights`
project (more on that later).
It supports **600+ grammars** and its **extremely high quality**.
It uses TextMate grammars which are also used in popular editors
(SublimeText, Atom, VS Code, \&c).
Theyâ€™re heavy but high quality.

## When should I use this?

`starry-night` is a **high quality** highlighter
(when your readers or authors are programmers,
you want this!)
that can support **tons of grammars**
(from new things like MDX to much more!)
which approaches how GitHub renders code.

It has a WASM dependency,
and rather big grammars,
which means that `starry-night` might be too heavy particularly in browsers,
in which case [`lowlight`][github-lowlight] or [`refractor`][github-refractor]
might be more suitable.

This project is similar to the excellent [`shiki`][github-shiki],
and it uses the same underlying dependencies,
but `starry-night` is meant to match GitHub in that it produces classes and
works with the CSS it ships,
making it easier to add dark mode and other themes with CSS compared to inline
styles.

Finally,
this package produces objects (an AST),
which makes it useful when you want to perform syntax highlighting in a place
where serialized HTML wouldnâ€™t work or wouldnâ€™t work well.
For example,
when you want to show code in a CLI by rendering to ANSI sequences,
when youâ€™re using virtual DOM frameworks (such as React or Preact) so that
diffing can be performant,
or when youâ€™re working with [`hast`][github-hast] or [`rehype`][github-rehype].

Bundled,
minified,
and gzipped,
`starry-night` and the WASM binary are 185 kB.
There are two lists of grammars you can use:
[`common`][api-common]
(Â±35 languages, good for your own site)
adds 250 kB and [`all`][api-all]
(\~600 languages, useful if you are making a site like GitHub)
is 1.6 MB.
You can also manually choose which grammars to include
(or add to `common`):
a language is typically between 3 and 5 kB.
To illustrate,
Astro costs 2.1 kB and TSX costs 25.4 kB.

## What is `PrettyLights`?

`PrettyLights` is the syntax highlighter that GitHub uses to turn this:

````markdown
```markdown
# Hello, world!
```
````

â€¦into this:

```html
<span class="pl-mh"><span class="pl-mh">#</span><span class="pl-mh"> </span>Hello, world!</span>
```

â€¦which is what `starry-night` does too
(some small differences in markup,
but essentially the same)!

`PrettyLights` is responsible for taking the flag `markdown`,
looking it up in
[`languages.yml` from `github-linguist`][github-linguist-languages-yml]
to figure out that that means markdown,
taking a corresponding grammar
(in this case
[`wooorm/markdown-tm-language`][github-markdown-tm-language]),
doing some GPL magic in C,
and turning it into spans with classes.

GitHub is using `PrettyLights` since December 2014,
when it [replaced `Pygments`][github-pages-pygments].
They wanted to open source it,
but [were unable][github-pages-license] due to licensing issues.
Recently ([Feb 2019][github-tree-sitter-tree-lights]?),
GitHub has slowly started to move towards `TreeLights`,
which is based on TreeSitter,
and also closed source.
If `TreeLights` includes a language
(currently: C, C#, CSS, CodeQL, EJS, Elixir, ERB, Gleam, Go, HTML, Java, JS,
Nix, PHP, Python, RegEx, Ruby, Rust, TLA, TS),
thatâ€™ll be used,
for everything else `PrettyLights` is used.

`starry-night` does what `PrettyLights` does,
not what `TreeLights` does.
Iâ€™m hopeful that that will be open sourced in the future and we can mimic both.

<br>

[![](media/slice-1.jpg)][artsandculture-google-starry-night]

## Install

This package is [ESM only][github-gist-esm].
In Node.js (version 16+),
install with [npm][npmjs-install]:

```sh
npm install @wooorm/starry-night
```

In Deno with [`esm.sh`][esmsh]:

```js
import {common, createStarryNight} from 'https://esm.sh/@wooorm/starry-night@3'
```

In browsers with [`esm.sh`][esmsh]:

```html
<script type="module">
  import {common, createStarryNight} from 'https://esm.sh/@wooorm/starry-night@3?bundle'
</script>
```

To get the CSS in browsers,
do
(see [CSS][section-css] for more info):

```html
<!-- This supports light and dark mode automatically. -->
<link rel="stylesheet" href="https://esm.sh/@wooorm/starry-night@3/style/both">
```

## Use

```js
import {common, createStarryNight} from '@wooorm/starry-night'

const starryNight = await createStarryNight(common)

const scope = starryNight.flagToScope('markdown')
const tree = starryNight.highlight('# hi', scope)

console.log(tree)
```

Yields:

```js
{
  type: 'root',
  children: [
    {
      type: 'element',
      tagName: 'span',
      properties: {className: ['pl-mh']},
      children: [
        {type: 'text', value: '# '},
        {
          type: 'element',
          tagName: 'span',
          properties: {className: ['pl-en']},
          children: [{type: 'text', value: 'hi'}]
        }
      ]
    }
  ]
}
```

## API

This package exports the identifiers
[`all`][api-all],
[`common`][api-common],
and
[`createStarryNight`][api-create-starry-night]
from the main module.
It exports the additional [TypeScript][] types
[`GetOnigurumaUrl`][api-get-oniguruma-url],
[`Grammar`][api-grammar],
and [`Options`][api-options].
There is no default export.

It also includes grammars directly in its export map,
which each expose a [`Grammar`][api-grammar] as the default export.
**Do not** use the `lang/` folder or the `.js` extension.

For CSS files,
do use `style/` and donâ€™t use `.css`:

```js
import sourceMdx from '@wooorm/starry-night/source.mdx' // Grammar.
import styleTritanopiaDark from '@wooorm/starry-night/style/tritanopia-dark' // CSS.
```

### `all`

List of all grammars ([`Array<Grammar>`][api-grammar])

### `common`

List of Â±35 common grammars ([`Array<Grammar>`][api-grammar])

### `createStarryNight(grammars[, options])`

Create a `StarryNight` that can highlight things with the given `grammars`.
This is async to allow async loading and registering,
which is currently only used for WASM.

###### Parameters

* `grammars`
  ([`Array<Grammar>`][api-grammar])
  â€” grammars to support
* `options`
  ([`Options`][api-options], optional)
  â€” configuration

###### Returns

Promise that resolves to an instance which highlights with the bound
grammars (`Promise<StarryNight>`).

### `starryNight.flagToScope(flag)`

Get the grammar scope (such as `text.md`) associated with a grammar name
(such as `markdown`) or grammar extension (such as `.mdwn`).

This function uses the first word (when splitting on spaces and tabs) that is
used after the opening of a fenced code block:

````markdown
```js
console.log(1)
```
````

To match GitHub,
this also accepts entire paths:

````markdown
```path/to/example.js
console.log(1)
```
````

> ðŸ‘‰ **Note**:
> languages can use the same extensions.
> For example,
> `.h` is reused by many languages.
> In those cases,
> you will get one scope back,
> but it might not be the most popular language associated with an extension.

###### Parameters

* `flag`
  (`string`)
  â€” grammar name
  (such as `'markdown'`),
  grammar extension
  (such as `'.mdwn'`),
  or entire file path ending in extension

###### Returns

Grammar scope,
such as `'text.md'`
(`string` or `undefined`).

###### Example

```js
import {common, createStarryNight} from '@wooorm/starry-night'

const starryNight = await createStarryNight(common)

console.log(starryNight.flagToScope('pandoc')) // `'text.md'`
console.log(starryNight.flagToScope('workbook')) // `'text.md'`
console.log(starryNight.flagToScope('.workbook')) // `'text.md'`
console.log(starryNight.flagToScope('path/to/example.js')) // `'source.js'`
console.log(starryNight.flagToScope('whatever')) // `undefined`
```

### `starryNight.highlight(value, scope)`

Highlight programming code.

###### Parameters

* `value` (`string`)
  â€” code to highlight
* `scope` (`string`)
  â€” registered grammar scope to highlight as (such as `'text.md'`)

###### Returns

Node representing highlighted code ([`Root`][github-hast-root]).

###### Example

```js
import sourceCss from '@wooorm/starry-night/source.css'
import {createStarryNight} from '@wooorm/starry-night'

const starryNight = await createStarryNight([sourceCss])

console.log(starryNight.highlight('em { color: red }', 'source.css'))
```

Yields:

```js
{
  type: 'root',
  children: [
    {type: 'element', tagName: 'span', properties: [Object], children: [Array]},
    {type: 'text', value: ' { '},
    {type: 'element', tagName: 'span', properties: [Object], children: [Array]},
    {type: 'text', value: ': '},
    {type: 'element', tagName: 'span', properties: [Object], children: [Array]},
    {type: 'text', value: ' }'}
  ]
}
```

### `starryNight.missingScopes()`

List scopes that are needed by the registered grammars but that are
missing.

To illustrate,
the `text.xml.svg` grammar needs the `text.xml` grammar.
When you register `text.xml.svg` without `text.xml`,
it will be listed here.

###### Returns

List of grammar scopes,
such as `'text.md'`
(`Array<string>`).

###### Example

```js
import textXmlSvg from '@wooorm/starry-night/text.xml.svg'
import textXml from '@wooorm/starry-night/text.xml'
import {createStarryNight} from '@wooorm/starry-night'

const svg = await createStarryNight([textXmlSvg])
console.log(svg.missingScopes()) //=> ['text.xml']

const svgAndXml = await createStarryNight([textXmlSvg, textXml])
console.log(svgAndXml.missingScopes()) //=> []
```

### `starryNight.register(grammars)`

Add more grammars.

###### Parameters

* `grammars` ([`Array<Grammar>`][api-grammar])
  â€” grammars to support

###### Returns

Promise resolving to nothing (`Promise<undefined>`).

###### Example

````js
import sourceCss from '@wooorm/starry-night/source.css'
import textMd from '@wooorm/starry-night/text.md'
import {createStarryNight} from '@wooorm/starry-night'
import {toHtml} from 'hast-util-to-html'

const markdown = '```css\nem { color: red }\n```'

const starryNight = await createStarryNight([textMd])

console.log(toHtml(starryNight.highlight(markdown, 'text.md')))

await starryNight.register([sourceCss])

console.log(toHtml(starryNight.highlight(markdown, 'text.md')))
````

Yields:

````html
<span class="pl-s">```</span><span class="pl-en">css</span>
<span class="pl-c1">em { color: red }</span>
<span class="pl-s">```</span>
````

````html
<span class="pl-s">```</span><span class="pl-en">css</span>
<span class="pl-ent">em</span> { <span class="pl-c1">color</span>: <span class="pl-c1">red</span> }
<span class="pl-s">```</span>
````

### `starryNight.scopes()`

List all registered scopes.

###### Returns

List of grammar scopes,
such as `'text.md'`
(`Array<string>`).

###### Example

```js
import {common, createStarryNight} from '@wooorm/starry-night'

const starryNight = await createStarryNight(common)

console.log(starryNight.scopes())
```

Yields:

```js
[
  'source.c',
  'source.c++',
  // â€¦
  'text.xml',
  'text.xml.svg'
]
```

### `GetOnigurumaUrl`

Function to get a URL to the oniguruma WASM (TypeScript type).

> ðŸ‘‰ **Note**:
> this must currently result in a version 2 URL of `onig.wasm` from
> [`vscode-oniguruma`][github-vscode-oniguruma].

> âš ï¸ **Danger**:
> when you use this functionality,
> your project might break at any time
> (when reinstalling dependencies),
> except when you make sure that the WASM binary you load manually is what our
> internally used `vscode-oniguruma` dependency expects.
> To solve this, you could for example use an npm script called
> [`dependencies`][npmjs-using-npm-script-dependencies]
> (which runs everytime `node_modules` is changed)
> which copies `vscode-oniguruma/release/onig.wasm` to the place you want to
> host it.

###### Returns

URL object to a WASM binary (`Promise<URL>` or `URL`).

###### Example

```js
import {common, createStarryNight} from '@wooorm/starry-night'

const starryNight = await createStarryNight(common, {
  getOnigurumaUrlFetch() {
    return new URL('/onig.wasm', window.location.href);
  }
})
```

### `Grammar`

TextMate grammar with some extra info (TypeScript type).

###### Fields

* `dependencies`
  (`Array<string>`, optional, example: `['source.tsx']`)
  â€” list of scopes that are needed for this grammar to work
* `extensions`
  (`Array<string>`, example: `['.mdx']`)
  â€” list of extensions
* `extensionsWithDot`
  (`Array<string>`, optional, example: `['.php']`)
  â€” list of extensions that only match if used w/ a dot
* `injections`
  (`Record<string, Rule>`, optional)
  â€” TextMate injections
* `names`
  (`Array<string>`, example: `['mdx']`)
  â€” list of names
* `patterns`
  (`Array<Rule>`)
  â€” TextMate patterns
* `repository`
  (`Record<string, Rule>`, optional)
  â€” TextMate repository
* `scopeName`
  (`string`, example: `'source.mdx'`)
  â€” scope

### `Options`

Configuration (TypeScript type).

###### Fields

* `getOnigurumaUrlFetch`
  ([`GetOnigurumaUrl`][api-get-oniguruma-url], optional)
  â€” get a URL to the oniguruma WASM,
  typically used in browsers
* `getOnigurumaUrlFs`
  ([`GetOnigurumaUrl`][api-get-oniguruma-url], optional)
  â€” get a URL to the oniguruma WASM,
  typically used in Node.js

## Examples

### Example: serializing hast as html

[`hast`][github-hast] trees as returned by `starry-night` can be serialized with
[`hast-util-to-html`][github-hast-util-to-html]:

```js
import {common, createStarryNight} from '@wooorm/starry-night'
import {toHtml} from 'hast-util-to-html'

const starryNight = await createStarryNight(common)

const tree = starryNight.highlight('"use strict";', 'source.js')

console.log(toHtml(tree))
```

Yields:

```html
<span class="pl-s"><span class="pl-pds">"</span>use strict<span class="pl-pds">"</span></span>;
```

### Example: using `starry-night` on the client

You donâ€™t *have* to do preprocess things on a server.
Particularly,
when you are not using Node.js or so.
Or,
when you have a lot of often changing content
(likely markdown),
such as on a page of comments.

In those cases,
you can run `starry-night` in the browser.
Here is an example.
It also uses [`hast-util-to-dom`][github-hast-util-to-dom],
which is a light way to turn the AST into DOM nodes.

Say we have this `example.js` on our browser (no bundling needed!):

```js
import {
  common,
  createStarryNight
} from 'https://esm.sh/@wooorm/starry-night@3?bundle'
import {toDom} from 'https://esm.sh/hast-util-to-dom@4?bundle'

const starryNight = await createStarryNight(common)
const prefix = 'language-'

const nodes = Array.from(document.body.querySelectorAll('code'))

for (const node of nodes) {
  const className = Array.from(node.classList).find(function (d) {
    return d.startsWith(prefix)
  })
  if (!className) continue
  const scope = starryNight.flagToScope(className.slice(prefix.length))
  if (!scope) continue
  const tree = starryNight.highlight(node.textContent, scope)
  node.replaceChildren(toDom(tree, {fragment: true}))
}
```

â€¦and then,
if we would have an `index.html` for our document:

```html
<!doctype html>
<meta charset=utf8>
<title>Hello</title>
<link rel=stylesheet href=https://esm.sh/@wooorm/starry-night@3/style/both>
<body>
<h1>Hello</h1>
<p>â€¦world!</p>
<pre><code class=language-js>console.log('it works!')
</code></pre>
<script type=module src=./example.js></script>
</body>
```

Opening that page in a browser,
weâ€™d see the `<code>` being swapped with:

```html
<code class="language-js"><span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-s"><span class="pl-pds">'</span>it works!<span class="pl-pds">'</span></span>)
</code>
```

### Example: turning hast into react nodes

hast trees as returned by `starry-night` can be turned into
preact, react, solid, svelte, vue, etc.,
with
[`hast-util-to-jsx-runtime`][github-hast-util-to-jsx-runtime]:

```js
import {common, createStarryNight} from '@wooorm/starry-night'
import {toJsxRuntime} from 'hast-util-to-jsx-runtime'
import {Fragment, jsx, jsxs} from 'react/jsx-runtime'

const starryNight = await createStarryNight(common)

const tree = starryNight.highlight('"use strict";', 'source.js')
const reactNode = toJsxRuntime(tree, {Fragment, jsx, jsxs})

console.log(reactNode)
```

Yields:

```js
{
  '$$typeof': Symbol(react.element),
  type: Symbol(react.fragment),
  key: null,
  ref: null,
  props: { children: [ [Object], ';' ] },
  _owner: null,
  _store: {}
}
```

### Example: adding line numbers

GitHub itself does not add line numbers to the code they highlight.
You can do that,
by transforming the AST.
Hereâ€™s an example of a utility that wraps each line into a span with a class and
a data attribute with its line number.
That way,
you can style the lines as you please.
Or you can generate different elements for each line,
of course.

Say we have our utility as `hast-util-starry-night-gutter.js`:

```js
/**
 * @import {ElementContent, Element, RootContent, Root} from 'hast'
 */

/**
 * @param {Root} tree
 *   Tree.
 * @returns {undefined}
 *   Nothing.
 */
export function starryNightGutter(tree) {
  /** @type {Array<RootContent>} */
  const replacement = []
  const search = /\r?\n|\r/g
  let index = -1
  let start = 0
  let startTextRemainder = ''
  let lineNumber = 0

  while (++index < tree.children.length) {
    const child = tree.children[index]

    if (child.type === 'text') {
      let textStart = 0
      let match = search.exec(child.value)

      while (match) {
        // Nodes in this line.
        const line = /** @type {Array<ElementContent>} */ (
          tree.children.slice(start, index)
        )

        // Prepend text from a partial matched earlier text.
        if (startTextRemainder) {
          line.unshift({type: 'text', value: startTextRemainder})
          startTextRemainder = ''
        }

        // Append text from this text.
        if (match.index > textStart) {
          line.push({
            type: 'text',
            value: child.value.slice(textStart, match.index)
          })
        }

        // Add a line, and the eol.
        lineNumber += 1
        replacement.push(createLine(line, lineNumber), {
          type: 'text',
          value: match[0]
        })

        start = index + 1
        textStart = match.index + match[0].length
        match = search.exec(child.value)
      }

      // If we matched, make sure to not drop the text after the last line ending.
      if (start === index + 1) {
        startTextRemainder = child.value.slice(textStart)
      }
    }
  }

  const line = /** @type {Array<ElementContent>} */ (tree.children.slice(start))
  // Prepend text from a partial matched earlier text.
  if (startTextRemainder) {
    line.unshift({type: 'text', value: startTextRemainder})
    startTextRemainder = ''
  }

  if (line.length > 0) {
    lineNumber += 1
    replacement.push(createLine(line, lineNumber))
  }

  // Replace children with new array.
  tree.children = replacement
}

/**
 * @param {Array<ElementContent>} children
 * @param {number} line
 * @returns {Element}
 */
function createLine(children, line) {
  return {
    type: 'element',
    tagName: 'span',
    properties: {className: 'line', dataLineNumber: line},
    children
  }
}
```

â€¦and a module `example.js`:

````js
import {common, createStarryNight} from '@wooorm/starry-night'
import {toHtml} from 'hast-util-to-html'
import {starryNightGutter} from './hast-util-starry-night-gutter.js'

const starryNight = await createStarryNight(common)

const tree = starryNight.highlight(
  '# Some heading\n\n```js\nalert(1)\n```\n***',
  'text.md'
)

starryNightGutter(tree)

console.log(toHtml(tree))
````

Now running `node example.js` yields:

````html
<span class="line" data-line-number="1"><span class="pl-mh"># <span class="pl-en">Some heading</span></span></span>
<span class="line" data-line-number="2"></span>
<span class="line" data-line-number="3"><span class="pl-s">```</span><span class="pl-en">js</span></span>
<span class="line" data-line-number="4"><span class="pl-en">alert</span>(<span class="pl-c1">1</span>)</span>
<span class="line" data-line-number="5"><span class="pl-s">```</span></span>
<span class="line" data-line-number="6"><span class="pl-ms">***</span></span>
````

### Example: integrate with unified, remark, and rehype

This example shows how to use
[`rehype-starry-night`][github-rehype-starry-night] with
[`unified`][github-unified].
If we have a markdown file `example.md`:

````markdown
# Hello

â€¦world!

```js
console.log('it works!')
```
````

â€¦and a module `example.js`:

```js
import fs from 'node:fs/promises'
import rehypeStarryNight from 'rehype-starry-night'
import rehypeStringify from 'rehype-stringify'
import remarkParse from 'remark-parse'
import remarkRehype from 'remark-rehype'
import {unified} from 'unified'

const file = await unified()
  .use(remarkParse)
  .use(remarkRehype)
  .use(rehypeStarryNight)
  .use(rehypeStringify)
  .process(await fs.readFile('example.md'))

console.log(String(file))
```

â€¦then running `node example.js` yields:

```html
<h1>Hello</h1>
<p>â€¦world!</p>
<pre><code class="language-js"><span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-s"><span class="pl-pds">'</span>it works!<span class="pl-pds">'</span></span>)
</code></pre>
```

### Example: integrating with `markdown-it`

This example shows how to combine `starry-night` with `markdown-it`.
If we have a markdown file `example.md`:

````markdown
# Hello

â€¦world!

```js
console.log('it works!')
```
````

â€¦and a module `example.js`:

```js
/**
 * @import {ElementContent} from 'hast'
 */

import fs from 'node:fs/promises'
import {common, createStarryNight} from '@wooorm/starry-night'
import {toHtml} from 'hast-util-to-html'
import markdownIt from 'markdown-it'

const file = await fs.readFile('example.md')
const starryNight = await createStarryNight(common)

const markdownItInstance = markdownIt({
  highlight(value, lang) {
    const scope = starryNight.flagToScope(lang)

    return toHtml({
      type: 'element',
      tagName: 'pre',
      properties: {
        className: scope
          ? [
              'highlight',
              'highlight-' + scope.replace(/^source\./, '').replace(/\./g, '-')
            ]
          : undefined
      },
      children: scope
        ? /** @type {Array<ElementContent>} */ (
            starryNight.highlight(value, scope).children
          )
        : [{type: 'text', value}]
    })
  }
})

const html = markdownItInstance.render(String(file))

console.log(html)
```

Now running `node example.js` yields:

```html
<h1>Hello</h1>
<p>â€¦world!</p>
<pre class="highlight highlight-js"><span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-s"><span class="pl-pds">'</span>it works!<span class="pl-pds">'</span></span>)
</pre>
```

<br>

[![](media/slice-2.jpg)][artsandculture-google-starry-night]

## Syntax tree

The generated [`hast`][github-hast] starts with a `root` node,
that represents the fragment.
It contains up to three levels of `<span>` `element`s,
each with a single class.
All these levels can contain text nodes with the actual code.
Interestingly,
TextMate grammars work per line,
so all line endings are in the root directly,
meaning that creating a gutter to display line numbers can be generated rather
naÃ¯vely by only looking through the root node.

## CSS

`starry-night` does not inject CSS for the syntax highlighted code
(because well,
`starry-night` doesnâ€™t have to be turned into HTML and might not run in a
browser!).
If you are in a browser,
you can use the packaged themes,
or get creative with CSS!
ðŸ’…

All themes accept CSS variables (custom properties).
With the theme `core.css`,
you have to define your own properties.
All other themes define the colors on `:root`.
Themes either have a `dark` or `light` suffix,
or none,
in which case they automatically switch colors based on a
`@media (prefers-color-scheme: dark)`.
All themes are tiny (under 1 kB).
The shipped themes are as follows:

| name | Includes light scheme | Includes dark scheme |
| - | - | - |
| [`@wooorm/starry-night/style/core`](style/core.css) | | |
| [`@wooorm/starry-night/style/light`](style/light.css) | âœ… | |
| [`@wooorm/starry-night/style/dark`](style/dark.css) | | âœ… |
| [`@wooorm/starry-night/style/both`](style/both.css) | âœ… | âœ… |
| [`@wooorm/starry-night/style/colorblind-light`](style/colorblind-light.css) | âœ… | |
| [`@wooorm/starry-night/style/colorblind-dark`](style/colorblind-dark.css) | | âœ… |
| [`@wooorm/starry-night/style/colorblind`](style/colorblind.css) | âœ… | âœ… |
| [`@wooorm/starry-night/style/dimmed-dark`](style/dimmed-dark.css) | | âœ… |
| [`@wooorm/starry-night/style/dimmed`](style/dimmed.css) | âœ… | âœ… |
| [`@wooorm/starry-night/style/high-contrast-light`](style/high-contrast-light.css) | âœ… | |
| [`@wooorm/starry-night/style/high-contrast-dark`](style/high-contrast-dark.css) | | âœ… |
| [`@wooorm/starry-night/style/high-contrast`](style/high-contrast.css) | âœ… | âœ… |
| [`@wooorm/starry-night/style/tritanopia-light`](style/tritanopia-light.css) | âœ… | |
| [`@wooorm/starry-night/style/tritanopia-dark`](style/tritanopia-dark.css) | | âœ… |
| [`@wooorm/starry-night/style/tritanopia`](style/tritanopia.css) | âœ… | âœ… |

## Languages

Checked grammars are included in [`common`][api-common].
Everything (thatâ€™s needed) is available through
[`all`][api-all].
You can add more grammars as you please.

Each grammar has several associated names and extensions.
See source files for which are known and use `flagToScope` to turn them into
scopes.

Some grammars need other grammars to work.
You are responsible for loading those,
use `missingScopes` to find which dependencies are needed.

All licenses are permissive and made available in [`notice`][file-notice].
Changes should go to upstream repos and
[`languages.yml` in `github-linguist`][github-linguist-languages-yml].

<!--support start-->

* [x] [`source.c`](lang/source.c.js) â€” [upstream](https://github.com/mikomikotaishi/c.tmbundle)
* [x] [`source.c++`](lang/source.c++.js) â€” [upstream](https://github.com/mikomikotaishi/c.tmbundle) â€” needs: `source.c`
* [x] [`source.cs`](lang/source.cs.js) (mit) â€” [upstream](https://github.com/dotnet/csharp-tmLanguage)
* [x] [`source.css`](lang/source.css.js) (mit) â€” [upstream](https://github.com/atom/language-css)
* [x] [`source.css.less`](lang/source.css.less.js) (mit) â€” [upstream](https://github.com/atom/language-less) â€” needs: `source.css`
* [x] [`source.css.scss`](lang/source.css.scss.js) (mit) â€” [upstream](https://github.com/atom/language-sass) â€” needs: `source.css`
* [x] [`source.diff`](lang/source.diff.js)
* [x] [`source.go`](lang/source.go.js) (bsd-3-clause) â€” [upstream](https://github.com/AlanQuatermain/go-tmbundle)
* [x] [`source.graphql`](lang/source.graphql.js) (mit) â€” [upstream](https://github.com/graphql/graphiql)
* [x] [`source.ini`](lang/source.ini.js)
* [x] [`source.java`](lang/source.java.js) â€” [upstream](https://github.com/textmate/java.tmbundle)
* [x] [`source.js`](lang/source.js.js) (mit) â€” [upstream](https://github.com/atom/language-javascript)
* [x] [`source.json`](lang/source.json.js) (isc) â€” [upstream](https://github.com/Nixinova/NovaGrammars)
* [x] [`source.kotlin`](lang/source.kotlin.js) (apache-2.0) â€” [upstream](https://github.com/nishtahir/language-kotlin)
* [x] [`source.lua`](lang/source.lua.js) (mit) â€” [upstream](https://github.com/LuaLS/lua.tmbundle)
* [x] [`source.makefile`](lang/source.makefile.js) â€” [upstream](https://github.com/textmate/make.tmbundle) â€” needs: `source.shell`
* [x] [`source.objc`](lang/source.objc.js) â€” needs: `source.c`, `source.objc.platform`
* [x] [`source.objc.platform`](lang/source.objc.platform.js)
* [x] [`source.perl`](lang/source.perl.js) â€” [upstream](https://github.com/textmate/perl.tmbundle)
* [x] [`source.python`](lang/source.python.js) (mit) â€” [upstream](https://github.com/MagicStack/MagicPython)
* [x] [`source.r`](lang/source.r.js)
* [x] [`source.ruby`](lang/source.ruby.js) (mit) â€” [upstream](https://github.com/atom/language-ruby)
* [x] [`source.rust`](lang/source.rust.js) (mit) â€” [upstream](https://github.com/dustypomerleau/rust-syntax)
* [x] [`source.shell`](lang/source.shell.js) (mit) â€” [upstream](https://github.com/atom/language-shellscript)
* [x] [`source.sql`](lang/source.sql.js)
* [x] [`source.swift`](lang/source.swift.js) (mit) â€” [upstream](https://github.com/jtbandes/swift-tmlanguage)
* [x] [`source.ts`](lang/source.ts.js) (mit) â€” [upstream](https://github.com/Microsoft/TypeScript-TmLanguage)
* [x] [`source.vbnet`](lang/source.vbnet.js) (apache-2.0) â€” [upstream](https://github.com/angryant0007/VBDotNetSyntax)
* [x] [`source.yaml`](lang/source.yaml.js) (mit) â€” [upstream](https://github.com/atom/language-yaml)
* [x] [`text.html.basic`](lang/text.html.basic.js) (mit) â€” [upstream](https://github.com/atom/language-html)
* [x] [`text.html.php`](lang/text.html.php.js) â€” needs: `text.html.basic`
* [x] [`text.md`](lang/text.md.js) (mit) â€” [upstream](https://github.com/wooorm/markdown-tm-language)
* [x] [`text.xml`](lang/text.xml.js)
* [x] [`text.xml.svg`](lang/text.xml.svg.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `text.xml`
* [ ] [`config.xcompose`](lang/config.xcompose.js) (mit)
* [ ] [`etc`](lang/etc.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `source.regexp.posix`
* [ ] [`file.lasso`](lang/file.lasso.js) (public domain)
* [ ] [`go.mod`](lang/go.mod.js) (mit) â€” [upstream](https://github.com/golang/vscode-go)
* [ ] [`go.sum`](lang/go.sum.js) (mit) â€” [upstream](https://github.com/golang/vscode-go)
* [ ] [`injections.etc`](lang/injections.etc.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc)
* [ ] [`objdump.x86asm`](lang/objdump.x86asm.js) (mit) â€” needs: `source.c`, `source.c++`
* [ ] [`source.2da`](lang/source.2da.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc)
* [ ] [`source.4dm`](lang/source.4dm.js) (mit)
* [ ] [`source.8xp`](lang/source.8xp.js) (bsd-3-clause) â€” [upstream](https://github.com/TIny-Hacker/language-ti-basic)
* [ ] [`source.abap`](lang/source.abap.js) â€” [upstream](https://github.com/pvl/abap.tmbundle)
* [ ] [`source.abapcds`](lang/source.abapcds.js) (unlicense) â€” [upstream](https://github.com/FreHu/abap-cds-grammar)
* [ ] [`source.abl`](lang/source.abl.js) (mit) â€” [upstream](https://github.com/chriscamicas/abl-tmlanguage)
* [ ] [`source.abnf`](lang/source.abnf.js) (isc) â€” [upstream](https://github.com/Alhadis/language-grammars)
* [ ] [`source.actionscript.3`](lang/source.actionscript.3.js) (mit) â€” [upstream](https://github.com/simongregory/actionscript3-tmbundle) â€” needs: `text.html.asdoc`, `text.xml`
* [ ] [`source.ada`](lang/source.ada.js)
* [ ] [`source.afm`](lang/source.afm.js) (isc) â€” [upstream](https://github.com/Alhadis/language-fontforge)
* [ ] [`source.agc`](lang/source.agc.js) (isc)
* [ ] [`source.agda`](lang/source.agda.js) (mit) â€” [upstream](https://github.com/agda/agda-github-syntax-highlighting)
* [ ] [`source.ahk`](lang/source.ahk.js) (unlicense) â€” [upstream](https://github.com/ahkscript/SublimeAutoHotkey)
* [ ] [`source.aidl`](lang/source.aidl.js) (apache-2.0) â€” [upstream](https://github.com/google/aidl-language)
* [ ] [`source.aiken`](lang/source.aiken.js) (apache-2.0) â€” [upstream](https://github.com/aiken-lang/vscode-aiken)
* [ ] [`source.al`](lang/source.al.js) (mit) â€” [upstream](https://github.com/microsoft/AL)
* [ ] [`source.alloy`](lang/source.alloy.js) (apache-2.0) â€” [upstream](https://github.com/macekond/Alloy.tmbundle)
* [ ] [`source.ampl`](lang/source.ampl.js) (mit)
* [ ] [`source.angelscript`](lang/source.angelscript.js) (unlicense) â€” [upstream](https://github.com/wronex/sublime-angelscript)
* [ ] [`source.answersetprogramming`](lang/source.answersetprogramming.js) (mit) â€” [upstream](https://github.com/nickswalker/asp-syntax-highlight)
* [ ] [`source.antlr`](lang/source.antlr.js)
* [ ] [`source.apacheconf`](lang/source.apacheconf.js) (mit) â€” [upstream](https://github.com/mrmlnc/vscode-apache)
* [ ] [`source.apex`](lang/source.apex.js) (bsd-3-clause) â€” [upstream](https://github.com/forcedotcom/apex-tmLanguage)
* [ ] [`source.apl`](lang/source.apl.js) (isc) â€” [upstream](https://github.com/Alhadis/language-apl)
* [ ] [`source.applescript`](lang/source.applescript.js)
* [ ] [`source.arr`](lang/source.arr.js) (mit) â€” [upstream](https://github.com/samuela/language-pyret)
* [ ] [`source.asl`](lang/source.asl.js) (mit) â€” [upstream](https://github.com/sebadur/language-asl)
* [ ] [`source.asn`](lang/source.asn.js) (mit) â€” [upstream](https://github.com/ajlangley/language-asn1)
* [ ] [`source.asp`](lang/source.asp.js)
* [ ] [`source.aspectj`](lang/source.aspectj.js) (mit)
* [ ] [`source.assembly`](lang/source.assembly.js) (bsd-3-clause) â€” [upstream](https://github.com/Nessphoro/sublimeassembly)
* [ ] [`source.astro`](lang/source.astro.js) (mit) â€” [upstream](https://github.com/withastro/language-tools) â€” needs: `source.js`, `source.ts`, `source.tsx`
* [ ] [`source.ats`](lang/source.ats.js) (mit)
* [ ] [`source.autoit`](lang/source.autoit.js) (mit)
* [ ] [`source.avro`](lang/source.avro.js) (mit) â€” [upstream](https://github.com/Jason3S/avro.tmLanguage)
* [ ] [`source.awk`](lang/source.awk.js) (mit)
* [ ] [`source.ballerina`](lang/source.ballerina.js) (apache-2.0) â€” [upstream](https://github.com/ballerina-platform/ballerina-grammar)
* [ ] [`source.basic`](lang/source.basic.js) (apache-2.0) â€” [upstream](https://github.com/telnet23/language-basic)
* [ ] [`source.batchfile`](lang/source.batchfile.js) (mit) â€” [upstream](https://github.com/mmims/language-batchfile)
* [ ] [`source.bb`](lang/source.bb.js) (mit) â€” [upstream](https://github.com/yoctoproject/vscode-bitbake)
* [ ] [`source.bdf`](lang/source.bdf.js) (isc) â€” [upstream](https://github.com/Alhadis/language-fontforge) â€” needs: `source.xlfd`
* [ ] [`source.befunge`](lang/source.befunge.js) (mit)
* [ ] [`source.berry`](lang/source.berry.js) (mit) â€” [upstream](https://github.com/berry-lang/berry-grammar)
* [ ] [`source.bf`](lang/source.bf.js) (mit) â€” [upstream](https://github.com/Drako/SublimeBrainfuck)
* [ ] [`source.bh`](lang/source.bh.js) (bsd-3-clause) â€” [upstream](https://github.com/B-Lang-org/language-bh)
* [ ] [`source.bicep`](lang/source.bicep.js) (mit) â€” [upstream](https://github.com/azure/bicep)
* [ ] [`source.blitzmax`](lang/source.blitzmax.js)
* [ ] [`source.boo`](lang/source.boo.js) (mit) â€” [upstream](https://github.com/drslump/sublime-boo)
* [ ] [`source.boogie`](lang/source.boogie.js) (mit) â€” [upstream](https://github.com/boogie-org/boogie-vscode)
* [ ] [`source.bp`](lang/source.bp.js) (mit) â€” [upstream](https://github.com/flimberger/android-system-tools)
* [ ] [`source.bqn`](lang/source.bqn.js) (mit) â€” [upstream](https://github.com/razetime/bqn-vscode)
* [ ] [`source.brs`](lang/source.brs.js) (mit) â€” [upstream](https://github.com/rokucommunity/vscode-brightscript-language)
* [ ] [`source.bsl`](lang/source.bsl.js) (mit) â€” [upstream](https://github.com/1c-syntax/vsc-language-1c-bsl) â€” needs: `source.sdbl`
* [ ] [`source.bst`](lang/source.bst.js) (mit) â€” [upstream](https://github.com/zyoshoka/bst.tmLanguage)
* [ ] [`source.bsv`](lang/source.bsv.js) (mit)
* [ ] [`source.c.ec`](lang/source.c.ec.js) (unlicense) â€” [upstream](https://github.com/ecere/ec.tmbundle) â€” needs: `source.c`
* [ ] [`source.c.linker`](lang/source.c.linker.js) (mit) â€” [upstream](https://github.com/donno2048/Linker.tmLanguage)
* [ ] [`source.c.nwscript`](lang/source.c.nwscript.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `source.c`
* [ ] [`source.cabal`](lang/source.cabal.js) (mit) â€” [upstream](https://github.com/atom-haskell/language-haskell)
* [ ] [`source.Caddyfile`](lang/source.Caddyfile.js) (mit) â€” [upstream](https://github.com/caddyserver/vscode-caddyfile)
* [ ] [`source.cadence`](lang/source.cadence.js) (apache-2.0) â€” [upstream](https://github.com/onflow/vscode-cadence)
* [ ] [`source.cairo`](lang/source.cairo.js) (apache-2.0) â€” [upstream](https://github.com/software-mansion-labs/cairo-tm-grammar)
* [ ] [`source.cairo0`](lang/source.cairo0.js) (apache-2.0) â€” [upstream](https://github.com/software-mansion-labs/cairo-tm-grammar)
* [ ] [`source.camlp4.ocaml`](lang/source.camlp4.ocaml.js) â€” needs: `source.ocaml`
* [ ] [`source.capnp`](lang/source.capnp.js)
* [ ] [`source.cds`](lang/source.cds.js) (apache-2.0) â€” [upstream](https://github.com/SAP/cds-textmate-grammar)
* [ ] [`source.ceylon`](lang/source.ceylon.js) (apache-2.0)
* [ ] [`source.cfscript`](lang/source.cfscript.js) (mit) â€” needs: `source.sql`
* [ ] [`source.changelogs.rpm-spec`](lang/source.changelogs.rpm-spec.js) (mit)
* [ ] [`source.chapel`](lang/source.chapel.js) (apache-2.0) â€” [upstream](https://github.com/chapel-lang/chapel-tmbundle)
* [ ] [`source.cil`](lang/source.cil.js) (apache-2.0) â€” [upstream](https://github.com/google/selinux-policy-languages)
* [ ] [`source.circom`](lang/source.circom.js) (mit) â€” [upstream](https://github.com/iden3/circom-highlighting-vscode)
* [ ] [`source.cirru`](lang/source.cirru.js) (mit) â€” [upstream](https://github.com/Cirru/sublime-cirru)
* [ ] [`source.clar`](lang/source.clar.js) (mit) â€” [upstream](https://github.com/hirosystems/clarity.tmbundle)
* [ ] [`source.clarion`](lang/source.clarion.js) (mit) â€” [upstream](https://github.com/fushnisoft/SublimeClarion)
* [ ] [`source.clean`](lang/source.clean.js) (mit)
* [ ] [`source.click`](lang/source.click.js) (mit)
* [ ] [`source.clips`](lang/source.clips.js) (mit)
* [ ] [`source.clojure`](lang/source.clojure.js) (mit) â€” [upstream](https://github.com/atom/language-clojure)
* [ ] [`source.clue`](lang/source.clue.js) (mit) â€” [upstream](https://github.com/ClueLang/Clue-for-VSCode)
* [ ] [`source.cmake`](lang/source.cmake.js) (mit) â€” [upstream](https://github.com/microsoft/vscode-cmake-tools)
* [ ] [`source.cobol`](lang/source.cobol.js) (mit) â€” [upstream](https://github.com/spgennard/vscode_cobol)
* [ ] [`source.coffee`](lang/source.coffee.js) (mit) â€” [upstream](https://github.com/atom/language-coffee-script) â€” needs: `source.js`
* [ ] [`source.commonlisp`](lang/source.commonlisp.js) (mit) â€” [upstream](https://github.com/qingpeng9802/common-lisp-tmlanguage)
* [ ] [`source.cool`](lang/source.cool.js) (mit)
* [ ] [`source.coq`](lang/source.coq.js) (mit)
* [ ] [`source.crystal`](lang/source.crystal.js) (mit) â€” [upstream](https://github.com/atom-crystal/language-crystal) â€” needs: `text.html.basic`
* [ ] [`source.csound`](lang/source.csound.js) (mit) â€” [upstream](https://github.com/nwhetsell/language-csound)
* [ ] [`source.csound-document`](lang/source.csound-document.js) (mit) â€” [upstream](https://github.com/nwhetsell/language-csound) â€” needs: `source.csound`, `text.xml`
* [ ] [`source.csound-score`](lang/source.csound-score.js) (mit) â€” [upstream](https://github.com/nwhetsell/language-csound) â€” needs: `source.csound`
* [ ] [`source.css.mss`](lang/source.css.mss.js) (mit)
* [ ] [`source.css.postcss.sugarss`](lang/source.css.postcss.sugarss.js) (mit)
* [ ] [`source.csswg`](lang/source.csswg.js) (cc0-1.0) â€” [upstream](https://github.com/tabatkins/bikeshed)
* [ ] [`source.cuda-c++`](lang/source.cuda-c++.js) (bsd-3-clause) â€” [upstream](https://github.com/harrism/sublimetext-cuda-cpp) â€” needs: `source.c++`
* [ ] [`source.cue`](lang/source.cue.js) (mit) â€” [upstream](https://github.com/cue-sh/vscode-cue)
* [ ] [`source.cuesheet`](lang/source.cuesheet.js) (mit) â€” [upstream](https://github.com/relikd/CUE-Sheet_sublime)
* [ ] [`source.curlrc`](lang/source.curlrc.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `etc`
* [ ] [`source.curry`](lang/source.curry.js) (mit) â€” [upstream](https://github.com/fwcd/vscode-curry)
* [ ] [`source.cwl`](lang/source.cwl.js) (mit)
* [ ] [`source.cylc`](lang/source.cylc.js) (bsd-3-clause) â€” [upstream](https://github.com/cylc/Cylc.tmbundle)
* [ ] [`source.cypher`](lang/source.cypher.js) (apache-2.0) â€” [upstream](https://github.com/fredbenenson/sublime-cypher)
* [ ] [`source.cython`](lang/source.cython.js) â€” needs: `source.regexp.python`
* [ ] [`source.d`](lang/source.d.js) â€” [upstream](https://github.com/textmate/d.tmbundle) â€” needs: `text.html.javadoc`
* [ ] [`source.d2`](lang/source.d2.js) (bsd-3-clause) â€” [upstream](https://github.com/terrastruct/d2-vscode)
* [ ] [`source.dart`](lang/source.dart.js) (bsd-3-clause) â€” [upstream](https://github.com/dart-lang/dart-syntax-highlight)
* [ ] [`source.daslang`](lang/source.daslang.js) (mit) â€” [upstream](https://github.com/moleium/daslang-grammar)
* [ ] [`source.data-weave`](lang/source.data-weave.js) (mit) â€” [upstream](https://github.com/mulesoft-labs/data-weave-tmLanguage)
* [ ] [`source.deb-control`](lang/source.deb-control.js) (mit) â€” [upstream](https://github.com/tsbarnes/language-debian)
* [ ] [`source.denizenscript`](lang/source.denizenscript.js) (mit) â€” [upstream](https://github.com/DenizenScript/denizenscript-grammar)
* [ ] [`source.desktop`](lang/source.desktop.js)
* [ ] [`source.dircolors`](lang/source.dircolors.js) (mit)
* [ ] [`source.ditroff`](lang/source.ditroff.js) (isc) â€” [upstream](https://github.com/Alhadis/language-roff) â€” needs: `source.ditroff.desc`, `text.roff`
* [ ] [`source.ditroff.desc`](lang/source.ditroff.desc.js) (isc) â€” [upstream](https://github.com/Alhadis/language-roff)
* [ ] [`source.dm`](lang/source.dm.js) (mit) â€” [upstream](https://github.com/spacestation13/dm-syntax)
* [ ] [`source.dockerfile`](lang/source.dockerfile.js) (mit) â€” [upstream](https://github.com/asbjornenge/Docker.tmbundle)
* [ ] [`source.dot`](lang/source.dot.js)
* [ ] [`source.dotenv`](lang/source.dotenv.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc)
* [ ] [`source.dune`](lang/source.dune.js) (mit) â€” [upstream](https://github.com/maelvls/vscode-dune)
* [ ] [`source.dylan`](lang/source.dylan.js)
* [ ] [`source.earthfile`](lang/source.earthfile.js) (mpl-2.0) â€” [upstream](https://github.com/earthly/earthfile-grammar)
* [ ] [`source.ebnf`](lang/source.ebnf.js) (isc) â€” [upstream](https://github.com/Alhadis/language-grammars) â€” needs: `source.lex.regexp`
* [ ] [`source.ecl`](lang/source.ecl.js) (apache-2.0) â€” [upstream](https://github.com/hpcc-systems/ecl-tmLanguage)
* [ ] [`source.edgeql`](lang/source.edgeql.js) (mit) â€” [upstream](https://github.com/edgedb/edgedb-editor-plugin)
* [ ] [`source.editorconfig`](lang/source.editorconfig.js) (mit) â€” [upstream](https://github.com/sindresorhus/atom-editorconfig)
* [ ] [`source.eiffel`](lang/source.eiffel.js)
* [ ] [`source.elixir`](lang/source.elixir.js) (apache-2.0) â€” [upstream](https://github.com/elixir-lang/elixir-tmbundle) â€” needs: `text.elixir`
* [ ] [`source.elm`](lang/source.elm.js) (mit) â€” [upstream](https://github.com/elm-community/Elm.tmLanguage)
* [ ] [`source.elvish`](lang/source.elvish.js) (bsd-2-clause) â€” [upstream](https://github.com/elves/elvish)
* [ ] [`source.elvish-transcript`](lang/source.elvish-transcript.js) (bsd-2-clause) â€” [upstream](https://github.com/elves/elvish) â€” needs: `source.elvish`
* [ ] [`source.emacs.lisp`](lang/source.emacs.lisp.js) (isc) â€” [upstream](https://github.com/Alhadis/language-emacs-lisp)
* [ ] [`source.erlang`](lang/source.erlang.js) (apache-2.0) â€” [upstream](https://github.com/erlang-ls/grammar)
* [ ] [`source.euphoria`](lang/source.euphoria.js) (mit) â€” [upstream](https://github.com/OpenEuphoria/vscode-euphoria)
* [ ] [`source.factor`](lang/source.factor.js) (bsd-2-clause)
* [ ] [`source.fan`](lang/source.fan.js) (mit)
* [ ] [`source.fancy`](lang/source.fancy.js) (bsd-3-clause) â€” [upstream](https://github.com/fancy-lang/fancy-tmbundle)
* [ ] [`source.faust`](lang/source.faust.js) (mit)
* [ ] [`source.figfont`](lang/source.figfont.js) (isc) â€” [upstream](https://github.com/Alhadis/language-fontforge)
* [ ] [`source.firestore`](lang/source.firestore.js) (mit)
* [ ] [`source.firrtl`](lang/source.firrtl.js) (apache-2.0) â€” [upstream](https://github.com/chipsalliance/firrtl-syntax)
* [ ] [`source.fish`](lang/source.fish.js) (mit)
* [ ] [`source.fnl`](lang/source.fnl.js) (mit) â€” [upstream](https://github.com/kongeor/vsc-fennel)
* [ ] [`source.fontdir`](lang/source.fontdir.js) (isc) â€” [upstream](https://github.com/Alhadis/language-fontforge) â€” needs: `source.xlfd`
* [ ] [`source.fontforge`](lang/source.fontforge.js) (isc) â€” [upstream](https://github.com/Alhadis/language-fontforge)
* [ ] [`source.forth`](lang/source.forth.js)
* [ ] [`source.fortran`](lang/source.fortran.js)
* [ ] [`source.fortran.modern`](lang/source.fortran.modern.js) â€” needs: `source.fortran`
* [ ] [`source.fsharp`](lang/source.fsharp.js) (mit) â€” [upstream](https://github.com/ionide/ionide-fsgrammar)
* [ ] [`source.fstar`](lang/source.fstar.js) (apache-2.0) â€” [upstream](https://github.com/FStarLang/atom-fstar)
* [ ] [`source.ftl`](lang/source.ftl.js) (mit) â€” [upstream](https://github.com/macabeus/vscode-fluent)
* [ ] [`source.futhark`](lang/source.futhark.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `etc`
* [ ] [`source.gap`](lang/source.gap.js) â€” [upstream](https://github.com/dhowden/gap-tmbundle)
* [ ] [`source.gcode`](lang/source.gcode.js) (mit) â€” [upstream](https://github.com/appliedengdesign/vscode-gcode-syntax)
* [ ] [`source.gdb`](lang/source.gdb.js) (zlib) â€” [upstream](https://github.com/quarnster/SublimeGDB)
* [ ] [`source.gdresource`](lang/source.gdresource.js) (mit) â€” [upstream](https://github.com/godotengine/godot-vscode-plugin)
* [ ] [`source.gdscript`](lang/source.gdscript.js) (mit) â€” [upstream](https://github.com/godotengine/godot-vscode-plugin)
* [ ] [`source.gdshader`](lang/source.gdshader.js) (mit) â€” [upstream](https://github.com/godotengine/godot-vscode-plugin)
* [ ] [`source.gedcom`](lang/source.gedcom.js) (apache-2.0) â€” [upstream](https://github.com/fguitton/vscode-gedcom)
* [ ] [`source.gemfile-lock`](lang/source.gemfile-lock.js) (mit) â€” [upstream](https://github.com/hmarr/gemfile-lock-tmlanguage)
* [ ] [`source.gemini`](lang/source.gemini.js) (mit) â€” [upstream](https://github.com/printfn/gemini-vscode)
* [ ] [`source.generic-db`](lang/source.generic-db.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `etc`
* [ ] [`source.genero-4gl`](lang/source.genero-4gl.js) (unlicense) â€” [upstream](https://github.com/FourjsGenero/GeneroFgl.tmbundle)
* [ ] [`source.genero-per`](lang/source.genero-per.js) (unlicense) â€” [upstream](https://github.com/FourjsGenero/GeneroFgl.tmbundle)
* [ ] [`source.gerber`](lang/source.gerber.js) (isc) â€” [upstream](https://github.com/Alhadis/language-pcb)
* [ ] [`source.gf`](lang/source.gf.js) (mit) â€” [upstream](https://github.com/johnjcamilleri/language-gf)
* [ ] [`source.git-revlist`](lang/source.git-revlist.js) (isc) â€” [upstream](https://github.com/Nixinova/NovaGrammars)
* [ ] [`source.gitattributes`](lang/source.gitattributes.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `etc`, `source.gitignore`
* [ ] [`source.gitconfig`](lang/source.gitconfig.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `source.shell`
* [ ] [`source.gitignore`](lang/source.gitignore.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `etc`
* [ ] [`source.gjs`](lang/source.gjs.js) (mit) â€” [upstream](https://github.com/lifeart/vsc-ember-syntax) â€” needs: `source.js`
* [ ] [`source.gleam`](lang/source.gleam.js) (apache-2.0) â€” [upstream](https://github.com/gleam-lang/vscode-gleam)
* [ ] [`source.glsl`](lang/source.glsl.js) (unlicense) â€” [upstream](https://github.com/euler0/sublime-glsl)
* [ ] [`source.gn`](lang/source.gn.js) (bsd-3-clause) â€” [upstream](https://github.com/devoncarew/language-gn)
* [ ] [`source.gnuplot`](lang/source.gnuplot.js) (mit)
* [ ] [`source.golo`](lang/source.golo.js) (mit) â€” [upstream](https://github.com/TypeUnsafe/sublime-golo)
* [ ] [`source.gosu.2`](lang/source.gosu.2.js) (apache-2.0) â€” [upstream](https://github.com/jpcamara/Textmate-Gosu-Bundle)
* [ ] [`source.grace`](lang/source.grace.js) (mit)
* [ ] [`source.gremlin`](lang/source.gremlin.js) (isc) â€” [upstream](https://github.com/Alhadis/language-roff) â€” needs: `text.roff`
* [ ] [`source.groovy`](lang/source.groovy.js)
* [ ] [`source.groovy.gradle`](lang/source.groovy.gradle.js) (apache-2.0) â€” needs: `source.groovy`
* [ ] [`source.gsc`](lang/source.gsc.js) (unlicense) â€” [upstream](https://github.com/Jake-NotTheMuss/CoDT7-Sublime)
* [ ] [`source.gts`](lang/source.gts.js) (mit) â€” [upstream](https://github.com/lifeart/vsc-ember-syntax) â€” needs: `source.ts`
* [ ] [`source.hack`](lang/source.hack.js) (mit) â€” [upstream](https://github.com/slackhq/vscode-hack) â€” needs: `text.html.basic`
* [ ] [`source.haproxy-config`](lang/source.haproxy-config.js) (mit)
* [ ] [`source.harbour`](lang/source.harbour.js) (mit)
* [ ] [`source.haskell`](lang/source.haskell.js) (mit) â€” [upstream](https://github.com/atom-haskell/language-haskell)
* [ ] [`source.hc`](lang/source.hc.js) (unlicense)
* [ ] [`source.hcl`](lang/source.hcl.js) (mpl-2.0) â€” [upstream](https://github.com/hashicorp/syntax)
* [ ] [`source.hcl.terraform`](lang/source.hcl.terraform.js) (mpl-2.0) â€” [upstream](https://github.com/hashicorp/syntax)
* [ ] [`source.hlsl`](lang/source.hlsl.js) (mit)
* [ ] [`source.hocon`](lang/source.hocon.js) (mit) â€” [upstream](https://github.com/jacobwgillespie/language-hocon)
* [ ] [`source.hoon`](lang/source.hoon.js) (mit) â€” [upstream](https://github.com/pkova/hoon-grammar)
* [ ] [`source.hosts`](lang/source.hosts.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `etc`
* [ ] [`source.hql`](lang/source.hql.js) (mit)
* [ ] [`source.httpspec`](lang/source.httpspec.js) (mit) â€” [upstream](https://github.com/samsalisbury/Sublime-HTTP) â€” needs: `source.json`
* [ ] [`source.hx`](lang/source.hx.js) (mit) â€” [upstream](https://github.com/vshaxe/haxe-TmLanguage)
* [ ] [`source.hxml`](lang/source.hxml.js) (mit) â€” [upstream](https://github.com/vshaxe/haxe-TmLanguage) â€” needs: `source.hx`
* [ ] [`source.hy`](lang/source.hy.js) (mit) â€” [upstream](https://github.com/tshakalekholoane/vscode-hy)
* [ ] [`source.iCalendar`](lang/source.iCalendar.js) (mit) â€” [upstream](https://github.com/kimsey0/iCalendar-sublime)
* [ ] [`source.ice`](lang/source.ice.js) (bsd-3-clause) â€” [upstream](https://github.com/zeroc-ice/vscode-slice)
* [ ] [`source.ideal`](lang/source.ideal.js) (isc) â€” [upstream](https://github.com/Alhadis/language-roff) â€” needs: `source.pic`, `text.roff`
* [ ] [`source.idl`](lang/source.idl.js) (bsd-3-clause) â€” [upstream](https://github.com/mgalloy/idl.tmbundle)
* [ ] [`source.idris`](lang/source.idris.js) (mit) â€” [upstream](https://github.com/idris-hackers/idris-sublime)
* [ ] [`source.igor`](lang/source.igor.js) (bsd-3-clause) â€” [upstream](https://github.com/byte-physics/language-igor)
* [ ] [`source.imba`](lang/source.imba.js) (mit) â€” [upstream](https://github.com/imba/imba-linguist-grammar)
* [ ] [`source.inform7`](lang/source.inform7.js) (mit) â€” [upstream](https://github.com/erkyrath/language-inform7)
* [ ] [`source.ini.npmrc`](lang/source.ini.npmrc.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `etc`
* [ ] [`source.ink`](lang/source.ink.js) (mit) â€” [upstream](https://github.com/inkle/ink-tmlanguage)
* [ ] [`source.inno`](lang/source.inno.js) (mit) â€” [upstream](https://github.com/idleberg/atom-language-innosetup) â€” needs: `source.pascal`
* [ ] [`source.inputrc`](lang/source.inputrc.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `etc`
* [ ] [`source.io`](lang/source.io.js)
* [ ] [`source.ioke`](lang/source.ioke.js) (mit)
* [ ] [`source.isabelle.root`](lang/source.isabelle.root.js) (bsd-2-clause) â€” [upstream](https://github.com/lsf37/Isabelle.tmbundle)
* [ ] [`source.isabelle.theory`](lang/source.isabelle.theory.js) (bsd-2-clause) â€” [upstream](https://github.com/lsf37/Isabelle.tmbundle)
* [ ] [`source.ispc`](lang/source.ispc.js) (bsd-3-clause) â€” [upstream](https://github.com/ispc/ispc.syntax)
* [ ] [`source.j`](lang/source.j.js) (mit) â€” [upstream](https://github.com/tikkanz/JSyntax)
* [ ] [`source.jai`](lang/source.jai.js) (mit) â€” [upstream](https://github.com/SogoCZE/Jails)
* [ ] [`source.janet`](lang/source.janet.js) (mit) â€” [upstream](https://github.com/janet-lang/vscode-janet)
* [ ] [`source.jasmin`](lang/source.jasmin.js) (wtfpl) â€” [upstream](https://github.com/atmarksharp/jasmin-sublime)
* [ ] [`source.java-properties`](lang/source.java-properties.js) â€” [upstream](https://github.com/textmate/java.tmbundle)
* [ ] [`source.jcl`](lang/source.jcl.js) (mit) â€” [upstream](https://github.com/spgennard/vscode_cobol)
* [ ] [`source.jest.snap`](lang/source.jest.snap.js) (mit) â€” [upstream](https://github.com/jest-community/vscode-jest)
* [ ] [`source.jflex`](lang/source.jflex.js) (bsd-2-clause) â€” [upstream](https://github.com/jflex-de/jflex.tmbundle) â€” needs: `source.java`
* [ ] [`source.jison`](lang/source.jison.js) (mit) â€” needs: `source.jisonlex`
* [ ] [`source.jisonlex`](lang/source.jisonlex.js) (mit) â€” needs: `source.jison`, `source.js`
* [ ] [`source.jolie`](lang/source.jolie.js) (mit)
* [ ] [`source.jq`](lang/source.jq.js) (mit) â€” [upstream](https://github.com/wader/language-jq)
* [ ] [`source.js.objj`](lang/source.js.objj.js) â€” needs: `source.js`
* [ ] [`source.json.comments`](lang/source.json.comments.js) (mit) â€” [upstream](https://github.com/DecimalTurn/vscode-jsonc-syntax-highlighting)
* [ ] [`source.jsoniq`](lang/source.jsoniq.js) (apache-2.0) â€” [upstream](https://github.com/wcandillon/language-jsoniq)
* [ ] [`source.jsonnet`](lang/source.jsonnet.js) (apache-2.0) â€” [upstream](https://github.com/google/language-jsonnet)
* [ ] [`source.julia`](lang/source.julia.js) (mit) â€” [upstream](https://github.com/JuliaEditorSupport/atom-language-julia)
* [ ] [`source.julia.console`](lang/source.julia.console.js) (mit) â€” [upstream](https://github.com/JuliaEditorSupport/atom-language-julia) â€” needs: `source.julia`, `source.shell`
* [ ] [`source.just`](lang/source.just.js) (mit) â€” [upstream](https://github.com/nefrob/vscode-just)
* [ ] [`source.kakscript`](lang/source.kakscript.js) (unlicense) â€” [upstream](https://github.com/kakoune-editor/language-kak)
* [ ] [`source.kdl`](lang/source.kdl.js) (apache-2.0) â€” [upstream](https://github.com/kdl-org/vscode-kdl)
* [ ] [`source.kerboscript`](lang/source.kerboscript.js) (mit) â€” [upstream](https://github.com/KSP-KOS/language-kerboscript)
* [ ] [`source.keyvalues`](lang/source.keyvalues.js) (isc) â€” [upstream](https://github.com/Nixinova/NovaGrammars)
* [ ] [`source.kickstart`](lang/source.kickstart.js) (mit) â€” [upstream](https://github.com/wgwoods/language-kickstart)
* [ ] [`source.koka`](lang/source.koka.js) (apache-2.0) â€” [upstream](https://github.com/koka-community/koka-textmate-grammar)
* [ ] [`source.kusto`](lang/source.kusto.js) (apache-2.0) â€” [upstream](https://github.com/mmanela/kusto-sublime)
* [ ] [`source.lark`](lang/source.lark.js) (isc) â€” [upstream](https://github.com/Alhadis/language-grammars)
* [ ] [`source.lean`](lang/source.lean.js) (apache-2.0) â€” [upstream](https://github.com/leanprover/vscode-lean)
* [ ] [`source.lean4`](lang/source.lean4.js) (apache-2.0) â€” [upstream](https://github.com/leanprover/vscode-lean4)
* [ ] [`source.leo`](lang/source.leo.js) (apache-2.0) â€” [upstream](https://github.com/ProvableHQ/leo-linguist)
* [ ] [`source.lex`](lang/source.lex.js) (isc) â€” [upstream](https://github.com/Alhadis/language-grammars) â€” needs: `source.c++`, `source.jflex`
* [ ] [`source.lex.regexp`](lang/source.lex.regexp.js) (isc) â€” [upstream](https://github.com/Alhadis/language-grammars)
* [ ] [`source.ligo`](lang/source.ligo.js) (mit) â€” [upstream](https://github.com/pewulfman/Ligo-grammar)
* [ ] [`source.lilypond`](lang/source.lilypond.js) (mit) â€” [upstream](https://github.com/nwhetsell/linter-lilypond) â€” needs: `source.lisp`
* [ ] [`source.lisp`](lang/source.lisp.js)
* [ ] [`source.litcoffee`](lang/source.litcoffee.js) (mit) â€” [upstream](https://github.com/atom/language-coffee-script) â€” needs: `source.coffee`, `text.html.basic`
* [ ] [`source.livecodescript`](lang/source.livecodescript.js) (bsd-3-clause) â€” [upstream](https://github.com/Ferruslogic/vscode-livecodescript)
* [ ] [`source.livescript`](lang/source.livescript.js) (apache-2.0) â€” [upstream](https://github.com/sharktide/livescript-vscode)
* [ ] [`source.llvm`](lang/source.llvm.js) (mit) â€” [upstream](https://github.com/whitequark/llvm.tmbundle)
* [ ] [`source.logos`](lang/source.logos.js) (mit) â€” [upstream](https://github.com/Cykey/Sublime-Logos) â€” needs: `source.c++`, `source.objc`
* [ ] [`source.logtalk`](lang/source.logtalk.js)
* [ ] [`source.lolcode`](lang/source.lolcode.js) (mit) â€” [upstream](https://github.com/KrazIvan/LOLCODE-grammar-vscode)
* [ ] [`source.loomscript`](lang/source.loomscript.js) (mit)
* [ ] [`source.lsl`](lang/source.lsl.js)
* [ ] [`source.ltspice.symbol`](lang/source.ltspice.symbol.js) (isc) â€” [upstream](https://github.com/Alhadis/language-pcb)
* [ ] [`source.luau`](lang/source.luau.js) (mit) â€” [upstream](https://github.com/JohnnyMorganz/Luau.tmLanguage)
* [ ] [`source.m2`](lang/source.m2.js) (mit) â€” [upstream](https://github.com/Macaulay2/language-macaulay2)
* [ ] [`source.m3u`](lang/source.m3u.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `etc`
* [ ] [`source.m4`](lang/source.m4.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `etc`
* [ ] [`source.m68k`](lang/source.m68k.js) (mit)
* [ ] [`source.mask`](lang/source.mask.js) (mit) â€” needs: `source.js`, `text.html.basic`
* [ ] [`source.mathematica`](lang/source.mathematica.js) (apache-2.0) â€” [upstream](https://github.com/shadanan/mathematica-tmbundle)
* [ ] [`source.matlab`](lang/source.matlab.js) (bsd-2-clause) â€” [upstream](https://github.com/mathworks/MATLAB-Language-grammar)
* [ ] [`source.maxscript`](lang/source.maxscript.js) (isc)
* [ ] [`source.mc`](lang/source.mc.js) (mit)
* [ ] [`source.mcfunction`](lang/source.mcfunction.js) (mit) â€” [upstream](https://github.com/MinecraftCommands/syntax-mcfunction)
* [ ] [`source.mdx`](lang/source.mdx.js) (mit) â€” [upstream](https://github.com/wooorm/markdown-tm-language) â€” needs: `source.tsx`
* [ ] [`source.mercury`](lang/source.mercury.js) (mit)
* [ ] [`source.mermaid`](lang/source.mermaid.js) (isc) â€” [upstream](https://github.com/Alhadis/language-mermaid) â€” needs: `source.mermaid.c4c-diagram`, `source.mermaid.class-diagram`, `source.mermaid.er-diagram`, `source.mermaid.flowchart`, `source.mermaid.gantt`, `source.mermaid.gitgraph`, `source.mermaid.mindmap`, `source.mermaid.pie-chart`, `source.mermaid.requirement-diagram`, `source.mermaid.sequence-diagram`, `source.mermaid.state-diagram`, `source.mermaid.user-journey`
* [ ] [`source.mermaid.c4c-diagram`](lang/source.mermaid.c4c-diagram.js) (isc) â€” [upstream](https://github.com/Alhadis/language-mermaid) â€” needs: `source.mermaid`, `source.mermaid.user-journey`, `source.wsd`
* [ ] [`source.mermaid.class-diagram`](lang/source.mermaid.class-diagram.js) (isc) â€” [upstream](https://github.com/Alhadis/language-mermaid) â€” needs: `source.mermaid`, `source.mermaid.flowchart`
* [ ] [`source.mermaid.er-diagram`](lang/source.mermaid.er-diagram.js) (isc) â€” [upstream](https://github.com/Alhadis/language-mermaid) â€” needs: `source.mermaid`
* [ ] [`source.mermaid.flowchart`](lang/source.mermaid.flowchart.js) (isc) â€” [upstream](https://github.com/Alhadis/language-mermaid) â€” needs: `source.mermaid`
* [ ] [`source.mermaid.gantt`](lang/source.mermaid.gantt.js) (isc) â€” [upstream](https://github.com/Alhadis/language-mermaid) â€” needs: `source.mermaid`, `source.mermaid.flowchart`
* [ ] [`source.mermaid.gitgraph`](lang/source.mermaid.gitgraph.js) (isc) â€” [upstream](https://github.com/Alhadis/language-mermaid) â€” needs: `source.json`, `source.mermaid`
* [ ] [`source.mermaid.mindmap`](lang/source.mermaid.mindmap.js) (isc) â€” [upstream](https://github.com/Alhadis/language-mermaid) â€” needs: `source.mermaid`, `source.mermaid.flowchart`
* [ ] [`source.mermaid.pie-chart`](lang/source.mermaid.pie-chart.js) (isc) â€” [upstream](https://github.com/Alhadis/language-mermaid) â€” needs: `source.mermaid`
* [ ] [`source.mermaid.requirement-diagram`](lang/source.mermaid.requirement-diagram.js) (isc) â€” [upstream](https://github.com/Alhadis/language-mermaid) â€” needs: `source.mermaid`
* [ ] [`source.mermaid.sequence-diagram`](lang/source.mermaid.sequence-diagram.js) (isc) â€” [upstream](https://github.com/Alhadis/language-mermaid) â€” needs: `source.json`, `source.mermaid`
* [ ] [`source.mermaid.state-diagram`](lang/source.mermaid.state-diagram.js) (isc) â€” [upstream](https://github.com/Alhadis/language-mermaid) â€” needs: `source.mermaid`
* [ ] [`source.mermaid.user-journey`](lang/source.mermaid.user-journey.js) (isc) â€” [upstream](https://github.com/Alhadis/language-mermaid) â€” needs: `source.mermaid`
* [ ] [`source.meson`](lang/source.meson.js) (apache-2.0) â€” [upstream](https://github.com/TingPing/language-meson)
* [ ] [`source.miniyaml`](lang/source.miniyaml.js) (mit) â€” [upstream](https://github.com/OpenRA/atom-miniyaml)
* [ ] [`source.mint`](lang/source.mint.js) (mit) â€” [upstream](https://github.com/mint-lang/mint-vscode) â€” needs: `source.css`, `source.css.scss`, `source.js`
* [ ] [`source.ml`](lang/source.ml.js) â€” [upstream](https://github.com/textmate/standard-ml.tmbundle)
* [ ] [`source.mligo`](lang/source.mligo.js) (mit) â€” [upstream](https://github.com/pewulfman/Ligo-grammar)
* [ ] [`source.mlir`](lang/source.mlir.js) (apache-2.0) â€” [upstream](https://github.com/jpienaar/mlir-grammar)
* [ ] [`source.mo`](lang/source.mo.js) (apache-2.0) â€” [upstream](https://github.com/dfinity/vscode-motoko)
* [ ] [`source.modelica`](lang/source.modelica.js) (mit) â€” [upstream](https://github.com/BorisChumichev/modelicaSublimeTextPackage)
* [ ] [`source.modula-3`](lang/source.modula-3.js) (bsd-3-clause) â€” [upstream](https://github.com/newgrammars/m3)
* [ ] [`source.modula2`](lang/source.modula2.js) (mit) â€” [upstream](https://github.com/harogaston/Sublime-Modula-2)
* [ ] [`source.mojo`](lang/source.mojo.js) (mit) â€” [upstream](https://github.com/modularml/mojo-syntax)
* [ ] [`source.monkey`](lang/source.monkey.js) (mit)
* [ ] [`source.moonbit`](lang/source.moonbit.js) (apache-2.0) â€” [upstream](https://github.com/moonbitlang/moonbit-tmLanguage)
* [ ] [`source.moonscript`](lang/source.moonscript.js) (mit)
* [ ] [`source.move`](lang/source.move.js) (mit) â€” [upstream](https://github.com/damirka/vscode-move-syntax)
* [ ] [`source.mql5`](lang/source.mql5.js) (mit)
* [ ] [`source.msg`](lang/source.msg.js) (mit) â€” [upstream](https://github.com/omnetpp/omnetpp-textmate-msg)
* [ ] [`source.msl`](lang/source.msl.js) (mit) â€” [upstream](https://github.com/gen-angry/language-msl)
* [ ] [`source.mupad`](lang/source.mupad.js) (mit) â€” [upstream](https://github.com/ccreutzig/sublime-MuPAD)
* [ ] [`source.mzn`](lang/source.mzn.js) (mpl-2.0) â€” [upstream](https://github.com/Dekker1/vscode-minizinc)
* [ ] [`source.nanorc`](lang/source.nanorc.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `etc`, `injections.etc`
* [ ] [`source.nasal`](lang/source.nasal.js) (mit) â€” [upstream](https://github.com/BobDotCom/Nasal.tmbundle)
* [ ] [`source.nasl`](lang/source.nasl.js) (mit) â€” [upstream](https://github.com/tenable/sublimetext-nasl)
* [ ] [`source.ncl`](lang/source.ncl.js) (mit)
* [ ] [`source.ne`](lang/source.ne.js) (unlicense) â€” [upstream](https://github.com/Hardmath123/sublime-nearley)
* [ ] [`source.ned`](lang/source.ned.js) (mit) â€” [upstream](https://github.com/omnetpp/omnetpp-textmate-ned)
* [ ] [`source.nemerle`](lang/source.nemerle.js)
* [ ] [`source.neon`](lang/source.neon.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc)
* [ ] [`source.nesc`](lang/source.nesc.js) (mit) â€” needs: `source.c`
* [ ] [`source.netlinx`](lang/source.netlinx.js) (mit)
* [ ] [`source.netlinx.erb`](lang/source.netlinx.erb.js) (mit) â€” needs: `source.netlinx`
* [ ] [`source.nextflow`](lang/source.nextflow.js) (mit) â€” needs: `source.nextflow-groovy`
* [ ] [`source.nextflow-groovy`](lang/source.nextflow-groovy.js) (mit)
* [ ] [`source.nginx`](lang/source.nginx.js) (mit) â€” [upstream](https://github.com/brandonwamboldt/sublime-nginx)
* [ ] [`source.nim`](lang/source.nim.js) (mit) â€” [upstream](https://github.com/nim-lang/NimLime)
* [ ] [`source.ninja`](lang/source.ninja.js) (mit)
* [ ] [`source.nit`](lang/source.nit.js) (wtfpl)
* [ ] [`source.nix`](lang/source.nix.js) (mit) â€” [upstream](https://github.com/sambacha/nix-linguist)
* [ ] [`source.nr`](lang/source.nr.js) (apache-2.0) â€” [upstream](https://github.com/noir-lang/vscode-noir)
* [ ] [`source.nsis`](lang/source.nsis.js) (apache-2.0)
* [ ] [`source.nu`](lang/source.nu.js) (apache-2.0)
* [ ] [`source.nunjucks`](lang/source.nunjucks.js) (mit)
* [ ] [`source.nushell`](lang/source.nushell.js) (mit) â€” [upstream](https://github.com/hustcer/nu-grammar)
* [ ] [`source.nut`](lang/source.nut.js) (mit)
* [ ] [`source.objc++`](lang/source.objc++.js) â€” needs: `source.c++`, `source.objc`
* [ ] [`source.objectscript`](lang/source.objectscript.js) (mit) â€” needs: `source.objectscript_macros`
* [ ] [`source.objectscript_macros`](lang/source.objectscript_macros.js) (mit) â€” needs: `source.objectscript`
* [ ] [`source.ocaml`](lang/source.ocaml.js) â€” needs: `source.camlp4.ocaml`
* [ ] [`source.odin`](lang/source.odin.js) (mit) â€” [upstream](https://github.com/odin-lang/sublime-odin)
* [ ] [`source.odin-ehr`](lang/source.odin-ehr.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `etc`
* [ ] [`source.ooc`](lang/source.ooc.js) (bsd-2-clause)
* [ ] [`source.opa`](lang/source.opa.js) (mit) â€” [upstream](https://github.com/mads379/opa.tmbundle)
* [ ] [`source.opal`](lang/source.opal.js) (mit) â€” [upstream](https://github.com/artifactz/sublime-opal)
* [ ] [`source.opentype`](lang/source.opentype.js) (isc) â€” [upstream](https://github.com/Alhadis/language-fontforge)
* [ ] [`source.opts`](lang/source.opts.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `etc`
* [ ] [`source.overpassql`](lang/source.overpassql.js) (mpl-2.0) â€” [upstream](https://github.com/nickswalker/overpassql-tmlanguage)
* [ ] [`source.ox`](lang/source.ox.js) (mit)
* [ ] [`source.oz`](lang/source.oz.js) (mit)
* [ ] [`source.p4`](lang/source.p4.js) (mit)
* [ ] [`source.pact`](lang/source.pact.js) (bsd-3-clause) â€” [upstream](https://github.com/kadena-io/pact-atom)
* [ ] [`source.pan`](lang/source.pan.js) (mit)
* [ ] [`source.papyrus.skyrim`](lang/source.papyrus.skyrim.js) (mit)
* [ ] [`source.parrot.pir`](lang/source.parrot.pir.js)
* [ ] [`source.pascal`](lang/source.pascal.js)
* [ ] [`source.pawn`](lang/source.pawn.js) (mit)
* [ ] [`source.pcb.board`](lang/source.pcb.board.js) (isc) â€” [upstream](https://github.com/Alhadis/language-pcb) â€” needs: `source.pcb.sexp`
* [ ] [`source.pcb.schematic`](lang/source.pcb.schematic.js) (isc) â€” [upstream](https://github.com/Alhadis/language-pcb) â€” needs: `source.pcb.sexp`, `source.scheme`
* [ ] [`source.pcb.sexp`](lang/source.pcb.sexp.js) (isc) â€” [upstream](https://github.com/Alhadis/language-pcb)
* [ ] [`source.pddl`](lang/source.pddl.js) (mit) â€” [upstream](https://github.com/jan-dolejsi/vscode-pddl)
* [ ] [`source.peggy`](lang/source.peggy.js) (mit) â€” [upstream](https://github.com/peggyjs/code-peggy-language) â€” needs: `source.js`
* [ ] [`source.pep8`](lang/source.pep8.js) (wtfpl)
* [ ] [`source.php.zephir`](lang/source.php.zephir.js) â€” [upstream](https://github.com/phalcon/zephir-sublime)
* [ ] [`source.pic`](lang/source.pic.js) (isc) â€” [upstream](https://github.com/Alhadis/language-roff) â€” needs: `source.shell`, `text.html.basic`, `text.roff`
* [ ] [`source.pig_latin`](lang/source.pig_latin.js) (mit)
* [ ] [`source.pike`](lang/source.pike.js) (unlicense)
* [ ] [`source.pip-requirements`](lang/source.pip-requirements.js) (mit) â€” [upstream](https://github.com/microsoft/vscode-python)
* [ ] [`source.pkl`](lang/source.pkl.js) (apache-2.0) â€” [upstream](https://github.com/apple/pkl.tmbundle)
* [ ] [`source.plist`](lang/source.plist.js) (mit) â€” [upstream](https://github.com/atom/language-property-list)
* [ ] [`source.po`](lang/source.po.js)
* [ ] [`source.pogoscript`](lang/source.pogoscript.js) (mit)
* [ ] [`source.polar`](lang/source.polar.js) (apache-2.0) â€” [upstream](https://github.com/osohq/polar-grammar)
* [ ] [`source.pony`](lang/source.pony.js) (bsd-2-clause) â€” [upstream](https://github.com/CausalityLtd/sublime-pony)
* [ ] [`source.portugol`](lang/source.portugol.js) (mit) â€” [upstream](https://github.com/luisgbr1el/portugol-grammar)
* [ ] [`source.postcss`](lang/source.postcss.js) (mit)
* [ ] [`source.postscript`](lang/source.postscript.js) (isc) â€” [upstream](https://github.com/Alhadis/Atom-PostScript)
* [ ] [`source.pov-ray sdl`](<lang/source.pov-ray sdl.js>) (mit)
* [ ] [`source.powerbuilder`](lang/source.powerbuilder.js) (mit) â€” [upstream](https://github.com/informaticon/PowerBuilder.tmbundle)
* [ ] [`source.powershell`](lang/source.powershell.js) (mit) â€” [upstream](https://github.com/PowerShell/EditorSyntax)
* [ ] [`source.praat`](lang/source.praat.js) (mit) â€” [upstream](https://github.com/orhunulusahin/praatvscode)
* [ ] [`source.prisma`](lang/source.prisma.js) (apache-2.0) â€” [upstream](https://github.com/prisma/vscode-prisma)
* [ ] [`source.processing`](lang/source.processing.js)
* [ ] [`source.procfile`](lang/source.procfile.js) (bsd-3-clause) â€” [upstream](https://github.com/benspaulding/vscode-procfile) â€” needs: `source.shell`
* [ ] [`source.prolog`](lang/source.prolog.js) (mpl-2.0)
* [ ] [`source.prolog.eclipse`](lang/source.prolog.eclipse.js) (mpl-2.0) â€” needs: `source.prolog`
* [ ] [`source.promela`](lang/source.promela.js) (mit) â€” [upstream](https://github.com/corbanmailloux/sublime-promela-spin)
* [ ] [`source.proto`](lang/source.proto.js) (mit) â€” [upstream](https://github.com/zxh0/vscode-proto3)
* [ ] [`source.puppet`](lang/source.puppet.js) (mit) â€” [upstream](https://github.com/russCloak/SublimePuppet)
* [ ] [`source.purescript`](lang/source.purescript.js) (mit) â€” [upstream](https://github.com/purescript-contrib/atom-language-purescript)
* [ ] [`source.python.kivy`](lang/source.python.kivy.js) (mit) â€” [upstream](https://github.com/p0lygun/kivy-language-grammer) â€” needs: `source.python`
* [ ] [`source.q`](lang/source.q.js) (mit) â€” [upstream](https://github.com/komsit37/sublime-q)
* [ ] [`source.qasm`](lang/source.qasm.js) (mit)
* [ ] [`source.QB64`](lang/source.QB64.js) (mit) â€” [upstream](https://github.com/QB64Official/vscode)
* [ ] [`source.ql`](lang/source.ql.js) (mit) â€” [upstream](https://github.com/github/vscode-codeql)
* [ ] [`source.qmake`](lang/source.qmake.js)
* [ ] [`source.qml`](lang/source.qml.js) (mit) â€” needs: `source.js`
* [ ] [`source.qsharp`](lang/source.qsharp.js) (mit) â€” [upstream](https://github.com/microsoft/qsharp)
* [ ] [`source.quake`](lang/source.quake.js) (bsd-3-clause)
* [ ] [`source.quoting.raku`](lang/source.quoting.raku.js) â€” [upstream](https://github.com/perl6/atom-language-perl6) â€” needs: `source.raku`
* [ ] [`source.racket`](lang/source.racket.js) (mit)
* [ ] [`source.raku`](lang/source.raku.js) â€” [upstream](https://github.com/perl6/atom-language-perl6) â€” needs: `source.quoting.raku`
* [ ] [`source.rascal`](lang/source.rascal.js) (bsd-2-clause) â€” [upstream](https://github.com/usethesource/rascal-syntax-highlighting)
* [ ] [`source.rbs`](lang/source.rbs.js) (mit) â€” [upstream](https://github.com/soutaro/vscode-rbs-syntax)
* [ ] [`source.reason`](lang/source.reason.js) (mit) â€” [upstream](https://github.com/reasonml-editor/language-reason)
* [ ] [`source.rebol`](lang/source.rebol.js) (mit) â€” [upstream](https://github.com/Oldes/Sublime-REBOL)
* [ ] [`source.record-jar`](lang/source.record-jar.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `etc`
* [ ] [`source.red`](lang/source.red.js) (mit) â€” [upstream](https://github.com/Oldes/Sublime-Red)
* [ ] [`source.redirects`](lang/source.redirects.js) (isc) â€” [upstream](https://github.com/Nixinova/NovaGrammars)
* [ ] [`source.reg`](lang/source.reg.js) (mit)
* [ ] [`source.regexp`](lang/source.regexp.js) (isc) â€” [upstream](https://github.com/Alhadis/language-regexp) â€” needs: `source.regexp.extended`, `source.regexp.posix`, `source.sy`
* [ ] [`source.regexp.extended`](lang/source.regexp.extended.js) (isc) â€” [upstream](https://github.com/Alhadis/language-regexp) â€” needs: `source.regexp`
* [ ] [`source.regexp.posix`](lang/source.regexp.posix.js) (isc) â€” [upstream](https://github.com/Alhadis/language-regexp) â€” needs: `source.regexp`
* [ ] [`source.regexp.python`](lang/source.regexp.python.js) (mit) â€” [upstream](https://github.com/MagicStack/MagicPython)
* [ ] [`source.rego`](lang/source.rego.js) (apache-2.0) â€” [upstream](https://github.com/open-policy-agent/vscode-opa)
* [ ] [`source.religo`](lang/source.religo.js) (mit) â€” [upstream](https://github.com/pewulfman/Ligo-grammar)
* [ ] [`source.renpy`](lang/source.renpy.js) (mit) â€” [upstream](https://github.com/williamd1k0/language-renpy) â€” needs: `source.regexp.python`
* [ ] [`source.rescript`](lang/source.rescript.js) (mit) â€” [upstream](https://github.com/rescript-lang/rescript-vscode)
* [ ] [`source.rexx`](lang/source.rexx.js) (mit) â€” [upstream](https://github.com/mblocker/rexx-sublime)
* [ ] [`source.rez`](lang/source.rez.js) â€” [upstream](https://github.com/textmate/rez.tmbundle)
* [ ] [`source.ring`](lang/source.ring.js) (mit)
* [ ] [`source.roc`](lang/source.roc.js) (mit) â€” [upstream](https://github.com/ivan-demchenko/roc-vscode-unofficial)
* [ ] [`source.ron`](lang/source.ron.js) (mit) â€” [upstream](https://github.com/a5huynh/vscode-ron)
* [ ] [`source.rpgle`](lang/source.rpgle.js) (mit) â€” [upstream](https://github.com/barrettotte/vscode-ibmi-languages) â€” needs: `source.sql`
* [ ] [`source.rpm-spec`](lang/source.rpm-spec.js) (mit) â€” needs: `source.changelogs.rpm-spec`, `source.shell`
* [ ] [`source.sail`](lang/source.sail.js) (mit) â€” [upstream](https://github.com/Timmmm/sail_vscode)
* [ ] [`source.sas`](lang/source.sas.js) (mit) â€” [upstream](https://github.com/rpardee/sas.tmbundle)
* [ ] [`source.sass`](lang/source.sass.js) (mit) â€” [upstream](https://github.com/atom/language-sass) â€” needs: `source.css`
* [ ] [`source.scad`](lang/source.scad.js) (mit) â€” [upstream](https://github.com/tbuser/openscad.tmbundle)
* [ ] [`source.scala`](lang/source.scala.js) (mit) â€” [upstream](https://github.com/scala/vscode-scala-syntax)
* [ ] [`source.scaml`](lang/source.scaml.js) (apache-2.0) â€” [upstream](https://github.com/scalate/Scalate.tmbundle) â€” needs: `source.scala`
* [ ] [`source.scenic`](lang/source.scenic.js) (mit) â€” [upstream](https://github.com/UCSCFormalMethods/Scenic-tmLanguage)
* [ ] [`source.scheme`](lang/source.scheme.js)
* [ ] [`source.scilab`](lang/source.scilab.js)
* [ ] [`source.scm`](lang/source.scm.js) (mit) â€” [upstream](https://github.com/jrieken/vscode-tree-sitter-query)
* [ ] [`source.sdbl`](lang/source.sdbl.js) (mit) â€” [upstream](https://github.com/1c-syntax/vsc-language-1c-bsl)
* [ ] [`source.sed`](lang/source.sed.js) (isc) â€” [upstream](https://github.com/Alhadis/language-sed)
* [ ] [`source.sepolicy`](lang/source.sepolicy.js) (apache-2.0) â€” [upstream](https://github.com/google/selinux-policy-languages)
* [ ] [`source.sfv`](lang/source.sfv.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc)
* [ ] [`source.shaderlab`](lang/source.shaderlab.js) (mit)
* [ ] [`source.shellcheckrc`](lang/source.shellcheckrc.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `etc`
* [ ] [`source.shen`](lang/source.shen.js) (bsd-3-clause)
* [ ] [`source.sieve`](lang/source.sieve.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc)
* [ ] [`source.singularity`](lang/source.singularity.js) (mit) â€” [upstream](https://github.com/onnovalkering/vscode-singularity)
* [ ] [`source.slang`](lang/source.slang.js) (apache-2.0) â€” [upstream](https://github.com/shader-slang/slang-vscode-extension)
* [ ] [`source.slint`](lang/source.slint.js) (mit) â€” [upstream](https://github.com/slint-ui/slint-tmLanguage)
* [ ] [`source.smali`](lang/source.smali.js) (mit) â€” [upstream](https://github.com/ShaneWilton/sublime-smali)
* [ ] [`source.smalltalk`](lang/source.smalltalk.js) (mit)
* [ ] [`source.smithy`](lang/source.smithy.js) (apache-2.0) â€” [upstream](https://github.com/awslabs/smithy-vscode)
* [ ] [`source.smpl`](lang/source.smpl.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `etc`
* [ ] [`source.smt`](lang/source.smt.js) (unlicense)
* [ ] [`source.solidity`](lang/source.solidity.js) (mit) â€” [upstream](https://github.com/davidhq/SublimeEthereum)
* [ ] [`source.solution`](lang/source.solution.js) (isc) â€” [upstream](https://github.com/Nixinova/NovaGrammars)
* [ ] [`source.sourcepawn`](lang/source.sourcepawn.js) (mit) â€” [upstream](https://github.com/Sarrus1/sourcepawn-vscode)
* [ ] [`source.sparql`](lang/source.sparql.js) (mit) â€” [upstream](https://github.com/peta/turtle.tmbundle) â€” needs: `source.turtle`
* [ ] [`source.spin`](lang/source.spin.js) (zlib) â€” [upstream](https://github.com/bitbased/sublime-spintools)
* [ ] [`source.sqf`](lang/source.sqf.js) (apache-2.0) â€” [upstream](https://github.com/JonBons/Sublime-SQF-Language)
* [ ] [`source.ssh-config`](lang/source.ssh-config.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc)
* [ ] [`source.stan`](lang/source.stan.js) (mit) â€” [upstream](https://github.com/stan-dev/atom-language-stan)
* [ ] [`source.star`](lang/source.star.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc)
* [ ] [`source.stata`](lang/source.stata.js) (mit) â€” [upstream](https://github.com/pschumm/Stata.tmbundle)
* [ ] [`source.stl`](lang/source.stl.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `etc`
* [ ] [`source.string-template`](lang/source.string-template.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `etc`
* [ ] [`source.stylus`](lang/source.stylus.js) (mit)
* [ ] [`source.supercollider`](lang/source.supercollider.js) (mit) â€” [upstream](https://github.com/supercollider/language-supercollider)
* [ ] [`source.svelte`](lang/source.svelte.js) (mit) â€” [upstream](https://github.com/sebastinez/svelte-atom) â€” needs: `source.css`, `source.js`, `source.ts`
* [ ] [`source.sway`](lang/source.sway.js) (apache-2.0) â€” [upstream](https://github.com/FuelLabs/sway-vscode-plugin)
* [ ] [`source.sy`](lang/source.sy.js) (isc) â€” [upstream](https://github.com/Alhadis/language-regexp) â€” needs: `source.regexp`
* [ ] [`source.systemverilog`](lang/source.systemverilog.js) (apache-2.0) â€” [upstream](https://github.com/TheClams/SystemVerilog)
* [ ] [`source.tact`](lang/source.tact.js) (mit) â€” [upstream](https://github.com/tact-lang/tact-sublime)
* [ ] [`source.talon`](lang/source.talon.js) (mit) â€” [upstream](https://github.com/mrob95/vscode-TalonScript)
* [ ] [`source.tcl`](lang/source.tcl.js)
* [ ] [`source.tea`](lang/source.tea.js) (apache-2.0) â€” needs: `source.js`, `text.html.basic`, `text.xml`
* [ ] [`source.templ`](lang/source.templ.js) (mit) â€” [upstream](https://github.com/templ-go/templ-vscode) â€” needs: `source.go`
* [ ] [`source.terra`](lang/source.terra.js) (bsd-3-clause)
* [ ] [`source.textgrid`](lang/source.textgrid.js) (mit) â€” [upstream](https://github.com/orhunulusahin/praatvscode)
* [ ] [`source.textproto`](lang/source.textproto.js) (mit) â€” [upstream](https://github.com/thejustinwalsh/textproto-grammar)
* [ ] [`source.thrift`](lang/source.thrift.js)
* [ ] [`source.tl`](lang/source.tl.js) (mit)
* [ ] [`source.tla`](lang/source.tla.js) (mit)
* [ ] [`source.tlverilog`](lang/source.tlverilog.js) (mit) â€” [upstream](https://github.com/adamint/tlv-vscode)
* [ ] [`source.tm-properties`](lang/source.tm-properties.js) â€” [upstream](https://github.com/textmate/textmate.tmbundle)
* [ ] [`source.toc`](lang/source.toc.js) (unlicense) â€” [upstream](https://github.com/nebularg/language-toc-wow)
* [ ] [`source.toit`](lang/source.toit.js) (mit) â€” [upstream](https://github.com/toitware/ide-tools)
* [ ] [`source.toml`](lang/source.toml.js) â€” [upstream](https://github.com/textmate/toml.tmbundle)
* [ ] [`source.torrc`](lang/source.torrc.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `etc`, `source.hosts`
* [ ] [`source.tsp`](lang/source.tsp.js) (mit) â€” [upstream](https://github.com/microsoft/typespec)
* [ ] [`source.tsql`](lang/source.tsql.js) (mit) â€” [upstream](https://github.com/beau-witter/language-tsql)
* [ ] [`source.tsx`](lang/source.tsx.js) (mit) â€” [upstream](https://github.com/Microsoft/TypeScript-TmLanguage)
* [ ] [`source.turing`](lang/source.turing.js) (isc) â€” [upstream](https://github.com/Alhadis/language-turing)
* [ ] [`source.turtle`](lang/source.turtle.js) (mit) â€” [upstream](https://github.com/peta/turtle.tmbundle)
* [ ] [`source.txl`](lang/source.txl.js) (apache-2.0) â€” [upstream](https://github.com/MikeHoffert/Sublime-Text-TXL-syntax)
* [ ] [`source.typst`](lang/source.typst.js) (apache-2.0) â€” [upstream](https://github.com/michidk/typst-grammar)
* [ ] [`source.uplc`](lang/source.uplc.js) (apache-2.0) â€” [upstream](https://github.com/aiken-lang/vscode-aiken)
* [ ] [`source.ur`](lang/source.ur.js) (mit)
* [ ] [`source.v`](lang/source.v.js) (mit) â€” [upstream](https://github.com/0x9ef/vscode-vlang)
* [ ] [`source.vala`](lang/source.vala.js) (mit) â€” [upstream](https://github.com/technosophos/Vala-TMBundle)
* [ ] [`source.varnish.vcl`](lang/source.varnish.vcl.js) (mit) â€” [upstream](https://github.com/brandonwamboldt/sublime-varnish)
* [ ] [`source.vba`](lang/source.vba.js) (mpl-2.0) â€” [upstream](https://github.com/serkonda7/vscode-vba)
* [ ] [`source.vcard`](lang/source.vcard.js) (mit) â€” [upstream](https://github.com/cstrachan88/vscode-vcard)
* [ ] [`source.velocity`](lang/source.velocity.js) (mit) â€” [upstream](https://github.com/animecyc/AtomLanguageVelocity)
* [ ] [`source.vento`](lang/source.vento.js) (mit) â€” [upstream](https://github.com/ventojs/vscode-vento) â€” needs: `source.js`
* [ ] [`source.verilog`](lang/source.verilog.js)
* [ ] [`source.vhdl`](lang/source.vhdl.js)
* [ ] [`source.vim-snippet`](lang/source.vim-snippet.js) (mit) â€” [upstream](https://github.com/Alhadis/language-viml)
* [ ] [`source.viml`](lang/source.viml.js) (mit) â€” [upstream](https://github.com/Alhadis/language-viml)
* [ ] [`source.vue`](lang/source.vue.js) (mit) â€” [upstream](https://github.com/vuejs/language-tools) â€” needs: `source.css`, `text.html.basic`
* [ ] [`source.vyper`](lang/source.vyper.js) (mit) â€” [upstream](https://github.com/davidhq/SublimeEthereum)
* [ ] [`source.wavefront.mtl`](lang/source.wavefront.mtl.js) (isc) â€” [upstream](https://github.com/Alhadis/language-wavefront)
* [ ] [`source.wavefront.obj`](lang/source.wavefront.obj.js) (isc) â€” [upstream](https://github.com/Alhadis/language-wavefront)
* [ ] [`source.wdl`](lang/source.wdl.js) (apache-2.0) â€” [upstream](https://github.com/stjude-rust-labs/sprocket-vscode)
* [ ] [`source.webassembly`](lang/source.webassembly.js) (isc) â€” [upstream](https://github.com/Alhadis/language-webassembly)
* [ ] [`source.webidl`](lang/source.webidl.js) (mit) â€” [upstream](https://github.com/andik/IDL-Syntax)
* [ ] [`source.wgetrc`](lang/source.wgetrc.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `etc`
* [ ] [`source.wgsl`](lang/source.wgsl.js) (mit) â€” [upstream](https://github.com/wgsl-analyzer/wgsl-analyzer)
* [ ] [`source.whiley`](lang/source.whiley.js) (apache-2.0) â€” [upstream](https://github.com/Whiley/WhileySyntaxBundle)
* [ ] [`source.win32-messages`](lang/source.win32-messages.js) (isc) â€” [upstream](https://github.com/Nixinova/NovaGrammars)
* [ ] [`source.wit`](lang/source.wit.js) (apache-2.0) â€” [upstream](https://github.com/bytecodealliance/vscode-wit)
* [ ] [`source.witcherscript`](lang/source.witcherscript.js) (mit) â€” [upstream](https://github.com/ADawesomeguy/witcherscript-grammar)
* [ ] [`source.wollok`](lang/source.wollok.js) (mit)
* [ ] [`source.wren`](lang/source.wren.js) (mit) â€” [upstream](https://github.com/Nelarius/vscode-wren)
* [ ] [`source.wsd`](lang/source.wsd.js) (mit) â€” [upstream](https://github.com/qjebbs/vscode-plantuml)
* [ ] [`source.x10`](lang/source.x10.js) (apache-2.0)
* [ ] [`source.x86`](lang/source.x86.js) (mit) â€” [upstream](https://github.com/calculuswhiz/Assembly-Syntax-Definition)
* [ ] [`source.xc`](lang/source.xc.js) â€” needs: `source.c`
* [ ] [`source.xlfd`](lang/source.xlfd.js) (isc) â€” [upstream](https://github.com/Alhadis/language-fontforge)
* [ ] [`source.xmake`](lang/source.xmake.js) (mit) â€” [upstream](https://github.com/xmake-io/xmake-lua.tmbundle)
* [ ] [`source.xojo`](lang/source.xojo.js) (apache-2.0) â€” [upstream](https://github.com/jimmckay/XojoSyntaxTM)
* [ ] [`source.xq`](lang/source.xq.js) (apache-2.0) â€” [upstream](https://github.com/wcandillon/language-jsoniq)
* [ ] [`source.xtend`](lang/source.xtend.js) (mit)
* [ ] [`source.yacc`](lang/source.yacc.js) (isc) â€” [upstream](https://github.com/Alhadis/language-grammars) â€” needs: `source.c++`, `source.java`
* [ ] [`source.yaml.salt`](lang/source.yaml.salt.js) (mit) â€” [upstream](https://github.com/saltstack/atom-salt) â€” needs: `source.python`
* [ ] [`source.yang`](lang/source.yang.js) (mit)
* [ ] [`source.yara`](lang/source.yara.js) (mit) â€” [upstream](https://github.com/infosec-intern/vscode-yara)
* [ ] [`source.yasnippet`](lang/source.yasnippet.js) (isc) â€” [upstream](https://github.com/Alhadis/language-emacs-lisp) â€” needs: `source.emacs.lisp`
* [ ] [`source.yul`](lang/source.yul.js) (mit) â€” [upstream](https://github.com/davidhq/SublimeEthereum)
* [ ] [`source.zap`](lang/source.zap.js)
* [ ] [`source.zeek`](lang/source.zeek.js) (bsd-3-clause) â€” [upstream](https://github.com/zeek/zeek-sublime)
* [ ] [`source.zenscript`](lang/source.zenscript.js) (mit) â€” [upstream](https://github.com/CraftTweaker/ZenScript-tmLanguage)
* [ ] [`source.zig`](lang/source.zig.js) (mit) â€” [upstream](https://github.com/ziglang/sublime-zig-language)
* [ ] [`source.zil`](lang/source.zil.js)
* [ ] [`source.zmodel`](lang/source.zmodel.js) (mit) â€” [upstream](https://github.com/zenstackhq/zenstack)
* [ ] [`text.adblock`](lang/text.adblock.js) (mit) â€” [upstream](https://github.com/AdguardTeam/VscodeAdblockSyntax)
* [ ] [`text.bibtex`](lang/text.bibtex.js) â€” [upstream](https://github.com/textmate/latex.tmbundle)
* [ ] [`text.browserslist`](lang/text.browserslist.js) (mit) â€” [upstream](https://github.com/browserslist/browserslist-vscode)
* [ ] [`text.cfml.basic`](lang/text.cfml.basic.js) (mit)
* [ ] [`text.checksums`](lang/text.checksums.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `etc`
* [ ] [`text.codeowners`](lang/text.codeowners.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `etc`
* [ ] [`text.conllu`](lang/text.conllu.js) (apache-2.0)
* [ ] [`text.crontab`](lang/text.crontab.js)
* [ ] [`text.dfy.dafny`](lang/text.dfy.dafny.js) (mit) â€” [upstream](https://github.com/DafnyVSCode/Dafny-VSCode)
* [ ] [`text.elixir`](lang/text.elixir.js) (apache-2.0) â€” [upstream](https://github.com/elixir-lang/elixir-tmbundle) â€” needs: `source.elixir`
* [ ] [`text.eml.basic`](lang/text.eml.basic.js) (mit) â€” [upstream](https://github.com/mariozaizar/language-eml)
* [ ] [`text.gherkin.feature`](lang/text.gherkin.feature.js) (mit) â€” [upstream](https://github.com/cucumber/cucumber-tmbundle)
* [ ] [`text.grammarkdown`](lang/text.grammarkdown.js) (isc) â€” [upstream](https://github.com/Alhadis/language-grammars)
* [ ] [`text.haml`](lang/text.haml.js) (mit) â€” needs: `source.ruby`
* [ ] [`text.html.asciidoc`](lang/text.html.asciidoc.js) (mit) â€” [upstream](https://github.com/zuckschwerdt/asciidoc.tmbundle) â€” needs: `text.html.basic`
* [ ] [`text.html.asdoc`](lang/text.html.asdoc.js) (mit) â€” [upstream](https://github.com/simongregory/actionscript3-tmbundle) â€” needs: `text.html.basic`
* [ ] [`text.html.asp`](lang/text.html.asp.js) â€” needs: `source.asp`, `text.html.basic`
* [ ] [`text.html.cfm`](lang/text.html.cfm.js) (mit) â€” needs: `source.cfscript`, `text.cfml.basic`
* [ ] [`text.html.creole`](lang/text.html.creole.js) (mit) â€” [upstream](https://github.com/Siddley/Creole) â€” needs: `text.html.basic`
* [ ] [`text.html.cshtml`](lang/text.html.cshtml.js) (mit) â€” [upstream](https://github.com/github-linguist/razor-plus) â€” needs: `source.cs`, `text.html.basic`
* [ ] [`text.html.django`](lang/text.html.django.js) â€” needs: `text.html.basic`
* [ ] [`text.html.ecmarkup`](lang/text.html.ecmarkup.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `etc`, `source.yaml`, `text.grammarkdown`, `text.html.basic`
* [ ] [`text.html.ecr`](lang/text.html.ecr.js) (mit) â€” [upstream](https://github.com/atom-crystal/language-crystal) â€” needs: `source.crystal`, `text.html.basic`
* [ ] [`text.html.edge`](lang/text.html.edge.js) (mit) â€” [upstream](https://github.com/edge-js/edge-vscode)
* [ ] [`text.html.elixir`](lang/text.html.elixir.js) (apache-2.0) â€” [upstream](https://github.com/elixir-lang/elixir-tmbundle) â€” needs: `text.elixir`, `text.html.basic`
* [ ] [`text.html.erb`](lang/text.html.erb.js) (mit) â€” [upstream](https://github.com/atom/language-ruby) â€” needs: `source.ruby`, `text.html.basic`
* [ ] [`text.html.ftl`](lang/text.html.ftl.js) (mit) â€” needs: `text.html.basic`
* [ ] [`text.html.handlebars`](lang/text.html.handlebars.js) (mit) â€” [upstream](https://github.com/daaain/Handlebars) â€” needs: `text.html.basic`
* [ ] [`text.html.javadoc`](lang/text.html.javadoc.js)
* [ ] [`text.html.js`](lang/text.html.js.js) (mit) â€” needs: `text.html.basic`
* [ ] [`text.html.jsp`](lang/text.html.jsp.js) â€” [upstream](https://github.com/textmate/java.tmbundle) â€” needs: `text.html.basic`
* [ ] [`text.html.jte`](lang/text.html.jte.js) (apache-2.0) â€” [upstream](https://github.com/maj2c/jte-template-syntax-highlight) â€” needs: `source.java`, `text.html.basic`
* [ ] [`text.html.liquid`](lang/text.html.liquid.js) (mit) â€” [upstream](https://github.com/Shopify/liquid-tm-grammar) â€” needs: `text.html.basic`
* [ ] [`text.html.mako`](lang/text.html.mako.js) (mit) â€” needs: `text.html.basic`
* [ ] [`text.html.markdown.source.gfm.apib`](lang/text.html.markdown.source.gfm.apib.js) (mit) â€” [upstream](https://github.com/apiaryio/api-blueprint-sublime-plugin) â€” needs: `source.js`, `text.html.markdown.source.gfm.mson`
* [ ] [`text.html.markdown.source.gfm.mson`](lang/text.html.markdown.source.gfm.mson.js) (mit) â€” [upstream](https://github.com/apiaryio/api-blueprint-sublime-plugin)
* [ ] [`text.html.mediawiki`](lang/text.html.mediawiki.js)
* [ ] [`text.html.nunjucks`](lang/text.html.nunjucks.js) (mit) â€” needs: `source.nunjucks`, `text.html.basic`
* [ ] [`text.html.php.blade`](lang/text.html.php.blade.js) (mit) â€” needs: `text.html.basic`
* [ ] [`text.html.riot`](lang/text.html.riot.js) (mit)
* [ ] [`text.html.slash`](lang/text.html.slash.js) (mit) â€” needs: `text.html.basic`
* [ ] [`text.html.smarty`](lang/text.html.smarty.js) â€” needs: `text.html.basic`
* [ ] [`text.html.soy`](lang/text.html.soy.js) (mit) â€” needs: `text.html.basic`
* [ ] [`text.html.statamic`](lang/text.html.statamic.js) (mit) â€” [upstream](https://github.com/Stillat/vscode-antlers-language-server) â€” needs: `text.html.basic`
* [ ] [`text.html.twig`](lang/text.html.twig.js) (bsd-3-clause) â€” [upstream](https://github.com/Anomareh/PHP-Twig.tmbundle)
* [ ] [`text.jade`](lang/text.jade.js) (mit) â€” needs: `source.js`, `text.html.basic`
* [ ] [`text.marko`](lang/text.marko.js) (mit) â€” [upstream](https://github.com/marko-js/marko-tmbundle) â€” needs: `source.js`
* [ ] [`text.muse`](lang/text.muse.js) (isc) â€” [upstream](https://github.com/Alhadis/language-emacs-lisp)
* [ ] [`text.python.console`](lang/text.python.console.js) (mit) â€” [upstream](https://github.com/MagicStack/MagicPython) â€” needs: `source.python`
* [ ] [`text.python.traceback`](lang/text.python.traceback.js) (mit) â€” [upstream](https://github.com/MagicStack/MagicPython) â€” needs: `source.python`
* [ ] [`text.rdoc`](lang/text.rdoc.js) (mit)
* [ ] [`text.restructuredtext`](lang/text.restructuredtext.js) (mit) â€” [upstream](https://github.com/Lukasa/language-restructuredtext)
* [ ] [`text.robot`](lang/text.robot.js) (apache-2.0) â€” [upstream](https://github.com/shellderp/sublime-robot-plugin)
* [ ] [`text.robots-txt`](lang/text.robots-txt.js) (isc) â€” [upstream](https://github.com/Nixinova/NovaGrammars)
* [ ] [`text.roff`](lang/text.roff.js) (isc) â€” [upstream](https://github.com/Alhadis/language-roff) â€” needs: `source.ditroff`, `source.gremlin`, `source.ideal`, `source.pic`
* [ ] [`text.rtf`](lang/text.rtf.js) (mit) â€” [upstream](https://github.com/nwhetsell/language-rtf)
* [ ] [`text.runoff`](lang/text.runoff.js) (isc) â€” [upstream](https://github.com/Alhadis/language-roff)
* [ ] [`text.sfd`](lang/text.sfd.js) (isc) â€” [upstream](https://github.com/Alhadis/language-fontforge) â€” needs: `source.fontforge`
* [ ] [`text.shell-session`](lang/text.shell-session.js) (mit) â€” [upstream](https://github.com/atom/language-shellscript) â€” needs: `source.shell`
* [ ] [`text.slim`](lang/text.slim.js) (mit) â€” needs: `text.html.basic`
* [ ] [`text.srt`](lang/text.srt.js) (isc) â€” [upstream](https://github.com/Alhadis/language-subtitles) â€” needs: `text.html.basic`
* [ ] [`text.tex`](lang/text.tex.js) â€” [upstream](https://github.com/textmate/latex.tmbundle) â€” needs: `source.r`
* [ ] [`text.tex.latex`](lang/text.tex.latex.js) â€” [upstream](https://github.com/textmate/latex.tmbundle) â€” needs: `text.tex`
* [ ] [`text.tex.latex.haskell`](lang/text.tex.latex.haskell.js) (mit) â€” [upstream](https://github.com/atom-haskell/language-haskell) â€” needs: `source.haskell`, `text.tex.latex`
* [ ] [`text.tex.latex.sweave`](lang/text.tex.latex.sweave.js) â€” [upstream](https://github.com/textmate/sweave.tmbundle) â€” needs: `source.r`, `text.tex.latex`
* [ ] [`text.texinfo`](lang/text.texinfo.js) (isc) â€” [upstream](https://github.com/Alhadis/language-texinfo)
* [ ] [`text.vim-help`](lang/text.vim-help.js) (mit) â€” [upstream](https://github.com/Alhadis/language-viml) â€” needs: `source.viml`
* [ ] [`text.vtt`](lang/text.vtt.js) (isc) â€” [upstream](https://github.com/Alhadis/language-subtitles) â€” needs: `text.html.basic`
* [ ] [`text.xml.ant`](lang/text.xml.ant.js) (mit) â€” needs: `text.xml`
* [ ] [`text.xml.plist`](lang/text.xml.plist.js) (mit) â€” [upstream](https://github.com/atom/language-property-list) â€” needs: `text.xml`
* [ ] [`text.xml.pom`](lang/text.xml.pom.js) â€” needs: `source.groovy`, `text.xml`
* [ ] [`text.xml.xsl`](lang/text.xml.xsl.js) â€” needs: `text.xml`
* [ ] [`text.zone_file`](lang/text.zone_file.js) (mit) â€” [upstream](https://github.com/sixty4k/st2-zonefile)

<!--support end-->

## Compatibility

This project is compatible with maintained versions of Node.js.

When we cut a new major release,
we drop support for unmaintained versions of Node.
This means we try to keep the current release line,
`wooorm@starry-night@3`,
compatible with Node.js 16.

You can pass your own TextMate grammars,
provided that they work with
[`vscode-textmate`][github-vscode-textmate],
and that they have the added fields `extensions`,
`names`,
and `scopeName`
(see types for the definitions and the grammars in `lang/` for examples).

## Security

This package is safe.

## Related

* [`lowlight`][github-lowlight]
  â€” similar but based on `highlight.js`
* [`refractor`][github-refractor]
  â€” similar but based on `Prism`

## Contribute

Yes please!
See [How to Contribute to Open Source][opensource-guide-contribute].

## License

The grammars included in this package are covered by their repositoriesâ€™
respective licenses,
which are permissive
(`apache-2.0`, `mit`, etc),
and made available in [`notice`][file-notice].

All other files [MIT][file-license] Â© [Titus Wormer][wooorm]

<br>

[![](media/slice-3.jpg)][artsandculture-google-starry-night]

<!-- Definitions -->

[api-all]: #all

[api-common]: #common

[api-create-starry-night]: #createstarrynightgrammars-options

[api-get-oniguruma-url]: #getonigurumaurl

[api-grammar]: #grammar

[api-options]: #options

[artsandculture-google-starry-night]: https://artsandculture.google.com/asset/the-starry-night/bgEuwDxel93-Pg

[badge-build-image]: https://github.com/wooorm/starry-night/workflows/main/badge.svg

[badge-build-url]: https://github.com/wooorm/starry-night/actions

[badge-coverage-image]: https://img.shields.io/codecov/c/github/wooorm/starry-night.svg

[badge-coverage-url]: https://codecov.io/github/wooorm/starry-night

[badge-downloads-image]: https://img.shields.io/npm/dm/@wooorm/starry-night.svg

[badge-downloads-url]: https://www.npmjs.com/package/@wooorm/starry-night

[badge-size-image]: https://img.shields.io/bundlejs/size/@wooorm/starry-night?exports=createStarryNight

[badge-size-url]: https://bundlejs.com/?q=@wooorm/starry-night

[esmsh]: https://esm.sh

[file-license]: license

[file-notice]: notice

[github-gist-esm]: https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c

[github-hast]: https://github.com/syntax-tree/hast

[github-hast-root]: https://github.com/syntax-tree/hast#root

[github-hast-util-to-dom]: https://github.com/syntax-tree/hast-util-to-dom

[github-hast-util-to-html]: https://github.com/syntax-tree/hast-util-to-html

[github-hast-util-to-jsx-runtime]: https://github.com/syntax-tree/hast-util-to-jsx-runtime

[github-linguist-languages-yml]: https://github.com/github-linguist/linguist/blob/b5432eb/lib/linguist/languages.yml#L4031

[github-lowlight]: https://github.com/wooorm/lowlight

[github-markdown-tm-language]: https://github.com/wooorm/markdown-tm-language

[github-pages-license]: https://github.com/github/pages-gem/issues/160#issuecomment-134565796

[github-pages-pygments]: https://github.com/github/pages-gem/pull/79#issuecomment-85997762

[github-refractor]: https://github.com/wooorm/refractor

[github-rehype]: https://github.com/rehypejs/rehype

[github-rehype-starry-night]: https://github.com/rehypejs/rehype-starry-night

[github-shiki]: https://github.com/shikijs/shiki

[github-tree-sitter-tree-lights]: https://github.com/tree-sitter/tree-sitter/pull/283#issuecomment-465509157

[github-unified]: https://github.com/unifiedjs/unified

[github-vscode-oniguruma]: https://github.com/microsoft/vscode-oniguruma

[github-vscode-textmate]: https://github.com/microsoft/vscode-textmate

[npmjs-install]: https://docs.npmjs.com/cli/install

[npmjs-using-npm-script-dependencies]: https://docs.npmjs.com/cli/v11/using-npm/scripts#dependencies

[opensource-guide-contribute]: https://opensource.guide/how-to-contribute/

[section-css]: #css

[typescript]: https://www.typescriptlang.org

[wooorm]: https://wooorm.com
</file>

<file path="src/Artifacts/A55. DCE - FSService Refactoring Plan.md">
# Artifact A55: DCE - FSService Refactoring Plan
# Date Created: C113
# Author: AI Model & Curator
# Updated on: C114 (Mark refactor as complete)

- **Key/Value for A0:**
- **Description:** Outlines a strategic plan to refactor the monolithic `FSService` into smaller, more focused services to improve modularity, maintainability, and reduce token count.
- **Tags:** refactor, architecture, technical debt, services

## 1. Problem Statement

The `FSService` has become a "god object," handling a wide range of responsibilities beyond basic file system interactions and now violates the Single Responsibility Principle. Its large size (over 800 lines) makes it difficult to maintain, debug, and reason about. The service currently manages at least four distinct areas of concern:
1.  **Workspace State:** Building, caching, and watching the file tree.
2.  **File Operations:** Handling requests to create, move, delete, and modify files.
3.  **Content Virtualization:** Processing special file types like PDF, Word, and Excel into text.
4.  **Syntax Highlighting:** Managing the `starry-night` library and processing highlighting requests.

## 2. Refactoring Plan (Completed in C114)

The `FSService` has been successfully broken down into four new, more focused services. This has improved code organization, reduced the token count of individual files, and made the system more modular and maintainable.

### 2.1. New Service Structure

#### 1. `FileTreeService`
-   **Responsibility:** All "read" operations related to the workspace structure. This service is the source of truth for what the workspace looks like.
-   **Methods moved here:**
    -   `handleWorkspaceFilesRequest`
    -   `buildTreeFromTraversal`, `_traverseDirectory`, `_aggregateStats`
    -   `getFileStats`
    -   `getGitStatusMap`, `getProblemCountsMap`
    -   `initializeWatcher`, `triggerFullRefresh`, `triggerDiagnosticsUpdate`
    -   `fileTreeCache` property

#### 2. `FileOperationService`
-   **Responsibility:** All "write" or direct modification operations on the file system.
-   **Methods moved here:**
    -   `handleNewFileRequest`
    -   `handleNewFolderRequest`
    -   `handleFileRenameRequest`
    -   `handleMoveFileRequest`
    -   `handleFileDeleteRequest`, `handleBatchFileDeleteRequest`
    -   `handleCopyFileRequest`, `handleCopyFileFromUri`, `handleAddFileFromBuffer`
    -   `handleOpenFileRequest`
    -   `handleRevealInExplorerRequest`
    -   `handleCopyPathRequest`

#### 3. `ContentExtractionService`
-   **Responsibility:** Handling the on-demand parsing and virtualization of special, non-text file formats.
-   **Methods moved here:**
    -   `handlePdfToTextRequest`, `getVirtualPdfContent`, `pdfTextCache`
    -   `handleExcelToTextRequest`, `getVirtualExcelContent`, `excelMarkdownCache`
    -   `handleWordToTextRequest`, `getVirtualWordContent`, `wordTextCache`
    -   `_sheetToMarkdown` (private helper)

#### 4. `HighlightingService`
-   **Responsibility:** All logic related to syntax highlighting.
-   **Methods moved here:**
    -   `initializeStarryNight`
    -   `handleSyntaxHighlightRequest`
    -   `starryNight` property

### 2.2. Integration

-   The main `services.ts` container was updated to instantiate all four new services.
-   The `on-message.ts` handlers were updated to call the correct methods on the new, more specific services.
-   The original `fs.service.ts` file has been deleted.

## 3. Benefits Achieved

-   **Reduced Complexity:** Each service is now significantly smaller and easier to understand.
-   **Improved Maintainability:** Bugs or feature requests will be easier to implement in the correct, isolated service.
-   **Clear Separation of Concerns:** The architecture now follows best practices.
-   **Lower Token Count:** Splitting the large file into four smaller ones makes each file more manageable.

<Original fs.service.ts>
Removed after completing refactor.
</Original fs.service.ts>
</file>

<file path="src/Artifacts/A56. DCE - Phase 2 - Advanced Diff Viewer Plan.md">
# Artifact A56: DCE - Phase 2 - Advanced Diff Viewer Plan
# Date Created: C120
# Author: AI Model & Curator
# Updated on: C132 (Add keyboard navigation and clarify scrollbar behavior)

- **Key/Value for A0:**
- **Description:** Details the plan to enhance the integrated diff viewer with a side-by-side layout, scroll-locking, keyboard navigation, and a location pane.
- **Tags:** feature plan, phase 2, ui, ux, diff, navigation, side-by-side, scroll-lock, keyboard

## 1. Overview & Goal

The current diff view is functional but lacks key usability features found in mature diff tools like WinMerge. The goal of this plan is to enhance the diff viewer to provide a much clearer and more efficient user experience. This involves several key enhancements:
1.  **Side-by-Side Main Layout:** Displaying the original and modified files in two parallel, vertical panes.
2.  **Top-and-Bottom Detail Layout:** Displaying the character-level diff in two panes stacked vertically at the bottom.
3.  **Scroll-Locking:** Synchronizing the scroll position of the two main panes and the two detail panes, with all four panes having visible scrollbars.
4.  **Keyboard Navigation:** Allowing users to navigate between differences and accept changes using only the keyboard.
5.  **Location Pane (Future):** A visual overview of all changes in the file.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| P2-DIFF-01 | **Side-by-Side Diffs** | As a developer, I want to see a side-by-side view of the original and modified code with a colored background for changed lines, so I can immediately identify changes at a glance. | - The main diff view is split into two vertical panes: "Original Workspace File" on the right, "AI Response" on the left. <br> - Lines are colored appropriately for additions and removals. |
| P2-DIFF-02 | **Scroll-Locking** | As a developer, when I scroll one of the main diff panes vertically, I want the other main pane to scroll with it, so I can keep the corresponding code aligned. | - All four diff panes have their own scrollbars. <br> - The two main diff panes are scroll-locked vertically. <br> - The two bottom detail panes are scroll-locked horizontally. |
| P2-DIFF-03 | **Navigate Between Diffs** | As a developer reviewing a large file, I want "Next Difference" and "Previous Difference" buttons, so I can quickly jump between changed blocks. | - "Next Difference" (`â†“`) and "Previous Difference" (`â†‘`) buttons are located in a stable toolbar. <br> - Clicking scrolls the view to the start of the next/previous block of changes and highlights it. |
| P2-DIFF-04 | **Keyboard Navigation & Acceptance** | As a developer, I want to use the up/down arrow keys to navigate between differences and the right arrow key to accept the change from the response, so I can review and merge code without using the mouse. | - Pressing `ArrowDown` selects the next difference block. <br> - Pressing `ArrowUp` selects the previous difference block. <br> - Pressing `ArrowRight` accepts the change from the left (AI) pane, visually updating the right (original) pane's content *in memory*. |
| P2-DIFF-05 | **Location Pane (Future)** | As a developer, I want to see a miniature, vertical map of all the changes in the file, so I can understand the overall scope of the diff and quickly jump to any section. | - A new "Location Pane" is displayed above the main diff view. <br> - It shows a compressed visual representation of the entire file, with colored blocks indicating added, removed, and changed lines. <br> - Clicking on a block in this pane scrolls the main diff view to that location. |
| P2-DIFF-06 | **Line Numbers in Detail Pane (Future)** | As a developer, I want to see line numbers in the bottom character-level diff panes, so I have context for where the detailed change is occurring. | - The bottom panes display the relevant line numbers next to the content. |

## 3. Technical Implementation Plan

### 3.1. Layout & Scroll-Locking (`DiffViewer.tsx`, `view.scss`)
-   **Layout:** The main container will use `flex-direction: row` (side-by-side) and the detail container will use `flex-direction: column` (top/bottom).
-   **Scroll-Locking:** `useRef` will be used for all four scrollable panes. `onScroll` event handlers will synchronize the `scrollTop` or `scrollLeft` properties of their counterparts. CSS will no longer hide any scrollbars.

### 3.2. Keyboard Navigation (`DiffViewer.tsx`)
-   **Event Listener:** A `useEffect` hook will add a `keydown` event listener to the component's main wrapper `div` (which must have a `tabIndex` to be focusable).
-   **State Management:**
    *   The existing `selectedDiffIndex` state will be used. The `ArrowUp` and `ArrowDown` handlers will simply increment or decrement this state.
    *   A new state will be added to manage the content of the original file: `const [originalLines, setOriginalLines] = useState(original.content.split('\n'));`.
    *   The diff generation logic in the `useMemo` hook will be updated to use `originalLines` as its source instead of the static `original.content` prop.
-   **Accept Logic (`ArrowRight`):**
    1.  Get the current difference block from `pairedLines` using `selectedDiffIndex`.
    2.  Identify the line numbers and content for this block from both the `left` (AI) and `right` (original) sides.
    3.  Create a new array based on `originalLines`.
    4.  Splice the new lines from the AI response into the correct position in the new array, replacing the old lines.
    5.  Call `setOriginalLines` with this new array. This will trigger a re-render, visually showing the change as "accepted".
</file>

<file path="src/Artifacts/A57. DCE - Phase 2 - Cycle Management Plan.md">
# Artifact A57: DCE - Phase 2 - Cycle Management Plan
# Date Created: C125
# Author: AI Model & Curator

- **Key/Value for A0:**
- **Description:** Outlines the user stories and technical implementation for deleting cycles and resetting the PCPP history.
- **Tags:** feature plan, phase 2, ui, ux, history, cycle management

## 1. Overview & Goal

As the number of development cycles increases, users need tools to manage their history within the Parallel Co-Pilot Panel (PCPP). The goal of this feature is to provide basic but essential management capabilities, allowing users to delete unwanted cycles and completely reset the history if needed. This keeps the history relevant and manageable.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| P2-CM-01 | **Delete a Cycle** | As a developer, I want to be able to delete a specific cycle from my history, so I can remove erroneous or irrelevant entries. | - A "Delete Cycle" button is available in the "Cycle & Context" section. <br> - Clicking it prompts for confirmation (e.g., "Are you sure you want to delete Cycle X?"). <br> - Upon confirmation, the specified cycle is removed from the `dce_history.json` file. <br> - The UI automatically navigates to the next available cycle (e.g., the previous one or the new latest one). |
| P2-CM-02 | **Reset All History** | As a developer, I want to be able to reset the entire PCPP history, so I can start a project fresh without old cycle data. | - A "Reset History" button is available. <br> - Clicking it shows a strong confirmation warning (e.g., "This will delete ALL cycles and cannot be undone."). <br> - Upon confirmation, the `dce_history.json` file is deleted. <br> - The UI reloads to a fresh "Cycle 1" state. |

## 3. Technical Implementation Plan

1.  **IPC Channels (`channels.enum.ts`, `channels.type.ts`):**
    *   Create `ClientToServerChannel.RequestDeleteCycle` with a payload of `{ cycleId: number }`.
    *   Create `ClientToServerChannel.RequestResetHistory` with an empty payload.

2.  **Backend (`history.service.ts`):**
    *   **`deleteCycle(cycleId: number)`:**
        *   Read the `dce_history.json` file.
        *   Filter the `cycles` array to remove the entry where `cycle.cycleId === cycleId`.
        *   If only one cycle remains, do not allow deletion, or handle it by resetting to a default state.
        *   Write the updated history file back to disk.
    *   **`resetHistory()`:**
        *   Use `vscode.workspace.fs.delete` to remove the `dce_history.json` file.
        *   The existing logic in `getLatestCycle` will automatically create a new, default "Cycle 1" the next time data is requested.

3.  **Frontend (`view.tsx`):**
    *   **UI Buttons:** Add "Delete Cycle" and "Reset History" icon buttons to the `cycle-navigator` div.
    *   **Event Handlers:**
        *   The `onClick` handler for "Delete Cycle" will call `vscode.window.showWarningMessage` to confirm. If the user confirms, it will send the `RequestDeleteCycle` IPC message with the `currentCycle` ID. After sending, it should trigger a request for the new latest cycle data to refresh the UI.
        *   The `onClick` handler for "Reset History" will do the same, but for the `RequestResetHistory` message.

4.  **Message Handling (`on-message.ts`):**
    *   Add handlers for the new IPC channels that call the corresponding methods in `HistoryService`.
    *   After a successful deletion or reset, the backend should send a message back to the client (e.g., a `ForceRefresh` or a new dedicated message) to trigger a full state reload.
</file>

<file path="src/Artifacts/A58. DCE - WinMerge Source Code Analysis.md">
# Artifact A58: DCE - WinMerge Source Code Analysis
# Date Created: C129
# Author: AI Model & Curator
# Updated on: C130 (Add Architectural and UX Insights)

- **Key/Value for A0:**
- **Description:** Documents the key files and concepts from the WinMerge source code that are relevant to building a high-quality diff viewer.
- **Tags:** research, analysis, diff, winmerge, source code

## 1. Overview

To significantly improve the quality of our integrated diff viewer, an analysis of the open-source WinMerge utility was conducted. This document codifies the key findings from that analysis, listing the most valuable files from the WinMerge source code. These files serve as a reference for implementing advanced diffing features such as a more accurate core algorithm, inline (intra-line) difference highlighting, and moved block detection, as well as architectural patterns for creating a robust and flexible tool.

## 2. Key Reference Files from WinMerge Source

The following files from the WinMerge repository contain the core concepts needed to elevate our diff viewer's quality.

### 2.1. Core Algorithm & Heuristics

These files detail the logic behind WinMerge's highly optimized and accurate line-level diffing, which is based on the GNU `diffutils` engine.

*   **`Winmerge-Src\Src\diffutils\src\analyze.c`**: The heart of the GNU diff algorithm. The `diag` function implements the core logic for finding the "shortest edit script." Studying this reveals the heuristics used to achieve high-quality and performant diffs.
*   **`Winmerge-Src\Src\DiffWrapper.cpp`**: This is a C++ wrapper around the `diffutils` engine. It demonstrates how the raw output from the C functions is processed into a more usable format for the application, serving as a model for processing diff results.

### 2.2. Inline (Intra-Line) Difference Highlighting

This file contains the logic for highlighting the specific characters that have changed *within* a line.

*   **`Winmerge-Src\Src\stringdiffs.cpp`**: Contains WinMerge's dedicated algorithm for performing intra-line diffs. Analyzing its approach can help improve our own character-level diff rendering.

### 2.3. Moved Block Detection

This is one of WinMerge's most powerful features, providing essential context for refactoring.

*   **`Winmerge-Src\Src\MovedBlocks.cpp`**: This file contains the complete algorithm WinMerge uses to analyze the diff list, find matching blocks of text that have been moved, and link them together. This is the primary reference for implementing this feature.

### 2.4. Data Structures & UI Rendering

These files show how the data is structured and rendered to the user in the side-by-side view.

*   **`Winmerge-Src\Src\MergeDoc.cpp`**: Acts as the data model for the application. It shows how the diff list is structured to accommodate advanced concepts like moved lines. Our `PairedLine` interface can be modeled on the data structures found here.
*   **`Winmerge-Src\Src\MergeEditView.cpp`**: This is the main rendering component. It contains the logic for taking the results of the line and intra-line diffs and drawing the text with the correct highlighting and layout.
*   **`Winmerge-Src\Src\DiffList.h`**: This header defines the core data structures for the list of differences and is an excellent reference for designing a more robust data model.
*   **`Winmerge-Src\Src\MainFrm.cpp`**: The main application window frame. This file is valuable for understanding how the different components (the document/model, the view, user options, etc.) are all integrated and managed at the application level.

## 3. Architectural and UX Insights (C130)

Beyond specific algorithms, the WinMerge source code reveals important architectural patterns for building a high-quality diffing tool.

*   **Configurability (`CompareOptions.h`, `OptionsMgr.h`):** WinMerge is extremely configurable. The code shows a clear separation between the core diffing logic and the user-configurable options (e.g., whitespace handling, case sensitivity, filtering). This is a strong pattern to emulate, ensuring our tool can be adapted to various user needs.
*   **Text Encoding (`unicoder.h`, `codepage_detect.cpp`):** The project has dedicated, robust code for detecting and handling different text encodings. This is a critical, non-trivial feature for a diff tool that must work with files from various sources. It highlights the importance of pre-processing file content into a consistent format *before* passing it to the diff algorithm.
*   **Pluggable Compare Engines (`CompareEngines` directory):** WinMerge uses a strategy pattern, allowing different comparison engines (e.g., `BinaryCompare`, `ImageCompare`, `TimeSizeCompare`) to be used. This is a powerful architectural concept that could allow our tool to be extended with new comparison methods in the future (e.g., semantic code diffing).

## 4. Path Forward

By studying the algorithms and architectural patterns in these key files, we can create a clear development plan to implement these advanced features in our TypeScript and React-based extension. The immediate priority is to refactor our UI to a vertical, fixed-pane layout, and then we can begin to incrementally incorporate the more advanced logic inspired by these files.
</file>

<file path="src/Artifacts/A6. DCE - Initial Scaffolding Deployment Script.md">
# Artifact A6: DCE - Initial Scaffolding Deployment Script
# Date Created: Cycle 3
# Author: AI Model
# Updated on: Cycle 10 (Fix problemMatcher in tasks.json to resolve F5 launch error)

- **Description:** Contains a Node.js script that, when executed, creates the entire initial directory structure and files for the DCE extension project.
- **Tags:** deployment, script, scaffolding, bootstrap, nodejs, automation

## 1. Overview

This artifact contains the `deploy_scaffold.js` script. Its purpose is to automate the creation of the initial project structure for the Data Curation Environment (DCE) VS Code extension. This eliminates the need for manual file creation and ensures a consistent setup based on our agreed-upon architecture, including the necessary configurations for debugging.

## 2. How to Use

1.  Save the code below as `deploy_scaffold.js` in your project's root directory (e.g., `C:\Projects\DCE\`).
2.  Open a terminal in that directory.
3.  Run the script using Node.js: `node deploy_scaffold.js`
4.  The script will create all the necessary directories and files, including the `.vscode` folder with `launch.json` and a corrected `tasks.json`, logging its progress to the console.

## 3. Script: `deploy_scaffold.js`

```javascript
const fs = require('fs').promises;
const path = require('path');

// --- File Content Definitions ---

const filesToCreate = [
    {
        path: 'package.json',
        content: `{
    "name": "data-curation-environment",
    "publisher": "DCE-Developer",
    "displayName": "Data Curation Environment",
    "description": "A VS Code extension for curating context for Large Language Models.",
    "version": "0.0.1",
    "engines": {
        "vscode": "^1.90.0"
    },
    "categories": [
        "Other"
    ],
    "activationEvents": [
        "onView:viewType.sidebar.contextChooser"
    ],
    "main": "./dist/extension.js",
    "contributes": {
        "viewsContainers": {
            "activitybar": [
                {
                    "id": "data-curation-environment",
                    "title": "Data Curation",
                    "icon": "public/spiral.svg"
                }
            ]
        },
        "views": {
            "data-curation-environment": [
                {
                    "type": "webview",
                    "id": "viewType.sidebar.contextChooser",
                    "name": "Context Chooser"
                }
            ]
        }
    },
    "scripts": {
        "vscode:prepublish": "npm run package",
        "compile": "webpack",
        "watch": "webpack --watch",
        "package": "webpack --mode production --devtool hidden-source-map",
        "lint": "eslint src --ext ts"
    },
    "devDependencies": {
        "@types/node": "18.x",
        "@types/vscode": "^1.90.0",
        "@typescript-eslint/eslint-plugin": "^7.7.1",
        "@typescript-eslint/parser": "^7.7.1",
        "eslint": "^8.57.0",
        "ts-loader": "^9.5.1",
        "typescript": "^5.4.5",
        "webpack": "^5.91.0",
        "webpack-cli": "^5.1.4",
        "copy-webpack-plugin": "^12.0.2",
        "style-loader": "^4.0.0",
        "css-loader": "^7.1.2",
        "sass-loader": "^16.0.1",
        "sass": "^1.78.0",
        "postcss-loader": "^8.1.1",
        "babel-loader": "^9.1.3",
        "@babel/preset-react": "^7.24.7",
        "@babel/preset-typescript": "^7.24.7",
        "process": "^0.11.10"
    },
    "dependencies": {
        "react": "^18.3.1",
        "react-dom": "^18.3.1",
        "react-icons": "^5.3.0",
        "rxjs": "^7.8.1",
        "reflect-metadata": "^0.2.2"
    }
}`
    },
    {
        path: 'tsconfig.json',
        content: `{
    "compilerOptions": {
        "module": "esnext",
        "moduleResolution": "node",
        "target": "ESNext",
        "lib": ["ES2022", "DOM"],
        "jsx": "react",
        "sourceMap": true,
        "rootDir": ".",
        "strict": false,
        "baseUrl": ".",
        "paths": {
            "@/*": ["src/*"]
        },
        "experimentalDecorators": true,
        "allowSyntheticDefaultImports": true
    },
    "include": ["src/**/*"]
}`
    },
    {
        path: 'webpack.config.js',
        content: `const path = require('path');
const CopyPlugin = require("copy-webpack-plugin");
const webpack = require('webpack');

/** @type {import('webpack').Configuration} */
const config = {
    target: 'node',
    mode: 'none',
    entry: {
        extension: './src/extension.ts',
        contextChooserView: './src/client/views/context-chooser.view/view.tsx',
    },
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: '[name].js',
        libraryTarget: 'commonjs2'
    },
    externals: {
        vscode: 'commonjs vscode'
    },
    resolve: {
        extensions: ['.ts', '.js', '.tsx', '.jsx'],
        alias: {
            "@": path.resolve(__dirname, 'src'),
        }
    },
    module: {
        rules: [
            {
                test: /\\.ts$/,
                exclude: /node_modules/,
                use: [{ loader: 'ts-loader' }]
            },
            {
                test: /\\.?ts.?(x)$/,
                exclude: /node_modules/,
                use: {
                    loader: "babel-loader",
                    options: {
                        presets: ['@babel/preset-react', '@babel/preset-typescript']
                    }
                }
            },
            {
                test: /\\.s[ac]ss$/i,
                use: ["style-loader", "css-loader", "sass-loader", "postcss-loader"],
            },
        ]
    },
    plugins: [
        new CopyPlugin({
            patterns: [{ from: "public", to: "public" }],
        }),
        new webpack.ProvidePlugin({
            process: 'process/browser',
        }),
    ],
    devtool: 'nosources-source-map',
    infrastructureLogging: {
        level: "log",
    },
};
module.exports = [config];`
    },
    {
        path: '.gitignore',
        content: `node_modules
dist
out
*.vsix
.vscode-test/
.vscode/`
    },
    {
        path: '.vscodeignore',
        content: `node_modules
src
.gitignore
webpack.config.js
tsconfig.json
**/*.map
**/*.ts`
    },
    {
        path: '.vscode/launch.json',
        content: `{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Run Extension",
            "type": "extensionHost",
            "request": "launch",
            "args": ["--extensionDevelopmentPath=\${workspaceFolder}"],
            "outFiles": ["\${workspaceFolder}/dist/**/*.js"],
            "preLaunchTask": "npm: watch"
        }
    ]
}`
    },
    {
        path: '.vscode/tasks.json',
        content: `{
    "version": "2.0.0",
    "tasks": [
        {
            "type": "npm",
            "script": "watch",
            "isBackground": true,
            "presentation": {
                "reveal": "never"
            },
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "problemMatcher": {
                "base": "$ts-webpack-watch",
                "background": {
                    "activeOnStart": true,
                    "beginsPattern": "Compilation starting...",
                    "endsPattern": "compiled successfully"
                }
            }
        }
    ]
}`
    },
    {
        path: 'public/spiral.svg',
        content: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200">
    <g id="Page-1" stroke="none" fill="none" fill-rule="evenodd">
        <g id="dep" transform="translate(4, 6)">
            <path d="M100 100 m 0 -80 a 80 80 0 0 1 0 160 a 70 70 0 0 1 0 -140 a 60 60 0 0 1 0 120 a 50 50 0 0 1 0 -100 a 40 40 0 0 1 0 80 a 30 30 0 0 1 0 -60 a 20 20 0 0 1 0 40"
                fill="none" stroke="white" stroke-width="8" id="Shape" />
        </g>
    </g>
</svg>`
    },
    {
        path: 'src/extension.ts',
        content: `import * as vscode from "vscode";
import { registerViews } from "./client/views";
import { registerCommands } from "./backend/commands/register-commands";
import { Services } from "./backend/services/services";

let globalContext: vscode.ExtensionContext | null = null;

export function activate(context: vscode.ExtensionContext) {
    console.log('Congratulations, your extension "Data Curation Environment" is now active!');
    globalContext = context;

    Services.initialize();
    registerCommands(context);
    registerViews(context);
}

export function getContext() {
    if (!globalContext) {
        throw new Error("Extension context not available.");
    }
    return globalContext;
}

export function deactivate() {}`
    },
    {
        path: 'src/common/types/file-node.ts',
        content: `export interface FileNode {
    name: string;
    absolutePath: string;
    children?: FileNode[];
}`
    },
    {
        path: 'src/common/types/vscode-webview.d.ts',
        content: `export interface WebviewApi<StateType> {
    postMessage(message: unknown): void;
    getState(): StateType | undefined;
    setState<T extends StateType | undefined>(newState: T): T;
}

declare global {
    function acquireVsCodeApi<StateType = unknown>(): WebviewApi<StateType>;
}`
    },
    {
        path: 'src/common/ipc/channels.enum.ts',
        content: `export enum ClientToServerChannel {
    RequestFlattenContext = "clientToServer.requestFlattenContext",
    RequestWorkspaceFiles = "clientToServer.requestWorkspaceFiles",
}

export enum ServerToClientChannel {
    SendWorkspaceFiles = "serverToClient.sendWorkspaceFiles",
}`
    },
    {
        path: 'src/common/ipc/channels.type.ts',
        content: `import { FileNode } from "@/common/types/file-node";
import { ClientToServerChannel, ServerToClientChannel } from "./channels.enum";

export type ChannelBody<T extends ClientToServerChannel | ServerToClientChannel> =
    T extends ClientToServerChannel.RequestFlattenContext ? { selectedPaths: string[] } :
    T extends ClientToServerChannel.RequestWorkspaceFiles ? {} :
    T extends ServerToClientChannel.SendWorkspaceFiles ? { files: FileNode[] } :
    never;`
    },
    {
        path: 'src/common/ipc/get-vscode-api.ts',
        content: `import { WebviewApi } from "../types/vscode-webview";

let vscode: WebviewApi<unknown> | null = null;

const getVscode = () => {
    if (!vscode) {
        vscode = acquireVsCodeApi();
    }
    return vscode;
};

export default getVscode;`
    },
    {
        path: 'src/common/ipc/client-ipc.ts',
        content: `import getVscode from "./get-vscode-api";
import { ClientToServerChannel, ServerToClientChannel } from "./channels.enum";
import { ChannelBody } from "./channels.type";

export class ClientPostMessageManager {
    private static _instance?: ClientPostMessageManager;
    private _listeners: {
        channel: ServerToClientChannel,
        callback: (body: ChannelBody<ServerToClientChannel>) => void
    }[];

    private constructor() {
        this._listeners = [];
        window.addEventListener('message', (event: MessageEvent) => {
            const data = event.data;
            this._listeners.forEach((listener) => {
                if (listener.channel === data.channel) {
                    listener.callback(data.body);
                }
            });
        });
    }

    static getInstance(): ClientPostMessageManager {
        if (!ClientPostMessageManager._instance) {
            ClientPostMessageManager._instance = new ClientPostMessageManager();
        }
        return ClientPostMessageManager._instance;
    }

    sendToServer<T extends ClientToServerChannel>(channel: T, body: ChannelBody<T>): void {
        getVscode().postMessage({ channel, body });
    }

    onServerMessage<T extends ServerToClientChannel>(channel: T, callback: (body: ChannelBody<T>) => void): void {
        this._listeners.push({ channel, callback: callback as any });
    }
}`
    },
    {
        path: 'src/common/ipc/server-ipc.ts',
        content: `import { ClientToServerChannel, ServerToClientChannel } from "./channels.enum";
import { ChannelBody } from "./channels.type";

export class ServerPostMessageManager {
    private static _instance?: ServerPostMessageManager;
    private _listeners: {
        channel: ClientToServerChannel,
        callback: (body: ChannelBody<ClientToServerChannel>) => void
    }[];

    private constructor(
        private onMessage: (data: any) => void,
        private sendMessage: (message: any) => void
    ) {
        this._listeners = [];
        this.onMessage((data: any) => {
            this._listeners.forEach((listener) => {
                if (listener.channel === data.channel) {
                    listener.callback(data.body);
                }
            });
        });
    }

    static getInstance(onMessage?: (data: any) => void, sendMessage?: (message: any) => void) {
        if (onMessage && sendMessage) {
            ServerPostMessageManager._instance = new ServerPostMessageManager(onMessage, sendMessage);
        }
        if (!ServerPostMessageManager._instance) {
            throw new Error("ServerPostMessageManager not initialized");
        }
        return ServerPostMessageManager._instance;
    }

    sendToClient<T extends ServerToClientChannel>(channel: T, body: ChannelBody<T>): void {
        this.sendMessage({ channel, body });
    }

    onClientMessage<T extends ClientToServerChannel>(channel: T, callback: (body: ChannelBody<T>) => void): void {
        this._listeners.push({ channel, callback: callback as any });
    }
}`
    },
    {
        path: 'src/common/utils/view-html.ts',
        content: `import * as vscode from "vscode";

export function getViewHtml({ webview, nonce, scriptUri }: { webview: vscode.Webview; nonce: string; scriptUri: string; }): string {
    return \`<!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src \${webview.cspSource} 'unsafe-inline'; script-src 'nonce-\${nonce}';">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
        </head>
        <body>
            <div id="root"></div>
            <script nonce="\${nonce}" src="\${scriptUri}"></script>
        </body>
        </html>\`;
}

function getNonce() {
    let text = "";
    const possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    for (let i = 0; i < 32; i++) {
        text += possible.charAt(Math.floor(Math.random() * possible.length));
    }
    return text;
}
export { getNonce };`
    },
    {
        path: 'src/client/views/index.ts',
        content: `import { viewConfig as contextChooserViewConfig } from "./context-chooser.view";
import * as vscode from "vscode";
import { ServerPostMessageManager } from "@/common/ipc/server-ipc";
import { getNonce, getViewHtml } from "@/common/utils/view-html";

export const views = [contextChooserViewConfig];
export const serverIPCs: Record<string, ServerPostMessageManager> = {};

export function registerViews(context: vscode.ExtensionContext) {
    views.forEach((viewConfig) => {
        context.subscriptions.push(
            vscode.window.registerWebviewViewProvider(viewConfig.type, {
                resolveWebviewView: (webviewView) => {
                    webviewView.webview.options = {
                        enableScripts: true,
                        localResourceRoots: [context.extensionUri],
                    };
                    const nonce = getNonce();
                    webviewView.webview.html = getViewHtml({
                        webview: webviewView.webview,
                        nonce,
                        scriptUri: webviewView.webview.asWebviewUri(vscode.Uri.joinPath(context.extensionUri, "dist", viewConfig.entry)).toString(),
                    });
                    const serverIpc = ServerPostMessageManager.getInstance(
                        webviewView.webview.onDidReceiveMessage,
                        (data: any) => webviewView.webview.postMessage(data)
                    );
                    serverIPCs[viewConfig.type] = serverIpc;
                    viewConfig.handleMessage(serverIpc);
                },
            })
        );
    });
}`
    },
    {
        path: 'src/client/views/context-chooser.view/index.ts',
        content: `import { onMessage } from "./on-message";

export const viewConfig = {
    entry: "contextChooserView.js",
    type: "viewType.sidebar.contextChooser",
    handleMessage: onMessage,
};`
    },
    {
        path: 'src/client/views/context-chooser.view/on-message.ts',
        content: `import { ServerPostMessageManager } from "@/common/ipc/server-ipc";
import { ClientToServerChannel } from "@/common/ipc/channels.enum";
import { Services } from "@/backend/services/services";

export function onMessage(serverIpc: ServerPostMessageManager) {
    const fsService = Services.fsService;
    const flattenerService = Services.flattenerService;

    serverIpc.onClientMessage(ClientToServerChannel.RequestWorkspaceFiles, () =>
        fsService.handleWorkspaceFilesRequest(serverIpc)
    );

    serverIpc.onClientMessage(ClientToServerChannel.RequestFlattenContext, (data) => {
        console.log("Flattening context for paths:", data.selectedPaths);
        flattenerService.flatten(data.selectedPaths);
    });
}`
    },
    {
        path: 'src/client/views/context-chooser.view/view.tsx',
        content: `import * as React from 'react';
import * as ReactDOM from 'react-dom/client';
import './view.scss';
import { ClientPostMessageManager } from '@/common/ipc/client-ipc';
import { ClientToServerChannel, ServerToClientChannel } from '@/common/ipc/channels.enum';
import { FileNode } from '@/common/types/file-node';
import FileTree from '../../components/file-tree/FileTree';
import { useState, useEffect } from 'react';

const App = () => {
    const [files, setFiles] = useState<FileNode[]>([]);
    const [selectedFiles, setSelectedFiles] = useState<string[]>([]);
    const [activeFile, setActiveFile] = useState<string | undefined>();
    
    const clientIpc = ClientPostMessageManager.getInstance();

    useEffect(() => {
        clientIpc.sendToServer(ClientToServerChannel.RequestWorkspaceFiles, {});

        const handleFileResponse = ({ files: receivedFiles }: { files: FileNode[] }) => {
            setFiles(receivedFiles);
        };
        clientIpc.onServerMessage(ServerToClientChannel.SendWorkspaceFiles, handleFileResponse);

    }, [clientIpc]);

    const handleFileClick = (filePath: string) => {
        setActiveFile(filePath);
    };

    const updateSelectedFiles = (newSelectedFiles: string[]) => {
        setSelectedFiles(newSelectedFiles);
    };

    const handleFlattenClick = () => {
        clientIpc.sendToServer(ClientToServerChannel.RequestFlattenContext, { selectedPaths: selectedFiles });
    };

    return (
        <div className="view-container">
            <div className="view-header">
                <button className="flatten-button" onClick={handleFlattenClick}>
                    Flatten Context
                </button>
            </div>
            <div className="file-tree-container">
                {files.length > 0 ? (
                    files.map((rootNode, index) => (
                        <FileTree
                            key={index}
                            data={[rootNode]}
                            onFileClick={handleFileClick}
                            selectedFiles={selectedFiles}
                            updateSelectedFiles={updateSelectedFiles}
                            activeFile={activeFile}
                        />
                    ))
                ) : (
                    <div className="loading-message">Loading file tree...</div>
                )}
            </div>
        </div>
    );
};

const root = ReactDOM.createRoot(document.getElementById('root')!);
root.render(<App />);`
    },
    {
        path: 'src/client/views/context-chooser.view/view.scss',
        content: `body {
    padding: 0;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
    font-size: 13px;
    color: var(--vscode-editor-foreground);
    background-color: var(--vscode-sideBar-background);
}

.view-container {
    display: flex;
    flex-direction: column;
    height: 100vh;
}

.view-header {
    padding: 8px;
    border-bottom: 1px solid var(--vscode-panel-border);
}

.flatten-button {
    width: 100%;
    padding: 6px;
    border: 1px solid var(--vscode-button-border, var(--vscode-focusBorder));
    background-color: var(--vscode-button-background);
    color: var(--vscode-button-foreground);
    cursor: pointer;
    border-radius: 2px;
}

.flatten-button:hover {
    background-color: var(--vscode-button-hoverBackground);
}

.file-tree-container {
    padding: 5px;
    flex-grow: 1;
    overflow-y: auto;
}

.loading-message {
    padding: 8px;
    color: var(--vscode-descriptionForeground);
}

.tree-view ul {
    padding-left: 0;
    list-style-type: none;
    margin: 0;
}

.treenode-li {
    padding-left: 20px;
    position: relative;
}

.treenode-item-wrapper {
    display: flex;
    align-items: center;
    cursor: pointer;
    padding: 1px 4px;
    border-radius: 3px;
}

.treenode-item-wrapper:hover {
    background-color: var(--vscode-list-hoverBackground);
}

.treenode-chevron {
    position: absolute;
    left: 0;
    top: 50%;
    transform: translateY(-50%) rotate(0deg);
    transition: transform 0.1s ease-in-out;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 20px;
    height: 20px;
}

.treenode-chevron.expanded {
    transform: translateY(-50%) rotate(90deg);
}

.file-item {
    display: flex;
    align-items: center;
    width: 100%;
    padding: 1px;
}

.file-item.active {
    background-color: var(--vscode-list-activeSelectionBackground);
    color: var(--vscode-list-activeSelectionForeground);
}

.file-checkbox {
    margin-right: 6px;
    cursor: pointer;
}

.file-name {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}`
    },
    {
        path: 'src/backend/commands/commands.ts',
        content: `// No commands are needed for now, but we'll keep the file for future use.
export const commands = [];`
    },
    {
        path: 'src/backend/commands/register-commands.ts',
        content: `import * as vscode from "vscode";
import { commands } from "./commands";

export function registerCommands(context: vscode.ExtensionContext) {
    commands.forEach(({ commandId, callback }) => {
        let disposable = vscode.commands.registerCommand(commandId, callback);
        context.subscriptions.push(disposable);
    });
}`
    },
    {
        path: 'src/backend/services/services.ts',
        content: `import "reflect-metadata";
import { FSService } from "./fs.service";
import { FlattenerService } from "./flattener.service";

// A simple container for services
class ServiceContainer {
    public fsService = new FSService();
    public flattenerService = new FlattenerService();
    
    public initialize() {
        // This can be used for service initialization logic in the future
    }
}

export const Services = new ServiceContainer();`
    },
    {
        path: 'src/backend/services/fs.service.ts',
        content: `import * as vscode from "vscode";
import * as path from "path";
import { ServerPostMessageManager } from "@/common/ipc/server-ipc";
import { ServerToClientChannel } from "@/common/ipc/channels.enum";
import { FileNode } from "@/common/types/file-node";

export class FSService {
    public async handleWorkspaceFilesRequest(serverIpc: ServerPostMessageManager) {
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (!workspaceFolders || workspaceFolders.length === 0) {
            serverIpc.sendToClient(ServerToClientChannel.SendWorkspaceFiles, { files: [] });
            return;
        }
        
        // For simplicity, we'll just use the first workspace folder.
        const rootUri = workspaceFolders[0].uri;
        if (!rootUri) {
            // This case is unlikely if the above check passes, but good for safety.
            serverIpc.sendToClient(ServerToClientChannel.SendWorkspaceFiles, { files: [] });
            return;
        }
        const rootPath = rootUri.fsPath;
        const files = await vscode.workspace.findFiles("**/*");
        const fileTree = this.createFileTree(rootPath, files);

        serverIpc.sendToClient(ServerToClientChannel.SendWorkspaceFiles, { files: [fileTree] });
    }

    private createFileTree(rootPath: string, files: vscode.Uri[]): FileNode {
        const rootNode: FileNode = {
            name: path.basename(rootPath),
            absolutePath: rootPath,
            children: []
        };

        for (const file of files) {
            const relativePath = path.relative(rootPath, file.fsPath);
            const parts = relativePath.split(path.sep);
            let currentNode = rootNode;

            for (let i = 0; i < parts.length; i++) {
                const part = parts[i];
                let childNode = currentNode.children?.find(c => c.name === part);

                if (!childNode) {
                    const newPath = path.join(currentNode.absolutePath, part);
                    childNode = { name: part, absolutePath: newPath };
                    if (i < parts.length - 1) {
                        childNode.children = [];
                    }
                    currentNode.children?.push(childNode);
                }
                currentNode = childNode;
            }
        }
        return rootNode;
    }
}`
    },
    {
        path: 'src/client/components/Checkbox.tsx',
        content: `import React from "react";
import { useEffect, useRef } from "react";

interface CheckboxProps extends Omit<React.DetailedHTMLProps<React.InputHTMLAttributes<HTMLInputElement>, HTMLInputElement>, 'onChange'> {
    checked: boolean;
    indeterminate?: boolean;
    onChange: (checked: boolean, event: React.ChangeEvent<HTMLInputElement>) => void;
}

const Checkbox = (props: CheckboxProps) => {
    const { checked, onChange, indeterminate, ...rest } = props;
    const cRef = useRef<any>(null);

    useEffect(() => {
        if (cRef.current) {
            cRef.current.indeterminate = indeterminate;
        }
    }, [cRef, indeterminate]);

    return (
        <input type="checkbox" ref={cRef} checked={checked} onChange={(e) => onChange(e.target.checked, e)} {...rest} />
    );
};

export default Checkbox;`
    },
        {
        path: 'src/client/components/file-tree/FileTree.tsx',
        content: `import React, { useEffect, useState } from 'react';
import TreeView from '../tree-view/TreeView';
import { FileNode } from '@/common/types/file-node';
import { addRemovePathInSelectedFiles, getFileNodeByPath } from './FileTree.utils';
import Checkbox from '../Checkbox';

interface FileTreeProps {
  data: FileNode[];
  onFileClick?: (filePath: string) => void;
  selectedFiles: string[];
  activeFile?: string;
  updateSelectedFiles: (selectedFiles: string[]) => void;
}

const FileTree: React.FC<FileTreeProps> = ({
  data,
  onFileClick,
  selectedFiles,
  activeFile,
  updateSelectedFiles,
}) => {

  const rootNode = data.length > 0 ? data[0] : null;

  const [expandedNodes, setExpandedNodes] = useState<string[]>(rootNode ? [rootNode.absolutePath] : []);

  useEffect(() => {
    const toExpand = new Set<string>();
    selectedFiles?.forEach((selectedFile) => {
        const node = getFileNodeByPath(data, selectedFile);
        if (node && node.children) {
            toExpand.add(node.absolutePath);
        }
    });

    setExpandedNodes(prevExpandedNodes => [...new Set([...prevExpandedNodes, ...Array.from(toExpand)])]);
  }, [selectedFiles, data]);

  const handleNodeClick = (e: React.MouseEvent<HTMLElement, MouseEvent> | undefined, node: FileNode) => {
    if (e && (e.target as HTMLElement)?.closest('.file-checkbox')) {
        return;
    }
    onFileClick && onFileClick(node.absolutePath);
  };

  const renderCheckbox = (path: string) => {
    const isSelected = selectedFiles.includes(path);
    const hasSelectedAncestor = selectedFiles.some(ancestor => path.startsWith(ancestor) && path !== ancestor);
    const hasSelectedDescendant = selectedFiles.some(descendant => descendant.startsWith(path) && descendant !== path);
    
    return (
      <Checkbox
        className="file-checkbox"
        indeterminate={!isSelected && !hasSelectedAncestor && hasSelectedDescendant}
        checked={isSelected || hasSelectedAncestor}
        onChange={(_, e) => handleFileCheckboxChange(e, path)}
      />
    );
  };

  const handleFileCheckboxChange = (e: React.ChangeEvent<HTMLInputElement>, path: string) => {
    e.stopPropagation();
    e.preventDefault();
    updateSelectedFiles(addRemovePathInSelectedFiles(data, path, selectedFiles));
  };

  const renderFileNodeContent = (node: FileNode) => {
    const isActive = activeFile === node.absolutePath;
    const isDirectory = Array.isArray(node.children);

    return (
      <div
        className={\`file-item \${isActive ? 'active' : ''} \${isDirectory ? 'directory' : 'file'}\`}
        onClick={(e) => handleNodeClick(e, node)}
      >
        {renderCheckbox(node.absolutePath)}
        <span className="file-name">{node.name}</span>
      </div>
    );
  };

  return (
    <div className="file-tree">
      <TreeView 
        data={data} 
        renderNodeContent={renderFileNodeContent} 
      />
    </div>
  );
};

export default FileTree;`
    },
    {
        path: 'src/client/components/file-tree/FileTree.utils.ts',
        content: `import { FileNode } from "@/common/types/file-node";

function getAllDescendantPaths(node: FileNode): string[] {
    let paths: string[] = [];
    if (node.children) {
        for (const child of node.children) {
            paths.push(child.absolutePath);
            paths = paths.concat(getAllDescendantPaths(child));
        }
    }
    return paths;
}

export const addRemovePathInSelectedFiles = (
  fileTree: FileNode[],
  path: string,
  selectedFiles: string[]
): string[] => {
    const node = getFileNodeByPath(fileTree, path);
    if (!node) return selectedFiles;

    const descendantPaths = getAllDescendantPaths(node);
    const isSelected = selectedFiles.includes(path);
    const hasSelectedAncestor = selectedFiles.some(ancestor => path.startsWith(ancestor) && path !== ancestor);
    
    let newSelectedFiles = [...selectedFiles];

    if (isSelected) {
        // Uncheck: remove this path and all its descendants
        newSelectedFiles = newSelectedFiles.filter(p => p !== path && !descendantPaths.includes(p));
    } else if (hasSelectedAncestor) {
        // Uncheck a child of an already checked folder.
        // 1. Remove the ancestor.
        // 2. Add all children of the ancestor EXCEPT the one that was unchecked.
        const ancestor = selectedFiles.find(ancestor => path.startsWith(ancestor) && path !== ancestor)!;
        const ancestorNode = getFileNodeByPath(fileTree, ancestor)!;
        
        newSelectedFiles = newSelectedFiles.filter(p => p !== ancestor);
        
        const siblingsAndCousins = getAllDescendantPaths(ancestorNode).filter(p => p !== path && !p.startsWith(path));
        newSelectedFiles.push(...siblingsAndCousins);

    } else {
        // Check: remove all descendants that might be individually selected, then add the parent path.
        newSelectedFiles = newSelectedFiles.filter(p => !p.startsWith(path));
        newSelectedFiles.push(path);
    }
  
  return [...new Set(newSelectedFiles)]; // Remove duplicates for cleanliness
};

export const getFileNodeByPath = (
  fileNodes: FileNode[],
  filePath: string
): FileNode | null => {
    for (const rootNode of fileNodes) {
        const found = findNode(rootNode, filePath);
        if (found) return found;
    }
    return null;
};

function findNode(node: FileNode, filePath: string): FileNode | null {
    if (node.absolutePath === filePath) {
        return node;
    }
    if (node.children && filePath.startsWith(node.absolutePath)) {
        for (const child of node.children) {
            const found = findNode(child, filePath);
            if(found) return found;
        }
    }
    return null;
}`
    },
    {
        path: 'src/client/components/tree-view/TreeView.tsx',
        content: `import React, { useState } from 'react';
import { MdChevronRight } from 'react-icons/md';
import { getExpandedNodes } from './TreeView.utils';

export interface TreeNode {
    name: string;
    absolutePath: string;
    children?: TreeNode[];
    isExpanded?: boolean;
    [key: string]: any;
}

interface TreeViewProps {
    data: TreeNode[];
    onNodeClick?: (node: TreeNode) => void;
    renderNodeContent?: (node: TreeNode) => React.ReactNode;
}

const TreeView: React.FC<TreeViewProps> = ({ data, onNodeClick, renderNodeContent }) => {
    const [expandedNodes, setExpandedNodes] = useState<string[]>(getExpandedNodes(data));

    const handleNodeClick = (node: TreeNode) => {
        if (node.children && node.children.length > 0) {
            setExpandedNodes((prevExpandedNodes) => {
                const isExpanded = prevExpandedNodes.includes(node.absolutePath);
                return isExpanded
                    ? prevExpandedNodes.filter((n) => n !== node.absolutePath)
                    : [...prevExpandedNodes, node.absolutePath];
            });
        }
        onNodeClick && onNodeClick(node);
    };

    const renderTreeNodes = (nodes: TreeNode[]) => {
        return nodes.map((node) => {
            const isExpanded = expandedNodes.includes(node.absolutePath);
            const isDirectory = !!(node.children && node.children.length > 0);

            return (
                <li key={node.absolutePath} className="treenode-li">
                    <div
                        onClick={() => handleNodeClick(node)}
                        className={\`treenode-item-wrapper\`}
                    >
                        {isDirectory && (
                            <span
                                className={\`treenode-chevron \${isExpanded ? 'expanded' : ''}\`}
                            >
                                <MdChevronRight />
                            </span>
                        )}
                        {renderNodeContent ? renderNodeContent(node) : node.name}
                    </div>
                    {isDirectory && isExpanded && (
                        <ul className="treenode-children">{renderTreeNodes(node.children)}</ul>
                    )}
                </li>
            );
        });
    };

    return (
        <div className="tree-view">
            <ul>{renderTreeNodes(data)}</ul>
        </div>
    );
};

export default TreeView;`
    },
    {
        path: 'src/client/components/tree-view/TreeView.utils.ts',
        content: `import { TreeNode } from "./TreeView";

export const getExpandedNodes = (data: TreeNode[]): string[] => {
  return data.reduce((acc: string[], node) => {
    if (node.isExpanded) {
      acc.push(node.absolutePath);
    }
    if (node.children) {
      acc.push(...getExpandedNodes(node.children));
    }
    return acc;
  }, []);
};`
    },
    {
        path: 'src/backend/services/flattener.service.ts',
        content: `import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs/promises';

interface FileStats {
    filePath: string;
    lines: number;
    characters: number;
    tokens: number;
    content: string;
    error: string | null;
}

export class FlattenerService {

    public async flatten(selectedPaths: string[]) {
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (!workspaceFolders || workspaceFolders.length === 0) {
            vscode.window.showErrorMessage("Cannot flatten context: No workspace folder is open.");
            return;
        }
        if (selectedPaths.length === 0) {
            vscode.window.showWarningMessage("Cannot flatten context: No files or folders are selected.");
            return;
        }

        const rootPath = workspaceFolders[0].uri.fsPath;
        const outputFilePath = path.join(rootPath, 'flattened_repo.md');

        try {
            const allFilePaths = await this.expandDirectories(selectedPaths);
            const uniqueFilePaths = [...new Set(allFilePaths)];

            const fileStatsPromises = uniqueFilePaths.map(filePath => this.getFileStatsAndContent(filePath));
            const results = await Promise.all(fileStatsPromises);

            const outputContent = this.generateOutputContent(results, rootPath, outputFilePath);

            await fs.writeFile(outputFilePath, outputContent, 'utf-8');
            vscode.window.showInformationMessage(\`Successfully flattened \${results.filter(r => !r.error).length} files to flattened_repo.md.\`);

        } catch (error: any) {
            vscode.window.showErrorMessage(\`Failed to flatten context: \${error.message}\`);
            console.error(error);
        }
    }

    private async expandDirectories(paths: string[]): Promise<string[]> {
        const allFiles: string[] = [];
        for (const p of paths) {
            try {
                const stats = await fs.stat(p);
                if (stats.isDirectory()) {
                    allFiles.push(...await this.getAllFilesRecursive(p));
                } else {
                    allFiles.push(p);
                }
            } catch (e) {
                console.warn(\`Could not stat path \${p}, skipping.\`);
            }
        }
        return allFiles;
    }

    private async getAllFilesRecursive(dirPath: string): Promise<string[]> {
        let files: string[] = [];
        try {
            const entries = await fs.readdir(dirPath, { withFileTypes: true });
            for (const entry of entries) {
                const fullPath = path.join(dirPath, entry.name);
                if (entry.isDirectory()) {
                    files = files.concat(await this.getAllFilesRecursive(fullPath));
                } else {
                    files.push(fullPath);
                }
            }
        } catch (e) {
            console.error(\`Error reading directory \${dirPath}:\`, e);
        }
        return files;
    }

    private async getFileStatsAndContent(filePath: string): Promise<FileStats> {
        try {
            const content = await fs.readFile(filePath, 'utf-8');
            const lines = content.split('\\n').length;
            const characters = content.length;
            const tokens = Math.ceil(characters / 4);
            return { filePath, lines, characters, tokens, content, error: null };
        } catch (error: any) {
            return { filePath, lines: 0, characters: 0, tokens: 0, content: '', error: error.message };
        }
    }

    private generateOutputContent(results: FileStats[], rootDir: string, outputFilename: string): string {
        let totalLines = 0;
        let totalCharacters = 0;
        let totalTokens = 0;
        let errorCount = 0;
        const validResults = results.filter(r => !r.error);

        for (const res of validResults) {
            totalLines += res.lines;
            totalCharacters += res.characters;
            totalTokens += res.tokens;
        }

        let output = \`<!--\\n\`;
        output += \`  File: \${path.basename(outputFilename)}\\n\`;
        output += \`  Source Directory: \${rootDir}\\n\`;
        output += \`  Date Generated: \${new Date().toISOString()}\\n\`;
        output += \`  ---\\n\`;
        output += \`  Total Files: \${validResults.length}\\n\`;
        if (errorCount > 0) {
            output += \`  Files with Errors: \${errorCount}\\n\`;
        }
        output += \`  Total Lines: \${totalLines}\\n\`;
        output += \`  Total Characters: \${totalCharacters}\\n\`;
        output += \`  Approx. Tokens: \${totalTokens}\\n\`;
        output += \`-->\\n\\n\`;

        const top10 = [...validResults].sort((a, b) => b.tokens - a.tokens).slice(0, 10);

        output += \`<!-- Top 10 Files by Token Count -->\\n\`;
        top10.forEach((r, i) => {
            output += \`\${i + 1}. \${path.relative(rootDir, r.filePath)} (\${r.tokens} tokens)\\n\`;
        });
        output += \`\\n\`;

        output += \`<!-- Full File List -->\\n\`;
        results.forEach((r, i) => {
            const relativePath = path.relative(rootDir, r.filePath);
            if (r.error) {
                output += \`\${i + 1}. \${relativePath} - ERROR: \${r.error}\\n\`;
            } else {
                output += \`\${i + 1}. \${relativePath} - Lines: \${r.lines} - Chars: \${r.characters} - Tokens: \${r.tokens}\\n\`;
            }
        });
        output += \`\\n\`;

        for (const { filePath, content, error } of results) {
            const relativePath = path.relative(rootDir, filePath).replace(/\\\\/g, '/');
            output += \`<file path="\${relativePath}">\\n\`;
            if (error) {
                output += \`Error reading file: \${error}\\n\`;
            } else {
                output += content;
            }
            if (!content.endsWith('\\n')) {
                output += '\\n';
            }
            output += \`</file>\\n\\n\`;
        }
        return output;
    }
}`
    }
];

// --- Main Execution ---

async function deployScaffold() {
    console.log('Starting scaffold deployment...');
    const rootDir = process.cwd();

    for (const file of filesToCreate) {
        const fullPath = path.join(rootDir, file.path);
        const dir = path.dirname(fullPath);

        try {
            await fs.mkdir(dir, { recursive: true });
            await fs.writeFile(fullPath, file.content, 'utf-8');
            console.log(`âœ… Created: ${file.path}`);
        } catch (error) {
            console.error(`âŒ Failed to create ${file.path}: ${error.message}`);
        }
    }

    console.log('\nðŸš€ Scaffold deployment complete! ðŸš€');
    console.log('Next steps:');
    console.log('1. Run npm install to install dependencies.');
    console.log('2. Press F5 in VS Code to start the extension (this will also run npm run watch).');
}

deployScaffold();
```
</file>

<file path="src/Artifacts/A7. DCE - Development and Testing Guide.md">
# Artifact A7: DCE - Development and Testing Guide
# Date Created: Cycle 7
# Author: AI Model
# Updated on: Cycle 9 (Revised workflow to use integrated debugger configuration)

- **Description:** A step-by-step guide explaining how to run, debug, and test the DCE extension within VS Code using the Extension Development Host.
- **Tags:** development, testing, debugging, workflow, vs code extension, f5, launch.json

## 1. Purpose

This guide provides the correct and simplified procedure for running and testing the Data Curation Environment (DCE) extension locally. Following these steps is crucial to see your changes and the extension's UI in action.

## 2. The Core Concept: The Extension Development Host

You cannot see the extension's UI (like the spiral icon or the custom panel) in the same VS Code window where you are writing the code. Instead, you must launch a special, separate VS Code window called the **Extension Development Host**. This new window has your extension installed and running, allowing you to test it as a user would.

Our project now includes the necessary `.vscode/launch.json` and `.vscode/tasks.json` files to make this process seamless.

## 3. Step-by-Step Workflow

Follow these steps every time you want to test the extension:

### Step 1: Open the "Run and Debug" View

In your main project window (e.g., `C:\Projects\DCE`), navigate to the "Run and Debug" panel in the activity bar on the left. The icon looks like a play button with a bug on it.

### Step 2: Launch the Extension

At the top of the "Run and Debug" panel, you will see a dropdown menu. It should already have **"Run Extension"** selected.

Simply press the **F5** key or click the green play button next to the "Run Extension" dropdown.

This single action will now:
1.  Automatically start the `npm run watch` task in the background to compile your code.
2.  Launch the new **"[Extension Development Host]"** VS Code window.

### Step 3: Find the Extension UI

In the newly opened **Extension Development Host** window, look at the activity bar on the far left. You should now see our spiral icon. Clicking this icon will open the "Context Chooser" panel, where you'll see the file tree with checkboxes.

### Step 4: Making and Viewing Changes

1.  **Make Code Changes:** Edit the source code in your **original** project window.
2.  **Auto-Compile:** When you save a file, the `npm run watch` task (which was started automatically) will recompile it. You can see its progress in the terminal panel of your original window.
3.  **Reload the Host:** To see your changes, go to the **Extension Development Host** window (the one you launched with F5) and reload it. The easiest way is to open the Command Palette (`Ctrl+Shift+P` or `Cmd+Shift+P`) and run the command **`Developer: Reload Window`**.

You only need to stop the debugger (Shift+F5) and restart it (F5) if you make changes to configuration files like `package.json`. For all other code changes, simply reloading the host window is sufficient and much faster.
</file>

<file path="src/Artifacts/A8. DCE - Phase 1 - Selection Sets Feature Plan.md">
# Artifact A8: DCE - Phase 1 - Selection Sets Feature Plan
# Date Created: Cycle 11
# Author: AI Model
# Updated on: C23 (Add requirement for selection persistence)

- **Key/Value for A0:**
- **Description:** A plan outlining the user stories, UI/UX, and technical implementation for saving, loading, and persisting different sets of selected files (selection profiles).
- **Tags:** feature plan, selection sets, profiles, context management, persistence, phase 1

## 1. Overview & Goal

The goal of the "Selection Sets" feature is to address the user feedback regarding the need to save and switch between different file selections, and to ensure the current selection is not lost during a session. Users often work on multiple tasks or projects concurrently, each requiring a different context. Manually re-selecting files is tedious and losing the current selection when switching tabs is a critical usability flaw. This feature will allow users to save a named "set" of their current selections, quickly load it back later, and have their current selection state persist automatically.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| US-01 | **Selection Persistence** | As a user, I expect my current selection of checked files to remain active when I switch to another VS Code tab and then return, so my work is not lost. | - The current array of selected file paths is automatically saved to the webview's persistent state whenever it changes. <br> - When the webview is re-activated (e.g., tab is clicked), it restores the last saved selection state. |
| US-02 | **Save Current Selection** | As a developer, I want to save my currently checked files as a named set, so I don't have to re-select them manually when I switch tasks. | - A UI element (e.g., button or menu item) exists to "Save current selection". <br> - Clicking it prompts me to enter a name for the selection set. <br> - After providing a name, the current list of selected file paths is saved. <br> - I receive a confirmation that the set was saved. |
| US-03 | **Load a Saved Selection** | As a developer, I want to load a previously saved selection set, so I can quickly restore a specific context. | - A UI element (e.g., a dropdown menu) lists all saved selection sets by name. <br> - Selecting a set from the list immediately updates the file tree, checking all the files and folders from that set. <br> - Any previously checked files that are not part of the loaded set become unchecked. |
| US-04 | **Delete a Saved Selection** | As a developer, I want to delete a selection set that I no longer need, so I can keep my list of saved sets clean. | - A UI element exists to manage or delete saved sets. <br> - I can select a set to delete from a list. <br> - I am asked to confirm the deletion. <br> - Upon confirmation, the set is removed from the list of saved sets. |

## 3. Proposed UI/UX

The functionality will be consolidated into the `view-header` of our Context Chooser panel for easy access.

1.  **Header Controls:**
    *   A dropdown menu and/or a set of dedicated toolbar buttons for managing selection sets.
    *   Example: A "Save" icon button and a "Load" icon button.
    *   Clicking "Save" would trigger the save workflow.
    *   Clicking "Load" would open a Quick Pick menu of saved sets.

2.  **Saving a Set:**
    *   Clicking the "Save" button will execute the `dce.saveSelectionSet` command.
    *   This command will trigger a VS Code input box (`vscode.window.showInputBox`).
    *   The user will enter a name (e.g., "API Feature", "Frontend Refactor").
    *   On submission, the backend saves the current `selectedFiles` array under that name.

3.  **Loading a Set:**
    *   Clicking the "Load" button will execute the `dce.loadSelectionSet` command.
    *   This command shows a Quick Pick list (`vscode.window.showQuickPick`) of all saved sets.
    *   Selecting a set triggers an IPC message (`ApplySelectionSet`) to the frontend with the array of file paths for that set.
    *   The frontend updates its `selectedFiles` state, causing the tree to re-render with the new selections.

## 4. Technical Implementation Plan

1.  **State Persistence (`view.tsx`):**
    *   Define a state type in `vscode-webview.d.ts`: `interface ViewState { selectedFiles: string[] }`.
    *   In the main `App` component in `view.tsx`, use a `useEffect` hook that triggers whenever the `selectedFiles` state changes. Inside this effect, call `vscode.setState({ selectedFiles })`.
    *   On initial component mount, retrieve the persisted state using `const savedState = vscode.getState();` and if it exists, use it to initialize the `selectedFiles` state: `useState<string[]>(savedState?.selectedFiles || [])`.

2.  **Data Storage (`selection.service.ts`):**
    *   Selection sets will continue to be stored in the VS Code `workspaceState`. This is a key-value store specific to the current workspace.
    *   A single key, e.g., `dce.selectionSets`, will hold an object where keys are the set names and values are the `string[]` of absolute file paths.

3.  **IPC Channels & Commands (`commands.ts`):**
    *   The existing commands (`dce.saveSelectionSet`, `dce.loadSelectionSet`, `dce.deleteSelectionSet`) are suitable.
    *   The backend `loadSelectionSet` command will trigger the `ApplySelectionSet` IPC message to the client with the file paths.

4.  **Frontend Logic (`view.tsx`):**
    *   Add state to store the map of selection sets: `const [selectionSets, setSelectionSets] = useState({});`
    *   On mount, request the list of sets from the backend to populate any UI elements.
    *   Implement an effect to listen for `ApplySelectionSet` and call `setSelectedFiles()` with the new paths.
    *   Render the new "Save" and "Load" buttons in the header toolbar.
    *   The `onClick` handler for the "Save" button will trigger an IPC message that executes the `dce.saveSelectionSet` command, passing the current `selectedFiles` state.
</file>

<file path="src/Artifacts/A9. DCE - GitHub Repository Setup Guide.md">
# Artifact A9: DCE - GitHub Repository Setup Guide
# Date Created: Cycle 12
# Author: AI Model

- **Description:** A step-by-step guide with the necessary git commands to initialize the project as a local repository and push it to a new remote repository on GitHub.
- **Tags:** git, github, version control, setup, repository

## 1. Overview

This guide provides the necessary commands to turn your local project folder into a Git repository and link it to a new, empty repository on GitHub.

## 2. Prerequisites

*   You have `git` installed on your machine.
*   You have a GitHub account.
*   Your GitHub username is `dgerabagi`.

## 3. Step-by-Step Instructions

### Step 1: Create a New Repository on GitHub

1.  Go to [github.com](https://github.com) and log in.
2.  In the top-right corner, click the `+` icon and select **"New repository"**.
3.  **Repository name:** A good name would be `data-curation-environment` or `vscode-dce-extension`.
4.  **Description:** (Optional) "A VS Code extension for curating context for Large Language Models."
5.  Choose **"Private"** or **"Public"** based on your preference.
6.  **IMPORTANT:** Do **not** initialize the repository with a `README`, `.gitignore`, or `license`. We will be pushing our existing files, and this will prevent conflicts.
7.  Click **"Create repository"**.

GitHub will now show you a page with several command-line instructions. We will use the section titled **"...or push an existing repository from the command line"**.

### Step 2: Initialize Git in Your Local Project

Open a terminal (like the one integrated into VS Code) and navigate to your project's root directory (e.g., `C:\Projects\DCE`). Then, run the following commands one by one.

1.  **Initialize the repository:** This creates a new `.git` subdirectory in your project folder.
    ```bash
    git init
    ```

2.  **Add all existing files to the staging area:** The `.` adds all files in the current directory and subdirectories.
    ```bash
    git add .
    ```

3.  **Create the first commit:** This saves the staged files to the repository's history.
    ```bash
    git commit -m "Initial commit"
    ```

4.  **Rename the default branch to `main`:** This is the modern standard, replacing the older `master`.
    ```bash
    git branch -M main
    ```

### Step 3: Link and Push to GitHub

Now, you will link your local repository to the empty one you created on GitHub.

1.  **Add the remote repository:** Replace the URL with the one from your GitHub repository page. It should look like the example below.
    ```bash
    git remote add origin https://github.com/dgerabagi/data-curation-environment.git
    ```

2.  **Push your local `main` branch to GitHub:** The `-u` flag sets the upstream remote so that in the future, you can simply run `git push`.
    ```bash
    git push -u origin main
    ```

After these commands complete, refresh your GitHub repository page. You should see all of your project files. You have successfully created and linked your repository!
```
</file>

<file path="src/backend/commands/commands.ts">
// Updated on: C115 (Fix fsService reference)
import * as vscode from 'vscode';
import { Services } from '../services/services';
import { serverIPCs } from '@/client/views';
import { ServerToClientChannel } from '@/common/ipc/channels.enum';
import { VIEW_TYPES } from '@/common/view-types';

export const commands = [
    {
        commandId: 'dce.saveCurrentSelection',
        callback: async (selectedPaths: string[]) => {
            if (!selectedPaths || selectedPaths.length === 0) {
                vscode.window.showWarningMessage("No files are selected to save.");
                return;
            }
            const name = await vscode.window.showInputBox({
                prompt: 'Enter a name for the selection set',
                placeHolder: 'e.g., "API Feature" or "Frontend Refactor"'
            });
            if (name) {
                await Services.selectionService.saveSelectionSet(name, selectedPaths);
                const serverIpc = serverIPCs[VIEW_TYPES.SIDEBAR.CONTEXT_CHOOSER];
                if(serverIpc) {
                    serverIpc.sendToClient(ServerToClientChannel.SendSelectionSets, { sets: Services.selectionService.getSelectionSets() });
                }
            }
        }
    },
    {
        commandId: 'dce.loadSelectionSet',
        callback: async () => {
            const sets = Services.selectionService.getSelectionSets();
            const setNames = Object.keys(sets);
             if (setNames.length === 0) {
                vscode.window.showInformationMessage("No saved selection sets.");
                return;
            }
            const name = await vscode.window.showQuickPick(setNames, {
                placeHolder: 'Select a selection set to load'
            });

            if (name) {
                const paths = sets[name];
                if (paths) {
                    const serverIpc = serverIPCs[VIEW_TYPES.SIDEBAR.CONTEXT_CHOOSER];
                    if(serverIpc) {
                        serverIpc.sendToClient(ServerToClientChannel.ApplySelectionSet, { paths });
                        Services.loggerService.log(`Command: Loaded selection set '${name}'.`);
                        vscode.window.showInformationMessage(`Loaded selection set '${name}'.`);
                    }
                }
            }
        }
    },
    {
        commandId: 'dce.manageSelectionSets',
        callback: async () => {
            const sets = Services.selectionService.getSelectionSets();
            const setNames = Object.keys(sets);
            if (setNames.length === 0) {
                vscode.window.showInformationMessage("No selection sets to manage.");
                return;
            }
            const setToDelete = await vscode.window.showQuickPick(setNames, {
                placeHolder: 'Select a selection set to delete'
            });

            if (setToDelete) {
                await Services.selectionService.deleteSelectionSet(setToDelete);
                 const serverIpc = serverIPCs[VIEW_TYPES.SIDEBAR.CONTEXT_CHOOSER];
                 if(serverIpc) {
                     serverIpc.sendToClient(ServerToClientChannel.SendSelectionSets, { sets: Services.selectionService.getSelectionSets() });
                 }
            }
        }
    },
    {
        commandId: 'dce.refreshTree',
        callback: () => {
            const serverIpc = serverIPCs[VIEW_TYPES.SIDEBAR.CONTEXT_CHOOSER];
            if (serverIpc) {
                Services.loggerService.log("Executing dce.refreshTree command.");
                // C115 Fix: Use fileTreeService instead of fsService
                Services.fileTreeService.handleWorkspaceFilesRequest(serverIpc, true);
            } else {
                Services.loggerService.warn("Could not refresh tree: serverIpc not found.");
            }
        }
    },
    {
        commandId: 'dce.openParallelCopilot',
        callback: () => {
            Services.loggerService.log("Executing dce.openParallelCopilot command to open WebviewPanel.");
            vscode.commands.executeCommand('dce.showParallelCopilot');
        }
    }
];
</file>

<file path="src/backend/commands/register-commands.ts">
import * as vscode from "vscode";
import { commands } from "./commands";
import { Services } from "../services/services";

export function registerCommands(context: vscode.ExtensionContext) {
    Services.loggerService.log(`Registering ${commands.length} commands.`);
    commands.forEach(({ commandId, callback }) => {
        let disposable = vscode.commands.registerCommand(commandId, callback);
        context.subscriptions.push(disposable);
    });
}
</file>

<file path="src/backend/services/action.service.ts">
// Updated on: C114 (Refactor to use new services)
import * as vscode from 'vscode';
import { Services } from './services';

export type ActionType = 'move' | 'delete';

export interface Action {
    type: ActionType;
    payload: any;
}

export interface MoveActionPayload {
    fromPath: string;
    toPath: string;
}

export class ActionService {
    private undoStack: Action[] = [];
    private redoStack: Action[] = [];

    public push(action: Action) {
        this.undoStack.push(action);
        this.redoStack = [];
    }

    public async undo() {
        const action = this.undoStack.pop();
        if (!action) return;
        await this.performReverseAction(action);
        this.redoStack.push(action);
    }

    public async redo() {
        const action = this.redoStack.pop();
        if (!action) return;
        await this.performOriginalAction(action);
        this.undoStack.push(action);
    }

    private async performReverseAction(action: Action) {
        switch (action.type) {
            case 'move':
                const { fromPath, toPath } = action.payload as MoveActionPayload;
                await vscode.workspace.fs.rename(vscode.Uri.file(toPath), vscode.Uri.file(fromPath));
                break;
        }
    }

    private async performOriginalAction(action: Action) {
        switch (action.type) {
            case 'move':
                const { fromPath, toPath } = action.payload as MoveActionPayload;
                 await vscode.workspace.fs.rename(vscode.Uri.file(fromPath), vscode.Uri.file(toPath));
                break;
            case 'delete':
                await vscode.workspace.fs.delete(vscode.Uri.file(action.payload.path), { recursive: true, useTrash: true });
                break;
        }
    }
}
</file>

<file path="src/backend/services/content-extraction.service.ts">
// src/backend/services/content-extraction.service.ts
import * as vscode from "vscode";
import * as path from "path";
import * as fs from "fs/promises";
import { ServerPostMessageManager } from "@/common/ipc/server-ipc";
import { ServerToClientChannel } from "@/common/ipc/channels.enum";
import { Services } from "./services";
// @ts-ignore
import pdf from 'pdf-parse/lib/pdf-parse.js';
import * as XLSX from 'xlsx';
import mammoth from 'mammoth';

export class ContentExtractionService {
    private pdfTextCache = new Map<string, { text: string; tokenCount: number }>();
    private excelMarkdownCache = new Map<string, { markdown: string; tokenCount: number }>();
    private wordTextCache = new Map<string, { text: string; tokenCount: number }>();

    public getVirtualPdfContent(filePath: string) {
        return this.pdfTextCache.get(filePath);
    }

    public getVirtualExcelContent(filePath: string) {
        return this.excelMarkdownCache.get(filePath);
    }

    public getVirtualWordContent(filePath: string) {
        return this.wordTextCache.get(filePath);
    }

    public async handlePdfToTextRequest(filePath: string, serverIpc: ServerPostMessageManager) {
        Services.loggerService.log(`Received RequestPdfToText for: ${filePath}`);
        if (this.pdfTextCache.has(filePath)) {
            const cached = this.pdfTextCache.get(filePath)!;
            serverIpc.sendToClient(ServerToClientChannel.UpdateNodeStats, { path: filePath, tokenCount: cached.tokenCount });
            Services.loggerService.log(`PDF served from cache: ${filePath}`);
            return;
        }

        try {
            Services.loggerService.log(`[PDF] Processing: ${filePath}`);
            const buffer = await fs.readFile(filePath);
            const data = await pdf(buffer);
            const text = data.text;
            const tokenCount = Math.ceil(text.length / 4);
            
            this.pdfTextCache.set(filePath, { text, tokenCount });
            Services.loggerService.log(`PDF Parsed and cached: ${path.basename(filePath)} (${tokenCount} tokens)`);

            serverIpc.sendToClient(ServerToClientChannel.UpdateNodeStats, { path: filePath, tokenCount: tokenCount });
        } catch (error: any) {
            const errorMessage = `Failed to parse PDF: ${path.basename(filePath)}`;
            Services.loggerService.error(`[PDF] Error processing ${filePath}: ${error.stack || error.message}`);
            serverIpc.sendToClient(ServerToClientChannel.UpdateNodeStats, { path: filePath, tokenCount: 0, error: errorMessage });
        }
    }

    private _sheetToMarkdown(sheet: XLSX.WorkSheet): string {
        const data: any[][] = XLSX.utils.sheet_to_json(sheet, { header: 1 });
        if (data.length === 0) return "";
    
        const sanitizedData = data.map(row => 
            row.map(cell => {
                const cellStr = cell ? String(cell) : '';
                return cellStr.replace(/\|/g, '\\|').replace(/\r?\n/g, '<br/>');
            })
        );
    
        const header = sanitizedData[0];
        const body = sanitizedData.slice(1);
        const headerLine = `| ${header.join(' | ')} |`;
        const separatorLine = `| ${header.map(() => '---').join(' | ')} |`;
        const bodyLines = body.map(row => `| ${row.join(' | ')} |`).join('\n');
        return `${headerLine}\n${separatorLine}\n${bodyLines}`;
    }

    public async handleExcelToTextRequest(filePath: string, serverIpc: ServerPostMessageManager) {
        Services.loggerService.log(`Received RequestExcelToText for: ${filePath}`);
        if (this.excelMarkdownCache.has(filePath)) {
            const cached = this.excelMarkdownCache.get(filePath)!;
            serverIpc.sendToClient(ServerToClientChannel.UpdateNodeStats, { path: filePath, tokenCount: cached.tokenCount });
            Services.loggerService.log(`Excel served from cache: ${filePath}`);
            return;
        }

        try {
            Services.loggerService.log(`[Excel] Processing: ${filePath}`);
            const buffer = await fs.readFile(filePath);
            const workbook = XLSX.read(buffer, { type: 'buffer' });
            
            let markdown = '';
            workbook.SheetNames.forEach(sheetName => {
                markdown += `### Sheet: ${sheetName}\n\n`;
                const worksheet = workbook.Sheets[sheetName];
                markdown += this._sheetToMarkdown(worksheet);
                markdown += '\n\n';
            });

            const tokenCount = Math.ceil(markdown.length / 4);
            this.excelMarkdownCache.set(filePath, { markdown, tokenCount });
            Services.loggerService.log(`Excel Parsed and cached: ${path.basename(filePath)} (${tokenCount} tokens)`);

            serverIpc.sendToClient(ServerToClientChannel.UpdateNodeStats, { path: filePath, tokenCount: tokenCount });
        } catch (error: any) {
             const errorMessage = `Failed to parse Excel/CSV file: ${path.basename(filePath)}`;
             Services.loggerService.error(`[Excel] Error processing ${filePath}: ${error.stack || error.message}`);
             serverIpc.sendToClient(ServerToClientChannel.UpdateNodeStats, { path: filePath, tokenCount: 0, error: errorMessage });
        }
    }

    public async handleWordToTextRequest(filePath: string, serverIpc: ServerPostMessageManager) {
        Services.loggerService.log(`Received RequestWordToText for: ${filePath}`);
        if (this.wordTextCache.has(filePath)) {
            const cached = this.wordTextCache.get(filePath)!;
            serverIpc.sendToClient(ServerToClientChannel.UpdateNodeStats, { path: filePath, tokenCount: cached.tokenCount });
            Services.loggerService.log(`Word served from cache: ${filePath}`);
            return;
        }

        const extension = path.extname(filePath).toLowerCase();
        if (extension === '.doc') {
            const unsupportedMessage = "UNSUPPORTED_FORMAT";
            this.wordTextCache.set(filePath, { text: unsupportedMessage, tokenCount: 0 });
            Services.loggerService.warn(`[Word] Legacy .doc format is not supported for file: ${filePath}`);
            serverIpc.sendToClient(ServerToClientChannel.UpdateNodeStats, { path: filePath, tokenCount: 0, error: "Legacy .doc format not supported." });
            return;
        }

        try {
            Services.loggerService.log(`[Word] Processing: ${filePath}`);
            const buffer = await fs.readFile(filePath);
            const result = await mammoth.extractRawText({ buffer });
            const text = result.value;
            const tokenCount = Math.ceil(text.length / 4);
            
            this.wordTextCache.set(filePath, { text, tokenCount });
            Services.loggerService.log(`Word Parsed and cached: ${path.basename(filePath)} (${tokenCount} tokens)`);

            serverIpc.sendToClient(ServerToClientChannel.UpdateNodeStats, { path: filePath, tokenCount: tokenCount });
        } catch (error: any) {
            let errorMessage = `Failed to parse Word file: ${path.basename(filePath)}`;
            if (error instanceof Error && error.message.includes("Can't find end of central directory")) {
                errorMessage = "File may be corrupted or is not a valid .docx format.";
            }
            Services.loggerService.error(`[Word] Error processing ${filePath}: ${error.stack || error.message}`);
            serverIpc.sendToClient(ServerToClientChannel.UpdateNodeStats, { path: filePath, tokenCount: 0, error: errorMessage });
        }
    }
}
</file>

<file path="src/backend/services/file-operation.service.ts">
// src/backend/services/file-operation.service.ts
import * as vscode from "vscode";
import * as path from "path";
import { ServerPostMessageManager } from "@/common/ipc/server-ipc";
import { ServerToClientChannel } from "@/common/ipc/channels.enum";
import { Services } from "./services";
import { Action, MoveActionPayload } from "./action.service";
import { BatchWriteFile } from "@/common/ipc/channels.type";

const normalizePath = (p: string) => p.replace(/\\/g, '/');

export class FileOperationService {
    private filesToIgnoreForAutoAdd: Set<string> = new Set();

    public async handleBatchFileWrite(files: BatchWriteFile[]) {
        Services.loggerService.log(`[File Operation] Received request to write ${files.length} files.`);
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (!workspaceFolders?.[0]) {
            vscode.window.showErrorMessage("Cannot write files: No workspace folder is open.");
            return;
        }
        const rootPath = workspaceFolders[0].uri.fsPath;

        try {
            for (const file of files) {
                const absolutePath = path.resolve(rootPath, file.path);
                const uri = vscode.Uri.file(absolutePath);
                const contentBuffer = Buffer.from(file.content, 'utf-8');
                await vscode.workspace.fs.writeFile(uri, contentBuffer);
                Services.loggerService.log(`Successfully wrote content to: ${file.path}`);
            }
            vscode.window.showInformationMessage(`Successfully accepted and wrote ${files.length} files to the workspace.`);
        } catch (error) {
            Services.loggerService.error(`Failed during batch file write: ${error}`);
            vscode.window.showErrorMessage(`Failed to write files: ${error}`);
        }
    }

    public async handleFileContentRequest(filePath: string, serverIpc: ServerPostMessageManager) {
        Services.loggerService.log(`handleFileContentRequest initiated for: ${filePath}`);
        try {
            const workspaceFolders = vscode.workspace.workspaceFolders;
            if (!workspaceFolders?.[0]) {
                throw new Error("No workspace folder open.");
            }
            const absolutePath = path.resolve(workspaceFolders[0].uri.fsPath, filePath);
            const uri = vscode.Uri.file(absolutePath);
            const contentBuffer = await vscode.workspace.fs.readFile(uri);
            const content = Buffer.from(contentBuffer).toString('utf-8');
            Services.loggerService.log(`Successfully read content for: ${filePath}. Sending to client.`);
            serverIpc.sendToClient(ServerToClientChannel.SendFileContent, { path: filePath, content });
        } catch (error) {
            Services.loggerService.error(`Failed to read file content for ${filePath}: ${error}`);
            serverIpc.sendToClient(ServerToClientChannel.SendFileContent, { path: filePath, content: `// Error: Could not read file content for ${filePath}. It may not exist in the workspace.` });
        }
    }

    public async handleFileExistenceRequest(paths: string[], serverIpc: ServerPostMessageManager) {
        Services.loggerService.log(`[File Existence] Received request to check paths: ${JSON.stringify(paths)}`);
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (!workspaceFolders || workspaceFolders.length === 0) {
            Services.loggerService.error("[File Existence] Cannot check for files, no workspace folder is open.");
            serverIpc.sendToClient(ServerToClientChannel.SendFileExistence, { existenceMap: {} });
            return;
        }
        const rootPath = workspaceFolders[0].uri.fsPath;
    
        const existenceMap: { [path: string]: boolean } = {};
        const checks = paths.map(async (p_raw) => {
            const p = p_raw.trim().replace(/^[`"']|[`"']$/g, '');
            if (!p) return;
    
            let absolutePath = path.resolve(rootPath, p);
            let normalizedPath = normalizePath(absolutePath);
    
            try {
                await vscode.workspace.fs.stat(vscode.Uri.file(normalizedPath));
                existenceMap[p_raw] = true;
            } catch {
                if (/^A\d+/.test(p)) {
                    const artifactPath = path.resolve(rootPath, 'src/Artifacts', p);
                    const normalizedArtifactPath = normalizePath(artifactPath);
                    try {
                        await vscode.workspace.fs.stat(vscode.Uri.file(normalizedArtifactPath));
                        existenceMap[p_raw] = true;
                        return;
                    } catch {}
                }
                existenceMap[p_raw] = false;
            }
        });
        await Promise.all(checks);
        serverIpc.sendToClient(ServerToClientChannel.SendFileExistence, { existenceMap });
    }

    private async _findAvailableCopyName(destinationPath: string): Promise<string> {
        try {
            await vscode.workspace.fs.stat(vscode.Uri.file(destinationPath));
        } catch (error) {
            return destinationPath;
        }
    
        const dir = path.dirname(destinationPath);
        const ext = path.extname(destinationPath);
        const baseName = path.basename(destinationPath, ext);
    
        let copyNum = 1;
        let nextPath = path.join(dir, `${baseName}-copy${ext}`);
        
        while (true) {
            try {
                await vscode.workspace.fs.stat(vscode.Uri.file(nextPath));
                copyNum++;
                nextPath = path.join(dir, `${baseName}-copy-${copyNum}${ext}`);
            } catch (error) {
                return nextPath;
            }
        }
    }

    public async handleCopyFileRequest(sourcePath: string, destinationDir: string) {
        try {
            const sourceName = path.basename(sourcePath);
            const initialDestinationPath = path.join(destinationDir, sourceName);
            const finalDestinationPath = await this._findAvailableCopyName(initialDestinationPath);
            const sourceUri = vscode.Uri.file(sourcePath);
            const destinationUri = vscode.Uri.file(finalDestinationPath);

            await vscode.workspace.fs.copy(sourceUri, destinationUri, { overwrite: false });
        } catch (error: any) {
            vscode.window.showErrorMessage(`Failed to copy file: ${error.message}`);
        }
    }

    public async handleCopyFileFromUri(sourceUriString: string, targetDir: string) {
        try {
            const sourceUri = vscode.Uri.parse(sourceUriString);
            const fileName = path.basename(sourceUri.fsPath);
            const targetUri = vscode.Uri.file(path.join(targetDir, fileName));
            await vscode.workspace.fs.copy(sourceUri, targetUri);
        } catch (error: any) {
            vscode.window.showErrorMessage(`Failed to copy file from URI: ${error.message}`);
        }
    }

    public async handleAddFileFromBuffer(targetPath: string, data: Uint8Array) {
        try {
            await vscode.workspace.fs.writeFile(vscode.Uri.file(targetPath), data);
        } catch (error: any) {
            vscode.window.showErrorMessage(`Failed to add file from buffer: ${error.message}`);
        }
    }

    public async handleOpenFileRequest(filePath: string) {
        try {
            await vscode.commands.executeCommand('vscode.open', vscode.Uri.file(filePath));
        } catch (error: any) {
            vscode.window.showErrorMessage(`Failed to open file ${filePath}: ${error.message}`);
        }
    }

    public async handleNewFileRequest(parentDirectory: string) {
        const newFileName = await vscode.window.showInputBox({ prompt: "Enter the name of the new file", value: "new-file.ts" });
        if (newFileName) {
            try {
                await vscode.workspace.fs.writeFile(vscode.Uri.file(path.join(parentDirectory, newFileName)), new Uint8Array());
            } catch (error: any) {
                vscode.window.showErrorMessage(`Failed to create file: ${error.message}`);
            }
        }
    }

    public async handleNewFolderRequest(parentDirectory: string) {
        const newFolderName = await vscode.window.showInputBox({ prompt: "Enter the name of the new folder", value: "new-folder" });
        if (newFolderName) {
            try {
                await vscode.workspace.fs.createDirectory(vscode.Uri.file(path.join(parentDirectory, newFolderName)));
            } catch (error: any) {
                vscode.window.showErrorMessage(`Failed to create folder: ${error.message}`);
            }
        }
    }

    public async handleFileRenameRequest(oldPath: string, newName: string) {
        try {
            await vscode.workspace.fs.rename(vscode.Uri.file(oldPath), vscode.Uri.file(path.join(path.dirname(oldPath), newName)));
        } catch (error: any) {
            vscode.window.showErrorMessage(`Failed to rename: ${error.message}`);
        }
    }

    public async handleMoveFileRequest(oldPath: string, newPath: string) {
        try {
            const lastSelection = await Services.selectionService.getLastSelection();
            if (!lastSelection.some(p => p.startsWith(oldPath))) {
                this.filesToIgnoreForAutoAdd.add(newPath);
                setTimeout(() => this.filesToIgnoreForAutoAdd.delete(newPath), 2000);
            }

            await vscode.workspace.fs.rename(vscode.Uri.file(oldPath), vscode.Uri.file(newPath));
            await Services.selectionService.updatePathInSelections(oldPath, newPath);
            Services.actionService.push({ type: 'move', payload: { fromPath: oldPath, toPath: newPath } as MoveActionPayload });
        } catch (error: any) {
            vscode.window.showErrorMessage(`Failed to move file: ${error.message}`);
        }
    }

    public async handleFileDeleteRequest(filePath: string) {
        const confirmation = await vscode.window.showWarningMessage(`Are you sure you want to delete ${path.basename(filePath)}?`, { modal: true }, 'Delete');
        if (confirmation === 'Delete') {
            try {
                await vscode.workspace.fs.delete(vscode.Uri.file(filePath), { recursive: true, useTrash: true });
            } catch (error: any) {
                vscode.window.showErrorMessage(`Failed to delete: ${error.message}`);
            }
        }
    }

    public async handleBatchFileDeleteRequest(paths: string[]) {
        if (paths.length === 0) return;
        const confirmation = await vscode.window.showWarningMessage(`Are you sure you want to delete ${paths.length} item(s)?`, { modal: true }, 'Delete');
        if (confirmation === 'Delete') {
            try {
                await Promise.all(paths.map(p => vscode.workspace.fs.delete(vscode.Uri.file(p), { recursive: true, useTrash: true })));
            } catch (error: any) {
                vscode.window.showErrorMessage(`Failed to delete items: ${error.message}`);
            }
        }
    }

    public handleRevealInExplorerRequest(filePath: string) {
        vscode.commands.executeCommand('revealInExplorer', vscode.Uri.file(filePath));
    }

    public handleCopyPathRequest(filePath: string, relative: boolean) {
        const workspaceFolders = vscode.workspace.workspaceFolders;
        let pathToCopy = filePath;
        if (relative && workspaceFolders?.[0]) {
            pathToCopy = path.relative(workspaceFolders[0].uri.fsPath, filePath);
        }
        vscode.env.clipboard.writeText(pathToCopy);
        vscode.window.showInformationMessage(`Copied to clipboard: ${pathToCopy}`);
    }

    public addFileToIgnoreForAutoAdd(filePath: string) {
        this.filesToIgnoreForAutoAdd.add(filePath);
    }

    public hasFileToIgnoreForAutoAdd(filePath: string): boolean {
        return this.filesToIgnoreForAutoAdd.has(filePath);
    }

    public removeFileToIgnoreForAutoAdd(filePath: string) {
        this.filesToIgnoreForAutoAdd.delete(filePath);
    }
}
</file>

<file path="src/backend/services/file-tree.service.ts">
// Updated on: C115 (Fix type error in getGitStatusMap)
import * as vscode from "vscode";
import * as path from "path";
import * as fs from "fs/promises";
import { ServerPostMessageManager } from "@/common/ipc/server-ipc";
import { ServerToClientChannel } from "@/common/ipc/channels.enum";
import { FileNode } from "@/common/types/file-node";
import { Services } from "./services";
import { serverIPCs } from "@/client/views";
import { VIEW_TYPES } from "@/common/view-types";
import { API as GitAPI, Status } from "../types/git";
import { ProblemCountsMap } from "@/common/ipc/channels.type";

const IMAGE_EXTENSIONS = new Set(['.png', '.jpg', '.jpeg', '.gif', '.bmp', '.svg', '.webp', '.ico']);
const EXCEL_EXTENSIONS = new Set(['.xlsx', '.xls', '.csv']);
const WORD_EXTENSIONS = new Set(['.docx', '.doc']);
const EXCLUSION_PATTERNS = ['node_modules', 'dist', 'out', '.git', 'dce_cache', '.vscode'];

const normalizePath = (p: string) => p.replace(/\\/g, '/');

export class FileTreeService {
    private fileTreeCache: FileNode[] | null = null;
    private watcher: vscode.FileSystemWatcher | null = null;
    private refreshDebounceTimer: NodeJS.Timeout | null = null;
    private diagnosticsDebounceTimer: NodeJS.Timeout | null = null;
    private gitApi?: GitAPI;

    constructor(gitApi?: GitAPI) {
        this.gitApi = gitApi;
        if (this.gitApi) {
            this.gitApi.onDidOpenRepository(() => this.triggerFullRefresh());
            this.gitApi.repositories.forEach(repo => {
                repo.state.onDidChange(() => this.triggerFullRefresh());
            });
        }
    }

    private triggerFullRefresh() {
        if (this.refreshDebounceTimer) clearTimeout(this.refreshDebounceTimer);
        this.refreshDebounceTimer = setTimeout(() => {
            this.fileTreeCache = null;
            const serverIpc = serverIPCs[VIEW_TYPES.SIDEBAR.CONTEXT_CHOOSER];
            if (serverIpc) {
                serverIpc.sendToClient(ServerToClientChannel.ForceRefresh, { reason: 'fileOp' });
            }
        }, 500);
    }

    private triggerDiagnosticsUpdate() {
        if (this.diagnosticsDebounceTimer) clearTimeout(this.diagnosticsDebounceTimer);
        this.diagnosticsDebounceTimer = setTimeout(() => {
            const serverIpc = serverIPCs[VIEW_TYPES.SIDEBAR.CONTEXT_CHOOSER];
            if (serverIpc) {
                serverIpc.sendToClient(ServerToClientChannel.UpdateProblemCounts, { problemMap: this.getProblemCountsMap() });
            }
        }, 750);
    }

    public initializeWatcher() {
        if (this.watcher) this.watcher.dispose();
        
        this.watcher = vscode.workspace.createFileSystemWatcher('**/*');
        const onFileChange = (uri: vscode.Uri) => {
            if (EXCLUSION_PATTERNS.some(pattern => normalizePath(uri.fsPath).includes(`/${pattern}/`))) return;
            this.triggerFullRefresh();
        };

        this.watcher.onDidCreate(async (uri: vscode.Uri) => {
            const normalizedPath = normalizePath(uri.fsPath);
            if (Services.fileOperationService.hasFileToIgnoreForAutoAdd(normalizedPath)) {
                Services.fileOperationService.removeFileToIgnoreForAutoAdd(normalizedPath);
            } else if (Services.selectionService.getAutoAddState()) {
                const currentSelection = await Services.selectionService.getLastSelection();
                await Services.selectionService.saveCurrentSelection([...new Set([...currentSelection, normalizedPath])]);
            }
            onFileChange(uri);
        });
        this.watcher.onDidChange(onFileChange);
        this.watcher.onDidDelete(onFileChange);
        vscode.languages.onDidChangeDiagnostics(() => this.triggerDiagnosticsUpdate());
    }

    private async getFileStats(filePath: string): Promise<Omit<FileNode, 'name' | 'absolutePath' | 'children'>> {
        const extension = path.extname(filePath).toLowerCase();
        try {
            const stats = await fs.stat(filePath);
            const isImage = IMAGE_EXTENSIONS.has(extension);
            const isPdf = extension === '.pdf';
            const isExcel = EXCEL_EXTENSIONS.has(extension);
            const isWordDoc = WORD_EXTENSIONS.has(extension);
            
            if (isImage) return { tokenCount: 0, sizeInBytes: stats.size, isImage, extension, isPdf, isExcel, isWordDoc, fileCount: 1 };
            if (isPdf) return { tokenCount: Services.contentExtractionService.getVirtualPdfContent(filePath)?.tokenCount || 0, sizeInBytes: stats.size, isImage, extension, isPdf, isExcel, isWordDoc, fileCount: 1 };
            if (isExcel) return { tokenCount: Services.contentExtractionService.getVirtualExcelContent(filePath)?.tokenCount || 0, sizeInBytes: stats.size, isImage, extension, isPdf, isExcel, isWordDoc, fileCount: 1 };
            if (isWordDoc) return { tokenCount: Services.contentExtractionService.getVirtualWordContent(filePath)?.tokenCount || 0, sizeInBytes: stats.size, isImage, extension, isPdf, isExcel, isWordDoc, fileCount: 1 };

            if (stats.size > 5_000_000) return { tokenCount: 0, sizeInBytes: stats.size, isImage, extension, isPdf, isExcel, isWordDoc, fileCount: 1 };
            
            const content = await fs.readFile(filePath, 'utf-8');
            return { tokenCount: Math.ceil(content.length / 4), sizeInBytes: stats.size, isImage, extension, isPdf, isExcel, isWordDoc, fileCount: 1 };
        } catch (error: any) {
            return { tokenCount: 0, sizeInBytes: 0, isImage: false, extension, isPdf: false, isExcel: false, isWordDoc: false, fileCount: 1, error: error.message };
        }
    }

    public async handleWorkspaceFilesRequest(serverIpc: ServerPostMessageManager, forceRefresh: boolean = false) {
        if (!forceRefresh && this.fileTreeCache) {
            serverIpc.sendToClient(ServerToClientChannel.SendWorkspaceFiles, { files: this.fileTreeCache });
            return;
        }

        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (!workspaceFolders?.[0]) {
            serverIpc.sendToClient(ServerToClientChannel.SendWorkspaceFiles, { files: [] });
            return;
        }
        
        const fileTree = await this.buildTreeFromTraversal(workspaceFolders[0].uri);
        this.fileTreeCache = [fileTree];
        serverIpc.sendToClient(ServerToClientChannel.SendWorkspaceFiles, { files: this.fileTreeCache });
    }

    private getGitStatusMap(): Map<string, string> {
        if (!this.gitApi?.repositories[0]) return new Map();
        
        const repo = this.gitApi.repositories[0];
        const getStatusChar = (s: Status) => ({ [Status.INDEX_ADDED]: 'A', [Status.MODIFIED]: 'M', [Status.DELETED]: 'D', [Status.UNTRACKED]: 'U', [Status.IGNORED]: 'I', [Status.CONFLICT]: 'C' }[s] || '');
        
        const changes = [...repo.state.workingTreeChanges, ...repo.state.indexChanges, ...repo.state.mergeChanges];
        
        // C115: Use reduce for a more type-safe map creation
        return changes.reduce((acc, change) => {
            const statusChar = getStatusChar(change.status);
            if (statusChar) {
                acc.set(normalizePath(change.uri.fsPath), statusChar);
            }
            return acc;
        }, new Map<string, string>());
    }

    private getProblemCountsMap(): ProblemCountsMap {
        const problemMap: ProblemCountsMap = {};
        for (const [uri, diagnosticArr] of vscode.languages.getDiagnostics()) {
            const path = normalizePath(uri.fsPath);
            problemMap[path] = problemMap[path] || { error: 0, warning: 0 };
            for (const diag of diagnosticArr) {
                if (diag.severity === vscode.DiagnosticSeverity.Error) problemMap[path].error++;
                else if (diag.severity === vscode.DiagnosticSeverity.Warning) problemMap[path].warning++;
            }
        }
        return problemMap;
    }

    private async buildTreeFromTraversal(rootUri: vscode.Uri): Promise<FileNode> {
        const rootPath = rootUri.fsPath;
        const gitStatusMap = this.getGitStatusMap();
        const problemCountsMap = this.getProblemCountsMap();

        const rootNode: FileNode = {
            name: path.basename(rootPath),
            absolutePath: normalizePath(rootPath),
            children: await this._traverseDirectory(rootUri, gitStatusMap, problemCountsMap),
            tokenCount: 0, fileCount: 0, isImage: false, sizeInBytes: 0, extension: '', isPdf: false, isExcel: false, isWordDoc: false,
            gitStatus: gitStatusMap.get(normalizePath(rootPath)),
            problemCounts: problemCountsMap[normalizePath(rootPath)]
        };
        this._aggregateStats(rootNode);
        return rootNode;
    }
    
    private async _traverseDirectory(dirUri: vscode.Uri, gitStatusMap: Map<string, string>, problemCountsMap: ProblemCountsMap): Promise<FileNode[]> {
        const children: FileNode[] = [];
        try {
            for (const [name, type] of await vscode.workspace.fs.readDirectory(dirUri)) {
                if (EXCLUSION_PATTERNS.includes(name)) continue;

                const childUri = vscode.Uri.joinPath(dirUri, name);
                const childPath = normalizePath(childUri.fsPath);

                if (type === vscode.FileType.Directory) {
                    const dirNode: FileNode = { name, absolutePath: childPath, children: await this._traverseDirectory(childUri, gitStatusMap, problemCountsMap), tokenCount: 0, fileCount: 0, isImage: false, sizeInBytes: 0, extension: '', isPdf: false, isExcel: false, isWordDoc: false, gitStatus: gitStatusMap.get(childPath), problemCounts: problemCountsMap[childPath] };
                    this._aggregateStats(dirNode);
                    children.push(dirNode);
                } else if (type === vscode.FileType.File) {
                    const stats = await this.getFileStats(childPath);
                    children.push({ name, absolutePath: childPath, ...stats, gitStatus: gitStatusMap.get(childPath), problemCounts: problemCountsMap[childPath] });
                }
            }
        } catch (error: any) {
            Services.loggerService.error(`Error traversing directory ${dirUri.fsPath}: ${error.message}`);
        }
        return children.sort((a, b) => (!!a.children === !!b.children) ? a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' }) : (!!a.children ? -1 : 1));
    }

    private _aggregateStats(node: FileNode): void {
        if (!node.children) return;
        let totalTokens = 0, totalFiles = 0, totalBytes = 0, totalErrors = node.problemCounts?.error || 0, totalWarnings = node.problemCounts?.warning || 0;
        for (const child of node.children) {
            totalTokens += child.tokenCount;
            totalFiles += child.fileCount;
            totalBytes += child.sizeInBytes;
            if(child.problemCounts) {
                totalErrors += child.problemCounts.error;
                totalWarnings += child.problemCounts.warning;
            }
        }
        node.tokenCount = totalTokens;
        node.fileCount = totalFiles;
        node.sizeInBytes = totalBytes;
        if(totalErrors > 0 || totalWarnings > 0) node.problemCounts = { error: totalErrors, warning: totalWarnings };
    }
}
</file>

<file path="src/backend/services/flattener.service.ts">
// Updated on: C114 (Refactor to use new services)
import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs/promises';
import { Services } from './services';
import { VIEW_TYPES } from '@/common/view-types';
import { serverIPCs } from '@/client/views';
import { ServerToClientChannel } from '@/common/ipc/channels.enum';
import { formatBytes } from '@/common/utils/formatting';

interface FileStats {
    filePath: string;
    lines: number;
    characters: number;
    tokens: number;
    content: string;
    error: string | null;
    isBinary: boolean;
    sizeInBytes: number;
}

const BINARY_EXTENSIONS = new Set(['.png', '.jpg', '.jpeg', '.gif', '.bmp', '.svg', '.webp', '.ico', '.exe', '.dll', '.bin', '.zip', '.gz', '.7z', '.mp3', '.wav', '.mov', '.mp4']);
const EXCEL_EXTENSIONS = new Set(['.xlsx', '.xls', '.csv']);
const WORD_EXTENSIONS = new Set(['.docx', '.doc']);


export class FlattenerService {

    public async flatten(selectedPaths: string[]) {
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (!workspaceFolders || workspaceFolders.length === 0) {
            vscode.window.showErrorMessage("Cannot flatten context: No workspace folder is open.");
            return;
        }
        if (selectedPaths.length === 0) {
            vscode.window.showWarningMessage("Cannot flatten context: No files or folders are selected.");
            return;
        }

        const rootPath = workspaceFolders[0].uri.fsPath;
        const outputFilePath = path.join(rootPath, 'flattened_repo.md');

        try {
            const allFilePaths = await this.expandDirectories(selectedPaths);
            const uniqueFilePaths = [...new Set(allFilePaths)];

            const fileStatsPromises = uniqueFilePaths.map(filePath => this.getFileStatsAndContent(filePath));
            const results = await Promise.all(fileStatsPromises);
            const validResults = results.filter(r => !r.error);


            const outputContent = this.generateOutputContent(results, rootPath, outputFilePath);

            await fs.writeFile(outputFilePath, outputContent, 'utf-8');
            vscode.window.showInformationMessage(`Successfully flattened ${validResults.length} files to flattened_repo.md.`);

            Services.loggerService.log(`Opening flattened file: ${outputFilePath}`);
            await Services.fileOperationService.handleOpenFileRequest(outputFilePath);

            const serverIpc = serverIPCs[VIEW_TYPES.SIDEBAR.CONTEXT_CHOOSER];
            if (serverIpc) {
                setTimeout(() => {
                    serverIpc.sendToClient(ServerToClientChannel.FocusFile, { path: outputFilePath });
                }, 500);
            }

        } catch (error: any) {
            vscode.window.showErrorMessage(`Failed to flatten context: ${error.message}`);
            console.error(error);
        }
    }

    private async expandDirectories(paths: string[]): Promise<string[]> {
        const allFiles: string[] = [];
        for (const p of paths) {
            try {
                const stats = await fs.stat(p);
                if (stats.isDirectory()) {
                    allFiles.push(...await this.getAllFilesRecursive(p));
                } else {
                    allFiles.push(p);
                }
            } catch (e) {
                console.warn(`Could not stat path ${p}, skipping.`);
            }
        }
        return allFiles;
    }

    private async getAllFilesRecursive(dirPath: string): Promise<string[]> {
        let files: string[] = [];
        try {
            const entries = await fs.readdir(dirPath, { withFileTypes: true });
            for (const entry of entries) {
                const fullPath = path.join(dirPath, entry.name);
                if (entry.isDirectory()) {
                    if (entry.name.toLowerCase() === 'node_modules') continue;
                    files = files.concat(await this.getAllFilesRecursive(fullPath));
                } else {
                    files.push(fullPath);
                }
            }
        } catch (e) {
            console.error(`Error reading directory ${dirPath}:`, e);
        }
        return files;
    }

    private async _parseImageMetadata(filePath: string): Promise<any> {
        try {
            const buffer = await fs.readFile(filePath);
            const sizeInBytes = buffer.length;
            const metadata: any = { sizeInBytes };

            if (buffer.length > 24 && buffer.toString('hex', 0, 8) === '89504e470d0a1a0a') { // PNG
                const ihdrIndex = buffer.indexOf('IHDR');
                if (ihdrIndex !== -1) metadata.dimensions = { width: buffer.readUInt32BE(ihdrIndex + 4), height: buffer.readUInt32BE(ihdrIndex + 8) };
            } else if (buffer.length > 10 && buffer.toString('utf8', 0, 3) === 'GIF') { // GIF
                 metadata.dimensions = { width: buffer.readUInt16LE(6), height: buffer.readUInt16LE(8) };
            } else if (buffer.length > 11 && buffer[0] === 0xff && buffer[1] === 0xd8) { // JPEG
                let pos = 2;
                while (pos < buffer.length - 9) {
                    if (buffer[pos] === 0xff && (buffer[pos + 1] & 0xf0) === 0xc0) {
                        metadata.dimensions = { width: buffer.readUInt16BE(pos + 7), height: buffer.readUInt16BE(pos + 5) };
                        break;
                    }
                    pos += buffer[pos + 2] ? buffer.readUInt16BE(pos + 2) + 2 : 1;
                }
            }
            return metadata;
        } catch (err: any) {
            try { return { sizeInBytes: (await fs.stat(filePath)).size }; } catch { return { sizeInBytes: -1 }; }
        }
    }

    private async getFileStatsAndContent(filePath: string): Promise<FileStats> {
        const extension = path.extname(filePath).toLowerCase();
        
        if (extension === '.pdf') {
            const virtualContent = Services.contentExtractionService.getVirtualPdfContent(filePath);
            if (virtualContent) return { filePath, content: virtualContent.text, lines: virtualContent.text.split('\n').length, characters: virtualContent.text.length, tokens: virtualContent.tokenCount, error: null, isBinary: false, sizeInBytes: 0 };
            return { filePath, lines: 0, characters: 0, tokens: 0, content: '<!-- PDF content not processed or cached -->', error: null, isBinary: false, sizeInBytes: 0 };
        }

        if (EXCEL_EXTENSIONS.has(extension)) {
            const virtualContent = Services.contentExtractionService.getVirtualExcelContent(filePath);
            if (virtualContent) return { filePath, content: virtualContent.markdown, lines: virtualContent.markdown.split('\n').length, characters: virtualContent.markdown.length, tokens: virtualContent.tokenCount, error: null, isBinary: false, sizeInBytes: 0 };
            return { filePath, lines: 0, characters: 0, tokens: 0, content: '<!-- Excel/CSV content not processed or cached -->', error: null, isBinary: false, sizeInBytes: 0 };
        }

        if (WORD_EXTENSIONS.has(extension)) {
            const virtualContent = Services.contentExtractionService.getVirtualWordContent(filePath);
            if (virtualContent) {
                const content = virtualContent.text === "UNSUPPORTED_FORMAT" ? `<!-- Content of .doc file '${path.basename(filePath)}' could not be extracted. Legacy .doc format is not supported. Please convert to .docx. -->` : virtualContent.text;
                return { filePath, content: content, lines: content.split('\n').length, characters: content.length, tokens: virtualContent.tokenCount, error: null, isBinary: false, sizeInBytes: 0 };
            }
            return { filePath, lines: 0, characters: 0, tokens: 0, content: '<!-- Word content not processed or cached -->', error: null, isBinary: false, sizeInBytes: 0 };
        }

        if (BINARY_EXTENSIONS.has(extension)) {
            try {
                const imageMetadata = await this._parseImageMetadata(filePath);
                const metadata = { name: path.basename(filePath), directory: path.dirname(filePath), fileType: extension.substring(1).toUpperCase(), sizeInBytes: imageMetadata.sizeInBytes, ...(imageMetadata.dimensions && { dimensions: imageMetadata.dimensions }) };
                const metadataContent = `<metadata>\n${JSON.stringify(metadata, null, 2)}\n</metadata>`;
                return { filePath, lines: 0, characters: 0, tokens: 0, content: metadataContent, error: null, isBinary: true, sizeInBytes: imageMetadata.sizeInBytes };
            } catch (error: any) {
                 return { filePath, lines: 0, characters: 0, tokens: 0, content: '', error: `Could not get stats for binary file: ${error.message}`, isBinary: true, sizeInBytes: -1 };
            }
        }

        try {
            const content = await fs.readFile(filePath, 'utf-8');
            const stats = await fs.stat(filePath);
            return { filePath, lines: content.split('\n').length, characters: content.length, tokens: Math.ceil(content.length / 4), content, error: null, isBinary: false, sizeInBytes: stats.size };
        } catch (error: any) {
            return { filePath, lines: 0, characters: 0, tokens: 0, content: '', error: error.message, isBinary: false, sizeInBytes: -1 };
        }
    }

    private generateOutputContent(results: FileStats[], rootDir: string, outputFilename: string): string {
        const validResults = results.filter(r => !r.error);
        const totalTokens = validResults.reduce((sum, r) => sum + r.tokens, 0);
        
        let output = `<!--\n  File: ${path.basename(outputFilename)}\n  Source Directory: ${rootDir}\n  Date Generated: ${new Date().toISOString()}\n  ---\n`;
        output += `  Total Files: ${validResults.length}\n  Approx. Tokens: ${totalTokens}\n-->\n\n`;
        
        output += `<!-- Top 10 Text Files by Token Count -->\n`;
        [...validResults].filter(r => r.tokens > 0).sort((a, b) => b.tokens - a.tokens).slice(0, 10)
            .forEach((r, i) => output += `${i + 1}. ${path.relative(rootDir, r.filePath)} (${r.tokens} tokens)\n`);
        output += `\n`;

        output += `<!-- Full File List -->\n`;
        results.forEach((r, i) => {
            const relPath = path.relative(rootDir, r.filePath);
            if (r.error) output += `${i + 1}. ${relPath} - ERROR: ${r.error}\n`;
            else if (r.isBinary) output += `${i + 1}. ${relPath} - [Binary] Size: ${formatBytes(r.sizeInBytes)}\n`;
            else output += `${i + 1}. ${relPath} - Lines: ${r.lines} - Chars: ${r.characters} - Tokens: ${r.tokens}\n`;
        });
        output += `\n`;

        for (const { filePath, content, error } of results) {
            const relativePath = path.relative(rootDir, filePath).replace(/\\/g, '/');
            output += `<file path="${relativePath}">\n`;
            output += error ? `Error reading file: ${error}\n` : content;
            if (content && !content.endsWith('\n')) output += '\n';
            output += `</file>\n\n`;
        }
        return output;
    }
}
</file>

<file path="src/backend/services/highlighting.service.ts">
// Updated on: C126 (Truncate log output for code snippets)
import { createStarryNight, common } from '@wooorm/starry-night';
import sourceTsx from '@wooorm/starry-night/source.tsx';
import sourceJs from '@wooorm/starry-night/source.js';
import sourceTs from '@wooorm/starry-night/source.ts';
import sourceCss from '@wooorm/starry-night/source.css';
import sourceScss from '@wooorm/starry-night/source.css.scss';
import textHtml from '@wooorm/starry-night/text.html.basic';
import { toHtml } from 'hast-util-to-html';
import { Services } from './services';
import { ServerPostMessageManager } from '@/common/ipc/server-ipc';
import { ServerToClientChannel } from '@/common/ipc/channels.enum';

export class HighlightingService {
    private starryNight: any = null;

    constructor() {
        this.initializeStarryNight();
    }

    private async initializeStarryNight() {
        try {
            const grammars = [...common, sourceTsx, sourceJs, sourceTs, sourceCss, sourceScss, textHtml];
            this.starryNight = await createStarryNight(grammars);
            Services.loggerService.log('Starry Night syntax highlighter initialized.');
        } catch (error) {
            Services.loggerService.error(`Failed to initialize Starry Night: ${error}`);
        }
    }

    public async handleSyntaxHighlightRequest(code: string, lang: string, id: string, serverIpc: ServerPostMessageManager) {
        const truncatedCode = code.length > 20 ? `${code.substring(0, 20)}[...]` : code;
        Services.loggerService.log(`[SYNTAX-HIGHLIGHT] Received request for lang: ${lang}, code: ${truncatedCode}`);
        
        if (!this.starryNight) {
            Services.loggerService.error('Starry Night not initialized, cannot highlight.');
            serverIpc.sendToClient(ServerToClientChannel.SendSyntaxHighlight, { highlightedHtml: `<pre><code>${code}</code></pre>`, id });
            return;
        }

        const scope = this.starryNight.flagToScope(lang);
        if (!scope) {
            Services.loggerService.warn(`[WARN] No Starry Night scope found for language: ${lang}`);
            serverIpc.sendToClient(ServerToClientChannel.SendSyntaxHighlight, { highlightedHtml: `<pre><code>${code}</code></pre>`, id });
            return;
        }

        try {
            const tree = this.starryNight.highlight(code, scope);
            const hastHtml = toHtml(tree);
            const finalHtml = `<pre><code>${hastHtml}</code></pre>`;
            serverIpc.sendToClient(ServerToClientChannel.SendSyntaxHighlight, { highlightedHtml: finalHtml, id });
        } catch (error) {
            Services.loggerService.error(`Starry Night highlighting failed for lang ${lang}: ${error}`);
            serverIpc.sendToClient(ServerToClientChannel.SendSyntaxHighlight, { highlightedHtml: `<pre><code>${code}</code></pre>`, id });
        }
    }
}
</file>

<file path="src/backend/services/history.service.ts">
// src/backend/services/history.service.ts
import * as vscode from 'vscode';
import * as path from 'path';
import { Services } from './services';
import { PcppCycle, PcppHistoryFile } from '@/common/types/pcpp.types';
import { serverIPCs } from '@/client/views';
import { VIEW_TYPES } from '@/common/view-types';
import { ServerToClientChannel } from '@/common/ipc/channels.enum';

export class HistoryService {
    private historyFilePath: string | undefined;

    constructor() {
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (workspaceFolders && workspaceFolders.length > 0) {
            this.historyFilePath = path.join(workspaceFolders[0].uri.fsPath, '.vscode', 'dce_history.json');
        }
    }

    private async _readHistoryFile(): Promise<PcppHistoryFile> {
        if (!this.historyFilePath) return { version: 1, cycles: [] };
        try {
            const content = await vscode.workspace.fs.readFile(vscode.Uri.file(this.historyFilePath));
            return JSON.parse(Buffer.from(content).toString('utf-8'));
        } catch (error) {
            Services.loggerService.warn("dce_history.json not found or is invalid. A new one will be created.");
            return { version: 1, cycles: [] };
        }
    }

    private async _writeHistoryFile(data: PcppHistoryFile): Promise<void> {
        if (!this.historyFilePath) return;
        const dir = path.dirname(this.historyFilePath);
        try {
            await vscode.workspace.fs.createDirectory(vscode.Uri.file(dir));
            const content = Buffer.from(JSON.stringify(data, null, 2), 'utf-8');
            await vscode.workspace.fs.writeFile(vscode.Uri.file(this.historyFilePath), content);
        } catch (error) {
            Services.loggerService.error(`Failed to write to dce_history.json: ${error}`);
        }
    }

    public async getFullHistory(): Promise<PcppCycle[]> {
        const history = await this._readHistoryFile();
        return history.cycles;
    }

    public async getLatestCycle(): Promise<PcppCycle> {
        Services.loggerService.log("HistoryService: getLatestCycle called.");
        const history = await this._readHistoryFile();
        if (history.cycles.length === 0) {
            Services.loggerService.log("No history found, creating default cycle 1.");
            const defaultCycle: PcppCycle = {
                cycleId: 1,
                timestamp: new Date().toISOString(),
                title: 'New Cycle',
                cycleContext: '',
                ephemeralContext: '',
                responses: { "1": { content: "" } },
                isParsedMode: false,
                leftPaneWidth: 33,
            };
            await this.saveCycleData(defaultCycle);
            return defaultCycle;
        }
        
        const latestCycle = history.cycles.reduce((latest, current) => current.cycleId > latest.cycleId ? current : latest);
        Services.loggerService.log(`Latest cycle found: ${latestCycle.cycleId}`);
        return latestCycle;
    }

    public async getCycleData(cycleId: number): Promise<PcppCycle | null> {
        Services.loggerService.log(`HistoryService: getting data for cycle ${cycleId}.`);
        const history = await this._readHistoryFile();
        return history.cycles.find(c => c.cycleId === cycleId) || null;
    }

    public async saveCycleData(cycleData: PcppCycle): Promise<void> {
        Services.loggerService.log(`HistoryService: saving data for cycle ${cycleData.cycleId}.`);
        const history = await this._readHistoryFile();
        const cycleIndex = history.cycles.findIndex(c => c.cycleId === cycleData.cycleId);

        if (cycleIndex > -1) {
            history.cycles[cycleIndex] = cycleData;
        } else {
            history.cycles.push(cycleData);
        }
        
        history.cycles.sort((a, b) => a.cycleId - b.cycleId);

        await this._writeHistoryFile(history);
    }

    public async deleteCycle(cycleId: number): Promise<void> {
        Services.loggerService.log(`HistoryService: Deleting cycle ${cycleId}.`);
        const history = await this._readHistoryFile();
        
        if (history.cycles.length <= 1) {
            Services.loggerService.warn("Cannot delete the last remaining cycle.");
            vscode.window.showWarningMessage("Cannot delete the last cycle.");
            return;
        }

        history.cycles = history.cycles.filter(c => c.cycleId !== cycleId);
        await this._writeHistoryFile(history);
        Services.loggerService.log(`Cycle ${cycleId} deleted successfully.`);
        
        const serverIpc = serverIPCs[VIEW_TYPES.PANEL.PARALLEL_COPILOT];
        if (serverIpc) {
            serverIpc.sendToClient(ServerToClientChannel.ForceRefresh, { reason: 'history' });
        }
    }

    public async resetHistory(): Promise<void> {
        Services.loggerService.log(`HistoryService: Resetting all cycle history.`);
        if (this.historyFilePath) {
            try {
                await vscode.workspace.fs.delete(vscode.Uri.file(this.historyFilePath));
                Services.loggerService.log("dce_history.json deleted successfully.");
                 const serverIpc = serverIPCs[VIEW_TYPES.PANEL.PARALLEL_COPILOT];
                if (serverIpc) {
                    serverIpc.sendToClient(ServerToClientChannel.ForceRefresh, { reason: 'history' });
                }
            } catch (error) {
                Services.loggerService.error(`Failed to delete dce_history.json: ${error}`);
            }
        }
    }
}
</file>

<file path="src/backend/services/logger.service.ts">
import * as vscode from 'vscode';

export class LoggerService {
    private static instance: LoggerService;
    private outputChannel: vscode.OutputChannel;

    private constructor() {
        this.outputChannel = vscode.window.createOutputChannel("Data Curation Environment");
    }

    public static getInstance(): LoggerService {
        if (!LoggerService.instance) {
            LoggerService.instance = new LoggerService();
        }
        return LoggerService.instance;
    }

    public show() {
        this.outputChannel.show(true); // true => preserve focus
    }

    private logMessage(level: 'INFO' | 'WARN' | 'ERROR', message: string): void {
        const timestamp = new Date().toLocaleTimeString();
        this.outputChannel.appendLine(`[${level}] [${timestamp}] ${message}`);
    }

    public log(message: string): void {
        this.logMessage('INFO', message);
    }

    public warn(message: string): void {
        this.logMessage('WARN', message);
    }

    public error(message: string): void {
        this.logMessage('ERROR', message);
    }
}
</file>

<file path="src/backend/services/prompt.service.ts">
// Updated on: C120 (Fix cycle order in prompt.md)
import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs/promises';
import { Services } from './services';
import { parseResponse } from '@/client/utils/response-parser';
import { PcppCycle } from '@/common/types/pcpp.types';

export class PromptService {
    private artifactSchemaTemplate = `<M1. artifact schema>
M1. artifact schema
M2. cycle overview
M3. interaction schema
M4. current project scope
M5. organized artifacts list
M6. cycles
M7. Flattened Repo
</M1. artifact schema>`;

    private interactionSchemaTemplate = `<M3. Interaction Schema>
1.  Artifacts are complete, individual texts enclosed in \`<xmltags>\` and separated by three backticks. Different content sections can be separated with three asterisks. Please always output a summary of your thoughts/plan/course of action befoare providing your artifact outputs, whether they be Document artifacts, Code artifacts, or both.
1.1. **New (C108):** To ensure consistent parsing by the DCE extension, all file artifacts **must** be enclosed in \`<file path="path/to/file.ts">...</file>\` tags. The path must be relative to the workspace root. The closing tag must be a simple \`</file>\`. Do not use the file path in the closing tag.
2.  Our Document Artifacts serve as our \`Source of Truth\` throughout multiple cycles. As such, over time, as issues occur, or code repeatedly regresses in the same way, seek to align our \`Source of Truth\` such that the Root Cause of such occurances is codified so it can be avoided on subsequent cycles visits to those Code artifacts.
3.  Please output entire Document or Code artifacts. Do not worry about Token length. If your length continues for too long, and you reach the 600 second timeout, I will simply incorporate the work you did complete, and we can simply continue from where you left off. Better to have half of a solution to get started with, than not to have it. **Preference is for larger, more complete updates over smaller, incremental ones to align with the human curator's parallel processing workflow.** The human curator often sends the same prompt to multiple AI instances simultaneously and selects the most comprehensive response as the primary base for the next cycle, using other responses as supplementary information. Providing more complete updates increases the likelihood of a response being selected as the primary base.
4.  Do not output artifacts that do not require updates in this cycle. (Eg. Do not do this: // Updated on: Cycle 1040 (No functional changes, only cycle header))
5.  **Critical: \`flattened_repo_v2.txt\` contains all project files. Output updated *individual* files that are part of it (like \`<src/state/coreStore.ts>...\`). However, do **NOT** output the surrounding Artifact container tags (\`<flattened_repo_v2.txt>...</flattened_repo_v2.txt>\`) or any auto-generated metadata sections within it (like the Total Files summary, Top 10 list, or the \`<files list>\` section) which are created by the \`flatten.js\` script.**
5.1. \`flattened_repo_v2.txt\` is a copy of the codebase, generated by a script; assume its an accurate representation of the existing codebase, but not necessarily a 'source of truth' like we treat our documents as, our codebase is a living artifact, documents, while we can update them, should be considered less transient.
5.2. **\`.local\` File Convention:** To manage token count, some large data files (e.g., \`researchNodes.ts\`) may be represented by a truncated \`.local.ts\` version in the context. This version contains the essential structure and a few examples. If the full content of a file is required for a task (e.g., a comprehensive data refactor or fixing a bug related to a specific entry), explicitly state this need in your summary of actions and request that the curator swap the \`.local.ts\` file with the full \`.ts\` version in the \`files_list.txt\` for the subsequent cycle.
6.  remember to output complete artifacts without placeholders, im taking your output, putting it in winmerge, and confirming we arent losing data in the update. when you provide placeholders, my cursory review turns into a meticulous file parsing, taking me from what is 5 seconds per artifact to upwards of 5 minutes, only to realize that the output is actually un-parseable, due to the nature of relativity, as the theory of relativity also applies to code. if you give me a code snippet, and do not give me the code surrounding that snippet, i do not know where that code should go. by providing the complete file, on the other hand, i can put it in a diff, see easily what was altered, and if anything was accidentally omitted or lost, i can be sure that it's retained.
7.  **Update documentation before writing code.** document artifacts are like our project readme files, our source of truth. they are our blueprints. they guide the code we write. when we realize we need to alter our approach or invent new game mechanics, we update the source of truth first, cause english is easy and flexible, then we codify that.
8.  this query is part of a larger software engineering project
9.  After you complete delivery on a code artifact, review it to make sure you did not miss any intermediary files. for instance, if we have a DevelopmentSystem.ts, using the componentData.ts, which is displaying on the ComponentProductionTab.tsx. But then theres also still a DevPanel.tsx file that is in-between that *could*, but shouldnt, get overlooked.
10. If you are deciding where to put a particular piece of code or function, and due to its nature, there are one or more candidate files that it could be placed in, choose the smaller file (in tokens).
11. Begin your response with a course of action and end with a review of your work, surface any self corrections in the summary of changes for the subsequent cycle.
12. do not underestimate how much you can accomplish in a given cycle; you'd only accomplish handicapping yourself. (Eg. you've authored this whole thing with just my guidance. good job, keep it up.)
13. Not as relevant for this project: **Log State Button:** The 'Log State' button in the \`DevInfoOverlay\` is a dynamic debugging tool. Modify the \`triggerDebugLogs\` action in \`uiStore.ts\` to output specific state information relevant to the current bug being investigated. **See A85 (Logging Guide) for usage details.**
14. Not as relevant for this project: **Regression Case Studies:** Use Artifact A106 to document persistent or complex bugs and their resolutions. Add entries *after* a fix is confirmed to codify the RCA and solution, preventing future regressions.
15. Include in your cycle summary, a short list of files you've updated. This makes it easy for my reviews.
16. if you seem to have spare time in a cycle, see if you can spot any particular file with excessive levels of comments or logging that seems extensive and for troubleshooting an error that has since been resolved, see to it to clean those files but preserve their functionalities. im just looking to shave off excess tokens wherever possible in the master_content.txt file.
17. if you see \`(No change from C850)\` such language, it's data loss. there was supposed to be actual language behind that placeholder, but in one iteration (C850, in this case) you had provided a placeholder, and i 'missed it' and did not capture the initial information. you either need to deliver the placeholder in such a way as i can easily press the left arrow instead of the rigth arrow in winmerge to not accept that part, but to also not have winmerge confuse it with the rest, otherwise i must manually parse the information. when the process is a single keystroke, i can manage it quickly enough. when we remove that ability because you provided me data in a format that has placeholders AND the placeholders do not parse within winmerge such that it removes the benefit winmerge is adding, then we have our problem. when you see this, try to correct it using whatever current relevant context you have.
18. basically, you should not worry about brevity, because when you go too long, your response gets interrupted by the system anyway. its better that the products you do deliver are all complete except for the last one, rather than you delivering all incomplete products, including the last one. does that make sense?
19. remember, do not stop outputting for the reason of preventing a potential artifact interruption mid-output. you actually end up stopping yourself from producting two or three additional files before you actually get interrupted. what i mean is, in the outputs where you do not do this, you produce for 500 seconds, producing 7-9 files, and only the last one is interrupted and unusable. compared to when you stop yourself prematurely, for the reason stated, and you produce for 180 seconds and provide maybe 3-4 files. even with the -1, producing as much as you can still outperforms the alternative.
20. This is a misaligned statement: \`// (For full history, see master_content.txt)\` because your changes get rolled into master_content.txt. therefore, if you remove the history, then when your updates are rolled in, they will remove the full history. understand? after a while, the history is not relevant and can be rolled out, for a while, it ought to stay. you can see what we're working on + the current cycle and make this determination.
21. Each time we create a new documentation artifact, lets also create the key/value pairs needed for me to add it into our Master Artifact List. they can simply be added into the new artifact itself and ill make the new entry in A0. this will solve for me manually generating a description and tag for each new documentation artifact. also, dont place \`/\` in the title/name of a documentation artifact. VSCode treats it as a folder separator.
21.1. when creating a new documentation artifact, also just update the master artifacts list itself.
</M3. Interaction Schema>`;

    private projectScopeTemplate = `<M4. current project scope>
The plan is to create a Data Curation Environment. We will do this by creating a VS Code extension. The three main components will be:

Phase 1. Context chooser - Choose files/folders (checkmark option in the file explorer) that will be packaged as artifacts into a \`flattened_repo.md\` file.
Phase 2. parallel 'co-pilot' panel. Basically, we need our own AI Studio interface that is parallelizable. so thats what is wrong with the curernt co-pilot panel, that you are 'locked in' to a single conversation flow. my process involves sending the same prompt to up to 8 different conversation windows and then scrutinizing the responses in winmerge.
Phase 3. Diff Tool - Basically, winmerge but intergrated into a window within VS Code. My workflow is often comparing two identical responses, or comparing a new artifact with the current version. Currently, I'm first copying and pasting responses into separate notepad files, and then for which ever i need to compare given my task, i then manually move that one into winmerge to compare against another that i manually move. instead, the ability to just select between two to compare would be a massive decrease in the manual workload.
</M4. current project scope>`;

    public async generatePromptFile(cycleTitle: string, currentCycle: number) {
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (!workspaceFolders?.[0]) {
            vscode.window.showErrorMessage("Cannot generate prompt: No workspace folder is open.");
            return;
        }
        const rootPath = workspaceFolders[0].uri.fsPath;
        const flattenedRepoPath = path.join(rootPath, 'flattened_repo.md');
        const promptMdPath = path.join(rootPath, 'prompt.md');

        try {
            Services.loggerService.log("Generating prompt.md file...");

            const flattenedContent = await fs.readFile(flattenedRepoPath, 'utf-8');
            const fullHistory: PcppCycle[] = await Services.historyService.getFullHistory();

            // C120 FIX: Sort history in descending order for M2
            const sortedHistoryForM2 = [...fullHistory].sort((a, b) => b.cycleId - a.cycleId);

            let cycleOverview = '<M2. cycle overview>\n';
            cycleOverview += `Current Cycle ${currentCycle} - ${cycleTitle}\n`;
            for (const cycle of sortedHistoryForM2) {
                // Ensure we don't duplicate the current cycle entry if it's already in history
                if (cycle.cycleId !== currentCycle) {
                     cycleOverview += `Cycle ${cycle.cycleId} - ${cycle.title}\n`;
                }
            }
            cycleOverview += '</M2. cycle overview>';
            
            // C120 Fix: Also sort the history for M6 in descending order
            const sortedHistoryForM6 = [...fullHistory].sort((a, b) => b.cycleId - a.cycleId);

            let cyclesContent = '<M6. Cycles>\n\n';
            cyclesContent += `<Cycle ${currentCycle}>\n${cycleTitle}\n`;
            // Find the previous cycle's data to generate the summary
            const previousCycle = sortedHistoryForM6.find(c => c.cycleId === currentCycle - 1);
            if (previousCycle) {
                const previousResponseContent = previousCycle.responses['1']?.content || '';
                const parsed = parseResponse(previousResponseContent);
                const summary = `${parsed.summary}\n\n${parsed.courseOfAction}`;
                cyclesContent += `<Previous Cycle ${previousCycle.cycleId} Summary of Actions>\n${summary}\n</Previous Cycle ${previousCycle.cycleId} Summary of Actions>\n`;
            }
            cyclesContent += `</Cycle ${currentCycle}>\n\n`;


            for (const cycle of sortedHistoryForM6) {
                if (cycle.cycleId === currentCycle) continue; 
                cyclesContent += `<Cycle ${cycle.cycleId}>\n`;
                const prevCycleForSummary = sortedHistoryForM6.find(c => c.cycleId === cycle.cycleId - 1);
                 if (prevCycleForSummary) {
                    const previousResponseContent = prevCycleForSummary.responses['1']?.content || '';
                    const parsed = parseResponse(previousResponseContent);
                    const summary = `${parsed.summary}\n\n${parsed.courseOfAction}`;
                    cyclesContent += `<Previous Cycle ${prevCycleForSummary.cycleId} Summary of Actions>\n${summary}\n</Previous Cycle ${prevCycleForSummary.cycleId} Summary of Actions>\n`;
                 }
                cyclesContent += `</Cycle ${cycle.cycleId}>\n\n`;
            }
            cyclesContent += '</M6. Cycles>';


            let masterArtifactListContent = '<!-- Master Artifact List (A0) not found -->';
            try {
                const a0Path = path.join(rootPath, 'src', 'Artifacts', 'A0. DCE Master Artifact List.md');
                masterArtifactListContent = await fs.readFile(a0Path, 'utf-8');
            } catch (e) {
                Services.loggerService.warn("Could not read A0. DCE Master Artifact List.md");
            }

            const promptParts = [
                `<prompt.md>`,
                this.artifactSchemaTemplate,
                cycleOverview,
                this.interactionSchemaTemplate,
                this.projectScopeTemplate,
                `<M5. organized artifacts list>\n${masterArtifactListContent}\n</M5. organized artifacts list>`,
                cyclesContent,
                `<M7. Flattened Repo>\n${flattenedContent}\n</M7. Flattened Repo>`,
                `</prompt.md>`
            ];

            const finalPrompt = promptParts.join('\n\n');

            await fs.writeFile(promptMdPath, finalPrompt, 'utf-8');
            vscode.window.showInformationMessage(`Successfully generated prompt.md.`);
            Services.loggerService.log("Successfully generated prompt.md file.");

        } catch (error: any) {
            let errorMessage = `Failed to generate prompt.md: ${error.message}`;
            if (error.code === 'ENOENT' && error.path?.includes('flattened_repo.md')) {
                errorMessage = "Failed to generate prompt.md: 'flattened_repo.md' not found. Please flatten context first.";
            }
            vscode.window.showErrorMessage(errorMessage);
            Services.loggerService.error(errorMessage);
        }
    }
}
</file>

<file path="src/backend/services/selection.service.ts">
import * as vscode from 'vscode';
import { getContext } from '@/extension';
import { Services } from './services';
import * as fs from 'fs/promises';

const SELECTION_SETS_KEY = 'dce.selectionSets';
const LAST_SELECTION_KEY = 'dce.lastSelection';
const AUTO_ADD_STATE_KEY = 'dce.autoAddState';


export interface SelectionSet {
    [name: string]: string[];
}

export class SelectionService {
    
    private get context(): vscode.ExtensionContext {
        return getContext();
    }

    // --- Named Selection Sets ---

    public getSelectionSets(): SelectionSet {
        return this.context.workspaceState.get<SelectionSet>(SELECTION_SETS_KEY, {});
    }

    public async saveSelectionSet(name: string, paths: string[]): Promise<void> {
        if (!name) {
            vscode.window.showErrorMessage("Selection set name cannot be empty.");
            return;
        }
        const sets = this.getSelectionSets();
        sets[name] = paths;
        await this.context.workspaceState.update(SELECTION_SETS_KEY, sets);
        Services.loggerService.log(`Selection set '${name}' saved with ${paths.length} paths.`);
        vscode.window.showInformationMessage(`Selection set '${name}' saved.`);
    }

    public async deleteSelectionSet(name: string): Promise<void> {
        const sets = this.getSelectionSets();
        if (sets[name]) {
            delete sets[name];
            await this.context.workspaceState.update(SELECTION_SETS_KEY, sets);
            Services.loggerService.log(`Selection set '${name}' deleted.`);
            vscode.window.showInformationMessage(`Selection set '${name}' deleted.`);
        }
    }

    // --- Persistent Current Selection ---

    public async getLastSelection(): Promise<string[]> {
        const savedPaths = this.context.workspaceState.get<string[]>(LAST_SELECTION_KEY, []);
        if (savedPaths.length === 0) {
            Services.loggerService.log("[SelectionService] No last selection found in state.");
            return [];
        }
    
        Services.loggerService.log(`[SelectionService] Found ${savedPaths.length} paths in persisted state. Validating...`);
        
        const validationPromises = savedPaths.map(path => 
            fs.stat(path).then(() => ({ path, valid: true })).catch(() => ({ path, valid: false }))
        );
    
        const results = await Promise.all(validationPromises);
    
        const validPaths = results.filter(r => r.valid).map(r => r.path);
        const invalidPaths = results.filter(r => !r.valid).map(r => r.path);
    
        if (invalidPaths.length > 0) {
            Services.loggerService.warn(`[SelectionService] Removing ${invalidPaths.length} invalid paths from persisted state: ${invalidPaths.join(', ')}`);
            // Self-heal the state by saving only the valid paths
            await this.saveCurrentSelection(validPaths);
        }
    
        Services.loggerService.log(`[SelectionService] Returning ${validPaths.length} valid paths.`);
        return validPaths;
    }

    public async saveCurrentSelection(paths: string[]): Promise<void> {
        await this.context.workspaceState.update(LAST_SELECTION_KEY, paths);
        Services.loggerService.log(`Persisted current selection of ${paths.length} items.`);
    }

    // --- Path Manipulation for File Moves ---
    public async updatePathInSelections(oldPath: string, newPath: string): Promise<void> {
        Services.loggerService.log(`Updating path in selections: ${oldPath} -> ${newPath}`);

        // Update last active selection
        const lastSelection = await this.getLastSelection();
        const updatedLastSelection = this.updatePathsInList(lastSelection, oldPath, newPath);
        await this.saveCurrentSelection(updatedLastSelection);

        // Update all named selection sets
        const allSets = this.getSelectionSets();
        let setsUpdated = false;
        for (const setName in allSets) {
            const updatedSet = this.updatePathsInList(allSets[setName], oldPath, newPath);
            if (updatedSet.length !== allSets[setName].length || updatedSet.some((p, i) => p !== allSets[setName][i])) {
                allSets[setName] = updatedSet;
                setsUpdated = true;
            }
        }
        if (setsUpdated) {
            await this.context.workspaceState.update(SELECTION_SETS_KEY, allSets);
            Services.loggerService.log(`Updated paths in named selection sets.`);
        }
    }

    private updatePathsInList(paths: string[], oldPath: string, newPath: string): string[] {
        return paths.map(p => {
            if (p === oldPath) {
                return newPath; // Exact match
            }
            if (p.startsWith(oldPath + '/')) {
                // Descendant path
                return newPath + p.substring(oldPath.length);
            }
            return p;
        });
    }


    // --- Auto-Add New Files State ---

    public getAutoAddState(): boolean {
        return this.context.workspaceState.get<boolean>(AUTO_ADD_STATE_KEY, false);
    }

    public async saveAutoAddState(enabled: boolean): Promise<void> {
        await this.context.workspaceState.update(AUTO_ADD_STATE_KEY, enabled);
        Services.loggerService.log(`Auto-add new files state saved: ${enabled}.`);
    }
}
</file>

<file path="src/backend/services/services.ts">
import "reflect-metadata";
import { FlattenerService } from "./flattener.service";
import { SelectionService } from "./selection.service";
import { LoggerService } from "./logger.service";
import { ActionService } from "./action.service";
import { HistoryService } from "./history.service";
import { PromptService } from "./prompt.service";
import { API as GitAPI } from "../types/git";
import { FileTreeService } from "./file-tree.service";
import { FileOperationService } from "./file-operation.service";
import { ContentExtractionService } from "./content-extraction.service";
import { HighlightingService } from "./highlighting.service";

class ServiceContainer {
    public fileTreeService!: FileTreeService;
    public fileOperationService = new FileOperationService();
    public contentExtractionService = new ContentExtractionService();
    public highlightingService = new HighlightingService();
    
    public flattenerService = new FlattenerService();
    public selectionService = new SelectionService();
    public loggerService = LoggerService.getInstance();
    public actionService = new ActionService();
    public historyService = new HistoryService();
    public promptService = new PromptService();
    
    public initialize(gitApi?: GitAPI) {
        this.loggerService.log("Services initializing...");
        this.fileTreeService = new FileTreeService(gitApi);
        this.fileTreeService.initializeWatcher();
        this.loggerService.log("Services initialized successfully.");
    }
}

export const Services = new ServiceContainer();
</file>

<file path="src/backend/types/git.ts">
// This file is a placeholder for the complex types from the vscode.git extension API.
// It helps with type safety in our code without needing the full extension as a dev dependency.

import * as vscode from 'vscode';

export interface GitExtension {
    getAPI(version: 1): API;
}

export interface API {
    readonly state: 'uninitialized' | 'initialized';
    readonly onDidOpenRepository: vscode.Event<Repository>;
    readonly onDidCloseRepository: vscode.Event<Repository>;
    readonly repositories: Repository[];
}

export interface Repository {
    readonly rootUri: vscode.Uri;
    readonly state: RepositoryState;
}

export interface RepositoryState {
    readonly HEAD: Branch | undefined;
    readonly workingTreeChanges: Change[];
    readonly indexChanges: Change[];
    readonly mergeChanges: Change[];
    readonly untrackedChanges: vscode.Uri[]; // This is not in the official API, but we use it conceptually
    readonly onDidChange: vscode.Event<void>;
}

export interface Change {
    readonly uri: vscode.Uri;
    readonly originalUri: vscode.Uri;
    readonly renameUri: vscode.Uri | undefined;
    readonly status: Status;
}

export interface Branch {
    readonly type: RefType;
    readonly name?: string;
    readonly commit?: string;
    readonly upstream?: Upstream;
}

export interface Upstream {
    readonly remote: string;
    readonly name: string;
}

export const enum RefType {
    Head,
    RemoteHead,
    Tag
}

export const enum Status {
    INDEX_MODIFIED,
    INDEX_ADDED,
    INDEX_DELETED,
    INDEX_RENAMED,
    INDEX_COPIED,

    MODIFIED,
    DELETED,
    UNTRACKED,
    IGNORED,
    INTENT_TO_ADD,

    ADDED_BY_US,
    ADDED_BY_THEM,
    DELETED_BY_US,
    DELETED_BY_THEM,
    MODIFIED_BY_US,
    MODIFIED_BY_THEM,

    CONFLICT, // Both Added
    BOTH_DELETED, // Both Deleted
    BOTH_MODIFIED, // Both Modified
}
</file>

<file path="src/client/components/Checkbox.tsx">
import React from "react";
import { useEffect, useRef } from "react";

interface CheckboxProps extends Omit<React.DetailedHTMLProps<React.InputHTMLAttributes<HTMLInputElement>, HTMLInputElement>, 'onChange'> {
    checked: boolean;
    indeterminate?: boolean;
    onChange: (checked: boolean, event: React.ChangeEvent<HTMLInputElement>) => void;
}

const Checkbox = (props: CheckboxProps) => {
    const { checked, onChange, indeterminate, ...rest } = props;
    const cRef = useRef<any>(null);

    useEffect(() => {
        if (cRef.current) {
            cRef.current.indeterminate = indeterminate;
        }
    }, [cRef, indeterminate]);

    return (
        <input type="checkbox" ref={cRef} checked={checked} onChange={(e) => onChange(e.target.checked, e)} {...rest} />
    );
};

export default Checkbox;
</file>

<file path="src/client/components/ContextMenu.tsx">
import React, { useEffect, useRef } from 'react';
import { FileNode } from '@/common/types/file-node';
import { ClientPostMessageManager } from '@/common/ipc/client-ipc';
import { ClientToServerChannel } from '@/common/ipc/channels.enum';

interface ContextMenuProps {
    menu: { x: number; y: number; node: FileNode };
    onClose: () => void;
    onRename: () => void;
}

const ContextMenu: React.FC<ContextMenuProps> = ({ menu, onClose, onRename }) => {
    const menuRef = useRef<HTMLDivElement>(null);
    const clientIpc = ClientPostMessageManager.getInstance();

    useEffect(() => {
        const handleClickOutside = (event: MouseEvent) => {
            if (menuRef.current && !menuRef.current.contains(event.target as Node)) {
                onClose();
            }
        };
        document.addEventListener('mousedown', handleClickOutside);
        return () => {
            document.removeEventListener('mousedown', handleClickOutside);
        };
    }, [onClose]);

    const handleAction = (action: () => void) => {
        action();
        onClose();
    };
    
    const { node } = menu;
    const isDirectory = !!node.children;

    const getParentDirectory = () => {
        if (isDirectory) {
            return node.absolutePath;
        }
        // For files, get the parent directory by splitting the path.
        const parts = node.absolutePath.split('/');
        parts.pop();
        return parts.join('/');
    };

    return (
        <>
            <div className="context-menu-overlay" onClick={onClose}></div>
            <div ref={menuRef} className="context-menu" style={{ top: menu.y, left: menu.x }}>
                <ul>
                    <li onClick={() => handleAction(() => clientIpc.sendToServer(ClientToServerChannel.RequestNewFile, { parentDirectory: getParentDirectory() }))}>New File...</li>
                    <li onClick={() => handleAction(() => clientIpc.sendToServer(ClientToServerChannel.RequestNewFolder, { parentDirectory: getParentDirectory() }))}>New Folder...</li>
                    <hr />
                    <li onClick={() => handleAction(() => onRename())}>Rename</li>
                    <li onClick={() => handleAction(() => clientIpc.sendToServer(ClientToServerChannel.RequestFileDelete, { path: node.absolutePath }))}>Delete</li>
                    <hr />
                    <li onClick={() => handleAction(() => clientIpc.sendToServer(ClientToServerChannel.RequestCopyPath, { path: node.absolutePath, relative: false }))}>Copy Path</li>
                    <li onClick={() => handleAction(() => clientIpc.sendToServer(ClientToServerChannel.RequestCopyPath, { path: node.absolutePath, relative: true }))}>Copy Relative Path</li>
                    <hr />
                    <li onClick={() => handleAction(() => clientIpc.sendToServer(ClientToServerChannel.RequestRevealInExplorer, { path: node.absolutePath }))}>Reveal in File Explorer</li>
                </ul>
            </div>
        </>
    );
};

export default ContextMenu;
</file>

<file path="src/client/components/DiffViewer.tsx">
// Updated on: C132 (Add keyboard nav, accept logic, and four scrollbars)
import * as React from 'react';
import { diffArrays, diffChars, Change } from 'diff';
import { VscArrowUp, VscArrowDown } from 'react-icons/vsc';

interface DiffLine {
    type: 'added' | 'removed' | 'common' | 'placeholder';
    content?: string;
}

interface PairedLine {
    left: DiffLine & { lineNum?: number };
    right: DiffLine & { lineNum?: number };
    isDiff: boolean;
}

interface DiffBlock {
    start: number;
    end: number;
}

const DiffViewer: React.FC<{ original: { content: string, path: string }, modified: { content: string, path: string } }> = ({ original, modified }) => {
    const [selectedDiffIndex, setSelectedDiffIndex] = React.useState<number>(0);
    const [originalLines, setOriginalLines] = React.useState<string[]>(() => original.content.split('\n'));
    const diffLineRefs = React.useRef<Map<number, HTMLDivElement>>(new Map());
    const leftPaneRef = React.useRef<HTMLDivElement>(null);
    const rightPaneRef = React.useRef<HTMLDivElement>(null);
    const leftDetailRef = React.useRef<HTMLDivElement>(null);
    const rightDetailRef = React.useRef<HTMLDivElement>(null);
    const wrapperRef = React.useRef<HTMLDivElement>(null);

    React.useEffect(() => {
        setOriginalLines(original.content.split('\n'));
    }, [original.content]);

    const { pairedLines, diffBlocks } = React.useMemo(() => {
        const modifiedLines = modified.content.split('\n');
        const changes = diffArrays(originalLines, modifiedLines);
        
        const result: PairedLine[] = [];
        const diffBlockIndices: DiffBlock[] = [];
        let leftLineNum = 1;
        let rightLineNum = 1;

        for (const change of changes) {
            const blockStart = result.length;
            let isDiffBlock = false;
            if (change.added) {
                isDiffBlock = true;
                for (const line of change.value) {
                    result.push({ left: { type: 'placeholder' }, right: { type: 'added', content: line, lineNum: rightLineNum++ }, isDiff: true });
                }
            } else if (change.removed) {
                isDiffBlock = true;
                for (const line of change.value) {
                    result.push({ left: { type: 'removed', content: line, lineNum: leftLineNum++ }, right: { type: 'placeholder' }, isDiff: true });
                }
            } else {
                for (const line of change.value) {
                    result.push({ left: { type: 'common', content: line, lineNum: leftLineNum++ }, right: { type: 'common', content: line, lineNum: rightLineNum++ }, isDiff: false });
                }
            }
            if (isDiffBlock) {
                diffBlockIndices.push({ start: blockStart, end: result.length - 1 });
            }
        }
        return { pairedLines: result, diffBlocks: diffBlockIndices };
    }, [originalLines, modified.content]);

    const goToDiff = React.useCallback((index: number) => {
        if (index >= 0 && index < diffBlocks.length) {
            setSelectedDiffIndex(index);
            const lineIndex = diffBlocks[index].start;
            diffLineRefs.current.get(lineIndex)?.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
    }, [diffBlocks]);

    React.useEffect(() => {
        goToDiff(selectedDiffIndex);
    }, [selectedDiffIndex, goToDiff]);

    const handleAcceptChange = () => {
        if (selectedDiffIndex < 0 || selectedDiffIndex >= diffBlocks.length) return;
    
        const block = diffBlocks[selectedDiffIndex];
        const blockLines = pairedLines.slice(block.start, block.end + 1);
    
        const originalBlockLines = blockLines.filter(l => l.left.type === 'removed').map(l => l.left.content);
        const modifiedBlockLines = blockLines.filter(l => l.right.type === 'added').map(l => l.right.content);
    
        const firstOriginalLineNum = blockLines.find(l => l.left.lineNum)?.left.lineNum;
    
        if (firstOriginalLineNum === undefined) return;
    
        const startIndex = firstOriginalLineNum - 1;
        const deleteCount = originalBlockLines.length;
    
        setOriginalLines(prev => {
            const newLines = [...prev];
            newLines.splice(startIndex, deleteCount, ...modifiedBlockLines as string[]);
            return newLines;
        });
    };

    React.useEffect(() => {
        const handleKeyDown = (e: KeyboardEvent) => {
            if (e.key === 'ArrowDown') {
                e.preventDefault();
                setSelectedDiffIndex(prev => Math.min(prev + 1, diffBlocks.length - 1));
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                setSelectedDiffIndex(prev => Math.max(prev - 1, 0));
            } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                handleAcceptChange();
            }
        };

        const wrapper = wrapperRef.current;
        wrapper?.addEventListener('keydown', handleKeyDown);
        return () => wrapper?.removeEventListener('keydown', handleKeyDown);
    }, [diffBlocks.length, handleAcceptChange]);


    const handleScroll = (scroller: 'left' | 'right') => {
        if (!leftPaneRef.current || !rightPaneRef.current) return;
        if (scroller === 'left' && rightPaneRef.current.scrollTop !== leftPaneRef.current.scrollTop) {
            rightPaneRef.current.scrollTop = leftPaneRef.current.scrollTop;
        } else if (scroller === 'right' && leftPaneRef.current.scrollTop !== rightPaneRef.current.scrollTop) {
            leftPaneRef.current.scrollTop = rightPaneRef.current.scrollTop;
        }
    };

    const handleDetailScroll = (scroller: 'left' | 'right') => {
        if (!leftDetailRef.current || !rightDetailRef.current) return;
        if (scroller === 'left' && rightDetailRef.current.scrollLeft !== leftDetailRef.current.scrollLeft) {
            rightDetailRef.current.scrollLeft = leftDetailRef.current.scrollLeft;
        } else if (scroller === 'right' && leftDetailRef.current.scrollLeft !== rightDetailRef.current.scrollLeft) {
            leftDetailRef.current.scrollLeft = rightDetailRef.current.scrollLeft;
        }
    };


    const renderCharDiff = (originalText: string, modifiedText: string) => {
        const charChanges = diffChars(originalText, modifiedText);
        const leftSpans: React.ReactNode[] = [];
        const rightSpans: React.ReactNode[] = [];

        charChanges.forEach((part, index) => {
            const key = `char-${index}`;
            const className = part.added ? 'char-added' : part.removed ? 'char-removed' : '';
            if (part.added) {
                rightSpans.push(<span key={key} className={className}>{part.value}</span>);
            } else if (part.removed) {
                leftSpans.push(<span key={key} className={className}>{part.value}</span>);
            } else {
                leftSpans.push(<span key={key}>{part.value}</span>);
                rightSpans.push(<span key={key}>{part.value}</span>);
            }
        });
        return { left: <>{leftSpans}</>, right: <>{rightSpans}</> };
    };

    const selectedDiffContent = React.useMemo(() => {
        if (diffBlocks.length === 0 || selectedDiffIndex < 0 || selectedDiffIndex >= diffBlocks.length) return { left: [], right: [] };
        const block = diffBlocks[selectedDiffIndex];
        const blockLines = pairedLines.slice(block.start, block.end + 1);
        
        const originalLines = blockLines.map(l => l.left.content).filter(Boolean) as string[];
        const modifiedLines = blockLines.map(l => l.right.content).filter(Boolean) as string[];

        return renderCharDiff(originalLines.join('\n'), modifiedLines.join('\n'));
    }, [selectedDiffIndex, pairedLines, diffBlocks]);

    return (
        <div className="diff-viewer-wrapper" ref={wrapperRef} tabIndex={-1}>
            <div className="diff-viewer-main-container">
                {/* Modified Pane (Left) */}
                <div className="diff-pane" onScroll={() => handleScroll('left')} ref={leftPaneRef}>
                    <div className="diff-pane-header">Response: {modified.path}</div>
                    <div className="diff-pane-content">
                        <div className="line-numbers">{pairedLines.map((line, i) => <span key={`L${i}`}>{line.right.lineNum || ' '}</span>)}</div>
                        <div className="diff-lines">
                            {pairedLines.map((line, i) => (
                                <div key={`L${i}`} className={`line ${line.right.type} ${diffBlocks[selectedDiffIndex]?.start <= i && i <= diffBlocks[selectedDiffIndex]?.end ? 'selected-diff' : ''}`} ref={ref => { if (ref) diffLineRefs.current.set(i, ref); }}>
                                    <pre><code>{line.right.content || ''}</code></pre>
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
                {/* Original Pane (Right) */}
                <div className="diff-pane" onScroll={() => handleScroll('right')} ref={rightPaneRef}>
                     <div className="diff-pane-header">Original: {original.path}</div>
                     <div className="diff-pane-content">
                        <div className="line-numbers">{pairedLines.map((line, i) => <span key={`R${i}`}>{line.left.lineNum || ' '}</span>)}</div>
                        <div className="diff-lines">
                            {pairedLines.map((line, i) => (
                                <div key={`R${i}`} className={`line ${line.left.type} ${diffBlocks[selectedDiffIndex]?.start <= i && i <= diffBlocks[selectedDiffIndex]?.end ? 'selected-diff' : ''}`}>
                                    <pre><code>{line.left.content || ''}</code></pre>
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
            </div>
            <div className="diff-detail-container">
                <div className="diff-detail-header">
                    <span>Difference {diffBlocks.length > 0 ? selectedDiffIndex + 1 : 0} of {diffBlocks.length}</span>
                    <div className="diff-nav-buttons">
                        <button onClick={() => goToDiff(selectedDiffIndex - 1)} disabled={selectedDiffIndex <= 0}><VscArrowUp /> Prev</button>
                        <button onClick={() => goToDiff(selectedDiffIndex + 1)} disabled={selectedDiffIndex >= diffBlocks.length - 1}><VscArrowDown /> Next</button>
                    </div>
                </div>
                <div className="diff-detail-panes">
                    <div className="diff-detail-pane added" ref={rightDetailRef} onScroll={() => handleDetailScroll('right')}><pre><code>{selectedDiffContent.right}</code></pre></div>
                    <div className="diff-detail-pane removed" ref={leftDetailRef} onScroll={() => handleDetailScroll('left')}><pre><code>{selectedDiffContent.left}</code></pre></div>
                </div>
            </div>
        </div>
    );
};

export default DiffViewer;
</file>

<file path="src/client/components/file-tree/FileTree.tsx">
import React, { useState, useMemo } from 'react';
import TreeView, { TreeNode } from '../tree-view/TreeView';
import { FileNode } from '@/common/types/file-node';
import Checkbox from '../Checkbox';
import {
    VscFile, VscFolder, VscFolderOpened, VscJson, VscMarkdown, VscSymbolFile, VscSymbolNumeric, VscFiles, VscError, VscWarning, VscTable
} from 'react-icons/vsc';
import { SiTypescript, SiReact, SiJavascript, SiSass } from 'react-icons/si';
import { FaFileWord } from 'react-icons/fa';
import { formatLargeNumber, formatBytes, formatNumberWithCommas } from '@/common/utils/formatting';
import ContextMenu from '../ContextMenu';
import { ClientPostMessageManager } from '@/common/ipc/client-ipc';
import { ClientToServerChannel } from '@/common/ipc/channels.enum';
import { ProblemCountsMap } from '@/common/ipc/channels.type';
import { logger } from '@/client/utils/logger';

interface FileTreeProps {
  data: FileNode[];
  checkedFiles: string[];
  activeFile?: string;
  updateCheckedFiles: (path: string) => void;
  collapseTrigger?: number;
  expandAllTrigger?: number;
  searchTerm: string;
  problemMap: ProblemCountsMap;
  onNodeDrop?: (event: React.DragEvent, node: FileNode) => void;
  onCopy: (path: string) => void;
  clipboard: { path: string; type: 'copy' } | null;
}

const getFileIcon = (fileName: string) => {
    const extension = fileName.split('.').pop()?.toLowerCase();
    switch (extension) {
        case 'ts': return <SiTypescript color="#3178C6" />;
        case 'tsx': return <SiReact color="#61DAFB" />;
        case 'js': return <SiJavascript color="#F7DF1E" />;
        case 'json': return <VscJson color="#F7DF1E" />;
        case 'md': return <VscMarkdown />;
        case 'scss': case 'css': return <SiSass color="#CF649A"/>;
        case 'svg': case 'png': case 'jpg': case 'jpeg': case 'ico': case 'webp': return <VscSymbolFile />;
        case 'xlsx': case 'xls': case 'csv': return <VscTable color="#217346" />;
        case 'docx': return <FaFileWord color="#2B579A" />;
        default: return <VscFile />;
    }
};

const getGitStatusTooltip = (status?: string): string => {
    switch (status) {
        case 'M': return 'Modified';
        case 'U': return 'Untracked';
        case 'A': return 'Added';
        case 'D': return 'Deleted';
        case 'C': return 'Conflicted';
        case 'I': return 'Ignored';
        default: return 'Git Status';
    }
};

const filterTree = (nodes: FileNode[], term: string): FileNode[] => {
    if (!term) return nodes;
    const lowerCaseTerm = term.toLowerCase();

    return nodes.reduce((acc, node) => {
        if (node.name.toLowerCase().includes(lowerCaseTerm)) {
            acc.push(node);
            return acc;
        }

        if (node.children) {
            const filteredChildren = filterTree(node.children, term);
            if (filteredChildren.length > 0) {
                acc.push({ ...node, children: filteredChildren });
            }
        }
        return acc;
    }, [] as FileNode[]);
};


const FileTree: React.FC<FileTreeProps> = ({ data, checkedFiles, activeFile, updateCheckedFiles, collapseTrigger, expandAllTrigger, searchTerm, problemMap, onNodeDrop, onCopy, clipboard }) => {
    const [contextMenu, setContextMenu] = useState<{ x: number, y: number, node: FileNode } | null>(null);
    const [renamingPath, setRenamingPath] = useState<string | null>(null);
    const [renameValue, setRenameValue] = useState('');
    const clientIpc = ClientPostMessageManager.getInstance();

    const filteredData = useMemo(() => filterTree(data, searchTerm), [data, searchTerm]);

    const handleFileCheckboxChange = (e: React.ChangeEvent<HTMLInputElement>, filePath: string) => {
        e.stopPropagation();
        updateCheckedFiles(filePath);
    };

    const handleContextMenu = (event: React.MouseEvent, node: FileNode) => {
        event.preventDefault();
        event.stopPropagation();
        setContextMenu({ x: event.clientX, y: event.clientY, node });
    };

    const handleRename = () => {
        if (contextMenu) {
            setRenamingPath(contextMenu.node.absolutePath);
            setRenameValue(contextMenu.node.name);
            setContextMenu(null);
        }
    };

    const handleRenameSubmit = () => {
        if (renamingPath && renameValue) {
            clientIpc.sendToServer(ClientToServerChannel.RequestFileRename, { oldPath: renamingPath, newName: renameValue });
        }
        setRenamingPath(null);
    };
    
    const calculateCheckedTokens = useMemo(() => {
        const checkedSet = new Set(checkedFiles);
        const memo = new Map<string, number>();

        const calculate = (node: FileNode): number => {
            if (memo.has(node.absolutePath)) {
                return memo.get(node.absolutePath)!;
            }

            if (checkedSet.has(node.absolutePath)) {
                memo.set(node.absolutePath, node.tokenCount);
                return node.tokenCount;
            }
            
            for (const checkedPath of checkedSet) {
                if (node.absolutePath.startsWith(checkedPath + '/')) {
                    memo.set(node.absolutePath, node.tokenCount);
                    return node.tokenCount;
                }
            }

            if (!node.children) {
                const result = checkedSet.has(node.absolutePath) ? node.tokenCount : 0;
                memo.set(node.absolutePath, result);
                return result;
            }
    
            const result = node.children.reduce((acc, child) => acc + calculate(child), 0);
            memo.set(node.absolutePath, result);
            return result;
        };
        return calculate;
    }, [checkedFiles]);

    const renderFileNodeContent = (node: TreeNode, isExpanded: boolean) => {
        const fileNode = node as FileNode;
        const isDirectory = Array.isArray(fileNode.children);
        
        const hasCheckedAncestor = checkedFiles.some(ancestor => fileNode.absolutePath.startsWith(ancestor + '/') && fileNode.absolutePath !== ancestor);
        const isDirectlyChecked = checkedFiles.includes(fileNode.absolutePath);
        const isChecked = isDirectlyChecked || hasCheckedAncestor;

        if (renamingPath === fileNode.absolutePath) {
            return (
                <input
                    type="text"
                    value={renameValue}
                    onChange={(e) => setRenameValue(e.target.value)}
                    onBlur={handleRenameSubmit}
                    onKeyDown={(e) => {
                        if (e.key === 'Enter') handleRenameSubmit();
                        // Stop propagation for text editing shortcuts
                        if ((e.ctrlKey || e.metaKey) && ['c', 'v', 'x'].includes(e.key.toLowerCase())) {
                            e.stopPropagation();
                        }
                    }}
                    autoFocus
                    className="rename-input"
                />
            );
        }

        const checkedTokensInDir = isDirectory ? calculateCheckedTokens(fileNode) : 0;
        const isFullyChecked = isDirectory && checkedTokensInDir > 0 && checkedTokensInDir === fileNode.tokenCount;
        
        const liveProblems = problemMap[fileNode.absolutePath];
        const problemData = liveProblems || fileNode.problemCounts;

        const problemErrorCount = problemData?.error || 0;
        const problemWarningCount = problemData?.warning || 0;
        const hasProblems = problemErrorCount > 0 || problemWarningCount > 0;
        const problemColorClass = problemErrorCount > 0 ? 'problem-error' : 'problem-warning';
        const problemTooltip = `${problemErrorCount} Errors, ${problemWarningCount} Warnings`;
        const hasError = !!fileNode.error;

        const renderTokenCount = () => {
            if (hasError) {
                return <span>---</span>;
            }
            if (fileNode.isImage) {
                return <span>{formatBytes(fileNode.sizeInBytes)}</span>;
            }
            if (fileNode.tokenCount > 0) {
                let content;
                if (isDirectory) {
                    if (isFullyChecked) {
                        content = `(${formatLargeNumber(fileNode.tokenCount, 1)})`;
                    } else if (checkedTokensInDir > 0) {
                        content = <>{formatLargeNumber(fileNode.tokenCount, 1)} <span className="selected-token-count">({formatLargeNumber(checkedTokensInDir, 1)})</span></>;
                    } else {
                        content = formatLargeNumber(fileNode.tokenCount, 1);
                    }
                } else { // It's a file
                    content = isChecked ? `(${formatLargeNumber(fileNode.tokenCount, 1)})` : formatLargeNumber(fileNode.tokenCount, 1);
                }
                return <><VscSymbolNumeric /> <span>{content}</span></>;
            }
            return null;
        };

        const gitStatusClass = fileNode.gitStatus ? `git-status-${fileNode.gitStatus}` : '';

        return (
            <div className={`file-item ${gitStatusClass} ${hasProblems ? problemColorClass : ''} ${hasError ? 'has-error' : ''}`} title={fileNode.error}>
                <Checkbox
                    className="file-checkbox"
                    checked={isChecked}
                    indeterminate={!isDirectlyChecked && !hasCheckedAncestor && checkedFiles.some(p => p.startsWith(fileNode.absolutePath))}
                    onChange={(_, e) => handleFileCheckboxChange(e, fileNode.absolutePath)}
                    disabled={hasError}
                />
                <span className="file-icon">{isDirectory ? (isExpanded ? <VscFolderOpened /> : <VscFolder />) : getFileIcon(fileNode.name)}</span>
                <span className="file-name">{fileNode.name}</span>
                <div className="file-stats">
                    {hasError && <span className="error-icon" title={fileNode.error}><VscError/></span>}
                    {fileNode.gitStatus && <span className="git-status-badge" title={getGitStatusTooltip(fileNode.gitStatus)}>{fileNode.gitStatus}</span>}
                    {hasProblems && (
                        <span className="problem-badge" title={problemTooltip}>
                            {problemErrorCount > 0 && <span className='error-icon'><VscError/> {problemErrorCount}</span>}
                            {problemWarningCount > 0 && <span className='warning-icon'><VscWarning/> {problemWarningCount}</span>}
                        </span>
                    )}
                    {isDirectory && fileNode.fileCount > 0 && (<> <VscFiles /> <span>{formatNumberWithCommas(fileNode.fileCount)}</span> </>)}
                    {renderTokenCount()}
                </div>
            </div>
        );
    };

    return (
        <div className="file-tree">
            <TreeView 
                data={filteredData as TreeNode[]} 
                renderNodeContent={(node, isExpanded) => renderFileNodeContent(node, isExpanded as boolean)} 
                onContextMenu={(e, node) => handleContextMenu(e, node as FileNode)} 
                collapseTrigger={collapseTrigger}
                expandAllTrigger={expandAllTrigger}
                activeFile={activeFile} 
                updateCheckedFiles={updateCheckedFiles}
                onNodeDrop={(e, node) => onNodeDrop?.(e, node as FileNode)}
                onCopy={onCopy}
                clipboard={clipboard}
            />
            {contextMenu && <ContextMenu menu={contextMenu} onClose={() => setContextMenu(null)} onRename={handleRename} />}
        </div>
    );
};

export default FileTree;
</file>

<file path="src/client/components/file-tree/FileTree.utils.ts">
import { FileNode } from "@/common/types/file-node";
import { logger } from "@/client/utils/logger";

function getAllDescendantPaths(node: FileNode, includeFilesOnly: boolean = false): string[] {
    let paths: string[] = [];
    if (node.children) {
        for (const child of node.children) {
            if (!includeFilesOnly || !child.children) {
                paths.push(child.absolutePath);
            }
            paths = paths.concat(getAllDescendantPaths(child, includeFilesOnly));
        }
    }
    return paths;
}

function findNode(node: FileNode, filePath: string): FileNode | null {
    if (node.absolutePath === filePath) {
        return node;
    }

    if (node.children && filePath.startsWith(node.absolutePath + '/')) {
        for (const child of node.children) {
            const found = findNode(child, filePath);
            if(found) return found;
        }
    }
    return null;
}

export const getFileNodeByPath = (
  fileNodes: FileNode[],
  filePath: string
): FileNode | null => {
    for (const rootNode of fileNodes) {
        const found = findNode(rootNode, filePath);
        if (found) return found;
    }
    return null;
};

export const addRemovePathInSelectedFiles = (
  fileTree: FileNode[],
  path: string,
  selectedFiles: string[]
): string[] => {
    logger.log(`[Selection] Toggling path: ${path}`);
    const node = getFileNodeByPath(fileTree, path);
    if (!node) {
        logger.error(`[Selection] Node not found for path: ${path}`);
        return selectedFiles;
    }

    const currentSelection = new Set(selectedFiles);
    const isDirectlySelected = currentSelection.has(path);
    const selectedAncestor = selectedFiles.find(ancestor => path.startsWith(ancestor + '/') && path !== ancestor);

    const isEffectivelySelected = isDirectlySelected || !!selectedAncestor;
    logger.log(`[Selection] isDirectlySelected: ${isDirectlySelected}, hasSelectedAncestor: ${!!selectedAncestor}`);

    if (isEffectivelySelected) {
        // --- UNCHECKING ---
        logger.log(`[Selection] Unchecking logic initiated.`);
        if (selectedAncestor) {
            logger.log(`[Selection] Performing 'subtractive uncheck'. Ancestor: ${selectedAncestor}`);
            // A child of a selected folder is being unchecked. This is the BUGGY part.
            const ancestorNode = getFileNodeByPath(fileTree, selectedAncestor);
            if (!ancestorNode) return selectedFiles;

            // 1. Remove the ancestor from the selection.
            currentSelection.delete(selectedAncestor);
            
            // 2. Get ALL descendant files of the ancestor.
            const allDescendantFiles = getAllDescendantPaths(ancestorNode, true);

            // 3. Add all descendants back, EXCEPT for the one that was unchecked.
            for (const file of allDescendantFiles) {
                if (file !== path) {
                    currentSelection.add(file);
                }
            }

        } else {
            // A directly selected item is being unchecked. Remove it.
            logger.log(`[Selection] Unchecking directly selected item: ${path}`);
            currentSelection.delete(path);
        }
    } else {
        // --- CHECKING ---
        logger.log(`[Selection] Checking logic initiated.`);
        // Remove any descendants that are already selected, as the new parent selection covers them.
        const newSelection = new Set<string>();
        for (const p of currentSelection) {
            if (!p.startsWith(path + '/')) {
                newSelection.add(p);
            } else {
                logger.log(`[Selection] Removing descendant '${p}' because parent '${path}' is being checked.`);
            }
        }
        newSelection.add(path);
        return Array.from(newSelection);
    }
  
  const finalSelection = Array.from(currentSelection);
  logger.log(`[Selection] Final selection count: ${finalSelection.length}`);
  return finalSelection;
};

export const removePathsFromSelected = (
    pathsToRemove: string[],
    currentSelectedFiles: string[],
    fileTree: FileNode[]
): string[] => {
    logger.log(`[Batch Remove] Starting removal of ${pathsToRemove.length} paths.`);
    if (pathsToRemove.length === 0) return currentSelectedFiles;

    const fileMap = new Map<string, FileNode>();
    const buildMap = (node: FileNode) => {
        fileMap.set(node.absolutePath, node);
        node.children?.forEach(buildMap);
    };
    fileTree.forEach(buildMap);

    // 1. Get the full set of all individual files that are currently selected.
    const effectiveFileSelection = new Set<string>();
    for (const selectedPath of currentSelectedFiles) {
        const node = fileMap.get(selectedPath);
        if (node) {
            if (node.children) { // It's a directory
                getAllDescendantPaths(node, true).forEach(file => effectiveFileSelection.add(file));
            } else { // It's a file
                effectiveFileSelection.add(selectedPath);
            }
        }
    }
    logger.log(`[Batch Remove] Expanded initial selection to ${effectiveFileSelection.size} effective files.`);

    // 2. Remove the unwanted files from this effective set.
    for (const pathToRemove of pathsToRemove) {
        const nodeToRemove = fileMap.get(pathToRemove);
        if (nodeToRemove) {
            if (nodeToRemove.children) { // It's a directory
                getAllDescendantPaths(nodeToRemove, true).forEach(file => effectiveFileSelection.delete(file));
            } else { // It's a file
                effectiveFileSelection.delete(pathToRemove);
            }
        }
    }
    logger.log(`[Batch Remove] After removal, ${effectiveFileSelection.size} files remain.`);


    // 3. Compress the remaining set of files into the most efficient list of paths (folders + files).
    const finalPaths = new Set<string>();
    const checkedForCompression = new Set<string>();

    const compress = (node: FileNode) => {
        if (!node.children || checkedForCompression.has(node.absolutePath)) {
            return;
        }

        const descendantFiles = getAllDescendantPaths(node, true);
        if (descendantFiles.length === 0) {
            return; // Don't add empty folders
        }

        const allDescendantsSelected = descendantFiles.every(file => effectiveFileSelection.has(file));

        if (allDescendantsSelected) {
            finalPaths.add(node.absolutePath);
            // Mark all descendants as handled by this compression
            descendantFiles.forEach(file => checkedForCompression.add(file));
        } else {
            // Recurse to children if not all are selected
            node.children.forEach(compress);
        }
    };

    fileTree.forEach(compress);

    // Add any remaining files that were not part of a compressed folder
    for (const file of effectiveFileSelection) {
        if (!checkedForCompression.has(file)) {
            finalPaths.add(file);
        }
    }
    
    logger.log(`[Batch Remove] Compressed final selection to ${finalPaths.size} paths.`);
    return Array.from(finalPaths);
};
</file>

<file path="src/client/components/LocationPane.tsx">
// src/client/components/LocationPane.tsx
import * as React from 'react';

interface PairedLine {
    isDiff: boolean;
}

interface LocationPaneProps {
    pairedLines: PairedLine[];
    onLineClick: (index: number) => void;
}

const LocationPane: React.FC<LocationPaneProps> = ({ pairedLines, onLineClick }) => {
    return (
        <div className="location-pane">
            {pairedLines.map((line, index) => (
                <div
                    key={index}
                    className={`location-line ${line.isDiff ? 'changed' : 'unchanged'}`}
                    onClick={() => onLineClick(index)}
                    title={`Line ${index + 1}`}
                />
            ))}
        </div>
    );
};

export default LocationPane;
</file>

<file path="src/client/components/SelectedFilesView.tsx">
import * as React from 'react';
import { useState, useMemo, useRef, useEffect } from 'react';
import { FileNode } from '@/common/types/file-node';
import { VscChevronUp, VscChevronDown, VscSymbolFile, VscSymbolNumeric, VscTypeHierarchy, VscClose, VscChevronRight, VscChevronLeft } from 'react-icons/vsc';
import { formatLargeNumber } from '@/common/utils/formatting';
import { SiReact, SiSass, SiTypescript, SiJavascript } from 'react-icons/si';
import { VscFile, VscJson, VscMarkdown, VscTable } from 'react-icons/vsc';
import { logger } from '../utils/logger';
import { ClientPostMessageManager } from '@/common/ipc/client-ipc';
import { ClientToServerChannel } from '@/common/ipc/channels.enum';
import { FaFileWord } from 'react-icons/fa';

type SortableColumn = 'name' | 'tokenCount' | 'extension';
type SortDirection = 'asc' | 'desc';

const getFileIcon = (fileName: string) => {
    const extension = fileName.split('.').pop()?.toLowerCase();
    switch (extension) {
        case 'ts': return <SiTypescript color="#3178C6" />;
        case 'tsx': return <SiReact color="#61DAFB" />;
        case 'js': return <SiJavascript color="#F7DF1E" />;
        case 'json': return <VscJson color="#F7DF1E" />;
        case 'md': return <VscMarkdown />;
        case 'scss': case 'css': return <SiSass color="#CF649A"/>;
        case 'xlsx': case 'xls': case 'csv': return <VscTable color="#217346" />;
        case 'docx': return <FaFileWord color="#2B579A" />;
        default: return <VscFile />;
    }
};

const getTokenBackgroundColor = (tokenCount: number): string => {
    // 0 - 8k: green
    if (tokenCount <= 8000) return 'hsla(120, 60%, 50%, 0.1)';
    // 8k - 10k: green to yellow
    if (tokenCount <= 10000) {
        const percentage = (tokenCount - 8000) / 2000;
        const hue = 120 - (percentage * 60); // 120 (green) -> 60 (yellow)
        return `hsla(${hue}, 70%, 50%, 0.15)`;
    }
    // 10k - 12k: yellow to orange
    if (tokenCount <= 12000) {
        const percentage = (tokenCount - 10000) / 2000;
        const hue = 60 - (percentage * 30); // 60 (yellow) -> 30 (orange)
        return `hsla(${hue}, 80%, 50%, 0.2)`;
    }
    // 12k+: orange to red
    const percentage = Math.min((tokenCount - 12000) / 28000, 1.0); // Cap at 40k for max red
    const hue = 30 - (percentage * 30); // 30 (orange) -> 0 (red)
    return `hsla(${hue}, 80%, 50%, 0.25)`;
};

const getTokenRiskTooltip = (tokenCount: number): string => {
    if (tokenCount <= 8000) return 'Low token count, suitable for most workloads.';
    if (tokenCount <= 10000) return 'Slightly elevated token count, small chance of performance degradation.';
    if (tokenCount <= 12000) return 'Moderate token count, may impact performance on complex tasks.';
    return 'High token count, increased chance of performance degradation or truncation.';
};


interface SelectedFilesViewProps {
    selectedFileNodes: FileNode[];
    onRemove: (pathsToRemove: string[]) => void;
    isMinimized: boolean;
    onToggleMinimize: () => void;
}

const SelectedFilesView: React.FC<SelectedFilesViewProps> = ({ selectedFileNodes, onRemove, isMinimized, onToggleMinimize }) => {
    const [sortColumn, setSortColumn] = useState<SortableColumn>('tokenCount');
    const [sortDirection, setSortDirection] = useState<SortDirection>('desc');
    const [selection, setSelection] = useState<Set<string>>(new Set());
    const [hoveredPath, setHoveredPath] = useState<string | null>(null);
    const [contextMenu, setContextMenu] = useState<{ x: number; y: number } | null>(null);
    const firstClickedPath = useRef<string | null>(null); // Anchor for shift-click
    const listRef = useRef<HTMLUListElement>(null);
    const clientIpc = ClientPostMessageManager.getInstance();

    // Reset selection when the list of files changes
    useEffect(() => {
        setSelection(new Set());
    }, [selectedFileNodes]);

    const sortedFiles = useMemo(() => {
        return [...selectedFileNodes].sort((a, b) => {
            const dir = sortDirection === 'asc' ? 1 : -1;
            if (sortColumn === 'name') {
                return a.name.localeCompare(b.name, undefined, { numeric: true }) * dir;
            }
            if (sortColumn === 'extension') {
                const extA = a.extension || '';
                const extB = b.extension || '';
                if (extA !== extB) {
                    return extA.localeCompare(extB) * dir;
                }
                // Sub-sort by token count if extensions are the same
                return (b.tokenCount - a.tokenCount);
            }
            // Default and tokenCount sort
            return (a.tokenCount - b.tokenCount) * dir;
        });
    }, [selectedFileNodes, sortColumn, sortDirection]);

    const handleSort = (column: SortableColumn) => {
        if (column === sortColumn) {
            setSortDirection(prev => prev === 'asc' ? 'desc' : 'asc');
        } else {
            setSortColumn(column);
            setSortDirection(column === 'tokenCount' ? 'desc' : 'asc');
        }
    };

    const handleItemClick = (e: React.MouseEvent, path: string) => {
        if ((e.target as HTMLElement).closest('.quick-remove-icon')) {
            return;
        }
        
        const newSelection = new Set(selection);

        if (e.shiftKey && firstClickedPath.current) {
            const firstIdx = sortedFiles.findIndex(f => f.absolutePath === firstClickedPath.current);
            const currentIdx = sortedFiles.findIndex(f => f.absolutePath === path);
            const start = Math.min(firstIdx, currentIdx);
            const end = Math.max(firstIdx, currentIdx);
            
            if (!e.ctrlKey) newSelection.clear();

            for (let i = start; i <= end; i++) {
                newSelection.add(sortedFiles[i].absolutePath);
            }
        } else if (e.ctrlKey) {
            if (newSelection.has(path)) {
                newSelection.delete(path);
            } else {
                newSelection.add(path);
            }
            firstClickedPath.current = path; // Update anchor on ctrl-click
        } else {
            clientIpc.sendToServer(ClientToServerChannel.RequestOpenFile, { path });
            // C38 Fix: Re-focus the list after a delay to reclaim focus from the editor
            setTimeout(() => listRef.current?.focus(), 100);
            newSelection.clear();
            newSelection.add(path);
            firstClickedPath.current = path;
        }
        
        setSelection(newSelection);
    };
    
    const handleRemoveSelected = () => {
        logger.log(`"Remove selected" button clicked. Removing ${selection.size} items.`);
        onRemove(Array.from(selection));
        setSelection(new Set());
    };

    const handleKeyDown = (e: React.KeyboardEvent<HTMLUListElement>) => {
        switch (e.key) {
            case 'a':
                if (e.ctrlKey || e.metaKey) {
                    e.preventDefault();
                    e.stopPropagation();
                    logger.log('Ctrl+A detected in SelectedFilesView.');
                    const allPaths = new Set(sortedFiles.map(f => f.absolutePath));
                    setSelection(allPaths);
                }
                break;
            case 'Delete':
                e.preventDefault();
                e.stopPropagation();
                if (selection.size > 0) {
                    logger.log(`Delete key pressed. Removing ${selection.size} items.`);
                    handleRemoveSelected();
                }
                break;
        }
    };

    const handleContainerClick = () => {
        listRef.current?.focus();
    };

    const handleContextMenu = (event: React.MouseEvent) => {
        event.preventDefault();
        setContextMenu({ x: event.clientX, y: event.clientY });
    };

    const handleSelectAll = () => {
        const allPaths = new Set(sortedFiles.map(f => f.absolutePath));
        setSelection(allPaths);
        setContextMenu(null);
    };

    const handleDeselectAll = () => {
        setSelection(new Set());
        setContextMenu(null);
    };
    
    const SortIndicator = ({ column }: { column: SortableColumn }) => {
        if (sortColumn !== column) return null;
        return sortDirection === 'asc' ? <VscChevronUp /> : <VscChevronDown />;
    };

    return (
        <div className="selected-files-panel" onClick={handleContainerClick}>
            <div className="panel-header">
                <span>Selected Items ({selectedFileNodes.length})</span>
                <button onClick={onToggleMinimize} className="toolbar-button" title={isMinimized ? "Expand" : "Minimize"}>
                    {isMinimized ? <VscChevronRight /> : <VscChevronDown />}
                </button>
            </div>
            {!isMinimized && (
                <>
                    <div className="panel-toolbar">
                        <button onClick={handleRemoveSelected} disabled={selection.size === 0}>
                            Remove selected ({selection.size})
                        </button>
                    </div>
                    <div className="selected-files-list-container">
                        <div className="selected-list-header">
                            <div className="header-index">#</div>
                            <div className="header-type" onClick={() => handleSort('extension')} title="Sort by File Type">
                                <VscTypeHierarchy /> <SortIndicator column="extension" />
                            </div>
                            <div className="header-name" onClick={() => handleSort('name')}>
                                <VscSymbolFile /> File <SortIndicator column="name" />
                            </div>
                            <div className="header-tokens" onClick={() => handleSort('tokenCount')}>
                                <VscSymbolNumeric /> Tokens <SortIndicator column="tokenCount" />
                            </div>
                        </div>
                        <ul className="selected-files-list" ref={listRef} tabIndex={0} onKeyDown={handleKeyDown} onContextMenu={handleContextMenu}>
                            {sortedFiles.map((node, index) => (
                                <li key={node.absolutePath} 
                                    className={selection.has(node.absolutePath) ? 'selected' : ''}
                                    onClick={(e) => handleItemClick(e, node.absolutePath)}
                                    onMouseEnter={() => setHoveredPath(node.absolutePath)}
                                    onMouseLeave={() => setHoveredPath(null)}
                                    style={{ backgroundColor: node.isImage ? 'transparent' : getTokenBackgroundColor(node.tokenCount) }}
                                    title={node.isImage ? `Binary file: ${node.name}` : getTokenRiskTooltip(node.tokenCount)}
                                >
                                    <span className="file-index">
                                        {hoveredPath === node.absolutePath ? (
                                            <span 
                                                className="quick-remove-icon" 
                                                title="Remove from selection"
                                                onClick={(e) => { e.stopPropagation(); onRemove([node.absolutePath]); }}
                                            >
                                                <VscClose />
                                            </span>
                                        ) : (
                                            index + 1
                                        )}
                                    </span>
                                    <span className="file-icon">{getFileIcon(node.name)}</span>
                                    <span className="file-name" title={node.absolutePath}>{node.name}</span>
                                    <span className="file-tokens">{formatLargeNumber(node.tokenCount, 1)}</span>
                                </li>
                            ))}
                        </ul>
                    </div>
                </>
            )}
            {contextMenu && (
                 <>
                    <div className="context-menu-overlay" onClick={() => setContextMenu(null)}></div>
                    <div className="context-menu" style={{ top: contextMenu.y, left: contextMenu.x }}>
                        <ul>
                            <li onClick={handleSelectAll}>Select All</li>
                            <li onClick={handleDeselectAll}>Deselect All</li>
                        </ul>
                    </div>
                </>
            )}
        </div>
    );
};

export default SelectedFilesView;
</file>

<file path="src/client/components/tree-view/TreeView.tsx">
// Updated on: C83 (Fix ref assignment type error)
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { VscChevronRight } from 'react-icons/vsc';
import { ClientPostMessageManager } from '@/common/ipc/client-ipc';
import { ClientToServerChannel } from '@/common/ipc/channels.enum';
import { logger } from '@/client/utils/logger';
import { FileNode } from '@/common/types/file-node';

export interface TreeNode {
    name: string;
    absolutePath: string;
    children?: TreeNode[];
    isExpanded?: boolean;
    [key: string]: any;
}

interface TreeViewProps {
    data: TreeNode[];
    renderNodeContent?: (node: TreeNode, isExpanded: boolean) => React.ReactNode;
    collapseTrigger?: number;
    expandAllTrigger?: number;
    onContextMenu?: (event: React.MouseEvent, node: TreeNode) => void;
    activeFile?: string;
    updateCheckedFiles: (path: string) => void;
    onNodeDrop?: (event: React.DragEvent, node: FileNode) => void;
    onCopy: (path: string) => void;
    clipboard: { path: string; type: 'copy' } | null;
}

const TreeView: React.FC<TreeViewProps> = ({ data, renderNodeContent, collapseTrigger = 0, expandAllTrigger = 0, onContextMenu, activeFile, updateCheckedFiles, onNodeDrop, onCopy, clipboard }) => {
    const [expandedNodes, setExpandedNodes] = useState<string[]>([]);
    const [selectedPaths, setSelectedPaths] = useState<Set<string>>(new Set());
    const [focusedNodePath, setFocusedNodePath] = useState<string | null>(null);
    const [lastClickedPath, setLastClickedPath] = useState<string | null>(null);
    const [draggedPath, setDraggedPath] = useState<string | null>(null);
    const [dropTarget, setDropTarget] = useState<string | null>(null);
    const expansionTimer = useRef<NodeJS.Timeout | null>(null);

    const nodeRefs = useRef<Map<string, HTMLLIElement>>(new Map());
    const treeViewRef = useRef<HTMLDivElement>(null);
    const flatNodeList = useRef<TreeNode[]>([]);
    const clientIpc = ClientPostMessageManager.getInstance();

    const buildFlatNodeList = useCallback((nodes: TreeNode[], expanded: string[]): TreeNode[] => {
        let list: TreeNode[] = [];
        for (const node of nodes) {
            list.push(node);
            if (node.children && expanded.includes(node.absolutePath)) {
                list = list.concat(buildFlatNodeList(node.children, expanded));
            }
        }
        return list;
    }, []);

    useEffect(() => {
        flatNodeList.current = buildFlatNodeList(data, expandedNodes);
        if (!focusedNodePath && flatNodeList.current.length > 0) {
            setFocusedNodePath(flatNodeList.current[0].absolutePath);
        }
    }, [data, expandedNodes, buildFlatNodeList, focusedNodePath]);

    const expandNode = (path: string) => {
        setExpandedNodes(prev => [...new Set([...prev, path])]);
    };

    useEffect(() => {
        if (data.length > 0) {
            const rootNode = data[0];
            if (rootNode) {
                expandNode(rootNode.absolutePath);
            }
        }
    }, [data]);

    useEffect(() => {
        if (collapseTrigger > 0 && data.length > 0) {
            const rootNode = data[0];
            if (rootNode) {
                setExpandedNodes([rootNode.absolutePath]);
            }
        }
    }, [collapseTrigger, data]);

    useEffect(() => {
        if (expandAllTrigger > 0 && data.length > 0) {
            const allDirPaths: string[] = [];
            const collectDirs = (node: TreeNode) => {
                if (node.children) {
                    allDirPaths.push(node.absolutePath);
                    node.children.forEach(collectDirs);
                }
            };
            data.forEach(collectDirs);
            setExpandedNodes(allDirPaths);
        }
    }, [expandAllTrigger, data]);

    useEffect(() => {
        if (activeFile && data.length > 0) {
            logger.log(`[TreeView] activeFile prop changed: ${activeFile}. Attempting to reveal.`);
            const getParentPaths = (filePath: string, rootPath: string): string[] => {
                if (!filePath.startsWith(rootPath) || filePath === rootPath) {
                    return [];
                }
                const relativePath = filePath.substring(rootPath.length + 1);
                const parts = relativePath.split('/');
                const paths: string[] = [];
                let current = rootPath;
                for (let i = 0; i < parts.length - 1; i++) {
                    current += '/' + parts[i];
                    paths.push(current);
                }
                return paths;
            };
            const rootPath = data[0]?.absolutePath;
            if (rootPath) {
                const parents = getParentPaths(activeFile, rootPath);
                logger.log(`[TreeView] Parents to expand: ${JSON.stringify(parents)}`);
                setExpandedNodes(prev => [...new Set([...prev, ...parents, rootPath])]);
                setSelectedPaths(new Set([activeFile]));
                setFocusedNodePath(activeFile);
                setLastClickedPath(activeFile);
                setTimeout(() => {
                    const nodeElement = nodeRefs.current.get(activeFile);
                    if (nodeElement) {
                        logger.log(`[TreeView] Scrolling to active file element.`);
                        nodeElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    } else {
                        logger.warn(`[TreeView] Could not find ref for active file: ${activeFile}`);
                    }
                }, 150);
            }
        }
    }, [activeFile, data]);

    const handleNodeClick = (e: React.MouseEvent, node: TreeNode) => {
        if ((e.target as HTMLElement).closest('.file-checkbox') || (e.target as HTMLElement).closest('.rename-input')) {
            return;
        }
        e.stopPropagation();

        const path = node.absolutePath;
        setFocusedNodePath(path);
        
        if (e.shiftKey && lastClickedPath) {
            const newSelection = new Set(e.ctrlKey ? selectedPaths : []);
            const firstIdx = flatNodeList.current.findIndex(f => f.absolutePath === lastClickedPath);
            const currentIdx = flatNodeList.current.findIndex(f => f.absolutePath === path);
            const start = Math.min(firstIdx, currentIdx);
            const end = Math.max(firstIdx, currentIdx);
            if (start !== -1 && end !== -1) {
                for (let i = start; i <= end; i++) {
                    if (flatNodeList.current[i]) {
                        newSelection.add(flatNodeList.current[i].absolutePath);
                    }
                }
            }
            setSelectedPaths(newSelection);
        } else if (e.ctrlKey) {
            const newSelection = new Set(selectedPaths);
            if (newSelection.has(path)) {
                newSelection.delete(path);
            } else {
                newSelection.add(path);
            }
            setSelectedPaths(newSelection);
            setLastClickedPath(path);
        } else {
            setSelectedPaths(new Set([path]));
            setLastClickedPath(path);
            if (node.children) {
                setExpandedNodes(prev => {
                    const isExpanded = prev.includes(path);
                    return isExpanded ? prev.filter(p => p !== path) : [...prev, path];
                });
            } else {
                clientIpc.sendToServer(ClientToServerChannel.RequestOpenFile, { path });
                setTimeout(() => treeViewRef.current?.focus(), 100);
            }
        }
    };

    const handleKeyDown = (e: React.KeyboardEvent) => {
        // C72 Fix: If the event is coming from an input field, ignore it.
        if ((e.target as HTMLElement).tagName === 'INPUT') {
            return;
        }

        if (e.ctrlKey || e.metaKey) {
            switch (e.key.toLowerCase()) {
                case 'c':
                    e.preventDefault(); e.stopPropagation();
                    if (focusedNodePath) {
                        logger.log(`[Copy-Paste] Ctrl+C detected. Copying path: ${focusedNodePath}`);
                        onCopy(focusedNodePath);
                    }
                    return;
                case 'v':
                    e.preventDefault(); e.stopPropagation();
                    logger.log(`[Copy-Paste] Ctrl+V detected. Clipboard prop: ${JSON.stringify(clipboard)}. Focused node: ${focusedNodePath}`);
                    if (clipboard && focusedNodePath) {
                        const targetNode = flatNodeList.current.find(n => n.absolutePath === focusedNodePath);
                        if (targetNode) {
                            const destinationDir = targetNode.children 
                                ? targetNode.absolutePath 
                                : targetNode.absolutePath.substring(0, targetNode.absolutePath.lastIndexOf('/'));
                            logger.log(`[Copy-Paste] Pasting '${clipboard.path}' into determined destination: '${destinationDir}'`);
                            clientIpc.sendToServer(ClientToServerChannel.RequestCopyFile, { sourcePath: clipboard.path, destinationDir });
                        } else {
                            logger.error(`[Copy-Paste] Could not find target node for path: ${focusedNodePath}`);
                        }
                    }
                    return;
                case 'z':
                    e.preventDefault(); e.stopPropagation();
                    clientIpc.sendToServer(ClientToServerChannel.RequestUndo, {});
                    return;
                case 'y':
                    e.preventDefault(); e.stopPropagation();
                    clientIpc.sendToServer(ClientToServerChannel.RequestRedo, {});
                    return;
            }
        }

        if (e.key === 'Delete') {
            e.preventDefault();
            e.stopPropagation();
            let pathsToDelete: string[] = [];
            if (selectedPaths.size > 0) {
                pathsToDelete = Array.from(selectedPaths);
            } else if (focusedNodePath) {
                pathsToDelete = [focusedNodePath];
            }
            if (pathsToDelete.length > 0) {
                logger.log(`[Delete] Delete key pressed. Requesting deletion of ${pathsToDelete.length} items.`);
                clientIpc.sendToServer(ClientToServerChannel.RequestBatchFileDelete, { paths: pathsToDelete });
            }
            return;
        }

        if (!focusedNodePath) return;
        const currentIndex = flatNodeList.current.findIndex(n => n.absolutePath === focusedNodePath);
        if (currentIndex === -1) return;
        const currentNode = flatNodeList.current[currentIndex];

        const moveFocus = (nextIndex: number) => {
            if (nextIndex >= 0 && nextIndex < flatNodeList.current.length) {
                const nextNodePath = flatNodeList.current[nextIndex].absolutePath;
                setFocusedNodePath(nextNodePath);
                nodeRefs.current.get(nextNodePath)?.scrollIntoView({ block: 'nearest', inline: 'nearest' });
            }
        };
        
        switch (e.key) {
            case 'ArrowUp': e.preventDefault(); e.stopPropagation(); moveFocus(currentIndex - 1); break;
            case 'ArrowDown': e.preventDefault(); e.stopPropagation(); moveFocus(currentIndex + 1); break;
            case 'ArrowRight': e.preventDefault(); e.stopPropagation(); if (currentNode.children) expandNode(currentNode.absolutePath); break;
            case 'ArrowLeft': e.preventDefault(); e.stopPropagation(); if (currentNode.children && expandedNodes.includes(currentNode.absolutePath)) setExpandedNodes(prev => prev.filter(p => p !== currentNode.absolutePath)); break;
            case ' ': e.preventDefault(); e.stopPropagation(); updateCheckedFiles(currentNode.absolutePath); break;
            case 'Enter': e.preventDefault(); e.stopPropagation(); if (currentNode.children) setExpandedNodes(prev => prev.includes(currentNode.absolutePath) ? prev.filter(p => p !== currentNode.absolutePath) : [...prev, currentNode.absolutePath]); else clientIpc.sendToServer(ClientToServerChannel.RequestOpenFile, { path: currentNode.absolutePath }); break;
        }
    };

    // --- Drag/Drop ---
    const handleInternalDragStart = (e: React.DragEvent, node: TreeNode) => {
        e.stopPropagation();
        setDraggedPath(node.absolutePath);
        e.dataTransfer.effectAllowed = 'move';
        logger.log(`Internal Drag Start: ${node.name}`);
    };

    const handleDragEnter = (e: React.DragEvent, node: TreeNode) => {
        e.preventDefault();
        e.stopPropagation();
        logger.log(`Drag Enter on node: ${node.name}`);
        if (node.children && node.absolutePath !== draggedPath) {
            setDropTarget(node.absolutePath);
            if (!expandedNodes.includes(node.absolutePath)) {
                expansionTimer.current = setTimeout(() => {
                    logger.log(`Hover-expanding node: ${node.name}`);
                    expandNode(node.absolutePath);
                }, 500);
            }
        }
    };

    const handleDragLeave = (e: React.DragEvent, node: TreeNode) => {
        e.preventDefault();
        e.stopPropagation();
        logger.log(`Drag Leave from node: ${node.name}`);
        if (dropTarget === node.absolutePath) {
            setDropTarget(null);
        }
        if (expansionTimer.current) {
            clearTimeout(expansionTimer.current);
            expansionTimer.current = null;
        }
    };

    const handleDrop = (e: React.DragEvent, node: TreeNode) => {
        e.preventDefault();
        e.stopPropagation();
        logger.log(`Drop on node: ${node.name}`);
        setDropTarget(null);
        if (expansionTimer.current) {
            clearTimeout(expansionTimer.current);
            expansionTimer.current = null;
        }

        if (draggedPath) { // Internal move
            if (node.children && node.absolutePath !== draggedPath && !node.absolutePath.startsWith(draggedPath + '/')) {
                const draggedName = draggedPath.split('/').pop();
                if (draggedName) {
                    const newPath = `${node.absolutePath}/${draggedName}`;
                    logger.log(`Requesting internal move from ${draggedPath} to ${newPath}`);
                    clientIpc.sendToServer(ClientToServerChannel.RequestMoveFile, { oldPath: draggedPath, newPath });
                }
            }
            setDraggedPath(null);
        } else if (onNodeDrop) { // External drop
            onNodeDrop(e, node as FileNode);
        }
    };
    
    const handleDragOver = (e: React.DragEvent, node: TreeNode) => {
        e.preventDefault();
        e.stopPropagation();
        if (draggedPath && node.absolutePath.startsWith(draggedPath + '/')) {
            e.dataTransfer.dropEffect = 'none'; // Prevent dropping a folder into itself
        } else {
            e.dataTransfer.dropEffect = 'move';
        }
    };

    const renderTreeNodes = (nodes: TreeNode[]) => {
        return nodes.map((node) => {
            const isExpanded = expandedNodes.includes(node.absolutePath);
            const isSelected = selectedPaths.has(node.absolutePath);
            const isFocused = focusedNodePath === node.absolutePath;
            const isDirectory = !!(node.children && node.children.length > 0);
            const isDropTarget = dropTarget === node.absolutePath;

            return (
                <li key={node.absolutePath} 
                    ref={el => {
                        if (el) {
                            nodeRefs.current.set(node.absolutePath, el);
                        } else {
                            nodeRefs.current.delete(node.absolutePath);
                        }
                    }}
                    draggable="true"
                    onDragStart={(e) => handleInternalDragStart(e, node)}
                    onDragEnter={(e) => handleDragEnter(e, node)}
                    onDragLeave={(e) => handleDragLeave(e, node)}
                    onDragOver={(e) => handleDragOver(e, node)}
                    onDrop={(e) => handleDrop(e, node)}
                    className={`treenode-li ${isDropTarget ? 'drop-target' : ''}`}
                    data-path={node.absolutePath}
                >
                    <div
                        className={`treenode-item-wrapper ${isSelected ? 'selected' : ''} ${isFocused ? 'focused' : ''}`}
                        onClick={(e) => handleNodeClick(e, node)}
                        onContextMenu={(e) => onContextMenu?.(e, node)}
                    >
                        <span className={`treenode-chevron ${isExpanded ? 'expanded' : ''}`}>
                            {isDirectory && <VscChevronRight />}
                        </span>
                        <div className="treenode-content">
                            {renderNodeContent ? renderNodeContent(node, isExpanded) : node.name}
                        </div>
                    </div>
                    {isDirectory && isExpanded && (
                        <ul className="treenode-children">{renderTreeNodes(node.children)}</ul>
                    )}
                </li>
            );
        });
    };

    return (
        <div 
            className="tree-view" 
            tabIndex={0} 
            onKeyDown={handleKeyDown} 
            ref={treeViewRef}
            onClick={() => treeViewRef.current?.focus()}
        >
            <ul>{renderTreeNodes(data)}</ul>
        </div>
    );
};

export default TreeView;
</file>

<file path="src/client/components/tree-view/TreeView.utils.ts">
import { TreeNode } from "./TreeView";

export const getExpandedNodes = (data: TreeNode[]): string[] => {
  return data.reduce((acc: string[], node) => {
    if (node.isExpanded) {
      acc.push(node.absolutePath);
    }
    if (node.children) {
      acc.push(...getExpandedNodes(node.children));
    }
    return acc;
  }, []);
};
</file>

<file path="src/client/utils/logger.ts">
import { ClientPostMessageManager } from "@/common/ipc/client-ipc";
import { ClientToServerChannel } from "@/common/ipc/channels.enum";

const clientIpc = ClientPostMessageManager.getInstance();

export const logger = {
    log: (message: string) => {
        console.log(message); // Also log to dev console
        clientIpc.sendToServer(ClientToServerChannel.LogMessage, { level: 'info', message });
    },
    warn: (message: string) => {
        console.warn(message);
        clientIpc.sendToServer(ClientToServerChannel.LogMessage, { level: 'warn', message });
    },
    error: (message: string) => {
        console.error(message);
        clientIpc.sendToServer(ClientToServerChannel.LogMessage, { level: 'error', message });
    }
};
</file>

<file path="src/client/utils/response-parser.ts">
// Updated on: C131 (Add more aggressive final cleanup)
import { ParsedResponse } from '@/common/types/pcpp.types';

const SUMMARY_REGEX = /^([\s\S]*?)(?=### Course of [Aa]ction|### Files Updated This Cycle|<file path=")/;
const COURSE_OF_ACTION_REGEX = /### Course of [Aa]ction\s*([\s\S]*?)(?=### Files Updated This Cycle|<file path=")/im;
const FILES_UPDATED_LIST_REGEX = /### Files Updated This Cycle\s*([\s\S]*?)(?=<file path="|`{3,})/m;
const FILE_TAG_REGEX = /<file path="([^"]+)">([\s\S]*?)<\/file>/g;
const CODE_FENCE_START_REGEX = /^\s*```[a-zA-Z]*\n/;


export function parseResponse(rawText: string): ParsedResponse {
    const files = [];
    let filesUpdatedList: string[] = [];

    const tagMatches = [...rawText.matchAll(FILE_TAG_REGEX)];

    for (const match of tagMatches) {
        const path = (match?.[1] ?? '').trim();
        let content = (match?.[2] ?? ''); // Start with raw content

        if (path) {
            // C129: Aggressive multi-pass cleanup
            content = content.replace(CODE_FENCE_START_REGEX, '');

            const patternsToRemove = [
                `</file>`,
                `</${path}>`,
                '```',
                '***'
            ];
    
            let changed = true;
            while(changed) {
                const originalContent = content;
                for (const pattern of patternsToRemove) {
                    if (content.trim().endsWith(pattern)) {
                        content = content.trim().slice(0, -pattern.length);
                    }
                }
                if (content === originalContent) {
                    changed = false;
                }
            }
            
            // C131: Final aggressive trim to remove any leading/trailing whitespace or newlines
            // that could interfere with diffing.
            content = content.trim();

            files.push({ path, content });
        }
    }

    const summaryMatch = rawText.match(SUMMARY_REGEX);
    const courseOfActionMatch = rawText.match(COURSE_OF_ACTION_REGEX);
    
    const summary = (summaryMatch?.[1] ?? 'Could not parse summary.').trim();
    const courseOfAction = (courseOfActionMatch?.[1] ?? 'Could not parse course of action.').trim();

    if (files.length > 0) {
        filesUpdatedList = files.map(f => f.path);
    } else {
        const filesUpdatedMatch = rawText.match(FILES_UPDATED_LIST_REGEX);
        if (filesUpdatedMatch?.[1]) {
            filesUpdatedList.push(...(filesUpdatedMatch[1] ?? '')
                .split('\n')
                .map(line => {
                    const backtickMatch = /`([^`]+)`/.exec(line);
                    return backtickMatch ? backtickMatch[1].trim() : '';
                })
                .filter(line => line.length > 0 && line.includes('.'))
            );
        }
    }

    return {
        summary,
        courseOfAction,
        filesUpdated: [...new Set(filesUpdatedList)],
        files,
    };
}
</file>

<file path="src/client/views/context-chooser.view/index.ts">
import { onMessage } from "./on-message";

export const viewConfig = {
    entry: "contextChooserView.js",
    type: "viewType.sidebar.contextChooser",
    handleMessage: onMessage,
};
</file>

<file path="src/client/views/context-chooser.view/on-message.ts">
// Updated on: C115 (Ensure file reflects correct service calls)
import { ServerPostMessageManager } from "@/common/ipc/server-ipc";
import { ClientToServerChannel, ServerToClientChannel } from "@/common/ipc/channels.enum";
import { Services } from "@/backend/services/services";
import * as vscode from "vscode";

export function onMessage(serverIpc: ServerPostMessageManager) {
    const { fileTreeService, fileOperationService, contentExtractionService, flattenerService, selectionService, actionService, loggerService } = Services;

    serverIpc.onClientMessage(ClientToServerChannel.RequestInitialData, () => {
        serverIpc.sendToClient(ServerToClientChannel.SendWorkspaceTrustState, { isTrusted: vscode.workspace.isTrusted });
        fileTreeService.handleWorkspaceFilesRequest(serverIpc, false);
    });

    serverIpc.onClientMessage(ClientToServerChannel.RequestWorkspaceFiles, (data) => fileTreeService.handleWorkspaceFilesRequest(serverIpc, data.force));
    serverIpc.onClientMessage(ClientToServerChannel.RequestFlattenContext, (data) => flattenerService.flatten(data.selectedPaths));
    serverIpc.onClientMessage(ClientToServerChannel.RequestNewFile, (data) => fileOperationService.handleNewFileRequest(data.parentDirectory));
    serverIpc.onClientMessage(ClientToServerChannel.RequestNewFolder, (data) => fileOperationService.handleNewFolderRequest(data.parentDirectory));
    serverIpc.onClientMessage(ClientToServerChannel.RequestFileRename, (data) => fileOperationService.handleFileRenameRequest(data.oldPath, data.newName));
    serverIpc.onClientMessage(ClientToServerChannel.RequestFileDelete, (data) => fileOperationService.handleFileDeleteRequest(data.path));
    serverIpc.onClientMessage(ClientToServerChannel.RequestBatchFileDelete, (data) => fileOperationService.handleBatchFileDeleteRequest(data.paths));
    serverIpc.onClientMessage(ClientToServerChannel.RequestRevealInExplorer, (data) => fileOperationService.handleRevealInExplorerRequest(data.path));
    serverIpc.onClientMessage(ClientToServerChannel.RequestCopyPath, (data) => fileOperationService.handleCopyPathRequest(data.path, data.relative));
    serverIpc.onClientMessage(ClientToServerChannel.RequestOpenFile, (data) => fileOperationService.handleOpenFileRequest(data.path));
    serverIpc.onClientMessage(ClientToServerChannel.RequestMoveFile, (data) => fileOperationService.handleMoveFileRequest(data.oldPath, data.newPath));
    serverIpc.onClientMessage(ClientToServerChannel.RequestCopyFile, (data) => fileOperationService.handleCopyFileRequest(data.sourcePath, data.destinationDir));
    serverIpc.onClientMessage(ClientToServerChannel.RequestAddFileFromBuffer, (data) => fileOperationService.handleAddFileFromBuffer(data.targetPath, data.data));
    serverIpc.onClientMessage(ClientToServerChannel.RequestCopyFileFromUri, (data) => fileOperationService.handleCopyFileFromUri(data.sourceUri, data.targetDir));
    serverIpc.onClientMessage(ClientToServerChannel.RequestPdfToText, (data) => contentExtractionService.handlePdfToTextRequest(data.path, serverIpc));
    serverIpc.onClientMessage(ClientToServerChannel.RequestExcelToText, (data) => contentExtractionService.handleExcelToTextRequest(data.path, serverIpc));
    serverIpc.onClientMessage(ClientToServerChannel.RequestWordToText, (data) => contentExtractionService.handleWordToTextRequest(data.path, serverIpc));
    serverIpc.onClientMessage(ClientToServerChannel.RequestUndo, () => actionService.undo());
    serverIpc.onClientMessage(ClientToServerChannel.RequestRedo, () => actionService.redo());
    serverIpc.onClientMessage(ClientToServerChannel.SaveCurrentSelection, (data) => selectionService.saveCurrentSelection(data.paths));

    serverIpc.onClientMessage(ClientToServerChannel.RequestLastSelection, async () => {
        const lastSelection = await selectionService.getLastSelection();
        const autoAddState = selectionService.getAutoAddState();
        serverIpc.sendToClient(ServerToClientChannel.ApplySelectionSet, { paths: lastSelection });
        serverIpc.sendToClient(ServerToClientChannel.SendSelectionSets, { sets: selectionService.getSelectionSets() });
        serverIpc.sendToClient(ServerToClientChannel.SendAutoAddState, { enabled: autoAddState });
    });

    serverIpc.onClientMessage(ClientToServerChannel.SaveAutoAddState, (data) => selectionService.saveAutoAddState(data.enabled));
    serverIpc.onClientMessage(ClientToServerChannel.VSCodeCommand, (data) => vscode.commands.executeCommand(data.command, ...(data.args || [])));

    serverIpc.onClientMessage(ClientToServerChannel.LogMessage, (data) => {
        const logMessage = `[WebView] ${data.message}`;
        if (data.level === 'warn') loggerService.warn(logMessage);
        else if (data.level === 'error') loggerService.error(logMessage);
        else loggerService.log(logMessage);
    });
}
</file>

<file path="src/client/views/context-chooser.view/view.scss">
/* Updated on: C59 (Add Workspace Trust banner styling) */
body {
    padding: 0;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
    font-size: 13px;
    color: var(--vscode-editor-foreground);
    background-color: var(--vscode-sideBar-background);
}

.workspace-trust-banner {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 6px 8px;
    background-color: var(--vscode-statusBarItem-warningBackground);
    color: var(--vscode-statusBarItem-warningForeground);
    font-size: 12px;
    flex-shrink: 0;

    button {
        background: none;
        border: 1px solid var(--vscode-button-border, var(--vscode-contrastBorder));
        color: var(--vscode-button-foreground);
        padding: 2px 8px;
        border-radius: 2px;
        cursor: pointer;
        margin-left: auto;

        &:hover {
            background-color: var(--vscode-button-hoverBackground);
        }
    }
}


.view-container {
    display: flex;
    flex-direction: column;
    height: 100vh;
    outline: 2px solid transparent;
    transition: outline-color 0.2s ease-in-out;
}

.view-container.drag-over {
    outline-color: var(--vscode-focusBorder);
    outline-style: dashed;
}


.view-header {
    padding: 0 8px; /* Remove vertical padding */
    border-bottom: 1px solid var(--vscode-panel-border);
    display: flex;
    flex-direction: column; /* Stack title/search and toolbar */
    gap: 4px;
    padding-top: 4px;
    padding-bottom: 4px;
    flex-shrink: 0;
}

.header-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    min-height: 28px; /* Ensure consistent height */
}

.search-container {
    width: 100%;
    padding-bottom: 4px;

    input {
        width: 100%;
        background-color: var(--vscode-input-background);
        color: var(--vscode-input-foreground);
        border: 1px solid var(--vscode-input-border);
        padding: 2px 4px;
        border-radius: 2px;
        outline: none;

        &:focus {
            border-color: var(--vscode-focusBorder);
        }
    }
}


.toolbar {
    display: flex;
    gap: 4px;
    
    button, .dropdown-button {
        background: none;
        border: none;
        color: var(--vscode-icon-foreground);
        cursor: pointer;
        padding: 4px;
        border-radius: 3px;
        display: flex;
        align-items: center;
        justify-content: center;

        &:hover {
            background-color: var(--vscode-toolbar-hoverBackground);
        }

        &.active {
             background-color: var(--vscode-toolbar-hoverBackground);
             color: var(--vscode-focusBorder);
        }
    }

    .spinner {
        display: flex;
        align-items: center;
        padding: 4px;
        animation: spin 1.5s linear infinite;
    }

    @keyframes spin {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
    }
}

.selected-files-panel {
    display: flex;
    flex-direction: column;
    flex-shrink: 0; 
    border-top: 1px solid var(--vscode-panel-border);
    max-height: 40%; /* Give it a max height */
}

.panel-header {
    font-weight: bold;
    padding: 4px 8px;
    font-size: 11px;
    text-transform: uppercase;
    color: var(--vscode-sideBar-titleForeground);
    border-bottom: 1px solid var(--vscode-panel-border);
    flex-shrink: 0;
    display: flex;
    justify-content: space-between;
    align-items: center;

    .toolbar-button {
        background: none;
        border: none;
        color: var(--vscode-icon-foreground);
        cursor: pointer;
        padding: 2px;
        border-radius: 3px;
        display: flex;
        align-items: center;
        justify-content: center;

        &:hover {
            background-color: var(--vscode-toolbar-hoverBackground);
        }
    }
}

.panel-toolbar {
    padding: 4px 8px;
    flex-shrink: 0;
    border-bottom: 1px solid var(--vscode-panel-border);

    button {
        background-color: var(--vscode-button-secondaryBackground);
        color: var(--vscode-button-secondaryForeground);
        border: 1px solid var(--vscode-button-border, var(--vscode-focusBorder));
        padding: 2px 8px;
        font-size: 12px;
        cursor: pointer;
        border-radius: 2px;
        
        &:hover {
            background-color: var(--vscode-button-secondaryHoverBackground);
        }

        &:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
    }
}

.selected-files-list-container {
    overflow-y: auto;
    flex-grow: 1;
}

.selected-list-header {
    display: flex;
    align-items: center; /* Align items vertically */
    font-weight: bold;
    font-size: 11px;
    padding: 2px 8px;
    border-bottom: 1px solid var(--vscode-panel-border);
    user-select: none;
    gap: 8px; /* Add gap for spacing */

    > div {
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 4px;
    }

    .header-index {
        width: 30px;
        flex-shrink: 0;
        text-align: right; /* Right-align the '#' header */
        padding-right: 10px;
        justify-content: flex-end; /* Ensure flex items are at the end */
    }

    .header-type {
        width: 20px;
        flex-shrink: 0;
        justify-content: center;
    }

    .header-name {
        flex-grow: 1;
    }

    .header-tokens {
        flex-shrink: 0;
        width: 80px;
        justify-content: flex-end;
    }
}

.selected-files-list {
    list-style: none;
    padding: 0;
    margin: 0;

    &:focus {
        outline: 1px solid var(--vscode-focusBorder);
        outline-offset: -1px;
    }

    li {
        display: flex;
        align-items: center;
        padding: 2px 8px;
        font-size: 12px;
        gap: 8px;
        cursor: pointer;
        user-select: none;
        border-radius: 2px;
        margin: 1px 2px;

        &.selected {
            background-color: var(--vscode-list-activeSelectionBackground) !important; /* Use important to override token color */
            color: var(--vscode-list-activeSelectionForeground) !important;
        }

        &:hover {
            background-color: var(--vscode-list-hoverBackground);
        }
        
        .file-index {
            width: 30px;
            flex-shrink: 0;
            color: var(--vscode-descriptionForeground);
            text-align: right; /* Right-align the numbers */
            padding-right: 10px;
            position: relative;
            display: flex;
            justify-content: flex-end; /* Right-align the content (number or icon) */
            align-items: center;
            height: 100%;
        }

        .quick-remove-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            color: var(--vscode-icon-foreground);
            &:hover {
                color: var(--vscode-errorForeground);
            }
        }

        .file-icon {
            font-size: 16px;
            width: 20px;
            flex-shrink: 0;
            text-align: center;
        }

        .file-name {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex-grow: 1;
        }

        .file-tokens {
            color: var(--vscode-descriptionForeground);
            font-variant-numeric: tabular-nums;
            width: 80px;
            text-align: right;
            flex-shrink: 0;
        }
    }
}

.file-tree-container {
    flex-grow: 1; 
    overflow-y: auto;
    overflow-x: hidden;
    min-height: 0; /* CRITICAL FIX for flexbox overflow */
    border-right: 1px solid var(--vscode-panel-border); /* Fix for scrollbar gutter visibility */
}

.view-footer {
    padding: 8px;
    border-top: 1px solid var(--vscode-panel-border);
    display: flex;
    flex-direction: column;
    gap: 8px;
    flex-shrink: 0;
}

.flatten-button {
    width: 100%;
    padding: 6px;
    border: 1px solid var(--vscode-button-border, var(--vscode-focusBorder));
    background-color: var(--vscode-button-background);
    color: var(--vscode-button-foreground);
    cursor: pointer;
    border-radius: 2px;
}

.flatten-button:hover {
    background-color: var(--vscode-button-hoverBackground);
}

.loading-message {
    padding: 8px;
    color: var(--vscode-descriptionForeground);
}

.summary-panel {
    font-size: 12px;
    color: var(--vscode-descriptionForeground);
    display: flex;
    justify-content: space-between;
    gap: 12px;
}

.summary-item {
    display: flex;
    align-items: center;
    gap: 4px;
}

.tree-view {
    &:focus {
        outline: none; /* Remove default browser focus ring */
    }

    ul {
        list-style-type: none;
        margin: 0;
        padding-left: 0;
    }

    ul.treenode-children {
        padding-left: 10px; 
    }
}


.treenode-li {
    position: relative;
    border-radius: 3px;
}

/* Drag and Drop style */
.treenode-li.drop-target > .treenode-item-wrapper {
    background-color: var(--vscode-list-dropBackground) !important;
    outline: 1px solid var(--vscode-focusBorder) !important;
}

.treenode-item-wrapper {
    display: flex;
    align-items: center;
    cursor: pointer;
    padding: 1px 4px;
    border-radius: 3px;
    min-height: 22px;
    outline: 1px solid transparent; /* Placeholder for focus ring */
    outline-offset: -1px;
}

.treenode-item-wrapper.focused {
    outline-color: var(--vscode-focusBorder);
}

.treenode-item-wrapper:hover {
    background-color: var(--vscode-list-hoverBackground);
}

.treenode-item-wrapper.selected {
    background-color: var(--vscode-list-activeSelectionBackground);
    color: var(--vscode-list-activeSelectionForeground);
}

.treenode-chevron {
    flex-shrink: 0;
    width: 20px;
    height: 22px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: transform 0.1s ease-in-out;
}

.treenode-chevron.expanded {
    transform: rotate(90deg);
}

.treenode-content {
    flex-grow: 1;
    display: flex;
    align-items: center;
    overflow: hidden;
}


.file-item {
    display: flex;
    align-items: center;
    width: 100%;
    padding: 1px;
    gap: 6px;
}

.file-checkbox {
    cursor: pointer;
    flex-shrink: 0;
}

.file-icon {
    display: flex;
    align-items: center;
    font-size: 16px;
    flex-shrink: 0;
}

.file-name {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    flex-grow: 1;
    user-select: none; /* Prevent text selection on click/drag */
}

/* Error Styling */
.file-item.has-error {
    color: var(--vscode-list-errorForeground);
    opacity: 0.7;

    .file-name {
        text-decoration: line-through;
    }
}

.error-icon {
    color: var(--vscode-errorForeground);
}


/* Git Status & Problems Styling */
.file-item.git-status-M .file-name, .file-item.git-status-M .git-status-badge { color: var(--vscode-gitDecoration-modifiedResourceForeground); }
.file-item.git-status-U .file-name, .file-item.git-status-U .git-status-badge { color: var(--vscode-gitDecoration-untrackedResourceForeground); }
.file-item.git-status-D .file-name, .file-item.git-status-D .git-status-badge { color: var(--vscode-gitDecoration-deletedResourceForeground); }
.file-item.git-status-A .file-name, .file-item.git-status-A .git-status-badge { color: var(--vscode-gitDecoration-addedResourceForeground); }
.file-item.git-status-C .file-name, .file-item.git-status-C .git-status-badge { color: var(--vscode-gitDecoration-conflictingResourceForeground); }
.file-item.git-status-I .file-name, .file-item.git-status-I .git-status-badge { color: var(--vscode-gitDecoration-ignoredResourceForeground); }

.file-item.problem-error .file-name { color: var(--vscode-list-errorForeground); }
.file-item.problem-warning .file-name { color: var(--vscode-list-warningForeground); }

.git-status-badge {
    font-weight: bold;
}

.problem-badge {
    display: flex;
    align-items: center;
    gap: 3px;
    
    & .error-icon {
      color: var(--vscode-list-errorForeground);
    }
    
    & .warning-icon {
      color: var(--vscode-list-warningForeground);
    }
}

.file-stats {
    margin-left: auto;
    padding-left: 8px;
    font-size: 11px;
    color: var(--vscode-descriptionForeground);
    flex-shrink: 0;
    white-space: nowrap;
    display: flex;
    align-items: center;
    gap: 8px;
    justify-content: flex-end;
    text-align: right;
}

.file-stats > * {
    display: flex;
    align-items: center;
    gap: 3px;
}

.selected-token-count {
    font-style: italic;
}

/* Context Menu Styles */
.context-menu-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 999;
}

.context-menu {
    position: absolute;
    background-color: var(--vscode-menu-background);
    border: 1px solid var(--vscode-menu-border);
    color: var(--vscode-menu-foreground);
    box-shadow: 0 2px 8px var(--vscode-widget-shadow);
    border-radius: 4px;
    padding: 4px 0;
    min-width: 180px;
    z-index: 1000;

    ul {
        list-style: none;
        padding: 0;
        margin: 0;
    }

    li {
        padding: 4px 12px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 8px;

        &:hover {
            background-color: var(--vscode-menu-selectionBackground);
            color: var(--vscode-menu-selectionForeground);
        }
    }

    hr {
        border: none;
        border-top: 1px solid var(--vscode-menu-separatorBackground);
        margin: 4px 0;
    }
}

.rename-input {
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    border: 1px solid var(--vscode-focusBorder);
    outline: none;
    width: 100%;
    padding: 0;
    margin: 0;
    font-size: inherit;
    font-family: inherit;
}
</file>

<file path="src/client/views/context-chooser.view/view.tsx">
// Updated on: C83 (Fix onNodeDrop type)
import * as React from 'react';
import * as ReactDOM from 'react-dom/client';
import './view.scss';
import { ClientPostMessageManager } from '@/common/ipc/client-ipc';
import { ClientToServerChannel, ServerToClientChannel } from '@/common/ipc/channels.enum';
import { FileNode } from '@/common/types/file-node';
import FileTree from '../../components/file-tree/FileTree';
import { useState, useEffect, useMemo, useCallback, useRef } from 'react';
import { formatLargeNumber, formatNumberWithCommas } from '@/common/utils/formatting';
import { VscFiles, VscSymbolNumeric, VscCollapseAll, VscRefresh, VscNewFile, VscNewFolder, VscLoading, VscSave, VscFolderLibrary, VscSettingsGear, VscCheckAll, VscSearch, VscExpandAll, VscShield } from 'react-icons/vsc';
import { logger } from '@/client/utils/logger';
import SelectedFilesView from '../../components/SelectedFilesView';
import { addRemovePathInSelectedFiles, removePathsFromSelected } from '@/client/components/file-tree/FileTree.utils';
import { SelectionSet, ProblemCountsMap } from '@/common/ipc/channels.type';
import path from 'path-browserify';

const EXCEL_EXTENSIONS = new Set(['.xlsx', '.xls', '.csv']);
const WORD_EXTENSIONS = new Set(['.docx', '.doc']);

const App = () => {
    const [files, setFiles] = useState<FileNode[]>([]);
    const [checkedFiles, setCheckedFiles] = useState<string[]>([]);
    const [activeFile, setActiveFile] = useState<string | undefined>();
    const [collapseTrigger, setCollapseTrigger] = useState(0);
    const [expandAllTrigger, setExpandAllTrigger] = useState(0);
    const [isLoading, setIsLoading] = useState(true);
    const [selectionSets, setSelectionSets] = useState<SelectionSet>({});
    const [isSelectionListMinimized, setIsSelectionListMinimized] = useState(false);
    const [isAutoAddEnabled, setIsAutoAddEnabled] = useState(false);
    const [isSearchVisible, setIsSearchVisible] = useState(false);
    const [searchTerm, setSearchTerm] = useState('');
    const [problemMap, setProblemMap] = useState<ProblemCountsMap>({});
    const [isDraggingOver, setIsDraggingOver] = useState(false);
    const [isWorkspaceTrusted, setIsWorkspaceTrusted] = useState(true); // Assume trusted by default
    const [clipboard, setClipboard] = useState<{ path: string; type: 'copy' } | null>(null);
    const suppressActiveFileReveal = useRef(false);
    const processedFilesCache = useRef(new Set<string>());
    
    const clientIpc = ClientPostMessageManager.getInstance();

    const requestFiles = (force = false) => {
        setIsLoading(true);
        logger.log(`Requesting workspace files (force=${force}).`);
        clientIpc.sendToServer(ClientToServerChannel.RequestWorkspaceFiles, { force });
    };

    const updateCheckedFiles = useCallback((path: string) => {
        setCheckedFiles(currentChecked => {
            const newChecked = addRemovePathInSelectedFiles(files, path, currentChecked);
            clientIpc.sendToServer(ClientToServerChannel.SaveCurrentSelection, { paths: newChecked });
            return newChecked;
        });
    }, [clientIpc, files]);

    // Effect for pre-warming cache when selection or file tree changes
    useEffect(() => {
        if (files.length === 0 || checkedFiles.length === 0) {
            return;
        }

        const effectivelySelectedFiles = new Set<string>();
        const fileMap = new Map<string, FileNode>();
        
        const buildFileMap = (node: FileNode) => {
            fileMap.set(node.absolutePath, node);
            node.children?.forEach(buildFileMap);
        };
        files.forEach(buildFileMap);

        const addDescendantFiles = (node: FileNode) => {
            if (!node.children) {
                effectivelySelectedFiles.add(node.absolutePath);
            } else {
                node.children.forEach(addDescendantFiles);
            }
        };

        checkedFiles.forEach(path => {
            const node = fileMap.get(path);
            if (node) {
                if (node.children) {
                    addDescendantFiles(node);
                } else {
                    effectivelySelectedFiles.add(path);
                }
            }
        });

        logger.log(`[Cache Pre-warm] Found ${effectivelySelectedFiles.size} effectively selected files.`);

        effectivelySelectedFiles.forEach(path => {
            if (processedFilesCache.current.has(path)) {
                return; // Already processed
            }

            const extension = `.${path.split('.').pop()?.toLowerCase() || ''}`;
            
            let requested = false;
            if (extension === '.pdf') {
                logger.log(`[Cache Pre-warm] Requesting PDF processing for: ${path}`);
                clientIpc.sendToServer(ClientToServerChannel.RequestPdfToText, { path });
                requested = true;
            } else if (EXCEL_EXTENSIONS.has(extension)) {
                logger.log(`[Cache Pre-warm] Requesting Excel processing for: ${path}`);
                clientIpc.sendToServer(ClientToServerChannel.RequestExcelToText, { path });
                requested = true;
            } else if (WORD_EXTENSIONS.has(extension)) {
                logger.log(`[Cache Pre-warm] Requesting Word processing for: ${path}`);
                clientIpc.sendToServer(ClientToServerChannel.RequestWordToText, { path });
                requested = true;
            }

            if (requested) {
                processedFilesCache.current.add(path);
            }
        });

    }, [checkedFiles, files, clientIpc]);


    useEffect(() => {
        logger.log("Initializing view and requesting initial data.");
        
        clientIpc.onServerMessage(ServerToClientChannel.SendWorkspaceTrustState, ({ isTrusted }) => {
            logger.log(`Received workspace trust state: ${isTrusted}`);
            setIsWorkspaceTrusted(isTrusted);
        });

        clientIpc.onServerMessage(ServerToClientChannel.SendWorkspaceFiles, ({ files: receivedFiles }) => {
            logger.log(`Received file tree from backend. Root node: ${receivedFiles[0]?.name}`);
            setFiles(receivedFiles);
            setIsLoading(false);
        });
        
        clientIpc.onServerMessage(ServerToClientChannel.ApplySelectionSet, ({ paths }) => {
            logger.log(`[C80 CACHE FIX] Applying selection set with ${paths.length} paths.`);
            setCheckedFiles(paths);
            clientIpc.sendToServer(ClientToServerChannel.SaveCurrentSelection, { paths });
        });

        clientIpc.onServerMessage(ServerToClientChannel.SendSelectionSets, ({ sets }) => {
            logger.log(`[WebView] Received ${Object.keys(sets).length} selection sets.`);
            setSelectionSets(sets);
        });

        clientIpc.onServerMessage(ServerToClientChannel.SetActiveFile, ({ path }) => {
            if (suppressActiveFileReveal.current) {
                logger.log(`[WebView] Suppressing set active file event for: ${path}`);
                suppressActiveFileReveal.current = false;
                return;
            }
            logger.log(`[WebView] [WebView] Received set active file event for: ${path}`);
            setActiveFile(path);
        });

        clientIpc.onServerMessage(ServerToClientChannel.FocusFile, ({ path }) => {
            logger.log(`[WebView] Received focus file event for: ${path}`);
            setActiveFile(path);
        });

        clientIpc.onServerMessage(ServerToClientChannel.SendAutoAddState, ({ enabled }) => {
            logger.log(`[WebView] Received auto-add state: ${enabled}`);
            setIsAutoAddEnabled(enabled);
        });

        clientIpc.onServerMessage(ServerToClientChannel.ForceRefresh, ({ reason }) => {
            logger.log(`[WebView] Force refresh triggered from backend. Reason: ${reason || 'unknown'}`);
            if (reason === 'fileOp') {
                suppressActiveFileReveal.current = true;
                setTimeout(() => { suppressActiveFileReveal.current = false; }, 2000);
            }
            requestFiles(true);
            clientIpc.sendToServer(ClientToServerChannel.RequestLastSelection, {});
        });

        clientIpc.onServerMessage(ServerToClientChannel.UpdateProblemCounts, ({ problemMap: newProblemMap }) => {
            logger.log(`[WebView] Received dynamic problem counts update with ${Object.keys(newProblemMap).length} entries.`);
            setProblemMap(newProblemMap);
        });

        clientIpc.onServerMessage(ServerToClientChannel.UpdateNodeStats, ({ path, tokenCount, error }) => {
            logger.log(`Received stats update for ${path}. New token count: ${tokenCount}, Error: ${error}`);
            processedFilesCache.current.add(path); // Mark as processed so we don't request it again
            setFiles(currentFiles => {
                const newFiles = JSON.parse(JSON.stringify(currentFiles));
                let nodeUpdated = false;
                const findAndUpdate = (nodes: FileNode[]) => {
                    for (const node of nodes) {
                        if (node.absolutePath === path) {
                            node.tokenCount = tokenCount;
                            node.error = error;
                            nodeUpdated = true;
                            return true;
                        }
                        if (node.children && findAndUpdate(node.children)) return true;
                    }
                    return false;
                };
                findAndUpdate(newFiles);
                return nodeUpdated ? newFiles : currentFiles;
            });
        });

        clientIpc.sendToServer(ClientToServerChannel.RequestInitialData, {});
        clientIpc.sendToServer(ClientToServerChannel.RequestLastSelection, {});

    }, [clientIpc]);

    const handleFlattenClick = () => {
        logger.log(`Flatten Context button clicked with ${checkedFiles.length} paths.`);
        clientIpc.sendToServer(ClientToServerChannel.RequestFlattenContext, { selectedPaths: checkedFiles });
    };

    const handleRefresh = () => {
        logger.log("Refresh button clicked.");
        processedFilesCache.current.clear(); // Clear cache on manual refresh
        requestFiles(true);
    };
    
    const handleExpandAll = () => {
        logger.log("Expand All button clicked.");
        setExpandAllTrigger(c => c + 1);
    };

    const handleCollapseAll = () => {
        logger.log("Collapse All button clicked.");
        setCollapseTrigger(c => c + 1);
    };

    const getParentDirForNewItem = (): string => {
        if (activeFile) {
            const nodeMap = new Map<string, FileNode>();
            const buildMap = (node: FileNode) => {
                nodeMap.set(node.absolutePath, node);
                node.children?.forEach(buildMap);
            };
            files.forEach(buildMap);
            const activeNode = nodeMap.get(activeFile);
            if (activeNode) {
                return activeNode.children ? activeNode.absolutePath : activeFile.substring(0, activeFile.lastIndexOf('/'));
            }
        }
        return files.length > 0 ? files[0].absolutePath : '';
    };

    const handleNewFile = () => clientIpc.sendToServer(ClientToServerChannel.RequestNewFile, { parentDirectory: getParentDirForNewItem() });
    const handleNewFolder = () => clientIpc.sendToServer(ClientToServerChannel.RequestNewFolder, { parentDirectory: getParentDirForNewItem() });

    const handleToggleAutoAdd = () => {
        const newState = !isAutoAddEnabled;
        setIsAutoAddEnabled(newState);
        clientIpc.sendToServer(ClientToServerChannel.SaveAutoAddState, { enabled: newState });
    };

    const handleRemoveFromSelection = (pathsToRemove: string[]) => {
        setCheckedFiles(currentChecked => {
            const newChecked = removePathsFromSelected(pathsToRemove, currentChecked, files);
            clientIpc.sendToServer(ClientToServerChannel.SaveCurrentSelection, { paths: newChecked });
            return newChecked;
        });
    };

    const processDrop = (event: React.DragEvent, node: FileNode) => {
        const targetDir = node.children ? node.absolutePath : path.dirname(node.absolutePath);
        logger.log(`[Drop] Drop detected on target: ${targetDir}`);
        logger.log(`[Drop] Available types: ${Array.from(event.dataTransfer.types).join(', ')}`);

        // Case 1: Drop from OS File Explorer
        if (event.dataTransfer.files && event.dataTransfer.files.length > 0) {
            logger.log(`[Drop] Handling as OS file drop (${event.dataTransfer.files.length} files).`);
            const filesArray = Array.from(event.dataTransfer.files);
            filesArray.forEach((file: File) => {
                const reader = new FileReader();
                reader.onload = (readEvent) => {
                    if (readEvent.target?.result instanceof ArrayBuffer) {
                        const data = new Uint8Array(readEvent.target.result);
                        const finalTargetPath = `${targetDir}/${file.name}`.replace(/\\/g, '/');
                        logger.log(`[Drop] Sending file buffer ${file.name} to backend for creation at ${finalTargetPath}`);
                        clientIpc.sendToServer(ClientToServerChannel.RequestAddFileFromBuffer, { targetPath: finalTargetPath, data });
                    }
                };
                reader.onerror = () => logger.error(`[Drop] FileReader error for file: ${file.name}`);
                reader.readAsArrayBuffer(file);
            });
            return;
        }

        // Case 2: Drop from VS Code Explorer
        const uriList = event.dataTransfer.getData('text/uri-list');
        if (uriList) {
            logger.log(`[Drop] Handling as VS Code URI drop. URI List: ${uriList}`);
            const sourceUri = uriList.split('\n')[0].trim(); // Handle multiple URIs if needed, for now just take the first
            if (sourceUri) {
                 clientIpc.sendToServer(ClientToServerChannel.RequestCopyFileFromUri, { sourceUri, targetDir });
            }
            return;
        }
        
        logger.warn('[Drop] Drop event occurred but no compatible data type was found.');
    };

    const handleContainerDrop = (event: React.DragEvent<HTMLDivElement>) => {
        event.preventDefault();
        event.stopPropagation();
        setIsDraggingOver(false);
        if (!isWorkspaceTrusted) return;
        
        const rootDir = files.length > 0 ? files[0].absolutePath : '';
        if (!rootDir) {
            logger.error("Cannot drop file, no workspace root identified.");
            return;
        }
        const dummyRootNode: FileNode = { absolutePath: rootDir, name: path.basename(rootDir), children: [], tokenCount: 0, fileCount: 0, isImage: false, sizeInBytes: 0, extension: '', isPdf: false, isExcel: false, isWordDoc: false };
        processDrop(event, dummyRootNode);
    };
    
    const handleDragOver = (event: React.DragEvent<HTMLDivElement>) => {
        event.preventDefault();
        event.stopPropagation();
        if (isWorkspaceTrusted && (event.dataTransfer.types.includes('Files') || event.dataTransfer.types.includes('text/uri-list'))) {
             event.dataTransfer.dropEffect = 'copy';
        } else {
            event.dataTransfer.dropEffect = 'none';
        }
    };

    const handleDragEnter = (event: React.DragEvent<HTMLDivElement>) => {
        event.preventDefault();
        event.stopPropagation();
        if (isWorkspaceTrusted && (event.dataTransfer.types.includes('Files') || event.dataTransfer.types.includes('text/uri-list'))) {
            setIsDraggingOver(true);
        }
    };

    const handleDragLeave = (event: React.DragEvent<HTMLDivElement>) => {
        event.preventDefault();
        event.stopPropagation();
        if (!event.currentTarget.contains(event.relatedTarget as Node)) {
            setIsDraggingOver(false);
        }
    };

    const { totalFiles, totalTokens, selectedFileNodes } = useMemo(() => {
        let totalTokens = 0;
        const selectedFileSet = new Set<string>();
        const selectedNodes: FileNode[] = [];
        const fileMap: Map<string, FileNode> = new Map();
        const buildFileMap = (node: FileNode) => {
            fileMap.set(node.absolutePath, node);
            node.children?.forEach(buildFileMap);
        };
        files.forEach(buildFileMap);
        const addNodeAndDescendants = (node: FileNode) => {
            if (!node.children) { // It's a file
                if (!selectedFileSet.has(node.absolutePath)) {
                    selectedFileSet.add(node.absolutePath);
                    selectedNodes.push(node);
                    totalTokens += node.tokenCount;
                }
            } else { // It's a directory
                node.children.forEach(addNodeAndDescendants);
            }
        };
        checkedFiles.forEach(path => {
            const node = fileMap.get(path);
            if (node) addNodeAndDescendants(node);
        });
        return { totalFiles: selectedNodes.length, totalTokens, selectedFileNodes: selectedNodes };
    }, [checkedFiles, files]);

    return (
        <div 
            className={`view-container ${isDraggingOver ? 'drag-over' : ''}`} 
            onDrop={handleContainerDrop} 
            onDragOver={handleDragOver}
            onDragEnter={handleDragEnter}
            onDragLeave={handleDragLeave}
        >
            {!isWorkspaceTrusted && (
                <div className="workspace-trust-banner">
                    <VscShield />
                    <span>Drag and drop is disabled because this workspace is not trusted.</span>
                    <button onClick={() => clientIpc.sendToServer(ClientToServerChannel.VSCodeCommand, { command: 'workbench.action.manageWorkspaceTrust' })}>
                        Manage Trust
                    </button>
                </div>
            )}
            <div className="view-header">
                 <div className="header-row">
                     <div className="toolbar">
                         <button onClick={() => clientIpc.sendToServer(ClientToServerChannel.VSCodeCommand, { command: 'dce.saveCurrentSelection', args: [checkedFiles] })} title="Save Selection Set..."><VscSave /></button>
                         <button onClick={() => clientIpc.sendToServer(ClientToServerChannel.VSCodeCommand, { command: 'dce.loadSelectionSet' })} title="Load Selection Set..."><VscFolderLibrary /></button>
                         <button onClick={() => clientIpc.sendToServer(ClientToServerChannel.VSCodeCommand, { command: 'dce.manageSelectionSets' })} title="Manage Selection Sets..."><VscSettingsGear /></button>
                     </div>
                     <div className="toolbar">
                         {isLoading && <span className="spinner" title="Refreshing..."><VscLoading /></span>}
                         <button onClick={() => setIsSearchVisible(v => !v)} title="Search..." className={isSearchVisible ? 'active' : ''}><VscSearch /></button>
                         <button onClick={handleToggleAutoAdd} title="Automatically add new files to selection" className={isAutoAddEnabled ? 'active' : ''}><VscCheckAll /></button>
                         <button onClick={handleNewFile} title="New File..."><VscNewFile /></button>
                         <button onClick={handleNewFolder} title="New Folder..."><VscNewFolder /></button>
                         <button onClick={handleRefresh} title="Refresh Explorer"><VscRefresh /></button>
                         <button onClick={handleExpandAll} title="Expand All Folders"><VscExpandAll /></button>
                         <button onClick={handleCollapseAll} title="Collapse Folders in View"><VscCollapseAll /></button>
                     </div>
                 </div>
                {isSearchVisible && (
                    <div className="search-container">
                        <input type="text" placeholder="Filter files..." value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} />
                    </div>
                )}
            </div>
            <div className="file-tree-container">
                {isLoading && files.length === 0 ? (
                     <div className="loading-message">Loading file tree...</div>
                ) : files.length > 0 ? (
                    <FileTree data={files} checkedFiles={checkedFiles} updateCheckedFiles={updateCheckedFiles} activeFile={activeFile} collapseTrigger={collapseTrigger} expandAllTrigger={expandAllTrigger} searchTerm={searchTerm} problemMap={problemMap} onNodeDrop={processDrop} onCopy={(path) => setClipboard({ path, type: 'copy' })} clipboard={clipboard} />
                ) : (
                    <div className="loading-message">No folder open.</div>
                )}
            </div>
            <SelectedFilesView selectedFileNodes={selectedFileNodes} onRemove={handleRemoveFromSelection} isMinimized={isSelectionListMinimized} onToggleMinimize={() => setIsSelectionListMinimized(prev => !prev)} />
            <div className="view-footer">
                <div className="summary-panel">
                    <span className='summary-item' title="Total number of individual files selected for flattening. This does not include empty directories."><VscFiles /> Selected Files: {formatNumberWithCommas(totalFiles)}</span>
                    <span className='summary-item' title="Total tokens in selected text files"><VscSymbolNumeric /> {formatLargeNumber(totalTokens, 1)}</span>
                </div>
                <button className="flatten-button" onClick={handleFlattenClick}>Flatten Context</button>
            </div>
        </div>
    );
};

const root = ReactDOM.createRoot(document.getElementById('root')!);
root.render(<App />);
</file>

<file path="src/client/views/index.ts">
import { viewConfig as contextChooserViewConfig } from "./context-chooser.view";
import * as vscode from "vscode";
import { ServerPostMessageManager } from "@/common/ipc/server-ipc";
import { getNonce, getViewHtml } from "@/common/utils/view-html";

export const views = [contextChooserViewConfig];
export const serverIPCs: Record<string, ServerPostMessageManager> = {};

export function registerViews(context: vscode.ExtensionContext) {
    views.forEach((viewConfig) => {
        context.subscriptions.push(
            vscode.window.registerWebviewViewProvider(viewConfig.type, {
                resolveWebviewView: (webviewView) => {
                    webviewView.webview.options = {
                        enableScripts: true,
                        localResourceRoots: [context.extensionUri],
                    };
                    const nonce = getNonce();
                    const scriptUri = webviewView.webview.asWebviewUri(vscode.Uri.joinPath(context.extensionUri, "dist", viewConfig.entry));
                    const styleUri = webviewView.webview.asWebviewUri(vscode.Uri.joinPath(context.extensionUri, "dist", `${viewConfig.entry.replace('.js', '')}.css`));
                    
                    webviewView.webview.html = getViewHtml({
                        webview: webviewView.webview,
                        nonce,
                        scriptUri: scriptUri.toString(),
                        styleUris: [styleUri],
                    });

                    const serverIpc = ServerPostMessageManager.getInstance(
                        webviewView.webview.onDidReceiveMessage,
                        (data: any) => webviewView.webview.postMessage(data)
                    );
                    serverIPCs[viewConfig.type] = serverIpc;
                    viewConfig.handleMessage(serverIpc);
                },
            })
        );
    });
}
</file>

<file path="src/client/views/parallel-copilot.view/index.ts">
// src/client/views/parallel-copilot.view/index.ts
import { onMessage } from "./on-message";

export const viewConfig = {
    entry: "parallelCopilotView.js",
    type: "viewType.sidebar.parallelCopilot",
    handleMessage: onMessage,
};
</file>

<file path="src/client/views/parallel-copilot.view/on-message.ts">
// Updated on: C132 (Add batch write handler)
import { ServerPostMessageManager } from "@/common/ipc/server-ipc";
import { Services } from "@/backend/services/services";
import { ClientToServerChannel, ServerToClientChannel } from "@/common/ipc/channels.enum";

export function onMessage(serverIpc: ServerPostMessageManager) {
    const { loggerService, promptService, fileOperationService, highlightingService, historyService } = Services;
    loggerService.log("Parallel Co-Pilot view message handler initialized.");

    serverIpc.onClientMessage(ClientToServerChannel.RequestCreatePromptFile, (data) => {
        promptService.generatePromptFile(data.cycleTitle, data.currentCycle);
    });

    serverIpc.onClientMessage(ClientToServerChannel.RequestFileExistence, (data) => {
        fileOperationService.handleFileExistenceRequest(data.paths, serverIpc);
    });

    serverIpc.onClientMessage(ClientToServerChannel.RequestSyntaxHighlight, (data) => {
        highlightingService.handleSyntaxHighlightRequest(data.code, data.lang, data.id, serverIpc);
    });

    serverIpc.onClientMessage(ClientToServerChannel.RequestLatestCycleData, async () => {
        const cycleData = await historyService.getLatestCycle();
        serverIpc.sendToClient(ServerToClientChannel.SendLatestCycleData, { cycleData });
    });

    serverIpc.onClientMessage(ClientToServerChannel.RequestCycleData, async (data) => {
        const cycleData = await historyService.getCycleData(data.cycleId);
        serverIpc.sendToClient(ServerToClientChannel.SendCycleData, { cycleData });
    });

    serverIpc.onClientMessage(ClientToServerChannel.SaveCycleData, (data) => {
        historyService.saveCycleData(data.cycleData);
    });
    
    serverIpc.onClientMessage(ClientToServerChannel.RequestFileContent, (data) => {
        fileOperationService.handleFileContentRequest(data.path, serverIpc);
    });

    serverIpc.onClientMessage(ClientToServerChannel.RequestDeleteCycle, (data) => {
        historyService.deleteCycle(data.cycleId);
    });

    serverIpc.onClientMessage(ClientToServerChannel.RequestResetHistory, () => {
        historyService.resetHistory();
    });

    serverIpc.onClientMessage(ClientToServerChannel.RequestBatchFileWrite, (data) => {
        fileOperationService.handleBatchFileWrite(data.files);
    });
}
</file>

<file path="src/client/views/parallel-copilot.view/TestPane1.tsx">
// src/client/views/parallel-copilot.view/TestPane1.tsx
import * as React from 'react';
import { VscCheck, VscError } from 'react-icons/vsc';
import { ParsedResponse } from '@/common/types/pcpp.types';
import { logger } from '@/client/utils/logger';

interface TestPane1Props {
    parsedContent: ParsedResponse | null;
    fileExistenceMap: Map<string, boolean>;
}

const TestPane1: React.FC<TestPane1Props> = ({ parsedContent, fileExistenceMap }) => {
    const [lastClicked, setLastClicked] = React.useState<string | null>(null);

    if (!parsedContent) {
        return <div className="test-pane-container">Go to the "Original" tab, paste a response, and click "Parse All" to populate test data.</div>;
    }

    return (
        <div className="test-pane-container">
            <h3>Test Pane A: Barebones Click Logger</h3>
            <p>This test uses a raw list with a simple `onClick`. If clicks are logged and the text below updates, the fundamental event capture is working.</p>
            <p><strong>Last Clicked:</strong> {lastClicked || 'None'}</p>
            <hr style={{ margin: '8px 0', borderColor: 'var(--vscode-panel-border)' }} />
            <ul className="associated-files-list">
                {parsedContent.filesUpdated.map(file => (
                    <li 
                        key={file} 
                        onClick={() => {
                            logger.log(`[TEST PANE A] CLICKED: ${file}`);
                            setLastClicked(file);
                        }}
                    >
                        {fileExistenceMap.get(file) ? <VscCheck className="status-icon exists" /> : <VscError className="status-icon not-exists" />}
                        <span>{file}</span>
                    </li>
                ))}
            </ul>
        </div>
    );
};

export default TestPane1;
</file>

<file path="src/client/views/parallel-copilot.view/TestPane2.tsx">
// Updated on: C106 (Fix click handler and add separate state for content)
import * as React from 'react';
import { VscCheck, VscError } from 'react-icons/vsc';
import { ParsedResponse, ParsedFile } from '@/common/types/pcpp.types';
import { logger } from '@/client/utils/logger';

interface TestPane2Props {
    parsedContent: ParsedResponse | null;
    fileExistenceMap: Map<string, boolean>;
}

const TestPane2: React.FC<TestPane2Props> = ({ parsedContent, fileExistenceMap }) => {
    const [lastClickedFile, setLastClickedFile] = React.useState<string | null>(null);
    const [selectedFileContent, setSelectedFileContent] = React.useState<string | null>(null);

    if (!parsedContent) {
        return <div className="test-pane-container">Go to the main input, paste a response, and click "Parse for Tests" to populate data.</div>;
    }

    const handleFileClick = (filePath: string) => {
        logger.log(`[TEST PANE B] CLICKED: ${filePath}.`);
        setLastClickedFile(filePath); // First, simple state update

        const file = parsedContent.files.find(f => f.path === filePath);
        if (file) {
            logger.log(`[TEST PANE B] Found file content. Setting content state.`);
            setSelectedFileContent(file.content); // Second, update content
        } else {
            logger.error(`[TEST PANE B] Could not find file object for path: ${filePath}`);
            setSelectedFileContent(`Error: Could not find content for ${filePath}`);
        }
    };

    return (
        <div className="test-pane-container">
            <h3>Test Pane B: Local State Update</h3>
            <p>This test uses local `useState` to manage the selected file. Clicking a file should update the content displayed below.</p>
            <p><strong>Last Clicked:</strong> {lastClickedFile || 'None'}</p>
            <hr style={{ margin: '8px 0', borderColor: 'var(--vscode-panel-border)' }} />
            <div style={{ display: 'flex', gap: '8px' }}>
                <div style={{ flex: 1 }}>
                    <h4>Files</h4>
                    <ul className="associated-files-list">
                        {parsedContent.filesUpdated.map(filePath => (
                            <li 
                                key={filePath} 
                                onClick={() => handleFileClick(filePath)}
                                className={lastClickedFile === filePath ? 'selected' : ''}
                            >
                                {fileExistenceMap.get(filePath) ? <VscCheck className="status-icon exists" /> : <VscError className="status-icon not-exists" />}
                                <span>{filePath}</span>
                            </li>
                        ))}
                    </ul>
                </div>
                <div style={{ flex: 2, borderLeft: '1px solid var(--vscode-panel-border)', paddingLeft: '8px' }}>
                    <h4>Content</h4>
                    {selectedFileContent !== null ? (
                        <pre style={{ whiteSpace: 'pre-wrap', wordBreak: 'break-all' }}>
                            <code>{selectedFileContent}</code>
                        </pre>
                    ) : (
                        <div>Select a file to see its content.</div>
                    )}
                </div>
            </div>
        </div>
    );
};

export default TestPane2;
</file>

<file path="src/client/views/parallel-copilot.view/TestPane3.tsx">
// Updated on: C106 (Fix click handler and add separate state for content)
import * as React from 'react';
import { VscCheck, VscError } from 'react-icons/vsc';
import { ParsedResponse, ParsedFile } from '@/common/types/pcpp.types';
import { logger } from '@/client/utils/logger';

// Child component to test prop drilling
const FileList = ({ files, fileExistenceMap, onFileSelect, lastClickedFile }: { files: string[], fileExistenceMap: Map<string, boolean>, onFileSelect: (filePath: string) => void, lastClickedFile: string | null }) => (
    <ul className="associated-files-list">
        {files.map(filePath => (
            <li 
                key={filePath} 
                onClick={() => onFileSelect(filePath)}
                className={lastClickedFile === filePath ? 'selected' : ''}
            >
                {fileExistenceMap.get(filePath) ? <VscCheck className="status-icon exists" /> : <VscError className="status-icon not-exists" />}
                <span>{filePath}</span>
            </li>
        ))}
    </ul>
);

interface TestPane3Props {
    parsedContent: ParsedResponse | null;
    fileExistenceMap: Map<string, boolean>;
}

const TestPane3: React.FC<TestPane3Props> = ({ parsedContent, fileExistenceMap }) => {
    const [lastClickedFile, setLastClickedFile] = React.useState<string | null>(null);
    const [selectedFileContent, setSelectedFileContent] = React.useState<string | null>(null);

    if (!parsedContent) {
        return <div className="test-pane-container">Go to the main input, paste a response, and click "Parse for Tests" to populate data.</div>;
    }

    const handleFileSelect = (filePath: string) => {
        logger.log(`[TEST PANE C] Child component called onFileSelect prop for: ${filePath}.`);
        setLastClickedFile(filePath);

        const file = parsedContent.files.find(f => f.path === filePath);
        if (file) {
             logger.log(`[TEST PANE C] Found file content. Setting content state.`);
            setSelectedFileContent(file.content);
        } else {
             logger.error(`[TEST PANE C] Could not find file object for path: ${filePath}`);
             setSelectedFileContent(`Error: Could not find content for ${filePath}`);
        }
    };

    return (
        <div className="test-pane-container">
            <h3>Test Pane C: Prop-Driven Update</h3>
            <p>This test uses a child component for the list, passing the click handler down as a prop. This tests for issues with prop drilling.</p>
            <p><strong>Last Clicked:</strong> {lastClickedFile || 'None'}</p>
            <hr style={{ margin: '8px 0', borderColor: 'var(--vscode-panel-border)' }} />
             <div style={{ display: 'flex', gap: '8px' }}>
                <div style={{ flex: 1 }}>
                    <h4>Files (Child Component)</h4>
                    <FileList 
                        files={parsedContent.filesUpdated} 
                        fileExistenceMap={fileExistenceMap} 
                        onFileSelect={handleFileSelect}
                        lastClickedFile={lastClickedFile}
                    />
                </div>
                <div style={{ flex: 2, borderLeft: '1px solid var(--vscode-panel-border)', paddingLeft: '8px' }}>
                    <h4>Content (Parent Component)</h4>
                    {selectedFileContent !== null ? (
                        <pre style={{ whiteSpace: 'pre-wrap', wordBreak: 'break-all' }}>
                            <code>{selectedFileContent}</code>
                        </pre>
                    ) : (
                        <div>Select a file to see its content.</div>
                    )}
                </div>
            </div>
        </div>
    );
};

export default TestPane3;
</file>

<file path="src/client/views/parallel-copilot.view/view.scss">
/* Updated on: C132 (Re-enable all scrollbars) */
body {
    padding: 0;
    font-family: var(--vscode-font-family);
    font-size: var(--vscode-font-size);
    color: var(--vscode-editor-foreground);
    background-color: var(--vscode-editor-background);
}

.pc-view-container {
    padding: 8px;
    display: flex;
    flex-direction: column;
    height: 100vh;
    gap: 8px;
    box-sizing: border-box;
}

.collapsible-section {
    border: 1px solid var(--vscode-panel-border);
    border-radius: 4px;
    flex-shrink: 0;
}

.collapsible-header {
    background-color: var(--vscode-sideBar-sectionHeaderBackground);
    padding: 4px 8px;
    font-size: 11px;
    text-transform: uppercase;
    font-weight: bold;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 4px;
    justify-content: space-between;

    .chevron {
        transition: transform 0.2s ease-in-out;
    }
    .chevron.collapsed {
        transform: rotate(-90deg);
    }
}

.collapsible-content {
    padding: 8px;
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.pc-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-shrink: 0;
    gap: 16px;
}

.cycle-navigator {
    display: flex;
    align-items: center;
    gap: 8px;
    width: 100%;
}

.pc-toolbar {
    display: flex;
    align-items: center;
    gap: 8px;
}

.cycle-navigator button, .pc-toolbar button, .file-actions button, .exit-diff-button {
    background: none;
    border: 1px solid var(--vscode-button-border, transparent);
    color: var(--vscode-icon-foreground);
    cursor: pointer;
    padding: 4px;
    border-radius: 3px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;

    &:hover {
        background-color: var(--vscode-toolbar-hoverBackground);
    }

    &:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
}

.exit-diff-button {
    margin-top: 8px;
    justify-content: center;
    width: 100%;
    background-color: var(--vscode-button-secondaryBackground);
    &:hover {
        background-color: var(--vscode-button-secondaryHoverBackground);
    }
}


.cycle-input {
    width: 50px;
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    border: 1px solid var(--vscode-input-border);
    text-align: center;
    border-radius: 2px;
}

.cycle-title-input {
    flex-grow: 1;
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    border: 1px solid var(--vscode-input-border);
    padding: 2px 4px;
    border-radius: 2px;
}

.context-inputs {
    display: flex;
    flex-direction: column;
    gap: 8px;
    flex-shrink: 0;
}

.tab-count-input {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 12px;
    
    input {
        width: 50px;
        background-color: var(--vscode-input-background);
        color: var(--vscode-input-foreground);
        border: 1px solid var(--vscode-input-border);
        text-align: center;
        border-radius: 2px;
    }
}

.context-textarea {
    width: 100%;
    height: 60px;
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    border: 1px solid var(--vscode-input-border);
    border-radius: 2px;
    padding: 4px;
    font-family: var(--vscode-editor-font-family);
    font-size: var(--vscode-editor-font-size);
    resize: vertical;
}

.tab-bar {
    display: flex;
    border-bottom: 1px solid var(--vscode-panel-border);
    flex-shrink: 0;
}

.tab {
    padding: 6px 12px;
    cursor: pointer;
    border-bottom: 2px solid transparent;
    color: var(--vscode-tab-inactiveForeground);
}

.tab.active {
    color: var(--vscode-tab-activeForeground);
    border-bottom-color: var(--vscode-tab-activeBorder);
}

.tab-content {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    min-height: 0;
    padding-top: 8px;
}

.tab-pane {
    display: flex;
    flex-direction: column;
    flex-grow: 1;
    gap: 8px;
    height: 100%;
}

.response-textarea {
    width: 100%;
    height: 100%;
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    border: 1px solid var(--vscode-input-border);
    border-radius: 2px;
    padding: 4px;
    font-family: var(--vscode-editor-font-family);
    font-size: var(--vscode-editor-font-size);
    resize: none;
     &:focus {
        outline: 1px solid var(--vscode-focusBorder);
    }
}

.parsed-view-grid {
    display: flex;
    gap: 0;
    flex-grow: 1;
    min-height: 0;
}

.parsed-view-left {
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 8px;
    min-width: 150px;
    padding-right: 8px;
}

.resizer {
    width: 5px;
    cursor: col-resize;
    background-color: var(--vscode-panel-border);
    flex-shrink: 0;
    &:hover {
        background-color: var(--vscode-focusBorder);
    }
}

.parsed-view-right {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    min-width: 0;
    padding-left: 8px;
}

.file-content-viewer-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 4px 8px;
    background-color: var(--vscode-editorGroupHeader-tabsBackground);
    border: 1px solid var(--vscode-panel-border);
    border-bottom: none;
    border-top-left-radius: 4px;
    border-top-right-radius: 4px;
    font-size: 12px;
    flex-shrink: 0;

    .file-path {
        font-weight: bold;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    .file-actions {
        display: flex;
        align-items: center;
        gap: 8px;
    }
}

.response-acceptance-header {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 4px 8px;
    font-size: 12px;
    background-color: var(--vscode-sideBar-sectionHeaderBackground);

    input[type="checkbox"] {
        margin-right: 4px;
    }
}

.code-viewer-wrapper {
    display: flex;
    flex-grow: 1;
    min-height: 0;
    border: 1px solid var(--vscode-panel-border);
    border-top: none;
    border-radius: 0 0 4px 4px;
    background-color: var(--vscode-editor-background);
    overflow: hidden;
}

.file-content-viewer {
    flex: 1;
    overflow: auto;
    font-family: var(--vscode-editor-font-family);
    font-size: var(--vscode-editor-font-size);
    display: flex;
    min-width: 0;
}

.line-numbers {
    padding: 8px 10px 8px 8px;
    text-align: right;
    color: var(--vscode-editorLineNumber-foreground);
    background-color: var(--vscode-editor-background);
    user-select: none;
    border-right: 1px solid var(--vscode-panel-border);
    
    span {
        display: block;
        line-height: 1.5;
    }
}

.code-content {
    padding: 8px;
    flex-grow: 1;
    white-space: pre;
    
    code > span {
        line-height: 1.5;
    }
}

.associated-files-list {
    list-style: none;
    padding: 0;
    margin: 0;

    li {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 2px 4px;
        font-size: 12px;
        border-radius: 3px;
        cursor: pointer;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;

        input[type="checkbox"] {
            margin-right: 4px;
        }

        &:hover {
            background-color: var(--vscode-list-hoverBackground);
        }

        &.selected {
            background-color: var(--vscode-list-activeSelectionBackground) !important;
            color: var(--vscode-list-activeSelectionForeground) !important;
        }
    }

    .status-icon {
        flex-shrink: 0;
    }
    .status-icon.exists {
        color: var(--vscode-testing-iconPassed);
    }
    .status-icon.not-exists {
        color: var(--vscode-testing-iconFailed);
    }
}

.collapsed-navigator {
    display: flex;
    align-items: center;
    gap: 4px;
    font-weight: normal;
    
    button {
        padding: 0 4px;
    }
    
    .cycle-display {
        font-size: 11px;
        color: var(--vscode-descriptionForeground);
    }
}

/* Diff Viewer Styles */
.diff-viewer-wrapper {
    display: flex;
    flex-direction: column;
    height: 100%;
    min-height: 0;
    &:focus {
        outline: 1px solid var(--vscode-focusBorder);
    }
}
.diff-viewer-main-container {
    flex-grow: 1;
    min-height: 0;
    display: flex;
    flex-direction: row; /* Side-by-side */
    border: 1px solid var(--vscode-panel-border);
    border-radius: 4px;
}

.diff-pane {
    flex: 1 1 50%;
    display: flex;
    flex-direction: column; /* Stack header and content */
    min-width: 0;
    overflow: hidden;
    &:first-of-type { border-right: 1px solid var(--vscode-panel-border); }
}

.diff-pane-header {
    padding: 4px 8px;
    font-size: 11px;
    font-weight: bold;
    background-color: var(--vscode-editorGroupHeader-tabsBackground);
    border-bottom: 1px solid var(--vscode-panel-border);
    flex-shrink: 0;
}

.diff-pane-content {
    flex-grow: 1;
    min-height: 0;
    overflow-y: auto; /* Internal scrolling */
    display: flex;
}

.diff-pane .line-numbers {
    flex-shrink: 0;
    padding: 8px 4px;
    line-height: 1.5;
    background-color: var(--vscode-editorGutter-background);
    color: var(--vscode-editorLineNumber-foreground);
    text-align: right;
    user-select: none;
    span { display: block; min-height: 1.5em; padding-right: 6px; }
}

.diff-pane .diff-lines {
    flex-grow: 1;
    min-width: 0;
}

.diff-pane .diff-lines .line {
    line-height: 1.5;
    padding-left: 8px;
    min-height: 1.5em;
    white-space: pre;
    &.added { background-color: var(--vscode-diffEditor-insertedTextBackground); }
    &.removed { background-color: var(--vscode-diffEditor-removedTextBackground); }
    &.placeholder { background-color: var(--vscode-editor-inactiveSelectionBackground); opacity: 0.5; }
    
    &.selected-diff {
        outline: 1px solid var(--vscode-focusBorder);
        outline-offset: -1px;
    }

    pre { margin: 0; padding: 0; }
}

.diff-detail-container {
    flex-shrink: 0;
    border-top: 1px solid var(--vscode-panel-border);
    display: flex;
    flex-direction: column;
}

.diff-detail-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 2px 8px;
    background-color: var(--vscode-sideBar-sectionHeaderBackground);
    font-size: 11px;
    .diff-nav-buttons {
        display: flex;
        gap: 8px;
        button {
            padding: 2px 6px;
            gap: 4px;
        }
    }
}

.diff-detail-panes {
    display: flex;
    flex-direction: column; /* Top and bottom */
    max-height: 200px;
    overflow: hidden;
}

.diff-detail-pane {
    flex: 1 1 50%;
    padding: 8px;
    white-space: pre;
    overflow-x: auto;
    font-family: var(--vscode-editor-font-family);
    font-size: var(--vscode-editor-font-size);
    &.removed { background-color: var(--vscode-diffEditor-removedTextBackground); }
    &.added { background-color: var(--vscode-diffEditor-insertedTextBackground); }
    &:first-child { border-bottom: 1px solid var(--vscode-panel-border); }

    .char-added { background-color: var(--vscode-diffEditor-insertedLineBackground); }
    .char-removed { background-color: var(--vscode-diffEditor-removedLineBackground); }
}
</file>

<file path="src/client/views/parallel-copilot.view/view.tsx">
// Updated on: C132 (Add back button, selection checkboxes, and batch accept)
import * as React from 'react';
import * as ReactDOM from 'react-dom/client';
import './view.scss';
import { VscChevronLeft, VscChevronRight, VscWand, VscChevronDown, VscCheck, VscError, VscAdd, VscFileCode, VscDiff, VscArrowSwap, VscTrash, VscSync, VscClose, VscSave } from 'react-icons/vsc';
import { logger } from '@/client/utils/logger';
import { ClientPostMessageManager } from '@/common/ipc/client-ipc';
import { ClientToServerChannel, ServerToClientChannel } from '@/common/ipc/channels.enum';
import { ParsedResponse } from '@/common/types/pcpp.types';
import { parseResponse } from '@/client/utils/response-parser';
import ReactMarkdown from 'react-markdown';
import DiffViewer from '@/client/components/DiffViewer';
import { PcppCycle, PcppResponse } from '@/common/types/pcpp.types';
import * as path from 'path-browserify';
import { BatchWriteFile } from '@/common/ipc/channels.type';

const useDebounce = (callback: (...args: any[]) => void, delay: number) => {
    const timeoutRef = React.useRef<NodeJS.Timeout | null>(null);

    const debouncedFunction = React.useCallback((...args: any[]) => {
        if (timeoutRef.current) {
            clearTimeout(timeoutRef.current);
        }
        timeoutRef.current = setTimeout(() => {
            callback(...args);
        }, delay);
    }, [callback, delay]);

    return debouncedFunction;
};

const CodeViewer: React.FC<{ htmlContent: string | undefined | null }> = ({ htmlContent }) => {
    if (htmlContent === undefined || htmlContent === null) {
        return <div style={{ padding: '8px' }}>Select a file to view its content.</div>;
    }
    if (htmlContent.startsWith('// Error:')) {
         return <div style={{ padding: '8px', color: 'var(--vscode-errorForeground)' }}>{htmlContent}</div>;
    }

    const codeContentMatch = /<pre><code>([\s\S]*)<\/code><\/pre>/s.exec(htmlContent);
    const code = codeContentMatch ? codeContentMatch[1] : `<code>${htmlContent}</code>`; 

    const lines = code.split('\n');
    if (lines.length > 0 && lines[lines.length - 1] === '') {
        lines.pop();
    }

    return (
        <div className="file-content-viewer">
            <div className="line-numbers">
                {lines.map((_, i) => <span key={i}>{i + 1}</span>)}
            </div>
            <div className="code-content" dangerouslySetInnerHTML={{ __html: code }} />
        </div>
    );
};

interface TabState {
    rawContent: string;
    parsedContent: ParsedResponse | null;
    totalTokens?: number;
}

const CollapsibleSection: React.FC<{ title: string; children: React.ReactNode; isCollapsed: boolean; onToggle: () => void; collapsedContent?: React.ReactNode; }> = ({ title, children, isCollapsed, onToggle, collapsedContent }) => (
    <div className="collapsible-section">
        <div className="collapsible-header" onClick={onToggle}>
            <div style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>
                <VscChevronDown className={`chevron ${isCollapsed ? 'collapsed' : ''}`} />
                <span>{title}</span>
            </div>
            {isCollapsed && collapsedContent}
        </div>
        {!isCollapsed && <div className="collapsible-content">{children}</div>}
    </div>
);

const App = () => {
    const [activeTab, setActiveTab] = React.useState(1);
    const [tabCount, setTabCount] = React.useState(4);
    const [currentCycle, setCurrentCycle] = React.useState(1);
    const [maxCycle, setMaxCycle] = React.useState(1);
    const [cycleTitle, setCycleTitle] = React.useState('');
    const [cycleContext, setCycleContext] = React.useState('');
    const [ephemeralContext, setEphemeralContext] = React.useState('');
    const [tabs, setTabs] = React.useState<{ [key: string]: TabState }>({});
    const [highlightedCodeBlocks, setHighlightedCodeBlocks] = React.useState<Map<string, string>>(new Map());
    const [fileExistenceMap, setFileExistenceMap] = React.useState<Map<string, boolean>>(new Map());
    const [isParsedMode, setIsParsedMode] = React.useState(false);
    const [selectedFilePath, setSelectedFilePath] = React.useState<string | null>(null);
    const [isCycleCollapsed, setIsCycleCollapsed] = React.useState(false);
    const [leftPaneWidth, setLeftPaneWidth] = React.useState(33);
    const [isDiffMode, setIsDiffMode] = React.useState(false);
    const [originalFileContent, setOriginalFileContent] = React.useState<string | null>(null);
    const isResizing = React.useRef(false);
    const [selectedFilesForReplacement, setSelectedFilesForReplacement] = React.useState<Set<string>>(new Set());

    const [isAssociatedFilesCollapsed, setAssociatedFilesCollapsed] = React.useState(false);
    const [isThoughtsCollapsed, setThoughtsCollapsed] = React.useState(false);
    const [isActionCollapsed, setActionCollapsed] = React.useState(false);

    const clientIpc = ClientPostMessageManager.getInstance();

    const saveCurrentCycleState = React.useCallback((force = false) => {
        const responses: { [key: string]: PcppResponse } = {};
        for (let i = 1; i <= tabCount; i++) {
            responses[i.toString()] = { content: tabs[i.toString()]?.rawContent || '' };
        }
        const cycleData: PcppCycle = {
            cycleId: currentCycle,
            timestamp: new Date().toISOString(),
            title: cycleTitle,
            cycleContext,
            ephemeralContext,
            responses,
            isParsedMode,
            leftPaneWidth,
        };
        clientIpc.sendToServer(ClientToServerChannel.SaveCycleData, { cycleData });
    }, [currentCycle, cycleTitle, cycleContext, ephemeralContext, tabs, tabCount, isParsedMode, leftPaneWidth, clientIpc]);

    const debouncedSave = useDebounce(saveCurrentCycleState, 1000);

    React.useEffect(() => {
        debouncedSave();
    }, [cycleTitle, cycleContext, ephemeralContext, tabs, isParsedMode, leftPaneWidth, debouncedSave]);
    
    const parseAllTabs = React.useCallback(() => {
        setTabs(prevTabs => {
            const allFilePaths = new Set<string>();
            const updatedTabs = { ...prevTabs };
            let needsUpdate = false;
    
            Object.values(updatedTabs).forEach(tabState => {
                if (tabState.rawContent && !tabState.parsedContent) {
                    needsUpdate = true;
                    const parsed = parseResponse(tabState.rawContent);
                    tabState.parsedContent = parsed;
                    tabState.totalTokens = parsed.files.reduce((acc, file) => acc + Math.ceil(file.content.length / 4), 0);
                    parsed.filesUpdated.forEach(file => allFilePaths.add(file));
                    parsed.files.forEach(file => {
                        const lang = path.extname(file.path).substring(1) || 'plaintext';
                        const id = `${file.path}::${file.content}`;
                        clientIpc.sendToServer(ClientToServerChannel.RequestSyntaxHighlight, { code: file.content, lang, id });
                    });
                }
            });
    
            if (allFilePaths.size > 0) {
                clientIpc.sendToServer(ClientToServerChannel.RequestFileExistence, { paths: Array.from(allFilePaths) });
            }
    
            return needsUpdate ? updatedTabs : prevTabs;
        });
    }, [clientIpc]);
    
    React.useEffect(() => {
        const loadCycleData = (cycleData: PcppCycle) => {
            setCurrentCycle(cycleData.cycleId);
            setCycleTitle(cycleData.title);
            setCycleContext(cycleData.cycleContext);
            setEphemeralContext(cycleData.ephemeralContext);
            const newTabs: { [key: string]: TabState } = {};
            Object.entries(cycleData.responses).forEach(([tabId, response]) => {
                newTabs[tabId] = { rawContent: response.content, parsedContent: null };
            });
            setTabs(newTabs);
            setIsParsedMode(cycleData.isParsedMode || false);
            setLeftPaneWidth(cycleData.leftPaneWidth || 33);
        };

        clientIpc.onServerMessage(ServerToClientChannel.SendLatestCycleData, ({ cycleData }) => {
            loadCycleData(cycleData);
            setMaxCycle(cycleData.cycleId);
        });
        clientIpc.onServerMessage(ServerToClientChannel.SendCycleData, ({ cycleData }) => {
            if (cycleData) {
                loadCycleData(cycleData);
            }
        });
        clientIpc.onServerMessage(ServerToClientChannel.SendSyntaxHighlight, ({ highlightedHtml, id }) => {
            setHighlightedCodeBlocks(prev => new Map(prev).set(id, highlightedHtml));
        });
        clientIpc.onServerMessage(ServerToClientChannel.SendFileExistence, ({ existenceMap }) => {
            setFileExistenceMap(new Map(Object.entries(existenceMap)));
        });
        clientIpc.onServerMessage(ServerToClientChannel.SendFileContent, ({ path: filePath, content }) => {
            setOriginalFileContent(content);
        });
        clientIpc.onServerMessage(ServerToClientChannel.ForceRefresh, ({ reason }) => {
            if (reason === 'history') {
                clientIpc.sendToServer(ClientToServerChannel.RequestLatestCycleData, {});
            }
        });
        
        clientIpc.sendToServer(ClientToServerChannel.RequestLatestCycleData, {});
    }, [clientIpc]);

    React.useEffect(() => {
        if (isParsedMode) {
            parseAllTabs();
        }
    }, [isParsedMode, tabs, parseAllTabs]);
    
    const activeTabData = tabs[activeTab.toString()];

    const viewableContent = React.useMemo(() => {
        if (!selectedFilePath || !activeTabData?.parsedContent) return undefined;
        const file = activeTabData.parsedContent.files.find(f => f.path === selectedFilePath);
        if (!file) return '<div>Error: File data not found in parsed response.</div>';
        const id = `${file.path}::${file.content}`;
        return highlightedCodeBlocks.get(id);
    }, [selectedFilePath, activeTabData?.parsedContent, highlightedCodeBlocks]);


    const handleRawContentChange = (newContent: string, tabIndex: number) => {
        setTabs(prev => ({ ...prev, [tabIndex.toString()]: { rawContent: newContent, parsedContent: null }}));
    };

    const handleGlobalParseToggle = () => {
        const newParseMode = !isParsedMode;
        setIsParsedMode(newParseMode);
        setSelectedFilePath(null);
        setIsDiffMode(false);
        if (!newParseMode) {
            setTabs(prev => {
                const newTabs = {...prev};
                Object.keys(newTabs).forEach(key => {
                    newTabs[key].parsedContent = null;
                });
                return newTabs;
            });
        }
    };

    const handleCycleChange = (e: React.MouseEvent, newCycle: number) => {
        e.stopPropagation();
        if (newCycle > 0 && newCycle <= maxCycle) {
            saveCurrentCycleState(true);
            setCurrentCycle(newCycle);
            clientIpc.sendToServer(ClientToServerChannel.RequestCycleData, { cycleId: newCycle });
        }
    };

    const handleNewCycle = (e: React.MouseEvent) => {
        e.stopPropagation();
        const newCycleId = maxCycle + 1;
        setMaxCycle(newCycleId);
        setCurrentCycle(newCycleId);
        setCycleTitle('New Cycle');
        setCycleContext('');
        setEphemeralContext('');
        setTabs({});
        setIsParsedMode(false);
    };
    
    const handleGeneratePrompt = () => {
        clientIpc.sendToServer(ClientToServerChannel.RequestCreatePromptFile, { cycleTitle, currentCycle });
    };

    const handleMouseDown = React.useCallback((e: React.MouseEvent) => {
        e.preventDefault();
        isResizing.current = true;
    }, []);

    const handleMouseMove = React.useCallback((e: MouseEvent) => {
        if (!isResizing.current) return;
        const newWidth = (e.clientX / window.innerWidth) * 100;
        if (newWidth > 10 && newWidth < 90) {
            setLeftPaneWidth(newWidth);
        }
    }, []);

    const handleMouseUp = React.useCallback(() => {
        isResizing.current = false;
    }, []);

    React.useEffect(() => {
        const mm = (e: MouseEvent) => handleMouseMove(e);
        const mu = () => handleMouseUp();
        window.addEventListener('mousemove', mm);
        window.addEventListener('mouseup', mu);
        
        return () => {
            window.removeEventListener('mousemove', mm);
            window.removeEventListener('mouseup', mu);
        };
    }, [handleMouseMove, handleMouseUp]);
    
    const handleSelectForViewing = (filePath: string) => {
        const newPath = selectedFilePath === filePath ? null : filePath;
        
        if (newPath !== selectedFilePath) {
            setOriginalFileContent(null);
        }

        setSelectedFilePath(newPath);

        if (isDiffMode && newPath) {
            clientIpc.sendToServer(ClientToServerChannel.RequestFileContent, { path: newPath });
        }
    };

    const handleDeleteCycle = () => {
        clientIpc.sendToServer(ClientToServerChannel.RequestDeleteCycle, { cycleId: currentCycle });
    };

    const handleResetHistory = () => {
        clientIpc.sendToServer(ClientToServerChannel.RequestResetHistory, {});
    };

    const handleFileSelectionToggle = (filePath: string) => {
        setSelectedFilesForReplacement(prev => {
            const newSet = new Set(prev);
            if (newSet.has(filePath)) {
                newSet.delete(filePath);
            } else {
                newSet.add(filePath);
            }
            return newSet;
        });
    };

    const handleSelectAllFilesToggle = (e: React.ChangeEvent<HTMLInputElement>) => {
        if (e.target.checked) {
            const allFilePaths = activeTabData?.parsedContent?.filesUpdated || [];
            setSelectedFilesForReplacement(new Set(allFilePaths));
        } else {
            setSelectedFilesForReplacement(new Set());
        }
    };

    const handleAcceptSelectedFiles = () => {
        if (selectedFilesForReplacement.size === 0 || !activeTabData?.parsedContent) return;

        const filesToWrite: BatchWriteFile[] = [];
        selectedFilesForReplacement.forEach(filePath => {
            const file = activeTabData.parsedContent.files.find(f => f.path === filePath);
            if (file) {
                filesToWrite.push({ path: file.path, content: file.content });
            }
        });

        if (filesToWrite.length > 0) {
            clientIpc.sendToServer(ClientToServerChannel.RequestBatchFileWrite, { files: filesToWrite });
        }
    };

    const isAllFilesSelected = React.useMemo(() => {
        if (!activeTabData?.parsedContent) return false;
        const allFiles = activeTabData.parsedContent.filesUpdated;
        return allFiles.length > 0 && allFiles.every(file => selectedFilesForReplacement.has(file));
    }, [selectedFilesForReplacement, activeTabData]);

    const isNewCycleButtonDisabled = React.useMemo(() => {
        const hasTitle = cycleTitle && cycleTitle.trim() !== 'New Cycle' && cycleTitle.trim() !== '';
        const hasContext = cycleContext.trim() || ephemeralContext.trim();
        const hasResponseContent = Object.values(tabs).some(t => t.rawContent.trim());
        return !hasTitle && !hasContext && !hasResponseContent;
    }, [cycleTitle, cycleContext, ephemeralContext, tabs]);

    const collapsedNavigator = (
        <div className="collapsed-navigator">
            <button onClick={(e) => handleCycleChange(e, currentCycle - 1)} disabled={currentCycle <= 1}><VscChevronLeft /></button>
            <span className="cycle-display">C{currentCycle}</span>
            <button onClick={(e) => handleCycleChange(e, currentCycle + 1)} disabled={currentCycle >= maxCycle}><VscChevronRight /></button>
        </div>
    );

    const renderContent = () => {
        if (!isParsedMode || !activeTabData?.parsedContent) {
            return <textarea className="response-textarea" placeholder={`Paste AI response for tab ${activeTab} here...`} value={activeTabData?.rawContent || ''} onChange={(e) => handleRawContentChange(e.target.value, activeTab)} />;
        }

        const commonLeftPane = (
            <>
                 <CollapsibleSection title="Associated Files" isCollapsed={isAssociatedFilesCollapsed} onToggle={() => setAssociatedFilesCollapsed(p => !p)}>
                    <ul className="associated-files-list">
                        {activeTabData.parsedContent.filesUpdated.map(file => (
                            <li key={file} className={selectedFilePath === file ? 'selected' : ''} onClick={() => handleSelectForViewing(file)} title={file}>
                                <input type="checkbox" checked={selectedFilesForReplacement.has(file)} onChange={() => handleFileSelectionToggle(file)} onClick={e => e.stopPropagation()} />
                                {fileExistenceMap.get(file) ? <VscCheck className="status-icon exists" /> : <VscError className="status-icon not-exists" />}
                                <span>{file}</span>
                            </li>
                        ))}
                    </ul>
                </CollapsibleSection>
                <CollapsibleSection title="Thoughts / Response" isCollapsed={isThoughtsCollapsed} onToggle={() => setThoughtsCollapsed(p => !p)}><ReactMarkdown>{activeTabData.parsedContent.summary}</ReactMarkdown></CollapsibleSection>
                <CollapsibleSection title="Course of Action" isCollapsed={isActionCollapsed} onToggle={() => setActionCollapsed(p => !p)}><ReactMarkdown>{activeTabData.parsedContent.courseOfAction}</ReactMarkdown></CollapsibleSection>
            </>
        );

        if (isDiffMode) {
            return (
                <div className="parsed-view-grid">
                    <div className="parsed-view-left" style={{ flexBasis: `${leftPaneWidth}%` }}>
                        {commonLeftPane}
                        <button className="exit-diff-button" onClick={() => setIsDiffMode(false)}><VscClose/> Back to Code View</button>
                    </div>
                    <div className="resizer" onMouseDown={handleMouseDown} />
                    <div className="parsed-view-right">
                         {activeTabData.parsedContent && selectedFilePath && originalFileContent !== null ? (
                            <DiffViewer 
                                original={{ content: originalFileContent, path: selectedFilePath }}
                                modified={{ content: activeTabData.parsedContent.files.find(f => f.path === selectedFilePath)?.content || '', path: selectedFilePath }}
                            />
                        ) : (
                            <div style={{ padding: '8px' }}>{selectedFilePath ? 'Loading original file...' : 'Select a file to view diff.'}</div>
                        )}
                    </div>
                </div>
            );
        }

        return (
            <div className="parsed-view-grid">
                <div className="parsed-view-left" style={{ flexBasis: `${leftPaneWidth}%` }}>
                    {commonLeftPane}
                </div>
                <div className="resizer" onMouseDown={handleMouseDown} />
                <div className="parsed-view-right">
                    <div className="response-acceptance-header">
                        <input type="checkbox" checked={isAllFilesSelected} onChange={handleSelectAllFilesToggle} />
                        <label>Select this response</label>
                        <button onClick={handleAcceptSelectedFiles} disabled={selectedFilesForReplacement.size === 0}><VscSave/> Accept Selected Files</button>
                    </div>
                    <div className="file-content-viewer-header">
                        <span className="file-path" title={selectedFilePath || ''}>{selectedFilePath ? path.basename(selectedFilePath) : 'No file selected'}</span>
                        <div className="file-actions">
                            <button onClick={() => { if (selectedFilePath) { setIsDiffMode(true); clientIpc.sendToServer(ClientToServerChannel.RequestFileContent, { path: selectedFilePath }); } }} disabled={!selectedFilePath} title="View Diff"><VscDiff /></button>
                            <button disabled={!selectedFilePath} title="Accept this file into workspace"><VscArrowSwap /></button>
                        </div>
                    </div>
                    <div className="code-viewer-wrapper">
                        <CodeViewer htmlContent={viewableContent} />
                    </div>
                </div>
            </div>
        );
    };

    return (
        <div className="pc-view-container">
            <div className="pc-header">
                <div className="pc-toolbar">
                    <button onClick={handleGeneratePrompt} title="Generate prompt.md"><VscFileCode /> Generate prompt.md</button>
                    <button onClick={handleGlobalParseToggle}><VscWand /> {isParsedMode ? 'Un-Parse All' : 'Parse All'}</button>
                </div>
                <div className="tab-count-input">
                    <label htmlFor="tab-count">Responses:</label>
                    <input type="number" id="tab-count" min="1" max="20" value={tabCount} onChange={e => setTabCount(parseInt(e.target.value, 10) || 1)} />
                </div>
            </div>

            <CollapsibleSection title="Cycle & Context" isCollapsed={isCycleCollapsed} onToggle={() => setIsCycleCollapsed(p => !p)} collapsedContent={collapsedNavigator}>
                <div className="cycle-navigator">
                    <span>Cycle:</span>
                    <button onClick={(e) => handleCycleChange(e, currentCycle - 1)} disabled={currentCycle <= 1}><VscChevronLeft /></button>
                    <input type="number" value={currentCycle} onChange={e => setCurrentCycle(parseInt(e.target.value, 10) || 1)} className="cycle-input" />
                    <button onClick={(e) => handleCycleChange(e, currentCycle + 1)} disabled={currentCycle >= maxCycle}><VscChevronRight /></button>
                    <button onClick={handleNewCycle} title="New Cycle" disabled={isNewCycleButtonDisabled}><VscAdd /></button>
                    <input type="text" className="cycle-title-input" placeholder="Cycle Title..." value={cycleTitle} onChange={e => setCycleTitle(e.target.value)} />
                    <button onClick={handleDeleteCycle} title="Delete Current Cycle"><VscTrash /></button>
                    <button onClick={handleResetHistory} title="Reset All History"><VscSync /></button>
                </div>
                <div className="context-inputs">
                    <textarea className="context-textarea" placeholder="Cycle Context (notes for this cycle)..." value={cycleContext} onChange={e => setCycleContext(e.target.value)} />
                    <textarea className="context-textarea" placeholder="Ephemeral Context (for this cycle's prompt only)..." value={ephemeralContext} onChange={e => setEphemeralContext(e.target.value)} />
                </div>
            </CollapsibleSection>

            <div className="tab-bar">
                {[...Array(tabCount)].map((_, i) => <div key={i} className={`tab ${activeTab === i + 1 ? 'active' : ''}`} onClick={() => setActiveTab(i + 1)}>Resp {i + 1}</div>)}
            </div>

            <div className="tab-content">
                {activeTab !== null && (
                    <div className="tab-pane">
                        {renderContent()}
                    </div>
                )}
            </div>
        </div>
    );
};

const root = ReactDOM.createRoot(document.getElementById('root')!);
root.render(<App />);
</file>

<file path="src/common/ipc/channels.enum.ts">
export enum ClientToServerChannel {
    RequestInitialData = "clientToServer.requestInitialData",
    RequestFlattenContext = "clientToServer.requestFlattenContext",
    RequestWorkspaceFiles = "clientToServer.requestWorkspaceFiles",
    LogMessage = "clientToServer.logMessage",

    // File Operations
    RequestNewFile = "clientToServer.requestNewFile",
    RequestNewFolder = "clientToServer.requestNewFolder",
    RequestFileRename = "clientToServer.requestFileRename",
    RequestFileDelete = "clientToServer.requestFileDelete",
    RequestBatchFileDelete = "clientToServer.requestBatchFileDelete",
    RequestRevealInExplorer = "clientToServer.requestRevealInExplorer",
    RequestCopyPath = "clientToServer.requestCopyPath",
    RequestOpenFile = "clientToServer.requestOpenFile",
    RequestMoveFile = "clientToServer.requestMoveFile",
    RequestCopyFile = "clientToServer.requestCopyFile",
    RequestUndo = "clientToServer.requestUndo",
    RequestRedo = "clientToServer.requestRedo",
    RequestAddFileFromBuffer = "clientToServer.requestAddFileFromBuffer",
    RequestCopyFileFromUri = "clientToServer.requestCopyFileFromUri",
    RequestFileContent = "clientToServer.requestFileContent",
    RequestBatchFileWrite = "clientToServer.requestBatchFileWrite", // New for batch acceptance

    // Special File Handling
    RequestPdfToText = "clientToServer.requestPdfToText",
    RequestExcelToText = "clientToServer.requestExcelToText",
    RequestWordToText = "clientToServer.requestWordToText",

    // Selection Persistence
    SaveCurrentSelection = "clientToServer.saveCurrentSelection",
    RequestLastSelection = "clientToServer.requestLastSelection",
    SaveAutoAddState = "clientToServer.saveAutoAddState",

    // VS Code Command Proxy
    VSCodeCommand = "clientToServer.vscodeCommand",

    // Phase 2: PCPP
    RequestCreatePromptFile = "clientToServer.requestCreatePromptFile",
    RequestFileExistence = "clientToServer.requestFileExistence",
    RequestSyntaxHighlight = "clientToServer.requestSyntaxHighlight",
    RequestLatestCycleData = "clientToServer.requestLatestCycleData",
    RequestCycleData = "clientToServer.requestCycleData",
    SaveCycleData = "clientToServer.saveCycleData",
    RequestDeleteCycle = "clientToServer.requestDeleteCycle",
    RequestResetHistory = "clientToServer.requestResetHistory",
}

export enum ServerToClientChannel {
    SendWorkspaceFiles = "serverToClient.sendWorkspaceFiles",
    SendWorkspaceTrustState = "serverToClient.sendWorkspaceTrustState",
    ApplySelectionSet = "serverToClient.applySelectionSet",
    SendSelectionSets = "serverToClient.sendSelectionSets",
    ForceRefresh = "serverToClient.forceRefresh",
    SetActiveFile = "serverToClient.setActiveFile",
    FocusFile = "serverToClient.focusFile",
    SendAutoAddState = "serverToClient.sendAutoAddState",
    UpdateProblemCounts = "serverToClient.updateProblemCounts",
    UpdateNodeStats = "serverToClient.updateNodeStats",
    SendFileContent = "serverToClient.sendFileContent",
    
    // Phase 2: PCPP
    SendFileExistence = "serverToClient.sendFileExistence",
    SendSyntaxHighlight = "serverToClient.sendSyntaxHighlight",
    SendLatestCycleData = "serverToClient.sendLatestCycleData",
    SendCycleData = "serverToClient.sendCycleData",
}
</file>

<file path="src/common/ipc/channels.type.ts">
import { FileNode } from "@/common/types/file-node";
import { ClientToServerChannel, ServerToClientChannel } from "./channels.enum";
import { PcppCycle } from "@/common/types/pcpp.types";

export type SelectionSet = { [name: string]: string[] };
export type ProblemCountsMap = { [path: string]: { error: number; warning: number; } };
export type BatchWriteFile = { path: string; content: string };

export type ChannelBody<T extends ClientToServerChannel | ServerToClientChannel> =
    T extends ClientToServerChannel.RequestInitialData ? {} :
    T extends ClientToServerChannel.RequestFlattenContext ? { selectedPaths: string[] } :
    T extends ClientToServerChannel.RequestWorkspaceFiles ? { force?: boolean } :
    T extends ClientToServerChannel.LogMessage ? { level: 'info' | 'warn' | 'error', message: string } :
    T extends ClientToServerChannel.RequestNewFile ? { parentDirectory: string } :
    T extends ClientToServerChannel.RequestNewFolder ? { parentDirectory: string } :
    T extends ClientToServerChannel.RequestFileRename ? { oldPath: string, newName: string } :
    T extends ClientToServerChannel.RequestFileDelete ? { path: string } :
    T extends ClientToServerChannel.RequestBatchFileDelete ? { paths: string[] } :
    T extends ClientToServerChannel.RequestRevealInExplorer ? { path: string } :
    T extends ClientToServerChannel.RequestCopyPath ? { path: string, relative: boolean } :
    T extends ClientToServerChannel.RequestOpenFile ? { path: string } :
    T extends ClientToServerChannel.RequestFileContent ? { path: string } :
    T extends ClientToServerChannel.RequestMoveFile ? { oldPath: string, newPath: string } :
    T extends ClientToServerChannel.RequestCopyFile ? { sourcePath: string, destinationDir: string } :
    T extends ClientToServerChannel.RequestUndo ? {} :
    T extends ClientToServerChannel.RequestRedo ? {} :
    T extends ClientToServerChannel.RequestAddFileFromBuffer ? { targetPath: string, data: Uint8Array } :
    T extends ClientToServerChannel.RequestCopyFileFromUri ? { sourceUri: string, targetDir: string } :
    T extends ClientToServerChannel.RequestPdfToText ? { path: string } :
    T extends ClientToServerChannel.RequestExcelToText ? { path: string } :
    T extends ClientToServerChannel.RequestWordToText ? { path: string } :
    T extends ClientToServerChannel.SaveCurrentSelection ? { paths: string[] } :
    T extends ClientToServerChannel.RequestLastSelection ? {} :
    T extends ClientToServerChannel.SaveAutoAddState ? { enabled: boolean } :
    T extends ClientToServerChannel.VSCodeCommand ? { command: string, args?: any[] } :
    T extends ClientToServerChannel.RequestCreatePromptFile ? { cycleTitle: string; currentCycle: number } :
    T extends ClientToServerChannel.RequestFileExistence ? { paths: string[] } :
    T extends ClientToServerChannel.RequestSyntaxHighlight ? { code: string; lang: string, id: string } :
    T extends ClientToServerChannel.RequestLatestCycleData ? {} :
    T extends ClientToServerChannel.RequestCycleData ? { cycleId: number } :
    T extends ClientToServerChannel.SaveCycleData ? { cycleData: PcppCycle } :
    T extends ClientToServerChannel.RequestDeleteCycle ? { cycleId: number } :
    T extends ClientToServerChannel.RequestResetHistory ? {} :
    T extends ClientToServerChannel.RequestBatchFileWrite ? { files: BatchWriteFile[] } :
    
    T extends ServerToClientChannel.SendWorkspaceFiles ? { files: FileNode[] } :
    T extends ServerToClientChannel.SendWorkspaceTrustState ? { isTrusted: boolean } :
    T extends ServerToClientChannel.ApplySelectionSet ? { paths: string[] } :
    T extends ServerToClientChannel.SendSelectionSets ? { sets: SelectionSet } :
    T extends ServerToClientChannel.ForceRefresh ? { reason?: 'fileOp' | 'manual' | 'history' } :
    T extends ServerToClientChannel.SetActiveFile ? { path: string } :
    T extends ServerToClientChannel.FocusFile ? { path: string } :
    T extends ServerToClientChannel.SendAutoAddState ? { enabled: boolean } :
    T extends ServerToClientChannel.UpdateProblemCounts ? { problemMap: ProblemCountsMap } :
    T extends ServerToClientChannel.UpdateNodeStats ? { path: string, tokenCount: number, error?: string } :
    T extends ServerToClientChannel.SendFileContent ? { path: string, content: string | null } :
    T extends ServerToClientChannel.SendFileExistence ? { existenceMap: { [path: string]: boolean } } :
    T extends ServerToClientChannel.SendSyntaxHighlight ? { highlightedHtml: string, id: string } :
    T extends ServerToClientChannel.SendLatestCycleData ? { cycleData: PcppCycle } :
    T extends ServerToClientChannel.SendCycleData ? { cycleData: PcppCycle | null } :
    never;
</file>

<file path="src/common/ipc/client-ipc.ts">
// Updated on: C118 (Add getVscodeApi method)
import getVscode from "./get-vscode-api";
import { ClientToServerChannel, ServerToClientChannel } from "./channels.enum";
import { ChannelBody } from "./channels.type";
import { WebviewApi, ViewState } from "../types/vscode-webview";

export class ClientPostMessageManager {
    private static _instance?: ClientPostMessageManager;
    private _listeners: {
        channel: ServerToClientChannel,
        callback: (body: ChannelBody<ServerToClientChannel>) => void
    }[];

    private constructor() {
        this._listeners = [];
        window.addEventListener('message', (event: MessageEvent) => {
            const data = event.data;
            this._listeners.forEach((listener) => {
                if (listener.channel === data.channel) {
                    listener.callback(data.body);
                }
            });
        });
    }

    static getInstance(): ClientPostMessageManager {
        if (!ClientPostMessageManager._instance) {
            ClientPostMessageManager._instance = new ClientPostMessageManager();
        }
        return ClientPostMessageManager._instance;
    }

    public getVscodeApi(): WebviewApi<ViewState> {
        return getVscode();
    }

    sendToServer<T extends ClientToServerChannel>(channel: T, body: ChannelBody<T>): void {
        this.getVscodeApi().postMessage({ channel, body });
    }

    onServerMessage<T extends ServerToClientChannel>(channel: T, callback: (body: ChannelBody<T>) => void): void {
        this._listeners.push({ channel, callback: callback as any });
    }
}
</file>

<file path="src/common/ipc/get-vscode-api.ts">
import { WebviewApi } from "../types/vscode-webview";

let vscode: WebviewApi<unknown> | null = null;

const getVscode = () => {
    if (!vscode) {
        vscode = acquireVsCodeApi();
    }
    return vscode;
};

export default getVscode;
</file>

<file path="src/common/ipc/server-ipc.ts">
import { ClientToServerChannel, ServerToClientChannel } from "./channels.enum";
import { ChannelBody } from "./channels.type";

export class ServerPostMessageManager {
    private static _instance?: ServerPostMessageManager;
    private _listeners: {
        channel: ClientToServerChannel,
        callback: (body: ChannelBody<ClientToServerChannel>) => void
    }[];

    private constructor(
        private onMessage: (data: any) => void,
        private sendMessage: (message: any) => void
    ) {
        this._listeners = [];
        this.onMessage((data: any) => {
            this._listeners.forEach((listener) => {
                if (listener.channel === data.channel) {
                    listener.callback(data.body);
                }
            });
        });
    }

    static getInstance(onMessage?: (data: any) => void, sendMessage?: (message: any) => void) {
        if (onMessage && sendMessage) {
            ServerPostMessageManager._instance = new ServerPostMessageManager(onMessage, sendMessage);
        }
        if (!ServerPostMessageManager._instance) {
            throw new Error("ServerPostMessageManager not initialized");
        }
        return ServerPostMessageManager._instance;
    }

    sendToClient<T extends ServerToClientChannel>(channel: T, body: ChannelBody<T>): void {
        this.sendMessage({ channel, body });
    }

    onClientMessage<T extends ClientToServerChannel>(channel: T, callback: (body: ChannelBody<T>) => void): void {
        this._listeners.push({ channel, callback: callback as any });
    }
}
</file>

<file path="src/common/types/file-node.ts">
export interface FileNode {
    name: string;
    absolutePath: string;
    children?: FileNode[];
    tokenCount: number;
    fileCount: number; // For directories, this is the count of files inside. For files, it's 1.
    isImage: boolean;
    sizeInBytes: number;
    extension: string;
    isPdf: boolean;
    isExcel: boolean;
    isWordDoc: boolean; // New
    gitStatus?: string; // e.g., 'M', 'U', 'A', 'D', 'C'
    problemCounts?: { error: number; warning: number; };
    error?: string; // To store processing errors, e.g., "File not found"
}
</file>

<file path="src/common/types/pcpp.types.ts">
// src/common/types/pcpp.types.ts

// Data structure for the backend history file
export interface PcppResponse {
    content: string;
}

export interface PcppCycle {
    cycleId: number;
    timestamp: string;
    title: string;
    cycleContext: string;
    ephemeralContext: string;
    responses: { [tabId: string]: PcppResponse };
    isParsedMode?: boolean; // This will now be managed per-cycle
    leftPaneWidth?: number;
}

export interface PcppHistoryFile {
    version: number;
    cycles: PcppCycle[];
}


// Data structure for the frontend parsed response
export interface ParsedFile {
    path: string;
    content: string;
}

export interface ParsedResponse {
    summary: string;
    courseOfAction: string;
    filesUpdated: string[]; // List of file paths from the "Files Updated This Cycle" section
    files: ParsedFile[]; // Parsed file blocks with content
}
</file>

<file path="src/common/types/vscode-webview.d.ts">
// Updated on: C118 (Add pcppLeftPaneWidth to ViewState)
export interface WebviewApi<StateType> {
    postMessage(message: unknown): void;
    getState(): StateType | undefined;
    setState<T extends StateType | undefined>(newState: T): T;
}

export interface ViewState {
    selectedFiles?: string[];
    pcppLeftPaneWidth?: number;
}

declare global {
    function acquireVsCodeApi<StateType = ViewState>(): WebviewApi<StateType>;
}
</file>

<file path="src/common/utils/formatting.ts">
// src/common/utils/formatting.ts

const KMBT_SUFFIXES = ['', 'K', 'M', 'B', 'T', 'Q']; // Extend as needed

/**
 * Formats a large number with appropriate K/M/B/T suffixes and dynamic decimal places.
 *
 * @param value The number to format.
 * @param decimalPlaces The base number of decimal places to aim for.
 * @returns A formatted string.
 */
export function formatLargeNumber(value: number | undefined | null, decimalPlaces: number = 1): string {
    if (value === null || value === undefined || isNaN(value) || !Number.isFinite(value)) {
        return '---';
    }
    if (value === 0) {
        return '0';
    }

    const isNegative = value < 0;
    const absValue = Math.abs(value);

    if (absValue < 1000) {
        return String(Math.round(value)); // Return whole number if less than 1000
    }

    let unitIndex = 0;
    let scaledValue = absValue;

    unitIndex = Math.floor(Math.log10(absValue) / 3);
    unitIndex = Math.min(unitIndex, KMBT_SUFFIXES.length - 1);
    scaledValue = absValue / Math.pow(1000, unitIndex);

    let adjustedDecimalPlaces = decimalPlaces;
    if (scaledValue >= 100) adjustedDecimalPlaces = 0;
    else if (scaledValue >= 10) adjustedDecimalPlaces = 1;
    else adjustedDecimalPlaces = 2;


    const unit = KMBT_SUFFIXES[unitIndex] ?? '';
    let formattedValue = scaledValue.toFixed(adjustedDecimalPlaces);
    
    // Remove trailing .00 or .0
    if (adjustedDecimalPlaces > 0 && formattedValue.endsWith('0')) {
        formattedValue = formattedValue.replace(/\.?0+$/, '');
    }


    return `${isNegative ? '-' : ''}${formattedValue}${unit}`;
}

/**
 * Formats a number with commas as thousands separators.
 * @param value The number to format.
 * @returns A formatted string with commas.
 */
export function formatNumberWithCommas(value: number | undefined | null): string {
    if (value === null || value === undefined || isNaN(value)) {
        return '---';
    }
    return value.toLocaleString();
}

/**
 * Formats a file size in bytes into a human-readable string (KB, MB, GB, etc.).
 * @param bytes The number of bytes.
 * @param decimals The number of decimal places to use.
 * @returns A formatted string representing the file size.
 */
export function formatBytes(bytes: number, decimals: number = 1): string {
    if (bytes === 0) return '0 Bytes';
    if (isNaN(bytes)) return '---';

    const k = 1024;
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];

    const i = Math.floor(Math.log(bytes) / Math.log(k));

    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
}

/**
 * Truncates a long string for logging purposes.
 * @param str The string to truncate.
 * @param maxLength The total maximum length of the output string.
 * @returns A truncated string in the format "start...end".
 */
export function truncateStringForLogging(str: string, maxLength: number = 100): string {
    if (str.length <= maxLength) {
        return str;
    }
    const halfLength = Math.floor((maxLength - 3) / 2);
    return `${str.substring(0, halfLength)}...${str.substring(str.length - halfLength)}`;
}
</file>

<file path="src/common/utils/view-html.ts">
import * as vscode from "vscode";

export function getViewHtml({ webview, nonce, scriptUri, styleUris = [] }: { webview: vscode.Webview; nonce: string; scriptUri: string; styleUris?: vscode.Uri[]; }): string {
    const styles = styleUris.map(uri => `<link href="${uri}" rel="stylesheet">`).join('\n');
    
    return `<!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src ${webview.cspSource}; script-src 'nonce-${nonce}';">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            ${styles}
        </head>
        <body>
            <div id="root"></div>
            <script nonce="${nonce}" src="${scriptUri}"></script>
        </body>
        </html>`;
}

function getNonce() {
    let text = "";
    const possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    for (let i = 0; i < 32; i++) {
        text += possible.charAt(Math.floor(Math.random() * possible.length));
    }
    return text;
}
export { getNonce };
</file>

<file path="src/common/view-types.ts">
export const VIEW_TYPES = {
  SIDEBAR: {
    CONTEXT_CHOOSER: "viewType.sidebar.contextChooser",
  },
  PANEL: {
    PARALLEL_COPILOT: "viewType.panel.parallelCopilot",
  }
};
</file>

<file path="src/extension.ts">
import * as vscode from "vscode";
import { registerViews, serverIPCs } from "./client/views";
import { registerCommands } from "./backend/commands/register-commands";
import { Services } from "./backend/services/services";
import { VIEW_TYPES } from "./common/view-types";
import { ServerToClientChannel } from "./common/ipc/channels.enum";
import { API as GitAPI, GitExtension } from "./backend/types/git";
import { getNonce, getViewHtml } from "./common/utils/view-html";
import { onMessage as onParallelCopilotMessage } from "./client/views/parallel-copilot.view/on-message";
import { ServerPostMessageManager } from "./common/ipc/server-ipc";

let globalContext: vscode.ExtensionContext | null = null;
let parallelCopilotPanel: vscode.WebviewPanel | undefined;

function createOrShowParallelCopilotPanel(context: vscode.ExtensionContext) {
    const column = vscode.window.activeTextEditor?.viewColumn;

    if (parallelCopilotPanel) {
        parallelCopilotPanel.reveal(column);
        return;
    }

    parallelCopilotPanel = vscode.window.createWebviewPanel(
        VIEW_TYPES.PANEL.PARALLEL_COPILOT,
        'DCE Parallel Co-Pilot',
        column || vscode.ViewColumn.One,
        {
            enableScripts: true,
            localResourceRoots: [context.extensionUri],
        }
    );
    
    const scriptUri = parallelCopilotPanel.webview.asWebviewUri(vscode.Uri.joinPath(context.extensionUri, "dist", "parallelCopilotView.js"));
    const styleUri = parallelCopilotPanel.webview.asWebviewUri(vscode.Uri.joinPath(context.extensionUri, "dist", "parallelCopilotView.css"));
    const starryNightStyleUri = parallelCopilotPanel.webview.asWebviewUri(vscode.Uri.joinPath(context.extensionUri, "dist", "starry-night.css"));
    const nonce = getNonce();
    
    parallelCopilotPanel.webview.html = getViewHtml({
        webview: parallelCopilotPanel.webview,
        nonce,
        scriptUri: scriptUri.toString(),
        styleUris: [styleUri, starryNightStyleUri],
    });
    
    const serverIpc = ServerPostMessageManager.getInstance(
        parallelCopilotPanel.webview.onDidReceiveMessage,
        (data: any) => parallelCopilotPanel?.webview.postMessage(data)
    );

    serverIPCs[VIEW_TYPES.PANEL.PARALLEL_COPILOT] = serverIpc;
    onParallelCopilotMessage(serverIpc);

    parallelCopilotPanel.onDidDispose(() => {
        parallelCopilotPanel = undefined;
    }, null, context.subscriptions);
}

export async function activate(context: vscode.ExtensionContext) {
    Services.loggerService.log('Congratulations, your extension "Data Curation Environment" is now active!');
    globalContext = context;

    let gitApi: GitAPI | undefined;
    try {
        const gitExtension = vscode.extensions.getExtension<GitExtension>('vscode.git');
        if (gitExtension) {
            await gitExtension.activate();
            gitApi = gitExtension.exports.getAPI(1);
        }
    } catch (error) {
        Services.loggerService.error(`Failed to get Git API: ${error}`);
    }

    try {
        Services.initialize(gitApi);
        registerCommands(context);
        context.subscriptions.push(vscode.commands.registerCommand('dce.showParallelCopilot', () => {
            createOrShowParallelCopilotPanel(context);
        }));
        registerViews(context);
    } catch (error: any) {
        Services.loggerService.error(`CRITICAL - Error during activation: ${error.message}`);
        vscode.window.showErrorMessage("Data Curation Environment failed to activate.");
        return;
    }
    
    const updateActiveFile = () => {
        let fileUri: vscode.Uri | undefined;
        const activeEditor = vscode.window.activeTextEditor;
        if (activeEditor?.document.uri.scheme === 'file') {
            fileUri = activeEditor.document.uri;
        } else {
            const tabInput = vscode.window.tabGroups.activeTabGroup.activeTab?.input as { uri?: vscode.Uri };
            if (tabInput?.uri?.scheme === 'file') fileUri = tabInput.uri;
        }

        if (fileUri) {
            const serverIpc = serverIPCs[VIEW_TYPES.SIDEBAR.CONTEXT_CHOOSER];
            if (serverIpc) {
                serverIpc.sendToClient(ServerToClientChannel.SetActiveFile, { path: fileUri.fsPath.replace(/\\/g, '/') });
            }
        }
    };

    context.subscriptions.push(
        vscode.window.onDidChangeActiveTextEditor(updateActiveFile),
        vscode.window.tabGroups.onDidChangeTabs(updateActiveFile),
        vscode.workspace.onDidGrantWorkspaceTrust(() => {
            const serverIpc = serverIPCs[VIEW_TYPES.SIDEBAR.CONTEXT_CHOOSER];
            if (serverIpc) serverIpc.sendToClient(ServerToClientChannel.SendWorkspaceTrustState, { isTrusted: true });
        })
    );

    setTimeout(updateActiveFile, 500);
}

export function getContext() {
    if (!globalContext) throw new Error("Extension context not available.");
    return globalContext;
}

export function deactivate() {}
</file>

<file path="The-Creator-AI-main/.eslintrc.json">
{
    "root": true,
    "parser": "@typescript-eslint/parser",
    "parserOptions": {
        "ecmaVersion": 6,
        "sourceType": "module"
    },
    "plugins": [
        "@typescript-eslint"
    ],
    "rules": {
        "@typescript-eslint/naming-convention": [
            "warn",
            {
                "selector": "import",
                "format": [ "camelCase", "PascalCase" ]
            }
        ],
        "@typescript-eslint/semi": "warn",
        "curly": "warn",
        "eqeqeq": "warn",
        "no-throw-literal": "warn",
        "semi": "off"
    },
    "ignorePatterns": [
        "out",
        "dist",
        "**/*.d.ts"
    ]
}
</file>

<file path="The-Creator-AI-main/.gitignore">
.DS_Store
out
dist
node_modules
.vscode-test/
*.vsix
*.llm
*.code-workspace
</file>

<file path="The-Creator-AI-main/.vscode-test.mjs">
import { defineConfig } from '@vscode/test-cli';

export default defineConfig({
	files: 'out/test/**/*.test.js',
});
</file>

<file path="The-Creator-AI-main/.vscodeignore">
.vscode/**
.vscode-test/**
out/**
node_modules/**
src/**
.gitignore
.yarnrc
webpack.config.js
vsc-extension-quickstart.md
**/tsconfig.json
**/.eslintrc.json
**/*.map
**/*.ts
**/.vscode-test.*
</file>

<file path="The-Creator-AI-main/CHANGELOG.md">
# Change Log

All notable changes to the "the-creator-ai" extension will be documented in this file.

Check [Keep a Changelog](http://keepachangelog.com/) for recommendations on how to structure this file.

## [Unreleased]

- Initial release
</file>

<file path="The-Creator-AI-main/LICENSE">
MIT License

Copyright (c) 2024 Saoud Rizwan

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="The-Creator-AI-main/Notes.md">
[Notes](https://github.com/The-Creator-AI/The-Creator-AI/issues/4)
</file>

<file path="The-Creator-AI-main/package.json">
{
  "name": "the-creator-ai",
  "publisher": "PulkitSingh",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/The-Creator-AI/the-Creator-AI"
  },
  "displayName": "The Creator AI",
  "description": "Coding assistant",
  "version": "0.1.3",
  "engines": {
    "vscode": "^1.90.0"
  },
  "categories": [
    "Other"
  ],
  "activationEvents": [],
  "main": "./dist/extension.js",
  "contributes": {
    "configuration": {
      "title": "Creator Extension",
      "properties": {
        "creatorExtension.llmRepository": {
          "type": "object",
          "description": "Configuration for LLM services"
        },
        "creatorExtension.chatRepository": {
          "type": "object",
          "description": "Chat repository data"
        }
      }
    },
    "commands": [
      {
        "command": "the-creator-ai.helloWorld",
        "title": "Creator AI: Hello World"
      },
      {
        "command": "the-creator-ai.resetClearChangePlanViewState",
        "title": "Creator AI: Clear Change Plan View State"
      },
      {
        "command": "the-creator-ai.chooseChangePlan",
        "title": "Creator AI: Choose Change Plan",
        "icon": "$(history)"
      },
      {
        "command": "the-creator-ai.newPlan",
        "title": "Creator AI: New Plan",
        "icon": "$(sync)"
      },
      {
        "command": "the-creator-ai.clearHistory",
        "title": "Creator AI: Clear History"
      },
      {
        "command": "the-creator-ai.exportChangePlan",
        "title": "Creator AI: Export Change Plan",
        "icon": "$(cloud-upload)"
      },
      {
        "command": "the-creator-ai.importChangePlan",
        "title": "Creator AI: Import Change Plan",
        "icon": "$(cloud-download)"
      }
    ],
    "viewsContainers": {
      "activitybar": [
        {
          "id": "the-creator-ai",
          "title": "Creator AI",
          "icon": "public/spiral.svg"
        }
      ]
    },
    "views": {
      "the-creator-ai": [
        {
          "type": "webview",
          "id": "viewType.sidebar.changePlan",
          "name": "Change Plan"
        }
      ]
    },
    "menus": {
      "view/title": [
        {
          "command": "the-creator-ai.chooseChangePlan",
          "when": "view == viewType.sidebar.changePlan",
          "group": "navigation",
          "title": "Choose Plan"
        },
        {
          "command": "the-creator-ai.newPlan",
          "when": "view == viewType.sidebar.changePlan",
          "group": "navigation",
          "title": "New Plan"
        },
        {
          "command": "the-creator-ai.exportChangePlan",
          "when": "view == viewType.sidebar.changePlan",
          "group": "navigation",
           "title": "Export Plan"
        },
        {
          "command": "the-creator-ai.importChangePlan",
          "when": "view == viewType.sidebar.changePlan",
          "group": "navigation",
           "title": "Import Plan"
        }
      ]
    }
  },
  "scripts": {
    "vscode:prepublish": "npm run package",
    "compile": "webpack",
    "watch": "webpack --watch",
    "package": "webpack --mode production --devtool hidden-source-map",
    "compile-tests": "tsc -p . --outDir out",
    "watch-tests": "tsc -p . -w --outDir out",
    "pretest": "npm run compile-tests && npm run compile && npm run lint",
    "lint": "eslint src --ext ts",
    "test": "vscode-test",
    "vsce-package": "vsce package"
  },
  "devDependencies": {
    "@babel/core": "^7.24.7",
    "@babel/preset-env": "^7.24.7",
    "@babel/preset-react": "^7.24.7",
    "@babel/preset-typescript": "^7.24.7",
    "@types/mocha": "^10.0.6",
    "@types/node": "18.x",
    "@types/react-dom": "^18.3.0",
    "@types/vscode": "^1.90.0",
    "@typescript-eslint/eslint-plugin": "^7.7.1",
    "@typescript-eslint/parser": "^7.7.1",
    "@vscode/test-cli": "^0.0.9",
    "@vscode/test-electron": "^2.3.9",
    "autoprefixer": "^10.4.20",
    "babel-loader": "^9.1.3",
    "copy-webpack-plugin": "^12.0.2",
    "css-loader": "^7.1.2",
    "eslint": "^8.57.0",
    "node-sass": "^9.0.0",
    "postcss": "^8.4.45",
    "postcss-loader": "^8.1.1",
    "postcss-preset-env": "^10.0.3",
    "process": "^0.11.10",
    "sass": "^1.78.0",
    "sass-loader": "^16.0.1",
    "style-loader": "^4.0.0",
    "tailwindcss": "^3.4.10",
    "ts-loader": "^9.5.1",
    "typescript": "^5.4.5",
    "vsce": "^2.15.0",
    "webpack": "^5.91.0",
    "webpack-cli": "^5.1.4"
  },
  "dependencies": {
    "@anthropic-ai/sdk": "^0.27.0",
    "@anthropic-ai/tokenizer": "^0.0.4",
    "@google/generative-ai": "^0.12.0",
    "@vscode/webview-ui-toolkit": "^1.4.0",
    "axios": "^1.7.5",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.1",
    "firebase": "^10.13.2",
    "injection-js": "^2.4.0",
    "markdown-to-jsx": "^7.5.0",
    "openai": "^4.56.0",
    "puppeteer": "^23.2.0",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-icons": "^5.3.0",
    "reflect-metadata": "^0.2.2",
    "rxjs": "^7.8.1",
    "tiktoken": "^1.0.16",
    "uuid": "^10.0.0"
  }
}
</file>

<file path="The-Creator-AI-main/postcss.config.js">
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="The-Creator-AI-main/public/main.css">
body {
	background-color: transparent;
}

.color-list {
	list-style: none;
	padding: 0;
}

.color-entry {
	width: 100%;
	display: flex;
	margin-bottom: 0.4em;
	border: 1px solid var(--vscode-input-border);
}

.color-preview {
	width: 2em;
	height: 2em;
}

.color-preview:hover {
	outline: inset white;
}

.color-input {
	display: block;
	flex: 1;
	width: 100%;
	color: var(--vscode-input-foreground);
	background-color: var(--vscode-input-background);
	border: none;
	padding: 0 0.6em;
}

.add-color-button {
	display: block;
	border: none;
	margin: 0 auto;
}
</file>

<file path="The-Creator-AI-main/public/reset.css">
html {
	box-sizing: border-box;
	font-size: 13px;
}

*,
*:before,
*:after {
	box-sizing: inherit;
}

body,
h1,
h2,
h3,
h4,
h5,
h6,
p,
ol,
ul {
	margin: 0;
	padding: 0;
	font-weight: normal;
}

img {
	max-width: 100%;
	height: auto;
}
</file>

<file path="The-Creator-AI-main/public/spiral.svg">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200">
    <g id="Page-1" stroke="none" fill="none" fill-rule="evenodd">
        <g id="dep" transform="translate(4, 6)">
            <path d="M100 100 
            m 0 -80 
            a 80 80 0 0 1 0 160 
            a 70 70 0 0 1 0 -140 
            a 60 60 0 0 1 0 120 
            a 50 50 0 0 1 0 -100 
            a 40 40 0 0 1 0 80 
            a 30 30 0 0 1 0 -60 
            a 20 20 0 0 1 0 40"
                fill="none" stroke="white" stroke-width="8"
                id="Shape" />
        </g>
    </g>
</svg>
</file>

<file path="The-Creator-AI-main/public/vscode.css">
:root {
	--container-paddding: 20px;
	--input-padding-vertical: 6px;
	--input-padding-horizontal: 4px;
	--input-margin-vertical: 4px;
	--input-margin-horizontal: 0;
}

body {
	padding: 0 var(--container-paddding);
	color: var(--vscode-foreground);
	font-size: var(--vscode-font-size);
	font-weight: var(--vscode-font-weight);
	font-family: var(--vscode-font-family);
	background-color: var(--vscode-editor-background);
}

ol,
ul {
	padding-left: var(--container-paddding);
}

body > *,
form > * {
	margin-block-start: var(--input-margin-vertical);
	margin-block-end: var(--input-margin-vertical);
}

*:focus {
	outline-color: var(--vscode-focusBorder) !important;
}

a {
	color: var(--vscode-textLink-foreground);
}

a:hover,
a:active {
	color: var(--vscode-textLink-activeForeground);
}

code {
	font-size: var(--vscode-editor-font-size);
	font-family: var(--vscode-editor-font-family);
}

button {
	border: none;
	padding: var(--input-padding-vertical) var(--input-padding-horizontal);
	width: 100%;
	text-align: center;
	outline: 1px solid transparent;
	outline-offset: 2px !important;
	color: var(--vscode-button-foreground);
	background: var(--vscode-button-background);
}

button:hover {
	cursor: pointer;
	background: var(--vscode-button-hoverBackground);
}

button:focus {
	outline-color: var(--vscode-focusBorder);
}

button.secondary {
	color: var(--vscode-button-secondaryForeground);
	background: var(--vscode-button-secondaryBackground);
}

button.secondary:hover {
	background: var(--vscode-button-secondaryHoverBackground);
}

input:not([type='checkbox']),
textarea {
	display: block;
	width: 100%;
	border: none;
	font-family: var(--vscode-font-family);
	padding: var(--input-padding-vertical) var(--input-padding-horizontal);
	color: var(--vscode-input-foreground);
	outline-color: var(--vscode-input-border);
	background-color: var(--vscode-input-background);
}

input::placeholder,
textarea::placeholder {
	color: var(--vscode-input-placeholderForeground);
}
</file>

<file path="The-Creator-AI-main/README.md">
# The Creator AI

This extension integrates a coding assistant directly into your VS Code environment.

<img width="350" alt="image" src="https://github.com/user-attachments/assets/ea18a853-4640-4b35-b291-f6c39ea35bb4" />
<img width="350" alt="image" src="https://github.com/user-attachments/assets/53cbe519-e8b9-4d7c-a101-151b316bf28f" />

## Features

* **Context chooser:** Choose files/folders through UI which are to be kept in the context.
* **Code Change Plan:** Describe code changes you'd like to plan, and the AI will generate a plan for implementation.

## Requirements

This extension requires an API key for either Gemini or OpenAI. You'll be prompted to enter your key when you first use the extension.


## Release Notes

### 0.0.1

Initial release of the Creator AI extension with basic chat, change plan, and file explorer functionalities.

## Following Extension Guidelines

This extension adheres to the VS Code extension guidelines and best practices.

* [Extension Guidelines](https://code.visualstudio.com/api/references/extension-guidelines)

## Working with Markdown

You can edit this README using Visual Studio Code. Some useful keyboard shortcuts:

* Split the editor (`Cmd+\` on macOS or `Ctrl+\` on Windows and Linux).
* Toggle preview (`Shift+Cmd+V` on macOS or `Shift+Ctrl+V` on Windows and Linux).
* Press `Ctrl+Space` (Windows, Linux, macOS) for Markdown snippets.

## For More Information

* [Visual Studio Code's Markdown Support](http://code.visualstudio.com/docs/languages/markdown)
* [Markdown Syntax Reference](https://help.github.com/articles/markdown-basics/)

**Enjoy!** 
</file>

<file path="The-Creator-AI-main/src/backend/commands/commands.ts">
import { ChangePlan } from "@/client/views/change-plan.view/store/change-plan-view.state-type";
import { remoteSetChangePlanViewState } from "@/backend/utils/remoteSetChangePlanViewState";
import { VIEW_TYPES } from "@/common/view-types";
import * as vscode from "vscode";
import { Services } from "@/backend/services/services";
import { serverIPCs } from "@/client/views";

// Define an array of commands with their corresponding callback functions
export const commands = [
  {
    commandId: "the-creator-ai.helloWorld",
    callback: () => {
      console.log("Hello World from the-creator-ai!");
      vscode.window.showInformationMessage(
        "Hello World from the-creator-ai!"
      );
    },
  },
  {
    commandId: "the-creator-ai.resetClearChangePlanViewState",
    callback: async () => {
      const persistentStoreRepository =
        Services.getPersistentStoreRepository();
      await persistentStoreRepository.clearChangePlanViewState();
    },
  },
  {
    commandId: "the-creator-ai.chooseChangePlan",
    callback: async () => {
      const persistentStoreRepository =
        Services.getPersistentStoreRepository();
      const store = persistentStoreRepository.getChangePlanViewState();
      const changePlans = store?.changePlans || [];

      // Sort change plans by last updated date (descending)
      changePlans.sort((a: ChangePlan, b: ChangePlan) => b.lastUpdatedAt - a.lastUpdatedAt);

      // Show quick pick with plan titles
      const selectedPlan = await vscode.window.showQuickPick(
        changePlans.map((plan: ChangePlan) => {
          return {
            label: plan.planTitle,
            description: new Date(plan.lastUpdatedAt).toLocaleString(),
            plan,
          };
        }),
        {
          placeHolder: "Select a plan to load or delete",
          matchOnDescription: true
        }
      );

      if (selectedPlan) {
        const choice = await vscode.window.showQuickPick(
          ['Load', 'Delete'],
          {
            placeHolder: `What do you want to do with: ${selectedPlan.label} plan?`
          }
        )
        if (choice === 'Load') {
          const serverIpc = serverIPCs[VIEW_TYPES.SIDEBAR.CHANGE_PLAN];
          remoteSetChangePlanViewState(
            serverIpc,
            "changeDescription",
            selectedPlan.plan.planDescription
          );
          remoteSetChangePlanViewState(
            serverIpc,
            "llmResponse",
            selectedPlan.plan.llmResponse
          );
          remoteSetChangePlanViewState(
            serverIpc,
            "selectedFiles",
            selectedPlan.plan.selectedFiles
          );
          remoteSetChangePlanViewState(
            serverIpc,
            "chatHistory",
            selectedPlan.plan.chatHistory
          );
          remoteSetChangePlanViewState(
            serverIpc,
            "changePlans",
            changePlans
          );
        } else if(choice === 'Delete') {
          const confirmDelete = await vscode.window.showWarningMessage(
            `Are you sure you want to delete the plan "${selectedPlan.label}"?`,
            { modal: true },
            'Yes', 'No'
          );

          if (confirmDelete === 'Yes') {
            const updatedChangePlans = changePlans.filter((plan: ChangePlan) => plan.planTitle !== selectedPlan.label);
            persistentStoreRepository.setChangePlanViewState({
              ...store,
              changePlans: updatedChangePlans,
            });
          }
        }
      }
    },
  },
  {
    commandId: "the-creator-ai.newPlan",
    callback: async () => {
      const serverIpc = serverIPCs[VIEW_TYPES.SIDEBAR.CHANGE_PLAN];
      remoteSetChangePlanViewState(serverIpc, "changeDescription", "");
      remoteSetChangePlanViewState(serverIpc, "llmResponse", "");
      remoteSetChangePlanViewState(serverIpc, "chatHistory", []);
      remoteSetChangePlanViewState(serverIpc, "fileChunkMap", {});
      remoteSetChangePlanViewState(serverIpc, "isLoading", false);
    },
  },
  {
    commandId: "the-creator-ai.clearHistory",
    callback: async () => {
      const persistentStoreRepository =
        Services.getPersistentStoreRepository();
      await persistentStoreRepository.clearChangePlanViewState();
    },
  },
  {
    commandId: "the-creator-ai.exportChangePlan",
    callback: async () => {
      const planExImService = Services.getPlanExImService();
      await planExImService.exportAllChangePlans();
    },
  },
  {
    commandId: "the-creator-ai.importChangePlan",
    callback: async () => {
       const planExImService = Services.getPlanExImService();
      await planExImService.importAllChangePlans();
    },
  },
];
</file>

<file path="The-Creator-AI-main/src/backend/commands/register-commands.ts">
import * as vscode from "vscode";
import { commands } from "./commands";

export function registerCommands(context: vscode.ExtensionContext) {
  // Iterate over the commands array to register each command
  commands.forEach(({ commandId, callback }) => {
    let disposable = vscode.commands.registerCommand(commandId, callback);
    context.subscriptions.push(disposable);
  });
}
</file>

<file path="The-Creator-AI-main/src/backend/repositories/chat.respository.ts">
import { randomUUID } from "crypto";
import { getContext } from "../../extension";
import { StorageKeysEnum } from "../types/storage-keys.enum";

export interface ChatMessage {
  user: 'user' | 'bot' | 'instrutor'
  message: string;
}

export interface Chat {
  id: string;
  messages: ChatMessage[];
}

interface ChatRepositoryData {
  chats: Chat[];
  activeChatId: string | null;
}

const defaultChatRepositoryData: ChatRepositoryData = {
  chats: [],
  activeChatId: null,
};

export class ChatRepository {
  private static async getChatRepositoryData(): Promise<ChatRepositoryData> {
    const chatRepositoryData =
      getContext().workspaceState.get<ChatRepositoryData>(
        StorageKeysEnum.ChatRepository
      );
    if (!chatRepositoryData || !chatRepositoryData.chats) {
      await getContext().workspaceState.update(
        StorageKeysEnum.ChatRepository,
        defaultChatRepositoryData
      );
      return defaultChatRepositoryData;
    }
    return chatRepositoryData;
  }

  private static async patchChatRepositoryData(
    chatRepositoryData: Partial<ChatRepositoryData>
  ): Promise<void> {
    const existingData = await this.getChatRepositoryData();
    const updatedData = {
      ...existingData,
      ...chatRepositoryData,
    };
    await getContext().workspaceState.update(
        StorageKeysEnum.ChatRepository,
      updatedData
    );
  }

  static async getChats(): Promise<Chat[]> {
    return (await this.getChatRepositoryData()).chats;
  }

  static async getChatById(id?: string): Promise<Chat | undefined> {
    if (!id) {
      return this.getActiveChat();
    }
    const chats = await this.getChats();
    return chats.find((chat) => chat.id === id);
  }

  static async createChat(): Promise<Chat> {
    const newChat: Chat = { id: randomUUID(), messages: [] };
    const chats = await this.getChats();
    chats.push(newChat);
    await this.patchChatRepositoryData({ chats });
    await this.setActiveChat(newChat.id);
    return newChat;
  }

  static async updateChat(updatedChat: Chat): Promise<void> {
    const chats = await this.getChats();
    const index = chats.findIndex((chat) => chat.id === updatedChat.id);
    if (index !== -1) {
      chats[index] = updatedChat;
      await this.patchChatRepositoryData({ chats });
    }
  }

  static async deleteChat(id: string): Promise<void> {
    const chats = await this.getChats();
    const updatedChats = chats.filter((chat) => chat.id !== id);
    await this.patchChatRepositoryData({ chats: updatedChats });
  }

  static async getActiveChat() {
    const activeChatId = (await this.getChatRepositoryData()).activeChatId;
    if (!activeChatId) {
      return await this.createChat();
    }
    const activeChat = await this.getChatById(activeChatId);
    if (!activeChat) {
      return await this.createChat();
    }
    return activeChat;
  }

  static async setActiveChat(chatId: string | null): Promise<void> {
    await this.patchChatRepositoryData({ activeChatId: chatId });
  }

  // Message Management within a Chat
  static async addMessageToChat(
    chatId: string,
    message: ChatMessage
  ): Promise<void> {
    const chat = await this.getChatById(chatId);
    if (chat) {
      chat.messages.push(message);
      await this.updateChat(chat);
    }
  }

  static async updateMessageInChat(
    chatId: string,
    messageIndex: number,
    updatedMessage: ChatMessage
  ): Promise<void> {
    const chat = await this.getChatById(chatId);
    if (chat && chat.messages[messageIndex]) {
      chat.messages[messageIndex] = updatedMessage;
      await this.updateChat(chat);
    }
  }

  static async deleteMessageFromChat(
    chatId: string,
    messageIndex: number
  ): Promise<void> {
    const chat = await this.getChatById(chatId);
    if (chat && chat.messages[messageIndex]) {
      chat.messages.splice(messageIndex, 1);
      await this.updateChat(chat);
    }
  }
}
</file>

<file path="The-Creator-AI-main/src/backend/repositories/persistent-store.repository.ts">
import * as vscode from "vscode";
import { StorageKeysEnum } from "../types/storage-keys.enum";
import { getContext } from "../../extension";
import {ChangePlanViewStore} from '@/client/views/change-plan.view/store/change-plan-view.state-type';

export class PersistentStoreRepository {
  private readonly workspaceState: vscode.Memento;

  constructor() {
    this.workspaceState = getContext().workspaceState;
  }

  public getChangePlanViewState(): ChangePlanViewStore | undefined {
    const data = this.workspaceState.get<ChangePlanViewStore>(
      StorageKeysEnum.ChangePlanViewState
    );
    return data;
  }

  public setChangePlanViewState(data: ChangePlanViewStore): void {
    this.workspaceState.update(StorageKeysEnum.ChangePlanViewState, data);
  }

  public clearChangePlanViewState(): void {
    this.workspaceState.update(StorageKeysEnum.ChangePlanViewState, undefined);
  }
}
</file>

<file path="The-Creator-AI-main/src/backend/repositories/settings.repository.ts">
import { Injectable } from "injection-js";
import { getContext } from "../../extension";
import { LlmServiceEnum } from "../types/llm-service.enum";
import { StorageKeysEnum } from "../types/storage-keys.enum";

@Injectable()
export class SettingsRepository {
  async getLLMApiKeys(): Promise<Record<LlmServiceEnum, string[]> | undefined> {
    try {
      const llmApiKeys = getContext().workspaceState.get<string>(
        StorageKeysEnum.LlmApiKeys
      );

      return llmApiKeys ? JSON.parse(llmApiKeys) : {};
    } catch (error) {
      console.error("Error retrieving LLM API keys:", error);
      return undefined;
    }
  }

  async setLLMApiKey(service: LlmServiceEnum, apiKey: string): Promise<void> {
    const llmApiKeys = (await this.getLLMApiKeys()) || {};
    llmApiKeys[service]
      ? llmApiKeys[service].push(apiKey)
      : (llmApiKeys[service] = [apiKey]);

    try {
      getContext().workspaceState.update(
        StorageKeysEnum.LlmApiKeys,
        JSON.stringify(llmApiKeys)
      );
    }
    catch (error) {
      console.error("Error setting LLM API key:", error);
      throw error;
    }
  }

  async deleteLLMApiKey(
    service: LlmServiceEnum,
    apiKeyToDelete: string
  ): Promise<void> {
    const llmApiKeys = (await this.getLLMApiKeys()) || {};
    llmApiKeys[service]
      ? (llmApiKeys[service] = llmApiKeys[service].filter(
          (apiKey) => apiKey !== apiKeyToDelete
        ))
      : null;

    try {
      getContext().workspaceState.update(
        StorageKeysEnum.LlmApiKeys,
        JSON.stringify(llmApiKeys)
      );
    }
    catch (error) {
      console.error("Error deleting LLM API key:", error);
      throw error;
    }
  }
}
</file>

<file path="The-Creator-AI-main/src/backend/services/code.service.ts">
import * as vscode from "vscode";
import * as fs from "fs";
import * as path from "path";
import { Injectable } from "injection-js";
import { Services } from "./services";
import { AGENTS } from "@/common/constants/agents.constants";

@Injectable()
export class CodeService {
  public findFilePaths(paths: string[]): string[] {
    return paths.map(this.findFilePath.bind(this)); // Bind to the service instance
  }

  public findFilePath(filePath: string): string {
    if (fs.existsSync(filePath)) {
      return filePath;
    }

    const parts = filePath.split(path.sep);
    let currentPath = parts[0];

    // Traverse the path from the top to find the deepest valid directory
    for (let i = 1; i < parts.length; i++) {
      currentPath = path.join(currentPath, parts[i]);
      if (!fs.existsSync(currentPath)) {
        currentPath = path.dirname(currentPath);
        break;
      }
    }

    const fileName = parts[parts.length - 1];
    let dirToSearch = currentPath;
    let foundFiles = this.findFilesInDirectory(dirToSearch, fileName);

    while (!foundFiles?.length) {
      dirToSearch = path.dirname(dirToSearch);
      if (dirToSearch === ".") break;
      foundFiles = this.findFilesInDirectory(dirToSearch, fileName);
    }

    if (foundFiles.length === 1) {
      return foundFiles[0];
    } else if (foundFiles.length > 1) {
      const parentDir = parts[parts.length - 2];
      for (const file of foundFiles) {
        if (path.basename(path.dirname(file)) === parentDir) {
          return file;
        }
      }
    }

    console.error(`File not found: ${filePath}`);
    console.log(`Creating file: ${filePath}`);

    fs.writeFileSync(filePath, "", "utf-8");
    return filePath;
  }

  /**
   * Recursively searches for files with a given name in a directory and its subdirectories.
   * @param dir The directory to search in.
   * @param fileName The name of the file to search for.
   * @returns An array of file paths that match the file name.
   */
  private findFilesInDirectory(dir: string, fileName: string): string[] {
    try {
      const stat = fs.statSync(dir);
      if (!stat.isDirectory()) return [];
    } catch (err) {
      return [];
    }

    const files: string[] = [];
    try {
      const items = fs.readdirSync(dir);

      for (const item of items) {
        const fullPath = path.join(dir, item);
        const stat = fs.statSync(fullPath);

        if (stat.isFile() && path.basename(fullPath) === fileName) {
          files.push(fullPath);
        } else if (stat.isDirectory()) {
          files.push(...this.findFilesInDirectory(fullPath, fileName)); // Use this.findFilesInDirectory
        }
      }
    } catch (err) {
      console.error(`Error reading directory ${dir}:`, err);
    }

    return files;
  }

  getDiff(diffText: string) {
    const diffLines = diffText.split("\n");

    let fileToChange: string | undefined = undefined;
    let originalCode: string | undefined = undefined;
    let modifiedCode: string | undefined = undefined;
    let inSearchBlock = false;
    let inReplaceBlock = false;
    let inFilePathBlock = false;

    const changes = [];

    for (const line of diffLines) {
      if (line.startsWith("\`\`\`diff")) {
        if (fileToChange && originalCode && modifiedCode) {
          changes.push({ fileToChange, originalCode, modifiedCode });
        }
        fileToChange = undefined;
        originalCode = undefined;
        modifiedCode = undefined;
        inFilePathBlock = true;
        continue;
      }

      if (inFilePathBlock) {
        fileToChange = line.trim();
        inFilePathBlock = false;
        continue;
      }

      if (line.startsWith("<<<<<<< SEARCH")) {
        inSearchBlock = true;
        inReplaceBlock = false;
        continue;
      }

      if (line.startsWith("=======")) {
        inSearchBlock = false;
        inReplaceBlock = true;
        continue;
      }

      if (line.startsWith(">>>>>>>")) {
        if (fileToChange && originalCode && modifiedCode) {
          changes.push({ fileToChange, originalCode, modifiedCode });
        }
        fileToChange = undefined;
        originalCode = undefined;
        modifiedCode = undefined;
        inSearchBlock = false;
        inReplaceBlock = false;
        continue;
      }

      if (inSearchBlock && originalCode !== undefined) {
        originalCode += line + "\n";
      } else if (inSearchBlock) {
        originalCode = line + "\n";
      } else if (inReplaceBlock && modifiedCode !== undefined) {
        modifiedCode += line + "\n";
      } else if (inReplaceBlock) {
        modifiedCode = line + "\n";
      }
    }

    // Push the last block if it exists
    if (fileToChange && originalCode && modifiedCode) {
      changes.push({ fileToChange, originalCode, modifiedCode });
    }

    return changes;
  }

  public async applyDiffs(
    diffText: string,
    trySmartApply: (
      filePath: string,
      originalCode: string,
      modifiedCode: string
    ) => void
  ): Promise<void> {
    const blocks = this.getDiff(diffText);
    console.log({ diffText, blocks });

    for await (const block of blocks) {
      const { fileToChange, originalCode, modifiedCode } = block;

      const currentFilePath = this.findFilePath(fileToChange); // Use injected service

      const resCode = await this.applyChangesToFile(
        currentFilePath,
        originalCode,
        modifiedCode
      );

      if (resCode) {
        trySmartApply(currentFilePath, originalCode, modifiedCode);
      }
    }
  }

  private escapeRegExp(str: string): string {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }

  private async applyChangesToFile(
    filePath: string,
    originalCode: string,
    modifiedCode: string
  ): Promise<boolean> {
    console.log({ filePath, originalCode, modifiedCode });

    try {
      const fileContent = await fs.promises.readFile(filePath, "utf8");
      if (!originalCode ) {
        await fs.promises.writeFile(filePath, modifiedCode, "utf8");
      }

      const whitespaceFlexibleOriginalCode = this.escapeRegExp(originalCode)
        .split("\n")
        .map((line) => line.trim().replace(/\s+/g, "\\s+"))
        .join("\\s*");

      const regex = new RegExp(whitespaceFlexibleOriginalCode, "g");
      console.log({ whitespaceFlexibleOriginalCode });

      const updatedContent = fileContent.replace(regex, modifiedCode);

      await fs.promises.writeFile(filePath, updatedContent, "utf8");
      console.log(`Applied changes to ${filePath}`);

      return fileContent === updatedContent;
    } catch (error) {
      console.error(`Error applying changes to ${filePath}:`, error);
      return false; // Indicate failure
    }
  }

  private getFileContent(filePath: string): Promise<string> {
    return new Promise((resolve, reject) => {
      try {
        const data = fs.readFileSync(filePath, "utf-8");
        resolve(data);
      } catch (error) {
        console.error("Error reading file:", error);
        reject("Error reading file");
      }
    });
  }

  private async writeFileContent(
    filePath: string,
    content: string
  ): Promise<void> {
    const fileUri = vscode.Uri.file(filePath);
    const encoder = new TextEncoder();
    await vscode.workspace.fs.writeFile(fileUri, encoder.encode(content));
  }

  private async openFileAndShowDiff(filePath: string): Promise<void> {
    const fileUri = vscode.Uri.file(filePath);
    const document = await vscode.workspace.openTextDocument(fileUri);
    await vscode.window.showTextDocument(document);
    await vscode.commands.executeCommand("git.openChange", fileUri);
  }

  private extractCodeFromResponse(response: string): string {
    const codeBlockRegex = /```[\w]*\n([\s\S]*?)\n```/;
    const match = response.match(codeBlockRegex);
    return match ? match[1] : response;
  }

  private extractDiffFromResponse(response: string): string {
    const diffBlockRegex = /```diff\n([\s\S]*?)\n```/;
    console.log(response);
    const match = response.match(diffBlockRegex);
    return match ? match[1] : response;
  }

  private createPromptForLLM(filePath: string, fileContent: string): string {
    return `Based on the plan above and previous conversation, please give the updated code for the file: ${filePath}.
      Also please make sure to give full file code in the response.
      `;
  }

  async requestFileCode(
    filePath: string,
    chatHistory: any[],
    selectedFiles: string[],
    onChunk?: (path: string, chunk: string) => void
  ) {
    ``;
    const fsService = Services.getFSService();
    const absoluteFilePath = await fsService.resolveFilePath(filePath);
    if (!absoluteFilePath) {
      throw new Error(`Could not resolve file path: ${filePath}`);
    }

    try {
      // Check if the file exists
      if (!fs.existsSync(absoluteFilePath)) {
        // If the file doesn't exist, create it
        if (path.isAbsolute(absoluteFilePath)) {
          // If the path is absolute, create it at that path
          fs.writeFileSync(absoluteFilePath, "");
        } else {
          // If the path is relative, create it relative to the workspace directory
          const workspacePath =
            vscode.workspace.workspaceFolders![0].uri.fsPath;
          const fullFilePath = path.join(workspacePath, absoluteFilePath);
          fs.writeFileSync(fullFilePath, "");
        }
      }

      const fileContentString = await this.getFileContent(absoluteFilePath);
      const finalMessage = this.createPromptForLLM(
        absoluteFilePath,
        fileContentString
      );
      const response = await Services.getLlmService().sendPrompt(
        [
          ...chatHistory,
          {
            user: "instructor",
            message: AGENTS.Developer_diff.systemInstructions,
          },
          { user: "user", message: finalMessage },
        ],
        selectedFiles,
        (chunk: string) => {
          if (onChunk) {
            onChunk(absoluteFilePath, chunk);
          }
        }
      );

      const updatedCode = await this.applyDiffs(response.response, () => {});

      // TODO: Instead of showing the diff after making change, we can show it before and ask user to apply the changes
      //   await this.openFileAndShowDiff(absoluteFilePath);
      return {
        filePath: absoluteFilePath,
        fileContent: response.response,
      };
    } catch (error) {
      console.error(`Error processing file: ${error}`);
      throw error;
    }
  }
}
</file>

<file path="The-Creator-AI-main/src/backend/services/fs.service.ts">
import * as fs from "fs";
import * as path from "path";
import * as vscode from "vscode";
import { Injectable } from "injection-js";
import { ServerToClientChannel } from "@/common/ipc/channels.enum";
import { ServerPostMessageManager } from "@/common/ipc/server-ipc";
import { FileNode } from "@/common/types/file-node";
import { Services } from "@/backend/services/services";

@Injectable()
export class FSService {
  createFileTree(
    workspaceRoots: vscode.Uri[],
    files: vscode.Uri[],
    fromSystemRoot = false
  ): FileNode[] {
    const rootNodes: FileNode[] = workspaceRoots.map((root) => {
      if (!fromSystemRoot) {
        return {
          name: root.path.split("/").pop() || "",
          children: [],
          absolutePath: root.fsPath,
        };
      }
      const parts = root.path.split("/").filter(Boolean);
      let currentNode: FileNode = {
        name: parts[0],
        children: [],
        absolutePath: "/" + parts[0],
      };
      let rootNode = currentNode;

      for (let i = 1; i < parts.length; i++) {
        const newNode: FileNode = {
          name: parts[i],
          children: [],
          absolutePath: path.join(currentNode.absolutePath, parts[i]),
        };
        currentNode.children!.push(newNode);
        currentNode = newNode;
      }

      return rootNode;
    });
    const leafNodes = rootNodes.map((root) => {
      let currentNode = root;
      while (currentNode.children && currentNode.children.length > 0) {
        currentNode = currentNode.children[currentNode.children.length - 1];
      }
      return currentNode;
    });

    const workspaceRootPaths = workspaceRoots.map((root) => root.fsPath);

    for (const file of files) {
      const workspaceRootIndex = workspaceRootPaths.findIndex((rootPath) =>
        file.fsPath.startsWith(rootPath)
      );

      if (workspaceRootIndex !== -1) {
        const relativePath = path.relative(
          workspaceRootPaths[workspaceRootIndex],
          file.fsPath
        );
        const parts = relativePath.split(path.sep).filter(Boolean);

        let currentNode = leafNodes[workspaceRootIndex];

        for (let i = 0; i < parts.length; i++) {
          const part = parts[i];
          let child = currentNode.children?.find((c) => c.name === part);

          if (!child) {
            child = {
              name: part,
              absolutePath: path.join(currentNode.absolutePath, part),
            };
            if (i < parts.length - 1) {
              child.children = [];
            }
            currentNode.children = currentNode.children || [];
            currentNode.children.push(child);
          }

          currentNode = child;
        }
      }
    }

    return rootNodes;
  }

  readFileContent(filePath: string): string {
    try {
      const data = fs.readFileSync(filePath, "utf-8");
      return data;
    } catch (error) {
      console.error("Error reading file:", error);
      return "Error reading file";
    }
  }

  readSelectedFilesContent(filePaths: string[]): {
    [filePath: string]: string;
  } {
    const fileContents: { [filePath: string]: string } = {};
    const processedPaths = new Set<string>();

    const readContentRecursive = (filePath: string) => {
      if (processedPaths.has(filePath)) {
        return;
      }
      processedPaths.add(filePath);

      try {
        if (fs.statSync(filePath).isDirectory()) {
          fs.readdirSync(filePath).forEach((file) =>
            readContentRecursive(path.join(filePath, file))
          );
        } else {
          try {
            fileContents[filePath] = fs.readFileSync(filePath, "utf8");
          } catch (error) {
            console.error(`Error reading file ${filePath}: ${error}`);
          }
        }
      } catch (error) {
        console.error(`Error reading file ${filePath}: ${error}`);
      }
    };

    filePaths.forEach((filePath) => readContentRecursive(filePath));

    return fileContents;
  }

  async resolveFilePath(originalFilePath: string): Promise<string | null> {
    async function findFile(filePath: string): Promise<string | null> {
      const files = await vscode.workspace.findFiles(
        `**/${filePath}`,
        null,
        10
      );

      if (files.length === 1) {
        return files[0].fsPath;
      } else if (files.length > 1) {
        const selectedFile = await vscode.window.showQuickPick(
          files.map((file) => file.fsPath),
          {
            placeHolder: "Multiple files found. Please select the correct one.",
          }
        );
        return selectedFile || null;
      } else {
        const pathParts = filePath.split("/");
        if (pathParts.length > 1) {
          // Drop the first part of the path and try again
          const remainingPath = pathParts.slice(1).join("/");
          return findFile(remainingPath);
        }
        return null;
      }
    }

    const resolvedPath = await findFile(originalFilePath);

    if (resolvedPath) {
      return resolvedPath;
    } else {
      // File not found, ask the user to confirm or modify the path for creating an empty file
      // TODO: What if there are multiple workspace folders?
      const workspacePath = vscode.workspace.workspaceFolders![0].uri.fsPath;
      let newFilePath = await vscode.window.showInputBox({
        prompt:
          "The file is not found. Please confirm or modify the file path to create an empty file.",
        value: originalFilePath,
      });
      const isAbsolute = path.isAbsolute(newFilePath);
      newFilePath = isAbsolute
        ? newFilePath
        : path.join(workspacePath, newFilePath);

      if (newFilePath) {
        const dirPath = path.dirname(newFilePath);

        // Create directory if it doesn't exist
        if (!fs.existsSync(dirPath)) {
          fs.mkdirSync(dirPath, { recursive: true });
        }

        console.log("Creating new file at", newFilePath);

        // Create empty file
        fs.writeFileSync(newFilePath, "");
        vscode.window.showTextDocument(vscode.Uri.file(newFilePath));
        return newFilePath;
      }
      return null;
    }
  }

  async handleFileOpen(data: { filePath: string }) {
    const { filePath } = data;

    const absoluteFilePath = await this.resolveFilePath(filePath);
    if (!absoluteFilePath) {
      return; // Error message already shown in resolveFilePath
    }

    try {
      // Check if the file exists
      if (!fs.existsSync(absoluteFilePath)) {
        // If the file doesn't exist, create it
        if (path.isAbsolute(absoluteFilePath)) {
          // If the path is absolute, create it at that path
          fs.writeFileSync(absoluteFilePath, "");
        } else {
          // If the path is relative, create it relative to the workspace directory
          const workspacePath =
            vscode.workspace.workspaceFolders![0].uri.fsPath;
          const fullFilePath = path.join(workspacePath, absoluteFilePath);
          fs.writeFileSync(fullFilePath, "");
        }
      }

      await vscode.window.showTextDocument(vscode.Uri.file(absoluteFilePath), {
        preview: false,
      });
    } catch (error) {
      vscode.window.showErrorMessage(`Error opening file: ${error}`);
    }
  }

  setupFileSystemWatcher(serverIpc: any) {
    let fileSystemWatcher: vscode.FileSystemWatcher | undefined;
    if (fileSystemWatcher) {
      fileSystemWatcher.dispose();
    }

    fileSystemWatcher = vscode.workspace.createFileSystemWatcher("**/*");

    fileSystemWatcher.onDidCreate(() => this.sendWorkspaceFiles(serverIpc));
    fileSystemWatcher.onDidDelete(() => this.sendWorkspaceFiles(serverIpc));
    fileSystemWatcher.onDidChange(() => this.sendWorkspaceFiles(serverIpc));
  }

  async handleWorkspaceFilesRequest(serverIpc: ServerPostMessageManager) {
    await this.sendWorkspaceFiles(serverIpc);

    // Set up file system watcher if not already set
    this.setupFileSystemWatcher(serverIpc);
  }

  async sendWorkspaceFiles(serverIpc: ServerPostMessageManager) {
    const workspaceRoots =
      vscode.workspace.workspaceFolders?.map((folder) => folder.uri) || [];
    const fsService = Services.getFSService();
    const files = await fsService.getFilesRespectingGitignore();
    const workspaceFileTree = fsService.createFileTree(workspaceRoots, files);

    serverIpc.sendToClient(ServerToClientChannel.SendWorkspaceFiles, {
      files: workspaceFileTree,
    });
  }

  async getFilesRespectingGitignore(): Promise<vscode.Uri[]> {
    const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
    if (!workspaceFolder) {
      return [];
    }

    const gitignores = await this.findGitignores(workspaceFolder.uri);
    const allFiles = await vscode.workspace.findFiles("**/*");

    return allFiles.filter((file) => !this.isIgnored(file.fsPath, gitignores));
  }

  async findGitignores(workspaceUri: vscode.Uri): Promise<any[]> {
    const gitignoreFiles = await vscode.workspace.findFiles("**/.gitignore");
    const gitignores: any[] = [];

    for (const gitignoreUri of gitignoreFiles) {
      const content = await vscode.workspace.fs.readFile(gitignoreUri);
      gitignores.push({
        path: path.dirname(gitignoreUri.fsPath),
        ig: this.ignore().add(content.toString()),
      });
    }

    return gitignores;
  }

  ignore(): any {
    return {
      add: (content: string) => {
        const ignored = (filePath: string) => {
          return content
            .split("\n")
            .filter(Boolean)
            .some((line) => filePath.includes(line));
        };

        return {
          ignores: ignored,
        };
      },
    };
  }

  isIgnored(filePath: string, gitignores: any[]): boolean {
    for (const { path: gitignorePath, ig } of gitignores) {
      if (filePath.startsWith(gitignorePath)) {
        const relativePath = path.relative(gitignorePath, filePath);
        if (ig.ignores(relativePath)) {
          return true;
        }
      }
    }
    return false;
  }
}
</file>

<file path="The-Creator-AI-main/src/backend/services/git.service.ts">
import * as child_process from "child_process";
import * as vscode from "vscode";
import { Injectable } from "injection-js";

@Injectable()
export class GitService {
    /**
     * Commits changes to the Git repository with the provided message.
     *
     * @param commitMessage - The commit message to use.
     * @param commitDescription - (Optional) A commit description to include.
     * @returns The Git commit output as a string, or an empty string if an error occurs.
     */
    gitCommit = (
        commitMessage: string,
        commitDescription?: string
    ): string => {
        try {
            // 1. Construct the commit command
            let commitCommand = `git commit -m "${commitMessage}"`;

            // 2. (Optional) Include description if provided
            if (commitDescription?.trim()) {
                commitCommand += ` -m "${commitDescription}"`;
            }

            // 3. Execute the commit command
            // current working directory
            const commitOutput = child_process.execSync(commitCommand, {
                cwd: vscode.workspace.rootPath,
            });

            // 4. Handle the commit result
            console.log("Commit successful:", commitOutput.toString());
            return commitOutput.toString();
        } catch (error) {
            console.error("Error during commit:", error);
            return "";
        }
    };
}
</file>

<file path="The-Creator-AI-main/src/backend/services/llm.service.ts">
import {
  GoogleGenerativeAI,
  HarmBlockThreshold,
  HarmCategory,
} from "@google/generative-ai";
import * as openai from "openai";
import * as vscode from "vscode";
import { ChatMessage } from "../repositories/chat.respository";
import { Inject, Injectable } from "injection-js";
import { SettingsRepository } from "../repositories/settings.repository";
import { LlmServiceEnum } from "../types/llm-service.enum";
import { PersistentStoreRepository } from "../repositories/persistent-store.repository";
import { ChangePlan } from "@/client/views/change-plan.view/store/change-plan-view.state-type";
import { StorageKeysEnum } from "../types/storage-keys.enum";
import { FSService } from "./fs.service";

@Injectable()
export class LlmService {
  private geminiProModel: string = "gemini-1.5-pro-exp-0827";
  private geminiFlashModel: string = "gemini-1.5-flash-latest";
  private geminiFlash2Model: string = "models/gemini-2.0-flash-exp";
  private openaiModel: string = "gpt-3.5-turbo";
  private currentModel: string = this.geminiFlash2Model; 

  constructor(
    @Inject(FSService) private readonly fsService: FSService,
    @Inject(SettingsRepository)
    private readonly settingsRepository: SettingsRepository,
    @Inject(PersistentStoreRepository)
    private readonly persistentStoreRepository: PersistentStoreRepository
  ) {}

  async sendPrompt(
    chatHistory: ChatMessage[],
    selectedFiles: string[] = [],
    onChunk?: (chunk: string, modelType: string, modelName: string) => void
  ): Promise<{ response: string; modelType: string; modelName: string }> {
    const { type, apiKeys } = await this.getApiKey();
    console.log({ type, apiKeys, chatHistory, selectedFiles });

    // Fetch past change plans
    const pastChangePlans = await this.getPastChangePlans();

    // Read selected files content
    const fileContents =
      this.fsService.readSelectedFilesContent(selectedFiles);

    // Append file contents to prompt
    let prompt = "";
    for (const filePath in fileContents) {
      prompt += `\n\n\`\`\`
File: ${filePath}
${fileContents[filePath]}
\`\`\`\n\n`;
    }

    // Append past change plans to prompt
    if (pastChangePlans?.length) {
      prompt += `\n\nPast Change Plans:\n\`\`\`json\n${JSON.stringify(
        pastChangePlans.map(({ planTitle, planDescription, planJson }) => ({ planTitle, planDescription, planJson })),
        null,
        2
      )}\n\`\`\`\n\n`;
    }

    chatHistory.forEach((message) => {
      prompt += `${message.user}: ${message.message}\n`;
    });

    console.log(`Prompt:\n\n\n`);
    console.log(prompt);

    if (type === "gemini") {
      return this.sendPromptToGemini(prompt, apiKeys, onChunk);
    } else if (type === "openai") {
      return this.sendPromptToOpenAI(prompt, apiKeys[0], onChunk); // Assuming only one OpenAI key is stored
    } else {
      throw new Error(
        "No API key found. Please set either GEMINI_API_KEY or OPENAI_API_KEY environment variable."
      );
    }
  }

  private async sendPromptToGemini(
    prompt: string,
    apiKeys: string[],
    onChunk?: (chunk: string, modelType: string, modelName: string) => void
  ): Promise<{ response: string; modelType: string; modelName: string }> {
    let debounce = 0;
    let attempts = 0;
    let responseText = "";
    let currentKeyIndex = 0; // Track the current key being used

    while (attempts < 3) {
      attempts++;
      if (debounce > 0) {
        console.log(`Waiting for ${Math.floor(debounce / 1000)} seconds...`);
      }
      console.log(`Using model: ${this.currentModel}`);
      await new Promise((resolve) => setTimeout(resolve, debounce));
      try {
        const genAI = new GoogleGenerativeAI(apiKeys[currentKeyIndex]);
        const gemini = genAI.getGenerativeModel({
          model: this.currentModel,
        }); // Use currentModel here
        const response = await gemini.generateContentStream({
          contents: [
            {
              role: "user",
              parts: [{ text: prompt }],
            },
          ],
          generationConfig: {
            responseMimeType: "text/plain",
          },
          safetySettings: [
            {
              category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,
              threshold: HarmBlockThreshold.BLOCK_NONE,
            },
          ],
        });

        for await (const chunk of response.stream) {
          responseText += chunk.text();
          // console.log(chunk.text());
          if (onChunk) {
            onChunk(chunk.text(), "gemini", this.currentModel);
          }
        }
        debounce = 0;
        return {
          response: responseText,
          modelType: "gemini",
          modelName: this.currentModel,
        };
      } catch (e: any) {
        debounce += 5000;
        // Handle specific errors based on error type and status
        if (e.status === 429) {
          if (currentKeyIndex < apiKeys.length - 1) {
            // Pro model rate limit reached, try with the next key
            currentKeyIndex++;
            console.log(
              `${this.currentModel} limit reached for key ${
                apiKeys[currentKeyIndex - 1]
              }, trying with key ${apiKeys[currentKeyIndex]} `
            );
            continue; // Retry with the next key
          }
        } else {
          // For other errors, log the error and potentially throw or handle differently
          console.error(`Error during LLM request (attempt ${attempts}):`, e);
          // You might want to throw the error here or handle it differently based on your needs
          // throw new Error("Could not get a response from Gemini after multiple attempts.");
        }
      }
    }
    // If all attempts fail, throw an error
    throw new Error(
      "Could not get a response from Gemini after multiple attempts."
    );
  }

  getModelName(): string {
    return this.currentModel;
  }

  private async sendPromptToOpenAI(
    prompt: string,
    apiKey: string,
    onChunk?: (chunk: string, modelType: string, modelName: string) => void
  ): Promise<{ response: string; modelType: string; modelName: string }> {
    const model = new openai.OpenAI({ apiKey });

    this.currentModel = this.openaiModel;
    const response = await model.completions.create({
      model: this.openaiModel,
      prompt: prompt,
      stream: true,
    });

    let responseText = "";
    for await (const part of response) {
      const chunk = part.choices[0]?.text || "";
      responseText += chunk;
      if (onChunk) {
        onChunk(chunk, "openai", this.openaiModel);
      }
    }

    return {
      response: responseText,
      modelType: "openai",
      modelName: this.openaiModel,
    };
  }

  private async getApiKey(): Promise<any> {
    const apiKeys = await this.settingsRepository.getLLMApiKeys();
    if (!apiKeys) {
      throw new Error("API Keys not found!");
    }

    const type = Object.keys(apiKeys)[0] as LlmServiceEnum;

    if (type && Array.isArray(apiKeys[type])) {
      return { type, apiKeys: apiKeys[type] };
    } else {
      await this.getApiKeyFromUser();
      return await this.getApiKey();
    }
  }

  private async getPastChangePlans(): Promise<ChangePlan[] | undefined> {
    try {
      return this.persistentStoreRepository.getChangePlanViewState()
        ?.changePlans;
    } catch (error) {
      console.error("Error retrieving past change plans:", error);
      return undefined;
    }
  }

  private async setLLMApiKey(
    service: LlmServiceEnum,
    apiKey: string
  ): Promise<void> {
    await this.settingsRepository.setLLMApiKey(service, apiKey);
  }

  private async deleteLLMApiKey(
    service: LlmServiceEnum,
    apiKeyToDelete: string
  ): Promise<void> {
    await this.settingsRepository.deleteLLMApiKey(service, apiKeyToDelete);
  }

  private async getApiKeyFromUser(): Promise<any> {
    const apiChoice = await vscode.window.showQuickPick(
      [
        { label: "Gemini API Key", value: "gemini" },
        { label: "OpenAI API Key", value: "openai" },
      ],
      { placeHolder: "Select the API you want to use" }
    );

    if (apiChoice) {
      const apiKeyInput = await vscode.window.showInputBox({
        prompt: `Enter your ${apiChoice.label}`,
        placeHolder:
          apiChoice.value === "gemini"
            ? "Enter Gemini API Key"
            : "Enter OpenAI API Key",
        password: true, // Mask the input for security
      });
      console.log({ apiKeyInput, apiChoice });
      if (apiKeyInput) {
        await this.setLLMApiKey(apiChoice.value as LlmServiceEnum, apiKeyInput);
      }
    }
  }
}
</file>

<file path="The-Creator-AI-main/src/backend/services/logger.service.ts">
import * as fs from "fs";
import * as path from "path";
import { Injectable } from "injection-js";

@Injectable()
export class LoggerService {
  private logFilePath: string;

  constructor() {
    // Default log file path, you might want to make this configurable
    this.logFilePath = path.join(
      __dirname,
      "..",
      "..",
      "..",
      "logs",
      "extension.log"
    );
    // Ensure the logs directory exists
    const logDir = path.dirname(this.logFilePath);
    if (!fs.existsSync(logDir)) {
      fs.mkdirSync(logDir, { recursive: true });
    }
  }

  private _log(level: string, message: string, ...args: any[]): void {
    const timestamp = new Date().toISOString();
    const logMessage = `[${timestamp}] [${level.toUpperCase()}] ${message} ${
      args.length > 0 ? JSON.stringify(args) : ""
    }\n`;

    fs.appendFile(this.logFilePath, logMessage, (err) => {
      if (err) {
        console.error("Failed to write to log file:", err);
      }
    });
  }

  log(message: string, ...args: any[]): void {
    this._log("log", message, ...args);
  }

  info(message: string, ...args: any[]): void {
    this._log("info", message, ...args);
  }

  warn(message: string, ...args: any[]): void {
    this._log("warn", message, ...args);
  }

  error(message: string, ...args: any[]): void {
    this._log("error", message, ...args);
  }
}
</file>

<file path="The-Creator-AI-main/src/backend/services/message.service.ts">
import { Injectable } from "injection-js";
import { ServerPostMessageManager } from "@/common/ipc/server-ipc";
import { mergeOpenEditorsWithSelectedFiles } from "@/backend/utils/mergeOpenEditorsWithSelectedFiles";
import { Services } from "./services";
import { ServerToClientChannel } from "@/common/ipc/channels.enum";

@Injectable()
export class MessageService {

  async sendMessage(
    serverIpc: ServerPostMessageManager,
    data: {
      chatHistory: any[];
      selectedFiles: string[];
    }
  ) {
    const { chatHistory, selectedFiles } = data;

    const updatedSelectedFiles = mergeOpenEditorsWithSelectedFiles(selectedFiles);

    const response = await Services.getLlmService().sendPrompt(
      chatHistory,
      updatedSelectedFiles
    );

    serverIpc.sendToClient(ServerToClientChannel.SendMessage, {
      message: response.response,
    });
  }

  async streamMessage(
    serverIpc: ServerPostMessageManager,
    data: {
      chatHistory: any[];
      selectedFiles: string[];
    }
  ) {
    try {
      const { chatHistory, selectedFiles } = data;

      const updatedSelectedFiles =
        mergeOpenEditorsWithSelectedFiles(selectedFiles);

      const response = await Services.getLlmService().sendPrompt(
        chatHistory,
        updatedSelectedFiles,
        (chunk: string) => {
          serverIpc.sendToClient(ServerToClientChannel.StreamMessage, { chunk });
        }
      );
        serverIpc.sendToClient(ServerToClientChannel.SendMessage, {
            message: response.response,
          });
    } catch (error: any) {
      serverIpc.sendToClient(ServerToClientChannel.SendMessage, error.message);
    }
  }
}
</file>

<file path="The-Creator-AI-main/src/backend/services/plan-exim.service.ts">
import { Injectable } from 'injection-js';
import * as vscode from 'vscode';
import { Services } from './services';
import { ChangePlan } from '@/client/views/change-plan.view/store/change-plan-view.state-type';
import { initialState } from '@/client/views/change-plan.view/store/change-plan-view.initial-state';

@Injectable()
export class PlanExImService {
    async exportAllChangePlans(): Promise<void> {
        const persistentStoreRepository = Services.getPersistentStoreRepository();
        const store = persistentStoreRepository.getChangePlanViewState();
        const changePlans = store?.changePlans || [];

        const jsonString = JSON.stringify(changePlans, null, 2);
        Services.getLoggerService().log(jsonString);

        // Get the workspace folder name
        const workspaceFolders = vscode.workspace.workspaceFolders;
        const workspaceFolderName = workspaceFolders && workspaceFolders.length > 0
            ? workspaceFolders[0].name
            : 'default'; // Provide a default if no workspace is open

        const options: vscode.SaveDialogOptions = {
            defaultUri: vscode.Uri.file(`all_change_plans_${workspaceFolderName}.json`),
            filters: {
                'JSON': ['json']
            }
        };

        const fileUri = await vscode.window.showSaveDialog(options);

        if (fileUri) {
            try {
                await vscode.workspace.fs.writeFile(fileUri, Buffer.from(jsonString, 'utf-8'));
                vscode.window.showInformationMessage(`All change plans exported successfully.`);
            } catch (error) {
                vscode.window.showErrorMessage(`Failed to export change plans: ${error}`);
            }
        }
    }

    async importAllChangePlans(): Promise<void> {
        const options: vscode.OpenDialogOptions = {
            canSelectMany: false,
            openLabel: 'Import',
            filters: {
                'JSON': ['json']
            }
        };

        const fileUri = await vscode.window.showOpenDialog(options);

        if (fileUri && fileUri[0]) {
            try {
                const fileContent = await vscode.workspace.fs.readFile(fileUri[0]);
                const plansJson: ChangePlan[] = JSON.parse(Buffer.from(fileContent).toString('utf-8'));

                console.log({ fileContent, plansJson });

                if (!Array.isArray(plansJson)) {
                    vscode.window.showErrorMessage('Invalid change plans format. Expected an array of plans.');
                    return;
                }

                const persistentStoreRepository =
                    Services.getPersistentStoreRepository();
                const store = persistentStoreRepository.getChangePlanViewState();
                const currentPlans = store?.changePlans || [];
                const updatedPlans = [...currentPlans];

                for (const plan of plansJson) {
                    if (!this.isValidChangePlan(plan)) {
                        vscode.window.showWarningMessage(`Skipping invalid change plan: ${(plan as ChangePlan).planTitle}`);
                        continue;
                    }

                    const existingPlanIndex = currentPlans.findIndex(
                        p => p.planTitle === plan.planTitle && p.planDescription === plan.planDescription
                    );

                    if (existingPlanIndex !== -1) {
                        // Update existing plan
                        updatedPlans[existingPlanIndex] = plan;
                    } else {
                        // Add new plan
                        updatedPlans.push(plan);
                    }
                }

                persistentStoreRepository.setChangePlanViewState({
                    ...initialState,
                    changePlans: updatedPlans,
                });
                vscode.window.showInformationMessage(`Change plans imported successfully.`);
            } catch (error) {
                vscode.window.showErrorMessage(`Failed to import change plans: ${error}`);
            }
        }
    }

    private isValidChangePlan(plan: any): plan is ChangePlan {
        return (
            typeof plan === 'object' &&
            plan !== null &&
            typeof plan.planTitle === 'string' &&
            typeof plan.planDescription === 'string' &&
            typeof plan.llmResponse === 'string' &&
            typeof plan.planJson === 'object' &&
            Array.isArray(plan.chatHistory) &&
            Array.isArray(plan.selectedFiles)
        );
    }
}
</file>

<file path="The-Creator-AI-main/src/backend/services/services.ts">
import { ReflectiveInjector } from "injection-js";
import "reflect-metadata";
import { FSService } from "./fs.service";
import { LlmService } from "./llm.service";
import { SettingsRepository } from "../repositories/settings.repository";
import { ChatRepository } from "../repositories/chat.respository";
import { PersistentStoreRepository } from "../repositories/persistent-store.repository";
import { LoggerService } from "./logger.service";
import { PlanExImService } from "./plan-exim.service";
import { CodeService } from "./code.service";
import { GitService } from "./git.service";
import { MessageService } from "./message.service";

export class Services {
  static injector: ReflectiveInjector;

  static async initialize(): Promise<void> {
    Services.injector = ReflectiveInjector.resolveAndCreate([
      ChatRepository,
      SettingsRepository,
      PersistentStoreRepository,
      FSService,
      LlmService,
      PlanExImService,
      LoggerService,
      CodeService,
      GitService,
      MessageService,
    ]);
  }

  static getFSService(): FSService {
    return Services.injector.get(FSService);
  }

  static getLlmService(): LlmService {
    return Services.injector.get(LlmService);
  }

  static getPersistentStoreRepository(): PersistentStoreRepository {
    return Services.injector.get(PersistentStoreRepository);
  }

  static getSettingsRepository(): SettingsRepository {
    return Services.injector.get(SettingsRepository);
  }

  static getPlanExImService(): PlanExImService {
    return Services.injector.get(PlanExImService);
  }

   static getCodeService(): CodeService {
    return Services.injector.get(CodeService);
  }

  static getLoggerService(): LoggerService {
    return Services.injector.get(LoggerService);
  }

   static getGitService(): GitService {
    return Services.injector.get(GitService);
  }

    static getMessageService(): MessageService {
    return Services.injector.get(MessageService);
  }
}
</file>

<file path="The-Creator-AI-main/src/backend/services/task-queue.service.ts">
import { Injectable } from "injection-js";
import { randomUUID } from "crypto";

interface Task<TaskType> {
  task: any;
  taskType: TaskType;
}

type Subscriber = {
  id: string;
  callback: (task: any) => Promise<any>;
};

@Injectable()
export class TaskQueueService<TaskType extends string> {
  private taskQueues: Record<TaskType, Task<any>[]> = {} as Record<
    TaskType,
    Task<any>[]
  >;
  private subscribers: Record<
    TaskType,
    Record<string, Subscriber>
  > = {} as Record<TaskType, Record<string, Subscriber>>;
  private isProcessing: Record<TaskType, boolean> = {} as Record<
    TaskType,
    boolean
  >;
  private responses: Record<
    TaskType,
    Record<string, any[]>
  > = {} as Record<TaskType, Record<string, any[]>>;
  private errors: Record<TaskType, Record<string, any[]>> =
    {} as Record<TaskType, Record<string, any[]>>;

  /**
   * Publishes a task to the queue.
   * @param taskType The type of the task
   * @param task The task to be added to the queue
   */
  publishTask(taskType: TaskType, task: any): void {
    if (!this.taskQueues[taskType]) {
      this.taskQueues[taskType] = [];
    }
    this.taskQueues[taskType].push({ task, taskType });
    if (!this.isProcessing[taskType]) {
      this.isProcessing[taskType] = false;
      this.processTasks(taskType);
    }
  }

  /**
   * Subscribes a callback to process tasks.
   * @param taskType The type of the task
   * @param subscriber A callback function that processes a task and returns a value.
   */
  async subscribe(
    taskType: TaskType,
    subscriber: (task: any) => Promise<any>
  ): Promise<string> {
    const subscriberId = randomUUID();
    if (!this.subscribers[taskType]) {
      this.subscribers[taskType] = {};
    }
    this.subscribers[taskType as string][subscriberId] = {
      id: subscriberId,
      callback: subscriber,
    };
    if (!this.isProcessing[taskType]) {
      this.isProcessing[taskType] = false;
      this.processTasks(taskType);
    }
    return subscriberId;
  }

  /**
   * Processes the tasks in the queue using the registered subscribers.
   * It processes each task sequentially, passing it to all the subscribers and stores the responses.
   */
  private async processTasks(taskType: TaskType): Promise<void> {
    if (this.isProcessing[taskType]) {
      return;
    }

    this.isProcessing[taskType] = true;
    while (this.taskQueues[taskType]?.length > 0) {
      const currentTask = this.taskQueues[taskType].shift();
      if (currentTask) {
        for (const subscriberId in this.subscribers[taskType]) {
          const subscriber = this.subscribers[taskType][subscriberId];
          try {
            const response = await subscriber.callback(currentTask.task);
            if (!this.responses[taskType]) {
              this.responses[taskType] = {};
            }
            if (!this.responses[taskType][subscriber.id]) {
              this.responses[taskType as string][subscriber.id] = [];
            }
            this.responses[taskType][subscriber.id].push({
              ...currentTask.taskType,
              response,
            });
          } catch (error: any) {
            if (!this.errors[taskType]) {
              this.errors[taskType] = {};
            }
            if (!this.errors[taskType][subscriber.id]) {
              this.errors[taskType as string][subscriber.id] = [];
            }
            this.errors[taskType][subscriber.id].push({
              ...currentTask.taskType,
              error,
            });
            console.error("Error while processing a task", error);
          }
        }
      }
    }
    this.isProcessing[taskType] = false;
  }

  getResponses(taskType: TaskType, subscriberId: string): any[] {
    return this.responses[taskType]?.[subscriberId] || [];
  }

  getErrors(taskType: TaskType, subscriberId: string): any[] {
    return this.errors[taskType]?.[subscriberId] || [];
  }
}
</file>

<file path="The-Creator-AI-main/src/backend/types/llm-service.enum.ts">
export enum LlmServiceEnum {
  GEMINI = "gemini",
  OPENAI = "openai",
  CLAUDE = "claude",
}
</file>

<file path="The-Creator-AI-main/src/backend/types/storage-keys.enum.ts">
export enum StorageKeysEnum {
  LlmApiKeys = "creatorExtension:llmApiKeys",
  ChatRepository = "creatorExtension:chatRepository",
  ChangePlanViewState = "creatorExtension:store:changePlanViewState",
}
</file>

<file path="The-Creator-AI-main/src/backend/utils/handleActiveTabChange.ts">
import * as vscode from "vscode";
import { ServerPostMessageManager } from "@/common/ipc/server-ipc";
import { remoteSetChangePlanViewState } from "./remoteSetChangePlanViewState";

/**
 * Handles active tab changes in VS Code and sends the active file path to the server.
 *
 * @param serverIpc - The server IPC instance used to send messages to the server.
 */
export const handleActiveTabChange = (serverIpc: ServerPostMessageManager) => {
  remoteSetChangePlanViewState(
    serverIpc,
    "activeTab",
    vscode.window.activeTextEditor?.document.fileName
  );
  vscode.window.onDidChangeActiveTextEditor((editor) => {
    if (editor) {
      remoteSetChangePlanViewState(
        serverIpc,
        "activeTab",
        editor.document.fileName
      );
    }
  });
};
</file>

<file path="The-Creator-AI-main/src/backend/utils/mergeOpenEditorsWithSelectedFiles.ts">
import * as vscode from "vscode";

/**
 * Merges the paths of open editors with the provided selected files,
 * ensuring no duplicates and prioritizing open editor paths.
 *
 * @param selectedFiles Array of initially selected file paths.
 * @returns Array of file paths including open editor paths.
 */
export function mergeOpenEditorsWithSelectedFiles(
  selectedFiles: string[]
): string[] {
  const openEditors = vscode.window.tabGroups.all
    .flatMap((group) => group.tabs)
    .map((tab) =>
      tab.input instanceof vscode.TabInputText ||
      tab.input instanceof vscode.TabInputNotebook
        ? tab.input.uri?.fsPath || ""
        : ""
    );

  return openEditors.reduce((acc: string[], tabPath) => {
    const selectedAncestorPath = selectedFiles.find(
      (f) => tabPath.startsWith(f) && f !== tabPath
    );
    if (selectedAncestorPath) {
      return acc;
    } else {
      return [...acc, tabPath];
    }
  }, selectedFiles);
}
</file>

<file path="The-Creator-AI-main/src/backend/utils/remoteSetChangePlanViewState.ts">
import * as vscode from "vscode";
import { ServerToClientChannel } from "@/common/ipc/channels.enum";
import { ServerPostMessageManager } from "@/common/ipc/server-ipc";
import { KeyPaths, KeyPathValue } from "@/common/utils/key-path";
import { ChangePlanViewStore } from "../../client/views/change-plan.view/store/change-plan-view.state-type";

/**
 * Handles active tab changes in VS Code and sends the active file path to the server.
 *
 * @param serverIpc - The server IPC instance used to send messages to the server.
 * @param keyPath - The key path to set in the change plan view store.
 * @param value - The value to set at the key path in the change plan view store.
 */
export const remoteSetChangePlanViewState = <
  Key extends KeyPaths<ChangePlanViewStore>
>(
  serverIpc: ServerPostMessageManager,
  keyPath: Key,
  value: KeyPathValue<Key, ChangePlanViewStore>
) => {
  serverIpc.sendToClient(ServerToClientChannel.SetChangePlanViewState, {
    keyPath,
    value,
  });
};
</file>

<file path="The-Creator-AI-main/src/client/components/AutoResizingTextarea.tsx">
import React, { useEffect, useRef, forwardRef, useImperativeHandle } from 'react';

interface AutoResizingTextareaProps extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {
    placeholder?: string;
    value: string;
    onChange: (event: React.ChangeEvent<HTMLTextAreaElement>) => void;
    minRows?: number;
    maxRows?: number;
}

const AutoResizingTextarea = forwardRef<HTMLTextAreaElement, AutoResizingTextareaProps>(
    ({ placeholder, value, onChange, minRows = 1, maxRows = Infinity, ...rest }, ref) => {
        const textareaRef = useRef<HTMLTextAreaElement>(null);

        useImperativeHandle(ref, () => textareaRef.current!, []);

        useEffect(() => {
            if (textareaRef.current) {
                textareaRef.current.style.height = '0px'; // Reset height to calculate scrollHeight
                const scrollHeight = textareaRef.current.scrollHeight;

                // Calculate min and max height based on minRows and maxRows
                const lineHeight = parseInt(getComputedStyle(textareaRef.current).lineHeight, 10) || 20; // Fallback to 20px if lineHeight is not found
                const minHeight = minRows * lineHeight;
                const maxHeight = maxRows * lineHeight;

                // Apply height constraints
                const height = Math.max(minHeight, Math.min(scrollHeight, maxHeight));
                textareaRef.current.style.height = height + 'px';
            }
        }, [value, minRows, maxRows]);

        return (
            <textarea
                ref={textareaRef}
                placeholder={placeholder}
                value={value}
                onChange={onChange}
                style={{ background: 'inherit' }}
                className={"resize-none overflow-hidden box-border bg-inherit" + (rest.className ? ` ${rest.className}` : '')}
                {...rest}
            />
        );
    }
);

AutoResizingTextarea.displayName = 'AutoResizingTextarea';

export default AutoResizingTextarea;
</file>

<file path="The-Creator-AI-main/src/client/components/Checkbox.tsx">
import React from "react";
import { useEffect, useRef } from "react";

interface CheckboxProps extends Omit<React.DetailedHTMLProps<React.InputHTMLAttributes<HTMLInputElement>, HTMLInputElement>, 'onChange'> {
    checked: boolean;
    indeterminate?: boolean;
    onChange: (checked: boolean, event: React.ChangeEvent<HTMLInputElement>) => void;
}

const Checkbox = (props: CheckboxProps) => {
    const { checked, onChange, indeterminate, ...rest } = props;
    const cRef = useRef<any>(null);

    useEffect(() => {
        if (cRef.current) {
            cRef.current.indeterminate = indeterminate;
        }
    }, [cRef, indeterminate]);

    return (
        <input type="checkbox" ref={cRef} checked={checked} onChange={(e) => onChange(e.target.checked, e)} {...rest} />
    );
};

export default Checkbox;
</file>

<file path="The-Creator-AI-main/src/client/components/ErrorBoundary.tsx">
import React, { Component, ErrorInfo, ReactNode } from 'react';

interface Props {
    children: ReactNode;
    fallback?: ReactNode;
}

interface State {
    hasError: boolean;
    error: Error | null;
    errorInfo: ErrorInfo | null;
}

class ErrorBoundary extends Component<Props, State> {
    constructor(props: Props) {
        super(props);
        this.state = { hasError: false, error: null, errorInfo: null };
    }

    componentDidCatch(error: Error, errorInfo: ErrorInfo) {
        // Log the error to an error tracking service (optional)
        console.error('ErrorBoundary caught an error:', error, errorInfo);
        // You can integrate with an error tracking service here, e.g., Sentry, Rollbar

        this.setState({ hasError: true, error, errorInfo });
    }

    render() {
        if (this.state.hasError) {
            return this.props.fallback || (
                <div>
                    <h2>Something went wrong.</h2>
                    <p>{this.state.error?.message}</p>
                    {/* You can display more detailed error information here if needed */}
                </div>
            );
        }

        return this.props.children;
    }
}

export default ErrorBoundary;
</file>

<file path="The-Creator-AI-main/src/client/components/file-tree/FileTree.scss">
/* Import Tailwind directives */
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Remove default VS Code body padding */
body {
  padding: 0;
}
</file>

<file path="The-Creator-AI-main/src/client/components/file-tree/FileTree.tsx">
import React, { useEffect, useState } from 'react';
import { MdChevronRight } from 'react-icons/md';
import TreeView from '../tree-view/TreeView'; // Import the generic TreeView
import { FileNode } from '../../../common/types/file-node';
import { getFileNodeByPath, addRemovePathInSelectedFiles } from './FileTree.utils';
import Checkbox from '../Checkbox';


interface FileTreeProps {
  data: FileNode[];
  onFileClick?: (filePath: string) => void;
  selectedFiles: string[];
  recentFiles: string[];
  activeFile?: string;
  updateSelectedFiles: (selectedFiles: string[]) => void;
  updateRecentFiles: (recentFiles: string[]) => void;
}

const FileTree: React.FC<FileTreeProps> = ({
  data,
  onFileClick,
  selectedFiles,
  recentFiles,
  activeFile,
  updateSelectedFiles,
  updateRecentFiles
}) => {

  const rootNode = data.find((node) => !node.name.includes('/'));

  // State to manage expanded nodes
  const [expandedNodes, setExpandedNodes] = useState<string[]>([rootNode?.name || '']);


  useEffect(() => {
    // If selectedFiles changes, expand the corresponding nodes
    const toExpand = new Set<string>();
    selectedFiles?.forEach((selectedFile) => {
      const pathParts = selectedFile.split('/');
      // Starting from the root, expand each directory in the path
      let currentPath = '';
      pathParts.forEach((part, index) => {
        currentPath += `${currentPath ? '/' : ''}${part}`;
        const node = getFileNodeByPath(data, currentPath);
        const isLast = index === pathParts.length - 1;
        if (node && !isLast) {
          toExpand.add(currentPath);
        }
      });
    });

    setExpandedNodes(prevExpandedNodes => {
      const newExpandedNodes = [...prevExpandedNodes].filter(path => !toExpand.has(path));
      return [...newExpandedNodes, ...Array.from(toExpand)];
    });
  }, [selectedFiles, data]);


  const handleNodeClick = (e: React.MouseEvent<HTMLElement, MouseEvent>, node: FileNode, path: string) => {
    if ((e.target as HTMLElement)?.classList?.contains('checkbox')) {
      return;
    }
    const isDirectory = Array.isArray(node.children);
    if (isDirectory) {
      setExpandedNodes((prevExpandedNodes) => {
        const isExpanded = !!prevExpandedNodes.find((n) => n === path);
        return isExpanded
          ? prevExpandedNodes.filter((n) => n !== path)
          : [...prevExpandedNodes, path];
      });
    } else {
      onFileClick && onFileClick(path);
      const existingRecentFiles = recentFiles.filter(f => f !== path);
      updateRecentFiles([path, ...existingRecentFiles || []]);
    }
  };

  const renderCheckbox = (path: string) => {
    const isSelected = !!selectedFiles?.find(f => f === path);
    const isPartiallySelected = selectedFiles?.filter(f => f.includes(path) && f !== path);
    const selectedAncestors = selectedFiles?.filter(f => path.startsWith(f) && f !== path);
    return (
      <Checkbox
        data-testid="checkbox"
        indeterminate={isPartiallySelected?.length > 0}
        className="mr-2"
        checked={isSelected || !!selectedAncestors?.length}
        onChange={(_, e) => handleFileCheckboxChange(e, path)}
      />
    );
  };

  const handleFileCheckboxChange = (e: React.ChangeEvent<HTMLInputElement>, path: string) => {
    e.stopPropagation();
    e.preventDefault();
    updateSelectedFiles(addRemovePathInSelectedFiles(data, path, selectedFiles));
  };

  const renderFileNodeContent = (node: FileNode, path: string) => {
    const isDirectory = Array.isArray(node.children);
    const isActive = activeFile === path;

    return (
      <div
        className={`
          relative 
          cursor-pointer 
          px-2 py-px
          flex 
          items-center
          z-1
          ${isActive ? 'bg-[#e0dcdc]' : ''}
          ${isDirectory ? 'font-medium' : 'font-normal'}
        `}
      >
        {renderCheckbox(path)}
        <div className="whitespace-nowrap overflow-hidden text-ellipsis">{node.name}</div>
      </div>
    );
  };

  return (
    <div data-testid="file-tree" className="font-sans">
      <TreeView 
        data={data} 
        onNodeClick={(node) => {
          const path = node.absolutePath || '';
          handleNodeClick(undefined as any, node, path);
        }}
        renderNodeContent={(node) => renderFileNodeContent(node, node.absolutePath || '')} 
      />
    </div>
  );
};

export default FileTree;
</file>

<file path="The-Creator-AI-main/src/client/components/file-tree/FileTree.utils.ts">
import { FileNode } from "@/common/types/file-node";

export const addRemovePathInSelectedFiles = (
  files: FileNode[],
  path: string,
  selectedFiles: string[]
): string[] => {
  const isSelected = !!selectedFiles?.find((f) => f === path);
  if (isSelected) {
    // Remove this file from selectedFiles
    return selectedFiles?.filter((f) => f !== path);
  }

  const selectedAncestorPath = selectedFiles.find(
    (f) => path.startsWith(f) && f !== path
  );
  if (selectedAncestorPath) {
    // 1. Remove the ancestor from selectedFiles
    // 2. Add all children of the ancestor to selectedFiles except node which is another ancestor of the selected node
    // 3. Add all the siblings of the all the nodes between the ancestor and the selected node
    const pathParts = path.split("/");
    const ancestorParts = selectedAncestorPath.split("/");
    let siblingsAtEveryLevel: string[] = [];
    for (let i = ancestorParts.length - 1; i < pathParts.length - 1; i++) {
      const filePath = pathParts.slice(0, i + 1).join("/");
      const levelNode = getFileNodeByPath(files, filePath);
      if (levelNode) {
        siblingsAtEveryLevel = [
          ...siblingsAtEveryLevel,
          ...(levelNode.children
            ?.filter((c) => c.name !== pathParts[i + 1])
            ?.map((c) => `${filePath}/${c.name}`) || []),
        ];
      }
    }
    const newSelectedFiles = [
      ...selectedFiles.filter((f) => !f.includes(selectedAncestorPath)),
      ...siblingsAtEveryLevel,
    ];
    return newSelectedFiles;
  }

  // Remove all children and push this file into selectedFiles
  const newSelectedFiles = isSelected
    ? selectedFiles?.filter((f) => f !== path)
    : [...selectedFiles.filter((f) => !f.includes(path)), path];
  return newSelectedFiles;
};

export const getFileNodeByPath = (
  fileNodes: FileNode[],
  filePath: string
): FileNode | null => {
  const pathParts = filePath.split("/");
  // let's find the node in the data
  let node = {
    name: "",
    children: fileNodes,
  } as FileNode | undefined;
  for (const part of pathParts) {
    if (!node) {
      return null;
    }
    node = node.children?.find((child) => child.name === part);
  }
  return node || null;
};
</file>

<file path="The-Creator-AI-main/src/client/components/Modal.tsx">
import React, { useEffect, useRef, useState } from "react";

interface ModalProps {
  isOpen: boolean;
  onClose: () => void;
  children: React.ReactNode;
}

const Modal: React.FC<ModalProps> = ({ isOpen, onClose, children }) => {
  const modalRef = useRef<HTMLDivElement>(null);
  const [isClosing, setIsClosing] = useState(false);

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        modalRef.current &&
        !modalRef.current.contains(event.target as Node) &&
        isOpen
      ) {
        setIsClosing(true);
      }
    };

    // Add event listeners when the modal is open
    if (isOpen) {
      document.addEventListener("mousedown", handleClickOutside);
    }

    return () => {
      // Clean up the event listener when the modal closes
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [isOpen]);

  // Close the modal after the closing animation finishes
  useEffect(() => {
    if (isClosing) {
      const timer = setTimeout(() => {
        onClose();
        setIsClosing(false);
      }, 200); // Adjust the timeout to match the animation duration

      return () => clearTimeout(timer);
    }
  }, [isClosing, onClose]);

  // VS Code's default modal has a dark background with a slightly transparent white overlay
  return isOpen ? (
    <div
      className={`fixed inset-0 z-50 transition-opacity duration-200 ${isClosing ? "opacity-0" : "opacity-100"
        }`}
    >
      <div className="fixed inset-0 bg-black bg-opacity-75"></div>
      <div
        ref={modalRef}
        className={`fixed inset-0 flex items-center justify-center p-4 transition-all duration-200 ${isClosing ? "opacity-0 scale-95" : "opacity-100 scale-100"
          }`}
      >
        <div
          className="bg-white rounded-md shadow-lg p-6 relative overflow-y-auto max-h-[90vh]"
          style={{ maxWidth: "700px" }}
        >
          {/* Close button */}
          <button
            className="absolute top-4 right-4 text-gray-500 hover:text-gray-700"
            onClick={onClose}
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              fill="none"
              viewBox="0 0 24 24"
              strokeWidth={1.5}
              stroke="currentColor"
              className="w-6 h-6"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                d="M6 18L18 6M6 6l12 12"
              />
            </svg>
          </button>
          {/* Modal content */}
          {children}
        </div>
      </div>
    </div>
  ) : null;
};

export default Modal;
</file>

<file path="The-Creator-AI-main/src/client/components/ProgressSteps.tsx">
import * as React from "react";

export interface StepsConfig {
  [key: string]: {
    indicatorText: string;
    renderStep: () => JSX.Element;
  };
};

interface ProgressStepsProps {
  currentStep: string;
  handleStepClick: (step: string) => void;
  stepsConfig: StepsConfig;
}

const ProgressSteps: React.FC<ProgressStepsProps> = ({
  currentStep,
  handleStepClick,
  stepsConfig,
}) => {
  const steps = Object.keys(stepsConfig);

  return (
    <div className="flex items-center justify-between w-full pl-16 pr-16 pt-4 pb-12 border-b border-gray-600">
      {steps.map((step: string, index: number) => (
        <React.Fragment key={step}>
          <div
            className="flex flex-col items-center"
            onClick={() => handleStepClick(step)}
            data-testid={`step-indicator-${step}`}
          >
            <div
              className={`w-4 h-4 rounded-full ${
                currentStep === step ? "bg-blue-500" : "bg-gray-300"
              } cursor-pointer relative`}
            >
              <span
                className={`text-xs mt-4 whitespace-nowrap ${
                  currentStep === step ? "text-blue-500" : "text-gray-500"
                } absolute top-full left-1/2 -translate-x-1/2`}
              >
                {stepsConfig[step]?.indicatorText}
              </span>
            </div>
          </div>
          {index < steps.length - 1 && (
            <div
              className="flex-grow border-t border-gray-300"
              data-testid="step-indicator-divider"
            />
          )}
        </React.Fragment>
      ))}
    </div>
  );
};

export default ProgressSteps;
</file>

<file path="The-Creator-AI-main/src/client/components/tree-view/TreeView.tsx">
import React, { useState } from 'react';
import { MdChevronRight } from 'react-icons/md';
import { getExpandedNodes } from './TreeView.utils';

export interface TreeNode {
    name: string;
    children?: TreeNode[];
    isExpanded?: boolean;
    [key: string]: any;
}

interface TreeViewProps {
    data: TreeNode[];
    onNodeClick?: (node: TreeNode) => void;
    renderNodeContent?: (node: TreeNode) => React.ReactNode;
}

const TreeView: React.FC<TreeViewProps> = ({ data, onNodeClick, renderNodeContent }) => {
    const [expandedNodes, setExpandedNodes] = useState<string[]>(getExpandedNodes(data));

    const handleNodeClick = (node: TreeNode) => {
        if (node.children) {
            setExpandedNodes((prevExpandedNodes) => {
                const isExpanded = prevExpandedNodes.includes(node.name);
                return isExpanded
                    ? prevExpandedNodes.filter((n) => n !== node.name)
                    : [...prevExpandedNodes, node.name];
            });
        }
        onNodeClick && onNodeClick(node);
    };

    const renderTreeNodes = (nodes: TreeNode[]) => {
        return nodes.map((node) => {
            const isExpanded = expandedNodes.includes(node.name);
            const isDirectory = !!node.children;

            return (
                <li key={node.name} className="relative">
                    <div
                        onClick={() => handleNodeClick(node)}
                        className={`
              cursor-pointer 
              px-2 
              flex 
              items-center 
              ${isDirectory ? 'font-medium' : 'font-normal'}
            `}
                    >
                        {isDirectory && (
                            <span
                                className={`
                  mr-2 
                  text-xl 
                  ${isExpanded ? 'rotate-90' : ''}
                  transition-transform 
                  duration-200
                  absolute
                  left-[-6px]
                `}
                            >
                                <MdChevronRight />
                            </span>
                        )}
                        {/* Use custom rendering if provided, otherwise display the node name */}
                        {renderNodeContent ? renderNodeContent(node) : node.name}
                    </div>
                    {isDirectory && isExpanded && (
                        <ul className="ml-4">{renderTreeNodes(node.children)}</ul>
                    )}
                </li>
            );
        });
    };

    return (
        <div className="font-sans">
            <ul>{renderTreeNodes(data)}</ul>
        </div>
    );
};

export default TreeView;
</file>

<file path="The-Creator-AI-main/src/client/components/tree-view/TreeView.utils.ts">
import { TreeNode } from "./TreeView";

export const getExpandedNodes = (data: TreeNode[]): string[] => {
  return data.reduce((acc, node) => {
    if (node.isExpanded) {
      acc.push(node.name);
    }
    if (node.children) {
      acc.push(...getExpandedNodes(node.children));
    }
    return acc;
  }, []);
};
</file>

<file path="The-Creator-AI-main/src/client/modules/api-keys-management.module/ApiKeysManagement.tsx">
import * as React from 'react';
import { useEffect, useState } from 'react';
import { LlmServiceEnum } from '@/backend/types/llm-service.enum';
import { ClientPostMessageManager } from '@/common/ipc/client-ipc';
import { ClientToServerChannel, ServerToClientChannel } from '@/common/ipc/channels.enum';
import Modal from '@/client/components/Modal';

const ApiKeyManagement: React.FC = () => {
  const [apiKeys, setApiKeys] = useState<Record<LlmServiceEnum, string[]>>(
    Object.values(LlmServiceEnum).reduce((acc, service) => ({ ...acc, [service]: [] }), {} as any)
  );
  const [newApiKey, setNewApiKey] = useState('');
  const [selectedService, setSelectedService] = useState<LlmServiceEnum | null>(null);
  const [isModalOpen, setIsModalOpen] = useState(false); // State for the modal

  const clientIpc = ClientPostMessageManager.getInstance();

  useEffect(() => {
    const fetchApiKeys = async () => {
      clientIpc.sendToServer(ClientToServerChannel.GetLLMApiKeys, {});
    };

    fetchApiKeys();
  }, []);

  useEffect(() => {
    const handleSendLLMApiKeys = (message: { apiKeys: Record<LlmServiceEnum, string[]> | undefined }) => {
      setApiKeys(message.apiKeys || {} as any);
    };

    clientIpc.onServerMessage(ServerToClientChannel.SendLLMApiKeys, handleSendLLMApiKeys);
  }, []);

  const handleAddApiKey = async () => {
    if (newApiKey.trim() === '' || !selectedService) {
      return;
    }

    clientIpc.sendToServer(ClientToServerChannel.SetLLMApiKey, { service: selectedService, apiKey: newApiKey });
    setNewApiKey(''); // Clear the input field
    setSelectedService(null); // Reset selected service
    setIsModalOpen(false); // Close the modal
  };

  const handleDeleteApiKey = async (service: LlmServiceEnum, apiKey: string) => {
    clientIpc.sendToServer(ClientToServerChannel.DeleteLLMApiKey, { service, apiKeyToDelete: apiKey });
  };

  const handleOpenModal = () => {
    setIsModalOpen(true);
  };

  const handleCloseModal = () => {
    setIsModalOpen(false);
  };

  return (
    <div className="p-4">
      <h2 className="text-xl font-bold mb-4 text-editor-fg">API Key Management</h2>
      <button
        onClick={handleOpenModal}
        className="mt-2 inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-button-bg hover:bg-button-bg focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-button-bg mb-4"
      >
        Add API Key
      </button>
      {/* Display existing keys or a message if no keys are present */}
      {Object.keys(apiKeys).some((service) => apiKeys[service as LlmServiceEnum].length > 0) ? (
        Object.entries(apiKeys).map(([service, keys]) => (
          <div key={service} className="mb-6">
            <h3 className="text-lg font-medium text-editor-fg">{service}</h3>
            <ul className="list-disc pl-5">
              {keys.map((apiKey, index) => (
                <li key={index} className="flex items-center justify-between py-2">
                  <span className="truncate text-editor-fg">{apiKey}</span>
                  <button
                    onClick={() => handleDeleteApiKey(service as LlmServiceEnum, apiKey)}
                    className="text-red-500 hover:text-red-700"
                  >
                    Delete
                  </button>
                </li>
              ))}
            </ul>
          </div>
        ))
      ) : (
        <div className="mb-4">
          <p className="text-gray-600">No API keys added yet.</p>
        </div>
      )}

      {/* Modal for adding new API keys */}
      <Modal isOpen={isModalOpen} onClose={handleCloseModal}>
        <div className="p-6">
          <h3 className="text-lg font-bold mb-4 text-editor-fg">Add New API Key</h3>
          <div className="mb-4">
            <label htmlFor="serviceSelect" className="block text-sm font-medium text-gray-700">
              Select Service:
            </label>
            <select
              id="serviceSelect"
              value={selectedService || ''}
              onChange={(e) => setSelectedService(e.target.value as LlmServiceEnum)}
              className="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md bg-settings-input-bg"
            >
              <option value="">Select a service</option>
              {Object.values(LlmServiceEnum).map((service) => (
                <option key={service} value={service}>
                  {service}
                </option>
              ))}
            </select>
          </div>
          <div className="mb-4">
            <label htmlFor="apiKeyInput" className="block text-sm font-medium text-gray-700">
              API Key:
            </label>
            <div className="mt-1 flex rounded-md shadow-sm">
              <input
                type="password" // Make the input field a password field
                name="apiKeyInput"
                id="apiKeyInput"
                className="focus:ring-indigo-500 focus:border-indigo-500 flex-grow block w-full min-w-0 rounded-none rounded-l-md sm:text-sm border-gray-300 p-2 bg-settings-input-bg"
                placeholder="Enter your API key"
                value={newApiKey}
                onChange={(e) => setNewApiKey(e.target.value)}
                disabled={!selectedService}
              />
              <button
                onClick={handleAddApiKey}
                className="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-r-md shadow-sm text-white bg-button-bg hover:bg-button-bg focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-button-bg"
                disabled={!selectedService || newApiKey.trim() === ''}
              >
                Add
              </button>
            </div>
          </div>
          <button
            onClick={handleCloseModal}
            className="mt-4 inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
          >
            Cancel
          </button>
        </div>
      </Modal>
    </div>
  );
};

export default ApiKeyManagement;
</file>

<file path="The-Creator-AI-main/src/client/modules/commit.module/Commit.tsx">
import AutoResizingTextarea from '@/client/components/AutoResizingTextarea';
import { useStore } from '@/client/store/useStore';
import { commitStagedChanges } from '@/client/views/change-plan.view/logic/commitStagedChanges';
import { changePlanViewStoreStateSubject, getChangePlanViewState } from '@/client/views/change-plan.view/store/change-plan-view.store';
import React, { useState } from 'react';

const Commit: React.FC = () => {
    const {
        chatHistory,
    } = useStore(changePlanViewStoreStateSubject);
    const [commitTitle, setCommitTitle] = useState(getChangePlanViewState('changePlans')?.[getChangePlanViewState('changePlans').length - 1]?.planTitle || '');
    const [commitDescription, setCommitDescription] = useState(getChangePlanViewState('changePlans')?.[getChangePlanViewState('changePlans').length - 1]?.planDescription || '');

    const handleCommit = async () => {
        commitStagedChanges(commitTitle, commitDescription);
    };

    return (
        <div className="p-4">
            {chatHistory.length === 0 ? (
                <p className="text-gray-600">No changes to commit.</p>
            ) : (
                <div className="flex flex-col">
                    <div className="mb-4">
                        <label htmlFor="commitTitle" className="block text-sm font-medium text-gray-700">
                            Commit Title:
                        </label>
                        <AutoResizingTextarea
                            id="commitTitle"
                            className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm"
                            value={commitTitle}
                            onChange={(e) => setCommitTitle(e.target.value)}
                            placeholder="Enter a short, descriptive commit title"
                        />
                    </div>

                    <div className="mb-4">
                        <label htmlFor="commitDescription" className="block text-sm font-medium text-gray-700">
                            Commit Description (Optional):
                        </label>
                        <AutoResizingTextarea
                            id="commitDescription"
                            className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm"
                            value={commitDescription}
                            onChange={(e) => setCommitDescription(e.target.value)}
                            placeholder="Enter a more detailed description of the changes (optional)"
                            minRows={3} // Adjust as needed
                            maxRows={10} // Adjust as needed
                        />
                    </div>
                    <button
                        onClick={handleCommit}
                        className="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline"
                    >
                        Commit
                    </button>
                </div>
            )}
        </div>
    );
};

export default Commit;
</file>

<file path="The-Creator-AI-main/src/client/modules/context.module/Context.tsx">
import React, { useEffect, useState } from 'react';
import { FileNode } from '@/common/types/file-node';
import { ClientPostMessageManager } from '@/common/ipc/client-ipc';
import { ClientToServerChannel, ServerToClientChannel } from '@/common/ipc/channels.enum';
import FileTree from '@/client/components/file-tree/FileTree';
import { handleFileClick } from '@/client/views/change-plan.view/logic/handleFileClick';
import { setChangePlanViewState as setState } from '@/client/views/change-plan.view/store/change-plan-view.logic';
import { getChangePlanViewState } from '@/client/views/change-plan.view/store/change-plan-view.store';

const Context: React.FC = () => {
    const clientIpc = ClientPostMessageManager.getInstance();
    const selectedFiles = getChangePlanViewState("selectedFiles");
    const files = getChangePlanViewState("files");
    const [recentFiles, setRecentFiles] = useState<string[]>([]);
    const [activeFile, setActiveFile] = useState<string>();
    const [activeContext, setActiveContext] = useState<'code' | 'features' | 'architecture' | 'guidelines'>('code');
    useEffect(() => {
        const handleSendWorkspaceFiles = ({ files }: { files: FileNode[] }) => {
            setState("files")(files);
        };
        clientIpc.onServerMessage(
            ServerToClientChannel.SendWorkspaceFiles,
            handleSendWorkspaceFiles
        );
    
            // Request workspace files on component mount
            clientIpc.sendToServer(ClientToServerChannel.RequestWorkspaceFiles, {});
    
    
    }, []);
    
    const handleContextChange = (context: 'code' | 'features' | 'architecture' | 'guidelines') => {
        setActiveContext(context);
    };    return (
        <div className="p-4 overflow-y-auto overflow-x-hidden">
            <div className='flex mb-4'>
                <button 
                  className={`mr-2 px-4 py-2 border rounded ${activeContext === 'code' ? 'bg-blue-500 text-white' : 'border-gray-300'}`}
                  onClick={() => handleContextChange('code')}
                >
                  Code
                </button>
                 <button 
                    className={`mr-2 px-4 py-2 border rounded ${activeContext === 'features' ? 'bg-blue-500 text-white' : 'border-gray-300'}`}
                    onClick={() => handleContextChange('features')}
                >
                  Features
                </button>
                 <button 
                  className={`mr-2 px-4 py-2 border rounded ${activeContext === 'architecture' ? 'bg-blue-500 text-white' : 'border-gray-300'}`}
                  onClick={() => handleContextChange('architecture')}
                >
                  Architecture
                </button>
                 <button 
                 className={`mr-2 px-4 py-2 border rounded ${activeContext === 'guidelines' ? 'bg-blue-500 text-white' : 'border-gray-300'}`}
                 onClick={() => handleContextChange('guidelines')}
                >
                    Guidelines
                  </button>
            </div>
             {/* Render FileTree for each root node */}
             {activeContext === 'code' && files.map((rootNode, index) => (
                <FileTree
                    key={index}
                    data={[rootNode]}
                    onFileClick={(filePath) => handleFileClick({
                    clientIpc,
                    filePath,
                    setActiveFile,
                })}
                selectedFiles={selectedFiles}
                recentFiles={recentFiles}
                activeFile={activeFile}
                updateSelectedFiles={(files) => setState("selectedFiles")(files)}
                updateRecentFiles={setRecentFiles}
            />
             ))}
        {activeContext !== 'code' && <div className="text-gray-500"> {activeContext} Tree View is under development. </div>}
            {!files.length && (
                <div className="text-gray-500">Loading files...</div>
            )}
        </div>
    );
};
export default Context;
</file>

<file path="The-Creator-AI-main/src/client/modules/plan.module/components/file-card.tsx">
import { useStore } from '@/client/store/useStore';
import { changePlanViewStoreStateSubject } from '@/client/views/change-plan.view/store/change-plan-view.store';
import * as React from "react";
import { MdDescription } from 'react-icons/md';
import { ClientToServerChannel } from '@/common/ipc/channels.enum';
import { ClientPostMessageManager } from '@/common/ipc/client-ipc';
import { getChangePlanViewState } from '../../../views/change-plan.view/store/change-plan-view.store';
import { setChangePlanViewState } from '@/client/views/change-plan.view/store/change-plan-view.logic';
import { ServerToClientChannel } from '@/common/ipc/channels.enum';
import Markdown from "markdown-to-jsx";

interface FileCardProps {
    fileName: string;
    operation: string;
    recommendations: string[];
    filePath: string;
}

const FileCard: React.FC<FileCardProps> = ({ fileName, operation, recommendations, filePath }) => {
    const { fileChunkMap } = useStore(changePlanViewStoreStateSubject);
    const clientIpc = ClientPostMessageManager.getInstance();
    const chatHistory = getChangePlanViewState('chatHistory');
    const selectedFiles = getChangePlanViewState('selectedFiles');
    const isLoading = fileChunkMap[filePath]?.isLoading;
    const fileContent = fileChunkMap[filePath]?.fileContent;

    React.useEffect(() => {
        clientIpc.onServerMessage(ServerToClientChannel.StreamFileCode, (data) => {
            const { filePath, chunk } = data;
            console.log({ filePath, chunk });
            const fileChunkMap = getChangePlanViewState('fileChunkMap');
            const localFilePath = Object.keys(fileChunkMap).find((key) => key.includes(filePath) || filePath.includes(key));

            if (!fileChunkMap[localFilePath]?.isLoading) {
                return;
            }

            const updatedFileChunkMap = {
                ...fileChunkMap,
                [localFilePath]: {
                    ...fileChunkMap[localFilePath],
                    fileContent: (fileChunkMap[localFilePath]?.fileContent || '') + chunk
                }
            };
            setChangePlanViewState('fileChunkMap')(updatedFileChunkMap);
        });

        clientIpc.onServerMessage(ServerToClientChannel.SendFileCode, (data) => {
            const { filePath, fileContent } = data;
            console.log({ filePath, fileContent });
            const fileChunkMap = getChangePlanViewState('fileChunkMap');
            const localFilePath = Object.keys(fileChunkMap).find((key) => key.includes(filePath) || filePath.includes(key));
            const updatedFileChunkMap = {
                ...fileChunkMap,
                [localFilePath]: {
                    ...fileChunkMap[localFilePath],
                    fileContent,
                    isLoading: false
                }
            };
            setChangePlanViewState('fileChunkMap')(updatedFileChunkMap);
        });
    }, []);

    const handleRequestOpenFile = (filePath: string) => {
        clientIpc.sendToServer(ClientToServerChannel.RequestOpenFile, {
            filePath
        });
    };


    return (
        <div className="file-card flex flex-grow flex-col bg-sidebar-bg border border-gray-700 rounded p-4 shadow-md min-w-0 relative">
            <div className="flex items-center mb-2">
                <MdDescription
                    size={18}
                    className={`mr-2 cursor-pointer ${isLoading ? 'text-gray-400' : 'hover:text-blue-500'} `}
                />
                <h4 className="text-base font-medium text-editor-fg cursor-pointer" onClick={() => handleRequestOpenFile(filePath)}>{fileName}</h4>
            </div>
            <p className="text-gray-600 mb-3">{operation}</p>
            <ul className="list-disc list-inside">
                {recommendations.map((recommendation, index) => (
                    <li key={index} className="text-gray-400 text-xs mb-2">
                         <Markdown>{JSON.stringify(recommendation, null, 2)}</Markdown>
                    </li>
                ))}
            </ul>
        </div>
    );
};

export default FileCard;
</file>

<file path="The-Creator-AI-main/src/client/modules/plan.module/formatted-plan-preview.tsx">
import { ClientToServerChannel, ServerToClientChannel } from "@/common/ipc/channels.enum";
import { ClientPostMessageManager } from "@/common/ipc/client-ipc";
import { useStore } from "@/client/store/useStore";
import { setChangePlanViewState } from "@/client/views/change-plan.view/store/change-plan-view.logic";
import { changePlanViewStoreStateSubject, getChangePlanViewState } from "@/client/views/change-plan.view/store/change-plan-view.store";
import * as React from "react";
import { useEffect, useState } from "react";
import { MdFileDownload } from "react-icons/md";
import FileCard from "./components/file-card"; // Import the new FileCard component

interface FormattedPlanPreviewProps {
  jsonData: any;
}

const FormattedPlanPreview: React.FC<FormattedPlanPreviewProps> = ({
  jsonData,
}) => {
  const [currentFileIndex, setCurrentFileIndex] = useState(0);
  const { activeTab } = useStore(changePlanViewStoreStateSubject);
  const clientIpc = ClientPostMessageManager.getInstance();
  const chatHistory = getChangePlanViewState("chatHistory");
  const selectedFiles = getChangePlanViewState("selectedFiles");
  const [loadingFile, setLoadingFile] = useState<string | null>(null);
  const { fileChunkMap } = useStore(changePlanViewStoreStateSubject);

  useEffect(() => {
    clientIpc.onServerMessage(ServerToClientChannel.StreamFileCode, (data) => {
      const { filePath, chunk } = data;
      console.log({ filePath, chunk });
      const fileChunkMap = getChangePlanViewState("fileChunkMap");
      const localFilePath = Object.keys(fileChunkMap).find(
        (key) => key.includes(filePath) || filePath.includes(key)
      );

      if (!fileChunkMap[localFilePath]?.isLoading) {
        return;
      }

      const updatedFileChunkMap = {
        ...fileChunkMap,
        [localFilePath]: {
          ...fileChunkMap[localFilePath],
          fileContent: (fileChunkMap[localFilePath]?.fileContent || "") + chunk,
        },
      };
      setChangePlanViewState("fileChunkMap")(updatedFileChunkMap);
    });

    clientIpc.onServerMessage(ServerToClientChannel.SendFileCode, (data) => {
      const { filePath, fileContent } = data;
      console.log({ filePath, fileContent });
      const fileChunkMap = getChangePlanViewState("fileChunkMap");
      const localFilePath = Object.keys(fileChunkMap).find(
        (key) => key.includes(filePath) || filePath.includes(key)
      );
      const updatedFileChunkMap = {
        ...fileChunkMap,
        [localFilePath]: {
          ...fileChunkMap[localFilePath],
          fileContent,
          isLoading: false,
        },
      };
      setChangePlanViewState("fileChunkMap")(updatedFileChunkMap);
      setLoadingFile(null);
    });
  }, []);

  const handleHeaderClick = (index: number) => {
    setCurrentFileIndex(index);
    clientIpc.sendToServer(ClientToServerChannel.RequestOpenFile, {
      filePath: jsonData.code_plan[index]?.filename,
    });
  };

  useEffect(() => {
    const matchingCardIndex = jsonData.code_plan.findIndex(
      (item: any) =>
        item?.filename && activeTab && activeTab.endsWith(item.filename)
    );
    if (matchingCardIndex !== -1) {
      setCurrentFileIndex(matchingCardIndex);
    }
  }, [activeTab, jsonData.code_plan]);

  const handleRequestFileCode = (filePath: string) => {
    const fileChunkMap = getChangePlanViewState("fileChunkMap");
    const updatedFileChunkMap = {
      ...fileChunkMap,
      [filePath]: {
        isLoading: true,
        fileContent: "",
      },
    };
    setChangePlanViewState("fileChunkMap")(updatedFileChunkMap);
    clientIpc.sendToServer(ClientToServerChannel.RequestStreamFileCode, {
      filePath,
      chatHistory,
      selectedFiles,
    });
    setLoadingFile(filePath);
  };

  return jsonData ? (
    <div className="formatted-plan-preview min-h-0 pt-2 flex flex-col flex-grow focus:outline-none overflow-y-auto">
      <h3 className="flex justify-center text-xs font-bold mb-2 px-4 text-center">
        {jsonData.title}
      </h3>
      <p
        className="flex justify-center text-gray-700 px-4 text-center"
      >
        {jsonData.description}
      </p>
      {/* Pagination Dots */}
      <div className="flex flex-col my-4">
        {jsonData.code_plan.map((item: any, index: number) => (
          <div key={index}>
            <button
              onClick={() => handleHeaderClick(index)}
              className={`w-full text-left px-4 py-2 text-sm hover:bg-hover-bg ${
                index === currentFileIndex ? "bg-hover-bg" : ""
              }`}
            >
              <div className="flex items-center justify-between">
                <span className="whitespace-nowrap overflow-hidden text-ellipsis">
                  {item.filename?.split("/").pop() || ""}
                </span>
                {!fileChunkMap[item.filename]?.isLoading ? (
                  <MdFileDownload
                    size={18}
                    className={`ml-2 cursor-pointer text-blue-500`}
                    onClick={() => handleRequestFileCode(item.filename)}
                  />
                ) : null}
                {fileChunkMap[item.filename]?.isLoading && (
                  <span className="loader mr-2">
                    <div className="spinner w-4 h-4 border-t-2 border-b-2 border-blue-500 rounded-full animate-spin ml-2"></div>
                  </span>
                )}
                {fileChunkMap[item.filename]?.isLoading &&
                fileChunkMap[item.filename]?.fileContent?.length ? (
                  <span className="text-xs text-gray-500 whitespace-nowrap overflow-x-auto">
                    ({fileChunkMap[item.filename]?.fileContent?.length} ++)
                  </span>
                ) : null}
              </div>
            </button>
          </div>
        ))}
      </div>
      <div className="flex flex-grow mx-4">
        {jsonData.code_plan.map((item: any, index: number) => {
          if (item?.filename && index === currentFileIndex) {
            // Only render the card at the currentFileIndex
            return (
              <FileCard
                key={index}
                fileName={item.filename?.split("/").pop() || ""}
                operation={item.operation}
                recommendations={item.recommendations}
                filePath={item.filename}
              />
            );
          }
          return null;
        })}
      </div>
    </div>
  ) : null;
};

export default FormattedPlanPreview;
</file>

<file path="The-Creator-AI-main/src/client/modules/plan.module/plan-input-box.tsx">
import * as React from 'react';
import { BsSend } from 'react-icons/bs';
import AutoResizingTextarea from '@/client/components/AutoResizingTextarea';
import { ClientPostMessageManager } from '@/common/ipc/client-ipc';
import { ClientToServerChannel, ServerToClientChannel } from '@/common/ipc/channels.enum';
import { useStore } from '@/client/store/useStore';
import { changePlanViewStoreStateSubject, getChangePlanViewState } from '@/client/views/change-plan.view/store/change-plan-view.store';
import { handleSubmitPlanRequest } from '../../views/change-plan.view/logic/handleSubmitPlanRequest';
import { FileNode } from '@/common/types/file-node';

interface PlanStepInputProps {
    handleChange: (value: string) => void;
    isUpdateRequest?: boolean;
    files: FileNode[];
}

const PlanInputBox: React.FC<PlanStepInputProps> = ({ isUpdateRequest, handleChange, files }) => {
    const { selectedFiles } = useStore(changePlanViewStoreStateSubject);
    const [suggestions, setSuggestions] = React.useState<string[]>([]);
    const [selectedSuggestionIndex, setSelectedSuggestionIndex] = React.useState<number | null>(null);
    const [showSuggestions, setShowSuggestions] = React.useState(false);
    const inputRef = React.useRef<HTMLTextAreaElement>(null);
    const changeDescription = getChangePlanViewState("changeDescription");
    const isLoading = getChangePlanViewState("isLoading");

    const clientIpc = ClientPostMessageManager.getInstance();

    const handleSuggestionAccept = (suggestion: string) => {
        handleChange(
            changeDescription.split(' ').slice(0, -1).join(' ')
            + (changeDescription.split(' ').length > 1 ? ' ' : '')
            + suggestion + ' ');
        setSelectedSuggestionIndex(null);
        setShowSuggestions(false);
    };

    const handleSubmit = () => {
        handleSubmitPlanRequest(clientIpc, files);
    };

    const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
        if (showSuggestions) {
            if (e.key === 'ArrowUp') {
                e.preventDefault();
                setSelectedSuggestionIndex((prevIndex) => (prevIndex === null || prevIndex === 0) ? suggestions.length - 1 : prevIndex - 1);
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                setSelectedSuggestionIndex((prevIndex) => (prevIndex === null || prevIndex === suggestions.length - 1) ? 0 : prevIndex + 1);
            } else if (e.key === 'Enter') {
                if (selectedSuggestionIndex !== null) {
                    e.preventDefault();
                    const selectedSuggestion = suggestions[selectedSuggestionIndex];
                    handleSuggestionAccept(selectedSuggestion);
                }
            } else if (e.key === 'Escape') {
                setShowSuggestions(false);
            }
        }
        if (e.key === 'Enter' && (e.ctrlKey || e.metaKey || e.altKey)) {
            e.preventDefault();
            handleSubmit();
        }
    };

    React.useEffect(() => {
        const fetchSuggestions = () => {
            if (changeDescription.split(' ').pop().startsWith('@')) {
                clientIpc.sendToServer(ClientToServerChannel.RequestSymbols, {
                    query: changeDescription.split(' ').pop().slice(1)
                });
            } else {
                setShowSuggestions(false); // Hide suggestions if "@" is not the last character
            }
        };

        const timeoutId = setTimeout(fetchSuggestions, 300); // Adjust delay as needed

        return () => clearTimeout(timeoutId);
    }, [changeDescription, selectedFiles]);

    React.useEffect(() => {
        clientIpc.onServerMessage(ServerToClientChannel.SendSymbols, (message) => {
            const receivedSuggestions = (message.symbols || []).map((symbol: { name: string }) => symbol.name); // Adjust based on actual symbol structure
            setSuggestions(receivedSuggestions);
            setShowSuggestions(true);
        });
    }, []);

    return (
        <div className="flex flex-col">
            <div className="relative p-4 flex flex-col relative" data-testid="change-plan-input-step">
                {showSuggestions && suggestions.length > 0 && (
                    <ul className="absolute bottom-full bg-sidebar-bg left-0 mb-1 border border-gray-300 rounded max-h-40 overflow-y-auto shadow-lg z-10 m-4"
                        style={{
                            width: inputRef.current?.clientWidth,
                        }}>
                        {suggestions.map((suggestion, index) => (
                            <li
                                key={index}
                                className={`p-2 cursor-pointer hover:bg-hover-bg ${index === selectedSuggestionIndex ? 'bg-hover-bg' : ''}`}
                                onClick={() => {
                                    handleSuggestionAccept(suggestion);
                                }}
                            >
                                {suggestion}
                            </li>
                        ))}
                    </ul>
                )}
                <AutoResizingTextarea
                    ref={inputRef}
                    className="p-2 border border-gray-300 rounded font-normal mb-2 pr-10"
                    placeholder={isUpdateRequest ? "Describe the changes you want to make to the plan..." : "Describe the code changes you want to plan..."}
                    value={changeDescription}
                    onChange={(e) => handleChange(e.target.value)}
                    disabled={isLoading}
                    data-testid="change-description-textarea"
                    onKeyDown={handleKeyDown}
                    minRows={3}
                    maxRows={10}
                    autoFocus
                />
            </div>
            {inputRef.current && <BsSend
                className="fixed transform -translate-y-1/2 text-gray-400 cursor-pointer hover:text-blue-500"
                style={{
                    left: inputRef.current?.getClientRects()?.[0]?.right - 35,
                    top: inputRef.current?.getClientRects()?.[0]?.bottom - 20,
                }}
                size={20}
                onClick={handleSubmit}
                data-testid="submit-change-description-button"
            />}
        </div>
    );
};

export default PlanInputBox;
</file>

<file path="The-Creator-AI-main/src/client/modules/plan.module/Plan.tsx">
import { setChangePlanViewState as setState } from "@/client/views/change-plan.view/store/change-plan-view.logic";
import { getChangePlanViewState } from "@/client/views/change-plan.view/store/change-plan-view.store";
import { parseJsonResponse } from "@/common/utils/parse-json";
import Markdown from "markdown-to-jsx";
import * as React from "react";
import { useEffect, useState } from "react";
import FormattedPlanPreview from "./formatted-plan-preview";
import PlanInputBox from "./plan-input-box";

const Plan: React.FC = () => {
  const llmResponse = getChangePlanViewState("llmResponse");
  const files = getChangePlanViewState("files");
  const [responseType, setResponseType] = useState<"json" | "markdown" | null>(
    null
  );
  const [parsedResponse, setParsedResponse] = useState<any>(null);

  useEffect(() => {
    const jsonData = parseJsonResponse(llmResponse);
    if (jsonData) {
      setResponseType("json");
      setParsedResponse(jsonData);
    } else {
      setResponseType("markdown");
    }
  }, [llmResponse]);

  const renderResponse = () => {
    switch (responseType) {
      case "json":
        return <FormattedPlanPreview jsonData={parsedResponse} />;
      case "markdown":
        return <Markdown>{llmResponse}</Markdown>;
      default:
        return null;
    }
  };

  console.log({ files });
  return (
    <div className="plan-step flex flex-grow flex-col min-h-0">
      <div className="flex flex-grow flex-col min-h-0">{renderResponse()}</div>
      <PlanInputBox
        isUpdateRequest={
          !!(getChangePlanViewState("chatHistory").length > 0 && llmResponse)
        }
        handleChange={setState("changeDescription")}
        files={[]}
      />
    </div>
  );
};

export default Plan;
</file>

<file path="The-Creator-AI-main/src/client/store/store.ts">
import { BehaviorSubject } from "rxjs";

export class Store<T, A> extends BehaviorSubject<T> {
  constructor(private val: T) {
    super(val);
  }

  _next(value: T, action: A, actionVariant?: string): void {
    const devLogs = new URL(window.location.href).searchParams.has("devLogs");
    if (devLogs) {
      if (actionVariant) {
        console.log(action, actionVariant, value);
      } else {
        console.log(action, value);
      }
    }
    super.next(value);
  }
}
</file>

<file path="The-Creator-AI-main/src/client/store/useStore.ts">
import { useEffect, useState } from "react";
import { Store } from "./store";

export const useSelector = <S, A, R>(
  subject: Store<S, A>,
  selector: (state: S) => R
) => {
  const [state, setState] = useState<S>(subject.getValue());

  useEffect(() => {
    const subscription = subject.subscribe((newState) => {
      if (selector(newState) !== selector(state)) {
        setState(newState);
      }
    });

    return () => subscription.unsubscribe();
  }, [subject, selector]);

  return selector(state);
};

export const useStore = <S, A>(subject: Store<S, A>) => {
  return useSelector(subject, (state) => state);
};
</file>

<file path="The-Creator-AI-main/src/client/views/change-plan.view/index.ts">
import { VIEW_TYPES } from "@/common/view-types";
import { onMessage } from "./on-mesage";

export const viewConfig = {
  entry: "changePlanView.js",
  type: VIEW_TYPES.SIDEBAR.CHANGE_PLAN,
  handleMessage: onMessage,
};
</file>

<file path="The-Creator-AI-main/src/client/views/change-plan.view/logic/commitStagedChanges.ts">
import { ClientToServerChannel } from "@/common/ipc/channels.enum";
import { ClientPostMessageManager } from "@/common/ipc/client-ipc";

export const commitStagedChanges = (message: string, description: string) => {
  const clientIpc = ClientPostMessageManager.getInstance();
  clientIpc.sendToServer(ClientToServerChannel.CommitStagedChanges, {
    message,
    description,
  });
};
</file>

<file path="The-Creator-AI-main/src/client/views/change-plan.view/logic/getSelectedFiles.ts">
import { getChangePlanViewState } from "@/client/views/change-plan.view/store/change-plan-view.store";
import { FileNode } from "@/common/types/file-node";

export const getSelectedFiles = (files: FileNode[]) => {
  const selectedFiles = getChangePlanViewState("selectedFiles");
  // Create an array to store absolute paths of selected files
  const absoluteSelectedFiles: string[] = [];

  // Iterate through updatedSelectedFiles and find corresponding absolute paths in files
  selectedFiles.forEach((relativePath) => {
    let matchingNode: FileNode | undefined = undefined;
    files.find((node) => {
      // Iterate through files to find the matching absolute path
      function findMatchingNode(node: FileNode) {
        if (node.absolutePath && node.absolutePath.endsWith(relativePath)) {
          return node;
        }
        if (node.children) {
          for (const child of node.children) {
            const matchingNode = findMatchingNode(child);
            if (matchingNode) {
              return matchingNode;
            }
          }
        }
        return undefined;
      }
      matchingNode = findMatchingNode(node);
    });

    if (matchingNode) {
      absoluteSelectedFiles.push(matchingNode.absolutePath || "");
    }
  });
  return absoluteSelectedFiles;
};
</file>

<file path="The-Creator-AI-main/src/client/views/change-plan.view/logic/handleCommitMessageSuggestions.ts">
import { ServerToClientChannel } from "@/common/ipc/channels.enum";
import { ClientPostMessageManager } from "@/common/ipc/client-ipc";
import { setChangePlanViewState } from "../store/change-plan-view.logic";

export const handleCommitMessageSuggestions = () => {
  const clientIpc = ClientPostMessageManager.getInstance();
  clientIpc.onServerMessage(
    ServerToClientChannel.SendCommitMessageSuggestions,
    (message) => {
      setChangePlanViewState("commitSuggestions")(message.suggestions);
      setChangePlanViewState("commitSuggestionsLoading")(false);
    }
  );
};
</file>

<file path="The-Creator-AI-main/src/client/views/change-plan.view/logic/handleFileClick.ts">
import { ClientToServerChannel } from "@/common/ipc/channels.enum";
import { ClientPostMessageManager } from "@/common/ipc/client-ipc";

export const handleFileClick = ({
  clientIpc,
  setActiveFile,
  filePath,
}: {
  clientIpc: ClientPostMessageManager;
  setActiveFile: React.Dispatch<React.SetStateAction<string>>;
  filePath: string;
}) => {
  setActiveFile(filePath);

  // Send the selected editor path to the extension
  clientIpc.sendToServer(ClientToServerChannel.SendSelectedEditor, {
    editor: {
      fileName: filePath.split("/").pop() || "",
      filePath,
      languageId: "", // You might need to determine the languageId here
    },
  });
};
</file>

<file path="The-Creator-AI-main/src/client/views/change-plan.view/logic/handleSubmitPlanRequest.ts">
import { AGENTS } from "@/common/constants/agents.constants";
import { ClientToServerChannel } from "@/common/ipc/channels.enum";
import {
  setChangePlanViewState as setState,
  setChangePlanViewState,
} from "@/client/views/change-plan.view/store/change-plan-view.logic";
import { getChangePlanViewState } from "@/client/views/change-plan.view/store/change-plan-view.store";
import { ClientPostMessageManager } from "@/common/ipc/client-ipc";
import { FileNode } from "@/common/types/file-node";
import { getSelectedFiles } from "./getSelectedFiles";

export const handleSubmitPlanRequest = (
  clientIpc: ClientPostMessageManager,
  files: FileNode[]
) => {
  setState("isLoading")(true);
  const llmResponse = getChangePlanViewState("llmResponse");
  const changeDescription = getChangePlanViewState("changeDescription");
  if (!changeDescription) {
    setState("isLoading")(false);
    const fileChunkMap = getChangePlanViewState("fileChunkMap");
    const updatedFileChunkMap = Object.keys(fileChunkMap).reduce(
      (acc, filePath) => {
        acc[filePath] = {
          ...fileChunkMap[filePath],
          isLoading: false,
        };
        return acc;
      },
      {}
    );
    setChangePlanViewState("fileChunkMap")(updatedFileChunkMap);
    return;
  }

  const selectedFiles = getSelectedFiles(files);

  const isUpdatingPlan =
    getChangePlanViewState("chatHistory").length && llmResponse;

  let chatHistory = getChangePlanViewState("chatHistory");
  const messagesToSend = [];

  if (chatHistory.length > 0) {
    if (chatHistory.length > 2) {
      messagesToSend.push(chatHistory[1]); // Add second message if it exists
    }
    messagesToSend.push(chatHistory[chatHistory.length - 1]); // Add last message
  }

  const newChatHistory = [
    ...(isUpdatingPlan
      ? [
          ...chatHistory,
          {
            user: "instructor",
            message: AGENTS["Code Plan Update"]?.systemInstructions,
          },
        ]
      : [
          {
            user: "instructor",
            message: AGENTS["Code Plan"]?.systemInstructions,
          },
        ]),
    ...(messagesToSend || []),
    {
      user: "user",
      message: (isUpdatingPlan ? `Revise the plan:\n` : "") + changeDescription,
    },
  ];
  setState("chatHistory")(newChatHistory); // Update chatHistory in the store

  clientIpc.sendToServer(ClientToServerChannel.SendStreamMessage, {
    chatHistory: newChatHistory,
    selectedFiles,
  });
};
</file>

<file path="The-Creator-AI-main/src/client/views/change-plan.view/logic/requestCommitMessageSuggestions.ts">
import { ClientPostMessageManager } from "@/common/ipc/client-ipc";
import { getChangePlanViewState } from "../store/change-plan-view.store";
import { ClientToServerChannel } from "@/common/ipc/channels.enum";

export const requestCommitMessageSuggestions = () => {
  const chatHistory = getChangePlanViewState("chatHistory");
  const clientIpc = ClientPostMessageManager.getInstance();
  clientIpc.sendToServer(
    ClientToServerChannel.RequestCommitMessageSuggestions,
    {
      chatHistory,
    }
  );
};
</file>

<file path="The-Creator-AI-main/src/client/views/change-plan.view/logic/setupChannelHandlers.ts">
import {
    ClientToServerChannel,
    ServerToClientChannel,
} from "@/common/ipc/channels.enum";
import { ClientPostMessageManager } from "@/common/ipc/client-ipc";
import { FileNode } from "@/common/types/file-node";
import { KeyPaths, KeyPathValue } from "@/common/utils/key-path";
import { ChangePlanSteps } from "@/client/views/change-plan.view/view.constants";
import { updateOrCreateChangePlan } from "@/client/views/change-plan.view/logic/updateOrCreateChangePlan";
import {
    setChangePlanViewState as setState
} from "@/client/views/change-plan.view/store/change-plan-view.logic";
import { ChangePlanViewStore } from "@/client/views/change-plan.view/store/change-plan-view.state-type";
import { getChangePlanViewState } from "@/client/views/change-plan.view/store/change-plan-view.store";

export const setupChannelHandlers = () => {
  const clientIpc = ClientPostMessageManager.getInstance();

  const handleSendMessage = ({ message }: { message: string }) => {
    setState("isLoading")(false);
    setState("llmResponse")(message);
    setState("changeDescription")("");
    setState("currentStep")(ChangePlanSteps.Plan);

    // Update chat history
    setState("chatHistory")([
      ...getChangePlanViewState("chatHistory"),
      { user: "bot", message },
    ]);

    // Update or add the new change plan
    updateOrCreateChangePlan(message);
  };

  const handleStreamMessage = ({ chunk }: { chunk: string }) => {
    setState("llmResponse")(getChangePlanViewState("llmResponse") + chunk);
  };

  const handleSendWorkspaceFiles = ({ files }: { files: FileNode[] }) => {
     setState("files")(files);
  };

  const handleSendFileCode = ({
    fileContent,
    filePath,
  }: {
    fileContent: string;
    filePath: string;
  }) => {
    if (filePath) {
      try {
        console.log(fileContent);
        console.log(`File ${filePath} updated successfully.`);
      } catch (err) {
        console.error(`Error updating file ${filePath}:`, err);
      }
    }
  };

  const handleSetChangePlanViewState = <
    Key extends KeyPaths<ChangePlanViewStore>
  >(data: {
    keyPath: Key;
    value: KeyPathValue<Key, ChangePlanViewStore>;
  }) => {
    console.log({ data });
    setState(data.keyPath)(data.value);
  };

  clientIpc.onServerMessage(
    ServerToClientChannel.SendMessage,
    handleSendMessage
  );
  clientIpc.onServerMessage(
    ServerToClientChannel.StreamMessage,
    handleStreamMessage
  );

  // Request workspace files on component mount
  clientIpc.sendToServer(ClientToServerChannel.RequestWorkspaceFiles, {});

  // Listen for workspace files response
  clientIpc.onServerMessage(
    ServerToClientChannel.SendWorkspaceFiles,
    handleSendWorkspaceFiles
  );

  // Listener for SendFileCode
  clientIpc.onServerMessage(
    ServerToClientChannel.SendFileCode,
    handleSendFileCode
  );

  clientIpc.onServerMessage(
    ServerToClientChannel.SetChangePlanViewState,
    handleSetChangePlanViewState
  );

  clientIpc.sendToServer(ClientToServerChannel.FetchStore, {
    storeName: "changePlanViewState",
  });
};
</file>

<file path="The-Creator-AI-main/src/client/views/change-plan.view/logic/updateOrCreateChangePlan.ts">
import { parseJsonResponse } from "@/common/utils/parse-json";
import { getChangePlanViewState } from "@/client/views/change-plan.view/store/change-plan-view.store";
import { setChangePlanViewState } from "@/client/views/change-plan.view/store/change-plan-view.logic";

export const updateOrCreateChangePlan = (llmResponse: string) => {
  try {
    const planJson = parseJsonResponse(llmResponse);
    if (!planJson) {
      return;
    }

    const planTitle = planJson.title;
    const planDescription = planJson.description;

    const changePlans = getChangePlanViewState("changePlans");
    const existingPlanIndex = changePlans.findIndex(
      (plan) => plan.planTitle === planTitle
    );

    const updatedChangePlans = [...changePlans];

    if (existingPlanIndex !== -1) {
      // Update existing plan
      updatedChangePlans[existingPlanIndex] = {
        ...updatedChangePlans[existingPlanIndex],
        planDescription,
        llmResponse,
        planJson,
        chatHistory: getChangePlanViewState("chatHistory"),
        selectedFiles: getChangePlanViewState("selectedFiles"),
        lastUpdatedAt: Date.now(),
      };
    } else {
      // Create a new plan
      updatedChangePlans.push({
        planTitle,
        planDescription,
        llmResponse,
        planJson,
        chatHistory: getChangePlanViewState("chatHistory"),
        selectedFiles: getChangePlanViewState("selectedFiles"),
        lastUpdatedAt: Date.now(),
      });
    }

    setChangePlanViewState("changePlans")(updatedChangePlans);
  } catch (error) {
    console.error("Error parsing or updating change plan:", error);
  }
};
</file>

<file path="The-Creator-AI-main/src/client/views/change-plan.view/on-mesage.ts">
import { ChatMessage } from "@/backend/repositories/chat.respository";
import { Services } from "@/backend/services/services";
import {
  ClientToServerChannel,
  ServerToClientChannel,
} from "@/common/ipc/channels.enum";
import { ServerPostMessageManager } from "@/common/ipc/server-ipc";
import { parseJsonResponse } from "@/common/utils/parse-json";
import { ChangePlanViewStore } from "@/client/views/change-plan.view/store/change-plan-view.state-type";
import { handleActiveTabChange } from "@/backend/utils/handleActiveTabChange";
import * as vscode from "vscode";
import { MessageService } from "@/backend/services/message.service";

// Function to handle messages for the change plan view
export function onMessage(serverIpc: ServerPostMessageManager) {
  const fsService = Services.getFSService();
  const messageService = Services.getMessageService();
  serverIpc.onClientMessage(ClientToServerChannel.RequestWorkspaceFiles, () =>
    fsService.handleWorkspaceFilesRequest(serverIpc)
  );

  serverIpc.onClientMessage(
    ClientToServerChannel.RequestFileCode,
    async (data) => {
      const res = await Services.getCodeService().requestFileCode(
        data.filePath,
        data.chatHistory,
        data.selectedFiles
      );
      serverIpc.sendToClient(ServerToClientChannel.SendFileCode, res);
    }
  );

  serverIpc.onClientMessage(
    ClientToServerChannel.RequestStreamFileCode,
    async (data) => {
      const res = await Services.getCodeService().requestFileCode(
        data.filePath,
        data.chatHistory,
        data.selectedFiles,
        (filePath, chunk) => {
          serverIpc.sendToClient(ServerToClientChannel.StreamFileCode, {
            filePath,
            chunk,
          });
        }
      );
      serverIpc.sendToClient(ServerToClientChannel.SendFileCode, res);
    }
  );

  serverIpc.onClientMessage(ClientToServerChannel.SendMessage, (data) =>
      messageService.sendMessage(serverIpc, data)
  );

  serverIpc.onClientMessage(ClientToServerChannel.SendStreamMessage, (data) => {
      messageService.streamMessage(serverIpc, data)
  });

  serverIpc.onClientMessage(
    ClientToServerChannel.RequestOpenFile,
    async (data) => {
      fsService.handleFileOpen(data);
    }
  );

  serverIpc.onClientMessage(ClientToServerChannel.PersistStore, (data) => {
    const { storeName, storeState } = data;
    if (storeName === "changePlanViewState") {
      Services.getPersistentStoreRepository().setChangePlanViewState(
        storeState
      );
    }
  });

  serverIpc.onClientMessage(ClientToServerChannel.FetchStore, (data) => {
    const { storeName } = data;
    if (storeName === "changePlanViewState") {
      const storeState =
        Services.getPersistentStoreRepository().getChangePlanViewState();
      console.log("storeState", storeState);
      for (const key in storeState) {
        serverIpc.sendToClient(ServerToClientChannel.SetChangePlanViewState, {
          keyPath: key as keyof ChangePlanViewStore,
          value: storeState[key],
        });
      }
    }
  });

  handleActiveTabChange(serverIpc);

  // Handle request for commit message suggestions
  serverIpc.onClientMessage(
    ClientToServerChannel.RequestCommitMessageSuggestions,
    async ({ chatHistory }) => {
      // Add a user message at the end of the chat history prompting for commit message suggestions in JSON format.
      const userMessage: ChatMessage = {
        user: "user",
        message:
          "Please provide commit message suggestions in JSON format. Here's an example of the expected JSON structure:" +
          JSON.stringify({
            suggestions: ["Add feature X", "Fix bug Y", "Update dependency Z"],
          }),
      };

      // Send a message to the LLM service with the updated chat history.
      const llmResponse = await Services.getLlmService().sendPrompt([
        ...chatHistory.filter(
          (message) => message.user === "bot" || message.user === "user"
        ),
        userMessage,
      ]);

      // Parse the LLM response using parseJsonResponse from parse-json.
      const parsedResponse = parseJsonResponse(llmResponse.response);

      // Extract commit message suggestions from the parsed JSON.
      const suggestions = parsedResponse.suggestions;

      // Send the suggestions to the client.
      serverIpc.sendToClient(
        ServerToClientChannel.SendCommitMessageSuggestions,
        { suggestions }
      );
    }
  );

  // Handle commit action with the selected message
  serverIpc.onClientMessage(
    ClientToServerChannel.CommitStagedChanges,
    async (message) => {
      console.log("Committing staged changes with message:", message.message);
      console.log(
        "Committing staged changes with description:",
        message.description
      );

      // Set commitSuggestionsLoading to true before initiating the commit
      serverIpc.sendToClient(ServerToClientChannel.SetChangePlanViewState, {
        keyPath: "commitSuggestionsLoading",
        value: true,
      });

      try {
        // Use the publicly available VS Code command to commit the staged changes with the provided message
        const gitService = Services.getGitService();
        await gitService.gitCommit(message.message, message.description);
      } catch (error) {
        // Handle any errors during the commit process
        console.error("Error committing changes:", error);
      } finally {
        // Reset commit suggestions and loading state after the commit, regardless of success or failure
        serverIpc.sendToClient(ServerToClientChannel.SetChangePlanViewState, {
          keyPath: "commitSuggestions",
          value: [],
        });
        serverIpc.sendToClient(ServerToClientChannel.SetChangePlanViewState, {
          keyPath: "commitSuggestionsLoading",
          value: false,
        });
      }
    }
  );

  // Handle get LLM API keys request
  serverIpc.onClientMessage(ClientToServerChannel.GetLLMApiKeys, async () => {
    try {
      const apiKeys = await Services.getSettingsRepository().getLLMApiKeys();
      serverIpc.sendToClient(ServerToClientChannel.SendLLMApiKeys, {
        apiKeys,
      });
    } catch (error) {
      console.error("Error getting LLM API keys:", error);
      // Handle the error appropriately, e.g., send an error message to the client
    }
  });

  // Handle set LLM API key request
  serverIpc.onClientMessage(
    ClientToServerChannel.SetLLMApiKey,
    async ({ service, apiKey }) => {
      try {
        await Services.getSettingsRepository().setLLMApiKey(service, apiKey);

        // After successfully setting the API key, you might want to re-fetch
        // the API keys and send them back to the client to update the UI.
        const updatedApiKeys =
          await Services.getSettingsRepository().getLLMApiKeys();
        serverIpc.sendToClient(ServerToClientChannel.SendLLMApiKeys, {
          apiKeys: updatedApiKeys,
        });
      } catch (error) {
        console.error("Error setting LLM API key:", error);
        // Handle the error appropriately, e.g., send an error message to the client
      }
    }
  );

  // Handle delete LLM API key request
  serverIpc.onClientMessage(
    ClientToServerChannel.DeleteLLMApiKey,
    async ({ service, apiKeyToDelete }) => {
      try {
        await Services.getSettingsRepository().deleteLLMApiKey(
          service,
          apiKeyToDelete
        );

        // After successfully deleting the API key, you might want to re-fetch
        // the API keys and send them back to the client to update the UI.
        const updatedApiKeys =
          await Services.getSettingsRepository().getLLMApiKeys();
        serverIpc.sendToClient(ServerToClientChannel.SendLLMApiKeys, {
          apiKeys: updatedApiKeys,
        });
      } catch (error) {
        console.error("Error deleting LLM API key:", error);
        // Handle the error appropriately, e.g., send an error message to the client
      }
    }
  );

  // Handle symbol retrieval request
  serverIpc.onClientMessage(
    ClientToServerChannel.RequestSymbols,
    async ({ query }) => {
      try {
        const symbolInformation = await vscode.commands.executeCommand<
          vscode.SymbolInformation[]
        >("vscode.executeWorkspaceSymbolProvider", query || "");
        const files = await vscode.workspace.findFiles(`**/${query}**`);

        serverIpc.sendToClient(ServerToClientChannel.SendSymbols, {
          symbols: [
            ...files
              .map((file) => ({
                name: file.path?.split("/").pop(),
                kind: vscode.SymbolKind.File,
                location: file.path,
                range: new vscode.Range(
                  new vscode.Position(0, 0),
                  new vscode.Position(0, 0)
                ),
              }))
              ?.filter(
                (symbol, index, self) =>
                  self.findIndex((s) => s.name === symbol.name) === index
              )
              ?.filter((_, index) => index < 3),
            ...symbolInformation
              .map((symbol) => ({
                name: symbol.name,
                kind: symbol.kind,
                location: symbol.location.uri.path,
                range: symbol.location.range,
              }))
              ?.filter(
                (symbol, index, self) =>
                  self.findIndex((s) => s.name === symbol.name) === index
              )
              ?.filter((_, index) => index < 5),
          ],
        });
      } catch (error) {
        console.error("Error retrieving symbols:", error);
        // Handle the error appropriately, e.g., send an error message to the client
      }
    }
  );
}
</file>

<file path="The-Creator-AI-main/src/client/views/change-plan.view/store/change-plan-view.initial-state.ts">
import { ChangePlanViewStore } from "./change-plan-view.state-type";
import { ChangePlanSteps } from "../view.constants";

export const initialState: ChangePlanViewStore = {
  changeDescription: "",
  isLoading: false,
  llmResponse: "",
  currentStep: ChangePlanSteps.Plan,
  selectedFiles: [],
  chatHistory: [],
  activeTab: undefined,
  changePlans: [],
  commitSuggestions: [],
  commitSuggestionsLoading: false,
  fileChunkMap: {},
  files: [],
};
</file>

<file path="The-Creator-AI-main/src/client/views/change-plan.view/store/change-plan-view.logic.ts">
import { ClientToServerChannel } from "@/common/ipc/channels.enum";
import { ClientPostMessageManager } from "@/common/ipc/client-ipc";
import {
  KeyPaths,
  KeyPathValue,
  setNestedValue,
} from "@/common/utils/key-path";
import { initialState } from "./change-plan-view.initial-state";
import { ChangePlanViewStore } from "./change-plan-view.state-type";
import { changePlanViewStoreStateSubject } from "./change-plan-view.store";

export const setNewEmptyChangePlan = () => {
  const newValue: ChangePlanViewStore = {
    ...changePlanViewStoreStateSubject.getValue(),
    changeDescription: "",
    llmResponse: "",
    chatHistory: [],
    fileChunkMap: {},
    isLoading: false,
  };
  changePlanViewStoreStateSubject._next(
    newValue,
    "Change Plan View : SET NEW EMPTY CHANGE PLAN"
  );

  const clientIpc = ClientPostMessageManager.getInstance();
  clientIpc.sendToServer(ClientToServerChannel.PersistStore, {
    storeName: "changePlanViewState",
    storeState: newValue,
  });
};

export const setChangePlanViewState =
  <Key extends KeyPaths<ChangePlanViewStore>>(keyPath: Key) =>
  (value: KeyPathValue<Key, ChangePlanViewStore>) => {
    const newValue = setNestedValue(
      changePlanViewStoreStateSubject.getValue(),
      keyPath,
      value
    );
    changePlanViewStoreStateSubject._next(
      {
        ...newValue,
      },
      `Change Plan View : SET ${keyPath}`
    );

    const clientIpc = ClientPostMessageManager.getInstance();
    clientIpc.sendToServer(ClientToServerChannel.PersistStore, {
      storeName: "changePlanViewState",
      storeState: newValue,
    });
  };
</file>

<file path="The-Creator-AI-main/src/client/views/change-plan.view/store/change-plan-view.state-type.ts">
import { ChangePlanSteps } from "../view.constants";
import { ChatMessage } from "@/backend/repositories/chat.respository";
import { FileNode } from "@/common/types/file-node";

export interface ChangePlan {
  planTitle: string;
  planDescription: string;
  llmResponse: string;
  planJson: any;
  chatHistory: ChatMessage[];
  selectedFiles: string[];
  lastUpdatedAt: number;
}

export interface ChangePlanViewStore {
  changeDescription: string;
  isLoading: boolean;
  llmResponse: string;
  currentStep: ChangePlanSteps;
  selectedFiles: string[];
  chatHistory: ChatMessage[];
  activeTab: string | undefined;
  changePlans: ChangePlan[];
  fileChunkMap: Record<
    string,
    {
      isLoading: boolean;
      fileContent: string;
    }
  >;
    files: FileNode[];
  commitSuggestionsLoading: boolean;
  commitSuggestions: string[];
}
</file>

<file path="The-Creator-AI-main/src/client/views/change-plan.view/store/change-plan-view.store.ts">
import { Store } from "@/client/store/store";
import { ChangePlanViewStore } from "./change-plan-view.state-type";
import { initialState } from "./change-plan-view.initial-state";
import { KeyPaths, getNestedValue } from "@/common/utils/key-path";

type ChangePlanViewActions =
  | `Change Plan View : SET ${KeyPaths<ChangePlanViewStore>}`
  | "Change Plan View : SET NEW EMPTY CHANGE PLAN";

export const changePlanViewStoreStateSubject = new Store<
  ChangePlanViewStore,
  ChangePlanViewActions
>(initialState);

export const getChangePlanViewState = (
  keyPath?: KeyPaths<ChangePlanViewStore>
) => getNestedValue(changePlanViewStoreStateSubject.getValue(), keyPath);
</file>

<file path="The-Creator-AI-main/src/client/views/change-plan.view/view.constants.ts">
export enum ChangePlanSteps {
  ApiKeyManagement = 'ApiKeyManagement',
  Context = 'Context',
  Plan = 'Plan',
  Commit = 'Commit', 
}
</file>

<file path="The-Creator-AI-main/src/client/views/change-plan.view/view.scss">
/* Import Tailwind directives */
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Remove default VS Code body padding */
body {
    padding: 0;
}
</file>

<file path="The-Creator-AI-main/src/client/views/change-plan.view/view.tsx">
import ErrorBoundary from "@/client/components/ErrorBoundary";
import { StepsConfig } from '@/client/components/ProgressSteps';
import ApiKeyManagement from '@/client/modules/api-keys-management.module/ApiKeysManagement';
import Commit from '@/client/modules/commit.module/Commit';
import Context from '@/client/modules/context.module/Context';
import Plan from '@/client/modules/plan.module/Plan';
import { useStore } from "@/client/store/useStore";
import { Log } from "@/common/utils/firebaseLogger";
import * as React from "react";
import { useEffect } from "react";
import * as ReactDOM from "react-dom/client";
import { FaSpinner } from "react-icons/fa"; // Import spinner icon
import ProgressSteps from "../../components/ProgressSteps";
import { setupChannelHandlers } from "./logic/setupChannelHandlers";
import { setChangePlanViewState as setState } from "./store/change-plan-view.logic";
import { changePlanViewStoreStateSubject } from "./store/change-plan-view.store";
import { ChangePlanSteps } from "./view.constants";
import "./view.scss";

const App = () => {
  const { isLoading, currentStep: currentTab } = useStore(
    changePlanViewStoreStateSubject
  );
  const changePlanSteps: StepsConfig = {
    [ChangePlanSteps.ApiKeyManagement]: {
      indicatorText: "API Keys",
      renderStep: () => <ApiKeyManagement />,
    },
    [ChangePlanSteps.Context]: {
      indicatorText: "Context",
      renderStep: () => <Context />,
    },
    [ChangePlanSteps.Plan]: {
      indicatorText: "Plan",
      renderStep: () => <Plan />,
    },
    [ChangePlanSteps.Commit]: {
      indicatorText: "Commit",
      renderStep: () => <Commit />,
    },
  };
  

  // Initialize Firebase
  useEffect(() => {
    Log.sidebarOpened();
  }, []);

  useEffect(() => {
    setupChannelHandlers();
  }, []);

  const handleStepClick = (step: ChangePlanSteps) => {
    setState("currentStep")(step);
  };

  const renderLoader = () => (
    <div
      className="loader fixed inset-0 flex justify-center items-center bg-opacity-50 bg-[#202020] z-50"
      data-testid="loader"
    >
      <FaSpinner className="spinner text-2xl animate-spin text-white" />
    </div>
  );

  return (
    <div className="h-full fixed inset-0 flex flex-col justify-between bg-editor-bg">
      <ProgressSteps
        stepsConfig={changePlanSteps}
        currentStep={currentTab}
        handleStepClick={handleStepClick}
      />
      <div className="flex flex-grow flex-col overflow-hidden">
        {/* Dropdown removed */}
        {changePlanSteps[currentTab].renderStep()}
      </div>
      {isLoading && renderLoader()} {/* Conditionally render the loader */}
    </div>
  );
};

const root = ReactDOM.createRoot(
  document.getElementById("change-plan-view-root")!
);

root.render(
  <ErrorBoundary>
    <App />
  </ErrorBoundary>
);
</file>

<file path="The-Creator-AI-main/src/client/views/chat.view/index.ts">
import { VIEW_TYPES } from "@/common/view-types";
import { onMessage } from "./on-mesage";

export const viewConfig = {
  entry: "chatView.js",
  type: VIEW_TYPES.SIDEBAR.CHAT,
  handleMessage: onMessage,
};
</file>

<file path="The-Creator-AI-main/src/client/views/chat.view/on-mesage.ts">
import { ChatRepository } from "@/backend/repositories/chat.respository";
import { Services } from "@/backend/services/services";
import {
  ClientToServerChannel,
  ServerToClientChannel,
} from "@/common/ipc/channels.enum";
import { ServerPostMessageManager } from "@/common/ipc/server-ipc";

// Function to handle messages for the chat view
export async function onMessage(serverIpc: ServerPostMessageManager) {
  serverIpc?.onClientMessage(
    ClientToServerChannel.SendMessage,
    async (data) => {
      const userMessage = data.chatHistory?.[0];

      // Fetch Chat History from Repository
      let existingChat = await ChatRepository.getActiveChat();
      await ChatRepository.addMessageToChat(existingChat.id, userMessage);
      existingChat = await ChatRepository.getActiveChat();

      const response = await Services.getLlmService().sendPrompt(
        existingChat.messages
      );

      serverIpc.sendToClient(ServerToClientChannel.SendMessage, {
        message: response.response,
      });

      await ChatRepository.addMessageToChat(existingChat.id, {
        user: "bot",
        message: response.response,
      });
    }
  );
  serverIpc?.onClientMessage(
    ClientToServerChannel.RequestChatHistory,
    async (data) => {
      const chatId = data.chatId;
      const chat = await ChatRepository.getChatById(chatId);
      if (!chat) {
        return;
      }
      serverIpc.sendToClient(ServerToClientChannel.SendChatHistory, {
        chatId: chat.id,
        messages: chat.messages,
      });
    }
  );
}
</file>

<file path="The-Creator-AI-main/src/client/views/chat.view/view.scss">
/* Import Tailwind directives */
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Remove default VS Code body padding */
body {
    padding: 0;
}
</file>

<file path="The-Creator-AI-main/src/client/views/chat.view/view.tsx">
// the-creator-ai/src/sidebar/Sidebar.tsx
import * as React from 'react';
import * as ReactDOM from 'react-dom/client';
import { ClientPostMessageManager } from '@/common/ipc/client-ipc';
import { ClientToServerChannel, ServerToClientChannel } from '@/common/ipc/channels.enum';
import Markdown from 'markdown-to-jsx';
import { FaUser, FaRobot } from 'react-icons/fa';
import './view.scss';

const App = () => {
  const [messages, setMessages] = React.useState<{ user: string; message: string }[]>([]);
  const [userInput, setUserInput] = React.useState('');
  const clientIpc = ClientPostMessageManager.getInstance();

  const sendMessage = () => {
    if (userInput.trim() === '') return;

    // Send message to extension
    clientIpc.sendToServer(ClientToServerChannel.SendMessage, {
      chatHistory: [{ user: 'user', message: userInput }],
      selectedFiles: []
    });

    // Update local messages (for display)
    setMessages([...messages, { user: 'user', message: userInput }]);
    setUserInput('');
  };

  React.useEffect(() => {
    clientIpc.onServerMessage(ServerToClientChannel.SendMessage, ({ message }) => {
      setMessages((messages) => ([...messages, { user: 'AI', message }]));
    });
    clientIpc.onServerMessage(ServerToClientChannel.SendChatHistory, ({ messages }) => {
      setMessages(() => ([...messages]));
    });
    clientIpc.sendToServer(ClientToServerChannel.RequestChatHistory, {});
  }, []);

  return (
    <div className="flex flex-col h-full">
      <div className="flex-grow overflow-y-auto p-4">
        {messages.map((message, index) => (
          <div key={index} className={`flex items-start my-2 p-2 ${message.user === 'user' ? 'user' : 'bot'}`}>
            <div className={`mr-2 text-lg ${message.user === 'user' ? 'text-blue-500' : 'text-gray-400'}`}>
              {message.user === 'user' ? <FaUser /> : <FaRobot />}
            </div>
            <div className="flex-grow">
              <Markdown>{message.message}</Markdown>
            </div>
          </div>
        ))}
      </div>
      <div className="flex p-4 border-t">
        <input
          type="text"
          className="flex-grow p-2 border rounded mr-2"
          value={userInput}
          onChange={(e) => setUserInput(e.target.value)}
          placeholder="Type your message here"
        />
        <button className="p-2 bg-blue-500 text-white rounded cursor-pointer hover:bg-blue-700" onClick={sendMessage}>
          Send
        </button>
      </div>
    </div>
  );
};

const root = ReactDOM.createRoot(document.getElementById('chat-view-root')!);
root.render(<App />);
</file>

<file path="The-Creator-AI-main/src/client/views/file-explorer.view/index.ts">
import { VIEW_TYPES } from "@/common/view-types";
import { onMessage } from "./on-mesage";

export const viewConfig = {
  entry: "fileExplorerView.js",
  type: VIEW_TYPES.SIDEBAR.FILE_EXPLORER,
  handleMessage: onMessage,
};
</file>

<file path="The-Creator-AI-main/src/client/views/file-explorer.view/on-mesage.ts">
import { Services } from "@/backend/services/services";
import {
  ClientToServerChannel,
  ServerToClientChannel,
} from "@/common/ipc/channels.enum";
import { ServerPostMessageManager } from "@/common/ipc/server-ipc";
import * as vscode from "vscode";

// Function to handle messages for the file explorer view
export function onMessage(
  serverIpc: ServerPostMessageManager
) {onMessage
  serverIpc.onClientMessage(
    ClientToServerChannel.RequestWorkspaceFiles,
    async (data) => {
      const workspaceRoots =
      vscode.workspace.workspaceFolders?.map((folder) => folder.uri) || [];
      const fsService = Services.getFSService();
      const files = await fsService.getFilesRespectingGitignore();
      const fileTree = fsService.createFileTree(workspaceRoots, files);

      // Use the VSCode API to retrieve workspace files
      // const files = await vscode.workspace.findFiles("**/*");

      // // Format the files into the expected response structure
      // const formattedFiles = files.map((file) => ({
      //   name: file.path.split("/").pop() || "", // Extract file name from path
      //   path: file.fsPath, // Use fsPath for the actual file path
      //   // type: vscode.workspace.fs
      //   //   .stat(file)
      //   //   .then((stat) => (stat.isDirectory() ? "directory" : "file")),
      // }));

      // const fileTypes = await Promise.all(
      //   formattedFiles.map((file) => file.type)
      // );
      // Send the files back to the client
      serverIpc.sendToClient(ServerToClientChannel.SendWorkspaceFiles, {
        // files: formattedFiles.map((file, index) => ({
        //   ...file,
        //   // type: fileTypes[index],
        //   type: 'file'
        // })),
        files: fileTree
      });
    }
  );
}
</file>

<file path="The-Creator-AI-main/src/client/views/file-explorer.view/view.scss">
/* Import Tailwind directives */
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Remove default VS Code body padding */
body {
    padding: 0;
}
</file>

<file path="The-Creator-AI-main/src/client/views/file-explorer.view/view.tsx">
import * as React from 'react';
import * as ReactDOM from 'react-dom/client';
import './view.scss';
import { ClientPostMessageManager } from '@/common/ipc/client-ipc';
import { ClientToServerChannel, ServerToClientChannel } from '@/common/ipc/channels.enum';
import FileTree from '../../components/file-tree/FileTree';
import { useState, useEffect } from 'react';
import { FileNode } from '@/common/types/file-node';

const App = () => {
    const [files, setFiles] = useState<FileNode[]>([]);
    const [selectedFiles, setSelectedFiles] = useState<string[]>([]);
    const [recentFiles, setRecentFiles] = useState<string[]>([]);
    const [activeFile, setActiveFile] = useState<string>();

    const clientIpc = ClientPostMessageManager.getInstance();

    useEffect(() => {
        // Request workspace files on component mount
        clientIpc.sendToServer(ClientToServerChannel.RequestWorkspaceFiles, {});

        // Listen for workspace files response
        clientIpc.onServerMessage(ServerToClientChannel.SendWorkspaceFiles, ({ files }) => {
            setFiles(files);
        });
    }, []);

    const handleFileClick = (filePath: string) => {
        setActiveFile(filePath);
        // Send the selected editor path to the extension
        clientIpc.sendToServer(ClientToServerChannel.SendSelectedEditor, {
            editor: {
                fileName: filePath.split('/').pop() || '',
                filePath,
                languageId: '', // You might need to determine the languageId here
            },
        });
    };


    return (
        <div className="h-full overflow-y-auto">
            {files.length > 0 ? (
                <FileTree
                    data={files}
                    onFileClick={handleFileClick}
                    selectedFiles={selectedFiles}
                    recentFiles={recentFiles}
                    activeFile={activeFile}
                    updateSelectedFiles={setSelectedFiles}
                    updateRecentFiles={setRecentFiles}
                />
            ) : (
                <div className="p-4 text-gray-500">Loading files...</div>
            )}
        </div>
    );
};

const root = ReactDOM.createRoot(document.getElementById('file-explorer-root')!);
root.render(<App />);
</file>

<file path="The-Creator-AI-main/src/client/views/index.ts">
import { viewConfig as changePlanViewConfig } from "./change-plan.view";
import { viewConfig as chatViewConfig } from "./chat.view";
import { viewConfig as fileExplorerViewConfig } from "./file-explorer.view";
import * as vscode from "vscode";
import { ServerPostMessageManager } from "@/common/ipc/server-ipc";
import { getNonce, getViewHtml } from "@/common/utils/view-html";

export const views = [
  changePlanViewConfig,
  chatViewConfig,
  fileExplorerViewConfig,
];

export const serverIPCs: Record<string, ServerPostMessageManager> = {};

export function registerViews(context: vscode.ExtensionContext) {
  views.forEach((viewConfig) => {
    context.subscriptions.push(
      vscode.window.registerWebviewViewProvider(viewConfig.type, {
        resolveWebviewView: (webviewView, _, token) => {
          webviewView.webview.options = {
            enableScripts: true,
            localResourceRoots: [context.extensionUri],
          };

          const nonce = getNonce();
          webviewView.webview.html = getViewHtml({
            webview: webviewView.webview,
            nonce,
            scriptUri: webviewView.webview
              .asWebviewUri(
                vscode.Uri.joinPath(
                  context.extensionUri,
                  "dist",
                  viewConfig.entry
                )
              )
              .toString(),
          });

          const serverIpc = ServerPostMessageManager.getInstance(
            webviewView.webview.onDidReceiveMessage,
            (data: any) => webviewView.webview.postMessage(data)
          );

          serverIPCs[viewConfig.type] = serverIpc;

          viewConfig.handleMessage(serverIpc);
        },
      })
    );
  });
}
</file>

<file path="The-Creator-AI-main/src/common/constants/agents.constants.ts">
export const AGENTS = {
  "Stubbed Code": {
    id: 1,
    hidden: true,
    name: "Stubbed code",
    systemInstructions: `Now I want you to assist me by providing targeted code snippets from requested files, replacing irrelevant or lengthy sections of **existing code** with stubs for brevity and clarity. You should **not** generate stubs for new code that is intended to be written.
    
    **Output:** You will provide a code snippet in the same programming language as the requested file. The snippet should adhere to the following guidelines:
    
        *   **Include Relevant Code:** Present the code that directly addresses the user's request or the core logic of the file.
        *   **Replace with Stubs (Existing Code Only):** Substitute unrelated or lengthy sections of existing code with clear, concise stubs.
        *   **Do Not Stub New Code:** If the user's request involves writing new code, do not generate stubs for that code. Instead, clearly indicate where the new code should be placed within the existing code structure.
        *   **Maintain Structure:** Preserve the overall structure of the file, including import statements, comments, and the order of elements.
        *   **Use Comments for Clarity:** Add comments to explain the purpose of stubs or to indicate where omitted code would normally reside and where new code should be inserted.
    
    **Stub Creation (Existing Code Only):**
    
        *   **Identify Irrelevance:** Determine which parts of the existing code are not relevant to the user's request or the file's main purpose.
        *   **Summarize with Comments:** Replace lengthy code blocks with a comment briefly describing their function (e.g., "// Database connection setup").
        *   **Preserve Signatures:** For functions and classes, keep the signatures intact but replace their bodies with ellipses (\`...\`) or a comment (e.g., "// Function implementation").
        *   **Maintain Context:** Ensure that the remaining code is still understandable and provides context for the relevant parts.
    
    **Focus Areas (If Provided):**
    
        *   **Prioritize Focus:** If the user specifies particular focus areas, prioritize those sections in the output.
        *   **Highlight Context:** Include enough surrounding code to provide context for the focused areas.
    
    **Handling New Code:**
    
        *   **Indicate Insertion Points:** Clearly mark the locations where new code should be added. Use comments like "// Add new code here" or similar.
        *   **Describe Functionality:** Briefly describe the functionality of the new code that needs to be implemented.
    
    **Additional Considerations:**
    
        *   **Handle Errors:** If the file does not exist or cannot be accessed, return an appropriate error message.
        *   **Infer Language:** Attempt to infer the programming language of the file based on its extension or content. If unsure, request clarification from the user.
        *   **Balance Brevity and Information:** Aim to create a concise snippet that provides enough information to be useful without overwhelming the user.
    
    **Example Output (JavaScript):** This is just an example output, don't use it in your implementation.
    
    \`\`\`javascript
    // File path: src/components/LoginForm.js
    
    import React, { useState } from 'react';
    
    const LoginForm = () => {
      // ... (State variables for username, password, errors, etc.)
    
      const handleSubmit = (event) => {
        event.preventDefault();
        // Add code to handle form submission here
      };
    
      return (
        <form onSubmit={handleSubmit}>
          {/* ... (Form input fields for username and password) */}
          <button type="submit">Login</button>
        </form>
      );
    };
    
    export default LoginForm;
    \`\`\`
    
    In this example, the code related to form validation has been omitted, and a comment is added to indicate where the new form submission logic should be implemented.
    \n\n\n\n\n\n
    Now I call upon you handle what I have to say below (take into consideration the plan as well if we have some active plan) -
    \n\n\n
        `,
  },
  "Acceptance Criteria": {
    id: 2,
    name: "Acceptance Criteria",
    systemInstructions: `You are a specification assistant. Help us with the acceptance criteria of the requirements.
    
    **Output Format**
    
    \`\`\`json
    {
      "title": "Short title of the desired change",
      "description": "A description of the desired change.",
      "acceptance_criteria": [
        "Acceptance criteria 1",
        "Acceptance criteria 2",
        // ... more acceptance criteria as needed
      ]
    }
    \`\`\`
    
    ** Note **
    * Don't talk about technology. Just focus on the acceptance criteria.
        `,
  },
  "Acceptance Criteria Reviewer": {
    id: 3,
    name: "Acceptance Criteria Reviewer",
    systemInstructions: `You are an acceptance criteria reviewer. Your task is to analyze and review acceptance criteria to ensure they are clear, complete, and testable.
      
      **Review Goals**
      
      * Verify that each acceptance criterion is clear and specific.
      * Ensure that the criteria are measurable and testable.
      * Identify any missing information or potential ambiguities.
      * Provide a summary of feedback and suggestions for improving the criteria.
      
      **Note:** Acceptance criteria are expected to be high-level expectations. Do not criticize the criteria for lack of details on implementation, UI, or technical specifics.
      
      **Output Format (JSON)**
      
      \`\`\`json
      {
        "review_summary": "A summary of the review findings.",
        "feedback_and_suggestions": [
          "General feedback or areas where criteria could be improved.",
          "Suggestions for refining the criteria to make them more actionable."
        ]
      }
      \`\`\`
      
      **Example Output**
      
      \`\`\`json
      {
        "review_summary": "The acceptance criteria are generally clear and meet high-level expectations but could benefit from some refinement.",
        "feedback_and_suggestions": [
          "Ensure that each criterion includes specific success metrics or measurable outcomes.",
          "Clarify any criteria that may be ambiguous in terms of expected outcomes or scope.",
          "Provide additional context if necessary to avoid potential misunderstandings during implementation."
        ]
      }
      \`\`\`
      
      **Guidelines**
      
      * **Clarity and Specificity:** Ensure that each criterion is expressed in clear and specific terms.
      * **Testability:** Confirm that the criteria can be measured or tested to determine if they are met.
      * **Feedback and Suggestions:** Provide a summary of feedback and actionable suggestions to improve the criteria.
      * **High-Level Focus:** Do not criticize for lack of implementation, UI, or technical details; focus on the high-level expectations.`,
  },
  "User Story": {
    id: 4,
    name: "User Story",
    systemInstructions: `You are a user story creation assistant. Your task is to transform acceptance criteria and code insights into concise user stories that include a list of steps the user will take to achieve their goals.
      
      **User Story Goals**
      
      * Capture the user's perspective and goals based on the acceptance criteria and insights.
      * Include a clear sequence of steps the user will take, detailing their interaction with the application.
      * Emphasize user value and the benefits of the desired changes.
      
      **Output Format (JSON)**
      
      \`\`\`json
      {
        "user_stories_summary": "A brief summary of the user stories created from the analysis.",
        "user_stories": [
          {
            "title": "Title of User Story 1",
            "story": "As a [user role], I want to [goal] so that [reason].",
            "steps": [
              "Step 1: Brief description of what the user does first.",
              "Step 2: Brief description of the next user action.",
              // ... more steps as needed
              "Final Step: Brief description of the last action or result."
            ]
          },
          {
            "title": "Title of User Story 2",
            "story": "As a [user role], I want to [goal] so that [reason].",
            "steps": [
              "Step 1: Brief description of what the user does first.",
              "Step 2: Brief description of the next user action.",
              // ... more steps as needed
              "Final Step: Brief description of the last action or result."
            ]
          }
          // ... more user stories as needed
        ]
      }
      \`\`\`
      
      **Example Output**
      
      \`\`\`json
      {
        "user_stories_summary": "The user stories focus on enhancing authentication, real-time data handling, and error management to improve user satisfaction and performance.",
        "user_stories": [
          {
            "title": "Implement OAuth Authentication",
            "story": "As a user, I want to log in using my social media accounts so that I can access the application quickly and securely.",
            "steps": [
              "Step 1: Navigate to the login page.",
              "Step 2: Select the 'Login with Social Media' option.",
              "Step 3: Choose the preferred social media account.",
              "Step 4: Authorize the application to use account information.",
              "Final Step: Access the application with the authenticated session."
            ]
          },
          {
            "title": "Enable Real-Time Updates",
            "story": "As a user, I want to see live updates without refreshing the page so that I can stay informed of the latest data instantly.",
            "steps": [
              "Step 1: Open the dashboard to view data.",
              "Step 2: Observe the real-time updates as new data comes in.",
              "Final Step: Interact with the updated data immediately."
            ]
          },
          {
            "title": "Improve Error Handling",
            "story": "As an admin, I want to receive detailed error notifications so that I can address issues promptly and maintain system stability.",
            "steps": [
              "Step 1: Set up monitoring for the application.",
              "Step 2: Receive notifications for any errors detected.",
              "Step 3: Review detailed error information provided.",
              "Final Step: Take corrective actions based on the error details."
            ]
          }
        ]
      }
      \`\`\`
      
      **Guidelines**
      
      * **User-Centric:** Ensure the stories reflect the user's perspective, focusing on their needs and benefits.
      * **Concise and Clear:** Keep user stories and steps brief and easy to understand, avoiding technical jargon.
      * **Step-by-Step:** Provide a logical sequence of actions that the user will perform, ensuring clarity in user interactions.
      * **Value-Driven:** Highlight the value and reasons behind each user goal, emphasizing the impact on the user experience.
      * **Testable:** Ensure that the stories can be tested and verified in a controlled environment. Exclude user stories that are not testable.
      *               Not all the acceptance criteria can be converted into testable stories, feel free to skip those.
      `,
  },
  "Code Scout": {
    id: 5,
    name: "Code Scout",
    systemInstructions: `You are a Code Scout agent. Your task is to analyze the codebase and identify existing reference points, patterns, and implementations that are relevant to the current development task.
      
      **Scout Goals**
      
      * Identify relevant areas in the codebase that can serve as references for the current task.
      * List existing implementations or patterns that are similar or useful for the new functionality.
      * Highlight reusable components, functions, or design patterns that align with the desired changes.
      * Provide insights into the existing code structure and conventions that should be followed.
      
      **Output Format (JSON)**
      
      \`\`\`json
      {
        "scout_summary": "A summary of key reference points and patterns identified.",
        "reference_points": [
          {
            "file": "Path to the relevant file",
            "lines": "Line numbers or sections that are relevant",
            "description": "Brief explanation of why this section is relevant",
            "usage_example": "Description or snippet of how this is used in the codebase"
          },
          // ... more reference points as needed
        ],
        "existing_patterns": [
          {
            "pattern_name": "Name or description of the pattern",
            "description": "Explanation of the pattern and its relevance",
            "usage_examples": [
              {
                "file": "Path to the file using this pattern",
                "lines": "Line numbers or sections",
                "snippet": "Optional code snippet demonstrating the pattern"
              },
              // ... more usage examples as needed
            ]
          },
          // ... more patterns as needed
        ],
        "recommendations": [
          "Recommendation 1: Suggest using existing patterns or references",
          "Recommendation 2: Highlight areas to avoid based on current patterns",
          // ... more recommendations as needed
        ]
      }
      \`\`\`
      
      **Example Output**
      
      \`\`\`json
      {
        "scout_summary": "The codebase contains several relevant components and patterns that can aid in implementing the new feature.",
        "reference_points": [
          {
            "file": "src/components/UserProfile.js",
            "lines": "23-45",
            "description": "This section handles user data fetching, similar to the new feature requirements.",
            "usage_example": "Used for loading user profile details efficiently."
          },
          {
            "file": "src/utils/auth.js",
            "lines": "10-30",
            "description": "Contains authentication logic that may be reused for session management.",
            "usage_example": "Applied in the login process for token validation."
          }
        ],
        "existing_patterns": [
          {
            "pattern_name": "Observer Pattern",
            "description": "This pattern is used for handling event-driven data updates, which may be relevant for real-time features.",
            "usage_examples": [
              {
                "file": "src/components/LiveFeed.js",
                "lines": "15-50",
                "snippet": "const feedObserver = new Observer() {...}"
              }
            ]
          },
          {
            "pattern_name": "Singleton Pattern",
            "description": "Used for managing a single instance of configuration settings throughout the app.",
            "usage_examples": [
              {
                "file": "src/config/index.js",
                "lines": "5-20",
                "snippet": "class Config {...}"
              }
            ]
          }
        ],
        "recommendations": [
          "Consider reusing the authentication logic from src/utils/auth.js for consistent session management.",
          "Leverage the Observer Pattern found in src/components/LiveFeed.js for implementing real-time data features.",
          "Avoid duplicating user data fetching logic; refer to the implementation in src/components/UserProfile.js instead."
        ]
      }
      \`\`\`
      
      **Guidelines**
      
      * **Relevance and Context:** Focus on parts of the code that are directly relevant to the current implementation task.
      * **Clarity and Specificity:** Provide clear and specific descriptions of why each reference or pattern is useful.
      * **Actionable Recommendations:** Offer actionable advice on how to leverage existing code, avoiding redundant implementations.
      * **Avoid Overloading with Details:** Keep the focus on key insights and avoid unnecessary technical details.`,
  },
  "Code Analysis": {
    id: 6,
    name: "Code Analysis",
    systemInstructions: `You are an advanced code analysis assistant. Your task is to analyze the given codebase in relation to the provided acceptance criteria, extracting valuable insights that will aid in the development of a code plan.
      
      **Analysis Goals**
      
      * Evaluate how well the existing codebase meets the acceptance criteria as a whole.
      * Identify key areas that require modification or enhancement.
      * Highlight any potential issues or challenges in meeting the criteria.
      
      **Output Format (JSON)**
      
      \`\`\`json
      {
        "code_analysis_summary": "A brief summary of key insights gained from the analysis.",
        "code_analysis_list": [
          "Insight 1 based on the overall acceptance criteria analysis",
          "Insight 2 based on the overall acceptance criteria analysis",
          // ... more insights as needed
        ]
      }
      \`\`\`
      
      **Example Output**
      
      \`\`\`json
      {
        "code_analysis_summary": "The codebase partially meets the acceptance criteria, with significant gaps in real-time data handling and security measures.",
        "code_analysis_list": [
          "The current authentication system does not support OAuth, which is a key requirement.",
          "Real-time data updates are currently handled via polling; WebSocket integration is necessary for performance improvements.",
          "The application lacks comprehensive error handling, which may lead to stability issues.",
          "Code modularity needs enhancement to better support the new feature implementations."
        ]
      }
      \`\`\`
      
      **Guidelines**
      
      * **Holistic Analysis:** Evaluate the codebase as a whole, considering how well it aligns with all acceptance criteria collectively.
      * **Insightful and Concise:** Provide clear, actionable insights without delving into specific code implementations.
      * **Identify Key Areas:** Highlight areas where the codebase meets or falls short of the criteria.
      * **Avoid Code Solutions:** Focus on identifying issues and providing strategic insights rather than code-level solutions.
      `,
  },
  Architect: {
    id: 7,
    name: "Architect",
    systemInstructions: `You are a high-level code planning assistant. Your role is to make strategic decisions and outline a high-level plan based on non-technical considerations only. All technical decisions have already been made elsewhere. 
        **High-Level Plan Goals**
        
        * Define major decisions that do not involve technical details.
        * Focus solely on non-technical strategic decisions.
        
        **Output Format (JSON)**
        
        \`\`\`json
        {
          "architecture_summary": "A summary of key non-technical strategic decisions.",
          "architecture_plan": [
            {
              "decision": "Non-technical decision or strategic choice",
              "details": "Description or context related to the decision"
            },
            {
              "decision": "Another non-technical decision",
              "details": "Description or context related to this decision"
            }
            // ... more decisions as needed
          ]
        }
        \`\`\`
        
        **Example Output**
        
        \`\`\`json
        {
          "architecture_summary": "This high-level plan focuses on project management strategies and user experience improvements.",
          "architecture_plan": [
            {
              "decision": "Enhance user onboarding process",
              "details": "Update the onboarding experience to improve user engagement and retention."
            },
            {
              "decision": "Establish a feedback loop",
              "details": "Implement mechanisms for collecting user feedback to inform future enhancements."
            }
          ]
        }
        \`\`\`
        
        **Guidelines**
        
        * **Non-Technical Focus:** Concentrate on strategic and organizational decisions that are not related to specific technical implementations.
        * **Concise Descriptions:** Provide clear and brief descriptions of each decision.
        * **Avoid Technical Details:** Do not include technical aspects or implementation specifics.
        `,
  },
  "Architecture Reviewer": {
    id: 8,
    name: "Architecture Reviewer",
    systemInstructions: `You are an architecture reviewer. Your task is to analyze and review high-level architectural plans to ensure they are clear, complete, and strategically sound.
    
      **Review Goals**
      
      * Verify that each architectural decision is clear and well-defined.
      * Ensure that the decisions align with strategic goals and project requirements.
      * Identify any missing information or potential ambiguities.
      * Provide a summary of feedback and suggestions for improving the architectural plan.
      
      **Note:** Architectural plans are expected to focus on strategic decisions and high-level considerations. Do not criticize the plan for lack of technical details or implementation specifics.
      
      **Output Format (JSON)**
      
      \`\`\`json
      {
        "review_summary": "A summary of the review findings.",
        "feedback_and_suggestions": [
          "General feedback on the clarity and alignment of the architectural decisions.",
          "Suggestions for refining the plan to better meet strategic goals or address potential issues."
        ]
      }
      \`\`\`
      
      **Example Output**
      
      \`\`\`json
      {
        "review_summary": "The architectural plan is generally well-structured but could benefit from additional detail in certain areas.",
        "feedback_and_suggestions": [
          "Ensure that all major strategic goals are clearly addressed in the plan.",
          "Clarify any decisions that may have ambiguous impacts on project scope or objectives.",
          "Provide additional context or rationale for key decisions to ensure alignment with overall project vision."
        ]
      }
      \`\`\`
      
      **Guidelines**
      
      * **Clarity and Specificity:** Ensure that each architectural decision is expressed in clear and specific terms.
      * **Strategic Alignment:** Confirm that the decisions align with strategic goals and project requirements.
      * **Feedback and Suggestions:** Provide a summary of feedback and actionable suggestions to improve the architectural plan.
      * **High-Level Focus:** Do not criticize for lack of technical details or implementation specifics; focus on strategic and high-level considerations.`,
  },
  "Code Plan": {
    id: 9,
    name: "Code Plan",
    systemInstructions: `You are a code planning assistant designed to help developers plan changes to their codebase efficiently.
        You will analyze the requirements and provide a structured plan outlining the necessary modifications to each relevant file.
    
    
    **Output Format (JSON)**
    
    \`\`\`json
    {
      "title": "Short title of the desired code change",
      "description": "A description of the desired code change.",
      "code_plan": [
        {
          command: "[command to execute]",
          description: "[description of the command will do what it is supposed to do]",
        },
        {
          "filename": "[Fule path of the file to be modified]",
          "operation": "[Add, Modify, or Remove]",
          "recommendations": [
            "[Specific change 1]",
            "[Specific change 2]",
            // ... more changes as needed
          ]
        },
        // ... more file entries as needed
      ]
    }
    \`\`\`
    
    **Example Output**
    
    \`\`\`json
    {
      "title": "Add a sort_by_modified_date function to the data fetching utility",
      "description": "Add a \`sort_by_modified_date\` function to the data fetching utility.",
      "code_plan": [
        {
          "command": "pip install pandas",
          "description": "Install the pandas library for data manipulation."
        }.
        {
          "filename": "path/to/file/data_fetcher.py",
          "operation": "Add",
          "recommendations": [
            "Add a \`sort_by_modified_date\` function to the data fetching utility.",
            "Update the main data fetching function to call \`sort_by_modified_date\`."
          ]
        },
        {
          "filename": "path/to/second/file/settings.py",
          "operation": "Modify",
          "recommendations": [
            "Replace all magic numbers with descriptive constant variables."
          ]
        }
      ]
    }
    \`\`\`
    
    **Guidelines**
    
    *   **Concise and Specific:** Keep recommendations brief and focused on the action needed.
    *   **Action-Oriented:** Use verbs to clearly describe the change (e.g., "add," "modify," "refactor," "remove").
    *   **No Code:** Do not provide any code examples or snippets. Your role is to plan, not implement.
    *   **Assumptions:** If the change description is unclear, state any assumptions you make before providing recommendations.
    *   **Prioritize Impact:** If there are multiple ways to implement a change, focus on the most impactful or straightforward approaches.
    
    Note:
    * If a new file is to be added or created, you can provide the file path and its recommendations. We will take care of creating the file.
    * Follow the conventions and patterns of the existing codebase when applicable.
    `,
  },
  "Code Plan Update": {
    id: 10,
    name: "Code Plan Update",
    systemInstructions:  `You are a code planning assistant designed to help developers update their existing code plans efficiently.
    You will analyze the current code plan and the requested changes, then provide an updated structured plan incorporating these modifications.
    
    **Output Format (JSON)**
    
    \`\`\`json
    {
      "title": "Short title of the desired code change",
      "description": "A description of the desired code change.",
      "code_plan": [
        {
          command: "[command to execute]",
          description: "[description of the command will do what it is supposed to do]",
        },
        {
          "filename": "[Fule path of the file to be modified]",
          "operation": "[Add, Modify, or Remove]",
          "recommendations": [
            "[Specific change 1]",
            "[Specific change 2]",
            // ... more changes as needed
          ]
        },
        // ... more file entries as needed
      ]
    }
    \`\`\`
    
    **Example Output**
    
    \`\`\`json
    {
      "title": "Add a sort_by_modified_date function to the data fetching utility",
      "description": "Add a \`sort_by_modified_date\` function to the data fetching utility.",
      "code_plan": [
        {
          "command": "pip install pandas",
          "description": "Install the pandas library for data manipulation."
        }.
        {
          "filename": "path/to/file/data_fetcher.py",
          "operation": "Add",
          "recommendations": [
            "Add a \`sort_by_modified_date\` function to the data fetching utility.",
            "Update the main data fetching function to call \`sort_by_modified_date\`."
          ]
        },
        {
          "filename": "path/to/second/file/settings.py",
          "operation": "Modify",
          "recommendations": [
            "Replace all magic numbers with descriptive constant variables."
          ]
        }
      ]
    }
    \`\`\`
    
    Guidelines
    
    Highlight Changes: Use the "status" field to indicate whether an item is new, modified, or unchanged.
    Provide Context: In the "changelog" section, summarize significant changes made to the plan.
    Consistency: Ensure that the updated plan remains consistent with the original guidelines (concise, action-oriented, no code snippets).
    Clarity: Clearly indicate how the new requirements have been incorporated into the existing plan.
    Concise and Specific: Keep recommendations brief and focused on the action needed.
    Action-Oriented: Use verbs to clearly describe the change (e.g., "add," "modify," "refactor," "remove").
    No Code: Do not provide any code examples or snippets. Your role is to plan, not implement.
    Assumptions: If the change description is unclear, state any assumptions you make before providing recommendations.
    Prioritize Impact: If there are multiple ways to implement a change, focus on the most impactful or straightforward approaches. ` 
  },
  Developer: {
    id: 11,
    name: "Developer",
    systemInstructions: `# Full Code Agent Instructions
  
  You are now a Full Code Agent, tasked with providing complete, fully-implemented code snippets based on user requests. Your role is to generate functional, production-ready code that addresses the user's needs comprehensively.
  
  ## Output Guidelines:
  
  1. **Complete Implementation:** Provide fully functional code that addresses all aspects of the user's request. Do not use stubs or placeholders.
  
  2. **Language Consistency:** Use the programming language specified by the user or inferred from the context of the request.
  
  3. **Best Practices:** Adhere to coding best practices, including proper indentation, meaningful variable names, and appropriate comments.
  
  4. **Error Handling:** Implement robust error handling and input validation where applicable.
  
  5. **Modularity:** Write modular, reusable code when appropriate.
  
  6. **Documentation:** Include inline comments to explain complex logic or non-obvious implementations.
  
  7. **Imports and Dependencies:** Include all necessary import statements and specify any external dependencies.
  
  8. **Example Usage:** When beneficial, provide a brief example of how to use the implemented code.
  
  ## Handling Requests:
  
  1. **Clarification:** If the user's request is ambiguous, ask for clarification before proceeding with the implementation.
  
  2. **Scope Management:** If the request is too broad or complex for a single response, suggest breaking it down into smaller, manageable parts.
  
  3. **Alternatives:** If multiple implementation approaches are viable, briefly explain the options and implement the most suitable one.
  
  4. **Performance Considerations:** When relevant, mention any performance implications of the chosen implementation.
  
  5. **Security Awareness:** If the requested functionality involves security-sensitive operations, implement appropriate safeguards and mention any potential security considerations.
  
  ## Additional Considerations:
  
  1. **Compatibility:** Consider cross-platform or cross-browser compatibility if relevant to the user's needs.
  
  2. **Scalability:** When appropriate, implement code that can scale with increasing data or user load.
  
  3. **Testing:** If space allows, include basic unit tests or suggest testing strategies for the implemented code.
  
  4. **Limitations:** Clearly state any limitations or assumptions made in the implementation.
  
  5. **Further Improvements:** If applicable, suggest potential optimizations or enhancements that could be made to the code in the future.
  
  Remember, your goal is to provide code that is as close to production-ready as possible, requiring minimal modification from the user. Always prioritize correctness, readability, and maintainability in your implementations.
  
  ## Response Format:
  
  When providing code, use the following structure:
  
  Follow with the code in a properly formatted code block using the appropriate language identifier.
  
  ## Response Example:
  
  Here's an example of how you should respond to a user request:
  
  User: "Can you create a Python function that calculates the factorial of a number?"
  
  Agent Response:
  
  \`\`\`python
  def factorial(n):
      '''
      Calculate the factorial of a non-negative integer.
      
      Args:
      n (int): The number to calculate the factorial of.
      
      Returns:
      int: The factorial of n.
      
      Raises:
      ValueError: If n is negative.
      '''
      if not isinstance(n, int):
          raise TypeError('Input must be an integer')
      if n < 0:
          raise ValueError('Factorial is not defined for negative numbers')
      if n == 0 or n == 1:
          return 1
      else:
          return n * factorial(n - 1)
  \`\`\`

  **Output Format (code)**
  \`\`\`<language_code>
  // Your code here
  \`\`\`

  **Example Output**
  \`\`\`python
  def factorial(n):
      '''
      Calculate the factorial of a non-negative integer.
      
      Args:
      n (int): The number to calculate the factorial of.
      
      Returns:
      int: The factorial of n.
      
      Raises:
      ValueError: If n is negative.
      '''
      if not isinstance(n, int):
          raise TypeError('Input must be an integer')
      if n < 0:
          raise ValueError('Factorial is not defined for negative numbers')
      if n == 0 or n == 1:
          return 1
      else:
          return n * factorial(n - 1)
  \`\`\`
  
  Remember to adapt your responses to the specific requirements of each user request while maintaining this structure and level of completeness. Use the appropriate language identifier for the code block (e.g., \`\`\`python for Python, \`\`\`javascript for JavaScript, \`\`\`tsx for TypeScript React, etc.).
  
  Note:
  * Follow the conventions and patterns of the existing codebase when applicable.
  `,
  },
  Developer_diff: {
    id: 12,
    name: "Developer (diff)",
    systemInstructions: `# Developer (diff) instructions
  You are now a Diff Developer Agent, tasked with providing code diff to replace sections of content in an existing file using SEARCH/REPLACE blocks that define exact changes to specific parts of the file. This tool should be used when you need to make targeted changes to specific parts of a file.
  This is alsmost like git diff but in a more structured way. You will provide a diff block that shows the changes to be made in the file.

  Note: file path should be inside search block.
  
  ## Response Format:
  
  When providing code, use the following structure:
  
  Follow with the code in a properly formatted diff block.

  \`\`\`diff
<file-path>
<<<<<<< SEARCH
<original code>
=======
<modified code>
>>>>>>> REPLACE
\`\`\`

  
  ## Response Example:
  
  Here's an example of how you should respond to a user request:

Example:

Let's say this is the original file -
\`\`\`code
const divide = (a, b) => {
  return a / b;
};
const sum = (a, b) => {
  return a + b;
}
const multiply = (a, b) => {
  return a * b;
};
\`\`\`

User: Can you please make sum accept three arguments and return the sum of all three.

Agent response:

\`\`\`diff
I:\a\path\to\change.ts
<<<<<<< SEARCH
const sum = (a, b) => {
  return a + b;
}
=======
const sum = (a, b, c) => {
  return a + b + c;
}
>>>>>>> REPLACE
\`\`\`

Critical rules:
  1. SEARCH content must match the associated file section to find EXACTLY:
     * Match character-for-character including whitespace, indentation, line endings
     * Include all comments, docstrings, etc.
  2. SEARCH/REPLACE blocks will ONLY replace the first match occurrence.
     * Including multiple unique SEARCH/REPLACE blocks if you need to make multiple changes.
     * Include *just* enough lines in each SEARCH section to uniquely match each set of lines that need to change.
     * When using multiple SEARCH/REPLACE blocks, list them in the order they appear in the file.
  3. Keep SEARCH/REPLACE blocks concise:
     * Break large SEARCH/REPLACE blocks into a series of smaller blocks that each change a small portion of the file.
     * Include just the changing lines, and a few surrounding lines if needed for uniqueness.
     * Do not include long runs of unchanging lines in SEARCH/REPLACE blocks.
     * Each line must be complete. Never truncate lines mid-way through as this can cause matching failures.
  4. Special operations:
     * To move code: Use two SEARCH/REPLACE blocks (one to delete from original + one to insert at new location)
     * To delete code: Use empty REPLACE section
`
  }
};
</file>

<file path="The-Creator-AI-main/src/common/firebase.ts">
// Import the functions you need from the SDKs you need
import { initializeApp } from "firebase/app";
import { getAnalytics } from "firebase/analytics";
// TODO: Add SDKs for Firebase products that you want to use
// https://firebase.google.com/docs/web/setup#available-libraries

// Your web app's Firebase configuration
// For Firebase JS SDK v7.20.0 and later, measurementId is optional
const firebaseConfig = {
  apiKey: "AIzaSyCqkthuqSjfIYNphtVzaTfC9OrWkRdyInI",
  authDomain: "the-creator-ai---extension.firebaseapp.com",
  projectId: "the-creator-ai---extension",
  storageBucket: "the-creator-ai---extension.appspot.com",
  messagingSenderId: "880822858438",
  appId: "1:880822858438:web:858b3ee79f18fd7985ddc7",
  measurementId: "G-GHB1S5QL2Y"
};

// Initialize Firebase
export const app = initializeApp(firebaseConfig);
export const analytics = getAnalytics(app);
</file>

<file path="The-Creator-AI-main/src/common/ipc/channels.enum.ts">
export enum ClientToServerChannel {
  SendMessage = "clientToServer.sendMessage",
  RequestChatHistory = "clientToServer.requestChatHistory",
  RequestOpenEditors = "clientToServer.requestOpenEditors",
  SendSelectedEditor = "clientToServer.sendSelectedEditor",
  RequestWorkspaceFiles = "clientToServer.requestWorkspaceFiles",
  RequestFileCode = "clientToServer.requestFileCode",
  RequestOpenFile = "clientToServer.requestOpenFile",
  SendStreamMessage = "clientToServer.sendStreamMessage",
  PersistStore = "clientToServer.persistStore",
  FetchStore = "clientToServer.fetchStore",
  RequestCommitMessageSuggestions = "clientToServer.requestCommitMessageSuggestions",
  CommitStagedChanges = "clientToServer.commitStagedChanges",
  RequestStreamFileCode = "clientToServer.requestStreamFileCode",
  // New channels for API key management
  GetLLMApiKeys = "clientToServer.getLLMApiKeys",
  SetLLMApiKey = "clientToServer.setLLMApiKey",
  DeleteLLMApiKey = "clientToServer.deleteLLMApiKey",
  // New channels for symbol retrieval
  RequestSymbols = "clientToServer.requestSymbols" 
}

export enum ServerToClientChannel {
  SendMessage = "serverToClient.sendMessage",
  SendChatHistory = "serverToClient.sendChatHistory",
  SendOpenEditors = "serverToClient.sendOpenEditors",
  SendWorkspaceFiles = "serverToClient.sendWorkspaceFiles",
  SendFileCode = "serverToClient.sendFileCode",
  StreamMessage = "serverToClient.streamMessage",
  SetChangePlanViewState = "serverToClient.setChangePlanViewState", // Fixed typo here
  SendCommitMessageSuggestions = "serverToClient.sendCommitMessageSuggestions",
  StreamFileCode = "serverToClient.streamFileCode",
  // New channels for API key management
  SendLLMApiKeys = "serverToClient.sendLLMApiKeys",
  // New channel for sending symbols
  SendSymbols = "serverToClient.sendSymbols" 
}
</file>

<file path="The-Creator-AI-main/src/common/ipc/channels.type.ts">
import { FileNode } from "@/common/types/file-node";
import { ClientToServerChannel, ServerToClientChannel } from "./channels.enum";
import { ChatMessage } from "@/backend/repositories/chat.respository";
import { KeyPaths, KeyPathValue } from "@/common/utils/key-path";
import { ChangePlanViewStore } from "@/client/views/change-plan.view/store/change-plan-view.state-type";
import { LlmServiceEnum } from "@/backend/types/llm-service.enum";

export type ChannelBody<T extends ClientToServerChannel | ServerToClientChannel> =
  T extends ClientToServerChannel.SendMessage
    ? { chatHistory: ChatMessage[]; selectedFiles: string[] }
    : T extends ServerToClientChannel.SendMessage
    ? { message: string }
    : T extends ClientToServerChannel.SendStreamMessage
    ? { chatHistory: ChatMessage[]; selectedFiles: string[] }
    : T extends ServerToClientChannel.StreamMessage
    ? { chunk: string }
    : T extends ClientToServerChannel.RequestChatHistory
    ? {
        chatId?: string;
      }
    : T extends ServerToClientChannel.SendChatHistory
    ? {
        chatId: string;
        messages: {
          user: string;
          message: string;
        }[];
      }
    : T extends ClientToServerChannel.RequestOpenEditors
    ? {}
    : T extends ServerToClientChannel.SendOpenEditors
    ? {
        editors: {
          fileName: string;
          filePath: string;
          languageId: string;
        }[];
      }
    : T extends ClientToServerChannel.SendSelectedEditor
    ? {
        editor: {
          fileName: string;
          filePath: string;
          languageId: string;
        };
      }
    : T extends ClientToServerChannel.RequestWorkspaceFiles
    ? {
        // You can add options for filtering here if needed
        // e.g., fileTypes: string[];
      }
    : T extends ServerToClientChannel.SendWorkspaceFiles
    ? {
        files: FileNode[];
      }
    : T extends ClientToServerChannel.RequestOpenFile
    ? {
        filePath: string;
      }
    : T extends ClientToServerChannel.RequestFileCode
    ? {
        filePath: string;
        chatHistory: ChatMessage[];
        selectedFiles: string[];
      }
    : T extends ServerToClientChannel.SendFileCode
    ? {
        filePath: string;
        fileContent: string;
      }
    : T extends ClientToServerChannel.RequestStreamFileCode
    ? {
        filePath: string;
        chatHistory: ChatMessage[];
        selectedFiles: string[];
      }
    : T extends ServerToClientChannel.StreamFileCode
    ? {
        filePath: string;
        chunk: string;
      }
    : T extends ClientToServerChannel.PersistStore
    ? {
        storeName: string;
        storeState: any;
      }
    : T extends ClientToServerChannel.FetchStore
    ? {
        storeName: string;
      }
    : T extends ServerToClientChannel.SetChangePlanViewState
    ? {
        keyPath: KeyPaths<ChangePlanViewStore>;
        value: KeyPathValue<KeyPaths<ChangePlanViewStore>, ChangePlanViewStore>;
      }
    : T extends ClientToServerChannel.RequestCommitMessageSuggestions
    ? {
        chatHistory: ChatMessage[];
      }
    : T extends ServerToClientChannel.SendCommitMessageSuggestions
    ? {
        suggestions: string[];
      }
    : T extends ClientToServerChannel.CommitStagedChanges
    ? {
        message: string;
        description: string;
      }
    : T extends ClientToServerChannel.GetLLMApiKeys
    ? {}
    : T extends ClientToServerChannel.SetLLMApiKey
    ? { service: LlmServiceEnum; apiKey: string }
    : T extends ClientToServerChannel.DeleteLLMApiKey
    ? { service: LlmServiceEnum; apiKeyToDelete: string }
    : T extends ServerToClientChannel.SendLLMApiKeys
    ? { apiKeys: Record<LlmServiceEnum, string[]> | undefined }
    : T extends ClientToServerChannel.RequestSymbols
    ? {
        query?: string;
      }
    : T extends ServerToClientChannel.SendSymbols
    ? {
        symbols: any;
      }
    : never;
</file>

<file path="The-Creator-AI-main/src/common/ipc/client-ipc.ts">
import getVscode from "./get-vscode-api";
import { ClientToServerChannel, ServerToClientChannel } from "./channels.enum";
import { ChannelBody } from "./channels.type";

// Client-side PostMessageManager
export class ClientPostMessageManager {
  private static _instance?: ClientPostMessageManager;
  private _listeners: {
    channel: ServerToClientChannel,
    callback: (body: ChannelBody<ServerToClientChannel>) => void
  }[];

  private constructor() {
    this._listeners = [];
    window.addEventListener('message', (event: MessageEvent) => {
      const data = event.data;

      this._listeners.forEach((listener) => {
        if (listener.channel === data.channel) {
          listener.callback(data.body);
        }
      });
    });
  }

  static getInstance(): ClientPostMessageManager {
    if (!ClientPostMessageManager._instance) {
      ClientPostMessageManager._instance = new ClientPostMessageManager();
    }
    return ClientPostMessageManager._instance;
  }

  sendToServer<T extends ClientToServerChannel>(channel: T, body: ChannelBody<T>): void {
    const message = { channel, body };
    getVscode().postMessage(message);
  }

  onServerMessage<T extends ServerToClientChannel>(channel: T, callback: (body: ChannelBody<T>) => void): void {
    this._listeners.push({ channel, callback: callback as any });
  }
}
</file>

<file path="The-Creator-AI-main/src/common/ipc/get-vscode-api.ts">
import { WebviewApi } from "../types/vscode-webview";

let vscode: WebviewApi<unknown> | null = null;

const getVscode = () => {
    if (!vscode) {
        vscode = acquireVsCodeApi();
    }
    return vscode;
};

export default getVscode;
</file>

<file path="The-Creator-AI-main/src/common/ipc/server-ipc.ts">
import { ClientToServerChannel, ServerToClientChannel } from "./channels.enum";
import { ChannelBody } from "./channels.type";

export class ServerPostMessageManager {
    private static _instance?: ServerPostMessageManager;
    private _listeners: {
        channel: ClientToServerChannel,
        callback: (body: ChannelBody<ClientToServerChannel>) => void
    }[];
    private constructor(
        private onMessage: (data: any) => void,
        private sendMessage: (message: any) => void
    ) {
        this._listeners = [];
        this.onMessage((data: any) => {
            this._listeners.forEach((listener) => {
                if (listener.channel === data.channel) {
                    listener.callback(data.body);
                }
            });
        });
    }

    static getInstance(
        onMessage?: (data: any) => void,
        sendMessage?: (message: any) => void
    ) {
        if (onMessage && sendMessage) {
            ServerPostMessageManager._instance = new ServerPostMessageManager(onMessage, sendMessage);
        }
        return ServerPostMessageManager._instance;
    }

    // Server-to-Client communication 
    sendToClient<T extends ServerToClientChannel>(channel: T, body: ChannelBody<T>): void {
        const message = { channel, body };
        this.sendMessage(message);
    }

    onClientMessage<T extends ClientToServerChannel>(channel: T, callback: (body: ChannelBody<T>) => void): void {
        this._listeners.push({ channel, callback: callback as any });
    }
}
</file>

<file path="The-Creator-AI-main/src/common/types/file-node.ts">
export interface FileNode {
  name: string;
  children?: FileNode[];
  absolutePath?: string;
}
</file>

<file path="The-Creator-AI-main/src/common/types/vscode-webview.d.ts">
// Type definitions for non-npm package vscode-webview 1.57
// Project: https://code.visualstudio.com/api/extension-guides/webview
// Definitions by: Matt Bierner <https://github.com/mjbvz>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped
// Minimum TypeScript Version: 3.0

/**
 * API exposed to webviews.
 *
 * @template StateType Type of the persisted state stored for the webview.
 */
export interface WebviewApi<StateType> {
    /**
     * Post a message to the owner of the webview.
     *
     * @param message Data to post. Must be JSON serializable.
     */
    postMessage(message: unknown): void;

    /**
     * Get the persistent state stored for this webview.
     *
     * @return The current state or `undefined` if no state has been set.
     */
    getState(): StateType | undefined;

    /**
     * Set the persistent state stored for this webview.
     *
     * @param newState New persisted state. This must be a JSON serializable object. Can be retrieved
     * using {@link getState}.
     *
     * @return The new state.
     */
    setState<T extends StateType | undefined>(newState: T): T;
}

declare global {
    /**
     * Acquire an instance of the webview API.
     *
     * This may only be called once in a webview's context. Attempting to call `acquireVsCodeApi` after it has already
     * been called will throw an exception.
     *
     * @template StateType Type of the persisted state stored for the webview.
     */
    // tslint:disable-next-line:no-unnecessary-generics
    function acquireVsCodeApi<StateType = unknown>(): WebviewApi<StateType>;
}
</file>

<file path="The-Creator-AI-main/src/common/utils/firebaseLogger.ts">
import { analytics } from "@/common/firebase";
import { getAnalytics, logEvent } from "firebase/analytics";

// Enum for Firebase events
export enum FirebaseEvents {
  EXTENSION_ACTIVATED = "extension_activated",
  SIDEBAR_OPENED = "sidebar_opened",
  PLAN_FETCHED = "plan_fetched",
  FILE_CODE_REQUESTED = "file_code_requested",
  FILE_CODE_GENERATED = "file_code_generated",
}

// Class for logging events to Firebase
export class Log {
  static logEvent(event: FirebaseEvents, params?: Record<string, any>): void {
    logEvent(analytics, event, {
      app_name: "the-creator-ai",
      app_version: "0.1.1",
      ...params,
    });
  }

  static extensionActivated(): void {
    this.logEvent(FirebaseEvents.EXTENSION_ACTIVATED);
  }

  static sidebarOpened(): void {
    this.logEvent(FirebaseEvents.SIDEBAR_OPENED);
  }

  static planFetched(): void {
    this.logEvent(FirebaseEvents.PLAN_FETCHED);
  }

  static fileCodeRequested(): void {
    this.logEvent(FirebaseEvents.FILE_CODE_REQUESTED);
  }

  static fileCodeGenerated(): void {
    this.logEvent(FirebaseEvents.FILE_CODE_GENERATED);
  }
}
</file>

<file path="The-Creator-AI-main/src/common/utils/key-path.ts">
export type KeyPaths<T> = T extends object
  ? {
      [K in keyof Required<T>]: `${Exclude<K, symbol>}${
        | ""
        | (Required<T>[K] extends Array<infer U>
            ? ""
            : Required<T>[K] extends object
            ? `.${KeyPaths<Required<T>[K]>}`
            : "")}`;
    }[keyof T]
  : "";

export type KeyPathValue<KeyPath, Obj> =
  KeyPath extends `${infer K}.${infer Rest}`
    ? K extends keyof Obj
      ? KeyPathValue<Rest, Obj>
      : never
    : KeyPath extends keyof Obj
    ? Obj[KeyPath]
    : never;

export const getNestedValue = <T>(obj: T, path?: string): any => {
  return path
    ? path.split(".").reduce((acc: any, part: string) => acc && acc[part], obj)
    : obj;
};

export const setNestedValue = <T>(
  obj: T,
  keyPath: KeyPaths<T>,
  value: KeyPathValue<KeyPaths<T>, T>
): T => {
  const keys = keyPath.split(".");
  const lastKey = keys.pop();
  let newObj = obj;
  let ref = newObj;
  keys.forEach((key) => {
    ref = ref[key];
  });
  ref[lastKey] = value;
  return newObj;
};
</file>

<file path="The-Creator-AI-main/src/common/utils/parse-json.ts">
export const parseJsonResponse = (response: string): any | null => {
  try {
    if (!response) {
      return null;
    }
    const jsonStart = response.indexOf("```json");
    const jsonEnd = response.lastIndexOf("```") + 1;

    if (jsonStart !== -1 && jsonEnd !== -1) {
      const jsonStr = response
        .substring(jsonStart + 7, jsonEnd - 2)
        ?.replaceAll("\n", "");
      return JSON.parse(jsonStr);
    }
  } catch (error) {
    console.error("Error parsing JSON:", error);
  }
  return null;
};
</file>

<file path="The-Creator-AI-main/src/common/utils/view-html.ts">
import * as vscode from "vscode";

export function getViewHtml({
  webview,
  nonce,
  scriptUri,
}: {
  webview: vscode.Webview;
  nonce: string;
  scriptUri: string;
}): string {
  return `<!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src ${webview.cspSource} 'unsafe-inline'; script-src 'nonce-${nonce}' https://www.gstatic.com/firebasejs/ https://www.googletagmanager.com; connect-src https://firebaseinstallations.googleapis.com https://firebaseremoteconfig.googleapis.com https://firebaselogging.googleapis.com https://firebaseanalytics.googleapis.com;">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
            </head>
            <body>
                <div id="change-plan-view-root"></div>
                <script nonce="${nonce}" src="${scriptUri}"></script>
            </body>
            </html>`;
}

export function getNonce() {
  let text = "";
  const possible =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  for (let i = 0; i < 32; i++) {
    text += possible.charAt(Math.floor(Math.random() * possible.length));
  }
  return text;
}
</file>

<file path="The-Creator-AI-main/src/common/view-types.ts">
export const VIEW_TYPES = {
  SIDEBAR: {
    CHAT: "viewType.sidebar.chat",
    FILE_EXPLORER: "viewType.sidebar.fileExplorer",
    CHANGE_PLAN: "viewType.sidebar.changePlan",
  },
};
</file>

<file path="The-Creator-AI-main/src/extension.ts">
import * as vscode from "vscode";
import { registerViews } from "./client/views";
import { registerCommands } from "./backend/commands/register-commands";
import { Services } from "./backend/services/services";

let globalContext: vscode.ExtensionContext | null = null;
export function activate(context: vscode.ExtensionContext) {
  globalContext = context;

  console.log(
    'Congratulations, your extension "the-creator-ai" is now active!'
  );

  registerCommands(context);
  registerViews(context);
  Services.initialize();
}

export function getContext() {
  return globalContext;
}

export function deactivate() {}
</file>

<file path="The-Creator-AI-main/src/test/extension.test.ts">
import * as assert from 'assert';

// You can import and use all API from the 'vscode' module
// as well as import your extension to test it
import * as vscode from 'vscode';
// import * as myExtension from '../../extension';

suite('Extension Test Suite', () => {
	vscode.window.showInformationMessage('Start all tests.');

	test('Sample test', () => {
		assert.strictEqual(-1, [1, 2, 3].indexOf(5));
		assert.strictEqual(-1, [1, 2, 3].indexOf(0));
	});
});
</file>

<file path="The-Creator-AI-main/tailwind.config.js">
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: ["./src/**/*.{html,js,jsx,ts,tsx}"],
  theme: {
    extend: {
      colors: {
        'dropdown-bg': 'var(--vscode-dropdown-background)',
        'active-selection-bg': 'var(--vscode-list-activeSelectionBackground)',
        'focus-bg': 'var(--vscode-list-focusBackground)',
        'dropdown-list-bg': 'var(--vscode-dropdown-list-background)',
        'settings-input-bg': 'var(--vscode-settings-textInputBackground)',
        'inactive-selection-bg': 'var(--vscode-list-inactiveSelectionBackground)',
        'hover-bg': 'var(--vscode-list-hoverBackground)',
        'drop-bg': 'var(--vscode-list-dropBackground)',
        'highlight-fg': 'var(--vscode-list-highlightForeground)',
        'button-bg': 'var(--vscode-button-background)',
        'editor-bg': 'var(--vscode-editor-background)',
        'editor-fg': 'var(--vscode-editor-foreground)',
        'selection-bg': 'var(--vscode-selection-background)',
        'selection-highlight-bg': 'var(--vscode-editor-selectionHighlightBackground)',
        'editor-selection-bg': 'var(--vscode-editor-selectionBackground)',
        'word-highlight-bg': 'var(--vscode-editor-wordHighlightBackground)',
        'word-highlight-strong-bg': 'var(--vscode-editor-wordHighlightStrongBackground)',
        'line-highlight-bg': 'var(--vscode-editor-lineHighlightBackground)',
        'line-number-active-fg': 'var(--vscode-editorLineNumber-activeForeground)',
        'cursor-fg': 'var(--vscode-editorCursor-foreground)',
        'whitespace-fg': 'var(--vscode-editorWhitespace-foreground)',
        'indent-guide-bg': 'var(--vscode-editorIndentGuide-background)',
        'indent-guide-active-bg': 'var(--vscode-editorIndentGuide-activeBackground)',
        'editor-group-header-tabs-bg': 'var(--vscode-editorGroupHeader-tabsBackground)',
        'editor-group-drop-bg': 'var(--vscode-editorGroup-dropBackground)',
        'tab-inactive-bg': 'var(--vscode-tab-inactiveBackground)',
        'tab-border': 'var(--vscode-tab-border)',
        'tab-modified-border': 'var(--vscode-tab-modifiedBorder)',
        'tab-inactive-fg': 'var(--vscode-tab-inactiveForeground)',
        'widget-shadow': 'var(--vscode-widget-shadow)',
        'progress-bar-bg': 'var(--vscode-progressBar-background)',
        'badge-bg': 'var(--vscode-badge-background)',
        'badge-fg': 'var(--vscode-badge-foreground)',
        'line-number-fg': 'var(--vscode-editorLineNumber-foreground)',
        'panel-title-active-fg': 'var(--vscode-panelTitle-activeForeground)',
        'panel-title-active-border': 'var(--vscode-panelTitle-activeBorder)',
        'panel-title-inactive-fg': 'var(--vscode-panelTitle-inactiveForeground)',
        'panel-border': 'var(--vscode-panel-border)',
        'title-bar-active-bg': 'var(--vscode-titleBar-activeBackground)',
        'status-bar-bg': 'var(--vscode-statusBar-background)',
        'status-bar-no-folder-bg': 'var(--vscode-statusBar-noFolderBackground)',
        'status-bar-debugging-bg': 'var(--vscode-statusBar-debuggingBackground)',
        'activity-bar-bg': 'var(--vscode-activityBar-background)',
        'activity-bar-fg': 'var(--vscode-activityBar-foreground)',
        'activity-bar-drop-bg': 'var(--vscode-activityBar-dropBackground)',
        'sidebar-bg': 'var(--vscode-sideBar-background)',
        'sidebar-section-header-bg': 'var(--vscode-sideBarSectionHeader-background)',
        'menu-bg': 'var(--vscode-menu-background)',
        'menu-fg': 'var(--vscode-menu-foreground)',
        'picker-group-fg': 'var(--vscode-pickerGroup-foreground)',
        'input-bg': 'var(--vscode-input-background)',
        'input-option-active-border': 'var(--vscode-inputOption-activeBorder)',
        'focus-border': 'var(--vscode-focusBorder)',
        'editor-widget-bg': 'var(--vscode-editorWidget-background)',
        'debug-toolbar-bg': 'var(--vscode-debugToolBar-background)',
        'diff-editor-inserted-text-bg': 'var(--vscode-diffEditor-insertedTextBackground)',
        'diff-editor-removed-text-bg': 'var(--vscode-diffEditor-removedTextBackground)',
        'input-validation-error-bg': 'var(--vscode-inputValidation-errorBackground)',
        'input-validation-error-border': 'var(--vscode-inputValidation-errorBorder)',
        'input-validation-warning-bg': 'var(--vscode-inputValidation-warningBackground)',
        'input-validation-warning-border': 'var(--vscode-inputValidation-warningBorder)',
        'input-validation-info-bg': 'var(--vscode-inputValidation-infoBackground)',
        'input-validation-info-border': 'var(--vscode-inputValidation-infoBorder)',
        'editor-hover-widget-bg': 'var(--vscode-editorHoverWidget-background)',
        'editor-hover-widget-border': 'var(--vscode-editorHoverWidget-border)',
        'editor-suggest-widget-bg': 'var(--vscode-editorSuggestWidget-background)',
        'editor-suggest-widget-border': 'var(--vscode-editorSuggestWidget-border)',
        'editor-group-border': 'var(--vscode-editorGroup-border)',
        'peek-view-border': 'var(--vscode-peekView-border)',
        'peek-view-editor-bg': 'var(--vscode-peekViewEditor-background)',
        'peek-view-result-bg': 'var(--vscode-peekViewResult-background)',
        'peek-view-title-bg': 'var(--vscode-peekViewTitle-background)',
        'peek-view-result-selection-bg': 'var(--vscode-peekViewResult-selectionBackground)',
        'peek-view-result-match-highlight-bg': 'var(--vscode-peekViewResult-matchHighlightBackground)',
        'peek-view-editor-match-highlight-bg': 'var(--vscode-peekViewEditor-matchHighlightBackground)',
        'terminal-ansi-black': 'var(--vscode-terminal-ansiBlack)',
        'terminal-ansi-red': 'var(--vscode-terminal-ansiRed)',
        'terminal-ansi-green': 'var(--vscode-terminal-ansiGreen)',
        'terminal-ansi-yellow': 'var(--vscode-terminal-ansiYellow)',
        'terminal-ansi-blue': 'var(--vscode-terminal-ansiBlue)',
        'terminal-ansi-magenta': 'var(--vscode-terminal-ansiMagenta)',
        'terminal-ansi-cyan': 'var(--vscode-terminal-ansiCyan)',
        'terminal-ansi-white': 'var(--vscode-terminal-ansiWhite)',
        'terminal-ansi-bright-black': 'var(--vscode-terminal-ansiBrightBlack)',
        'terminal-ansi-bright-red': 'var(--vscode-terminal-ansiBrightRed)',
        'terminal-ansi-bright-green': 'var(--vscode-terminal-ansiBrightGreen)',
        'terminal-ansi-bright-yellow': 'var(--vscode-terminal-ansiBrightYellow)',
        'terminal-ansi-bright-blue': 'var(--vscode-terminal-ansiBrightBlue)',
        'terminal-ansi-bright-magenta': 'var(--vscode-terminal-ansiBrightMagenta)',
        'terminal-ansi-bright-cyan': 'var(--vscode-terminal-ansiBrightCyan)',
        'terminal-ansi-bright-white': 'var(--vscode-terminal-ansiBrightWhite)',
      },
    },
  },
  plugins: [],
}
</file>

<file path="The-Creator-AI-main/tsconfig.json">
{
	"compilerOptions": {
		"module": "esnext",
		"moduleResolution": "node",
		"target": "ESNext",
		"lib": [
			"ES2022",
			"DOM"
		],
		"jsx": "react",
		"sourceMap": true,
		"rootDir": ".",
		"strict": false, /* enable all strict type-checking options */
		"noImplicitAny": false,
		"noImplicitReturns": false,
		"noImplicitThis": false,
		/* Additional Checks */
		// "noImplicitReturns": true, /* Report error when not all code paths in function return a value. */
		// "noFallthroughCasesInSwitch": true, /* Report errors for fallthrough cases in switch statement. */
		// "noUnusedParameters": true,  /* Report errors on unused parameters. */
		"baseUrl": ".",
		"paths": {
			"@/*": ["src/*"]
		},
		"experimentalDecorators": true,
		"allowSyntheticDefaultImports": true
	},
	"include": [
		"src/**/*"
	]
}
</file>

<file path="The-Creator-AI-main/vsc-extension-quickstart.md">
# Welcome to your VS Code Extension

## What's in the folder

* This folder contains all of the files necessary for your extension.
* `package.json` - this is the manifest file in which you declare your extension and command.
  * The sample plugin registers a command and defines its title and command name. With this information VS Code can show the command in the command palette. It doesnâ€™t yet need to load the plugin.
* `src/extension.ts` - this is the main file where you will provide the implementation of your command.
  * The file exports one function, `activate`, which is called the very first time your extension is activated (in this case by executing the command). Inside the `activate` function we call `registerCommand`.
  * We pass the function containing the implementation of the command as the second parameter to `registerCommand`.

## Setup

* install the recommended extensions (amodio.tsl-problem-matcher, ms-vscode.extension-test-runner, and dbaeumer.vscode-eslint)


## Get up and running straight away

* Press `F5` to open a new window with your extension loaded.
* Run your command from the command palette by pressing (`Ctrl+Shift+P` or `Cmd+Shift+P` on Mac) and typing `Hello World`.
* Set breakpoints in your code inside `src/extension.ts` to debug your extension.
* Find output from your extension in the debug console.

## Make changes

* You can relaunch the extension from the debug toolbar after changing code in `src/extension.ts`.
* You can also reload (`Ctrl+R` or `Cmd+R` on Mac) the VS Code window with your extension to load your changes.


## Explore the API

* You can open the full set of our API when you open the file `node_modules/@types/vscode/index.d.ts`.

## Run tests

* Install the [Extension Test Runner](https://marketplace.visualstudio.com/items?itemName=ms-vscode.extension-test-runner)
* Run the "watch" task via the **Tasks: Run Task** command. Make sure this is running, or tests might not be discovered.
* Open the Testing view from the activity bar and click the Run Test" button, or use the hotkey `Ctrl/Cmd + ; A`
* See the output of the test result in the Test Results view.
* Make changes to `src/test/extension.test.ts` or create new test files inside the `test` folder.
  * The provided test runner will only consider files matching the name pattern `**.test.ts`.
  * You can create folders inside the `test` folder to structure your tests any way you want.

## Go further

* Reduce the extension size and improve the startup time by [bundling your extension](https://code.visualstudio.com/api/working-with-extensions/bundling-extension).
* [Publish your extension](https://code.visualstudio.com/api/working-with-extensions/publishing-extension) on the VS Code extension marketplace.
* Automate builds by setting up [Continuous Integration](https://code.visualstudio.com/api/working-with-extensions/continuous-integration).
</file>

<file path="The-Creator-AI-main/webpack.config.js">
//@ts-check

'use strict';

const path = require('path');
const CopyPlugin = require("copy-webpack-plugin");
const webpack = require('webpack');

//@ts-check
/** @typedef {import('webpack').Configuration} WebpackConfig **/

/** @type WebpackConfig */
const extensionConfig = {
  target: 'node', // VS Code extensions run in a Node.js-context ðŸ“– -> https://webpack.js.org/configuration/node/
	mode: 'none', // this leaves the source code as close as possible to the original (when packaging we set this to 'production')

  entry: {
    extension: './src/extension.ts',
    chatView: './src/client/views/chat.view/view.tsx',
    changePlanView: './src/client/views/change-plan.view/view.tsx',
    fileExplorerView: './src/client/views/file-explorer.view/view.tsx',
  },  
  output: {
    // the bundle is stored in the 'dist' folder (check package.json), ðŸ“– -> https://webpack.js.org/configuration/output/
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].js',
    libraryTarget: 'commonjs2'
  },
  externals: {
    vscode: 'commonjs vscode' // the vscode-module is created on-the-fly and must be excluded. Add other modules that cannot be webpack'ed, ðŸ“– -> https://webpack.js.org/configuration/externals/
    // modules added here also need to be added in the .vscodeignore file
  },
  resolve: {
    // support reading TypeScript and JavaScript files, ðŸ“– -> https://github.com/TypeStrong/ts-loader
    extensions: ['.ts', '.js', '.tsx', '.jsx'],
    alias: {
      "@": path.resolve(__dirname, 'src'),
    }
  },
  module: {
    rules: [
      {
        test: /\.ts$/,
        exclude: /node_modules/,
        use: [
          {
            loader: 'ts-loader'
          }
        ]
      },
      {
        test: /\.?ts.?(x)$/,
        exclude: /node_modules/,
        use: {
          loader: "babel-loader",
          options: {
            presets: ['@babel/preset-env', '@babel/preset-react', '@babel/preset-typescript']
          }
        }
      },
      {
        test: /\.m?js$/,
        resolve: {
          fullySpecified: false
        },
      },
      {
        test: /\.s[ac]ss$/i,
        use: [
          // Creates `style` nodes from JS strings
          "style-loader",
          // Translates CSS into CommonJS
          "css-loader",
          // Compiles Sass to CSS
          "sass-loader",
          // PostCSS (needed for Tailwind)
          "postcss-loader", 
        ],
      },
    ]
  },
  plugins: [
    new CopyPlugin({
      patterns: [
        { from: "public", to: "public" }
      ],
    }),
    new webpack.ProvidePlugin({
      process: 'process/browser',
  }),
  ],
  devtool: 'nosources-source-map',
  infrastructureLogging: {
    level: "log", // enables logging required for problem matchers
  },
};
module.exports = [ extensionConfig ];
</file>

<file path="tsconfig.json">
{
    "compilerOptions": {
        "module": "esnext",
        "moduleResolution": "bundler",
        "target": "ESNext",
        "lib": ["ES2022", "DOM"],
        "jsx": "react",
        "sourceMap": true,
        "rootDir": "src",
        "strict": false,
        "baseUrl": "./",
        "paths": {
            "@/*": ["src/*"]
        },
        "experimentalDecorators": true,
        "allowSyntheticDefaultImports": true
    },
    "include": [
        "src/**/*.ts",
        "src/**/*.tsx"
    ],
    "exclude": [
        "node_modules",
        ".vscode-test",
        "The-Creator-AI-main"
    ]
}
</file>

<file path="webpack.config.js">
const path = require('path');
const CopyPlugin = require("copy-webpack-plugin");
const webpack = require('webpack');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');

/** @type {import('webpack').Configuration} */
const baseConfig = {
    mode: 'none',
    resolve: {
        extensions: ['.ts', '.js', '.tsx', '.jsx'],
        alias: {
            "@": path.resolve(__dirname, 'src'),
        }
    },
    module: {
        rules: [
            {
                test: /\.ts$/,
                exclude: /node_modules/,
                use: [{ loader: 'ts-loader' }]
            },
            {
                test: /\.?ts.?(x)$/,
                exclude: /node_modules/,
                use: {
                    loader: "babel-loader",
                    options: {
                        presets: ['@babel/preset-react', '@babel/preset-typescript']
                    }
                }
            },
        ]
    },
    devtool: 'nosources-source-map',
    infrastructureLogging: {
        level: "log",
    },
};

/** @type {import('webpack').Configuration} */
const extensionConfig = {
    ...baseConfig,
    target: 'node',
    entry: {
        extension: './src/extension.ts',
    },
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'extension.js',
        libraryTarget: 'commonjs2'
    },
    externals: {
        vscode: 'commonjs vscode',
    },
};

/** @type {import('webpack').Configuration} */
const webviewConfig = {
    ...baseConfig,
    target: 'web',
    entry: {
        contextChooserView: './src/client/views/context-chooser.view/view.tsx',
        parallelCopilotView: './src/client/views/parallel-copilot.view/view.tsx',
    },
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: '[name].js',
        libraryTarget: 'commonjs2'
    },
    module: {
        ...baseConfig.module,
        rules: [
            ...baseConfig.module.rules,
            {
                test: /\.s[ac]ss$/i,
                use: [MiniCssExtractPlugin.loader, "css-loader", "sass-loader"],
            },
        ]
    },
    resolve: {
        ...baseConfig.resolve,
        fallback: {
            "path": require.resolve("path-browserify")
        }
    },
    plugins: [
        new MiniCssExtractPlugin({
            filename: '[name].css'
        }),
        new CopyPlugin({
            patterns: [
                { from: "public", to: "public" },
                // C118: Copy the starry-night CSS theme to the dist folder so it can be loaded in the webview.
                { from: "node_modules/@wooorm/starry-night/style/both.css", to: "starry-night.css" }
            ],
        }),
        new webpack.ProvidePlugin({
            process: 'process/browser',
        }),
    ],
};

module.exports = [extensionConfig, webviewConfig];
</file>

