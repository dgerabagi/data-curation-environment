<!--
  File: flattened_repo.md
  Source Directory: C:\Projects\DCE
  Date Generated: 2025-08-25T13:15:47.713Z
  ---
  Total Files: 220
  Total Lines: 53223
  Total Characters: 1955836
  Approx. Tokens: 489042
-->

<!-- Top 10 Files by Token Count -->
1. winmerge_flattened_repo.md (246672 tokens)
2. src\Artifacts\A54. starry-night-readme.md (25577 tokens)
3. src\Artifacts\A6. DCE - Initial Scaffolding Deployment Script.md (10922 tokens)
4. The-Creator-AI-main\src\common\constants\agents.constants.ts (9159 tokens)
5. src\client\views\parallel-copilot.view\view.tsx (5566 tokens)
6. src\client\views\context-chooser.view\view.tsx (5562 tokens)
7. src\Artifacts\A0. DCE Master Artifact List.md (5057 tokens)
8. src\client\components\tree-view\TreeView.tsx (4508 tokens)
9. src\Artifacts\A11. DCE - Regression Case Studies.md (4259 tokens)
10. src\backend\services\prompt.service.ts (4134 tokens)

<!-- Full File List -->
1. .gitignore - Lines: 10 - Chars: 128 - Tokens: 32
2. .vscodeignore - Lines: 11 - Chars: 356 - Tokens: 89
3. bootstrap-flattener.js - Lines: 185 - Chars: 5834 - Tokens: 1459
4. LICENSE - Lines: 21 - Chars: 1090 - Tokens: 273
5. package.json - Lines: 139 - Chars: 4583 - Tokens: 1146
6. public\copilot.svg - Lines: 5 - Chars: 445 - Tokens: 112
7. public\spiral.svg - Lines: 8 - Chars: 459 - Tokens: 115
8. src\Artifacts\A0. DCE Master Artifact List.md - Lines: 274 - Chars: 20225 - Tokens: 5057
9. src\Artifacts\A1. DCE - Project Vision and Goals.md - Lines: 41 - Chars: 3995 - Tokens: 999
10. src\Artifacts\A10. DCE - Metadata and Statistics Display.md - Lines: 53 - Chars: 7286 - Tokens: 1822
11. src\Artifacts\A11. DCE - Regression Case Studies.md - Lines: 182 - Chars: 17035 - Tokens: 4259
12. src\Artifacts\A12. DCE - Logging and Debugging Guide.md - Lines: 80 - Chars: 5710 - Tokens: 1428
13. src\Artifacts\A13. DCE - Phase 1 - Right-Click Context Menu.md - Lines: 43 - Chars: 5476 - Tokens: 1369
14. src\Artifacts\A14. DCE - Ongoing Development Issues.md - Lines: 64 - Chars: 4324 - Tokens: 1081
15. src\Artifacts\A149. Local LLM Integration Plan.md - Lines: 99 - Chars: 6208 - Tokens: 1552
16. src\Artifacts\A15. DCE - Phase 1 - Multi-Select & Sorting Feature Plan.md - Lines: 43 - Chars: 7263 - Tokens: 1816
17. src\Artifacts\A16. DCE - Phase 1 - UI & UX Refinements Plan.md - Lines: 50 - Chars: 6421 - Tokens: 1606
18. src\Artifacts\A17. DCE - Phase 1 - Advanced Tree View Features.md - Lines: 47 - Chars: 3888 - Tokens: 972
19. src\Artifacts\A18. DCE - Phase 1 - Active File Sync Feature Plan.md - Lines: 46 - Chars: 4548 - Tokens: 1137
20. src\Artifacts\A189. Number Formatting Reference Guide.md - Lines: 118 - Chars: 4938 - Tokens: 1235
21. src\Artifacts\A19. DCE - Phase 1 - Double-Click & Quick-Remove Feature Plan.md - Lines: 42 - Chars: 4603 - Tokens: 1151
22. src\Artifacts\A2. DCE - Phase 1 - Context Chooser - Requirements & Design.md - Lines: 20 - Chars: 3329 - Tokens: 833
23. src\Artifacts\A20. DCE - Phase 1 - Advanced UX & Automation Plan.md - Lines: 47 - Chars: 7268 - Tokens: 1817
24. src\Artifacts\A21. DCE - Phase 1 - Feature Drift Analysis vs. VS Code Explorer.md - Lines: 48 - Chars: 7385 - Tokens: 1847
25. src\Artifacts\A22. DCE - Phase 1 - Search & Filter Feature Plan.md - Lines: 58 - Chars: 3663 - Tokens: 916
26. src\Artifacts\A23. DCE - Phase 1 - Advanced Interactions (Keyboard & Drag-Drop) Plan.md - Lines: 37 - Chars: 5504 - Tokens: 1376
27. src\Artifacts\A24. DCE - Selection Paradigm Terminology.md - Lines: 57 - Chars: 3330 - Tokens: 833
28. src\Artifacts\A25. DCE - Phase 1 - Git & Problems Integration Plan.md - Lines: 61 - Chars: 5871 - Tokens: 1468
29. src\Artifacts\A26. DCE - Phase 1 - File System Traversal & Caching Strategy.md - Lines: 46 - Chars: 4009 - Tokens: 1003
30. src\Artifacts\A27. DCE - Phase 1 - Undo-Redo Feature Plan.md - Lines: 50 - Chars: 4903 - Tokens: 1226
31. src\Artifacts\A28. DCE - Packaging and Distribution Guide.md - Lines: 96 - Chars: 4075 - Tokens: 1019
32. src\Artifacts\A29. DCE - Phase 1 - Binary and Image File Handling Strategy.md - Lines: 81 - Chars: 4217 - Tokens: 1055
33. src\Artifacts\A3. DCE - Technical Scaffolding Plan.md - Lines: 55 - Chars: 3684 - Tokens: 921
34. src\Artifacts\A30. DCE - Phase 1 - PDF Handling and Virtualization Strategy.md - Lines: 44 - Chars: 4431 - Tokens: 1108
35. src\Artifacts\A31. DCE - Phase 2 - Multimodal Content Extraction (PDF Images).md - Lines: 44 - Chars: 4035 - Tokens: 1009
36. src\Artifacts\A32. DCE - Phase 1 - Excel and CSV Handling Strategy.md - Lines: 44 - Chars: 4295 - Tokens: 1074
37. src\Artifacts\A33. DCE - Phase 1 - Copy-Paste Feature Plan.md - Lines: 42 - Chars: 4456 - Tokens: 1114
38. src\Artifacts\A34. DCE - Phase 2 - Parallel Co-Pilot Panel - Vision & Requirements.md - Lines: 44 - Chars: 6403 - Tokens: 1601
39. src\Artifacts\A35. DCE - Phase 2 - UI Mockups and Flow.md - Lines: 72 - Chars: 4665 - Tokens: 1167
40. src\Artifacts\A36. DCE - Phase 2 - Technical Implementation Plan.md - Lines: 77 - Chars: 4173 - Tokens: 1044
41. src\Artifacts\A37. DCE - Phase 2 - Cycle Navigator & Knowledge Graph - Vision.md - Lines: 28 - Chars: 3242 - Tokens: 811
42. src\Artifacts\A38. DCE - Phase 2 - Cycle Navigator - UI Mockup.md - Lines: 69 - Chars: 4621 - Tokens: 1156
43. src\Artifacts\A39. DCE - Phase 2 - Cycle Navigator - Technical Plan.md - Lines: 84 - Chars: 4595 - Tokens: 1149
44. src\Artifacts\A4. DCE - Analysis of The-Creator-AI Repo.md - Lines: 56 - Chars: 5722 - Tokens: 1431
45. src\Artifacts\A40. DCE - Phase 2 - Parallel Co-Pilot - Target File Structure.md - Lines: 66 - Chars: 3659 - Tokens: 915
46. src\Artifacts\A40.1. DCE - Phase 2 - Competitive Analysis & Feature Ideas.md - Lines: 43 - Chars: 4784 - Tokens: 1196
47. src\Artifacts\A41. DCE - Phase 2 - API Key Management - Feature Plan.md - Lines: 47 - Chars: 4542 - Tokens: 1136
48. src\Artifacts\A41.1. DCE - Phase 2 - Advanced Features & Integrations Plan.md - Lines: 44 - Chars: 3946 - Tokens: 987
49. src\Artifacts\A41.2. DCE - Phase 2 - Feature Ideation & Competitive Analysis.md - Lines: 40 - Chars: 4566 - Tokens: 1142
50. src\Artifacts\A42. DCE - Phase 2 - Initial Scaffolding Deployment Script.md - Lines: 246 - Chars: 8264 - Tokens: 2066
51. src\Artifacts\A43. DCE - Phase 2 - Implementation Roadmap.md - Lines: 69 - Chars: 4694 - Tokens: 1174
52. src\Artifacts\A44. DCE - Phase 1 - Word Document Handling Strategy.md - Lines: 45 - Chars: 4626 - Tokens: 1157
53. src\Artifacts\A45. DCE - Phase 2 - Pop-out Co-Pilot Window - Feature Plan.md - Lines: 49 - Chars: 4156 - Tokens: 1039
54. src\Artifacts\A46. DCE - Phase 2 - Paste and Parse Response - Feature Plan.md - Lines: 38 - Chars: 3587 - Tokens: 897
55. src\Artifacts\A47. DCE - Phase 2 - Prompt Amalgamation Feature Plan.md - Lines: 42 - Chars: 3499 - Tokens: 875
56. src\Artifacts\A48. DCE - Phase 2 - Advanced Syntax Highlighting Plan.md - Lines: 49 - Chars: 4044 - Tokens: 1011
57. src\Artifacts\A49. DCE - Phase 2 - File Association & Diffing Plan.md - Lines: 36 - Chars: 3857 - Tokens: 965
58. src\Artifacts\A5. DCE - Target File Structure.md - Lines: 67 - Chars: 1977 - Tokens: 495
59. src\Artifacts\A50. DCE - Phase 2 - UI Component Plan (Resizable Panes & Inner Editors).md - Lines: 51 - Chars: 5128 - Tokens: 1282
60. src\Artifacts\A51. DCE - A-B-C Testing Strategy for UI Bugs.md - Lines: 81 - Chars: 5490 - Tokens: 1373
61. src\Artifacts\A52. DCE - Interaction Schema Refinement.md - Lines: 61 - Chars: 3735 - Tokens: 934
62. src\Artifacts\A53. DCE - Phase 2 - Token Count and Similarity Analysis.md - Lines: 50 - Chars: 3971 - Tokens: 993
63. src\Artifacts\A54. starry-night-readme.md - Lines: 1824 - Chars: 102305 - Tokens: 25577
64. src\Artifacts\A55. DCE - FSService Refactoring Plan.md - Lines: 77 - Chars: 4022 - Tokens: 1006
65. src\Artifacts\A56. DCE - Phase 2 - Advanced Diff Viewer Plan.md - Lines: 54 - Chars: 6122 - Tokens: 1531
66. src\Artifacts\A57. DCE - Phase 2 - Cycle Management Plan.md - Lines: 44 - Chars: 3625 - Tokens: 907
67. src\Artifacts\A58. DCE - WinMerge Source Code Analysis.md - Lines: 56 - Chars: 5322 - Tokens: 1331
68. src\Artifacts\A6. DCE - Initial Scaffolding Deployment Script.md - Lines: 1282 - Chars: 43686 - Tokens: 10922
69. src\Artifacts\A7. DCE - Development and Testing Guide.md - Lines: 47 - Chars: 3075 - Tokens: 769
70. src\Artifacts\A8. DCE - Phase 1 - Selection Sets Feature Plan.md - Lines: 65 - Chars: 6043 - Tokens: 1511
71. src\Artifacts\A9. DCE - GitHub Repository Setup Guide.md - Lines: 71 - Chars: 3094 - Tokens: 774
72. src\backend\commands\commands.ts - Lines: 97 - Chars: 4211 - Tokens: 1053
73. src\backend\commands\register-commands.ts - Lines: 11 - Chars: 456 - Tokens: 114
74. src\backend\services\action.service.ts - Lines: 60 - Chars: 1831 - Tokens: 458
75. src\backend\services\content-extraction.service.ts - Lines: 148 - Chars: 7681 - Tokens: 1921
76. src\backend\services\file-operation.service.ts - Lines: 231 - Chars: 10878 - Tokens: 2720
77. src\backend\services\file-tree.service.ts - Lines: 212 - Chars: 11447 - Tokens: 2862
78. src\backend\services\flattener.service.ts - Lines: 210 - Chars: 11271 - Tokens: 2818
79. src\backend\services\highlighting.service.ts - Lines: 58 - Chars: 2920 - Tokens: 730
80. src\backend\services\history.service.ts - Lines: 129 - Chars: 5675 - Tokens: 1419
81. src\backend\services\logger.service.ts - Lines: 38 - Chars: 1115 - Tokens: 279
82. src\backend\services\prompt.service.ts - Lines: 151 - Chars: 16535 - Tokens: 4134
83. src\backend\services\selection.service.ts - Lines: 133 - Chars: 5411 - Tokens: 1353
84. src\backend\services\services.ts - Lines: 35 - Chars: 1597 - Tokens: 400
85. src\backend\types\git.ts - Lines: 79 - Chars: 1944 - Tokens: 486
86. src\client\components\Checkbox.tsx - Lines: 25 - Chars: 814 - Tokens: 204
87. src\client\components\ContextMenu.tsx - Lines: 67 - Chars: 3083 - Tokens: 771
88. src\client\components\DiffViewer.tsx - Lines: 148 - Chars: 7315 - Tokens: 1829
89. src\client\components\file-tree\FileTree.tsx - Lines: 262 - Chars: 11897 - Tokens: 2975
90. src\client\components\file-tree\FileTree.utils.ts - Lines: 189 - Chars: 7284 - Tokens: 1821
91. src\client\components\SelectedFilesView.tsx - Lines: 276 - Chars: 13099 - Tokens: 3275
92. src\client\components\tree-view\TreeView.tsx - Lines: 394 - Chars: 18029 - Tokens: 4508
93. src\client\components\tree-view\TreeView.utils.ts - Lines: 13 - Chars: 333 - Tokens: 84
94. src\client\utils\logger.ts - Lines: 19 - Chars: 762 - Tokens: 191
95. src\client\utils\response-parser.ts - Lines: 77 - Chars: 2854 - Tokens: 714
96. src\client\views\context-chooser.view\index.ts - Lines: 7 - Chars: 184 - Tokens: 46
97. src\client\views\context-chooser.view\on-message.ts - Lines: 53 - Chars: 4913 - Tokens: 1229
98. src\client\views\context-chooser.view\view.scss - Lines: 591 - Chars: 14549 - Tokens: 3638
99. src\client\views\context-chooser.view\view.tsx - Lines: 435 - Chars: 22245 - Tokens: 5562
100. src\client\views\index.ts - Lines: 39 - Chars: 1890 - Tokens: 473
101. src\client\views\parallel-copilot.view\index.ts - Lines: 9 - Chars: 238 - Tokens: 60
102. src\client\views\parallel-copilot.view\on-message.ts - Lines: 47 - Chars: 2218 - Tokens: 555
103. src\client\views\parallel-copilot.view\TestPane1.tsx - Lines: 43 - Chars: 1890 - Tokens: 473
104. src\client\views\parallel-copilot.view\TestPane2.tsx - Lines: 71 - Chars: 3447 - Tokens: 862
105. src\client\views\parallel-copilot.view\TestPane3.tsx - Lines: 81 - Chars: 3827 - Tokens: 957
106. src\client\views\parallel-copilot.view\view.scss - Lines: 477 - Chars: 11138 - Tokens: 2785
107. src\client\views\parallel-copilot.view\view.tsx - Lines: 430 - Chars: 22264 - Tokens: 5566
108. src\common\ipc\channels.enum.ts - Lines: 66 - Chars: 3257 - Tokens: 815
109. src\common\ipc\channels.type.ts - Lines: 59 - Chars: 4600 - Tokens: 1150
110. src\common\ipc\client-ipc.ts - Lines: 44 - Chars: 1590 - Tokens: 398
111. src\common\ipc\get-vscode-api.ts - Lines: 12 - Chars: 239 - Tokens: 60
112. src\common\ipc\server-ipc.ts - Lines: 42 - Chars: 1562 - Tokens: 391
113. src\common\types\file-node.ts - Lines: 16 - Chars: 567 - Tokens: 142
114. src\common\types\pcpp.types.ts - Lines: 36 - Chars: 914 - Tokens: 229
115. src\common\types\vscode-webview.d.ts - Lines: 15 - Chars: 449 - Tokens: 113
116. src\common\utils\formatting.ts - Lines: 95 - Chars: 3251 - Tokens: 813
117. src\common\utils\view-html.ts - Lines: 29 - Chars: 1117 - Tokens: 280
118. src\common\view-types.ts - Lines: 8 - Chars: 182 - Tokens: 46
119. src\extension.ts - Lines: 121 - Chars: 5044 - Tokens: 1261
120. The-Creator-AI-main\.eslintrc.json - Lines: 30 - Chars: 662 - Tokens: 166
121. The-Creator-AI-main\.gitignore - Lines: 8 - Chars: 75 - Tokens: 19
122. The-Creator-AI-main\.vscode-test.mjs - Lines: 6 - Chars: 117 - Tokens: 30
123. The-Creator-AI-main\.vscodeignore - Lines: 15 - Chars: 192 - Tokens: 48
124. The-Creator-AI-main\CHANGELOG.md - Lines: 9 - Chars: 241 - Tokens: 61
125. The-Creator-AI-main\LICENSE - Lines: 22 - Chars: 1069 - Tokens: 268
126. The-Creator-AI-main\Notes.md - Lines: 2 - Chars: 67 - Tokens: 17
127. The-Creator-AI-main\package.json - Lines: 181 - Chars: 5082 - Tokens: 1271
128. The-Creator-AI-main\postcss.config.js - Lines: 7 - Chars: 82 - Tokens: 21
129. The-Creator-AI-main\public\main.css - Lines: 40 - Chars: 559 - Tokens: 140
130. The-Creator-AI-main\public\reset.css - Lines: 30 - Chars: 233 - Tokens: 59
131. The-Creator-AI-main\public\spiral.svg - Lines: 17 - Chars: 579 - Tokens: 145
132. The-Creator-AI-main\public\vscode.css - Lines: 91 - Chars: 1977 - Tokens: 495
133. The-Creator-AI-main\README.md - Lines: 44 - Chars: 1614 - Tokens: 404
134. The-Creator-AI-main\src\backend\commands\commands.ts - Lines: 138 - Chars: 4691 - Tokens: 1173
135. The-Creator-AI-main\src\backend\commands\register-commands.ts - Lines: 11 - Chars: 382 - Tokens: 96
136. The-Creator-AI-main\src\backend\repositories\chat.respository.ts - Lines: 142 - Chars: 3906 - Tokens: 977
137. The-Creator-AI-main\src\backend\repositories\persistent-store.repository.ts - Lines: 28 - Chars: 897 - Tokens: 225
138. The-Creator-AI-main\src\backend\repositories\settings.repository.ts - Lines: 62 - Chars: 1694 - Tokens: 424
139. The-Creator-AI-main\src\backend\services\code.service.ts - Lines: 344 - Chars: 10472 - Tokens: 2618
140. The-Creator-AI-main\src\backend\services\fs.service.ts - Lines: 323 - Chars: 9979 - Tokens: 2495
141. The-Creator-AI-main\src\backend\services\git.service.ts - Lines: 41 - Chars: 1411 - Tokens: 353
142. The-Creator-AI-main\src\backend\services\llm.service.ts - Lines: 264 - Chars: 8622 - Tokens: 2156
143. The-Creator-AI-main\src\backend\services\logger.service.ts - Lines: 55 - Chars: 1371 - Tokens: 343
144. The-Creator-AI-main\src\backend\services\message.service.ts - Lines: 58 - Chars: 1661 - Tokens: 416
145. The-Creator-AI-main\src\backend\services\plan-exim.service.ts - Lines: 114 - Chars: 4560 - Tokens: 1140
146. The-Creator-AI-main\src\backend\services\services.ts - Lines: 67 - Chars: 1964 - Tokens: 491
147. The-Creator-AI-main\src\backend\services\task-queue.service.ts - Lines: 128 - Chars: 3921 - Tokens: 981
148. The-Creator-AI-main\src\backend\types\llm-service.enum.ts - Lines: 6 - Chars: 94 - Tokens: 24
149. The-Creator-AI-main\src\backend\types\storage-keys.enum.ts - Lines: 6 - Chars: 202 - Tokens: 51
150. The-Creator-AI-main\src\backend\utils\handleActiveTabChange.ts - Lines: 26 - Chars: 775 - Tokens: 194
151. The-Creator-AI-main\src\backend\utils\mergeOpenEditorsWithSelectedFiles.ts - Lines: 33 - Chars: 952 - Tokens: 238
152. The-Creator-AI-main\src\backend\utils\remoteSetChangePlanViewState.ts - Lines: 26 - Chars: 989 - Tokens: 248
153. The-Creator-AI-main\src\client\components\AutoResizingTextarea.tsx - Lines: 49 - Chars: 2000 - Tokens: 500
154. The-Creator-AI-main\src\client\components\Checkbox.tsx - Lines: 26 - Chars: 815 - Tokens: 204
155. The-Creator-AI-main\src\client\components\ErrorBoundary.tsx - Lines: 44 - Chars: 1220 - Tokens: 305
156. The-Creator-AI-main\src\client\components\file-tree\FileTree.scss - Lines: 9 - Chars: 157 - Tokens: 40
157. The-Creator-AI-main\src\client\components\file-tree\FileTree.tsx - Lines: 137 - Chars: 4398 - Tokens: 1100
158. The-Creator-AI-main\src\client\components\file-tree\FileTree.utils.ts - Lines: 68 - Chars: 2214 - Tokens: 554
159. The-Creator-AI-main\src\client\components\Modal.tsx - Lines: 91 - Chars: 2649 - Tokens: 663
160. The-Creator-AI-main\src\client\components\ProgressSteps.tsx - Lines: 59 - Chars: 1648 - Tokens: 412
161. The-Creator-AI-main\src\client\components\tree-view\TreeView.tsx - Lines: 84 - Chars: 2738 - Tokens: 685
162. The-Creator-AI-main\src\client\components\tree-view\TreeView.utils.ts - Lines: 14 - Chars: 316 - Tokens: 79
163. The-Creator-AI-main\src\client\modules\api-keys-management.module\ApiKeysManagement.tsx - Lines: 150 - Chars: 6318 - Tokens: 1580
164. The-Creator-AI-main\src\client\modules\commit.module\Commit.tsx - Lines: 63 - Chars: 3218 - Tokens: 805
165. The-Creator-AI-main\src\client\modules\context.module\Context.tsx - Lines: 87 - Chars: 4052 - Tokens: 1013
166. The-Creator-AI-main\src\client\modules\plan.module\components\file-card.tsx - Lines: 93 - Chars: 4112 - Tokens: 1028
167. The-Creator-AI-main\src\client\modules\plan.module\formatted-plan-preview.tsx - Lines: 172 - Chars: 6480 - Tokens: 1620
168. The-Creator-AI-main\src\client\modules\plan.module\plan-input-box.tsx - Lines: 139 - Chars: 6410 - Tokens: 1603
169. The-Creator-AI-main\src\client\modules\plan.module\Plan.tsx - Lines: 55 - Chars: 1749 - Tokens: 438
170. The-Creator-AI-main\src\client\store\store.ts - Lines: 20 - Chars: 479 - Tokens: 120
171. The-Creator-AI-main\src\client\store\useStore.ts - Lines: 26 - Chars: 627 - Tokens: 157
172. The-Creator-AI-main\src\client\views\change-plan.view\index.ts - Lines: 9 - Chars: 221 - Tokens: 56
173. The-Creator-AI-main\src\client\views\change-plan.view\logic\commitStagedChanges.ts - Lines: 11 - Chars: 385 - Tokens: 97
174. The-Creator-AI-main\src\client\views\change-plan.view\logic\getSelectedFiles.ts - Lines: 37 - Chars: 1294 - Tokens: 324
175. The-Creator-AI-main\src\client\views\change-plan.view\logic\handleCommitMessageSuggestions.ts - Lines: 15 - Chars: 580 - Tokens: 145
176. The-Creator-AI-main\src\client\views\change-plan.view\logic\handleFileClick.ts - Lines: 24 - Chars: 665 - Tokens: 167
177. The-Creator-AI-main\src\client\views\change-plan.view\logic\handleSubmitPlanRequest.ts - Lines: 79 - Chars: 2463 - Tokens: 616
178. The-Creator-AI-main\src\client\views\change-plan.view\logic\requestCommitMessageSuggestions.ts - Lines: 15 - Chars: 511 - Tokens: 128
179. The-Creator-AI-main\src\client\views\change-plan.view\logic\setupChannelHandlers.ts - Lines: 102 - Chars: 3069 - Tokens: 768
180. The-Creator-AI-main\src\client\views\change-plan.view\logic\updateOrCreateChangePlan.ts - Lines: 51 - Chars: 1633 - Tokens: 409
181. The-Creator-AI-main\src\client\views\change-plan.view\on-mesage.ts - Lines: 271 - Chars: 9696 - Tokens: 2424
182. The-Creator-AI-main\src\client\views\change-plan.view\store\change-plan-view.initial-state.ts - Lines: 17 - Chars: 453 - Tokens: 114
183. The-Creator-AI-main\src\client\views\change-plan.view\store\change-plan-view.logic.ts - Lines: 54 - Chars: 1617 - Tokens: 405
184. The-Creator-AI-main\src\client\views\change-plan.view\store\change-plan-view.state-type.ts - Lines: 34 - Chars: 843 - Tokens: 211
185. The-Creator-AI-main\src\client\views\change-plan.view\store\change-plan-view.store.ts - Lines: 18 - Chars: 672 - Tokens: 168
186. The-Creator-AI-main\src\client\views\change-plan.view\view.constants.ts - Lines: 6 - Chars: 134 - Tokens: 34
187. The-Creator-AI-main\src\client\views\change-plan.view\view.scss - Lines: 10 - Chars: 160 - Tokens: 40
188. The-Creator-AI-main\src\client\views\change-plan.view\view.tsx - Lines: 91 - Chars: 2823 - Tokens: 706
189. The-Creator-AI-main\src\client\views\chat.view\index.ts - Lines: 9 - Chars: 208 - Tokens: 52
190. The-Creator-AI-main\src\client\views\chat.view\on-mesage.ts - Lines: 50 - Chars: 1545 - Tokens: 387
191. The-Creator-AI-main\src\client\views\chat.view\view.scss - Lines: 10 - Chars: 160 - Tokens: 40
192. The-Creator-AI-main\src\client\views\chat.view\view.tsx - Lines: 71 - Chars: 2614 - Tokens: 654
193. The-Creator-AI-main\src\client\views\file-explorer.view\index.ts - Lines: 9 - Chars: 225 - Tokens: 57
194. The-Creator-AI-main\src\client\views\file-explorer.view\on-mesage.ts - Lines: 49 - Chars: 1773 - Tokens: 444
195. The-Creator-AI-main\src\client\views\file-explorer.view\view.scss - Lines: 10 - Chars: 160 - Tokens: 40
196. The-Creator-AI-main\src\client\views\file-explorer.view\view.tsx - Lines: 62 - Chars: 2265 - Tokens: 567
197. The-Creator-AI-main\src\client\views\index.ts - Lines: 54 - Chars: 1714 - Tokens: 429
198. The-Creator-AI-main\src\common\constants\agents.constants.ts - Lines: 837 - Chars: 36635 - Tokens: 9159
199. The-Creator-AI-main\src\common\firebase.ts - Lines: 22 - Chars: 874 - Tokens: 219
200. The-Creator-AI-main\src\common\ipc\channels.enum.ts - Lines: 37 - Chars: 1831 - Tokens: 458
201. The-Creator-AI-main\src\common\ipc\channels.type.ts - Lines: 125 - Chars: 3933 - Tokens: 984
202. The-Creator-AI-main\src\common\ipc\client-ipc.ts - Lines: 42 - Chars: 1338 - Tokens: 335
203. The-Creator-AI-main\src\common\ipc\get-vscode-api.ts - Lines: 12 - Chars: 239 - Tokens: 60
204. The-Creator-AI-main\src\common\ipc\server-ipc.ts - Lines: 44 - Chars: 1522 - Tokens: 381
205. The-Creator-AI-main\src\common\types\file-node.ts - Lines: 6 - Chars: 96 - Tokens: 24
206. The-Creator-AI-main\src\common\types\vscode-webview.d.ts - Lines: 49 - Chars: 1607 - Tokens: 402
207. The-Creator-AI-main\src\common\utils\firebaseLogger.ts - Lines: 43 - Chars: 1108 - Tokens: 277
208. The-Creator-AI-main\src\common\utils\key-path.ts - Lines: 43 - Chars: 1036 - Tokens: 259
209. The-Creator-AI-main\src\common\utils\parse-json.ts - Lines: 20 - Chars: 515 - Tokens: 129
210. The-Creator-AI-main\src\common\utils\view-html.ts - Lines: 35 - Chars: 1271 - Tokens: 318
211. The-Creator-AI-main\src\common\view-types.ts - Lines: 8 - Chars: 184 - Tokens: 46
212. The-Creator-AI-main\src\extension.ts - Lines: 24 - Chars: 623 - Tokens: 156
213. The-Creator-AI-main\src\test\extension.test.ts - Lines: 16 - Chars: 459 - Tokens: 115
214. The-Creator-AI-main\tailwind.config.js - Lines: 102 - Chars: 6814 - Tokens: 1704
215. The-Creator-AI-main\tsconfig.json - Lines: 31 - Chars: 814 - Tokens: 204
216. The-Creator-AI-main\vsc-extension-quickstart.md - Lines: 49 - Chars: 2893 - Tokens: 724
217. The-Creator-AI-main\webpack.config.js - Lines: 98 - Chars: 2795 - Tokens: 699
218. tsconfig.json - Lines: 27 - Chars: 632 - Tokens: 158
219. webpack.config.js - Lines: 103 - Chars: 2830 - Tokens: 708
220. winmerge_flattened_repo.md - Lines: 33169 - Chars: 986685 - Tokens: 246672

<file path=".gitignore">
node_modules
package-lock.json
dist
out
*.vsix
.vscode-test/
.vscode/
The-Creator-AI-main/
prompt.md
.vscode/dce_cache/
</file>

<file path=".vscodeignore">
# This file tells the VS Code packaging tool which files to ignore.
# We are removing 'node_modules' because our external dependencies (like xlsx)
# need to be included in the final package to be available at runtime.
# The `vsce` tool is smart enough to only bundle production dependencies.

src
.gitignore
webpack.config.js
tsconfig.json
**/*.map
**/*.ts
</file>

<file path="bootstrap-flattener.js">
#!/usr/bin/env node
/**
 * bootstrap-flattener.js
 *
 * This script recursively finds all files in a given directory, ignoring specified
 * patterns, and concatenates them into a single output file with a metadata header.
 *
 * Updated on: Cycle 2
 * - Added comprehensive metadata header including:
 *   - Total file, line, character, and token counts.
 *   - Top 10 files by token count.
 *   - A full list of all processed files with their stats.
 * - Added a configurable `DEFAULT_IGNORE` set to exclude common unnecessary files
 *   and directories (e.g., node_modules, .git, package-lock.json).
 * - Logic inspired by `flattenv2.js` to provide more useful output.
 */

const fs = require('fs').promises;
const path = require('path');

const OUTPUT_FILENAME = 'flattened_repo.md';

// --- Configuration ---
// Files and directories to ignore. Uses simple string matching.
const DEFAULT_IGNORE = new Set([
  'node_modules',
  '.git',
  '.vscode',
  'dist',
  'out',
  'package-lock.json',
  '.DS_Store',
  '.npm',
  '.yarn',
  'flattened_repo.md',
  'prompt.md'
]);


/**
 * Recursively gets all file paths in a directory, respecting the ignore list.
 * @param {string} dirPath The directory to start from.
 * @param {Set<string>} ignoreSet The set of directory/file names to ignore.
 * @returns {Promise<string[]>} A promise that resolves to an array of file paths.
 */
async function getFilePaths(dirPath, ignoreSet) {
  let filePaths = [];
  const entries = await fs.readdir(dirPath, { withFileTypes: true });

  for (const entry of entries) {
    if (ignoreSet.has(entry.name)) {
      continue;
    }

    const fullPath = path.join(dirPath, entry.name);
    if (entry.isDirectory()) {
      filePaths = filePaths.concat(await getFilePaths(fullPath, ignoreSet));
    } else {
      filePaths.push(fullPath);
    }
  }
  return filePaths;
}

/**
 * Gets stats and content for a single file.
 * @param {string} filePath The path to the file.
 * @returns {Promise<object>} An object with file stats and content.
 */
async function getFileStatsAndContent(filePath) {
    try {
        const content = await fs.readFile(filePath, 'utf-8');
        const lines = content.split('\n').length;
        const characters = content.length;
        const tokens = Math.ceil(characters / 4); // Simple approximation
        return { filePath, lines, characters, tokens, content, error: null };
    } catch (error) {
        console.warn(`Warning: Could not read file ${filePath}. Error: ${error.message}`);
        return { filePath, lines: 0, characters: 0, tokens: 0, content: `Error reading file: ${error.message}`, error: error.message };
    }
}


/**
 * The main function to execute the script.
 */
async function main() {
  const args = process.argv.slice(2);
  if (args.length !== 1) {
    console.error('Usage: node bootstrap-flattener.js <directory_path>');
    process.exit(1);
  }

  const rootDir = path.resolve(args[0]);
  const outputFilePath = path.join(process.cwd(), OUTPUT_FILENAME);

  try {
    await fs.access(rootDir);
  } catch (error) {
    console.error(`Error: Directory not found at ${rootDir}`);
    process.exit(1);
  }

  console.log(`Starting to flatten repository at: ${rootDir}`);
  console.log(`Ignoring: ${[...DEFAULT_IGNORE].join(', ')}`);

  const filePaths = await getFilePaths(rootDir, DEFAULT_IGNORE);
  console.log(`Found ${filePaths.length} files to process...`);

  const results = await Promise.all(filePaths.map(getFileStatsAndContent));

  let totalLines = 0;
  let totalCharacters = 0;
  let totalTokens = 0;
  let errorCount = 0;

  for (const res of results) {
      if (!res.error) {
          totalLines += res.lines;
          totalCharacters += res.characters;
          totalTokens += res.tokens;
      } else {
          errorCount++;
      }
  }

  // --- Build Metadata Header ---
  let output = `<!--\n`;
  output += `  File: ${OUTPUT_FILENAME}\n`;
  output += `  Source Directory: ${rootDir}\n`;
  output += `  Date Generated: ${new Date().toISOString()}\n`;
  output += `  ---\n`;
  output += `  Total Files: ${results.length}\n`;
  if (errorCount > 0) {
      output += `  Files with Errors: ${errorCount}\n`;
  }
  output += `  Total Lines: ${totalLines}\n`;
  output += `  Total Characters: ${totalCharacters}\n`;
  output += `  Approx. Tokens: ${totalTokens}\n`;
  output += `-->\n\n`;

  // --- Top 10 Files by Tokens ---
  const top10 = results
    .filter(r => !r.error)
    .sort((a, b) => b.tokens - a.tokens)
    .slice(0, 10);

  output += `<!-- Top 10 Files by Token Count -->\n`;
  top10.forEach((r, i) => {
     output += `${i + 1}. ${path.relative(rootDir, r.filePath)} (${r.tokens} tokens)\n`;
  });
  output += `\n`;

  // --- Full File List ---
  output += `<!-- Full File List -->\n`;
  results.forEach((r, i) => {
    const relativePath = path.relative(rootDir, r.filePath);
    if (r.error) {
        output += `${i + 1}. ${relativePath} - ERROR: ${r.error}\n`;
    } else {
        output += `${i + 1}. ${relativePath} - Lines: ${r.lines} - Chars: ${r.characters} - Tokens: ${r.tokens}\n`;
    }
  });
  output += `\n`;


  // --- File Contents ---
  for (const { filePath, content } of results) {
    const relativePath = path.relative(rootDir, filePath).replace(/\\/g, '/');
    output += `<file path="${relativePath}">\n`;
    output += content;
    if (!content.endsWith('\n')) {
      output += '\n';
    }
    output += `</file>\n\n`;
  }

  await fs.writeFile(outputFilePath, output);
  console.log(`âœ… Success! Flattened repository saved to: ${outputFilePath}`);
}

main().catch(err => {
  console.error('An unexpected error occurred:', err);
  process.exit(1);
});
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025 David Gerabagi

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="package.json">
{
    "name": "data-curation-environment",
    "publisher": "DCE-Developer",
    "displayName": "Data Curation Environment",
    "description": "A VS Code extension for curating context for Large Language Models.",
    "version": "0.0.3",
    "repository": {
        "type": "git",
        "url": "https://github.com/dgerabagi/data-curation-environment.git"
    },
    "engines": {
        "vscode": "^1.90.0"
    },
    "categories": [
        "Other"
    ],
    "activationEvents": [
        "onView:data-curation-environment",
        "onCommand:dce.showParallelCopilot"
    ],
    "main": "./dist/extension.js",
    "contributes": {
        "commands": [
            {
                "command": "dce.saveCurrentSelection",
                "title": "DCE: Save Current Selection Set",
                "category": "DCE"
            },
            {
                "command": "dce.loadSelectionSet",
                "title": "DCE: Load Selection Set",
                "category": "DCE"
            },
            {
                "command": "dce.manageSelectionSets",
                "title": "DCE: Manage Selection Sets",
                "category": "DCE"
            },
            {
                "command": "dce.refreshTree",
                "title": "DCE: Refresh Explorer",
                "category": "DCE"
            },
            {
                "command": "dce.openParallelCopilot",
                "title": "DCE: Open Parallel Co-Pilot",
                "category": "DCE",
                "icon": "$(multiple-windows)"
            },
            {
                "command": "dce.showParallelCopilot",
                "title": "DCE: Show Parallel Co-Pilot"
            }
        ],
        "viewsContainers": {
            "activitybar": [
                {
                    "id": "data-curation-environment",
                    "title": "Data Curation",
                    "icon": "public/spiral.svg"
                },
                {
                    "id": "dce-parallel-copilot-container",
                    "title": "DCE Parallel Co-Pilot",
                    "icon": "public/copilot.svg"
                }
            ]
        },
        "views": {
            "data-curation-environment": [
                {
                    "type": "webview",
                    "id": "viewType.sidebar.contextChooser",
                    "name": "Data Curation"
                }
            ]
        },
        "menus": {
            "view/title": [
                {
                    "command": "dce.openParallelCopilot",
                    "when": "view == viewType.sidebar.contextChooser",
                    "group": "navigation"
                }
            ],
            "activityBar/view/title": [
                 {
                    "command": "dce.showParallelCopilot",
                    "when": "viewContainer == dce-parallel-copilot-container"
                }
            ]
        }
    },
    "scripts": {
        "vscode:prepublish": "npm run package",
        "compile": "webpack",
        "watch": "webpack --watch",
        "package": "webpack --mode production --devtool hidden-source-map",
        "lint": "eslint src --ext ts"
    },
    "devDependencies": {
        "@types/node": "18.x",
        "@types/vscode": "^1.90.0",
        "@typescript-eslint/eslint-plugin": "^7.7.1",
        "@typescript-eslint/parser": "^7.7.1",
        "eslint": "^8.57.0",
        "ts-loader": "^9.5.1",
        "typescript": "^5.4.5",
        "webpack": "^5.91.0",
        "webpack-cli": "^5.1.4",
        "copy-webpack-plugin": "^12.0.2",
        "mini-css-extract-plugin": "^2.9.0",
        "style-loader": "^4.0.0",
        "css-loader": "^7.1.2",
        "sass-loader": "^16.0.1",
        "sass": "^1.78.0",
        "postcss-loader": "^8.1.1",
        "babel-loader": "^9.1.3",
        "@babel/preset-react": "^7.24.7",
        "@babel/preset-typescript": "^7.24.7",
        "process": "^0.11.10",
        "path-browserify": "^1.0.1"
    },
    "dependencies": {
        "@wooorm/starry-night": "^3.8.0",
        "hast-util-to-html": "^9.0.1",
        "react": "^18.3.1",
        "react-dom": "^18.3.1",
        "react-icons": "^5.3.0",
        "react-markdown": "^9.0.1",
        "rxjs": "^7.8.1",
        "reflect-metadata": "^0.2.2",
        "pdf-parse": "^1.1.1",
        "xlsx": "^0.18.5",
        "mammoth": "^1.8.0",
        "diff": "^5.2.0",
        "@types/diff": "^5.2.1"
    }
}
</file>

<file path="public/copilot.svg">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor" class="w-4 h-4">
  <path d="M6.5 3.5v8a.5.5 0 0 0 .5.5h2a.5.5 0 0 0 .5-.5v-8a.5.5 0 0 0-.5-.5h-2a.5.5 0 0 0-.5.5ZM7 4h2v7H7V4Z"/>
  <path d="M2.5 3.5v8a.5.5 0 0 0 .5.5h2a.5.5 0 0 0 .5-.5v-8a.5.5 0 0 0-.5-.5h-2a.5.5 0 0 0-.5.5ZM3 4h2v7H3V4Z"/>
  <path d="M10.5 3.5v8a.5.5 0 0 0 .5.5h2a.5.5 0 0 0 .5-.5v-8a.5.5 0 0 0-.5-.5h-2a.5.5 0 0 0-.5.5ZM11 4h2v7h-2V4Z"/>
</svg>
</file>

<file path="public/spiral.svg">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200">
    <g id="Page-1" stroke="none" fill="none" fill-rule="evenodd">
        <g id="dep" transform="translate(4, 6)">
            <path d="M100 100 m 0 -80 a 80 80 0 0 1 0 160 a 70 70 0 0 1 0 -140 a 60 60 0 0 1 0 120 a 50 50 0 0 1 0 -100 a 40 40 0 0 1 0 80 a 30 30 0 0 1 0 -60 a 20 20 0 0 1 0 40"
                fill="none" stroke="white" stroke-width="8" id="Shape" />
        </g>
    </g>
</svg>
</file>

<file path="src/Artifacts/A0. DCE Master Artifact List.md">
# Artifact A0: DCE Master Artifact List
# Date Created: C1
# Author: AI Model & Curator
# Updated on: C129 (Add A58 for WinMerge Source Code Analysis)

## 1. Purpose

# This file serves as the definitive, parseable list of all documentation artifacts for the "Data Curation Environment" (DCE) VS Code Extension project.

## 2. Formatting Rules for Parsing

# *   Lines beginning with `#` are comments and are ignored.
# *   `##` denotes a major category header and is ignored.
# *   `###` denotes an artifact entry. The text following it is the artifact's full name and ID.
# *   Lines beginning with `- **Description:**` provide context for the project.
# *   Lines beginning with `- **Tags:**` provide keywords for Inference.

## 3. Artifacts List

## I. Project Planning & Design

### A1. DCE - Project Vision and Goals
- **Description:** High-level overview of the DCE VS Code extension, its purpose, and the three-phase development plan.
- **Tags:** project vision, goals, scope, phase 1, phase 2, phase 3, vs code extension

### A2. DCE - Phase 1 - Context Chooser - Requirements & Design
- **Description:** Detailed functional and technical requirements for Phase 1, focusing on the file tree with checkboxes and the flattening functionality.
- **Tags:** requirements, design, phase 1, context chooser, tree view, checkbox, flatten, vs code api

### A3. DCE - Technical Scaffolding Plan
- **Description:** Outlines the proposed file structure, technologies, and key VS Code API components for the extension, based on the `The-Creator-AI-main` reference repo.
- **Tags:** technical plan, scaffolding, file structure, typescript, vs code extension, api

### A4. DCE - Analysis of The-Creator-AI Repo
- **Description:** Provides a detailed analysis of the `The-Creator-AI-main` reference repository, its architecture, and its mapping to the Data Curation Environment project goals.
- **Tags:** analysis, repository, architecture, vscode-extension, project-planning

### A5. DCE - Target File Structure
- **Description:** A text-based representation of the target file structure for the DCE extension, outlining the layout of directories and key files.
- **Tags:** file structure, architecture, project layout, scaffolding

### A6. DCE - Initial Scaffolding Deployment Script
- **Description:** Contains a Node.js script that, when executed, creates the entire initial directory structure and files for the DCE extension project.
- **Tags:** deployment, script, scaffolding, bootstrap, nodejs, automation

### A7. DCE - Development and Testing Guide
- **Description:** A step-by-step guide explaining how to run, debug, and test the DCE extension within VS Code using the Extension Development Host.
- **Tags:** development, testing, debugging, workflow, vs code extension, f5

### A8. DCE - Phase 1 - Selection Sets Feature Plan
- **Description:** A plan outlining the user stories, UI/UX, and technical implementation for saving, loading, and persisting different sets of selected files (selection profiles).
- **Tags:** feature plan, selection sets, profiles, context management, persistence, phase 1

### A9. DCE - GitHub Repository Setup Guide
- **Description:** A step-by-step guide with the necessary git commands to initialize the project as a local repository and push it to a new remote repository on GitHub.
- **Tags:** git, github, version control, setup, repository

### A10. DCE - Metadata and Statistics Display
- **Description:** Outlines the requirements and design for displaying live metadata (total selected files, total tokens) and for showing aggregate statistics (token and file counts) for folders in the file tree.
- **Tags:** feature plan, metadata, statistics, token count, ui, ux

### A11. DCE - Regression Case Studies
- **Description:** Documents recurring bugs, their root causes, and codified solutions to prevent future regressions during development.
- **Tags:** bugs, regression, troubleshooting, development, best practices

### A12. DCE - Logging and Debugging Guide
- **Description:** Explains how to access and use the integrated logging solution for debugging the extension's backend and frontend components.
- **Tags:** logging, debugging, troubleshooting, development, output channel

### A13. DCE - Phase 1 - Right-Click Context Menu
- **Description:** A plan for implementing standard file explorer context menu actions (e.g., Rename, Delete, Copy Path) in the custom file tree.
- **Tags:** feature plan, context menu, right-click, file operations, ux, phase 1

### A14. DCE - Ongoing Development Issues
- **Description:** A tracking document for recurring or persistent issues that need to be monitored across development cycles until they are confirmed as resolved.
- **Tags:** bugs, tracking, issues, logging, node_modules, performance

### A15. DCE - Phase 1 - Multi-Select & Sorting Feature Plan
- **Description:** Details the requirements for multi-selection (click, Ctrl, Shift) in both the main file tree and the "Selected Items" panel, and multi-level column sorting.
- **Tags:** feature plan, multi-select, sorting, list view, ux, phase 1

### A16. DCE - Phase 1 - UI & UX Refinements Plan
- **Description:** Covers visual and usability improvements like fixing panel layouts, resolving overflow bugs, adding loading indicators, and improving scrollbar visibility.
- **Tags:** feature plan, ui, ux, layout, bug fix, loading indicator, phase 1

### A17. DCE - Phase 1 - Advanced Tree View Features
- **Description:** Outlines the plan for advanced tree view interactions, specifically the implementation of scrollable, self-contained views for large, expanded folders.
- **Tags:** feature plan, tree view, ux, scrollable, phase 1

### A18. DCE - Phase 1 - Active File Sync Feature Plan
- **Description:** Details the requirements and implementation for automatically revealing and highlighting the active editor's file in the custom Data Curation file tree.
- **Tags:** feature plan, active file, sync, reveal, tree view, ux, phase 1

### A19. DCE - Phase 1 - File Interaction Plan (Click & Remove)
- **Description:** Details the requirements for opening files by single-clicking them and quickly removing single files from the selection list via a mouse-over action.
- **Tags:** feature plan, single-click, open file, quick remove, ux, phase 1

### A20. DCE - Phase 1 - Advanced UX & Automation Plan
- **Description:** Details plans for several UX enhancements, including auto-revealing the flattened file, showing selected counts in folder stats, and providing an option to auto-add new files to the selection.
- **Tags:** feature plan, ux, automation, reveal, statistics, auto-add, phase 1

### A21. DCE - Phase 1 - Feature Drift Analysis vs. VS Code Explorer
- **Description:** A comparative analysis documenting the functional and behavioral differences between the DCE custom file view and the native VS Code Explorer to guide future development and feature parity.
- **Tags:** feature plan, analysis, drift, ux, vs code explorer, parity

### A22. DCE - Phase 1 - Search & Filter Feature Plan
- **Description:** Outlines the requirements and implementation for a search bar to filter the main file tree view by file or folder name.
- **Tags:** feature plan, search, filter, tree view, ux, phase 1

### A23. DCE - Phase 1 - Advanced Interactions (Keyboard & Drag-Drop) Plan
- **Description:** Details the requirements for implementing full keyboard navigation and drag-and-drop file/folder operations within the main file tree.
- **Tags:** feature plan, keyboard navigation, drag and drop, file operations, accessibility, ux, phase 1

### A24. DCE - Selection Paradigm Terminology
- **Description:** A document to clarify the terminology used within the project to distinguish between different types of user selections (e.g., "checking" for flattening vs. "selecting" for actions).
- **Tags:** documentation, terminology, selection, checking, design

### A25. DCE - Phase 1 - Git & Problems Integration Plan
- **Description:** Outlines the user stories and technical approach for integrating Git status indicators and VS Code Problem Diagnostics into the custom file tree.
- **Tags:** feature plan, git, problems, diagnostics, ux, phase 1

### A26. DCE - Phase 1 - File System Traversal & Caching Strategy
- **Description:** Documents the root cause of the folder visibility bug and outlines the new strategy of using recursive directory traversal instead of `findFiles` to build a complete and accurate file system map.
- **Tags:** bug fix, file system, traversal, refresh, cache, architecture

### A27. DCE - Phase 1 - Undo-Redo Feature Plan
- **Description:** Details the requirements for implementing an undo/redo stack for file system operations (move, delete) performed within the DCE view, to achieve parity with the native explorer's Ctrl+Z functionality.
- **Tags:** feature plan, undo, redo, ctrl+z, file operations, ux, phase 1

### A28. DCE - Packaging and Distribution Guide
- **Description:** Provides a step-by-step guide on how to package the extension into a `.vsix` file for beta testing and distribution.
- **Tags:** packaging, distribution, vsix, vsce, deployment

### A29. DCE - Phase 1 - Binary and Image File Handling Strategy
- **Description:** Defines the strategy for handling binary files; they can be checked, but only their metadata (path, size) is included in the flattened output, not their content.
- **Tags:** feature plan, binary, image, metadata, flatten, phase 1

### A30. DCE - Phase 1 - PDF Handling and Virtualization Strategy
- **Description:** Defines the strategy for handling PDF files. Text is extracted on-demand and cached in memory for flattening, creating a "virtual" markdown file without modifying the user's workspace.
- **Tags:** feature plan, pdf, text extraction, virtualization, cache, phase 1

### A31. DCE - Phase 2 - Multimodal Content Extraction (PDF Images)
- **Description:** A plan for a future feature to extract images from PDF files and use a multimodal LLM to generate rich, textual descriptions for inclusion in the context.
- **Tags:** feature plan, multimodal, image to text, pdf, llm, phase 2

### A32. DCE - Phase 1 - Excel and CSV Handling Strategy
- **Description:** Defines the strategy for handling tabular data files (.xlsx, .xls, .csv) by converting them to Markdown tables on-demand and caching them in memory for flattening.
- **Tags:** feature plan, excel, csv, text extraction, virtualization, cache, phase 1

### A33. DCE - Phase 1 - Copy-Paste Feature Plan
- **Description:** Details the requirements and implementation for copying and pasting files and folders within the DCE file tree using standard keyboard shortcuts (Ctrl+C, Ctrl+V).
- **Tags:** feature plan, copy, paste, file operations, keyboard shortcuts, ux, phase 1

### A34. DCE - Phase 2 - Parallel Co-Pilot Panel - Vision & Requirements
- **Description:** Outlines the high-level vision and user stories for the Phase 2 multi-tabbed editor panel, designed for comparing and managing multiple AI-generated responses.
- **Tags:** feature plan, phase 2, co-pilot, multi-tab, ui, ux, requirements

### A35. DCE - Phase 2 - UI Mockups and Flow
- **Description:** Provides a detailed textual description and flow diagram for the user interface of the Parallel Co-Pilot Panel, including tab management and the "swap" interaction.
- **Tags:** feature plan, phase 2, ui, ux, mockup, workflow

### A36. DCE - Phase 2 - Technical Implementation Plan
- **Description:** Details the technical approach for building the Parallel Co-Pilot Panel, including the new webview provider, state management, IPC channels, and backend logic for file content swapping.
- **Tags:** feature plan, phase 2, technical plan, architecture, webview, ipc

### A37. DCE - Phase 2 - Cycle Navigator & Knowledge Graph - Vision
- **Description:** Outlines the vision for a cycle-based navigation system to browse the history of AI-generated responses and project states, creating a navigable knowledge graph.
- **Tags:** feature plan, phase 2, knowledge graph, history, cycle navigator, ui, ux

### A38. DCE - Phase 2 - Cycle Navigator - UI Mockup
- **Description:** Provides a textual mockup and interaction flow for the Cycle Navigator UI, including the cycle counter and navigation controls within the Parallel Co-Pilot Panel.
- **Tags:** feature plan, phase 2, ui, ux, mockup, workflow, cycle navigator

### A39. DCE - Phase 2 - Cycle Navigator - Technical Plan
- **Description:** Details the technical approach for implementing the Cycle Navigator, including data structures for storing cycle-specific responses and the state management for historical navigation.
- **Tags:** feature plan, phase 2, technical plan, architecture, state management, data model

### A40. DCE - Phase 2 - Parallel Co-Pilot - Target File Structure
- **Description:** A text-based representation of the target file structure for the new Phase 2 Parallel Co-Pilot panel, outlining the layout of new directories and key files.
- **Tags:** file structure, architecture, project layout, scaffolding, phase 2

### A40.1. DCE - Phase 2 - Competitive Analysis & Feature Ideas
- **Description:** An analysis of existing tools and extensions for managing multiple AI responses, with a list of potential features to incorporate into the Parallel Co-Pilot panel.
- **Tags:** feature plan, phase 2, research, competitive analysis, co-pilot

### A41. DCE - Phase 2 - API Key Management - Feature Plan
- **Description:** Outlines the user stories and technical plan for a settings UI where users can securely input and manage their API keys for various LLM services.
- **Tags:** feature plan, phase 2, settings, api key, configuration, security

### A41.1. DCE - Phase 2 - Advanced Features & Integrations Plan
- **Description:** Explores future enhancements for the Parallel Co-Pilot, such as applying AI responses as diff patches and integrating with Git for direct commits.
- **Tags:** feature plan, phase 2, ideation, diff, patch, git, workflow

### A41.2. DCE - Phase 2 - Feature Ideation & Competitive Analysis
- **Description:** An analysis of similar AI coding assistant tools (e.g., Cursor.sh, Copilot Chat) and a brainstorm of potential advanced features for the Parallel Co-Pilot panel.
- **Tags:** feature plan, phase 2, research, competitive analysis, ideation, roadmap

### A42. DCE - Phase 2 - Initial Scaffolding Deployment Script
- **Description:** Contains a Node.js script that, when executed, creates the file and directory structure for the Phase 2 Parallel Co-Pilot panel.
- **Tags:** deployment, script, scaffolding, bootstrap, nodejs, automation, phase 2

### A43. DCE - Phase 2 - Implementation Roadmap
- **Description:** Provides a step-by-step implementation plan for building the Phase 2 features, including the Parallel Co-Pilot panel and the integrated Diff Tool.
- **Tags:** feature plan, phase 2, roadmap, project plan, diff tool

### A44. DCE - Phase 1 - Word Document Handling Strategy
- **Description:** Defines the strategy for handling Word document files (.docx) by converting them to text on-demand and caching them in memory for flattening.
- **Tags:** feature plan, docx, text extraction, virtualization, cache, phase 1

### A45. DCE - Phase 2 - Pop-out Co-Pilot Window - Feature Plan
- **Description:** Outlines the technical strategy to allow the Parallel Co-Pilot panel to be "popped out" into a separate window by re-implementing it as a main editor WebviewPanel.
- **Tags:** feature plan, phase 2, pop-out, window, webview, ux

### A46. DCE - Phase 2 - Paste and Parse Response - Feature Plan
- **Description:** Details the plan for allowing users to paste a full AI response into a tab, which the extension will then parse to identify file paths referenced within XML tags.
- **Tags:** feature plan, phase 2, paste, parse, workflow, automation

### A47. DCE - Phase 2 - Prompt Amalgamation Feature Plan
- **Description:** Details the plan for a "Generate prompt.md" button that will assemble the static schemas, cycle history, and flattened code into a single, complete prompt file.
- **Tags:** feature plan, phase 2, prompt engineering, automation, workflow

### A48. DCE - Phase 2 - Advanced Syntax Highlighting Plan
- **Description:** Outlines the strategy to replace the plain textarea in response tabs with a proper code editor component to provide rich syntax highlighting for Markdown and embedded code.
- **Tags:** feature plan, phase 2, ui, ux, syntax highlighting, monaco, codemirror

### A49. DCE - Phase 2 - File Association & Diffing Plan
- **Description:** Plans the UI and backend logic to visually link file blocks in an AI response to workspace files and sets the stage for an integrated diff tool.
- **Tags:** feature plan, phase 2, ui, ux, diff, file association

### A50. DCE - Phase 2 - UI Component Plan (Resizable Panes & Inner Editors)
- **Description:** Documents the plan for advanced UI components like resizable panes and nested, scrollable editors within the Parallel Co-Pilot panel.
- **Tags:** feature plan, phase 2, ui, ux, resizable, scrollable, editor

### A51. DCE - A-B-C Testing Strategy for UI Bugs
- **Description:** Outlines a development pattern for creating parallel, isolated test components to diagnose and resolve persistent UI bugs, such as event handling or rendering issues.
- **Tags:** process, debugging, troubleshooting, ui, ux, react

### A52. DCE - Interaction Schema Refinement
- **Description:** Proposes a set of refined rules for the AI's output format to improve the reliability and consistency of automated parsing within the Parallel Co-Pilot Panel.
- **Tags:** documentation, process, parsing, interaction schema, roadmap

### A53. DCE - Phase 2 - Token Count and Similarity Analysis
- **Description:** Details the plan to implement token counting for raw and parsed responses, and to calculate a similarity score between AI-generated files and their workspace originals.
- **Tags:** feature plan, phase 2, token count, similarity, metrics, ui, ux

### A54. starry-night Readme
- **Description:** A copy of the readme.md file for the `@wooorm/starry-night` syntax highlighting library, providing a reference for available languages and API usage.
- **Tags:** documentation, library, syntax highlighting, starry-night

### A55. DCE - FSService Refactoring Plan
- **Description:** Outlines a strategic plan to refactor the monolithic `FSService` into smaller, more focused services to improve modularity, maintainability, and reduce token count.
- **Tags:** refactor, architecture, technical debt, services

### A56. DCE - Phase 2 - Advanced Diff Viewer Plan
- **Description:** Details the plan to enhance the integrated diff viewer with background coloring for changes and WinMerge-like navigation controls to jump between differences.
- **Tags:** feature plan, phase 2, ui, ux, diff, navigation, side-by-side

### A57. DCE - Phase 2 - Cycle Management Features
- **Description:** Details the plan for adding critical cycle management features to the Parallel Co-Pilot panel, including deleting the current cycle and resetting the entire history.
- **Tags:** feature plan, phase 2, ui, ux, history, cycle management

### A58. DCE - WinMerge Source Code Analysis
- **Description:** Documents the key files and concepts from the WinMerge source code that are relevant to building a high-quality diff viewer.
- **Tags:** research, analysis, diff, winmerge, source code

## II. Standalone Utilities & Guides

### A149. Local LLM Integration Plan
- **Description:** The technical plan for integrating a locally hosted LLM into the game via a secure backend proxy.
- **Tags:** llm, integration, plan, backend, api

### A189. Number Formatting Reference Guide
- **Description:** A standalone guide and utility script for formatting large numbers with K/M/B/T suffixes and dynamic decimal place adjustment for clean UI presentation.
- **Tags:** utility, script, formatting, numbers, ui, ux, javascript, typescript
</file>

<file path="src/Artifacts/A1. DCE - Project Vision and Goals.md">
# Artifact A1: DCE - Project Vision and Goals
# Date Created: Cycle 1
# Author: AI Model
# Updated on: C87 (Shifted Diff Tool to Phase 2, defined Phase 3 as LLM Integration)

## 1. Project Vision

The vision of the Data Curation Environment (DCE) is to create a seamless, integrated toolset within VS Code that streamlines the workflow of interacting with large language models. The core problem this project solves is the manual, cumbersome process of selecting, packaging, and managing the context (code files, documents, etc.) required for effective AI-assisted development.

## 2. High-Level Goals & Phases

The project will be developed in three distinct phases.

**Note on Reference Repository:** The discovery of the `The-Creator-AI-main` repository in Cycle 2 has provided a significant head-start, especially for Phase 1 and 2. The project's focus shifts from building these components from the ground up to adapting and extending the powerful, existing foundation.

### Phase 1: The Context Chooser

The goal of this phase is to eliminate the manual management of a `files_list.txt`. Users should be able to intuitively select files and folders for their AI context directly within the VS Code file explorer UI.

-   **Core Functionality:** Implement a file explorer view with checkboxes for every file and folder.
-   **Action:** A "Flatten Context" button will take all checked items and generate a single `flattened_repo.md` file in the project root.
-   **Outcome:** A user can curate a complex context with simple mouse clicks, completely removing the need to edit a text file.
-   **Status:** Largely complete.

### Phase 2: The Parallel Co-Pilot Panel & Integrated Diff Tool

This phase addresses the limitation of being locked into a single conversation with an AI assistant and brings the critical "diffing" workflow directly into the extension. The goal is to enable multiple, parallel interactions and to create a navigable record of the AI-driven development process.

-   **Core Functionality (Parallel Co-Pilot):** Create a custom panel within VS Code that hosts a multi-tabbed text editor. Users can manually paste or have the extension ingest different AI-generated code responses into each tab for side-by-side comparison.
-   **Key Feature ("Swap & Test"):** A button on each tab allows the user to "swap" the content of that tab with the corresponding source file in their workspace. This provides an immediate, low-friction way to test a given AI response.
-   **Core Functionality (Integrated Diff):** The panel will include a built-in diff viewer to compare the content of any two tabs, or a tab and the source file. This eliminates the need for external tools like WinMerge.
-   **Core Functionality (Cycle Navigator):** Integrate a UI element to navigate back and forth between development cycles. Each cycle will be associated with the set of AI responses generated during that cycle.
-   **Outcome:** A user can efficiently manage, compare, and test multiple AI solutions, and also review the historical evolution of the code by navigating through past cycles and their corresponding AI suggestions, creating a powerful "knowledge graph" of the project's development.

### Phase 3: Advanced AI & Local LLM Integration

This phase focuses on deeper integration with AI services and providing support for local models.

-   **Core Functionality:** Implement direct API calls to various LLM providers (e.g., Gemini, OpenAI, Anthropic) from within the Parallel Co-Pilot panel, populating the tabs automatically. This requires building a secure API key management system.
-   **Local LLM Support:** Allow users to configure an endpoint URL for a locally hosted LLM (e.g., via LM Studio, Ollama), enabling fully offline and private AI-assisted development.
-   **Outcome:** The DCE becomes a fully-featured AI interaction environment, supporting both cloud and local models, and automating the entire prompt-to-test workflow.
</file>

<file path="src/Artifacts/A10. DCE - Metadata and Statistics Display.md">
# Artifact A10: DCE - Metadata and Statistics Display
# Date Created: Cycle 14
# Author: AI Model
# Updated on: C40 (Clarify file counter label and tooltip)

- **Key/Value for A0:**
- **Description:** Outlines the requirements and design for displaying live metadata (total selected files, total tokens) and for showing aggregate statistics (token and file counts) for folders in the file tree.
- **Tags:** feature plan, metadata, statistics, token count, ui, ux

## 1. Overview & Goal

To enhance the data curation process, it is critical for the user to have immediate, quantitative feedback on their selections. This feature will provide at-a-glance statistics at both the folder level and the overall selection level. The goal is to empower the user to make informed decisions about context size and composition without needing to perform manual calculations.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| US-01 | **Folder Statistics** | As a data curator, I want to see the total token count and the total number of files contained within each folder, so I can quickly assess the size and complexity of different parts of my project. | - Next to each folder name in the file tree, a token count is displayed. <br> - This token count is the recursive sum of all tokens from all non-image files within that folder and its subfolders. <br> - Next to the token count, a file count is also displayed, formatted with commas (e.g., "1,234"). <br> - These numbers are calculated on the backend and provided with the initial file tree data. |
| US-02 | **Live Selection Summary** | As a data curator, I want to see a live summary of my total selection as I check and uncheck files, so I can monitor the total size of my context in real-time. | - A dedicated summary panel/footer is visible in the UI. <br> - This panel displays "X files" and "Y tokens". <br> - **(C40 Update)** The label for the file count is "Selected Files". The tooltip reads: "Total number of individual files selected for flattening. This does not include empty directories." <br> - "X" is the total count of all individual files included in the current selection, formatted with commas. <br> - "Y" is the sum of all token counts for those selected non-image files. <br> - These values update instantly whenever a checkbox is changed. |
| US-03 | **Readable Numbers & Icons** | As a data curator, I want large token counts to be formatted in a compact and readable way (e.g., 1,234 becomes "1.2K"), and for icons to visually represent the data, so I can easily parse the information. | - All token counts use K/M/B suffixes for numbers over 1,000. <br> - All file counts use commas for thousands separators. <br> - An icon is displayed next to the token count and file count for visual distinction. <br> - The statistics are right-justified in the file tree for better readability. |
| US-04 | **Image File Handling** | As a data curator, I want to see the file size for images instead of a token count, so I can understand their contribution to storage/transfer size rather than context length. | - The backend identifies common image file types (png, jpg, etc.). <br> - For image files, the token count is treated as 0. <br> - In the file tree, instead of a token count, the human-readable file size is displayed (e.g., "15.2 KB", "2.1 MB"). |
| US-05 | **Selected Token Count in Folders** | As a data curator, I want to see how many tokens are selected within a folder, so I can understand the composition of my selection without expanding the entire directory. | - Next to a folder's total token count, a secondary count in parentheses `(x)` appears. <br> - `x` is the recursive sum of tokens from all selected files within that folder. <br> - The display format is `TotalTokens (SelectedTokens)`, e.g., `347K (13K)`. <br> - This count only appears if selected tokens are > 0 and less than the total tokens. |
| US-06 | **Visual Cue for Selected Tokens** | As a curator, I want a clear visual indicator on the token count itself when an item is included in the selection, so I can confirm its inclusion without looking at the checkbox. | - When an individual file is checked, its token count is wrapped in parentheses, e.g., `(168)`. <br> - When a folder is checked, and *all* of its children are included in the selection, its total token count is wrapped in parentheses, e.g., `(336)`. <br> - This complements the `Total (Selected)` format for partially selected folders. |

## 3. Technical Implementation Plan

1.  **Backend (`fs.service.ts`):**
    *   The `FileNode` interface in `src/common/types/file-node.ts` will be updated to include `isImage: boolean` and `sizeInBytes: number`.
    *   The backend service will maintain a list of image file extensions.
    *   When building the tree, it will check each file's extension.
    *   If it's an image, it will use `fs.stat` to get the `sizeInBytes`, set `isImage: true`, and set `tokenCount: 0`.
    *   If it's not an image, it will calculate the `tokenCount` and get the `sizeInBytes`.
    *   The recursive sum logic for folders will aggregate `tokenCount`, `fileCount`, and `sizeInBytes` from their children.
    *   The `vscode.workspace.findFiles` call will be updated to exclude the `node_modules` directory.

2.  **Frontend - Formatting (`formatting.ts`):**
    *   A new `formatBytes(bytes)` utility will be created to convert bytes to KB, MB, etc.
    *   A new `formatNumberWithCommas(number)` utility will be created.

3.  **Frontend - File Tree (`FileTree.tsx` & `view.scss`):**
    *   The `FileTree.tsx` component will be updated to render the new data.
    *   It will conditionally display either a formatted token count (using `formatLargeNumber`) or a formatted file size (using `formatBytes`) based on the `isImage` flag.
    *   It will display folder file counts using `formatNumberWithCommas`.
    *   **Selected Token Calculation:** A new memoized, recursive function will be created within `FileTree.tsx` to calculate the selected token count for a given directory node by checking its descendants against the `selectedFiles` prop.
    *   The rendering logic will be updated to display the `(SelectedTokens)` value conditionally.
    *   **Parenthesis Logic (US-06):** The rendering logic will be further updated. For files, it will check if the file's path is in the `selectedFiles` list. For folders, it will compare the calculated `selectedTokensInDir` with the `node.tokenCount`. Based on these checks, it will conditionally wrap the output string in parentheses.
    *   It will incorporate icons from `react-icons/vsc` for tokens and file counts.
    *   The stylesheet (`view.scss`) will be updated to right-align all statistics, pushing them to the end of the file/folder row.

4.  **Frontend - Live Summary Panel (`context-chooser.view.tsx`):**
    *   The `useMemo` hook that calculates the summary will be updated to correctly sum the total number of files and total tokens from the selected items. It will continue to ignore image sizes for the token total to avoid mixing units.
    *   The rendered output will use the new formatting utilities and icons.
    *   **(C40)** The label and title attribute will be updated for clarity.
</file>

<file path="src/Artifacts/A11. DCE - Regression Case Studies.md">
# Artifact A11: DCE - Regression Case Studies
# Date Created: C16
# Author: AI Model & Curator
# Updated on: C130 (Add case for RegExp type inference errors)

- **Key/Value for A0:**
- **Description:** Documents recurring bugs, their root causes, and codified solutions to prevent future regressions during development.
- **Tags:** bugs, regression, troubleshooting, development, best practices

## 1. Purpose

This document serves as a living record of persistent or complex bugs that have recurred across multiple development cycles. By documenting the root cause analysis (RCA) and the confirmed solution for each issue, we create a "source of truth" that can be referenced to prevent the same mistakes from being reintroduced into the codebase.

## 2. Case Studies

---

### Case Study 009: TypeScript Type Inference with RegExp Results

-   **Artifacts Affected:** `src/client/utils/response-parser.ts`
-   **Cycles Observed:** 130
-   **Symptom:** TypeScript build fails with errors like `TS2339: Property 'trim' does not exist on type 'RegExpMatchArray'`. This occurs when trying to access a capture group from the result of `String.prototype.match()` or `RegExp.prototype.exec()`.
-   **Root Cause Analysis (RCA):** The TypeScript compiler, in some complex scenarios, can have difficulty inferring the precise type of a capture group within a `RegExpMatchArray` or `RegExpExecArray`. While the developer knows that `match[1]` should be a `string`, the compiler may infer a wider, incorrect type for the array element itself, leading to the erroneous belief that methods like `.trim()` or `.split()` do not exist.
-   **Codified Solution & Best Practice:**
    1.  **Use `matchAll` for Multiple Matches:** For global regular expressions, `String.prototype.matchAll()` is superior to a `while(regex.exec())` loop. It returns an iterator of `RegExpMatchArray` objects, and its type definitions are generally more robust and modern, making it easier for TypeScript to infer the correct types for capture groups.
    2.  **Use Optional Chaining and Nullish Coalescing:** For single matches (`String.prototype.match()`), the safest way to access a capture group is with optional chaining (`?.[]`) and the nullish coalescing operator (`??`). This pattern is both safe and clear to the TypeScript compiler.
-   **Example of Flawed Logic (Conceptual):**
    ```typescript
    const match = myString.match(/.../);
    const value = match ? match.trim() : ''; // This can fail if TS inference is poor
    ```
-   **Example of Correct Logic (Conceptual):**
    ```typescript
    const match = myString.match(/.../);
    const value = (match?. ?? '').trim(); // This is type-safe and robust
    ```

---

### Case Study 008: PCPP Parse/Un-Parse State Instability

-   **Artifacts Affected:** `src/client/views/parallel-copilot.view/view.tsx`
-   **Cycles Observed:** 124, 126
-   **Symptom:** The "Parse All" button exhibits unstable behavior.
    1.  Clicking it toggles the UI to the "Un-Parse All" state but immediately reverts to "Parse All". A second click is required for the state to stick.
    2.  When the UI is in the "Un-Parse All" state, selecting a file from the "Associated Files" list incorrectly toggles the mode back to "Parse All", making it impossible to view files.
-   **Root Cause Analysis (RCA):** The bug is caused by a dependency cycle in the React component's state management. The `parseAllTabs` function, which was wrapped in a `useCallback`, had a dependency on the `tabs` state. Inside the function, it called `setTabs`. This created a loop where the `useEffect` hook responsible for parsing would run, call `parseAllTabs`, which would update the `tabs` state, which would create a new `parseAllTabs` function on re-render, which would re-trigger the `useEffect`. This loop caused rapid, unpredictable state changes, leading to the observed UI flickering and instability.
-   **Codified Solution & Best Practice:**
    1.  **Break Dependency Cycle:** The `useCallback` hook for the `parseAllTabs` function was refactored. It now uses the functional update form of its `setTabs` call (e.g., `setTabs(prevTabs => ...)`).
    2.  This removes the need for the `tabs` state to be in the `useCallback` dependency array. The function is now stable across re-renders.
    3.  **Refine `useEffect`:** The `useEffect` that triggers the parsing logic can now safely depend on `parseAllTabs` without causing a loop. Its dependency array should be limited to `isParsedMode` and the raw content of the tabs, preventing it from running on unrelated UI state changes like file selection.
    4.  **Best Practice:** When a memoized callback (`useCallback`) needs to update a state that it also depends on, always use the functional update form to break the dependency cycle.

---

### Case Study 007: Corrupted or Unsupported Document Files
-   **Artifacts Affected:** `src/backend/services/content-extraction.service.ts`, `A44. DCE - Phase 1 - Word Document Handling Strategy.md`
-   **Cycles Observed:** 81
-   **Symptom:** Some `.docx` files fail to process with a `Can't find end of central directory` error in the logs, while legacy `.doc` files show an "Unsupported format" message in the UI.
-   **Root Cause Analysis (RCA):** This is not a bug, but rather the system correctly handling invalid inputs.
    1.  **Corrupted `.docx`:** The `.docx` format is a standard zip archive. The parsing library (`mammoth`, which uses `jszip`) throws the "central directory" error when a file is not a valid zip archive. This indicates the source file itself is corrupted or was saved incorrectly.
    2.  **Legacy `.doc`:** The `mammoth` library does not support the old binary `.doc` format. Our documented strategy in `A44` is to explicitly reject these files.
-   **Codified Solution & Best Practice:**
    1.  The error handling in `content-extraction.service.ts` is working as intended.
    2.  The `catch` block in `handleWordToTextRequest` should be enhanced to check for the specific "central directory" error message.
    3.  When this specific error is caught, a more user-friendly message like "File appears to be corrupted or is not a valid .docx format" should be sent to the frontend.
    4.  The system should continue to correctly identify `.doc` files and send the "Legacy .doc format not supported" message. This confirms the system is robust against invalid user inputs.

---

### Case Study 006: Special File Type Caching Fails on Initialization
-   **Artifacts Affected:** `src/client/views/context-chooser.view/view.tsx`
-   **Cycles Observed:** 65, 66, 75, 76, 78, 79, 80, 81
-   **Symptom:** When the extension loads and restores the previous selection, special file types (`.pdf`, `.xlsx`, `.docx`) have a token count of 0. When "Flatten Context" is clicked, the output shows `<!-- content not processed or cached -->`. The caching only works if the user manually un-checks and re-checks the file.
-   **Root Cause Analysis (RCA):** The frontend logic for "pre-warming" the cache was flawed. It was attempting to find the file nodes for the restored selection paths *before* the main file tree had been loaded from the backend. This race condition meant it found no files to process, so the cache was never populated on startup.
-   **Codified Solution & Best Practice:**
    1.  **Decouple and Defer Pre-warming:** The logic must be architected to handle asynchronous data arrival gracefully.
    2.  **Use a Trigger State:** In `view.tsx`, the `ApplySelectionSet` message handler should do nothing more than set two state variables: one for the `checkedFiles` (for the UI) and a separate "trigger" state (e.g., `selectionToPrewarm: string[]`).
    3.  **Use a Multi-Dependency `useEffect`:** A dedicated `useEffect` hook must be created to perform the pre-warming logic. Its dependency array **must** include both the trigger state and the file tree state (e.g., `[selectionToPrewarm, files]`).
    4.  This ensures the pre-warming code only executes when both the selection and the file tree data are guaranteed to be present, eliminating the race condition. After executing, the trigger state should be reset to `null` to prevent re-runs.

---

### Case Study 005: Spacebar De-selects Wrong Parent Folder
-   **Artifacts Affected:** `src/client/components/file-tree/FileTree.utils.ts`
-   **Cycles Observed:** 61, 68
-   **Symptom:** When a parent folder (e.g., `src`) is checked, focusing on a deeply nested descendant file (e.g., `src/components/menus/file.ts`) and pressing the spacebar causes a mid-level parent folder (e.g., `src/components`) to be de-selected instead of just the single focused file.
-   **Root Cause Analysis (RCA):** The logic for a "subtractive uncheck" in `addRemovePathInSelectedFiles` was flawed. It correctly identified the selected ancestor (e.g., `src`) but then attempted to re-add only its *direct children*, failing to handle nested structures. It would incorrectly identify which direct child to exclude based on the deep file path, leading to the removal of an entire subdirectory from the selection.
-   **Codified Solution & Best Practice:**
    1.  The `addRemovePathInSelectedFiles` function was refactored for the "subtractive uncheck" case.
    2.  The new logic is more explicit and reliable:
        *   Remove the high-level ancestor path (e.g., `src`) from the selection set.
        *   Get a list of **all descendant files** of that ancestor.
        *   Add all of these descendant files to the selection set, **except for the specific file that was the target of the uncheck action**.
    3.  This correctly translates the selection from a single high-level path (`src`) into many individual low-level file paths, minus the one the user explicitly removed, preserving their intent perfectly.

---

### Case Study 004: Spacebar De-selects Parent Folder Instead of File

-   **Artifacts Affected:** `src/client/components/file-tree/FileTree.utils.ts`
-   **Cycles Observed:** 61
-   **Symptom:** When a parent folder (e.g., `src`) is checked, focusing on a descendant file (e.g., `src/components/file.ts`) and pressing the spacebar causes the entire sub-folder (`src/components`) to be removed from the selection, rather than just the single file.
-   **Root Cause Analysis (RCA):** The logic for a "subtractive uncheck" was flawed. When attempting to uncheck a child of an already-selected parent, the utility function would correctly remove the parent from the selection set but would then re-add the parent's *direct children* except for the one containing the target file. This was too aggressive and did not correctly represent the user's intent to remove only a single file.
-   **Codified Solution & Best Practice:**
    1.  The `addRemovePathInSelectedFiles` function was refactored for the "subtractive uncheck" case.
    2.  The new logic is more explicit:
        *   Remove the ancestor path (e.g., `src`) from the selection.
        *   Get a list of **all descendant files** of that ancestor.
        *   Add all descendant files to the selection, **except for the specific file that was unchecked**.
    3.  This correctly translates the selection from a single high-level path (`src`) into many individual low-level paths, minus the one the user removed, preserving their intent.

---

### Case Study 003: Incorrect File Count in Flatten Success Message

-   **Artifacts Affected:** `src/backend/services/flattener.service.ts`
-   **Cycles Observed:** 61
-   **Symptom:** The success message after flattening (e.g., "Successfully flattened X files...") shows an incorrect count of files, often higher than what was actually selected and written.
-   **Root Cause Analysis (RCA):** The `flattener.service` was using the count of all unique file paths it was *initially given* for the success message. This list could include paths that were later filtered out (e.g., binary files before metadata handling was implemented) or files that failed to be read. The message did not reflect the final count of files successfully processed and written to the output file.
-   **Codified Solution & Best Practice:**
    1.  The `generateOutputContent` function is responsible for creating the final string to be written to disk. It already has access to the array of successfully processed file results.
    2.  The `vscode.window.showInformationMessage` call inside the `flatten` method was modified to use the `length` of this final, validated list of results (`validResults.length`) instead of the initial input list. This ensures the user is always shown the exact number of files included in the output.

---

### Case Study 002: Checkbox State Management in File Tree

-   **Artifacts Affected:** `src/client/components/file-tree/FileTree.utils.ts`, `src/client/components/file-tree/FileTree.tsx`
-   **Cycles Observed:** 14, 15, 16
-   **Symptom:** Checkbox functionality in the file tree is erratic. Only the root checkbox works as expected, but individual files or sub-folders cannot be checked or unchecked correctly. Clicking a checkbox on a child of an already-selected folder fails to deselect it.
-   **Root Cause Analysis (RCA):**
    The core issue was overly complex and flawed state management logic within the `addRemovePathInSelectedFiles` utility function. The logic attempted to handle the "unchecking a child of a selected parent" case by removing the parent and re-adding all of its other children (the "siblings"). This approach was brittle and failed to correctly calculate the new state, leading to a UI that did not update correctly. The complexity made the function difficult to debug and maintain.

-   **Codified Solution & Best Practice:**
    1.  **Simplify State Logic:** The state management logic was rewritten to be more direct and declarative, using a `Set` for efficient manipulation of selected paths.
    2.  **Handle Cases Explicitly:** The new function explicitly handles the three primary user actions:
        *   **CHECK:** When a node is checked, any of its descendants that are already in the selection are removed, and the node's own path is added. This ensures the most senior selected path is always the one stored in state.
        *   **UNCHECK (Direct):** When a node that is explicitly in the selection list is unchecked, its path and the paths of all its descendants are removed.
        *   **UNCHECK (Subtractive):** When a node is unchecked because its parent was checked, the parent is removed from the selection. Then, all of the parent's direct children *except for the one that was clicked* are added to the selection. This correctly "subtracts" the item from the parent's group selection without complex traversals.
    3.  **Robust Event Handling:** Ensure the checkbox `onChange` handler in the React component uses `event.stopPropagation()` to prevent the click event from bubbling up and triggering other actions, such as folder expansion.

-   **Example of Flawed Logic (Conceptual):**
    ```typescript
    // OLD LOGIC
    if (unchecking a child of a selected parent) {
      // 1. Remove parent from selected list.
      // 2. Traverse the entire tree from the parent.
      // 3. Add every descendant of the parent back, EXCEPT the clicked child.
      // This was inefficient and error-prone.
    }
    ```

-   **Example of Correct Logic (Conceptual):**
    ```typescript
    // NEW LOGIC
    if (unchecking a child of a selected parent) {
      // 1. Remove the parent from the selection set.
      const parentNode = findParentNode(clickedPath);
      // 2. Add all of the parent's *direct children* to the selection set,
      //    except for the clicked child itself.
      parentNode.children.forEach(child => {
        if (child.path !== clickedPath) {
          selectionSet.add(child.path);
        }
      });
    }
    ```

---

### Case Study 001: `path.sep` Usage in Frontend Components

-   **Artifacts Affected:** `src/client/components/file-tree/FileTree.tsx`
-   **Cycles Observed:** 13, 14, 16
-   **Symptom:** The webpack build process fails with TypeScript errors similar to `TS2339: Property 'sep' does not exist on type 'string'`.
-   **Root Cause Analysis (RCA):**
    The error occurs when frontend code (React components running in a webview) attempts to use `path.sep`. The `path` module is a core part of the Node.js runtime, but it does not exist in the browser-like context of a webview.
-   **Codified Solution & Best Practice:**
    1.  **Strict Environment Separation:** All file system path manipulation **must** occur in the backend (`src/backend/`).
    2.  **Normalized Paths:** The backend must normalize all paths to use forward slashes (`/`) before sending them to the frontend.
    3.  **Frontend Simplicity:** The frontend code must treat all file paths as simple strings and should never attempt to parse or join them using path-specific separators.
</file>

<file path="src/Artifacts/A12. DCE - Logging and Debugging Guide.md">
# Artifact A12: DCE - Logging and Debugging Guide
# Date Created: Cycle 19
# Author: AI Model & Curator
# Updated on: C126 (Add section on truncated logging)

- **Key/Value for A0:**
- **Description:** Explains how to access and use the integrated logging solution for debugging the extension's backend and frontend components.
- **Tags:** logging, debugging, troubleshooting, development, output channel

## 1. Purpose

This document provides instructions on how to access and use the logging features built into the Data Curation Environment (DCE) extension. Effective logging is crucial for diagnosing performance issues, tracking down bugs, and understanding the extension's behavior during development.

## 2. Two Primary Log Locations

There are two separate places to look for logs, depending on where the code is running.

### Location 1: The "Debug Console" (For `console.log`)

This is where you find logs from the **backend** (the extension's main Node.js process).

-   **What you'll see here:** `console.log()` statements from files in `src/backend/` and `src/extension.ts`. This is useful for debugging the extension's core activation and services *before* the UI is even visible.
-   **Where to find it:** In your **main development window** (the one where you press `F5`), look in the bottom panel for the **"DEBUG CONSOLE"** tab.

    ```
    -----------------------------------------------------------------------------------
    | PROBLEMS    OUTPUT    DEBUG CONSOLE    TERMINAL                                 |
    |---------------------------------------------------------------------------------|
    |                                                                                 |
    |  > Congratulations, your extension "Data Curation Environment" is now active!   |
    |  > FSService watcher initialized.                                               |
    |  ...                                                                            |
    -----------------------------------------------------------------------------------
    ```

### Location 2: The "Output" Channel (For Centralized Logging)

This is the primary, centralized log for the entire extension, including messages from the **frontend (WebView)**.

-   **What you'll see here:** Formatted log messages from both the backend (`LoggerService`) and the frontend (`logger.ts`). All messages are prefixed with a level (`[INFO]`, `[WARN]`, `[ERROR]`) and a timestamp. Frontend messages are also prefixed with `[WebView]`.
-   **Where to find it:** In the **"[Extension Development Host]" window** (the new window that opens after you press `F5`), follow these steps:
    1.  **Open the Panel:** Press `Ctrl+J` (or `Cmd+J` on Mac).
    2.  **Navigate to the "OUTPUT" Tab.**
    3.  In the dropdown menu on the right, select **`Data Curation Environment`**.

    ```
    -----------------------------------------------------------------------------------
    | PROBLEMS    OUTPUT    DEBUG CONSOLE    TERMINAL                                 |
    |---------------------------------------------------------------------------------|
    |                                                 [Data Curation Environment v]   |
    |                                                                                 |
    |  [INFO] [2:30:00 PM] Services initialized.                                      |
    |  [INFO] [2:30:01 PM] Received request for workspace files.                      |
    |  [INFO] [2:30:01 PM] [WebView] Initializing view and requesting workspace files.|
    |  [INFO] [2:30:01 PM] Scanning for files with exclusion pattern: ...             |
    |  ...                                                                            |
    -----------------------------------------------------------------------------------
    ```

## 3. Tactical Debugging with Logs (C93)

When a feature is not working as expected, especially one that involves communication between the frontend and backend, the most effective debugging technique is to add **tactical logs** at every step of the data's journey.

### Case Study: Fixing the "Associated Files" Parser (Cycle 93)

-   **Problem:** The UI was incorrectly reporting that files from a parsed AI response did not exist in the workspace.
-   **Data Flow:**
    1.  **Frontend (`view.tsx`):** User clicks "Parse All".
    2.  **Frontend (`response-parser.ts`):** Raw text is parsed into a list of relative file paths (e.g., `src/main.ts`).
    3.  **IPC (`RequestFileExistence`):** The list of relative paths is sent to the backend.
    4.  **Backend (`fs.service.ts`):** The backend receives the list and compares it against its own list of known workspace files, which are stored as absolute paths (e.g., `c:/project/src/main.ts`). The comparison fails.

## 4. Truncated Logging for Large Content (C126)

To prevent the output channel from becoming overwhelmed with large blocks of text (e.g., entire file contents), a logging utility has been implemented to truncate long strings.

-   **Behavior:** When a service logs a large piece of content (like a code block for syntax highlighting), it will use the `truncateStringForLogging` utility.
-   **Format:** If a string is longer than a set threshold (e.g., 100 characters), it will be displayed in the logs in a format like this:
    `[First 50 characters]...[Last 50 characters]`
-   **Benefit:** This keeps the logs clean and readable, allowing you to see that a large piece of data was processed without having its entire content flood the output. You can still see the beginning and end of the content to verify its identity.
</file>

<file path="src/Artifacts/A13. DCE - Phase 1 - Right-Click Context Menu.md">
# Artifact A13: DCE - Phase 1 - Right-Click Context Menu
# Date Created: Cycle 19
# Author: AI Model
# Updated on: C37 (Add context menu for "Selected Items" panel)

- **Key/Value for A0:**
- **Description:** A plan for implementing standard file explorer context menu actions (e.g., Rename, Delete, Copy Path) in the custom file tree.
- **Tags:** feature plan, context menu, right-click, file operations, ux, phase 1

## 1. Overview & Goal

To enhance the user experience and make the Data Curation Environment a more complete replacement for the native VS Code explorer, this feature adds standard right-click context menus. The goal is to provide essential file and list management operations directly within our extension's view, reducing the need for users to switch contexts for common tasks.

This plan covers two distinct context menus: one for the main file tree and one for the "Selected Items" list.

## 2. Main File Tree Context Menu

| ID | User Story | Acceptance Criteria |
|---|---|---|
| US-01 | **Copy Path** | As a user, I want to right-click a file or folder and copy its absolute or relative path to my clipboard, so I can easily reference it elsewhere. | - Right-clicking a node in the file tree opens a context menu. <br> - The menu contains "Copy Path" and "Copy Relative Path" options. <br> - Selecting an option copies the corresponding path string to the system clipboard. |
| US-02 | **Rename File/Folder** | As a user, I want to right-click a file or folder and rename it, so I can correct mistakes or refactor my project structure. | - The context menu contains a "Rename" option. <br> - Selecting it turns the file/folder name into an editable input field. <br> - Pressing Enter or clicking away saves the new name. <br> - The underlying file/folder is renamed on the file system. <br> - The file tree updates to reflect the change. |
| US-03 | **Delete File/Folder** | As a user, I want to right-click a file or folder and delete it, so I can remove unnecessary files from my project. | - The context menu contains a "Delete" option. <br> - Selecting it shows a confirmation dialog to prevent accidental deletion. <br> - Upon confirmation, the file or folder (and its contents, recursively) is moved to the trash/recycling bin. <br> - The file tree updates to reflect the change. |
| US-04 | **Reveal in OS Explorer** | As a user, I want to right-click a file or folder and have it revealed in the native OS file explorer, so I can interact with it outside of VS Code. | - The context menu contains a "Reveal in File Explorer" (or "Reveal in Finder" on macOS) option. <br> - Selecting it opens the parent directory of the item in the **operating system's default file manager** (e.g., Windows File Explorer) with the item selected. This should not simply switch to the VS Code Explorer tab. |
| US-05 | **New File/Folder** | As a user, I want to create new files and folders from the toolbar or context menu in the correct location, so I can build out my project structure without leaving the view. | - The header toolbar has "New File" and "New Folder" buttons. <br> - Clicking either prompts for a name. <br> - The new file/folder is created in the directory of the currently *active/highlighted* item in the tree. <br> - If the active item is a file, the new item is created in that file's parent directory. <br> - If no item is active, it defaults to the workspace root. <br> - The file tree automatically refreshes. |

## 3. "Selected Items" Panel Context Menu

| ID | User Story | Acceptance Criteria |
|---|---|---|
| US-06 | **Select All/Deselect All** | As a user, I want to right-click in the "Selected Items" panel to quickly select or deselect all items in the list, so I can perform batch removal operations more efficiently. | - Right-clicking anywhere within the list of selected files opens a context menu. <br> - The menu contains a "Select All" option. <br> - Clicking "Select All" highlights every item in the list, updating the "Remove selected" button count. <br> - The menu also contains a "Deselect All" option. <br> - Clicking "Deselect All" clears all selections in the list. |

## 4. Technical Implementation Plan

-   **Main Tree Menu:** Implemented in `TreeView.tsx` and `ContextMenu.tsx` using an `onContextMenu` event handler and state management to control visibility and position.
-   **"Selected Items" Menu (C37):**
    1.  **State Management (`SelectedFilesView.tsx`):** Add state to manage the menu's visibility and coordinates: `const [contextMenu, setContextMenu] = useState<{ x: number, y: number } | null>(null);`.
    2.  **Event Handling (`SelectedFilesView.tsx`):** Add an `onContextMenu` handler to the main `ul` element. This will prevent the default menu and set the state to render the custom menu.
    3.  **Component Rendering (`SelectedFilesView.tsx`):** Conditionally render a new context menu component based on the state. The component will have two list items: "Select All" and "Deselect All".
    4.  **Actions (`SelectedFilesView.tsx`):**
        *   The "Select All" `onClick` handler will create a `Set` from all paths in the `sortedFiles` prop and call `setSelection` with it.
        *   The "Deselect All" `onClick` handler will call `setSelection(new Set())`.
        *   Both actions will close the menu by setting `setContextMenu(null)`.
    5.  **Styling (`view.scss`):** Add CSS rules for the new context menu to match the existing one.
</file>

<file path="src/Artifacts/A14. DCE - Ongoing Development Issues.md">
# Artifact A14: DCE - Ongoing Development Issues
# Date Created: C20
# Author: AI Model & Curator
# Updated on: C23 (Add issues for selection persistence and remove button)

- **Key/Value for A0:**
- **Description:** A tracking document for recurring or persistent issues that need to be monitored across development cycles until they are confirmed as resolved.
- **Tags:** bugs, tracking, issues, logging, node_modules, performance

## 1. Purpose

This artifact serves as a centralized list to track ongoing and recurring issues during the development of the Data Curation Environment (DCE) extension. This ensures that persistent problems are not forgotten and are actively monitored across cycles until a definitive solution is implemented and verified.

## 2. Active Issues

---

### Issue #5: Selection State is Not Persistent

-   **Symptom:** When the user makes selections in the "Data Curation" view, then switches to another VS Code tab and back, all selections are lost.
-   **First Reported:** Cycle 23
-   **Status (C23):** **Active.** The frontend state for `selectedFiles` is not being persisted in the VS Code `workspaceState`.
-   **Next Steps (C23):** Implement a mechanism to save the `selectedFiles` array to `workspaceState` on every change and load it when the view is initialized. This will involve both frontend (`view.tsx`) and backend (`selection.service.ts`) changes.

---

### Issue #6: "Remove selected" Button is Non-Functional

-   **Symptom:** In the "Selected Items" view, selecting one or more files and clicking the "Remove selected" button does not remove them from the list or from the main selection. It also causes the file tree in the main view to collapse.
-   **First Reported:** Cycle 23
-   **Status (C23):** **Active.** The logic in `removePathsFromSelected` or the way its result is being used to update the state is flawed. The tree collapsing indicates an improper state update is causing a major re-render.
-   **Next Steps (C23):** Debug the `removePathsFromSelected` function in `FileTree.utils.ts`. Add logging to the `onClick` handler in `SelectedFilesView.tsx` to trace the data flow. Fix the state update to prevent the side-effect of collapsing the tree.

---

### Issue #1: Logging Visibility

-   **Symptom:** The custom "Data Curation Environment" output channel is not visible in the "OUTPUT" tab's dropdown menu in the Extension Development Host window. This prevents the primary logging mechanism from being used for debugging.
-   **First Reported:** Cycle 19
-   **Status (C23):** **Resolved (C21).** The issue was caused by an early-exit error during extension activation. Adding robust `try...catch` blocks around service initializations in `extension.ts` allowed the extension to fully load, making the output channel visible.

---

### Issue #2: `node_modules` Exclusion and Performance

-   **Symptom:** The `node_modules` directory is included in file tree scans, leading to incorrect file and token counts and a significant performance delay.
-   **First Reported:** Cycle 15 (and earlier)
-   **Status (C23):** **Resolved (C20).** The `vscode.workspace.findFiles` call in `fs.service.ts` was updated with a more robust glob pattern `'{**/node_modules/**,**/dist/**,**/out/**,**/.git/**,**/flattened_repo.md}'` which now correctly excludes these directories.

---

### Issue #3: Incorrect Image Token Counting

-   **Symptom:** Image files are being assigned a token count instead of displaying their file size.
-   **First Reported:** Cycle 18
-   **Status (C23):** **Resolved (C20).** The logic in `fs.service.ts` was corrected to identify images by extension, set `tokenCount` to 0, and get their `sizeInBytes`. The frontend (`FileTree.tsx`) now uses an `isImage` flag to display the formatted byte size instead of tokens.

---

### Issue #4: File Tree Caching and Refresh Behavior

-   **Symptom:** The file tree reloaded from scratch on every tab switch and did not auto-update on file changes.
-   **First Reported:** Cycle 19
-   **Status (C23):** **Resolved (C20).** A frontend cache was implemented by changing the `useEffect` dependency array. A backend `FileSystemWatcher` was implemented in `fs.service.ts` to detect changes and push updates to the client, triggering a refresh.
</file>

<file path="src/Artifacts/A149. Local LLM Integration Plan.md">
# Artifact: A149. Local LLM Integration Plan
# Updated on: C1280 (Add documentation for REMOTE_LLM_URL environment variable.)
# Updated on: C1217 (Update architecture to reflect that @Ascentia now uses a streaming Socket.IO event.)
# Updated on: C1216 (Reflect change from /chat/completions to /completions endpoint for chatbot streaming.)
# Date Created: Cycle 1211
# Author: AI Model

## 1. Overview & Goal

This document outlines the technical plan for integrating a locally hosted Large Language Model (LLM) into the "AI Ascent" game. The goal is to create a secure and robust connection between the game client/server and a local LLM endpoint (like one provided by LM Studio) to power new, dynamic gameplay features.

This integration will enable:
1.  An in-game helper bot, `@Ascentia`, that can answer player questions about the game.
2.  Interactive sessions where players can "talk" to their own AI products.
3.  A new "Poetry Battle" PvP competition between players' chatbot products.

## 2. Core Architecture: Backend Proxy

To ensure security and control, the game client will **never** directly call the local LLM endpoint. All communication will be routed through a dedicated backend API endpoint or WebSocket handler that acts as a proxy.

### 2.1. Rationale for a Backend Proxy
*   **Security:** Prevents malicious clients from directly accessing or overloading the local LLM server. It keeps the endpoint address and any potential API keys hidden from the client.
*   **Control:** Allows the server to inject, modify, or augment prompts before they are sent to the LLM. This is critical for:
    *   Adding system prompts and context for the `@Ascentia` helper bot.
    *   Injecting parameters to simulate quality degradation for the Poetry Battle.
    *   Enforcing rate limiting and preventing abuse.
*   **Flexibility:** The client-facing API remains consistent even if the underlying LLM provider or endpoint changes in the future.
*   **State Management:** The server can access the game's database (`prisma`) to fetch context for prompts (e.g., player stats, game rules from documentation artifacts).

### 2.2. Implementation: API Handlers in `server.ts`
*   The existing Express server (`src/server.ts`) will handle all LLM-related requests.
*   **Socket.IO `'start_ascentia_stream'` event:** This event is now used for all `@Ascentia` queries. It provides a streaming response for a better user experience.
*   **Socket.IO `'start_chatbot_stream'` event:** This event will be used for all streaming requests, specifically for the "Chat with Service" feature.
*   **`/api/llm/proxy` (POST):** This endpoint now handles only non-streaming, single-turn requests for features like the Player LLM Terminal.
*   The handlers for these routes and events will:
    1.  Authenticate the user session.
    2.  Based on the request's `context`, construct a final prompt string, potentially adding system instructions, game rules, or degradation parameters.
    3.  Use a server-side `fetch` to send the final, formatted request to the appropriate local LLM endpoint specified in an environment variable.
    4.  **For streaming:** The handler will read the `ReadableStream`, parse the SSE chunks, and emit the relevant `_stream_chunk` and `_stream_end` events back to the originating client socket.
    5.  **For non-streaming:** The handler will return the full response in the JSON body.

## 3. Local LLM Server Configuration (LM Studio)

### 3.1. Environment Variables (`.env` file)

To allow for flexible connections to different LLM servers (local, remote on the same network, or even production endpoints), the `server.ts` logic will prioritize URLs in the following order:

1.  **`REMOTE_LLM_URL` (NEW):** Use this to specify the address of an LLM running on a different machine on your local network. This is ideal for a two-PC development setup.
    *   **Example:** `REMOTE_LLM_URL=http://192.168.1.85:1234`
2.  **`LOCAL_LLM_URL`:** The standard variable for an LLM running on the same machine as the game server.
    *   **Example:** `LOCAL_LLM_URL=http://127.0.0.1:1234`
3.  **Hardcoded Default:** If neither environment variable is set, the server will fall back to `http://127.0.0.1:1234`.

The server will log which URL it is using upon startup for easy debugging.

### 3.2. Recommended Model & Settings
*   **Model:**
    *   **Identifier:** `qwen/qwen3-30b-a3b`
    *   **Context Length:** 32,768
*   **Server:**
    *   **Address:** Match the address in your `.env` file (e.g., `http://192.168.1.85:1234`).
    *   **Enable "Serve on Local Network"** in LM Studio if you are using `REMOTE_LLM_URL`.
    *   **Preset:** OpenAI API
*   **Hardware & Performance:**
    *   **GPU Offload:** Max
*   **Inference Parameters (Default for Creative/Chat Tasks):**
    *   **Temperature:** 0.8
    *   **Top K Sampling:** 40
    *   **Repeat Penalty:** 1.1
    *   **Top P Sampling:** 0.95
*   **Prompt Format:** For chatbot conversations sent to the `/v1/completions` endpoint, the prompt must be manually constructed using the model's chat template.

## 4. State Management: `llmStore.ts`

A new Zustand store will be created to manage the state of LLM-related interactions.

*   **`src/state/llmStore.ts`**
*   **State:**
    *   `isPlayerLlmTerminalOpen: boolean`
    *   `isPlayerChatbotInterfaceOpen: boolean`
    *   `isPoetryBattleViewerOpen: boolean`
    *   `productIdForInteraction: string | null`
    *   `activePoetryBattle: PoetryBattleState | null`
*   **Actions:**
    *   `openLlmTerminal(productId)`
    *   `openChatbotInterface(productId)`
    *   `closeInteractions()`
    *   ...and other actions for managing poetry battles.

## 5. New Files & Components

*   **Frontend UI:**
    *   `src/components/menus/llm/PlayerLlmTerminal.tsx`
    *   `src/components/menus/llm/PlayerChatbotInterface.tsx`
    *   `src/components/menus/llm/PoetryBattleViewer.tsx`
*   **Game Logic:** `src/game/systems/PoetryBattleSystem.ts`
*   **State:** `src/state/llmStore.ts`

This plan establishes a secure and extensible foundation for integrating LLM-powered features into AI Ascent.
</file>

<file path="src/Artifacts/A15. DCE - Phase 1 - Multi-Select & Sorting Feature Plan.md">
# Artifact A15: DCE - Phase 1 - Multi-Select & Sorting Feature Plan
# Date Created: Cycle 22
# Author: AI Model
# Updated on: C40 (Documented RCA and fix for batch removal bug)

- **Key/Value for A0:**
- **Description:** Details the requirements for multi-selection (click, Ctrl, Shift) in both the main file tree and the "Selected Items" panel, and multi-level column sorting.
- **Tags:** feature plan, multi-select, sorting, list view, ux, phase 1

## 1. Overview & Goal

To elevate the Data Curation Environment beyond basic functionality, this plan introduces advanced list-interaction features common in modern applications. The goal is to provide users with powerful and intuitive tools for managing their file selections, mirroring the behavior of native operating system file explorers. This includes robust multi-selection capabilities in both the main file tree and the "Selected Items" panel, and comprehensive sorting for the "Selected Items" list.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| US-01 | **"Selected Items" Multi-Selection** | As a curator, after selecting a large folder, I want to quickly remove a small group of unwanted files from the "Selected Items" list using standard Shift-click and Ctrl-click, so I don't have to uncheck them one by one in the main tree. | - Clicking a single item in the "Selected Items" list selects it and deselects all others. <br> - Ctrl-clicking an item toggles its selection state without affecting other items. <br> - Shift-clicking an item selects the range of items between the last-clicked anchor item and the current one. The anchor is set by the last non-Shift click. <br> - A "Remove Selected" button acts on all currently selected items in this list. |
| US-02 | **"Selected Items" Column Sorting** | As a curator, I want to sort the "Selected Items" list by file name or token count, so I can easily find specific files or identify the largest contributors to my context. | - The "Selected Items" panel has a header row with clickable "File" and "Tokens" labels. <br> - Clicking a column header sorts the list by that column. <br> - Clicking the same header again reverses the sort direction (ascending/descending). <br> - A visual indicator (e.g., an arrow) shows the current sort column and direction. <br> - The default, initial sort is by Token Count, descending. |
| US-03 | **"Selected Items" Multi-Layer Sorting** | As a curator, I want to apply a secondary sort, so I can group my selected files by type and then see the largest files within each group. | - The sorting mechanism supports at least two levels of sorting. <br> - The UI provides a way to define a primary and secondary sort key (e.g., Shift-clicking a second column header). <br> - The list first organizes by the primary key, then sorts items within those groups by the secondary key. For example, sort by Type (asc), then by Token Count (desc). |
| US-04 | **Main Tree Multi-Selection** | As a user, I want to select multiple files and folders in the main "Data Curation" file tree using standard OS conventions (Ctrl/Shift click), so I can perform context menu actions (like Delete) on multiple items at once. | - Standard multi-selection is implemented in the main file tree. <br> - This selection is a separate state from the checkbox state and is used for contextual actions, not for flattening. <br> - Right-clicking on any item within a multi-selected group opens a context menu that applies its actions to all selected items. <br> - **(Bug C31):** Ctrl-click is non-functional. Shift-click is inconsistent and difficult to use. |
| US-05 | **"As-Is" Sorting** | As a user, I want to be able to revert the "Selected Items" list to its default sort order, so I can see the files as they appear in the native VS Code explorer. | - A sort option for "Default" or "As-Is" is available. <br> - Selecting it sorts the items based on their original file system order (folders first, then files, all alphabetized). |

## 3. Technical Implementation Plan

1.  **`SelectedFilesView.tsx` Refactor:**
    *   **State Management:** Introduce new state variables to manage selection, sorting, and multi-selection.
        *   `const [selection, setSelection] = useState<Set<string>>(new Set());`
        *   `const [selectionAnchor, setSelectionAnchor] = useState<string | null>(null);` // For stable shift-click
        *   `const [sortConfig, setSortConfig] = useState<{ key: string; direction: 'asc' | 'desc' }[]>([{ key: 'tokenCount', direction: 'desc' }]);`
    *   **Event Handling:** Implement a comprehensive `onClick` handler for list items that inspects `event.ctrlKey` and `event.shiftKey`. A non-modifier click will set both the `selection` and the `selectionAnchor`. A shift-click will select from the `selectionAnchor` to the current item.
    *   **Sorting Logic:** The `useMemo` hook that sorts the `selectedFileNodes` prop will be updated to handle an array of `sortConfig` objects. It will perform a stable sort, iterating through the sort criteria until a non-zero comparison result is found. A new "Type" column will be added, requiring a utility to extract the file extension.

2.  **Batch Removal Logic (`FileTree.utils.ts`):**
    *   **Root Cause of C40 Bug:** The `removePathsFromSelected` function was buggy. It iterated through the list of files to remove, calling the single-item removal utility (`addRemovePathInSelectedFiles`) on each. This created a race condition where the first removal would perform a "subtractive uncheck" (e.g., removing `src` and adding back all its other children), drastically changing the selection state that subsequent iterations of the loop were relying on.
    *   **Codified Solution (C40):** The `removePathsFromSelected` function will be rewritten to be non-iterative and set-based. It will calculate the final desired state in a single pass by determining the full set of effectively selected files, removing the unwanted files from that set, and then "compressing" the remaining set of files back into the most efficient list of parent directories and individual files. This atomic approach is more robust and avoids the state mutation bug.

3.  **`FileTree.tsx` & `TreeView.tsx` (Main Tree Multi-Select):**
    *   This is a more complex task that mirrors the `SelectedFilesView` implementation but within a recursive tree structure.
    *   A new selection state for contextual actions (`const [contextSelection, setContextSelection] = useState<Set<string>>(new Set())`) will be managed at the top level (`view.tsx`).
    *   The selection state and handler functions will need to be passed down through `FileTree` to `TreeView`.
    *   **(Fix for C31):** The `handleNodeClick` event handler in `TreeView.tsx` must be corrected. The anchor for shift-click (`lastClickedPath`) must only be updated on a click *without* the Shift key pressed. The logic for Ctrl-click must be revised to correctly toggle a path's inclusion in the selection set without clearing other selections.
    *   The `onContextMenu` handler will need to be updated to check if the right-clicked node is part of the current `contextSelection` and pass the entire selection to the backend if an action is chosen.
</file>

<file path="src/Artifacts/A16. DCE - Phase 1 - UI & UX Refinements Plan.md">
# Artifact A16: DCE - Phase 1 - UI & UX Refinements Plan
# Date Created: Cycle 22
# Author: AI Model
# Updated on: C43 (Add Expand All button)

- **Key/Value for A0:**
- **Description:** Covers visual and usability improvements like fixing panel layouts, resolving overflow bugs, adding loading indicators, and improving scrollbar visibility.
- **Tags:** feature plan, ui, ux, layout, bug fix, loading indicator, phase 1

## 1. Overview & Goal

This document outlines a series of user interface (UI) and user experience (UX) refinements identified during playtesting. The goal is to address layout bugs, provide better visual feedback to the user, and improve the overall professional feel of the extension. These changes focus on fixing immediate usability problems and making the extension more intuitive to operate.

## 2. User Stories & Issues

| ID | User Story / Issue | Acceptance Criteria |
|---|---|---|
| UI-01 | **Header Layout Bug** | As a user, I want the header of the "Data Curation" panel to be compact, without the extra vertical space between the title and the toolbar buttons, so it looks clean and professional. | - The vertical gap between the view title row and the toolbar button row is removed. <br> - The header area takes up minimal vertical space. <br> - This is a CSS fix, likely involving adjusting `padding`, `margin`, or `gap` in the flex container. |
| UI-02 | **"Selected Items" Overflow Bug** | As a user, when I select many files, I want the "Selected Items" list to scroll within its panel instead of running off the screen behind the "Flatten Context" footer, so I can see and manage all my selections. | - The "Selected Items" panel has a defined `max-height`. <br> - When the content exceeds this height, a vertical scrollbar appears. <br> - The panel never overlaps or pushes the footer out of view. <br> - This is a CSS fix involving `flex-grow`, `flex-shrink`, `min-height: 0` on the file tree container, and `overflow-y: auto` on the list container. |
| UI-03 | **Resizable "Selected Items" Panel** | As a user, I want to be able to vertically resize the "Selected Items" panel, so I can see more or fewer items as needed for my current task. | - A draggable handle or resizer element is added to the top border of the "Selected Items" panel. <br> - Clicking and dragging this handle adjusts the `height` or `max-height` of the panel. <br> - The main file tree above it resizes accordingly to fill the remaining space. |
| UI-04 | **Visible Loading State** | As a user, when I perform a slow action like renaming a file or refreshing the explorer, I want to see a loading indicator, so I have clear feedback that the system is working and not frozen. | - A loading state (e.g., `isLoading`) is added to the main view's state. <br> - This state is set to `true` when a file system scan begins (e.g., on initial load or refresh). <br> - A loading indicator (e.g., a spinning icon) is displayed in the UI (e.g., in the header toolbar) while `isLoading` is true. <br> - The state is set to `false` when the file data is received from the backend. |
| UI-05 | **Improved Scrollbar Gutter** | As a user, I find it difficult to distinguish between the extension's internal scrollbar and the main VS Code scrollbar when they are side-by-side. I want a clearer visual separation between them. | - A subtle vertical border (`border-right`) is added to the main file tree container. <br> - This creates a persistent, visible dividing line between the two scrollable areas, making it easier to position the mouse. |
| UI-06 | **Expand All Button** | As a user, I want an "Expand All" button in the toolbar, so I can quickly see all files in the project without manually clicking every folder. | - An "Expand All" button is added to the main header toolbar. <br> - Clicking it expands every collapsed folder in the file tree. <br> - The button complements the existing "Collapse All" button. |

## 3. Technical Implementation Plan

1.  **Layout Fixes (`view.scss`):**
    *   **Header:** Inspect the `.view-header` and `.toolbar` classes. Remove any unnecessary `margin` or `padding`. Consolidate into a single flex container with `justify-content: space-between` if the title is to be included, or simply adjust the container of the toolbar.
    *   **Overflow:** This is a classic flexbox problem. The main container (`.view-container`) should be `display: flex; flex-direction: column; height: 100vh;`. The content area (`.file-tree-container`) must have `flex-grow: 1;` and crucially `min-height: 0;` to allow it to shrink. The "Selected Items" panel (`.selected-files-panel`) should have `flex-shrink: 0;` and `overflow-y: auto;` on its list container.
    *   **Scrollbar Gutter:** Add `border-right: 1px solid var(--vscode-panel-border);` to the `.file-tree-container`.

2.  **Loading Indicator (`view.tsx`):**
    *   Add `const [isLoading, setIsLoading] = useState(true);`.
    *   Set `setIsLoading(true)` at the start of the `requestFiles` function.
    *   Set `setIsLoading(false)` inside the `handleFileResponse` message handler after files are received and set.
    *   In the JSX for the `.toolbar`, add conditional rendering: `{isLoading && <SpinnerComponent />}`. The spinner can be an SVG or a component using `react-icons`.

3.  **Resizable Panel:**
    *   This is the most complex part of this plan. It typically requires a custom React hook or component.
    *   An invisible `div` will be placed on the top border of the panel.
    *   `onMouseDown`, `onMouseMove`, and `onMouseUp` event listeners will be used to track the drag gesture and calculate the new height for the panel.
    *   The height will be applied as an inline style to the panel.
    *   This feature will be implemented after the more critical bug fixes are complete.

4.  **Expand All (`view.tsx`, `TreeView.tsx`):**
    *   Add an "Expand All" button to the toolbar in `view.tsx`.
    *   Add a new state trigger: `const [expandAllTrigger, setExpandAllTrigger] = useState(0);`.
    *   The button's `onClick` handler will call `setExpandAllTrigger(c => c + 1)`.
    *   Pass the trigger down as a prop to `TreeView.tsx`.
    *   In `TreeView.tsx`, a `useEffect` will listen for changes to `expandAllTrigger`. When it fires, it will recursively traverse the `data` prop, collect all directory paths, and call `setExpandedNodes` with the full list.
</file>

<file path="src/Artifacts/A17. DCE - Phase 1 - Advanced Tree View Features.md">
# Artifact A17: DCE - Phase 1 - Advanced Tree View Features
# Date Created: Cycle 22
# Author: AI Model

- **Key/Value for A0:**
- **Description:** Outlines the plan for advanced tree view interactions, specifically the implementation of scrollable, self-contained views for large, expanded folders.
- **Tags:** feature plan, tree view, ux, scrollable, phase 1

## 1. Overview & Goal

The current file tree view expands vertically, which can create a poor user experience when a folder containing hundreds of files is opened. The entire view becomes excessively long, forcing the user to scroll a great distance to see files or folders below the expanded one. The goal of this feature is to innovate on the traditional tree view by containing the contents of a large expanded folder within a scrollable, "inline" window, preventing the main view from becoming unmanageable.

## 2. User Story

| ID | User Story | Acceptance Criteria |
|---|---|---|
| TV-01 | **Contained Folder Expansion** | As a user, when I expand a folder with a large number of children, I want its contents to appear in a scrollable sub-panel within the tree instead of pushing all subsequent items down, so I can browse the folder's contents without losing my place in the main file tree. | - When a folder is expanded, the extension checks the number of direct children. <br> - If the child count exceeds a certain threshold (e.g., 50), the children are rendered inside a nested, scrollable `div`. <br> - This `div` has a fixed `max-height`. <br> - A small 'x' icon is visible within this sub-panel. Clicking it closes the sub-panel and reverts the folder to the standard, fully expanded view for that session. |

## 3. Technical Implementation Plan

This is a significant UI/UX enhancement and will require careful implementation within the React component hierarchy.

1.  **Component (`TreeView.tsx`):**
    *   The core logic will reside in the `renderTreeNodes` function.
    *   **Threshold Check:** When rendering a directory node, check `if (node.children && node.children.length > FOLDER_CONTENT_THRESHOLD)`. The threshold will be a configurable constant.
    *   **State Management:** A new state variable will be needed to track which "large" folders have been reverted to the standard view by the user clicking the 'x' button. `const [standardViewFolders, setStandardViewFolders] = useState<Set<string>>(new Set());`
    *   **Conditional Rendering:**
        *   If the folder is expanded (`isExpanded`) AND its path is **not** in `standardViewFolders` AND it exceeds the threshold, render the children inside a special container:
            ```jsx
            <div className="large-folder-container" style={{ maxHeight: '300px', overflowY: 'auto' }}>
              <button onClick={() => setStandardViewFolders(prev => new Set(prev).add(node.absolutePath))}>X</button>
              <ul>{renderTreeNodes(node.children)}</ul>
            </div>
            ```
        *   Otherwise, render the children normally as is currently done:
            ```jsx
            <ul className="treenode-children">{renderTreeNodes(node.children)}</ul>
            ```

2.  **Styling (`view.scss`):**
    *   Create styles for `.large-folder-container`.
    *   It will need `position: relative`, a subtle `border` or `background-color` to distinguish it from the rest of the tree.
    *   The close button will need to be positioned appropriately within the container.

3.  **Performance Considerations:**
    *   This approach avoids virtualizing the entire tree, which is much more complex. It only contains the content of single, large folders.
    *   Rendering hundreds of nodes within the scrollable container might still have a minor performance impact on initial render, but it will be contained and will not affect the performance of the main tree's scrolling.
</file>

<file path="src/Artifacts/A18. DCE - Phase 1 - Active File Sync Feature Plan.md">
# Artifact A18: DCE - Phase 1 - Active File Sync Feature Plan
# Date Created: Cycle 24
# Author: AI Model
# Updated on: C44 (Add logic for suppressing auto-reveal after file operations)

- **Key/Value for A0:**
- **Description:** Details the requirements and implementation for automatically revealing and highlighting the active editor's file in the custom Data Curation file tree.
- **Tags:** feature plan, active file, sync, reveal, tree view, ux, phase 1

## 1. Overview & Goal

To create a more seamless and integrated experience, the Data Curation Environment's file tree should stay in sync with the user's focus in the main editor. Currently, selecting a file in the editor does not reflect in our custom view. The goal of this feature is to replicate the behavior of the native VS Code Explorer, where the active file is automatically revealed and highlighted in the file tree.

## 2. User Story

| ID | User Story | Acceptance Criteria |
|---|---|---|
| UX-01 | **Sync with Active Editor** | As a user, when I click on a file in the VS Code editor tabs or the native Explorer, I want the "Data Curation" file tree to automatically scroll to and highlight that file, so I can easily see its location in the project hierarchy and interact with its checkbox without manually searching for it. | - When the active text editor changes in VS Code, the new file is highlighted in the "Data Curation" tree view. <br> - All parent folders of the active file are automatically expanded to ensure it is visible. <br> - The file tree view scrolls so that the active file item is visible on the screen. |
| UX-02 | **Preserve View State** | As a user, after I perform an action that collapses the tree (e.g., "Collapse All") and then perform a file operation (e.g., drag-and-drop), I do not want the tree to automatically re-expand to reveal the active file, so my intended view state is respected. | - After a file operation (move, delete, rename, new file) triggers a refresh, the "Sync with Active Editor" feature is temporarily suppressed for the next event. <br> - This prevents the tree from re-expanding against the user's will. |

## 3. Technical Implementation Plan

1.  **Backend Listener (`extension.ts`):**
    *   Utilize the `vscode.window.onDidChangeActiveTextEditor` event listener in the `activate` function.
    *   This event provides the `TextEditor` object, from which `editor.document.uri.fsPath` can be extracted.
    *   When the event fires and an editor is present, the backend will normalize the file path (to use forward slashes) and send an IPC message to the webview containing the active file's path.

2.  **IPC Channel:**
    *   The existing `ServerToClientChannel.SetActiveFile` will be used.
    *   **(C44 Update)** The `ServerToClientChannel.ForceRefresh` channel's payload is updated from `{}` to `{ reason?: 'fileOp' | 'manual' }`.

3.  **Frontend View Logic (`TreeView.tsx`):**
    *   A `useEffect` hook in the `TreeView` component triggers whenever the `activeFile` prop changes.
    *   This effect is responsible for "revealing" the file by calculating all parent directory paths, adding them to the `expandedNodes` state, and then calling `scrollIntoView()` on the file's element ref.

4.  **Auto-Reveal Suppression Logic (C44):**
    *   **Backend (`fs.service.ts`):** The file watcher, upon detecting a change, will now send the `ForceRefresh` message with a payload: `{ reason: 'fileOp' }`.
    *   **Frontend (`view.tsx`):**
        *   A `useRef` flag (`suppressActiveFileReveal`) is used to track the suppression state.
        *   The message handler for `ForceRefresh` checks for the `fileOp` reason and sets the suppression flag to `true`, with a timeout to reset it.
        *   The message handler for `SetActiveFile` checks the flag. If `true`, it ignores the event, resets the flag, and prevents the `activeFile` state from being updated, thus preventing the reveal.

## 5. Debugging Notes & Regression Prevention

-   **Root Cause of C30 Regression:** The feature failed because of a path normalization mismatch. The `editor.document.uri.fsPath` property from the VS Code API returns paths with **backslashes (`\`)** on Windows. The frontend webview components, however, exclusively use and expect **forward slashes (`/`)** for path comparisons and manipulations.
-   **Codified Solution:** The path from the `onDidChangeActiveTextEditor` event **must** be normalized to use forward slashes *before* it is sent to the frontend via the IPC channel.
</file>

<file path="src/Artifacts/A189. Number Formatting Reference Guide.md">
# Artifact A189: Number Formatting Guide (K/M Suffixes & Dynamic Decimals)
# Date Created: Cycle 14
# Author: AI Model & Curator

- **Key/Value for A0:**
- **Description:** A standalone guide and utility script for formatting large numbers with K/M/B/T suffixes and dynamic decimal place adjustment for clean UI presentation.
- **Tags:** utility, script, formatting, numbers, ui, ux, javascript, typescript

## 1. Purpose

This artifact provides a set of robust, reusable TypeScript functions for formatting numbers in a user-friendly way. The core function, `formatLargeNumber`, intelligently converts large numbers into a compact format using suffixes like 'K' (thousands), 'M' (millions), 'B' (billions), and 'T' (trillions).

The key features of this utility are:
*   **Automatic Suffixing:** Automatically scales numbers and adds the appropriate suffix.
*   **Dynamic Decimal Precision:** Adjusts the number of decimal places shown based on the magnitude of the number, ensuring a clean and consistent look in the UI (e.g., `12.3K`, `123.5K`, `1.23M`).
*   **Handling of Small Numbers:** Gracefully handles numbers below 1,000 without applying a suffix.
*   **Specialized Wrappers:** Includes helper functions like `formatCurrency` and `formatCount` for common use cases.

## 2. Core Utility Functions (from `src/utils.ts`)

Below is the complete TypeScript code. You can save this as a `formatting.ts` file in a new project's `utils` directory.

```typescript
// src/common/utils/formatting.ts

const KMBT_SUFFIXES = ['', 'K', 'M', 'B', 'T', 'Q']; // Extend as needed

/**
 * Formats a large number with appropriate K/M/B/T suffixes and dynamic decimal places.
 * Handles very small near-zero numbers gracefully to avoid scientific notation.
 *
 * @param value The number to format.
 * @param decimalPlaces The base number of decimal places to aim for.
 * @returns A formatted string.
 */
export function formatLargeNumber(value: number | undefined | null, decimalPlaces: number = 2): string {
    if (value === null || value === undefined || isNaN(value) || !Number.isFinite(value)) {
        return '---';
    }
    if (value === 0) {
        return '0';
    }

    const VERY_SMALL_THRESHOLD = 1e-6; // 0.000001
    if (Math.abs(value) < VERY_SMALL_THRESHOLD) {
        return (0).toFixed(decimalPlaces);
    }

    const isNegative = value < 0;
    const absValue = Math.abs(value);

    let unitIndex = 0;
    let scaledValue = absValue;

    if (absValue < 1000) {
        return String(Math.round(value)); // Return whole number if less than 1000
    }

    if (absValue >= 1000) {
        unitIndex = Math.floor(Math.log10(absValue) / 3);
        unitIndex = Math.min(unitIndex, KMBT_SUFFIXES.length - 1);
        scaledValue = absValue / Math.pow(1000, unitIndex);
    }

    let adjustedDecimalPlaces = decimalPlaces;
    if (unitIndex > 0) { // If a suffix is used (K, M, B, T, Q)
        if (scaledValue >= 100) adjustedDecimalPlaces = Math.max(0, decimalPlaces - 2);
        else if (scaledValue >= 10) adjustedDecimalPlaces = Math.max(0, decimalPlaces - 1);
    } else { // No unit suffix (value < 1000)
        if (Math.abs(scaledValue) < 0.01 && scaledValue !== 0) {
            adjustedDecimalPlaces = Math.max(decimalPlaces, 4);
        } else if (Number.isInteger(scaledValue)) {
             adjustedDecimalPlaces = 0;
        }
    }

    const unit = KMBT_SUFFIXES[unitIndex] ?? '';
    let formattedValue = scaledValue.toFixed(adjustedDecimalPlaces);

    // Remove trailing .00 or .0
    if (adjustedDecimalPlaces > 0 && formattedValue.endsWith('0')) {
        formattedValue = formattedValue.replace(/\.?0+$/, '');
    }


    return `${isNegative ? '-' : ''}${formattedValue}${unit}`;
}```

## 3. Usage Examples

Here is how you can use these functions in your code:

```typescript
import { formatLargeNumber } from './path/to/formatting';

// formatLargeNumber examples
console.log(formatLargeNumber(123));        // "123"
console.log(formatLargeNumber(1234));       // "1.23K"
console.log(formatLargeNumber(12345));      // "12.3K"
console.log(formatLargeNumber(123456));     // "123K"
console.log(formatLargeNumber(1234567));    // "1.23M"
console.log(formatLargeNumber(9876543210)); // "9.88B"
console.log(formatLargeNumber(-54321));     // "-54.3K"
console.log(formatLargeNumber(0.0000001));  // "0.00"
```

## 4. Integration Guide

1.  **Copy the Code:** Save the code from Section 2 into a file named `formatting.ts` inside your project's `src/common/utils` directory.
2.  **Import and Use:** Import the function into your UI components.
    ```typescript
    import { formatLargeNumber } from '@/common/utils/formatting';

    const MyComponent = () => {
      const displayValue = formatLargeNumber(123456); // "123K"
      return <div>Tokens: {displayValue}</div>;
    };
    ```
</file>

<file path="src/Artifacts/A19. DCE - Phase 1 - Double-Click & Quick-Remove Feature Plan.md">
# Artifact A19: DCE - Phase 1 - File Interaction Plan (Click & Remove)
# Date Created: Cycle 26
# Author: AI Model
# Updated on: C28 (Changed interaction model from double-click to single-click to open files)

- **Key/Value for A0:**
- **Description:** Details the requirements for opening files by single-clicking them and quickly removing single files from the selection list via a mouse-over action.
- **Tags:** feature plan, single-click, open file, quick remove, ux, phase 1

## 1. Overview & Goal

To further align the Data Curation Environment with standard, intuitive user workflows, this plan introduces two high-impact interaction enhancements. The first is the ability to **single-click** any file to open it in the main editor, mimicking the native VS Code Explorer behavior. The second is a "quick-remove" feature in the "Selected Items" panel, allowing for rapid, single-click removal of files. The goal is to reduce friction and increase the speed at which a user can curate their context.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| UX-01 | **Single-Click to Open (Main Tree)** | As a user, I want to be able to single-click on a file in the main "Data Curation" file tree and have it open in the editor, so I can quickly view its contents just like in the native Explorer. | - A single click on a file item (not a folder) in the main file tree opens that file in the main VS Code editor pane. <br> - If the file is already open in a tab, the editor switches focus to that tab. <br> - A single click on a folder still expands or collapses it. |
| UX-02 | **Single-Click to Open (Selected List)** | As a user, I want to single-click a file in the "Selected Items" list to open it, so I can easily inspect the files that are contributing the most tokens to my context. | - A single click on a file item in the "Selected Items" list opens that file in the main VS Code editor pane. <br> - If the file is already open, focus is switched to its tab. |
| UX-03 | **Quick Remove from Selection** | As a user, after selecting a large folder, I want to quickly remove a single file from the "Selected Items" list with one click, so I don't have to select it and then click the "Remove Selected" button. | - In the "Selected Items" list, when I mouse over a file row, the row number (in the `#` column) is replaced by an 'X' icon. <br> - Clicking the 'X' icon immediately removes that single file from the selection. <br> - This action is equivalent to selecting only that file and clicking "Remove Selected". <br> - The mouse leaving the row restores the row number. |

## 3. Technical Implementation Plan

1.  **IPC Channel (`channels.enum.ts`, `channels.type.ts`):**
    *   The existing `ClientToServerChannel.RequestOpenFile` is sufficient.
    *   The `ChannelBody` remains `{ path: string }`.

2.  **Backend Handler (`on-message.ts`, `fs.service.ts`):**
    *   The existing handler for `RequestOpenFile` in `fs.service.ts` is sufficient. It uses `vscode.workspace.openTextDocument` and `vscode.window.showTextDocument`.

3.  **Frontend - Single-Click (`TreeView.tsx`, `SelectedFilesView.tsx`):**
    *   In `TreeView.tsx`, the main `onClick` handler (`handleToggleNode`) will be modified. It will now check if the clicked node is a file or a directory.
        *   If it's a file, it will call `clientIpc.sendToServer(ClientToServerChannel.RequestOpenFile, ...)`.
        *   If it's a directory, it will perform the existing expand/collapse logic.
    *   In `SelectedFilesView.tsx`, the `onDoubleClick` handler will be removed and the `onClick` handler will be simplified to *only* open the file, as the multi-selection logic is handled by checking for modifier keys (`ctrlKey`, `shiftKey`).

4.  **Frontend - Quick Remove (`SelectedFilesView.tsx`, `view.scss`):**
    *   **State:** A state variable will track the hovered item's path: `const [hoveredPath, setHoveredPath] = useState<string | null>(null);`.
    *   **Event Handlers:** Add `onMouseEnter` and `onMouseLeave` to the `<li>` element to update the hover state.
    *   **Conditional Rendering:** In the JSX for the index column, render conditionally: if the row is hovered, show an 'X' icon with an `onClick` handler; otherwise, show the row number.
    *   **Styling:** Add styles for the `.quick-remove` class in `view.scss` to ensure it's clickable and has appropriate hover effects.
    *   The `onClick` handler for the 'X' icon will call the existing `onRemove` prop and use `stopPropagation` to prevent the click from also selecting the row.
</file>

<file path="src/Artifacts/A2. DCE - Phase 1 - Context Chooser - Requirements & Design.md">
# Artifact A2: DCE - Phase 1 - Context Chooser - Requirements & Design
# Date Created: Cycle 1
# Author: AI Model
# Updated on: C46 (Remove requirement for ignoring binary files, per A29)

## 1. Overview

This document outlines the requirements for Phase 1 of the Data Curation Environment (DCE) project. The primary goal of this phase is to replace the manual, error-prone process of managing context via a `files_list.txt` with an intuitive, UI-driven approach within VS Code.

**Major Update (Cycle 2):** The analysis of the `The-Creator-AI-main` repository revealed an existing, highly-functional file tree component (`src/client/components/file-tree/FileTree.tsx`) with checkbox selection. The project requirements have been updated to reflect a shift from *building* this component from scratch to *analyzing, adapting, and integrating* the existing solution.

## 2. Functional Requirements

| ID | Requirement | User Story | Acceptance Criteria | Update (Cycle 2) |
|---|---|---|---|---|
| FR-01 | **Analyze Existing File Tree** | As a developer, I want to understand the capabilities of the `FileTree.tsx` component | - Analyze the component's props and state. <br> - Document its dependencies on other frontend components and backend services (`FSService`). <br> - Determine how checkbox state is managed and communicated. | **New** |
| FR-02 | **Display File Tree in View** | As a user, I want to see a tree of all files and folders in my workspace within a dedicated VS Code view. | - The view should accurately reflect the workspace's file system structure. <br> - It should respect `.gitignore` rules to hide irrelevant files. | **Adaptation.** The `FileTree.tsx` component and `FSService` already provide this. We need to ensure it's correctly instantiated in our extension's view. |
| FR-03 | **Checkbox Selection** | As a user, I want to select and deselect files and folders for my context using checkboxes. | - Every file and folder in the tree has a checkbox. <br> - Checking a folder checks all its children. <br> - Unchecking a folder unchecks all its children. <br> - A folder shows an "indeterminate" state if only some of its children are checked. | **Adaptation.** The reference component appears to support this logic. We must verify and adapt its state management (`selectedFiles` array). |
| FR-04 | **Flatten Selected Context** | As a user, I want a single button to package all my selected files into one context file. | - A "Flatten Context" button is present in the view. <br> - Clicking it triggers a process that reads the content of all checked files. <br> - The contents are concatenated into a single `flattened_repo.md` file in the project root. | **Implementation.** The logic for this will need to be implemented, using the state from the `FileTree` component as input for our enhanced `bootstrap-flattener.js` logic. |
| FR-05 | **Handle Binary Files** | As a user, I want to be able to select binary/image files to include their metadata in the context, without including their raw content. | - All files, including binary and image files, are selectable via their checkbox. <br> - When a binary/image file is selected and flattened, only its metadata (path, size, type) is included in `flattened_repo.md`. <br> - See `A29` for the full strategy. | **Revised (C46)** |
</file>

<file path="src/Artifacts/A20. DCE - Phase 1 - Advanced UX & Automation Plan.md">
# Artifact A20: DCE - Phase 1 - Advanced UX & Automation Plan
# Date Created: C27
# Author: AI Model
# Updated on: C73 (Adjust token count color scheme to make red the highest risk)

- **Key/Value for A0:**
- **Description:** Details plans for several UX enhancements, including auto-revealing the flattened file, showing selected counts in folder stats, and providing an option to auto-add new files to the selection.
- **Tags:** feature plan, ux, automation, reveal, statistics, auto-add, phase 1

## 1. Overview & Goal

This document outlines a series of advanced user experience (UX) and automation features designed to further streamline the data curation workflow. The goal is to reduce manual steps, provide more insightful contextual information, and make the extension's UI more flexible and powerful.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| UXA-01 | **Auto-Reveal Flattened File** | As a user, after I click "Flatten Context," I want the newly created `flattened_repo.md` file to be automatically selected and revealed in the file tree, so I can immediately open it without searching. | - After the `flattened_repo.md` file is created or updated, it becomes the `activeFile` in the Data Curation view. <br> - The tree view automatically expands and scrolls to show the `flattened_repo.md` file. |
| UXA-02 | **Contextual Selected Count** | As a user, when I have files selected inside a folder, I want to see a count of how many files are selected within that folder, displayed next to the folder's total file count, so I can understand my selection density at a glance. | - Next to a folder's total file count, a secondary count in parentheses `(x)` appears. <br> - `x` represents the number of files within that folder (recursively) that are part of the current selection. <br> - This count only appears if `x` is greater than 0 and less than the folder's total file count. |
| UXA-03 | **Minimize Selection Panel** | As a user, once I've made my selection, I want to minimize the "Selected Items" list to reclaim vertical space while keeping the "Flatten Context" button accessible, so I can focus on the main file tree. | - A minimize/expand button is present in the "Selected Items" panel header. <br> - Clicking it collapses the list of selected files, but the panel's header, toolbar, and the main footer (with the Flatten button) remain visible. <br> - Clicking it again expands the list to its previous state. |
| UXA-04 | **Auto-Add New Files** | As a user, I want to enable an "auto-add" mode where any new file I create in the workspace is automatically added to my current selection, so I don't have to break my coding flow to manually check the new file. | - A toggle button or checkbox exists in the UI to enable/disable "Auto-Add New Files" mode. <br> - When enabled, any file created in the workspace is automatically added to the `selectedFiles` list. <br> - The file system watcher is responsible for detecting file creation and triggering this logic. <br> - The state of this toggle is persisted in the workspace state. |
| UXA-05 | **Resizable Panels** | As a user, I want to be able to click and drag the divider between the main file tree and the "Selected Items" panel to vertically resize them, so I can customize the layout to my needs. | - The horizontal divider between the two main panels is a draggable handle. <br> - Dragging it up or down resizes both panels accordingly, while respecting their minimum and maximum height constraints. |
| UXA-06 | **Token Count Color Coding** | As a user, I want the items in the "Selected Items" list to be color-coded based on their token count, so I can immediately identify potentially problematic large files. | - List items have a background color that corresponds to their token count. <br> - **(C73 Update)** The color scheme indicates increasing risk: <br> - **0-8k tokens:** Green (Low risk). <br> - **8k-10k tokens:** Yellow (Slight risk). <br> - **10k-12k tokens:** Orange (Moderate risk). <br> - **12k+ tokens:** Red (High risk). <br> - A tooltip explains the color coding and associated risk. |
| UXA-07 | **Auto-Uncheck Empty Folder** | As a user, when I remove the last selected file from a folder via the "Selected Items" panel, I want the parent folder to become unchecked in the main file tree, so the UI state remains consistent. | - When a file removal action is processed, the logic checks if any sibling files of the removed file are still selected. <br> - If no siblings remain selected under a parent folder that was previously checked, that parent folder is also removed from the selection. |


## 3. Technical Implementation Plan

-   **Auto-Reveal (UXA-01):**
    -   Create a new IPC channel `ServerToClientChannel.FocusFile`.
    -   Backend (`flattener.service.ts`): After writing the file, send the `FocusFile` message with the file's absolute path. A small delay might be needed to allow the file watcher to trigger a UI refresh first.
    -   Frontend (`view.tsx`): Listen for `FocusFile` and call `setActiveFile` with the received path. The existing `useEffect` in `TreeView.tsx` will handle the reveal.
-   **Selected Count (UXA-02):**
    -   Frontend (`FileTree.tsx`): Implement a memoized recursive function that traverses a `FileNode`'s children and checks against the `selectedFiles` list to calculate the selected count. Render this count conditionally in the `renderFileNodeContent` function. This is a frontend-only calculation.
-   **Minimize Panel (UXA-03):**
    -   Frontend (`view.tsx`): Add a new state, `isSelectionListMinimized`.
    -   Frontend (`SelectedFilesView.tsx`): Add a button to the header that calls a prop function to toggle this state. Conditionally render the `<ul>` based on the state.
-   **Auto-Add Files (UXA-04):**
    -   Frontend (`view.tsx`): Add a toggle button and a state for this mode. When toggled, send an IPC message to the backend to update its persisted state.
    -   Backend (`selection.service.ts`): Store the toggle's state in `workspaceState`.
    -   Backend (`fs.service.ts`): The `onDidCreate` handler in the file watcher will check this state. If true, it will get the current selection, add the new file's path, and save it back using `selection.service.ts` before triggering the UI refresh.
-   **Token Count Coloring (UXA-06):**
    -   Frontend (`SelectedFilesView.tsx`): Create a helper function `getTokenBackgroundColor(tokenCount)` that returns an HSL color string based on the specified token ranges.
    -   Apply the returned color to the `<li>` element's `style` prop.
    -   Add a `title` attribute to the `<li>` to explain the risk associated with the token count.
-   **Auto-Uncheck Folder (UXA-07):**
    -   Frontend (`FileTree.utils.ts`): The `removePathsFromSelected` function will be enhanced. After calculating the new effective selection set, it will need to perform a check. For each removed path, it can traverse up the tree to find its parent directories. For each parent, it can check if any of its other children are still in the effective selection set. If not, the parent should not be included in the final compressed path list. This is complex and requires careful state calculation.
</file>

<file path="src/Artifacts/A21. DCE - Phase 1 - Feature Drift Analysis vs. VS Code Explorer.md">
# Artifact A21: DCE - Phase 1 - Feature Drift Analysis vs. VS Code Explorer
# Date Created: C28
# Author: AI Model
# Updated on: C39 (Update Keyboard Nav status to Complete)

- **Key/Value for A0:**
- **Description:** A comparative analysis documenting the functional and behavioral differences between the DCE custom file view and the native VS Code Explorer to guide future development and feature parity.
- **Tags:** feature plan, analysis, drift, ux, vs code explorer, parity

## 1. Overview & Goal

The primary goal of the Data Curation Environment (DCE) is to enhance, not replace, the core developer workflow. To minimize friction and maximize adoption, its custom file view must achieve a high degree of feature parity with the native VS Code Explorer. This document analyzes the "drift," or the set of features present in the native Explorer that are currently missing from the DCE view. This analysis will serve as a backlog and prioritization guide for future development cycles.

## 2. Feature Comparison Matrix

| Feature Category            | Native VS Code Explorer         | DCE (as of C39)        | Status & Notes                                                                                                                                              |
| --------------------------- | ------------------------------- | ---------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **File Display**            |                                 |                        |                                                                                                                                                             |
| Hierarchical Tree           | âœ…                              | âœ…                     | **Complete.** Core functionality is present.                                                                                                                |
| File/Folder Icons           | âœ…                              | âœ…                     | **Complete.** Icons match file types.                                                                                                                       |
| Active File Highlighting    | âœ…                              | âœ…                     | **Complete.**                                                                                                                                               |
| Problems/Git Status         | âœ… (Colors, badges)             | âœ…                     | **Complete.** Displays Git status colors/badges and problem indicators.                                                                                     |
| **Selection**               |                                 |                        |                                                                                                                                                             |
| Single-Click (Files)        | âœ… Opens file                   | âœ… Opens & Selects file| **Complete.** Aligns with native behavior.                                                                                                                  |
| Single-Click (Folders)      | âœ… Expands/Collapses            | âœ… Expands/Collapses   | **Complete.** |
| Multi-Select (Ctrl)         | âœ…                              | âœ…                     | **Complete.**                                                                                                                                               |
| Multi-Select (Shift)        | âœ… (Selects rows)               | âœ… (Selects rows)      | **Complete.**                                                                                                                                               |
| Select All (Ctrl+A)         | âœ… (In focused list)            | âœ…                     | **Complete.** The focus-stealing bug is now resolved, making `Ctrl+A` in the "Selected Items" list reliable.                                           |
| **Interaction**             |                                 |                        |                                                                                                                                                             |
| Drag and Drop               | âœ… (Move files/folders)         | âœ…                     | **Complete.**                                                                                                                                               |
| Right-Click Context Menu    | âœ… (Extensive options)          | âœ… (Basic + List actions) | **Partial.** DCE has basic file ops. Added "Select All" for lists in C37. Missing advanced options like `Open in Integrated Terminal`, `Compare...`.       |
| Keyboard Navigation         | âœ… (Arrows, Enter, Space)       | âœ…                     | **Complete (C39).** Arrow keys, Enter, and Spacebar now function as expected. The focus-stealing bug has been resolved.                                   |
| Inline Rename               | âœ… (F2 or slow double-click)    | âœ…                     | **Complete.** |
| **File Operations**         |                                 |                        |                                                                                                                                                             |
| New File / Folder           | âœ…                              | âœ…                     | **Complete.** |
| Delete (to Trash)           | âœ…                              | âœ…                     | **Complete.** |
| Cut / Copy / Paste          | âœ…                              | âŒ                     | **Missing.** Standard file system operations are not yet implemented.                                                                                       |
| Undo / Redo (Ctrl+Z)        | âœ…                              | âŒ                     | **Missing.** A critical feature for parity. Requires an action stack to reverse moves/deletes. Planned in A27.                                            |
| **Search & Filter**         |                                 |                        |                                                                                                                                                             |
| Filter by Name              | âœ… (Start typing)               | âœ…                     | **Complete.**                                                                                                                                               |

## 3. High-Priority Features for Future Cycles

Based on the analysis, the following features represent the most significant gaps in user experience and should be prioritized:

1.  **Undo / Redo (Ctrl+Z):** The ability to undo a file move or deletion is a fundamental expectation for any file manager and its absence is a major point of friction.
2.  **Cut / Copy / Paste:** Adding standard clipboard operations for files is a key missing piece of basic file management.
3.  **Expanded Context Menu:** Adding more of the native right-click options, especially `Open in Integrated Terminal` and `Compare Selected`, would significantly reduce the need for users to switch back to the native Explorer.
</file>

<file path="src/Artifacts/A22. DCE - Phase 1 - Search & Filter Feature Plan.md">
# Artifact A22: DCE - Phase 1 - Search & Filter Feature Plan
# Date Created: C29
# Author: AI Model

- **Key/Value for A0:**
- **Description:** Outlines the requirements and implementation for a search bar to filter the main file tree view by file or folder name.
- **Tags:** feature plan, search, filter, tree view, ux, phase 1

## 1. Overview & Goal

To improve navigation and usability in large projects, this feature introduces a search and filter capability to the Data Curation Environment. The goal is to allow users to quickly find specific files or folders by typing a part of their name, mirroring the incremental filtering behavior of the native VS Code Explorer.

## 2. User Story

| ID | User Story | Acceptance Criteria |
|---|---|---|
| SF-01 | **Filter File Tree** | As a user working in a large repository, I want to type in a search bar to filter the file tree in real-time, so I can quickly locate the files and folders I need without extensive scrolling. | - A search icon/button is present in the main header toolbar. <br> - Clicking the icon reveals a text input field. <br> - As I type into the input field, the file tree dynamically updates to show only the files and folders whose names match the search string. <br> - All parent directories of a matching file are also shown to preserve the tree structure. <br> - The search is case-insensitive. <br> - Clearing the search input restores the full, unfiltered tree. |

## 3. Technical Implementation Plan

1.  **Frontend - UI (`view.tsx`, `view.scss`):**
    *   Add a new state variable to the main `App` component: `const [filterTerm, setFilterTerm] = useState('');`.
    *   Add a search icon (`VscSearch`) to the header toolbar. A second state, `isSearchVisible`, can be used to toggle the visibility of the input field when the icon is clicked.
    *   The search `<input>` element's `value` will be bound to `filterTerm`, and its `onChange` handler will call `setFilterTerm`.

2.  **Frontend - Filtering Logic (`FileTree.tsx`):**
    *   The `FileTree` component will receive the `filterTerm` as a new prop.
    *   A `useMemo` hook will be used to compute the filtered tree whenever the source `data` or the `filterTerm` changes.
    *   This hook will call a new recursive filtering function:
        ```typescript
        function filterTree(nodes: FileNode[], term: string): FileNode[] {
            if (!term) return nodes;
            const lowerCaseTerm = term.toLowerCase();

            return nodes.reduce((acc, node) => {
                if (node.name.toLowerCase().includes(lowerCaseTerm)) {
                    // If the node itself matches, include it and all its children
                    acc.push(node);
                    return acc;
                }

                if (node.children) {
                    // If the node is a directory, filter its children
                    const filteredChildren = filterTree(node.children, term);
                    if (filteredChildren.length > 0) {
                        // If any children match, include the parent with its filtered children
                        acc.push({ ...node, children: filteredChildren });
                    }
                }
                return acc;
            }, [] as FileNode[]);
        }
        ```
    *   The `TreeView` component will then be rendered with this new, filtered data.

3.  **State Management:**
    *   The filtering is a pure frontend operation. No backend changes or IPC communication are required for this feature.
    *   The search term is transient UI state and does not need to be persisted.
</file>

<file path="src/Artifacts/A23. DCE - Phase 1 - Advanced Interactions (Keyboard & Drag-Drop) Plan.md">
# Artifact A23: DCE - Phase 1 - Advanced Interactions (Keyboard & Drag-Drop) Plan
# Date Created: C29
# Author: AI Model
# Updated on: C71 (Add Delete key functionality)

- **Key/Value for A0:**
- **Description:** Details the requirements for implementing full keyboard navigation and drag-and-drop file/folder operations within the main file tree.
- **Tags:** feature plan, keyboard navigation, drag and drop, file operations, accessibility, ux, phase 1

## 1. Overview & Goal

To achieve true feature parity with the native VS Code Explorer and cater to power users, the Data Curation Environment must support advanced interactions. This plan outlines the requirements for two major features: full keyboard navigation for accessibility and speed, and drag-and-drop functionality for intuitive file system manipulation.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| AI-01 | **Keyboard Navigation** | As a power user, I want to navigate the file tree using only my keyboard, so I can find, select, and manage files without taking my hands off the keyboard. | - Arrow Up/Down keys move the focus between visible nodes. <br> - Arrow Right on a collapsed folder expands it. <br> - Arrow Left on an open folder collapses it. <br> - `Enter` key opens the focused file or toggles expansion. <br> - `Spacebar` toggles the checkbox of the focused node. <br> - **(Bug C68):** When a file within a checked parent folder is focused, pressing spacebar incorrectly de-selects a higher-level directory instead of just the single file. |
| AI-02 | **Internal Drag-and-Drop** | As a user, I want to be able to drag a file or folder and drop it into another folder within the DCE view to move it, so I can reorganize my project intuitively. | - Clicking and dragging a file or folder initiates a drag operation. <br> - Dragging over a folder highlights it as a potential drop target. <br> - Dropping a file/folder onto another folder moves the dragged item. <br> - **Validation:** A folder cannot be dropped into itself or one of its own descendants. |
| AI-03 | **External Drag-and-Drop** | As a user, I want to drag a file (e.g., a PDF) from my computer's file explorer or the VS Code Explorer and drop it into a folder in the DCE view to add it to my project, so I can quickly incorporate new assets. | - Dragging a file from the OS or VS Code Explorer and dropping it onto a folder in the DCE view copies that file into the target folder in the workspace. <br> - The file tree automatically refreshes to show the newly added file. |
| AI-04 | **Delete Key** | As a user, I want to press the `Delete` key on my keyboard when an item is focused in the file tree to delete it, so I can manage files quickly without using the mouse. | - Focusing an item in the main file tree and pressing `Delete` initiates the delete workflow. <br> - It uses the same backend logic as the context menu, including the confirmation dialog and moving the item to the trash. |
| AI-05 | **Copy & Paste** | As a user, I want to use `Ctrl+C` and `Ctrl+V` to copy and paste files/folders within the tree, so I can use standard keyboard shortcuts for file duplication. | - `Ctrl+C` on a focused item copies its path to an internal clipboard. <br> - `Ctrl+V` on another item pastes the copied item into that location. <br> - Handles name collisions gracefully (e.g., `file-copy.ts`). |
| AI-06 | **Hover to Expand Folder** | As a user dragging a file, when I hover over a collapsed folder for a moment, I want it to automatically expand, so I can drop the file into a nested subdirectory without having to cancel the drag operation. | - During a drag operation, hovering over a collapsed folder for ~500ms triggers its expansion. <br> - Moving the mouse away from the folder before the timer completes cancels the expansion. |

## 3. Implementation Status & Notes

### Keyboard Navigation & Internal Drag-Drop
These features are stable and complete, with the exception of the noted spacebar bug.

### External Drag and Drop (De-Prioritized as of C61)

-   **Status:** **On Hold.**
-   **Summary of Attempts:** Multiple approaches were attempted between C54 and C60 to implement file drops from outside the webview (e.g., from the OS or the native VS Code Explorer).
    1.  **Standard HTML5 API (`dataTransfer.files`):** This worked for drops from the OS but failed for drops from the VS Code Explorer, as the `files` collection is empty for security reasons.
    2.  **VS Code URI-based API (`text/uri-list`):** This approach correctly captured the URI of the file being dropped from the VS Code Explorer. The URI was passed to the backend, which then used the `vscode.workspace.fs.copy()` API.
-   **Root Cause of Failure:** Despite correctly implementing the URI-based approach, the drag-and-drop events (`onDrop`, `onDragOver`) failed to fire reliably or at all when dragging from an external source into the webview. The root cause appears to be a complex interaction with VS Code's webview security model, event propagation, and possibly the Workspace Trust feature, which could not be resolved within a reasonable number of cycles.
-   **Path Forward:** This feature is now considered a **tertiary, long-term research goal**. The core functionality of the extension is not dependent on it. For now, users can add new files using the native VS Code Explorer, the "New File..." button in the DCE toolbar, or by simply creating the file, which will then appear on refresh.
</file>

<file path="src/Artifacts/A24. DCE - Selection Paradigm Terminology.md">
# Artifact A24: DCE - Selection Paradigm Terminology
# Date Created: C29
# Author: AI Model

- **Key/Value for A0:**
- **Description:** A document to clarify the terminology used within the project to distinguish between different types of user selections (e.g., "checking" for flattening vs. "selecting" for actions).
- **Tags:** documentation, terminology, selection, checking, design

## 1. Problem Statement

During development and feedback cycles, the term "select" has been used ambiguously, leading to confusion. It has been used to describe two distinct user actions with different purposes:
1.  Clicking a checkbox to include a file/folder in the context to be flattened.
2.  Clicking a file/folder row (with optional Ctrl/Shift modifiers) to highlight it for a contextual action (e.g., Rename, Delete).

This ambiguity makes feature requests and technical discussions difficult. The goal of this document is to establish clear, consistent terminology for use in all future artifacts, code, and discussions.

## 2. Defined Terminology

Henceforth, the following terms will be used to describe user interactions with the file tree:

### **Checking / Unchecking**

*   **Action:** Clicking the `checkbox` next to a file or folder item.
*   **Purpose:** To include or exclude an item from the set of files that will be processed by the **"Flatten Context"** action.
*   **UI State:** A visible checkmark (`âœ“`), indeterminate mark (`-`), or empty state in the checkbox.
*   **State Variable (conceptual):** `checkedPaths: Set<string>`
*   **User Phrasing:** "I **checked** the `src` folder."

---

### **Selecting / Highlighting**

*   **Action:** Single-clicking a file/folder row. Using `Ctrl+Click` or `Shift+Click` to highlight multiple rows.
*   **Purpose:** To designate one or more items as the target for a contextual action, such as those in the **right-click context menu** (e.g., Rename, Delete, Copy Path). This is also used to identify the "active" item for operations like "New File".
*   **UI State:** A visual highlight on the entire row, typically matching the VS Code theme's selection color.
*   **State Variable (conceptual):** `selectedPaths: Set<string>`
*   **User Phrasing:** "I **selected** three files and then right-clicked to delete them."

---

### **Focusing**

*   **Action:** Navigating the tree with keyboard arrow keys.
*   **Purpose:** To move a visual indicator (a focus ring or subtle highlight) to an item, making it the active target for keyboard actions (`Enter` to open, `Spacebar` to check/uncheck).
*   **UI State:** A focus outline around the item row.
*   **State Variable (conceptual):** `focusedPath: string | null`
*   **User Phrasing:** "The `README.md` file is currently **focused**."

## 3. Summary Table

| Term | Action | Purpose | UI Cue | State Name |
| :--- | :--- | :--- | :--- | :--- |
| **Check** | Click checkbox | Include in Flatten Context | Checkmark | `checkedPaths` |
| **Select** | Click / Ctrl+Click / Shift+Click row | Target for Context Menu Actions | Row highlight | `selectedPaths` |
| **Focus** | Keyboard navigation | Target for Keyboard Actions | Focus ring | `focusedPath` |

By adhering to this terminology, we can ensure clarity in communication and precision in our technical implementation.
</file>

<file path="src/Artifacts/A25. DCE - Phase 1 - Git & Problems Integration Plan.md">
# Artifact A25: DCE - Phase 1 - Git & Problems Integration Plan
# Date Created: C30
# Author: AI Model
# Updated on: C33 (Refine technical plan based on debugging)

- **Key/Value for A0:**
- **Description:** Outlines the user stories and technical approach for integrating Git status indicators and VS Code Problem Diagnostics into the custom file tree.
- **Tags:** feature plan, git, problems, diagnostics, ux, phase 1

## 1. Overview & Goal

To achieve full feature parity with the native VS Code Explorer and provide critical context to the user, the Data Curation Environment (DCE) file tree must display information about a file's Git status and any associated problems (errors/warnings). The goal of this feature is to overlay this diagnostic and source control information directly onto the file tree, allowing users to make more informed decisions during context curation.

**Status (C33):** Actively debugging and refining the implementation. The core issue appears to be in the backend's data gathering from the Git API.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| GP-01 | **Git Status Coloring** | As a user, I want to see files and folders colored according to their Git status (e.g., green for new, yellow for modified, gray for ignored), so I can quickly identify changes in my workspace. | - The file/folder name text color in the tree view changes based on its Git status. <br> - Colors should align with the user's current VS Code theme for Git decorations. <br> - A new, untracked file is green. <br> - A modified file is yellow/orange. <br> - A deleted file (in some views) is red. <br> - An ignored file is gray. |
| GP-02 | **Git Status Badges** | As a user, I want to see a letter badge next to a file's name indicating its specific Git status (e.g., 'U' for untracked, 'M' for modified), so I have an unambiguous indicator of its state. | - A small, colored badge with a letter appears to the right of the file name. <br> - 'U' for Untracked. <br> - 'M' for Modified. <br> - 'D' for Deleted. <br> - 'A' for Added. <br> - 'C' for Conflicted. <br> - The badge has a tooltip explaining the status (e.g., "Modified"). |
| GP-03 | **Problem Indicator Badges** | As a user, I want to see a badge with a count of errors and warnings on files and their parent folders, so I can immediately identify parts of the codebase that have issues. | - A file with problems displays a badge with the number of errors (e.g., in red). <br> - A folder recursively aggregates the problem counts of its children and displays a summary badge. <br> - Tooltips on the badge provide a breakdown (e.g., "2 Errors, 3 Warnings"). <br> - The file name may also be colored (e.g., red for errors, yellow for warnings) to match the Problems panel. |

## 3. Technical Implementation Plan

### Phase 1: Data Gathering (Backend)

1.  **Extend `FileNode` Type:** The `FileNode` interface in `src/common/types/file-node.ts` will be extended to include optional properties:
    ```typescript
    export interface FileNode {
        // ... existing properties
        gitStatus?: string; // e.g., 'M', 'U', 'A', 'D', 'C' for Conflicted
        problemCounts?: { error: number; warning: number; };
    }
    ```

2.  **Git Status Integration (`fs.service.ts`):**
    *   **API Acquisition:** The Git extension API will be acquired in `extension.ts` and passed into the `FSService` during initialization. This ensures it's available and handles cases where the Git extension might not be ready immediately.
    *   **Centralized Status Map:** A `private getGitStatusMap()` method will be created. This method builds a `Map<string, string>` of file paths to their status character.
    *   **Critical: Path Normalization:** All file paths retrieved from the Git API (`change.uri.fsPath`) **must** be normalized to use forward slashes (`/`) immediately before being used as keys in the map. This is the root cause of many cross-platform bugs.
    *   **Comprehensive Status Check:** The map will be populated by iterating through `repository.state.workingTreeChanges`, `repository.state.indexChanges`, and `repository.state.untrackedChanges`.
    *   **Logging:** Add detailed logging to confirm the Git API was found, the number of repositories, and the number of changes detected.

3.  **Problems Integration (`fs.service.ts`):**
    *   Use the `vscode.languages.getDiagnostics()` API. This returns all diagnostics for the entire workspace.
    *   Create a `Map<string, { error: number; warning: number; }>` to store aggregated counts per file URI.
    *   Iterate through the diagnostics and populate the map based on `diagnostic.severity`.
    *   When building the `FileNode` for a file, retrieve its counts from the map and add them to the `problemCounts` property.
    *   The recursive aggregation logic for folders (`_aggregateStats`) will be updated to also sum these `problemCounts`.

### Phase 2: Rendering (Frontend)

1.  **CSS Styling (`view.scss`):**
    *   Create new CSS classes for each Git status (e.g., `.git-status-M`, `.git-status-U`).
    *   Use VS Code theme variables for the colors to ensure consistency (e.g., `var(--vscode-gitDecoration-modifiedResourceForeground)`).
    *   Create classes for problem severity colors (e.g., `.problem-error`, `.problem-warning`) and badges.

2.  **Component Logic (`FileTree.tsx`):**
    *   In `renderFileNodeContent`, add logic to conditionally apply the CSS classes to the file name and the status badge based on the `gitStatus` and `problemCounts` properties of the `FileNode`.
    *   Add a new `<span>` element to render the Git status badge. Add a `title` attribute to this span to provide a helpful tooltip.
    *   Add another `<span>` to render the problem count badge, with a `title` attribute for the tooltip breakdown.
</file>

<file path="src/Artifacts/A26. DCE - Phase 1 - File System Traversal & Caching Strategy.md">
# Artifact A26: DCE - Phase 1 - File System Traversal & Caching Strategy
# Date Created: C31
# Author: AI Model

- **Key/Value for A0:**
- **Description:** Documents the root cause of the folder visibility bug and outlines the new strategy of using recursive directory traversal instead of `findFiles` to build a complete and accurate file system map.
- **Tags:** bug fix, file system, traversal, refresh, cache, architecture

## 1. Overview & Goal

This document addresses a critical bug identified in Cycle 31 where newly created empty folders do not appear in the Data Curation file tree, even after a refresh. The goal is to document the root cause and define a new, more robust file system traversal strategy that guarantees an accurate representation of the workspace, including empty directories.

## 2. Root Cause Analysis (RCA)

-   **Symptom:** Creating a new, empty folder in the workspace does not result in that folder appearing in the DCE file tree. The file watcher correctly detects a change and triggers a full refresh, but the new folder is still missing from the rendered output.
-   **Root Cause:** The file discovery mechanism in `fs.service.ts` exclusively uses the `vscode.workspace.findFiles("**/*", ...)` API call. This API is optimized to return a flat list of **files** matching a glob pattern. It does **not** return directories, especially empty ones, as they are not considered "files".
-   **Impact:** When the file tree is reconstructed from this file-only list, any empty directories are completely invisible to the tree-building logic, making it impossible for the UI to ever display them. This is a major regression that breaks core functionality.

## 3. New Traversal Strategy

To resolve this, the reliance on `vscode.workspace.findFiles` for building the tree structure will be eliminated and replaced with a manual, recursive directory traversal.

### 3.1. Technical Implementation Plan

1.  **Primary API:** The new strategy will be centered around the `vscode.workspace.fs.readDirectory(uri)` API. This function returns an array of `[name, fileType]` tuples for all immediate children of a given directory URI. `fileType` can be `File`, `Directory`, `SymbolicLink`, or `Unknown`.

2.  **Recursive Function:** A new `private async _traverseDirectory(uri)` method will be implemented in `fs.service.ts`.
    *   **Input:** The `vscode.Uri` of the directory to scan.
    *   **Process:**
        1.  Call `vscode.workspace.fs.readDirectory(uri)` to get the contents.
        2.  Iterate through the `[name, fileType]` tuples.
        3.  Apply the exclusion logic (e.g., skip `node_modules`, `.git`).
        4.  For each entry, create a `FileNode` object.
        5.  If `fileType` is `vscode.FileType.Directory`, recursively call `_traverseDirectory` for that child and assign the result to the `children` property of its `FileNode`.
        6.  If `fileType` is `vscode.FileType.File`, calculate its stats (token count, etc.).
        7.  Return the array of `FileNode` children.

3.  **Integration (`handleWorkspaceFilesRequest`):**
    *   The main `handleWorkspaceFilesRequest` function will now initiate the process by calling `_traverseDirectory` with the workspace root URI.
    *   The result of this recursive traversal will be the complete, accurate file tree, which can then be cached and sent to the client.

## 4. Benefits of the New Approach

-   **Accuracy:** This method builds a true representation of the file system, including all directories, regardless of whether they are empty or not.
-   **Control:** It gives us full control over the traversal, allowing for more sophisticated filtering or caching logic in the future.
-   **Performance:** While potentially slower for extremely large workspaces than a highly optimized native `findFiles` call, it avoids the overhead of converting a flat path list into a tree structure, as the tree is built directly during the scan. Performance will be monitored.
</file>

<file path="src/Artifacts/A27. DCE - Phase 1 - Undo-Redo Feature Plan.md">
# Artifact A27: DCE - Phase 1 - Undo-Redo Feature Plan
# Date Created: C35
# Author: AI Model

- **Key/Value for A0:**
- **Description:** Details the requirements for implementing an undo/redo stack for file system operations (move, delete) performed within the DCE view, to achieve parity with the native explorer's Ctrl+Z functionality.
- **Tags:** feature plan, undo, redo, ctrl+z, file operations, ux, phase 1

## 1. Overview & Goal

A critical feature for achieving parity with the native VS Code Explorer is the ability to undo file system operations. Users expect to be able to press `Ctrl+Z` to revert an accidental file move or deletion. The goal of this feature is to implement a robust undo/redo stack for file operations initiated from within the Data Curation Environment view.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| UR-01 | **Undo File Move** | As a user, after I drag and drop a file to a new location, I want to be able to press `Ctrl+Z` to move it back to its original location, so I can easily correct mistakes. | - Performing a file/folder move pushes an "action" object onto an undo stack. <br> - Pressing `Ctrl+Z` while the DCE view is focused pops the last action and reverses it (moves the file back). <br> - The file tree updates to reflect the reversed move. |
| UR-02 | **Undo File Deletion** | As a user, after I delete a file or folder (to the trash), I want to be able to press `Ctrl+Z` to restore it, so I don't lose work accidentally. | - Deleting a file/folder pushes an "action" object onto the undo stack. <br> - Pressing `Ctrl+Z` reverses the deletion. Since we use `useTrash: true`, this might be handled by a native VS Code command, or we may need to implement a restore from trash mechanism if possible. |
| UR-03 | **Redo Operation** | As a user, after I undo an action, I want to be able to press `Ctrl+Y` (or `Ctrl+Shift+Z`) to redo the action, so I can toggle between states. | - Undoing an action moves it from the undo stack to a redo stack. <br> - Pressing `Ctrl+Y` pops the last action from the redo stack and re-applies it. <br> - The file tree updates accordingly. |

## 3. Technical Implementation Plan

This feature will be implemented primarily on the backend to manage the file system state and the action history.

1.  **Action Stack Service (New Backend Service):**
    *   Create a new service, `action.service.ts`, to manage the undo and redo stacks.
    *   It will contain two arrays: `undoStack: Action[]` and `redoStack: Action[]`.
    *   An `Action` will be a typed object, e.g., `{ type: 'move', payload: { from: string, to: string } }` or `{ type: 'delete', payload: { path: string } }`.
    *   It will expose methods: `push(action: Action)`, `undo()`, and `redo()`.
        *   `push`: Adds an action to `undoStack` and clears `redoStack`.
        *   `undo`: Pops from `undoStack`, performs the reverse operation, and pushes the original action to `redoStack`.
        *   `redo`: Pops from `redoStack`, performs the original operation, and pushes it back to `undoStack`.

2.  **Integrate with `fs.service.ts`:**
    *   The `handleMoveFileRequest` and `handleFileDeleteRequest` methods in `fs.service.ts` will be updated.
    *   *Before* performing the file system operation, they will create the corresponding `Action` object.
    *   *After* the operation succeeds, they will call `Services.actionService.push(action)`.

3.  **IPC Channels and Commands:**
    *   Create two new `ClientToServerChannel` entries: `RequestUndo` and `RequestRedo`.
    *   The frontend (`TreeView.tsx`) will have a top-level `onKeyDown` handler. When `Ctrl+Z` or `Ctrl+Y` is detected, it will send the appropriate IPC message to the backend.
    *   Create two new backend commands, `dce.undo` and `dce.redo`, which will be called by the message handlers. These commands will simply call `Services.actionService.undo()` and `Services.actionService.redo()`.

4.  **Reverse Operations Logic (`action.service.ts`):**
    *   The `undo()` method will contain the logic to reverse actions.
    *   **Move:** To undo a move from `A` to `B`, it calls `vscode.workspace.fs.rename(B, A)`.
    *   **Delete:** Undoing a delete is more complex. Since we use `useTrash: true`, VS Code might not expose a direct API to "un-delete". Research is needed. The simplest approach might be to leverage a built-in command like `files.restoreFromTrash` if it can be targeted, or we may need to inform the user to use the native Explorer's undo for deletions. For a first pass, we might only support undo for **move** operations.

5.  **Frontend Focus:**
    *   The main `TreeView` component needs to be focusable (`tabIndex="0"`) to capture the keyboard shortcuts. The `onKeyDown` handler will check for `event.ctrlKey` and the specific key (`z` or `y`) and then send the IPC message.
</file>

<file path="src/Artifacts/A28. DCE - Packaging and Distribution Guide.md">
# Artifact A28: DCE - Packaging and Distribution Guide
# Date Created: C43
# Author: AI Model
# Updated on: C45 (Add step to update package.json before packaging)

- **Key/Value for A0:**
- **Description:** Provides a step-by-step guide on how to package the extension into a `.vsix` file for beta testing and distribution.
- **Tags:** packaging, distribution, vsix, vsce, deployment

## 1. Overview

This document provides instructions on how to package the Data Curation Environment (DCE) extension into a single `.vsix` file. This file is the standard format for distributing and installing VS Code extensions, making it easy to share with beta testers or submit to the official marketplace.

The primary tool used for this process is `vsce` (Visual Studio Code Extensions), the official command-line tool for managing extensions.

## 2. Prerequisites

1.  **Node.js and npm:** You must have Node.js and npm installed.
2.  **Install `vsce`:** If you haven't already, install `vsce` globally by running the following command in your terminal:
    ```bash
    npm install -g @vscode/vsce
    ```

## 3. Packaging the Extension

Follow these steps in your terminal from the root directory of the DCE project (e.g., `C:\Projects\DCE`):

### Step 0: Update `package.json` (Important!)

Before packaging, ensure your `package.json` file is complete. The `vsce` tool will warn you if important fields are missing. At a minimum, make sure the following fields are present and correct:

-   `publisher`: Your publisher ID from the VS Code Marketplace.
-   `repository`: An object pointing to your source code repository (e.g., on GitHub).
-   `homepage`: A link to your project's homepage.
-   `bugs`: A link to your project's issue tracker.
-   `version`: Increment the version number for each new release.

**Example `repository` field:**
```json
"repository": {
  "type": "git",
  "url": "https://github.com/dgerabagi/data-curation-environment.git"
}
```

### Step 1: Ensure Dependencies are Installed

Make sure your project's dependencies are up to date.

```bash
npm install
```

### Step 2: Create a Production Build

Before packaging, it's essential to create an optimized production build of the extension. Our `package.json` already has a script for this.

```bash
npm run package
```

This command runs webpack in `production` mode, which minifies the code and removes source maps, resulting in a smaller and faster extension. It will update the files in the `/dist` directory.

### Step 3: Run the Packaging Command

Once the production build is complete, you can run the `vsce` packaging command.

```bash
vsce package
```

This command will:
1.  Read the `package.json` manifest file.
2.  Gather all the necessary files, respecting the rules in `.vscodeignore`.
3.  Bundle everything into a single file named `data-curation-environment-X.X.X.vsix`, where `X.X.X` is the version number from `package.json`.

You will see the `.vsix` file in the root of your project directory.

## 4. Sharing and Installing the `.vsix` File

### For Beta Testers:

1.  **Share the File:** You can send the generated `.vsix` file directly to your testers (e.g., via email, Slack, or a shared drive).

2.  **Installation Instructions:** Your testers can install it in VS Code by following these steps:
    *   Open VS Code.
    *   Go to the **Extensions** view (Ctrl+Shift+X).
    *   Click the **...** (More Actions) button at the top of the Extensions view.
    *   Select **"Install from VSIX..."**.
    *   In the file dialog that opens, navigate to and select the `.vsix` file you provided.
    *   VS Code will install the extension and prompt for a reload.

## 5. Next Steps (Future)

*   **Versioning:** Before creating a new package for distribution, remember to increment the `version` number in `package.json`.
*   **Marketplace Publishing:** Publishing to the official VS Code Marketplace involves creating a publisher identity and using `vsce publish` instead of `vsce package`.
</file>

<file path="src/Artifacts/A29. DCE - Phase 1 - Binary and Image File Handling Strategy.md">
# Artifact A29: DCE - Phase 1 - Binary and Image File Handling Strategy
# Date Created: C46
# Author: AI Model
# Updated on: C47 (Richer metadata format and JSON output)

- **Key/Value for A0:**
- **Description:** Defines the strategy for handling binary files; they can be checked, but only their metadata (path, size) is included in the flattened output, not their content.
- **Tags:** feature plan, binary, image, metadata, flatten, phase 1

## 1. Overview & Goal

During beta testing, a use case emerged for including information about binary files (like images) in the flattened context without including their raw, unreadable content. The goal of this strategy is to allow users to select *any* file, but to intelligently handle non-text files during the flattening process to prevent corrupting the output while still capturing useful metadata.

## 2. Problem Statement

-   **Initial Problem:** Flattening a folder containing images (`.png`, `.gif`) resulted in binary gibberish being written to `flattened_repo.md`.
-   **Initial Solution (C43):** Prevent selection of binary files by disabling their checkboxes.
-   **Refined Requirement (C46):** The user realized they *do* want to capture the existence and properties of these files (e.g., path, size) as part of the context, just not their content.
-   **Refined Requirement (C47):** The metadata should be richer, including name, directory, dimensions, and file type, and be presented in a structured format.

## 3. The New Strategy

The extension will now adopt a "metadata-only" approach for a predefined list of binary and image file types.

### 3.1. User Experience

1.  **Selection is Always Allowed:** All files in the file tree, regardless of type, will have an enabled checkbox. The user is free to check any file or folder.
2.  **File Opening:** Clicking on any file in the tree view will open it using VS Code's default viewer for that file type (e.g., text editor for `.ts`, image preview for `.png`).
3.  **Flattening Behavior is Differentiated:**
    *   When a **text file** is checked and the "Flatten Context" button is pressed, its full content is read and included in `flattened_repo.md`.
    *   When a **binary or image file** is checked, its content is **not** read. Instead, the flattener service will gather its metadata and include a structured, human-readable entry for it in `flattened_repo.md`.

### 3.2. Output Format for Binary Files

When a binary file is included, its entry in the `<files content>` section of `flattened_repo.md` will contain a `<metadata>` tag with a JSON object. Dimensions will be included on a best-effort basis for common formats (PNG, JPG, GIF).

**Example (with dimensions):**
```xml
<file path="public/images/logo.png">
<metadata>
{
  "name": "logo.png",
  "directory": "public/images",
  "fileType": "PNG",
  "sizeInBytes": 12345,
  "dimensions": {
    "width": 256,
    "height": 256
  }
}
</metadata>
</file>
```

**Example (without dimensions):**
```xml
<file path="assets/archive.zip">
<metadata>
{
  "name": "archive.zip",
  "directory": "assets",
  "fileType": "ZIP",
  "sizeInBytes": 102400
}
</metadata>
</file>
```

## 4. Technical Implementation Plan

1.  **File Opening (`fs.service.ts`):**
    *   The `handleOpenFileRequest` method will be updated to use `vscode.commands.executeCommand('vscode.open', uri)`. This delegates opening to VS Code, which correctly selects the appropriate viewer for any file type.

2.  **Backend Flattener Logic (`flattener.service.ts`):**
    *   A constant set of binary/image extensions will be defined.
    *   A new private method, `_parseImageMetadata`, will be added. It will read a file's buffer and attempt to parse dimensions for PNG, JPG, and GIF files, adapting logic from `flattenv2.js`.
    *   The `getFileStatsAndContent` method will be updated. When it encounters a binary file, it will:
        *   Call `_parseImageMetadata`.
        *   Collect the name, directory, type, size, and (if available) dimensions.
        *   Construct the formatted JSON string.
        *   Return a `FileStats` object where `content` is this JSON string, and `tokens` is 0.
</file>

<file path="src/Artifacts/A3. DCE - Technical Scaffolding Plan.md">
# Artifact A3: DCE - Technical Scaffolding Plan
# Date Created: Cycle 1
# Author: AI Model
# Updated on: Cycle 2 (Adopted architecture from `The-Creator-AI-main` repository)

## 1. Overview

This document outlines the technical scaffolding and file structure for the Data Curation Environment (DCE) VS Code extension.

**Major Update (Cycle 2):** The initial plan for a simple file structure has been superseded. We are officially adopting the mature and robust architecture of the `The-Creator-AI-main` reference repository as our project's blueprint. This provides a proven, scalable foundation for all three project phases.

## 2. Adopted File Structure

The project will adhere to the following directory structure, derived directly from the reference repository:

```
.
â”œâ”€â”€ public/                     # Static assets for webviews (icons, css)
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ backend/                # Extension Host code (Node.js environment)
â”‚   â”‚   â”œâ”€â”€ commands/           # Command definitions and registration
â”‚   â”‚   â”œâ”€â”€ repositories/       # Data persistence logic (workspace state)
â”‚   â”‚   â”œâ”€â”€ services/           # Core backend services (LLM, FS, Git, etc.)
â”‚   â”‚   â”œâ”€â”€ types/              # TypeScript types for the backend
â”‚   â”‚   â””â”€â”€ utils/              # Utility functions for the backend
â”‚   â”‚
â”‚   â”œâ”€â”€ client/                 # Webview code (Browser environment)
â”‚   â”‚   â”œâ”€â”€ components/         # Generic, reusable React components (FileTree, Modal)
â”‚   â”‚   â”œâ”€â”€ modules/            # Feature-specific modules (Context, Plan)
â”‚   â”‚   â”œâ”€â”€ store/              # Global state management for webviews (RxJS)
â”‚   â”‚   â””â”€â”€ views/              # Entry points for each webview panel
â”‚   â”‚
â”‚   â”œâ”€â”€ common/                 # Code shared between backend and client
â”‚   â”‚   â”œâ”€â”€ constants/
â”‚   â”‚   â”œâ”€â”€ ipc/                # IPC channel definitions and managers
â”‚   â”‚   â”œâ”€â”€ types/              # Shared TypeScript types (FileNode)
â”‚   â”‚   â””â”€â”€ utils/              # Shared utility functions (parse-json)
â”‚   â”‚
â”‚   â””â”€â”€ extension.ts            # Main entry point for the VS Code extension
â”‚
â”œâ”€â”€ package.json                # Extension manifest, dependencies, and scripts
â”œâ”€â”€ tsconfig.json               # TypeScript configuration
â”œâ”€â”€ webpack.config.js           # Webpack configuration for bundling client/server code
â””â”€â”€ ... (config files like .eslintrc.json, .gitignore)
```

## 3. Key Architectural Concepts

-   **Separation of Concerns:** The structure strictly separates backend (Node.js) logic from frontend (React/webview) logic.
-   **Shared Code:** The `src/common/` directory is critical for sharing types and IPC definitions, ensuring type safety and consistency between the extension host and the webview.
-   **Service-Oriented Backend:** The `src/backend/services/` directory promotes modularity. Each service has a single responsibility (e.g., `FSService` for file operations, `LlmService` for AI interaction), making the system easier to maintain and test.
-   **Dependency Injection:** The `Services.ts` class acts as a simple injector, managing the instantiation and provision of backend services.
-   **Modular Frontend:** The `src/client/modules/` directory allows for building complex UIs by composing smaller, feature-focused modules.
-   **Component-Based UI:** The `src/client/components/` directory holds the fundamental building blocks of the UI, promoting reusability.
-   **Typed IPC Communication:** The use of `channels.enum.ts` and `channels.type.ts` in `src/common/ipc/` provides a strongly-typed and well-documented contract for communication between the webview and the extension host, reducing runtime errors.
</file>

<file path="src/Artifacts/A30. DCE - Phase 1 - PDF Handling and Virtualization Strategy.md">
# Artifact A30: DCE - Phase 1 - PDF Handling and Virtualization Strategy
# Date Created: C49
# Author: AI Model

- **Key/Value for A0:**
- **Description:** Defines the strategy for handling PDF files. Text is extracted on-demand and cached in memory for flattening, creating a "virtual" markdown file without modifying the user's workspace.
- **Tags:** feature plan, pdf, text extraction, virtualization, cache, phase 1

## 1. Overview & Goal

Users need to include the textual content of PDF documents in their flattened context. However, creating physical `.md` files for each PDF in the user's workspace is undesirable as it clutters their project. The goal of this strategy is to implement a "virtual file" system for PDFs. The extension will extract text from PDF files on demand and hold it in an in-memory cache, using this virtual content during the flattening process without ever writing new files to the user's disk.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| PDF-01 | **Include PDF Text in Context** | As a user, when I check a `.pdf` file in the DCE view, I want its textual content to be included in the `flattened_repo.md` file, so I can use documents and papers as context. | - Checking a `.pdf` file is allowed. <br> - The token count displayed for the PDF reflects its extracted text content, not its binary size. <br> - When flattened, the text from the PDF is included within a `<file>` tag, just like a normal text file. <br> - No `.md` file is ever created in the user's workspace. |
| PDF-02 | **Drag-Drop PDF to Add** | As a user, I want to drag a PDF from my computer's file explorer and drop it into the DCE view, so I can quickly add it to my project and include it in my context. | - Dropping a PDF file into a folder in the DCE view copies the PDF into that workspace directory. <br> - The new PDF immediately appears in the file tree. <br> - The user can then check it to include its text content for flattening. |

## 3. Technical Implementation Plan

1.  **Dependency:**
    *   The `pdf-parse` library will be added as a dependency to `package.json` to handle text extraction from PDF buffers.

2.  **Backend (`fs.service.ts`):**
    *   **In-Memory Cache:** A new private cache will be added: `private pdfTextCache = new Map<string, { text: string; tokenCount: number }>();`. This will store the extracted text and calculated token count, keyed by the PDF's absolute path.
    *   **New IPC Handler (`RequestPdfToText`):**
        *   This handler will receive a file path for a PDF.
        *   It will first check the `pdfTextCache`. If the content is present, it will return the cached data.
        *   If not cached, it will read the PDF file into a buffer, use `pdf-parse` to extract the text, calculate the token count, store the result in the cache, and then return it.
        *   It will send a `UpdateNodeStats` message back to the client with the new token count.

3.  **Frontend (`view.tsx`):**
    *   **On-Demand Extraction:** The `updateCheckedFiles` function will be modified. When a path that ends in `.pdf` is being checked for the first time, it will send a `RequestPdfToText` message to the backend.
    *   **Dynamic Stats Update:** A new IPC listener for `UpdateNodeStats` will be added. When it receives a message, it will find the corresponding `FileNode` in the `files` state and update its `tokenCount` property, causing the UI to re-render with the correct information.

4.  **Backend (`flattener.service.ts`):**
    *   **Virtual Content Retrieval:** The `getFileStatsAndContent` method will be updated.
    *   If it encounters a file path ending in `.pdf`, it will **not** attempt to read the file from the disk.
    *   Instead, it will call a new method on the `FSService` (e.g., `getVirtualPdfContent(filePath)`) to retrieve the text from the `pdfTextCache`.
    *   It will then use this cached text to generate the `FileStats` object, effectively treating the PDF as if it were a markdown file. If the content is not in the cache (e.g., the file was never checked), it will be flattened with empty content.

5.  **External Drag-and-Drop:**
    *   This will be handled by the generic "External Drag-and-Drop" feature planned in `A23`. The implementation will read the file buffer and send it to the backend for creation, which works for PDFs just as it does for any other file type.
</file>

<file path="src/Artifacts/A31. DCE - Phase 2 - Multimodal Content Extraction (PDF Images).md">
# Artifact A31: DCE - Phase 2 - Multimodal Content Extraction (PDF Images)
# Date Created: C49
# Author: AI Model

- **Key/Value for A0:**
- **Description:** A plan for a future feature to extract images from PDF files and use a multimodal LLM to generate rich, textual descriptions for inclusion in the context.
- **Tags:** feature plan, multimodal, image to text, pdf, llm, phase 2

## 1. Overview & Goal

Building on the PDF text extraction in Phase 1, this plan outlines a powerful Phase 2 enhancement: making the visual information within PDFs accessible to language models. Many technical papers, reports, and documents rely on diagrams, charts, and images to convey critical information. The goal of this feature is to extract these images from a PDF and use a multimodal vision-language model (VLM) to generate rich, textual descriptions. These descriptions can then be included in the flattened context, allowing an LLM to "understand" the visual elements of the document.

## 2. User Story

| ID | User Story | Acceptance Criteria |
|---|---|---|
| MM-01 | **Understand PDF Images** | As a data curator, when I include a PDF containing charts and diagrams in my context, I want the extension to generate textual descriptions of those images, so the LLM I'm prompting can reason about the visual data. | - When a PDF is processed, the extension identifies and extracts embedded images. <br> - For each extracted image, the extension sends it to a configured multimodal LLM API (e.g., Gemini). <br> - The LLM API returns a detailed textual description of the image's content. <br> - These descriptions are inserted into the virtual markdown content of the PDF at the appropriate locations (e.g., `[Image: A bar chart showing user growth from 2022 to 2024...]`). <br> - This feature can be enabled/disabled in the extension's settings to manage API costs. |

## 3. Technical Implementation Plan (High-Level)

This is a complex feature that will require new services and dependencies, likely as part of the project's Phase 2.

1.  **PDF Image Extraction Library:**
    *   **Research:** The first step is to research and select a robust Node.js library capable of extracting raw image data (e.g., as buffers) from a PDF file. `pdf-lib` or native command-line tools like `pdfimages` (wrapped in a Node.js process) are potential candidates.
    *   **Implementation:** A new method in `fs.service.ts`, `_extractImagesFromPdf(buffer)`, will be created to handle this process.

2.  **New Service: `ImageDescriptionService`:**
    *   A new backend service, `ImageDescriptionService`, will be created.
    *   This service will be responsible for communicating with a multimodal LLM provider (e.g., Google's Gemini API).
    *   It will have a method like `describeImage(imageBuffer: Buffer): Promise<string>`.
    *   This method will handle the API request, sending the image data and receiving the text description.
    *   It will require API key management, likely extending the existing settings infrastructure.

3.  **Integration with PDF Processing:**
    *   The `RequestPdfToText` handler in `fs.service.ts` will be significantly enhanced.
    *   After parsing the text with `pdf-parse`, it would ideally also call the new image extraction method.
    *   It would then iterate through the extracted images, call the `ImageDescriptionService` for each, and intelligently weave the resulting descriptions back into the main text content to create a comprehensive markdown representation of the entire PDF.
    *   This process would be computationally expensive and time-consuming, requiring clear user feedback (e.g., progress indicators) in the UI.

4.  **Configuration:**
    *   New settings will be added to `package.json` and managed via a settings service to allow the user to:
        *   Enable/disable this feature.
        *   Configure their multimodal API provider and key.
        *   Potentially set a budget or limit on the number of images to process per document.
</file>

<file path="src/Artifacts/A32. DCE - Phase 1 - Excel and CSV Handling Strategy.md">
# Artifact A32: DCE - Phase 1 - Excel and CSV Handling Strategy
# Date Created: C62
# Author: AI Model
# Updated on: C67 (Revert to xlsx and custom Markdown converter for stability)

- **Key/Value for A0:**
- **Description:** Defines the strategy for handling tabular data files (.xlsx, .xls, .csv) by converting them to Markdown tables on-demand and caching them in memory for flattening.
- **Tags:** feature plan, excel, csv, text extraction, virtualization, cache, phase 1

## 1. Overview & Goal

Following the successful implementation of PDF virtualization, users now require a similar capability for tabular data files, specifically Microsoft Excel (`.xlsx`, `.xls`) and Comma-Separated Values (`.csv`). The goal is to extract the content from these files and represent it as clean, readable Markdown tables within the flattened context. This will be achieved using the same on-demand, in-memory caching strategy to avoid creating temporary files in the user's workspace.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| XLS-01 | **Include Tabular Data in Context** | As a user, when I check an Excel or CSV file, I want its data to be converted to Markdown tables and included in the `flattened_repo.md`, so I can use structured data as context for the LLM. | - Checking `.xlsx`, `.xls`, and `.csv` files is allowed. <br> - The token count displayed for the file reflects its Markdown table content. <br> - When flattened, the content is included within a `<file>` tag. <br> - For Excel files with multiple sheets, each sheet is converted to a separate named Markdown table. <br> - No temporary `.md` files are created in the user's workspace. |

## 3. Technical Implementation Plan (C67 Update)

1.  **Dependency:**
    *   After encountering critical parsing bugs and format limitations with `exceljs`, the project has reverted to using the more robust **`xlsx` (SheetJS)** library. This will be the sole dependency for parsing tabular data.
    *   **Vulnerability Note:** The `xlsx` package has a known high-severity vulnerability. While a direct fix from the library maintainers is not yet available, our implementation mitigates risk by using it only for its core data parsing and implementing our own logic for converting that data to Markdown, rather than using the library's more complex and less-audited utility functions.

2.  **Backend (`fs.service.ts`):**
    *   **In-Memory Cache:** A private cache will be maintained: `private excelMarkdownCache = new Map<string, { markdown: string; tokenCount: number }>();`.
    *   **IPC Handler (`RequestExcelToText`):**
        *   This handler will receive a file path. It will first check the cache.
        *   If not cached, it will read the file buffer.
        *   It will use `XLSX.read(buffer)` to parse the file into a workbook object. This works for `.xlsx`, `.xls`, and `.csv`.
        *   It will iterate through each sheet name in the `workbook.SheetNames`.
        *   For each sheet, it will call a **custom private helper method, `_sheetToMarkdown`**.
    *   **Custom Markdown Converter (`_sheetToMarkdown`):**
        *   This new function will take a worksheet object from `xlsx` as input.
        *   It will use `XLSX.utils.sheet_to_json(worksheet, { header: 1 })` to get an array-of-arrays representation of the sheet.
        *   It will then manually iterate over these arrays to construct a Markdown table string, creating the header row (`| Col1 | Col2 |`), the separator line (`|---|---|`), and all data rows.
        *   This custom implementation provides stability and avoids potential bundling issues with the library's own `sheet_to_markdown` utility.
        *   The final Markdown string (including headers for each sheet) will be concatenated, its token count calculated, and the result stored in the cache.
        *   It will then send an `UpdateNodeStats` message back to the client with the new token count.

3.  **Frontend & Flattener Integration:**
    *   The frontend (`view.tsx`) will continue to trigger the `RequestExcelToText` message on-demand.
    *   The backend (`flattener.service.ts`) will continue to retrieve the virtual Markdown content from the `FSService`'s cache. No changes are needed in these files.
</file>

<file path="src/Artifacts/A33. DCE - Phase 1 - Copy-Paste Feature Plan.md">
# Artifact A33: DCE - Phase 1 - Copy-Paste Feature Plan
# Date Created: C68
# Author: AI Model

- **Key/Value for A0:**
- **Description:** Details the requirements for implementing copy-paste functionality (Ctrl+C, Ctrl+V) for files and folders within the DCE view, including handling name collisions.
- **Tags:** feature plan, copy, paste, file operations, ux, phase 1

## 1. Overview & Goal

To achieve greater feature parity with the native VS Code Explorer and improve workflow efficiency, this plan outlines the implementation of standard copy-paste functionality for files and folders. Users expect to be able to use `Ctrl+C` and `Ctrl+V` to duplicate items within the file tree. The goal is to provide this intuitive and essential file management feature, complete with robust handling of name collisions to prevent accidental file overwrites.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| CP-01 | **Copy and Paste File/Folder** | As a user, I want to select a file or folder, press `Ctrl+C`, then select a destination folder and press `Ctrl+V` to create a duplicate, so I can quickly copy assets or boilerplate code within my project. | - `Ctrl+C` on a focused file/folder in the DCE view copies its path to an internal clipboard. <br> - `Ctrl+V` pastes the copied item into the currently focused folder. <br> - If a file is focused, the paste occurs in its parent directory. <br> - Pasting a folder also copies its entire contents recursively. |
| CP-02 | **Handle Name Collisions** | As a user, when I paste a file named `file.txt` into a folder that already contains a `file.txt`, I expect the new file to be automatically renamed to `file-copy.txt` (or similar), so I don't accidentally overwrite my work. | - If a file with the same name exists at the destination, the pasted file is renamed. <br> - The renaming scheme is `[original]-copy.[ext]`. <br> - If `[original]-copy.[ext]` also exists, the scheme becomes `[original]-copy-2.[ext]`, `[original]-copy-3.[ext]`, and so on, until a unique name is found. <br> - This applies to both files and folders. |

## 3. Technical Implementation Plan

1.  **IPC Channels (`channels.enum.ts`, `channels.type.ts`):**
    *   Create a new `ClientToServerChannel.RequestCopyFile` channel.
    *   The payload will be `{ sourcePath: string; destinationDir: string; }`.

2.  **Frontend State & Logic (`view.tsx`, `TreeView.tsx`):**
    *   **Clipboard State (`view.tsx`):** Add a new state variable to the main `App` component to act as the internal clipboard: `const [clipboard, setClipboard] = useState<{ path: string; type: 'copy' } | null>(null);`.
    *   **Keyboard Event Handler (`TreeView.tsx`):** Update the `handleKeyDown` function.
        *   It will now listen for `e.key === 'c'` and `e.key === 'v'` when `e.ctrlKey` (or `e.metaKey`) is true.
        *   **On `Ctrl+C`:** It will call a prop function (`onCopy`) passed down from `view.tsx`, which will update the `clipboard` state with the `focusedNodePath`.
        *   **On `Ctrl+V`:** It will check if the `clipboard` state is populated. If so, it will determine the destination directory from the `focusedNodePath` (if the focused node is a folder, use its path; if it's a file, use its parent's path). It will then send the `RequestCopyFile` message to the backend.

3.  **Backend File Operation (`fs.service.ts`):**
    *   **New Handler:** Create a new `async handleCopyFileRequest({ sourcePath, destinationDir })` method.
    *   **Name Collision Logic:**
        *   This handler will contain a private helper function, `private async _findAvailableCopyName(destinationPath: string): Promise<string>`.
        *   This helper will parse the `destinationPath` into its directory, base name, and extension.
        *   It will check if the original path exists using `vscode.workspace.fs.stat`.
        *   If it exists, it will enter a loop, checking for `...-copy.[ext]`, then `...-copy-2.[ext]`, `...-copy-3.[ext]`, etc., until `fs.stat` throws an `ENOENT` error, indicating a free name.
        *   It will return the first available unique path.
    *   **File Copy:** The main handler will call `_findAvailableCopyName` to get the final target path and then use `vscode.workspace.fs.copy(sourceUri, targetUri)` to perform the recursive copy.
    *   The existing file system watcher will automatically detect the new file/folder and trigger a UI refresh.
</file>

<file path="src/Artifacts/A34. DCE - Phase 2 - Parallel Co-Pilot Panel - Vision & Requirements.md">
# Artifact A34: DCE - Phase 2 - Parallel Co-Pilot Panel - Vision & Requirements
# Date Created: C69
# Author: AI Model
# Updated on: C91 (Add global parse toggle and Associated Files list)

- **Key/Value for A0:**
- **Description:** Outlines the high-level vision and user stories for the Phase 2 multi-tabbed editor panel, designed for comparing and managing multiple AI-generated responses. Includes plans for response annotation and a "Cycles Context" field.
- **Tags:** feature plan, phase 2, co-pilot, multi-tab, ui, ux, requirements, annotation, persistence, diff, parsing

## 1. Vision & Goal

Phase 2 of the Data Curation Environment aims to solve the "single-threaded" nature of interacting with AI assistants. The current workflow for developers often involves sending the same prompt to multiple models or conversations, copying the results to separate text files, and then manually integrating them into their project to test. This is inefficient and cumbersome.

The goal of the **Parallel Co-Pilot Panel** is to create an integrated, **persistent** environment within VS Code specifically for managing, comparing, diffing, and testing multiple AI-generated code responses.

**Core Workflow (C91 Update):** The primary interaction model is now **parse-centric** and **globally controlled**. The user pastes raw AI responses into simple text areas in each tab. A single, global "Parse All" button then processes the raw text in all tabs simultaneously, transforming their UIs into a structured, read-only view. This view separates the AI's plan from its code artifacts and includes a new "Associated Files" list for at-a-glance validation.

## 2. Core Concepts

1.  **Dedicated View Container:** The panel has its own icon in the Activity Bar, providing a distinct, full-height space for its UI.
2.  **Stateful & Persistent:** The content of all tabs, context fields, and the current cycle number are automatically saved. The state persists across sessions and when moving the panel to a new window.
3.  **Global Parse-on-Demand:** A single "Parse All Responses" button in the main header controls the view mode for all tabs.
4.  **Structured, Readable View:** After parsing, each tab's `textarea` is replaced by a static, read-only view that:
    *   Renders the AI's summary and plan as **formatted Markdown**.
    *   Uses **collapsible sections** for the main UI areas (Cycle Info, Summary, etc.) to manage screen real estate.
    *   Displays an **"Associated Files" list** with indicators (`âœ“`/`âœ—`) showing if the files exist in the workspace.
    *   Displays individual, **syntax-highlighted** code blocks for each file.
5.  **Live Testing via "Swap":** The core innovation is a "swap" feature. The user can, with a single click, exchange the content of a parsed file block with its corresponding source file in the workspace.
6.  **Integrated Diffing:** Users can click on a file in the "Associated Files" list to see an immediate diff view comparing the AI's suggestion against the current workspace file.
7.  **Cycle Navigator:** A UI to navigate back and forth through the history of development cycles, loading the corresponding AI responses for each cycle.
8.  **Metadata Display:** Each response tab will display key metadata, such as token counts and similarity scores, to help the user quickly evaluate the AI's output.

## 3. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| P2-US-01 | **Manage Multiple Responses** | As a developer, I want a dedicated panel with multiple tabs where I can place different AI-generated code responses, so I can keep them organized. | - A new icon in the Activity Bar opens the Parallel Co-Pilot panel. <br> - The panel contains a slider or input to select the number of visible tabs. <br> - Each tab initially contains a large text input area. |
| P2-US-02 | **Parse All Responses** | As a developer, after pasting responses into multiple tabs, I want to click a single button to parse all of them into a structured view, so I can easily review them without repetitive clicking. | - A global "Parse All Responses" button exists in the panel's header. <br> - Clicking it processes the raw text in every tab. <br> - Each tab's UI transforms to show distinct sections for summary, action plan, and file blocks. <br> - A corresponding "Un-Parse All" button reverts all tabs to their raw text view. |
| P2-US-03 | **View Formatted Text** | As a developer, I want the AI's summary and plan to be rendered as formatted Markdown, so I can easily read lists, bolded text, and other formatting. | - The summary and course of action sections correctly render Markdown syntax. |
| P2-US-04 | **Manage UI Space** | As a developer, I want to be able to collapse the main sections of the UI, so I can focus on the code blocks without excessive scrolling. | - The Cycle Info, Summary, Course of Action, and Associated Files sections have collapsible headers. |
| P2-US-05 | **Verify Response Validity** | As a developer, I want to see a list of all files an AI response intends to modify, with a clear indicator of whether those files exist in my project, so I can immediately spot hallucinations or new file suggestions. | - After parsing, a list of "Associated Files" is displayed. <br> - A checkmark (`âœ“`) appears next to files that exist in the workspace. <br> - An 'x' (`âœ—`) appears next to files that do not exist. |
| P2-US-06 | **Persistent State** | As a developer, I want all the text I've entered into the panel to be saved automatically, so I don't lose my work if I close the panel, move it, or restart VS Code. | - All raw text content is saved to a history file (`.vscode/dce_history.json`). <br> - When the panel is reopened, it loads the state from the most recent cycle. |
| P2-US-07 | **Review Changes with Diff** | As a developer, I want to click on any file in the "Associated Files" list to see a diff, so I can review the exact changes before testing. | - Clicking a file path in the list opens a diff view comparing the workspace version with the AI's version. |
| P2-US-08 | **Navigate Cycle History** | As a developer, I want to navigate backward and forward through my project's development cycles, so I can review past AI suggestions. | - UI controls exist to move between cycles. <br> - Navigating to a past cycle loads its saved raw responses into the panel. |
</file>

<file path="src/Artifacts/A35. DCE - Phase 2 - UI Mockups and Flow.md">
# Artifact A35: DCE - Phase 2 - UI Mockups and Flow
# Date Created: C69
# Author: AI Model
# Updated on: C112 (Reorder left pane, add token/similarity metrics)

## 1. Overview

This document describes the user interface (UI) and interaction flow for the Parallel Co-Pilot Panel. The design is centered around a two-stage workflow: **Input**, followed by a global **Parse** that transforms the entire panel into a **Review & Act** mode.

## 2. UI Mockup (Textual Description)

### 2.1. Main Header

The main header is a single row containing all primary actions.

```
+-------------------------------------------------------------------------------------------------+
| [Parallel Co-Pilot] [ Gen prompt.md ] [ Parse All ] [ Settings ]   [ Number of Responses: [ 4 ] ] |
|-------------------------------------------------------------------------------------------------|```

### 2.2. Cycle & Context Section

This section has two states: expanded (default) and collapsed.

**Expanded State:**
```
| [v] Cycle & Context                                                                 |
| |-----------------------------------------------------------------------------------|
| | Cycle: [ < ] [ C98 ] [ > ] [ + ] [ Cycle Title Input: ... ]                        |
| |-----------------------------------------------------------------------------------|
| | [Cycle Context (Permanent notes)]          [Ephemeral Context (Temp logs)]        |
| | +----------------------------------------+ +------------------------------------+ |
| | | Multi-line text area...                | | Multi-line text area...            | |
| | +----------------------------------------+ +------------------------------------+ |
```

**Collapsed State:**
```
| [>] Cycle & Context         [ < ] [ C98 ] [ > ]                                     |
```

### 2.3. Parsed View

The parsed view uses a **resizable two-pane layout**. The left pane provides summary information and navigation, while the right pane displays the detailed code content.

```
|-------------------------------------------------------------------------------------------------|
| [ Response 1 (active) ] [ Response 2 ] [ ... ]                                                |
|-------------------------------------------------------------------------------------------------|
| [ Left Pane ]<--->[ Right Pane (Code Viewer) ]                                                 |
| |-------------||------------------------------------------------------------------------------| |
| | [v] ASSOCIATED FILES (Clickable)  | | [ File: src/.../view.tsx ] [ Original: 4.1K | New: 4.2K | Sim: 98% ] | |
| | |-------------------------------| | +------------------------------------------------------------------+ | |
| | | [âœ“] src/.../view.tsx (selected)| | | [ Read-only editor with line numbers and syntax highlighting ] | | |
| | | [âœ—] src/.../new-file.ts       | | |                                                                  | | |
| |                                   | | +------------------------------------------------------------------+ | |
| | [v] THOUGHTS / RESPONSE           | |                                                                    | |
| | | Rendered Markdown...            | |                                                                    | |
| |                                   | |                                                                    | |
| | [v] COURSE OF ACTION              | |                                                                    | |
| | | Rendered Markdown...            | |                                                                    | |
+-------------------------------------------------------------------------------------------------+
```
*   **Resizable Divider (`<--->`):** The user can click and drag the divider to resize the left and right panes.
*   **Reordered Left Pane (C112):** The "Associated Files" list is now the first item in the left pane for better information hierarchy.
*   **Token/Similarity Metrics (C112):** The right pane's header now displays the token counts for the original and new file versions, along with a similarity score.

## 3. User Interaction Flow

1.  **Load & Parse:** User loads the panel and clicks "Parse All". The UI transforms into the two-pane layout.
2.  **Select File:** The user clicks on a file in the "Associated Files" list (left pane).
3.  **Display Content:** The **right pane** updates. Its header shows the file path and placeholder metrics. The code viewer displays the syntax-highlighted content of the newly selected file.
</file>

<file path="src/Artifacts/A36. DCE - Phase 2 - Technical Implementation Plan.md">
# Artifact A36: DCE - Phase 2 - Technical Implementation Plan
# Date Created: C69
# Author: AI Model
# Updated on: C96 (Add persistent parse mode and robust new cycle logic)

- **Key/Value for A0:**
- **Description:** Details the technical approach for building the Parallel Co-Pilot Panel, including the new webview provider, state management, IPC channels, and backend logic for file content swapping.
- **Tags:** feature plan, phase 2, technical plan, architecture, webview, ipc, parsing, markdown, diff

## 1. Overview

This document outlines the technical implementation strategy for the Parallel Co-Pilot Panel. The plan is updated to reflect a two-pane UI for diffing, a smarter parser, more resilient backend path resolution, and several UI/UX fixes from Cycle 96.

## 2. Core Components

### 2.1. Frontend State Management (`view.tsx`)

The component state will be expanded to manage the new UI features.

```typescript
// State within the view.tsx component
interface PcppState {
  // ... existing state
  tabCount: number; // New: To control the number of response tabs
  isParsedMode: boolean;
  fileExistenceMap: Map<string, boolean>;
  diffTarget: ParsedFile | null;
  originalFileContent: string | null;
  // New: Separate state for each collapsible section
  isCycleCollapsed: boolean;
  isSummaryCollapsed: boolean;
  isCourseOfActionCollapsed: boolean;
  isAssociatedFilesCollapsed: boolean;
}
```
*   **`tabCount`**: A new state to control the number of tabs rendered.
*   **Collapsible States**: New booleans to manage the UI state for each collapsible section independently.

### 2.2. Persistent "Parsed Mode"

*   **Goal:** The `isParsedMode` state should be "sticky." If the user is in parsed mode and navigates to another cycle, the new cycle's content should be automatically parsed and displayed.
*   **Implementation:**
    1.  **Backend (`history.service.ts`):** The `PcppCycle` interface will be updated to include `isParsedMode: boolean`.
    2.  **Frontend (`view.tsx`):**
        *   The `saveCurrentCycleState` function will be updated to include the current `isParsedMode` in the data sent to the backend.
        *   When loading a cycle (either the latest or via navigation), the `isParsedMode` state will be restored from the loaded `cycleData`.
        *   A `useEffect` hook will listen for changes to the loaded cycle data. If `isParsedMode` is true after the data loads, it will automatically trigger the parsing logic for all tabs.

### 2.3. Robust "New Cycle" Button Logic

*   **Goal:** The `[ + ]` (New Cycle) button must be disabled if no meaningful content has been added to the current cycle.
*   **Implementation (`view.tsx`):** The `disabled` property of the button will be controlled by a memoized boolean:
    ```typescript
    const isNewCycleButtonDisabled = useMemo(() => {
        const hasTitle = cycleTitle && cycleTitle !== 'New Cycle';
        const hasContext = cycleContext || ephemeralContext;
        const hasResponseContent = Object.values(tabs).some(tab => tab.rawContent.trim());
        return !hasTitle && !hasContext && !hasResponseContent;
    }, [cycleTitle, cycleContext, ephemeralContext, tabs]);
    ```

### 2.4. Backend File Existence & Content (`fs.service.ts`)

*   **Status:** No changes required for this cycle. The existing plan for smarter path resolution and content fetching remains valid.

### 2.5. IPC Channel Updates

*   **Status:** No new channels required for this cycle.

### 2.6. Frontend UI Flow for Diffing (`view.tsx`)

*   **Goal:** Fix the non-functional diff view.
*   **Implementation:**
    1.  Add detailed `logger.log()` statements to the `handleSelectForDiff` function to confirm it is being called on click.
    2.  Log the `file.path` being sent over `RequestFileContent`.
    3.  Add logging to the `onmessage` handler for `SendFileContent` to confirm a response is received from the backend.
    4.  Log the state variables (`diffTarget`, `originalFileContent`) just before the component's `return` statement to verify they are being set correctly. This will isolate the point of failure.
</file>

<file path="src/Artifacts/A37. DCE - Phase 2 - Cycle Navigator & Knowledge Graph - Vision.md">
# Artifact A37: DCE - Phase 2 - Cycle Navigator & Knowledge Graph - Vision
# Date Created: C70
# Author: AI Model

- **Key/Value for A0:**
- **Description:** Outlines the vision for a cycle-based navigation system to browse the history of AI-generated responses and project states, creating a navigable knowledge graph.
- **Tags:** feature plan, phase 2, knowledge graph, history, cycle navigator, ui, ux

## 1. Vision & Goal

As the Data Curation Environment matures, the interaction history with the AI becomes a valuable asset in itself. Currently, this history is ephemeral, existing only within the context of a single session. The vision for the **Cycle Navigator & Knowledge Graph** is to capture this history and make it a persistent, navigable, and core feature of the development workflow.

The goal is to transform the series of AI interactions from a linear conversation into a structured, explorable history of the project's evolution. This creates a "knowledge graph" where each node is a development cycle, and the edges are the AI-generated solutions that led from one cycle to the next.

## 2. Core Concepts

1.  **Cycle-Based History:** The fundamental unit of history is the "Cycle." Every time the curator sends a prompt and receives responses, that entire transaction is associated with a unique Cycle ID (e.g., `C70`).
2.  **Persistent Response Storage:** All AI-generated responses (the content that would be pasted into the Parallel Co-Pilot tabs) are saved and tagged with their corresponding Cycle ID.
3.  **UI for Navigation:** A simple, non-intrusive UI will be added to the Parallel Co-Pilot panel, allowing the user to step backward and forward through the cycles.
4.  **Historical Context Loading:** As the user navigates to a past cycle (e.g., from `C70` to `C69`), the Parallel Co-Pilot panel will automatically load the set of AI responses that were generated during that cycle.

## 3. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| P2-US-06 | **Navigate Project History** | As a developer, I want to navigate backward and forward through my project's development cycles, so I can review past decisions and the AI suggestions that prompted them. | - A UI control (e.g., left/right arrows and a cycle number display) is present in the Parallel Co-Pilot panel. <br> - Clicking the arrows changes the currently viewed cycle. |
| P2-US-07 | **View Historical Responses** | As a developer, when I navigate to a previous cycle, I want the Parallel Co-Pilot tabs to automatically populate with the AI-generated responses from that specific cycle, so I can see exactly what options I was considering at that time. | - Navigating to a cycle loads the associated set of AI responses into the tabs. <br> - The metadata (token counts, etc.) for these historical responses is also displayed. |
| P2-US-08 | **Preserve Interaction Context** | As a developer, I want every AI response to be automatically saved and associated with the current cycle, so a complete and accurate history of the project is built over time. | - A mechanism exists to automatically persist all AI responses received. <br> - Each response is tagged with a Cycle ID and a unique response UUID. |
</file>

<file path="src/Artifacts/A38. DCE - Phase 2 - Cycle Navigator - UI Mockup.md">
# Artifact A38: DCE - Phase 2 - Cycle Navigator - UI Mockup
# Date Created: C70
# Author: AI Model

- **Key/Value for A0:**
- **Description:** Provides a textual mockup and interaction flow for the Cycle Navigator UI, including the cycle counter and navigation controls within the Parallel Co-Pilot Panel.
- **Tags:** feature plan, phase 2, ui, ux, mockup, workflow, cycle navigator

## 1. Overview

This document describes the proposed user interface (UI) for the Cycle Navigator. The design prioritizes simplicity and integration, placing the navigation controls directly within the Parallel Co-Pilot Panel, reinforcing the connection between the cycle history and the AI responses.

## 2. UI Mockup (Textual Description)

The Cycle Navigator will be a new UI element added to the top of the Parallel Co-Pilot Panel, positioned just below the main header and above the tab configuration slider.

```
+-----------------------------------------------------------------+
| [Parallel Co-Pilot] [Settings Icon]                             |
|-----------------------------------------------------------------|
| Cycle: [ < ] [ C70 ] [ > ]                                      |
|-----------------------------------------------------------------|
| Number of Tabs: [Slider: 1 to 8]  (Current: 4)                  |
|=================================================================|
| [ Tab 1 (active) ] [ Tab 2 ] [ Tab 3 ] [ Tab 4 ] [ + ]           |
|-----------------------------------------------------------------|
|                                                                 |
|   [Swap with Source]                                            |
|                                                                 |
|   Source: src/services/user.service.ts                          |
|   ------------------------------------------------------------  |
|   |          | Original Source      | This Tab (Response 1) |  |
|   | Lines    | 150                  | 165                   |  |
|   | Tokens   | 2.1K                 | 2.4K                  |  |
|   |----------|----------------------|-----------------------|  |
|   | Similarity Score: 85%                                   |  |
|   ------------------------------------------------------------  |
|                                                                 |
|   [Text editor area where user pastes AI-generated code...]     |
|   |                                                         |   |
|   | export class UserService {                              |   |
|   |   // ... AI generated code ...                           |   |
|   | }                                                       |   |
|   |                                                         |   |
|                                                                 |
+-----------------------------------------------------------------+
```

### 2.1. UI Components Breakdown

1.  **Cycle Navigator Bar:**
    *   A new horizontal bar containing the navigation controls.
    *   **Label:** "Cycle:".
    *   **Previous Button (`<`):** A button with a left-arrow icon. Clicking it navigates to the previous cycle (e.g., `C69`). The button is disabled if the user is at the very first recorded cycle.
    *   **Cycle Display (`C70`):** A read-only (or potentially editable) text field showing the ID of the currently viewed cycle.
    *   **Next Button (`>`):** A button with a right-arrow icon. Clicking it navigates to the next cycle (e.g., `C71`). The button is disabled if the user is at the most recent cycle.

## 3. User Interaction Flow

1.  **Initial State:** The user is working on Cycle 70. The Cycle Display shows `C70`. The `>` button is disabled. The Parallel Co-Pilot tabs show the AI responses generated for Cycle 70.
2.  **Navigate Back:**
    *   The user clicks the **`<`** button.
    *   **Action:** The extension's state updates to the previous cycle, `C69`.
    *   **UI Update:** The Cycle Display changes to `C69`.
    *   **Data Load:** The Parallel Co-Pilot panel fetches the historical data for Cycle 69. The tabs are cleared and re-populated with the AI responses that were generated during that cycle. The metadata and similarity scores all update to reflect this historical data. Both `<` and `>` buttons are now enabled.
3.  **Navigate Forward:**
    *   The user is viewing Cycle 69 and clicks the **`>`** button.
    *   **Action:** The state moves forward to `C70`.
    *   **UI Update & Data Load:** The UI returns to the state described in step 1. The `>` button becomes disabled again.
</file>

<file path="src/Artifacts/A39. DCE - Phase 2 - Cycle Navigator - Technical Plan.md">
# Artifact A39: DCE - Phase 2 - Cycle Navigator - Technical Plan
# Date Created: C70
# Author: AI Model
# Updated on: C92 (Revise initialization flow to fix persistence issues)

- **Key/Value for A0:**
- **Description:** Details the technical approach for implementing the Cycle Navigator, including data structures for storing cycle-specific responses and the state management for historical navigation.
- **Tags:** feature plan, phase 2, technical plan, architecture, state management, data model

## 1. Overview

This document outlines the technical strategy for implementing the Cycle Navigator and PCPP persistence. The implementation will require a structured data format for storing historical data, enhancements to the frontend state management, new IPC channels, and robust backend logic for data persistence. The key change in this revision is a new initialization flow to make the backend the single source of truth, resolving state loss on reload or window pop-out.

## 2. Data Structure and Persistence

A structured approach to storing the historical data is critical. A simple JSON file stored within the workspace's `.vscode` directory is a suitable starting point.

### 2.1. `dce_history.json` (Example)

```json
{
  "version": 1,
  "cycles": [
    {
      "cycleId": 91,
      "timestamp": "2025-08-20T12:30:00Z",
      "title": "Initial implementation",
      "cycleContext": "Long-term notes...",
      "ephemeralContext": "<console_log>...</console_log>",
      "responses": {
        "1": { "content": "<src/client/views/view.tsx>...</file>" },
        "2": { "content": "..." },
        "3": { "content": "" }
      }
    },
    {
      "cycleId": 92,
      "timestamp": "2025-08-21T10:00:00Z",
      "title": "Persistence fix",
      "cycleContext": "Focus on fixing state loss.",
      "ephemeralContext": "",
      "responses": {
        "1": { "content": "" }, "2": { "content": "" }, "3": { "content": "" }, "4": { "content": "" }
      }
    }
  ]
}
```

*   **Backend (`history.service.ts`):** This service will manage reading from and writing to `dce_history.json`. It will handle file locking to prevent race conditions and provide methods like `getCycle(cycleId)`, `saveCycle(cycleData)`, `getCycleList()`, and a new `getLatestCycle()`.

## 3. Frontend State Management & Initialization Flow (C92 Revision)

### 3.1. Initialization
1.  **Problem:** Previously, the frontend managed its own state and only requested pieces of data, leading to state loss when the webview was re-initialized (e.g., on reload or pop-out).
2.  **Solution:** The new flow makes the backend the single source of truth.
    *   On component mount, the frontend sends a single new IPC message: `RequestLatestCycleData`.
    *   The backend's `HistoryService` finds the cycle with the highest `cycleId` in `dce_history.json`. If the file is empty, it creates a default "Cycle 1" object.
    *   The backend sends this complete `PcppCycle` object back to the client via `SendLatestCycleData`.
    *   The frontend's message handler uses this single object to populate its *entire* initial state: `currentCycleId`, `maxCycleId`, `cycleTitle`, `cycleContext`, `ephemeralContext`, and all `tabs` content. This guarantees the UI always starts with the latest saved data.

### 3.2. State Management (`parallel-copilot.view.tsx`)
```typescript
interface PcppState {
  currentCycleId: number;
  maxCycleId: number;
  cycleTitle: string;
  // ... other state
}
```
*   The state remains largely the same, but it is now initialized from a single backend message.
*   A "New Cycle" button (`+`) will be added. Its handler will increment `maxCycleId`, set `currentCycleId = maxCycleId`, clear the UI fields, and trigger a `saveCycleData` call to create the new empty cycle record.

## 4. IPC Communication

*   **REMOVED:** `RequestCycleHistoryList`.
*   **NEW:** `ClientToServerChannel.RequestLatestCycleData`:
    *   **Payload:** `{}`
    *   **Action:** Frontend requests the full data object for the most recent cycle.
*   **NEW:** `ServerToClientChannel.SendLatestCycleData`:
    *   **Payload:** `{ cycleData: PcppCycle }`
    *   **Action:** Backend sends the complete, latest cycle data to the frontend for initialization.
*   `ClientToServerChannel.RequestCycleData`: Still used for navigating to *older* cycles.
*   `ClientToServerChannel.SaveCycleData`: Unchanged. It sends the entire state of the *current* cycle to the backend to be persisted. It's critical that the `cycleId` in the payload is correct.
</file>

<file path="src/Artifacts/A4. DCE - Analysis of The-Creator-AI Repo.md">
# Artifact A4: DCE - Analysis of The-Creator-AI Repo
# Date Created: Cycle 2
# Author: AI Model
- **Description:** Provides a detailed analysis of the `The-Creator-AI-main` reference repository, its architecture, and its mapping to the Data Curation Environment project goals.
- **Tags:** analysis, repository, architecture, vscode-extension, project-planning

## 1. Overview

The `The-Creator-AI-main` repository is a comprehensive and well-structured VS Code extension that functions as a sophisticated AI coding assistant. It utilizes a modern tech stack including TypeScript, React for webviews, and TailwindCSS for styling. Its architecture is service-oriented on the backend (extension host) and modular on the frontend (webview). The discovery of this repository provides a massive head-start for our project, as it contains pre-built solutions for many of our planned features.

## 2. Backend Architecture (Extension Host)

The backend, located primarily in `src/backend/`, follows a clean, service-oriented architecture.

-   **`extension.ts`**: The main entry point. It initializes services and registers the commands and webview providers.
-   **`services/`**: A directory containing distinct services for handling specific concerns:
    -   `LlmService.ts`: Manages interactions with multiple AI models (Gemini, OpenAI). It includes logic for API key management and prompt construction.
    -   `FSService.ts`: Handles all file system operations, including reading files, creating a file tree, and respecting `.gitignore`.
    -   `CodeService.ts`: Contains logic for applying code changes, parsing diffs, and generating code.
    -   `GitService.ts`: Provides an interface for Git operations, like committing changes.
    -   `MessageService.ts`: Orchestrates the flow of messages between the frontend and the LLM service.
    -   `PlanExImService.ts`: Manages exporting and importing of "Change Plans".
    -   `Services.ts`: A dependency injection container that initializes and provides access to all other services.
-   **`repositories/`**: Manages data persistence within the VS Code workspace state (e.g., `PersistentStoreRepository.ts`, `SettingsRepository.ts`).
-   **`commands/`**: Defines all the commands exposed by the extension in `package.json`.

## 3. Frontend Architecture (Webview)

The frontend, located in `src/client/`, is a React application bundled with Webpack.

-   **`views/`**: The application is divided into distinct views, each with its own entry point, state management, and logic (e.g., `change-plan.view`).
-   **`modules/`**: Contains reusable UI/logic modules that are composed into the main view, such as:
    -   `context.module/Context.tsx`: Renders the file explorer.
    -   `plan.module/Plan.tsx`: Handles displaying the AI-generated plan and user input.
-   **`components/`**: A collection of generic, reusable React components:
    -   `file-tree/FileTree.tsx`: A fully functional file tree component with checkbox selection, expansion state, and active file highlighting. This is directly applicable to our Phase 1 goal.
    -   `AutoResizingTextarea.tsx`, `Modal.tsx`, `ProgressSteps.tsx`: Other useful UI components.
-   **State Management**: Each view appears to have its own local store (`store/`), using RxJS `BehaviorSubject` for reactivity. This is a simple yet effective approach for managing state within a contained webview.
-   **IPC**: Communication with the backend is handled via a robust `ClientPostMessageManager` (`src/common/ipc/`) which defines clear channels for client-server interaction.

## 4. Mapping to DCE Project Goals

The reference repository provides solutions or strong foundations for all three of our project phases.

-   **Phase 1 (Context Chooser):** **Largely Complete.** The `FileTree.tsx` component in `src/client/components/file-tree/` combined with `FSService.ts` on the backend already provides the core functionality of a checkbox-based file explorer for context selection. Our work shifts from building this from scratch to adapting and integrating this existing, powerful component.

-   **Phase 2 (Parallel 'Co-pilot' Panel):** **Partially Complete.** The "Change Plan" view (`src/client/views/change-plan.view/`) is essentially a single "co-pilot" panel. It allows a user to describe a change, get an AI-generated plan, and interact with it. Our goal of *parallel* panels is not implemented, but the foundation for a single panel is incredibly strong.

-   **Phase 3 (Diff Tool):** **Not Present.** There is no integrated diff-viewing tool like WinMerge. However, the `CodeService.ts` *does* contain logic for parsing and applying diffs in a custom `<<<<<<< SEARCH` format, and the extension can trigger VS Code's native diff viewer (`git.openChange`).

## 5. Recommendations & Path Forward

1.  **Adopt the Architecture:** We should officially adopt the architecture of `The-Creator-AI-main` as the blueprint for our project. It is robust, scalable, and well-organized.
2.  **Focus on Adaptation:** Our immediate efforts for Phase 1 should be to isolate the `FileTree` component and its backend dependencies (`FSService.ts`) and ensure they can be used to generate the `flattened_repo.md` as originally specified.
3.  **De-risk Phase 2:** The "Change Plan" functionality is a perfect starting point for our parallel co-pilot. We should analyze its state management and IPC communication to understand how we might instantiate multiple, independent instances of it.
4.  **Update All Documentation:** All planning artifacts (`A1`, `A2`, `A3`) must be updated immediately to reflect this new context. Our plan has evolved from "build" to "analyze, adapt, and extend".
</file>

<file path="src/Artifacts/A40. DCE - Phase 2 - Parallel Co-Pilot - Target File Structure.md">
# Artifact A40: DCE - Phase 2 - Parallel Co-Pilot - Target File Structure
# Date Created: C71
# Author: AI Model

- **Key/Value for A0:**
- **Description:** A text-based representation of the new files and components required to build the Phase 2 Parallel Co-Pilot and Cycle Navigator features.
- **Tags:** file structure, architecture, project layout, scaffolding, phase 2

## 1. Overview

This document outlines the new files and directories that will be created to support the development of the Phase 2 features: the Parallel Co-Pilot Panel and the Cycle Navigator. This structure is designed to be modular and integrate cleanly with our existing architecture. This artifact also serves as the "pre-computation" plan requested in C71, allowing for a script to be created to scaffold these files when development begins.

## 2. New File Tree for Phase 2

This tree shows only the **new** files and directories to be added. Existing directories will be modified to import and use these new components.

```
src/
â”œâ”€â”€ backend/
â”‚   â””â”€â”€ services/
â”‚       â””â”€â”€ history.service.ts      # New: Manages reading/writing dce_history.json
â”‚
â””â”€â”€ client/
    â”œâ”€â”€ components/
    â”‚   â”œâ”€â”€ DiffViewer.tsx          # New (for Phase 3, but can be stubbed): A component for side-by-side text diffing.
    â”‚   â”œâ”€â”€ Slider.tsx              # New: A simple reusable slider component for the tab count.
    â”‚   â””â”€â”€ TabbedEditor.tsx        # New: The core multi-tab editor component.
    â”‚
    â”œâ”€â”€ views/
    â”‚   â””â”€â”€ parallel-copilot.view/  # New View for Phase 2
    â”‚       â”œâ”€â”€ index.ts
    â”‚       â”œâ”€â”€ on-message.ts
    â”‚       â”œâ”€â”€ view.scss
    â”‚       â””â”€â”€ view.tsx            # Main React component for the Parallel Co-Pilot panel
    â”‚
    â””â”€â”€ utils/
        â””â”€â”€ string-similarity.ts    # New: A lightweight utility for calculating string similarity scores.

.vscode/
â””â”€â”€ dce_history.json                # New (auto-generated): Stores the cycle history and AI responses.
```

## 3. Component & Service Descriptions

### Backend

-   **`src/backend/services/history.service.ts`:**
    -   **Responsibility:** Solely responsible for abstracting the file I/O for the `dce_history.json` file.
    -   **Methods:** `getCycleHistory()`, `getCycleData(cycleId)`, `saveResponseToCycle(...)`. This keeps the main `fs.service.ts` clean from business logic.

### Frontend Components

-   **`src/client/views/parallel-copilot.view/`:**
    -   This new directory will contain everything needed for the new panel, following the same structure as our existing `context-chooser.view`.
    -   `view.tsx` will be the main component, managing the state for all tabs, the current cycle, and orchestrating IPC communication.
-   **`src/client/components/TabbedEditor.tsx`:**
    -   A component that will manage the tab bar and the content of each tab editor, receiving the array of tab data as props.
-   **`src/client/components/Slider.tsx`:**
    -   A simple, reusable slider component to control the number of tabs. This extracts UI logic from the main view.
-   **`src/client/utils/string-similarity.ts`:**
    -   Will contain a function to calculate the similarity between two strings, likely implementing the Dice Coefficient or a similar algorithm. This keeps the calculation logic separate and testable.

### Root Directory

-   **`.vscode/dce_history.json`:**
    -   This file will be automatically created and managed by the `HistoryService`. Storing it in `.vscode` is standard practice for workspace-specific extension data that should not typically be checked into source control. It will be added to `.gitignore`.
</file>

<file path="src/Artifacts/A40.1. DCE - Phase 2 - Competitive Analysis & Feature Ideas.md">
# Artifact A40.1: DCE - Phase 2 - Competitive Analysis & Feature Ideas
# Date Created: C71
# Author: AI Model
# Updated on: C71 (Incorporate user feedback and consolidate ideas)

- **Key/Value for A0:**
- **Description:** An analysis of existing tools and extensions for managing multiple AI responses, with a list of potential features to incorporate into the Parallel Co-Pilot panel.
- **Tags:** feature plan, phase 2, research, competitive analysis, co-pilot

## 1. Overview

As requested in Cycle 71, this document summarizes research into existing tools that address the problem of managing and comparing multiple AI-generated code responses. The goal is to identify common features, discover innovative ideas, and ensure our Phase 2 "Parallel Co-Pilot Panel" is a best-in-class solution.

## 2. Research Summary

A search for "VS Code extensions for comparing AI responses" reveals that while many extensions integrate a single AI chat (like GitHub Copilot Chat), very few are designed for the specific workflow of managing *multiple, parallel* responses to the *same* prompt. [1, 3] This represents a significant opportunity for our project. The "AI Toolkit for Visual Studio Code" is a notable exception, offering features to run prompts against multiple models simultaneously and compare the results, validating our core concept. [1, 2]

Most developers still use a manual process involving external tools:
1.  Pasting responses into separate tabs in a text editor (Notepad++, Sublime Text).
2.  Using a dedicated diff tool (WinMerge, Beyond Compare, VS Code's native diff) to compare two responses at a time.

The key pain point is the friction of moving text between applications and the lack of an integrated testing loop, which our "swap" feature directly addresses.

## 3. Existing Tools & Inspirations

| Tool / Extension | Relevant Features | How It Inspires DCE |
| :--- | :--- | :--- |
| **AI Toolkit for VS Code** | - "Bulk Run" executes a prompt across multiple models simultaneously. [1] <br> - "Compare" view for side-by-side model responses. [2] <br> - Model evaluation with metrics like similarity and relevance. [2] | This extension is the closest conceptually to our goal. It validates the need for parallel prompting and comparison. Our "swap" feature for live testing remains a key differentiator. |
| **Cursor.sh (IDE)** | - A fork of VS Code built around an AI-first workflow. <br> - "Auto-debug" feature attempts to fix errors. <br> - Inline diffing for AI-suggested changes. | Cursor's deep integration is a long-term inspiration. An "Auto-fix TS Errors" button in our panel could be a powerful feature, where we send the code + errors back to the AI. |
| **Continue.dev** | - Open-source and customizable. <br> - Strong concept of "Context Providers," very similar to our Phase 1. | Their flexible context system is a good model. A future DCE feature could allow highlighting a specific function and sending *just that* to the Parallel Co-Pilot panel for iteration. |

## 4. New Feature Ideas for DCE Phase 2 (Refined with C71 Feedback)

Based on the analysis and our project goals, here are some new or refined feature ideas for the Parallel Co-Pilot Panel:

| Feature Idea | Description |
| :--- | :--- |
| **"Accept Response" Button** | As per user feedback, this is a more intuitive name than "Promote to Source". A button to overwrite the source file with the tab's content without swapping back. This signifies a permanent acceptance of the AI's suggestion for that cycle. |
| **One-Click Diff View** | A button that opens VS Code's native diff viewer, comparing the tab's content with the original source file. This is a great stepping stone to our fully integrated Phase 3 diff tool. |
| **AI-Powered Summary of Changes** | A button that sends the original code and the tab's code to an LLM with a prompt like "Summarize the key changes between these two code blocks." The summary would be displayed in the tab's metadata area. |
| **Response Annotation & Rating** | A feature the user liked: Allow adding thumbs up/down, tags (e.g., `refactor`, `bug-fix`), and comments to each response tab. This metadata would be saved with the cycle history, adding valuable context. |
| **Intent Buttons** | As per user feedback, instead of slash commands, provide clear buttons for common refinement tasks like "Add Documentation," "Find Bugs," or "Refactor for Readability." These would re-prompt the AI with the tab's content and the specific instruction. |
| **Ephemeral "Cycles Context" Field** | As per user feedback, add a separate text field for temporary context like error logs that are useful for the current cycle's prompt but should not be saved in the long-term cycle history to avoid token bloat. |
</file>

<file path="src/Artifacts/A41. DCE - Phase 2 - API Key Management - Feature Plan.md">
# Artifact A41: DCE - Phase 2 - API Key Management - Feature Plan
# Date Created: C71
# Author: AI Model

- **Key/Value for A0:**
- **Description:** Outlines the user stories and technical plan for a settings UI where users can securely input and manage their API keys for various LLM services or a local endpoint URL.
- **Tags:** feature plan, phase 2, settings, api key, configuration, security

## 1. Overview & Goal

As the DCE project moves into Phase 2, it will begin to make its own API calls to LLM providers. To do this securely and flexibly, the extension needs a dedicated interface for users to manage their API keys and specify a local LLM endpoint. The goal of this feature is to provide a simple, secure, and intuitive settings panel for managing these credentials.

This functionality is heavily inspired by the `ApiKeysManagement.tsx` module in the `The-Creator-AI-main` reference repository.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| P2-API-01 | **Configure API Key** | As a user, I want to add an API key for a specific cloud service (e.g., Gemini, OpenAI), so the extension can make API calls on my behalf. | - A UI is available to add a new API key. <br> - I can select the LLM provider from a dropdown list. <br> - I can paste my key into a text field. <br> - The key is stored securely using VS Code's `SecretStorage` API. |
| P2-API-02 | **Configure Local LLM Endpoint** | As a user with a local LLM (e.g., via LM Studio), I want to provide an API endpoint URL, so the extension can use my local model instead of a cloud service. | - The settings UI has a dedicated input field for a local LLM API URL. <br> - The URL is saved to the workspace settings. <br> - The extension prioritizes using this URL if it is set. |
| P2-API-03 | **View Saved Keys** | As a user, I want to see a list of my saved API keys (partially masked), so I can confirm which keys I have configured. | - The settings UI displays a list of all saved API keys. <br> - Keys are grouped by service. <br> - The key values are partially masked for security (e.g., `sk-xxxx...1234`). |
| P2-API-04 | **Delete an API Key** | As a user, I want to delete an API key that I no longer use, so I can manage my credentials. | - Each listed API key has a "Delete" button. <br> - Clicking "Delete" prompts for confirmation. <br> - Upon confirmation, the key is removed from the extension's secure storage. |
| P2-API-05 | **Secure Storage** | As a developer, I want API keys to be stored securely using VS Code's `SecretStorage` API, so sensitive user credentials are not exposed as plain text. | - API keys are not stored in plain text in `settings.json` or workspace state. <br> - The `SecretStorage` API is used to encrypt and store the keys, associating them with the extension. |

## 3. Technical Implementation Plan

1.  **New View / Command:**
    *   A new command, `dce.openApiSettings`, will be created. This command will open a new webview panel dedicated to API key management. This keeps the UI clean and separate from the main workflow panels.
    *   This can be triggered from a "Settings" icon within the Parallel Co-pilot view.

2.  **Backend (`settings.service.ts` - New):**
    *   A new `SettingsService` will be created to handle the logic for storing and retrieving secrets and settings.
    *   **API Key Storage:** It will use `vscode.ExtensionContext.secrets` (the `SecretStorage` API) for all API key operations.
    -   **Local URL Storage:** It will use the standard `vscode.workspace.getConfiguration` API to get/set the local LLM URL in the workspace `settings.json`.
    *   **Methods:** It will expose methods like `setApiKey(service: string, key: string)`, `getApiKeys()`, `deleteApiKey(service: string)`, `getLocalLlmUrl()`, and `setLocalLlmUrl(url: string)`. The `getApiKeys` method will return a structure with masked keys for the UI.

3.  **Frontend (New `api-settings.view.tsx`):**
    *   This new React view will render the UI for managing keys and the local endpoint URL.
    *   It will communicate with the backend `SettingsService` via new IPC channels.

4.  **IPC Channels:**
    *   `RequestApiKeys`: Frontend asks for the list of saved (masked) keys.
    *   `SendApiKeys`: Backend sends the list of keys.
    *   `SaveApiKey`: Frontend sends a new service and key to the backend.
    *   `DeleteApiKey`: Frontend requests the deletion of a specific key.
    *   `RequestLocalLlmUrl` / `SendLocalLlmUrl`
    *   `SaveLocalLlmUrl`
</file>

<file path="src/Artifacts/A41.1. DCE - Phase 2 - Advanced Features & Integrations Plan.md">
# Artifact A41.1: DCE - Phase 2 - Advanced Features & Integrations Plan
# Date Created: C71
# Author: AI Model

- **Key/Value for A0:**
- **Description:** Explores future enhancements for the Parallel Co-Pilot, such as applying AI responses as diff patches and integrating with Git for direct commits.
- **Tags:** feature plan, phase 2, ideation, diff, patch, git, workflow

## 1. Overview & Goal

This document explores potential high-impact features that could be built on top of the core Parallel Co-Pilot panel. The goal is to move beyond simple "swap" functionality and create a more powerful, integrated, and intelligent workflow for reviewing and applying AI-generated code. These ideas are intended for consideration and prioritization during Phase 2 development.

## 2. Proposed Advanced Features

### 2.1. Idea: Apply as Diff/Patch

-   **Problem:** The current "swap" feature is a blunt instrument. It replaces the entire file, which can be risky if the AI only intended to change a small part of it and made a mistake elsewhere. It also makes it hard to see exactly what changed.
-   **Proposed Solution:**
    1.  **Diff Generation:** When an AI response is pasted into a tab, the extension automatically generates a diff between the tab's content and the original source file.
    2.  **Inline Diff View:** The editor in the tab could be enhanced to show an inline diff view (similar to VS Code's source control view), highlighting added and removed lines.
    3.  **"Apply Patch" Button:** The "Swap" button is replaced with an "Apply Patch" button. Clicking it would attempt to apply only the identified changes to the source file, leaving the rest of the file untouched. This is a much safer and more precise way to integrate AI suggestions.
-   **Technical Notes:** This would require a diffing library (e.g., `diff-match-patch` or `jsdiff`) on the frontend or backend to generate and apply patches.

### 2.2. Idea: Integrated Git Workflow

-   **Problem:** After a developer tests and accepts an AI suggestion, the next step is almost always to commit the change. This requires leaving the co-pilot panel and using the source control view.
-   **Proposed Solution:**
    1.  **"Commit This Change" Button:** Add a new button to each tab in the Parallel Co-Pilot panel.
    2.  **Workflow:**
        *   The user swaps in the AI code and verifies it works.
        *   They click "Commit This Change".
        *   The extension automatically stages the modified file (`git add <file_path>`).
        *   The extension opens the Source Control commit input box.
        *   **Enhancement:** The commit message box could be pre-populated with a summary of the changes, potentially generated by another AI call based on the diff.
-   **Technical Notes:** This requires deeper integration with the `vscode.git` extension API to programmatically stage files and interact with the commit box.

### 2.3. Idea: Response Annotation and Rating

-   **Problem:** It's difficult to remember why a particular AI response was good or bad, especially when looking back at the history via the Cycle Navigator.
-   **Proposed Solution:**
    1.  **Rating/Annotation UI:** Add a small section to each tab allowing the user to give a thumbs up/down rating and add a short text note (e.g., "Works, but inefficient" or "Best solution, very clean"). This includes highlighting specific sections of code to associate with a comment.
    2.  **Persistence:** These annotations would be saved as part of the `dce_history.json` file, associated with that specific response.
    3.  **Benefit:** When navigating back through cycles, these notes would provide valuable context about the quality and outcome of each AI suggestion, enhancing the "knowledge graph" of the project.
-   **Technical Notes:** This requires extending the data model in `A39` and adding the corresponding UI elements and state management.
</file>

<file path="src/Artifacts/A41.2. DCE - Phase 2 - Feature Ideation & Competitive Analysis.md">
# Artifact A41.2: DCE - Phase 2 - Feature Ideation & Competitive Analysis
# Date Created: C71
# Author: AI Model
# Updated on: C71 (Incorporate user feedback from C71)

- **Key/Value for A0:**
- **Description:** An analysis of similar AI coding assistant tools (e.g., Cursor.sh, Copilot Chat) and a brainstorm of potential advanced features for the Parallel Co-Pilot panel.
- **Tags:** feature plan, phase 2, research, competitive analysis, ideation, roadmap

## 1. Overview & Goal

The core vision of the Parallel Co-Pilot panel is to solve the "single-threaded" limitation of current AI chat interfaces. As we plan its implementation, it's valuable to analyze existing tools to identify best-in-class features and brainstorm new ideas that could give our extension a unique advantage. The goal of this document is to explore this landscape and generate a backlog of potential enhancements for Phase 2 and beyond, incorporating feedback from Cycle 71.

## 2. Competitive Analysis (Incorporating Search Results [1, 2, 3, 4])

### 2.1. GitHub Copilot Chat & Similar Tools
-   **Strengths:** Deeply integrated, understands editor context, uses "slash commands" (`/fix`, `/doc`) for specific intents. [5]
-   **Weakness (Our Opportunity):** Fundamentally a linear, single-threaded chat. Comparing multiple responses to a single prompt is difficult and requires manual copy-pasting. Our parallel tabbed view is a direct solution to this.

### 2.2. Cursor.sh
-   **Strengths:** An "AI-first" fork of VS Code. Has an "AI-diff" feature that applies changes directly in the editor with an intuitive diff view.
-   **Weakness (Our Opportunity):** It's a separate application, not an extension. Users must leave their standard VS Code setup. Our tool integrates into the existing environment. The user has also specified a preference for a whole-file workflow over Cursor's chunk-based edits.

### 2.3. AI Toolkit for Visual Studio Code
-   **Strengths:** This is the most conceptually similar tool found. It explicitly supports a "Bulk Run" feature to execute prompts across multiple models simultaneously and a "Compare" view to see results side-by-side. [1, 2]
-   **Weakness (Our Opportunity):** While it excels at comparison, its workflow for *testing* the code within the user's live project is not as streamlined. Our "Swap" feature provides an immediate, integrated test loop that appears to be a unique advantage.

## 3. Brainstormed Feature Enhancements for DCE (Refined with C71 Feedback)

This is a backlog of potential features for the Parallel Co-Pilot panel, inspired by the analysis and our project's unique goals.

| Feature ID | Feature Name | Description | Priority |
| :--- | :--- | :--- | :--- |
| **P2-F01** | **Inline Diff View** | Instead of a blind "swap", clicking a button opens a diff view within the tab, comparing the AI response to the source file. The user can then accept the full change. | High |
| **P2-F02** | **AI Refinement Actions (Intent Buttons)** | Per user feedback, each tab will have a small toolbar with **buttons** like "Add Docs," "Find Bugs," or "Refactor." Clicking one sends the tab's content back to the LLM with that specific instruction, replacing the content with the refined response. | High |
| **P2-F03** | **Model Selection Per Tab** | Allow the user to select a different backend LLM (e.g., Gemini, Claude, Local URL) for each tab. This requires the API Key Management feature from `A41`. | Medium |
| **P2-F04** | **"Accept Response" Workflow** | Formalize the user's feedback. The "Swap" button is for temporary, iterative testing. A separate, explicit **"Accept Response"** button will permanently overwrite the source file, signifying the end of that iteration for that file. | High |
| **P2-F05** | **Response Annotation & Rating** | A feature the user liked: Add UI for thumbs up/down, short text notes, and tags (e.g., "works", "buggy"). This metadata is saved with the cycle history, enhancing the knowledge graph. | Medium |
| **P2-F06** | **Highlight-to-Context** | Allow a user to highlight a block of code in the main editor, right-click, and select "Send to Parallel Co-Pilot". This would open a new tab in the panel, pre-filled with the highlighted code. | Medium |
| **P2-F07** | **Ephemeral "Cycles Context" Field** | Per user feedback, add a separate text field for temporary context (e.g., error logs). This content is included in the prompt for the current cycle but is NOT saved to the permanent `dce_history.json` to prevent token bloat over time. | High |
</file>

<file path="src/Artifacts/A42. DCE - Phase 2 - Initial Scaffolding Deployment Script.md">
# Artifact A42: DCE - Phase 2 - Initial Scaffolding Deployment Script
# Date Created: C72
# Author: AI Model
# Updated on: C73 (Flesh out script with full placeholder content)

- **Key/Value for A0:**
- **Description:** Contains a Node.js script that, when executed, creates the file and directory structure for the Phase 2 Parallel Co-Pilot panel.
- **Tags:** deployment, script, scaffolding, bootstrap, nodejs, automation, phase 2

## 1. Overview

This artifact contains the `deploy_phase2_scaffold.js` script. Its purpose is to automate the creation of the new files and directories required for Phase 2, as outlined in `A40. DCE - Phase 2 - Parallel Co-Pilot - Target File Structure`. This ensures a consistent setup for starting development on the new features.

## 2. How to Use

1.  Save the code below as `deploy_phase2_scaffold.js` in your project's root directory (e.g., `C:\Projects\DCE\`).
2.  Open a terminal in that directory.
3.  Run the script using Node.js: `node deploy_phase2_scaffold.js`
4.  The script will create the new directories and placeholder files, logging its progress to the console.

## 3. Script: `deploy_phase2_scaffold.js`

```javascript
const fs = require('fs').promises;
const path = require('path');

// --- File Content Definitions ---

const filesToCreate = [
    {
        path: 'src/backend/services/history.service.ts',
        content: `// src/backend/services/history.service.ts
import * as vscode from 'vscode';
import { Services } from './services';

// Basic structure for history data
interface CycleResponse {
    responseId: string;
    model: string;
    content: string;
}

interface Cycle {
    cycleId: string;
    timestamp: string;
    prompt: string;
    responses: CycleResponse[];
}

interface HistoryFile {
    version: number;
    cycles: Cycle[];
}

export class HistoryService {
    private historyFilePath: string | undefined;

    constructor() {
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (workspaceFolders && workspaceFolders.length > 0) {
            this.historyFilePath = path.join(workspaceFolders.uri.fsPath, '.vscode', 'dce_history.json');
        }
    }

    private async _readHistoryFile(): Promise<HistoryFile> {
        if (!this.historyFilePath) return { version: 1, cycles: [] };
        try {
            const content = await vscode.workspace.fs.readFile(vscode.Uri.file(this.historyFilePath));
            return JSON.parse(Buffer.from(content).toString('utf-8'));
        } catch (error) {
            Services.loggerService.warn("dce_history.json not found or is invalid. A new one will be created.");
            return { version: 1, cycles: [] };
        }
    }

    private async _writeHistoryFile(data: HistoryFile): Promise<void> {
        if (!this.historyFilePath) return;
        const dir = path.dirname(this.historyFilePath);
        try {
            await vscode.workspace.fs.createDirectory(vscode.Uri.file(dir));
            const content = Buffer.from(JSON.stringify(data, null, 2), 'utf-8');
            await vscode.workspace.fs.writeFile(vscode.Uri.file(this.historyFilePath), content);
        } catch (error) {
            Services.loggerService.error(\`Failed to write to dce_history.json: \${error}\`);
        }
    }

    public async getCycleHistory() {
        Services.loggerService.log("HistoryService: getCycleHistory called.");
        const history = await this._readHistoryFile();
        return history.cycles.map(c => c.cycleId).sort(); // Return sorted list of cycle IDs
    }
}
`
    },
    {
        path: 'src/client/views/parallel-copilot.view/index.ts',
        content: `// src/client/views/parallel-copilot.view/index.ts
import { onMessage } from "./on-message";

export const viewConfig = {
    entry: "parallelCopilotView.js",
    type: "viewType.sidebar.parallelCopilot",
    handleMessage: onMessage,
};
`
    },
    {
        path: 'src/client/views/parallel-copilot.view/on-message.ts',
        content: `// src/client/views/parallel-copilot.view/on-message.ts
import { ServerPostMessageManager } from "@/common/ipc/server-ipc";
import { Services } from "@/backend/services/services";

export function onMessage(serverIpc: ServerPostMessageManager) {
    const loggerService = Services.loggerService;
    loggerService.log("Parallel Co-Pilot view message handler initialized.");

    // TODO: Add message handlers for Phase 2 features
    // e.g., serverIpc.onClientMessage(ClientToServerChannel.RequestSwapFileContent, ...)
}
`
    },
    {
        path: 'src/client/views/parallel-copilot.view/view.scss',
        content: `/* Styles for Parallel Co-Pilot View */
body {
    padding: 0;
    font-family: var(--vscode-font-family);
    font-size: var(--vscode-font-size);
    color: var(--vscode-editor-foreground);
    background-color: var(--vscode-sideBar-background);
}

.pc-view-container {
    padding: 8px;
    display: flex;
    flex-direction: column;
    height: 100vh;
    gap: 8px;
}

.cycle-navigator {
    display: flex;
    align-items: center;
    gap: 8px;
    padding-bottom: 8px;
    border-bottom: 1px solid var(--vscode-panel-border);
}

.tab-bar {
    display: flex;
    border-bottom: 1px solid var(--vscode-panel-border);
}

.tab {
    padding: 6px 12px;
    cursor: pointer;
    border-bottom: 2px solid transparent;
    color: var(--vscode-tab-inactiveForeground);
}

.tab.active {
    color: var(--vscode-tab-activeForeground);
    border-bottom-color: var(--vscode-tab-activeBorder);
}

.tab-content {
    padding-top: 8px;
}
`
    },
    {
        path: 'src/client/views/parallel-copilot.view/view.tsx',
        content: `// src/client/views/parallel-copilot.view/view.tsx
import * as React from 'react';
import * as ReactDOM from 'react-dom/client';
import './view.scss';
import { VscChevronLeft, VscChevronRight } from 'react-icons/vsc';

const App = () => {
    const [activeTab, setActiveTab] = React.useState(1);
    const tabCount = 4; // Example tab count

    return (
        <div className="pc-view-container">
            <div className="cycle-navigator">
                <span>Cycle:</span>
                <button><VscChevronLeft /></button>
                <span>C73</span>
                <button><VscChevronRight /></button>
            </div>
            
            <div className="tab-bar">
                {[...Array(tabCount)].map((_, i) => (
                    <div 
                        key={i} 
                        className={\`tab \${activeTab === i + 1 ? 'active' : ''}\`}
                        onClick={() => setActiveTab(i + 1)}
                    >
                        Response {i + 1}
                    </div>
                ))}
            </div>

            <div className="tab-content">
                {[...Array(tabCount)].map((_, i) => (
                    activeTab === i + 1 && <div key={i}>Content for Response {i + 1}</div>
                ))}
            </div>
        </div>
    );
};

const root = ReactDOM.createRoot(document.getElementById('root')!);
root.render(<App />);
`
    },
];

// --- Main Execution ---

async function deployScaffold() {
    console.log('Starting Phase 2 scaffold deployment...');
    const rootDir = process.cwd();

    for (const file of filesToCreate) {
        const fullPath = path.join(rootDir, file.path);
        const dir = path.dirname(fullPath);

        try {
            await fs.mkdir(dir, { recursive: true });
            await fs.writeFile(fullPath, file.content, 'utf-8');
            console.log(`âœ… Created: ${file.path}`);
        } catch (error) {
            console.error(`âŒ Failed to create ${file.path}: ${error.message}`);
        }
    }

    console.log('\\nðŸš€ Phase 2 scaffold deployment complete! ðŸš€');
    console.log('Next steps:');
    console.log('1. Review and apply changes to package.json, webpack.config.js, src/client/views/index.ts, and src/common/view-types.ts.');
    console.log('2. Update services.ts to instantiate and provide the new HistoryService.');
}

deployScaffold();
```
</file>

<file path="src/Artifacts/A43. DCE - Phase 2 - Implementation Roadmap.md">
# Artifact A43: DCE - Phase 2 - Implementation Roadmap
# Date Created: C72
# Author: AI Model
# Updated on: C87 (Promote Persistence and Diffing, defer advanced UI)

- **Key/Value for A0:**
- **Description:** Provides a step-by-step implementation plan for building the Phase 2 features, including the Parallel Co-Pilot panel and the integrated Diff Tool.
- **Tags:** feature plan, phase 2, roadmap, project plan, diff tool

## 1. Overview & Goal

This document provides a clear, step-by-step roadmap for the implementation of Phase 2. The scope of Phase 2 is now defined as the **Parallel Co-Pilot Panel with state persistence and an integrated Diff Tool**. This roadmap breaks the large feature set into smaller, manageable, and testable steps. The goal is to build the functionality incrementally, ensuring a stable foundation at each stage.

## 2. Implementation Steps

### Step 1: Foundational UI & State Persistence (Highest Priority)

-   **Goal:** Create a functional UI for the PCPP where all user input is saved and restored reliably.
-   **Tasks:**
    1.  **Scaffolding & Config:** Ensure all files from `A42` are in place and correctly configured in `package.json`, `webpack.config.js`, etc.
    2.  **UI Development (`view.tsx`):**
        *   Build the static React components for the panel based on the updated mockup in `A35`.
        *   **Crucially, re-add the "Cycle Context" and "Ephemeral Context" text areas to fix the C87 regression.**
    3.  **Backend (`history.service.ts`):** Implement the core logic to read from and write to the `.vscode/dce_history.json` file.
    4.  **State Sync Loop:** Implement the full persistence loop. Changes in the frontend UI trigger a debounced `SaveCycleData` IPC message. The backend `HistoryService` updates the JSON file.
-   **Outcome:** A visible panel where any text typed into any field is saved and restored when the panel is closed and reopened or moved to a new window.

### Step 2: Cycle Navigator

-   **Goal:** Enable navigation through the persistent history created in Step 1.
-   **Tasks:**
    1.  **IPC:** Implement the `RequestCycleHistoryList` and `RequestCycleData` channels.
    2.  **Frontend (`view.tsx`):**
        *   On load, fetch the list of all cycle IDs to determine the valid range for navigation (`1` to `maxCycleId`).
        *   Wire the `<` and `>` buttons to change the `currentCycleId` state.
        *   Create a `useEffect` hook that listens for changes to `currentCycleId` and requests the corresponding data from the backend.
        *   The handler for `SendCycleData` will update the entire panel's state with the historical data.
-   **Outcome:** The user can click the back and forward buttons to load and view the complete state of the PCPP from previous cycles.

### Step 3: File Association and Diffing

-   **Goal:** Implement the ability to see a diff for any file mentioned in an AI response.
-   **Tasks:**
    1.  **Add Dependency:** Add the `diff` library to `package.json`.
    2.  **UI (`view.tsx`):**
        *   Implement the "Associated Files" list UI element. It will be populated by the `detectedFiles` state, which is already being parsed.
        *   Make each file in the list a clickable button.
    3.  **IPC:** Create a `RequestFileContent` channel.
    4.  **Backend (`fs.service.ts`):** Implement a handler that reads a file's content and sends it back.
    5.  **Component (`DiffViewer.tsx`):** Create a new component that takes two strings and renders a side-by-side or inline diff.
    6.  **Workflow:** Clicking a file in the list sends `RequestFileContent`. When the content arrives, the frontend shows the `DiffViewer` component (e.g., in a modal) with the original content and the content from the AI response.
-   **Outcome:** The user can paste a response and immediately get a clear, color-coded view of the changes being proposed for any file.

### Step 4: Core "Swap" Functionality

-   **Goal:** Implement the "Swap with Source" feature.
-   **Tasks:**
    1.  **IPC Channels:** Implement `RequestSwapFileContent`.
    2.  **Backend (`fs.service.ts`):** Implement the `handleSwapFileContentRequest` method.
    3.  **Frontend (`view.tsx`):** Wire up the "Swap" button to trigger the IPC message.
-   **Outcome:** The user can test AI-generated code in their workspace with a single click.

### Step 5: Advanced Features (Future Cycles)

-   **Goal:** Implement remaining features from the vision.
-   **Tasks:**
    *   Annotation and Rating (Comments, Thumbs Up/Down).
    *   Live API Integration (The new Phase 3).
    *   Advanced UI from `A50` (Resizable panes, inner editors).
</file>

<file path="src/Artifacts/A44. DCE - Phase 1 - Word Document Handling Strategy.md">
# Artifact A44: DCE - Phase 1 - Word Document Handling Strategy
# Date Created: C73
# Author: AI Model
# Updated on: C81 (Add handling for corrupted .docx files)

- **Key/Value for A0:**
- **Description:** Defines the strategy for handling Word document files (.docx) by converting them to text on-demand and caching them in memory for flattening.
- **Tags:** feature plan, docx, text extraction, virtualization, cache, phase 1

## 1. Overview & Goal

To further expand the data curation capabilities of the extension, users need to be able to include the content of Microsoft Word documents (`.docx`). Following the successful virtualization pattern used for PDFs and Excel files, the goal is to extract text from Word documents on-demand and hold it in an in-memory cache. This allows their content to be included in the flattened context without creating temporary files in the user's workspace.

## 2. Supported & Unsupported Formats

-   **Supported:** This strategy focuses exclusively on the modern, XML-based **`.docx`** format.
-   **Unsupported:** The legacy binary **`.doc`** format is significantly more complex to parse and is **not supported**. The extension will identify `.doc` files and insert a placeholder in the flattened output rather than attempting to process them.

## 3. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| DOCX-01 | **Include Word Document Text in Context** | As a user, when I check a `.docx` file, I want its text content to be extracted and included in the `flattened_repo.md`, so I can use reports and documents as context for the LLM. | - Checking `.docx` files is allowed. <br> - The token count displayed for the file reflects its extracted text content. <br> - When flattened, the text from the document is included within a `<file>` tag. <br> - No temporary files are created in the user's workspace. |
| DOCX-02 | **Handle Unsupported `.doc` format** | As a user, when I check a legacy `.doc` file, I want the system to acknowledge it but inform me in the output that its content could not be processed, so I am not confused by missing data or corrupted text. | - Checking `.doc` files is allowed. <br> - The token count for `.doc` files remains 0. <br> - When flattened, a clear placeholder comment is included for the `.doc` file, stating that the format is unsupported. |
| DOCX-03 | **Handle Corrupted `.docx` files** | As a user, if I check a `.docx` file that is corrupted or invalid, I want the extension to fail gracefully and show me an error in the UI, so I know the file has a problem. | - The extension attempts to parse the `.docx` file. <br> - If parsing fails due to file corruption (e.g., it's not a valid zip archive), the token count is set to 0. <br> - An error message (e.g., "File may be corrupted") is displayed in the file's tooltip in the UI. <br> - The flattened output includes a comment indicating the failure. |

## 4. Technical Implementation Plan

1.  **Dependency:**
    *   The `mammoth` library will be added to `package.json`. It is a popular and effective library for converting `.docx` files to HTML and raw text.

2.  **Backend (`fs.service.ts`):**
    *   **In-Memory Cache:** A new private cache will be added: `private wordTextCache = new Map<string, { text: string; tokenCount: number }>();`.
    *   **New IPC Handler (`RequestWordToText`):**
        *   This handler will receive a file path. It will first check the cache.
        *   **If `.doc`:** It will cache an "Unsupported Format" message and a token count of 0, then notify the client.
        *   **If `.docx`:** It will read the file buffer and attempt to parse it with `mammoth.extractRawText()`.
        *   **Success:** On success, it will calculate the token count, store the result in the cache, and send the stats to the client.
        *   **Failure:** The `try...catch` block will inspect the error. If the error message indicates a corrupted file (e.g., from `jszip`), it will create a specific, user-friendly error message and send that to the client with a token count of 0.

3.  **Frontend (`view.tsx`):**
    *   **On-Demand Extraction:** The logic for handling checked files and restored selections will be updated to send a `RequestWordToText` message to the backend for `.docx` and `.doc` files.

4.  **Backend (`flattener.service.ts`):**
    *   **Virtual Content Retrieval:** The flattener will retrieve the text from the `wordTextCache` in the `FSService` instead of reading the binary file. It will correctly handle the "Unsupported Format" and "Corrupted File" messages from the cache.
</file>

<file path="src/Artifacts/A45. DCE - Phase 2 - Pop-out Co-Pilot Window - Feature Plan.md">
# Artifact A45: DCE - Phase 2 - Pop-out Co-Pilot Window - Feature Plan
# Date Created: C76
# Author: AI Model
# Updated on: C78 (Reflect implementation of WebviewPanel)

- **Key/Value for A0:**
- **Description:** Outlines the technical strategy to allow the Parallel Co-Pilot panel to be "popped out" into a separate window by re-implementing it as a main editor WebviewPanel.
- **Tags:** feature plan, phase 2, pop-out, window, webview, ux

## 1. Overview & Goal

The Parallel Co-Pilot panel is designed for intensive, side-by-side comparison of code, a task that benefits greatly from maximum screen real estate. Many developers use multiple monitors and would prefer to move this panel to a secondary display. The goal of this feature is to enable the user to "pop out" the Parallel Co-Pilot panel into its own floating window.

## 2. Problem & Proposed Solution

A direct `popOut()` API for a sidebar webview does not exist in the VS Code extension API. The most robust and user-friendly way to achieve this is to leverage a native VS Code feature: users can drag any editor tab into its own floating window.

Therefore, the proposed solution is to **re-architect the Parallel Co-Pilot from a sidebar view (`WebviewViewProvider`) into a main editor view (`WebviewPanel`)**.

### 2.1. User Experience Flow

1.  The user runs the `DCE: Open Parallel Co-Pilot` command from the Command Palette or clicks the icon in the Activity Bar.
2.  Instead of opening in the sidebar, the Parallel Co-Pilot panel opens as a new tab in the main editor group.
3.  The user can then click and drag this tab out of the main VS Code window, and it will become its own floating window, which can be moved to another monitor.

## 3. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| P2-WIN-01 | **Open Co-Pilot in Main Editor**| As a developer, I want a command or button to open the Parallel Co-Pilot panel in a main editor tab, so I have more horizontal space to view and compare responses. | - A command `DCE: Open Parallel Co-Pilot` exists. <br> - An icon in the activity bar triggers this command. <br> - Executing the command opens a new editor tab containing the full Co-Pilot UI. <br> - If the panel is already open, the command brings it into focus. |
| P2-WIN-02 | **Move Co-Pilot to New Window** | As a developer with multiple monitors, after opening the Co-Pilot in an editor tab, I want to drag that tab out of my main VS Code window to turn it into a separate, floating window, so I can place it on my second monitor. | - The Co-Pilot editor tab behaves like any other editor tab. <br> - It can be dragged to create new editor groups or dragged outside the main window to create a new floating window. |

## 4. Technical Implementation Plan (C78)

This is a significant architectural change that has been implemented.

1.  **Remove Sidebar Contribution (`package.json`):**
    *   The `dce-parallel-copilot` entry in `contributes.viewsContainers.activitybar` still exists to provide an entry point icon, but the view is no longer directly registered under `contributes.views`.

2.  **Create a `WebviewPanel` (`extension.ts`):**
    *   A new command, `dce.openParallelCopilot`, is registered.
    *   A module-level variable (`private static parallelCopilotPanel: vscode.WebviewPanel | undefined;`) is used to track the panel's instance, ensuring only one can exist.
    *   When the command is executed, it checks if the panel already exists. If so, it calls `panel.reveal()`.
    *   If not, it calls `vscode.window.createWebviewPanel`. This creates the webview in an editor tab.
    *   The panel's `onDidDispose` event is used to clear the static instance variable.
    *   The logic for setting the webview's HTML, options, and message handlers is now managed within this command's callback.

3.  **State Management:**
    *   Because the panel is now created on-demand, its state (tab content, cycle number) must be managed in a backend service to be restored if the panel is closed and reopened. This is a future enhancement. For now, the state is ephemeral to the panel's lifecycle.
</file>

<file path="src/Artifacts/A46. DCE - Phase 2 - Paste and Parse Response - Feature Plan.md">
# Artifact A46: DCE - Phase 2 - Paste and Parse Response - Feature Plan
# Date Created: C76
# Author: AI Model

- **Key/Value for A0:**
- **Description:** Details the plan for allowing users to paste a full AI response into a tab, which the extension will then parse to identify file paths referenced within XML tags.
- **Tags:** feature plan, phase 2, paste, parse, workflow, automation

## 1. Overview & Goal

The manual workflow for using the Parallel Co-Pilot involves copying an entire AI response and pasting it into one of the response tabs. These responses often contain multiple file updates, each wrapped in XML-like tags (e.g., `<file path="...">...</file>`). The goal of this feature is to make the extension "intelligent" about this pasted content. It should automatically parse the text, identify the files being modified, and associate them with the response tab.

## 2. User Story

| ID | User Story | Acceptance Criteria |
|---|---|---|
| P2-PARSE-01 | **Parse Pasted Content** | As a developer, when I paste a full AI response into a tab, I want the extension to automatically detect the file paths mentioned in the `<file>` tags, so I can see a list of affected files and use them for "Swap" and "Diff" operations. | - Pasting text into a response tab's editor triggers a parsing event. <br> - The extension uses a regular expression to find all occurrences of `<file path="...">`. <br> - The extracted file paths are stored in the state for that tab. <br> - The UI for the tab is updated to display the list of detected files. |
| P2-PARSE-02 | **Set Primary Source File** | As a developer, after pasting a response with multiple files, I want the first file detected to be automatically set as the primary "source file" for the "Swap" and "Diff" actions, so I don't have to select it manually. | - After parsing, if the tab's `sourceFilePath` is not already set, it is automatically populated with the path of the first file found in the pasted content. <br> - The metadata table (comparing original vs. response) updates accordingly. |

## 3. Technical Implementation Plan

1.  **Frontend Logic (`parallel-copilot.view/view.tsx`):**
    *   **Event Handler:** An `onPaste` event handler will be added to the `<textarea>` or code editor component for each tab.
    *   **Parsing Function:** A new utility function, `parseFilePathsFromResponse(text: string): string[]`, will be created.
        *   It will use a regular expression: `/<file path="([^"]+)">/g`.
        *   It will execute this regex on the input text to extract all captured file paths.
    *   **State Update:**
        *   Inside the `onPaste` handler, it will call `event.clipboardData.getData('text')` to get the pasted content.
        *   It will pass this content to the `parseFilePathsFromResponse` function.
        *   The resulting array of paths will be stored in the state for the active tab (e.g., in a new `detectedFiles: string[]` property).
        *   If the tab's primary `sourceFilePath` is empty, it will be set to the first path in the array.

2.  **UI Update (`parallel-copilot.view/view.tsx`):**
    *   A new UI element will be added to each tab's content area.
    *   It will conditionally render if `detectedFiles` has items.
    *   It will display a list of the detected file paths, perhaps as clickable links that could set the active `sourceFilePath` for the tab.

3.  **No Backend Changes:** This feature is entirely a frontend concern, involving UI event handling, string parsing, and state management within the React component.
</file>

<file path="src/Artifacts/A47. DCE - Phase 2 - Prompt Amalgamation Feature Plan.md">
# Artifact A47: DCE - Phase 2 - Prompt Amalgamation Feature Plan
# Date Created: C82
# Author: AI Model

- **Key/Value for A0:**
- **Description:** Details the plan for a "Generate prompt.md" button that will assemble the static schemas, cycle history, and flattened code into a single, complete prompt file.
- **Tags:** feature plan, phase 2, prompt engineering, automation, workflow

## 1. Overview & Goal

The process of constructing the final `prompt.md` file is a core part of the curator's workflow. It involves manually assembling several distinct pieces of content: static schemas, the cycle history, and the dynamically generated `flattened_repo.md`. This is a repetitive and error-prone task. The goal of this feature is to automate this process with a single button click, generating a complete, perfectly formatted `prompt.md` file on demand.

## 2. User Story

| ID | User Story | Acceptance Criteria |
|---|---|---|
| P2-PROMPT-01 | **Generate Complete Prompt** | As a curator, I want to click a button to generate a complete `prompt.md` file that includes all my standard schemas, the project's cycle history, and the latest flattened code, so I can start my next development cycle with zero manual setup. | - A "Generate `prompt.md`" button is available in the Parallel Co-Pilot Panel UI. <br> - A "Cycle Title" input field is available next to the cycle navigator. <br> - Clicking the button creates or overwrites `prompt.md` in the workspace root. <br> - The generated file has the correct structure: static schemas, then the dynamic cycle overview, then the content of `flattened_repo.md`. <br> - The cycle overview is built from the `dce_history.json` file and includes the title from the new input field. |

## 3. Technical Implementation Plan

1.  **UI (`parallel-copilot.view/view.tsx`):**
    *   Add a "Generate `prompt.md`" button to the main header toolbar.
    *   Add a new state variable and a corresponding `<input type="text">` element for the "Cycle Title" next to the cycle navigator.
    *   The button's `onClick` handler will send a new IPC message to the backend.

2.  **IPC Channels:**
    *   `ClientToServerChannel.RequestCreatePromptFile`: Payload will be `{ cycleTitle: string, currentCycle: number }`.

3.  **Backend (New `prompt.service.ts`):**
    *   Create a new `PromptService` to encapsulate the logic.
    *   **Static Templates:** The service will contain private string constants holding the content for `<M1. artifact schema>`, `<M3. Interaction Schema>`, and `<M4. current project scope>`.
    *   **`generatePromptFile` Method:** This method will be the core of the service.
        1.  It will receive the `cycleTitle` and `currentCycle` from the IPC message.
        2.  It will read the `dce_history.json` file (using `HistoryService`) to build the `<M2. cycle overview>` section dynamically.
        3.  It will read the entire content of `flattened_repo.md`.
        4.  It will assemble these strings in the correct order into a single, large string.
        5.  It will write this final string to `prompt.md` in the workspace root using `vscode.workspace.fs.writeFile`.
        6.  It will show a `showInformationMessage` to confirm completion.

4.  **Integration:**
    *   The new `PromptService` will be instantiated in `services.ts`.
    *   A new handler for `RequestCreatePromptFile` will be added to the `on-message.ts` for the Parallel Co-Pilot view, which will call the `PromptService`.
</file>

<file path="src/Artifacts/A48. DCE - Phase 2 - Advanced Syntax Highlighting Plan.md">
# Artifact A48: DCE - Phase 2 - Advanced Syntax Highlighting Plan
# Date Created: C82
# Author: AI Model
# Updated on: C90 (Update plan to reflect implementation)

## 1. Overview & Goal

AI-generated responses are complex documents, containing both explanatory Markdown text and code blocks in various languages. A plain `<textarea>` element does not provide any syntax highlighting, making these responses difficult to read and analyze. The goal of this feature is to significantly enhance the readability of AI responses by replacing the textareas with a proper code editor component that can provide rich, language-aware syntax highlighting.

## 2. User Story

| ID | User Story | Acceptance Criteria |
|---|---|---|
| P2-SYNTAX-01 | **View Highlighted Responses** | As a developer, I want to see AI responses with full syntax highlighting inside the Parallel Co-Pilot tabs, so I can easily distinguish between comments, keywords, and code, just like in a real editor. | - The content area of each response tab renders with syntax highlighting. <br> - Standard Markdown elements (headers, lists, bold, italics, backticks) are formatted correctly. <br> - Code blocks (e.g., ` ```typescript ... ``` `) are highlighted with the correct grammar for the specified language. <br> - The highlighting should be theme-aware, matching the user's current VS Code theme. |

## 3. Technical Implementation Strategy (C90)

### 3.1. Chosen Library: `starry-night`

After research and consideration of alternatives like `refractor`, **`@wooorm/starry-night`** is the chosen library for syntax highlighting.

-   **Rationale (C85):**
    -   **High Fidelity:** It uses the same TextMate grammars as VS Code itself. This is the most important factor, as it ensures the highlighting in our panel will be a perfect visual match to the user's native editor experience.
    -   **Backend Architecture:** Our implementation performs highlighting on the backend (in the Node.js extension host) and sends pre-rendered HTML to the frontend webview. This means the primary drawback of `starry-night`â€”its large bundle sizeâ€”is a non-issue for the client. The "heavy lifting" is done by the extension's server-side process, keeping the webview lightweight and performant.

### 3.2. Implementation Plan

1.  **Dependencies (`package.json`):**
    *   `@wooorm/starry-night` is the core backend dependency.
    *   `hast-util-to-html` is used to convert the abstract syntax tree to an HTML string.
    *   `react-markdown` is added as a frontend dependency to handle the rendering of non-code markdown content (lists, bold, etc.).

2.  **Backend (`fs.service.ts`):**
    *   The `handleSyntaxHighlightRequest({ code, lang, id })` method is implemented.
    *   It initializes `starry-night` with a set of common grammars.
    *   It uses `starryNight.highlight(code, scope)` where `scope` is determined from the language identifier (e.g., 'typescript' -> 'source.ts').
    *   It converts the resulting `hast` tree to an HTML string using `toHtml`.
    *   This HTML string is sent back to the client via the `SendSyntaxHighlight` IPC channel, including the `id` to match the request.

3.  **IPC Channels:**
    *   `ClientToServerChannel.RequestSyntaxHighlight`: Payload `{ code: string; lang: string, id: string }`.
    *   `ServerToClientChannel.SendSyntaxHighlight`: Payload `{ highlightedHtml: string, id: string }`.

4.  **Frontend (`parallel-copilot.view/view.tsx`):**
    *   After a response is parsed into `parsedContent`, the view iterates through `parsedContent.files`.
    *   For each file block, it sends a `RequestSyntaxHighlight` message to the backend.
    *   A state map (`highlightedCodeBlocks: Map<string, string>`) caches the HTML returned from the backend.
    *   The component that renders the file's code uses `dangerouslySetInnerHTML` to display the highlighted HTML.
    *   The `summary` and `courseOfAction` sections are rendered using the `<ReactMarkdown>` component to display formatted text.
</file>

<file path="src/Artifacts/A49. DCE - Phase 2 - File Association & Diffing Plan.md">
# Artifact A49: DCE - Phase 2 - File Association & Diffing Plan
# Date Created: C82
# Author: AI Model
# Updated on: C102 (Development paused for A/B/C testing strategy)

- **Key/Value for A0:**
- **Description:** Plans the UI and backend logic to visually link file blocks in an AI response to workspace files and sets the stage for an integrated diff tool.
- **Tags:** feature plan, phase 2, ui, ux, diff, file association

## 1. Overview & Goal

To make the "Swap with Source" feature trustworthy and intuitive, users need a clear visual confirmation of which local file an AI-generated code block is intended to replace. This feature introduces a "file association" mechanism that parses AI responses, verifies the existence of the mentioned files, and displays this status to the user.

**Update (C102):** Development on this feature is temporarily paused. The core `onClick` event handler for the "Associated Files" list is non-functional due to a persistent, unidentified bug. All efforts are now redirected to the **A/B/C Testing Strategy** (see A51) to resolve this foundational issue before re-introducing the complexity of diffing or single-file viewing.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| P2-ASSOC-01 | **See Affected Files** | As a developer, when I parse an AI response, I want the extension to automatically show me a list of all the file paths it intends to modify, so I can understand the scope of the proposed changes. | - After parsing, a collapsible "Associated Files" section appears in the tab's UI. <br> - This section displays a list of all file paths found in the response. |
| P2-ASSOC-02 | **Verify File Existence** | As a developer, for each file listed, I want to see a visual indicator of whether that file already exists in my workspace, so I can spot potential errors or new files proposed by the AI. | - Next to each listed file path, an icon is displayed. <br> - A green checkmark (`âœ“`) indicates the file exists at that path. <br> - A red cross (`âœ—`) indicates the file does not exist. |
| P2-ASSOC-03 | **Preview AI Code (Stage 1)** | As a developer, I want to click on an existing file in the "Associated Files" list to immediately see a syntax-highlighted view of the AI's proposed code, so I can review the changes. | - Clicking a file with a `âœ“` in the list opens a single-pane view in the right-hand panel. <br> - This view displays only the AI's proposed code, with full syntax highlighting. <br> - The view automatically loads with the *first valid file* upon parsing. |
| P2-ASSOC-04 | **Preview Changes with Diff (Stage 2)** | As a developer, after Stage 1 is complete, I want the view to be enhanced to show a side-by-side comparison of the original file and the AI's proposed changes, so I can review the exact changes before swapping. | - The single-pane view is replaced with a two-pane diff component. <br> - The diff view clearly shows added, removed, and common lines. |

## 3. Technical Implementation Plan (Paused)

1.  **Frontend - Parsing (`response-parser.ts`):**
    *   **Status:** **Complete.**

2.  **Backend - Verification & Highlighting (`fs.service.ts`):**
    *   **Status:** **Complete.** The `handleFileExistenceRequest` and `handleSyntaxHighlightRequest` handlers are working.

3.  **Frontend - UI & State (`view.tsx`):**
    *   **Status:** **Blocked.**
    *   **Root Cause:** The `onClick` handler on the `<li>` elements in the "Associated Files" list is not firing. The root cause is unknown and has resisted multiple debugging attempts.
    *   **Next Steps:** Implement the A/B/C Testing Strategy from `A51`. Create multiple, simplified test components to isolate the bug. Once a working click handler is achieved in one of the test panes, its implementation pattern will be used to rebuild this feature.
</file>

<file path="src/Artifacts/A5. DCE - Target File Structure.md">
# Artifact A5: DCE - Target File Structure
# Date Created: Cycle 3
# Author: AI Model

- **Description:** A text-based representation of the target file structure for the DCE extension, outlining the layout of directories and key files.
- **Tags:** file structure, architecture, project layout, scaffolding

## 1. Overview

This document provides a visual representation of the file structure that the `A6. DCE - Initial Scaffolding Deployment Script` will create. It is based on the robust and scalable architecture of the `The-Creator-AI-main` reference repository, as detailed in `A3. DCE - Technical Scaffolding Plan`.

## 2. File Tree

```
DCE/
â”œâ”€â”€ .gitignore
â”œâ”€â”€ .vscodeignore
â”œâ”€â”€ package.json
â”œâ”€â”€ tsconfig.json
â”œâ”€â”€ webpack.config.js
â”œâ”€â”€ public/
â”‚   â””â”€â”€ spiral.svg
â””â”€â”€ src/
    â”œâ”€â”€ backend/
    â”‚   â”œâ”€â”€ commands/
    â”‚   â”‚   â”œâ”€â”€ commands.ts
    â”‚   â”‚   â””â”€â”€ register-commands.ts
    â”‚   â”œâ”€â”€ repositories/
    â”‚   â”‚   â””â”€â”€ persistent-store.repository.ts
    â”‚   â”œâ”€â”€ services/
    â”‚   â”‚   â”œâ”€â”€ fs.service.ts
    â”‚   â”‚   â”œâ”€â”€ services.ts
    â”‚   â”‚   â””â”€â”€ flattener.service.ts
    â”‚   â””â”€â”€ types/
    â”‚       â””â”€â”€ storage-keys.enum.ts
    â”‚
    â”œâ”€â”€ client/
    â”‚   â”œâ”€â”€ components/
    â”‚   â”‚   â””â”€â”€ file-tree/
    â”‚   â”‚       â”œâ”€â”€ FileTree.tsx
    â”‚   â”‚       â””â”€â”€ FileTree.utils.ts
    â”‚   â”œâ”€â”€ views/
    â”‚   â”‚   â”œâ”€â”€ context-chooser.view/
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ on-message.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ view.scss
    â”‚   â”‚   â”‚   â””â”€â”€ view.tsx
    â”‚   â”‚   â””â”€â”€ index.ts
    â”‚   â””â”€â”€ store/
    â”‚       â”œâ”€â”€ store.ts
    â”‚       â””â”€â”€ useStore.ts
    â”‚
    â”œâ”€â”€ common/
    â”‚   â”œâ”€â”€ ipc/
    â”‚   â”‚   â”œâ”€â”€ channels.enum.ts
    â”‚   â”‚   â”œâ”€â”€ channels.type.ts
    â”‚   â”‚   â”œâ”€â”€ client-ipc.ts
    â”‚   â”‚   â”œâ”€â”€ get-vscode-api.ts
    â”‚   â”‚   â””â”€â”€ server-ipc.ts
    â”‚   â”œâ”€â”€ types/
    â”‚   â”‚   â”œâ”€â”€ file-node.ts
    â”‚   â”‚   â””â”€â”€ vscode-webview.d.ts
    â”‚   â””â”€â”€ utils/
    â”‚       â””â”€â”€ view-html.ts
    â”‚
    â””â”€â”€ extension.ts
```
</file>

<file path="src/Artifacts/A50. DCE - Phase 2 - UI Component Plan (Resizable Panes & Inner Editors).md">
# Artifact A50: DCE - Phase 2 - UI Component Plan (Resizable Panes & Inner Editors)
# Date Created: C87
# Author: AI Model
# Updated on: C112 (Prioritize resizable panes implementation)

- **Key/Value for A0:**
- **Description:** Documents the plan for advanced UI components like resizable panes and nested, scrollable editors within the Parallel Co-Pilot panel.
- **Tags:** feature plan, phase 2, ui, ux, resizable, scrollable, editor

## 1. Overview & Goal

As the Parallel Co-Pilot Panel (PCPP) becomes more feature-rich, its UI needs to be flexible and efficient. This document outlines the plan for two advanced UI components: a **resizable pane** for the summary/code view and a system of **nested, scrollable "inner editors"** for individual file blocks within a response. The goal is to create a highly readable and customizable interface that prevents "endless scrolling" and allows users to focus on the information that matters most to them.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| P2-UI-01 | **Resizable Panes** | As a developer, I want to be able to drag the vertical divider between the summary/file list pane and the code viewer pane, so I can give more space to the view that is most important for my current task. | - A draggable handle exists on the vertical divider between the two main panes in the parsed view. <br> - Clicking and dragging the handle adjusts the relative width of the two panes. <br> - The layout is responsive and does not break during resizing. <br> - The left pane should be collapsible. |
| P2-UI-02 | **Contained File Editors** | As a developer, when viewing a large AI response with multiple files, I want each file's code to be contained within its own fixed-height, scrollable text area, so I can quickly scroll past entire files without having to scroll through all of their content. | - The extension parses the AI response and identifies individual file blocks (e.g., content within `<file>` tags). <br> - Each file block is rendered inside its own container with a fixed `max-height` and `overflow-y: auto`. <br> - This allows the user to scroll through the list of files quickly, only scrolling within a specific file's content when needed. |
| P2-UI-03 | **File-Level Action Buttons** | As a developer, I want action buttons (like "Accept", "Diff", "Comment") to be associated with each individual file block within a response, so I can act on a single file at a time. | - In the "inner editor" view, each file container has its own set of action buttons. <br> - Clicking "Accept" on one file block only affects that specific file, not the entire response. |

## 3. Technical Implementation Plan

### 3.1. Resizable Panes (Priority for C112)

-   **Strategy:** Implement a custom, lightweight resizable pane component directly within `view.tsx`.
-   **Component Logic:**
    *   The main `.parsed-view-grid` will be the flex container.
    *   A new `div` element with a `.resizer` class will be added between the left and right panes to act as the draggable handle.
    *   **State:** A new state variable, `const [leftPaneWidth, setLeftPaneWidth] = useState(33);`, will manage the width of the left pane as a percentage.
    *   **Event Handling:**
        *   The resizer `div` will have an `onMouseDown` handler.
        *   This handler will attach `onMouseMove` and `onMouseUp` listeners to the `window`.
        *   The `onMouseMove` handler will calculate the new percentage width based on `event.clientX` and update the `leftPaneWidth` state, respecting min/max width constraints.
        *   The `onMouseUp` handler will remove the `mousemove` and `mouseup` listeners from the window.
-   **Integration:** The `style` attribute of the left pane will be bound to this state (e.g., `flex-basis: `${leftPaneWidth}%`).

### 3.2. Inner Editors / Contained File Blocks (Future Cycle)

-   **Strategy:** This requires a significant change to how the response content is rendered. Instead of treating the response as a single block of text to be rendered as Markdown, it must be parsed into a structured array of objects.
-   **Parsing Logic (`view.tsx`):**
    -   A new parsing function will take the raw response string and split it into an array of segments, e.g., `[{ type: 'markdown', content: '...' }, { type: 'file', path: '...', content: '...' }, ...]`.
-   **Rendering Logic (`view.tsx`):**
    -   The main render function will map over this array of segments.
    -   If `segment.type === 'markdown'`, it renders the content as before.
    -   If `segment.type === 'file'`, it renders a new component, e.g., `FileBlock.tsx`.
-   **`FileBlock.tsx` Component:**
    -   This component will be responsible for rendering a single file from the AI response.
    -   It will have a header displaying the file path and the file-specific action buttons (Accept, Diff, etc.).
    -   The main content area will be a `div` with CSS properties `max-height: 300px;` (or similar) and `overflow-y: auto;`.
    -   The code content within this `div` will be syntax-highlighted as before.
</file>

<file path="src/Artifacts/A51. DCE - A-B-C Testing Strategy for UI Bugs.md">
# Artifact A51: DCE - A-B-C Testing Strategy for UI Bugs
# Date Created: C102
# Author: AI Model & Curator
# Updated on: C103 (Refine to "Original-A-B-C" parallel testing model)

- **Key/Value for A0:**
- **Description:** Outlines a development pattern for creating parallel, isolated test components to diagnose and resolve persistent UI bugs, such as event handling or rendering issues.
- **Tags:** process, debugging, troubleshooting, ui, ux, react

## 1. Overview & Goal

When a user interface (UI) bug, particularly related to event handling (`onClick`, `onDrop`, etc.) or component rendering, proves resistant to conventional debugging, it often indicates a complex or non-obvious root cause. Continuously attempting small, incremental fixes on the main, complex component can be inefficient and can lead to regressions.

The goal of the **"Original-A-B-C" Testing Strategy** is to break this cycle by creating a test harness that runs the original, complex component in parallel with multiple, simplified, independent test components. Each test component attempts to solve the same basic problem using a slightly different technical approach, allowing for rapid diagnosis.

## 2. The Strategy

### 2.1. Core Principles
1.  **Preserve the Original:** Never gut or remove existing, working functionality to build a test case. The original component should remain available as the "control" in the experiment.
2.  **Isolate Variables:** Each test case should be as simple as possible, designed to test a single variable (e.g., raw event handling, local state updates, prop drilling).
3.  **Run in Parallel:** The original component and all test components should be accessible from the same UI, typically via a simple tab switcher, allowing for immediate comparison.

### 2.2. Steps
1.  **Identify the Core Problem:** Isolate the most fundamental action that is failing (e.g., "A click on a list item is not being registered").
2.  **Create Test Harness:** Refactor the main view to act as a "test harness."
    *   Introduce a top-level state to control which view is active (e.g., `activeView: 'Original' | 'TestA' | 'TestB'`).
    *   Create a simple tab bar UI to switch this state.
    *   Encapsulate the existing, complex component so it can be rendered when `activeView === 'Original'`.
3.  **Lift Necessary State:** Identify the minimum state required for the test components to function (e.g., `parsedContent`). Lift this state up to the test harness level. The "Original" component can then pass data up to the harness via a callback prop.
4.  **Implement Isolated Test Components:** Create new, simple components for each test case, which receive the shared state as props.
    *   **Test A (Barebones):** The simplest possible implementation. Use raw HTML elements with inline event handlers that only `logger.log()`.
    *   **Test B (Local State):** Introduce `useState` to test the component's ability to manage its own state and re-render on an event.
    *   **Test C (Prop-Driven):** Use a child component that calls a function passed down via props, testing the prop-drilling pattern.
5.  **Analyze Results:** Interact with each tab to see which implementation succeeds, thereby isolating the architectural pattern that is failing.

## 3. Cleanup Process

Once a working pattern is identified in a test component:
1.  **Codify Findings:** Document the successful pattern and the root cause of the failure in a relevant artifact (e.g., `A11. Regression Case Studies`).
2.  **Integrate Solution:** Refactor the "Original" component to use the successful pattern.
3.  **Remove Test Artifacts:**
    *   Remove the test harness tabs and view-switching logic from the main view component.
    *   Delete the temporary `TestPane*.tsx` component files.
    *   Remove any extra styling related to the test harness from the SCSS file.

## 4. Sample Test Data for Parser

To ensure consistent testing of the PCPP parser, use the following sample raw response. Paste this into a response tab in the "Original" view and click "Parse All".

```
I've analyzed the request and the provided context. The main goal is to add a new test harness to the Parallel Co-Pilot panel without removing the existing functionality. This involves refactoring `view.tsx` to support multiple, switchable views.

### Course of Action

1.  **Update Documentation:** I will first update `A51` to reflect the new "Original-A-B-C" parallel testing strategy.
2.  **Refactor `view.tsx`:** I will refactor the main component into a test harness that can switch between the original view and the new test panes.
3.  **Re-supply Test Panes:** I will provide the code for the three isolated test panes again.

### Files Updated This Cycle:
*   `A51. DCE - A-B-C Testing Strategy for UI Bugs.md` (Updated)
*   `src/client/views/parallel-copilot.view/view.tsx` (Updated)
*   `src/client/views/parallel-copilot.view/view.scss` (Updated)

<file path="src/client/views/parallel-copilot.view/view.tsx">
// This is a sample file content block.
// It will be parsed and displayed.
import * as React from 'react';

const TestComponent = () => {
    return <div>Hello, World!</div>;
};

export default TestComponent;
</file>
<file path="src/client/views/parallel-copilot.view/view.scss">
/* This is a sample SCSS file content block. */
.test-harness-tabs {
    display: flex;
    border-bottom: 1px solid var(--vscode-panel-border);
}
```
</file>

<file path="src/Artifacts/A52. DCE - Interaction Schema Refinement.md">
# Artifact A52: DCE - Interaction Schema Refinement
# Date Created: C110
# Author: AI Model & Curator
# Updated on: C126 (Specify case-insensitive header parsing)

- **Key/Value for A0:**
- **Description:** Proposes a set of refined rules for the AI's output format to improve the reliability and consistency of automated parsing within the Parallel Co-Pilot Panel.
- **Tags:** documentation, process, parsing, interaction schema, roadmap

## 1. Overview & Goal

The Parallel Co-Pilot Panel (PCPP) relies on parsing the AI's output to provide features like file association, diffing, and syntax highlighting. Analysis of historical cycle data reveals that the AI's output format has drifted over time, using multiple conventions for headers and file blocks. This inconsistency makes the parser complex and brittle.

The goal of this artifact is to define a refined, stricter set of rules for the AI's output. By codifying a canonical format, we make the parser's job simpler and more reliable, improving the overall robustness of the PCPP. This document contains the proposed changes to be integrated into the main `M3. Interaction Schema`.

## 2. Proposed Changes to `M3. Interaction Schema`

### 2.1. Standardized Response Structure

To ensure predictable parsing, all responses must adhere to the following structure and order:

1.  **Summary/Plan:** The response must begin with a high-level summary, thoughts, or plan. This section ends at the first occurrence of a standardized header.
2.  **Course of Action Header:** This section must begin with a markdown header like `### Course of Action`. **(C126 Update)** The parser will treat this header case-insensitively (e.g., `### Course of action` is also valid).
3.  **Files Updated Header:** This section must begin with the exact markdown header: `### Files Updated This Cycle:`.
4.  **File Blocks:** The response must conclude with the code/document artifact blocks.

### 2.2. Canonical File Block Format

To eliminate ambiguity, all file and document artifacts must be enclosed in the following canonical format:

```xml
<file path="path/to/your/file.ext">
[... file content ...]
</file>
```

**Rules for File Blocks:**
*   The opening tag **must** be `<file path="...">`. The path must be a relative path from the project root, using forward slashes (`/`).
*   The closing tag **must** be `</file>`.
*   Formats where the file path is the tag name (e.g., `<src/main.ts>...`) are now deprecated and should not be used.
*   The surrounding triple-backtick code fences (e.g., ` ```xml ... ``` `) are optional but recommended for readability. The parser will handle their presence or absence.

### 2.3. Standardized "Files Updated" List Format

The list of files under the `### Files Updated This Cycle:` header must follow this format:

```
* `path/to/file.ext` (Status)
```

**Rules for Files Updated List:**
*   Each item must be a markdown list item (starting with `*` or `-`).
*   The file path **must** be enclosed in backticks (`` ` ``).
*   The status (e.g., `(Updated)`, `(New)`, `(Deleted)`) is optional but recommended. The parser will be designed to ignore it.

## 3. Rationale

By enforcing this stricter contract on the AI's output, we significantly reduce the complexity of the `response-parser.ts`. The parser no longer needs multiple, complex regular expressions to account for numerous format variations. This leads to:
*   **Increased Reliability:** Parsing is less likely to fail on subtle format changes.
*   **Improved Maintainability:** The parser code becomes simpler and easier to understand.
*   **Predictable Behavior:** The PCPP's features will behave more consistently across all responses.
</file>

<file path="src/Artifacts/A53. DCE - Phase 2 - Token Count and Similarity Analysis.md">
# Artifact A53: DCE - Phase 2 - Token Count and Similarity Analysis
# Date Created: C112
# Author: AI Model & Curator

- **Key/Value for A0:**
- **Description:** Details the plan to implement token counting for raw and parsed responses, and to calculate a similarity score between AI-generated files and their workspace originals.
- **Tags:** feature plan, phase 2, token count, similarity, metrics, ui, ux

## 1. Overview & Goal

To enhance the curator's decision-making process, the Parallel Co-Pilot Panel (PCPP) must provide quantitative metrics about the AI's responses. The goal of this feature is to display token counts for various pieces of content and a similarity score to gauge the extent of changes proposed by the AI. This allows the user to quickly assess response verbosity, parser effectiveness, and the magnitude of code modifications.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| P2-MET-01 | **Raw Response Token Count** | As a user, I want to see the total token count of the raw AI response I've pasted, so I can understand the overall size of the output. | - A token count is displayed for the raw content in each response tab. <br> - This count updates in real-time as I type or paste content. |
| P2-MET-02 | **Parsed vs. Original Token Count** | As a user, when viewing a parsed file, I want to see a comparison of the token count between the original workspace file and the AI's new version, so I can quickly see if the code is growing or shrinking. | - In the header of the code viewer pane, the token counts for both the original and new versions of the selected file are displayed (e.g., "Original: 4.1K | New: 4.2K"). |
| P2-MET-03 | **File Similarity Score** | As a user, along with the token counts, I want to see a percentage-based similarity score, so I can gauge how substantially the AI has altered the file. | - A similarity score (e.g., "Sim: 98%") is displayed in the code viewer header. <br> - A score of 100% indicates identical files. <br> - A low score indicates a major rewrite. |

## 3. Technical Implementation Plan

### Phase 1: UI Placeholders (Current Cycle)

1.  **`parallel-copilot.view/view.tsx`:**
    *   Add placeholder elements in the UI to display the token counts and similarity score.
    *   Raw response token count: Calculate and display this on the frontend via `rawContent.length / 4`.
    *   Parsed file metrics: Display static placeholder text in the code viewer header.

### Phase 2: Backend Logic & Integration (Future Cycle)

1.  **New IPC Channel:**
    *   Create `ClientToServerChannel.RequestFileComparison`.
    *   Payload: `{ filePath: string; modifiedContent: string; }`.
    *   Response channel: `ServerToClientChannel.SendFileComparison`.
    *   Payload: `{ originalTokens: number; modifiedTokens: number; similarity: number; }`.

2.  **Backend (`fs.service.ts`):**
    *   Implement `handleFileComparisonRequest`.
    *   It will read the content of the original `filePath` from the workspace.
    *   It will calculate the token count for the original content.
    *   It will calculate the token count for the `modifiedContent` received in the payload.
    *   It will compute a similarity score. A simple and effective algorithm for this is the **SÃ¸rensen-Dice coefficient** on sets of n-grams (e.g., 2-grams) from each string.
    *   It will send the results back to the client via `SendFileComparison`.

3.  **Frontend (`parallel-copilot.view/view.tsx`):**
    *   When a file is selected for viewing (`setSelectedFilePath`), send the `RequestFileComparison` message.
    *   Create new state variables to hold the comparison results: `const [comparisonMetrics, setComparisonMetrics] = useState(null);`.
    *   The message handler for `SendFileComparison` will update this state.
    *   The UI will be updated to render the live data from the `comparisonMetrics` state instead of the placeholders.
</file>

<file path="src/Artifacts/A54. starry-night-readme.md">
[![](media/cover-dark.jpg)](https://artsandculture.google.com/asset/the-starry-night/bgEuwDxel93-Pg#gh-dark-mode-only)
[![](media/cover-light.jpg#gh-dark-mode-only)](https://artsandculture.google.com/asset/the-starry-night/bgEuwDxel93-Pg#gh-light-mode-only)

<p align="center">Close up of <b>The Starry Night</b> by Vincent van Gogh (1889)<br>with examples of <code>starry-night</code> over it</p>

<br>

# starry-night

[![Build][badge-build-image]][badge-build-url]
[![Coverage][badge-coverage-image]][badge-coverage-url]
[![Downloads][badge-downloads-image]][badge-downloads-url]
[![Size][badge-size-image]][badge-size-url]

Syntax highlighting,
like what GitHub uses to highlight code,
but free and open source and JavaScript!

## Contents

* [What is this?](#what-is-this)
* [When should I use this?](#when-should-i-use-this)
* [What is `PrettyLights`?](#what-is-prettylights)
* [Install](#install)
* [Use](#use)
* [API](#api)
  * [`all`](#all)
  * [`common`](#common)
  * [`createStarryNight(grammars[, options])`](#createstarrynightgrammars-options)
  * [`starryNight.flagToScope(flag)`](#starrynightflagtoscopeflag)
  * [`starryNight.highlight(value, scope)`](#starrynighthighlightvalue-scope)
  * [`starryNight.missingScopes()`](#starrynightmissingscopes)
  * [`starryNight.register(grammars)`](#starrynightregistergrammars)
  * [`starryNight.scopes()`](#starrynightscopes)
  * [`GetOnigurumaUrl`](#getonigurumaurl)
  * [`Grammar`](#grammar)
  * [`Options`](#options)
* [Examples](#examples)
  * [Example: serializing hast as html](#example-serializing-hast-as-html)
  * [Example: using `starry-night` on the client](#example-using-starry-night-on-the-client)
  * [Example: turning hast into react nodes](#example-turning-hast-into-react-nodes)
  * [Example: adding line numbers](#example-adding-line-numbers)
  * [Example: integrate with unified, remark, and rehype](#example-integrate-with-unified-remark-and-rehype)
  * [Example: integrating with `markdown-it`](#example-integrating-with-markdown-it)
* [Syntax tree](#syntax-tree)
* [CSS](#css)
* [Languages](#languages)
* [Compatibility](#compatibility)
* [Security](#security)
* [Related](#related)
* [Contribute](#contribute)
* [License](#license)

## What is this?

This package is an open source version of GitHubâ€™s closed-source `PrettyLights`
project (more on that later).
It supports **600+ grammars** and its **extremely high quality**.
It uses TextMate grammars which are also used in popular editors
(SublimeText, Atom, VS Code, \&c).
Theyâ€™re heavy but high quality.

## When should I use this?

`starry-night` is a **high quality** highlighter
(when your readers or authors are programmers,
you want this!)
that can support **tons of grammars**
(from new things like MDX to much more!)
which approaches how GitHub renders code.

It has a WASM dependency,
and rather big grammars,
which means that `starry-night` might be too heavy particularly in browsers,
in which case [`lowlight`][github-lowlight] or [`refractor`][github-refractor]
might be more suitable.

This project is similar to the excellent [`shiki`][github-shiki],
and it uses the same underlying dependencies,
but `starry-night` is meant to match GitHub in that it produces classes and
works with the CSS it ships,
making it easier to add dark mode and other themes with CSS compared to inline
styles.

Finally,
this package produces objects (an AST),
which makes it useful when you want to perform syntax highlighting in a place
where serialized HTML wouldnâ€™t work or wouldnâ€™t work well.
For example,
when you want to show code in a CLI by rendering to ANSI sequences,
when youâ€™re using virtual DOM frameworks (such as React or Preact) so that
diffing can be performant,
or when youâ€™re working with [`hast`][github-hast] or [`rehype`][github-rehype].

Bundled,
minified,
and gzipped,
`starry-night` and the WASM binary are 185 kB.
There are two lists of grammars you can use:
[`common`][api-common]
(Â±35 languages, good for your own site)
adds 250 kB and [`all`][api-all]
(\~600 languages, useful if you are making a site like GitHub)
is 1.6 MB.
You can also manually choose which grammars to include
(or add to `common`):
a language is typically between 3 and 5 kB.
To illustrate,
Astro costs 2.1 kB and TSX costs 25.4 kB.

## What is `PrettyLights`?

`PrettyLights` is the syntax highlighter that GitHub uses to turn this:

````markdown
```markdown
# Hello, world!
```
````

â€¦into this:

```html
<span class="pl-mh"><span class="pl-mh">#</span><span class="pl-mh"> </span>Hello, world!</span>
```

â€¦which is what `starry-night` does too
(some small differences in markup,
but essentially the same)!

`PrettyLights` is responsible for taking the flag `markdown`,
looking it up in
[`languages.yml` from `github-linguist`][github-linguist-languages-yml]
to figure out that that means markdown,
taking a corresponding grammar
(in this case
[`wooorm/markdown-tm-language`][github-markdown-tm-language]),
doing some GPL magic in C,
and turning it into spans with classes.

GitHub is using `PrettyLights` since December 2014,
when it [replaced `Pygments`][github-pages-pygments].
They wanted to open source it,
but [were unable][github-pages-license] due to licensing issues.
Recently ([Feb 2019][github-tree-sitter-tree-lights]?),
GitHub has slowly started to move towards `TreeLights`,
which is based on TreeSitter,
and also closed source.
If `TreeLights` includes a language
(currently: C, C#, CSS, CodeQL, EJS, Elixir, ERB, Gleam, Go, HTML, Java, JS,
Nix, PHP, Python, RegEx, Ruby, Rust, TLA, TS),
thatâ€™ll be used,
for everything else `PrettyLights` is used.

`starry-night` does what `PrettyLights` does,
not what `TreeLights` does.
Iâ€™m hopeful that that will be open sourced in the future and we can mimic both.

<br>

[![](media/slice-1.jpg)][artsandculture-google-starry-night]

## Install

This package is [ESM only][github-gist-esm].
In Node.js (version 16+),
install with [npm][npmjs-install]:

```sh
npm install @wooorm/starry-night
```

In Deno with [`esm.sh`][esmsh]:

```js
import {common, createStarryNight} from 'https://esm.sh/@wooorm/starry-night@3'
```

In browsers with [`esm.sh`][esmsh]:

```html
<script type="module">
  import {common, createStarryNight} from 'https://esm.sh/@wooorm/starry-night@3?bundle'
</script>
```

To get the CSS in browsers,
do
(see [CSS][section-css] for more info):

```html
<!-- This supports light and dark mode automatically. -->
<link rel="stylesheet" href="https://esm.sh/@wooorm/starry-night@3/style/both">
```

## Use

```js
import {common, createStarryNight} from '@wooorm/starry-night'

const starryNight = await createStarryNight(common)

const scope = starryNight.flagToScope('markdown')
const tree = starryNight.highlight('# hi', scope)

console.log(tree)
```

Yields:

```js
{
  type: 'root',
  children: [
    {
      type: 'element',
      tagName: 'span',
      properties: {className: ['pl-mh']},
      children: [
        {type: 'text', value: '# '},
        {
          type: 'element',
          tagName: 'span',
          properties: {className: ['pl-en']},
          children: [{type: 'text', value: 'hi'}]
        }
      ]
    }
  ]
}
```

## API

This package exports the identifiers
[`all`][api-all],
[`common`][api-common],
and
[`createStarryNight`][api-create-starry-night]
from the main module.
It exports the additional [TypeScript][] types
[`GetOnigurumaUrl`][api-get-oniguruma-url],
[`Grammar`][api-grammar],
and [`Options`][api-options].
There is no default export.

It also includes grammars directly in its export map,
which each expose a [`Grammar`][api-grammar] as the default export.
**Do not** use the `lang/` folder or the `.js` extension.

For CSS files,
do use `style/` and donâ€™t use `.css`:

```js
import sourceMdx from '@wooorm/starry-night/source.mdx' // Grammar.
import styleTritanopiaDark from '@wooorm/starry-night/style/tritanopia-dark' // CSS.
```

### `all`

List of all grammars ([`Array<Grammar>`][api-grammar])

### `common`

List of Â±35 common grammars ([`Array<Grammar>`][api-grammar])

### `createStarryNight(grammars[, options])`

Create a `StarryNight` that can highlight things with the given `grammars`.
This is async to allow async loading and registering,
which is currently only used for WASM.

###### Parameters

* `grammars`
  ([`Array<Grammar>`][api-grammar])
  â€” grammars to support
* `options`
  ([`Options`][api-options], optional)
  â€” configuration

###### Returns

Promise that resolves to an instance which highlights with the bound
grammars (`Promise<StarryNight>`).

### `starryNight.flagToScope(flag)`

Get the grammar scope (such as `text.md`) associated with a grammar name
(such as `markdown`) or grammar extension (such as `.mdwn`).

This function uses the first word (when splitting on spaces and tabs) that is
used after the opening of a fenced code block:

````markdown
```js
console.log(1)
```
````

To match GitHub,
this also accepts entire paths:

````markdown
```path/to/example.js
console.log(1)
```
````

> ðŸ‘‰ **Note**:
> languages can use the same extensions.
> For example,
> `.h` is reused by many languages.
> In those cases,
> you will get one scope back,
> but it might not be the most popular language associated with an extension.

###### Parameters

* `flag`
  (`string`)
  â€” grammar name
  (such as `'markdown'`),
  grammar extension
  (such as `'.mdwn'`),
  or entire file path ending in extension

###### Returns

Grammar scope,
such as `'text.md'`
(`string` or `undefined`).

###### Example

```js
import {common, createStarryNight} from '@wooorm/starry-night'

const starryNight = await createStarryNight(common)

console.log(starryNight.flagToScope('pandoc')) // `'text.md'`
console.log(starryNight.flagToScope('workbook')) // `'text.md'`
console.log(starryNight.flagToScope('.workbook')) // `'text.md'`
console.log(starryNight.flagToScope('path/to/example.js')) // `'source.js'`
console.log(starryNight.flagToScope('whatever')) // `undefined`
```

### `starryNight.highlight(value, scope)`

Highlight programming code.

###### Parameters

* `value` (`string`)
  â€” code to highlight
* `scope` (`string`)
  â€” registered grammar scope to highlight as (such as `'text.md'`)

###### Returns

Node representing highlighted code ([`Root`][github-hast-root]).

###### Example

```js
import sourceCss from '@wooorm/starry-night/source.css'
import {createStarryNight} from '@wooorm/starry-night'

const starryNight = await createStarryNight([sourceCss])

console.log(starryNight.highlight('em { color: red }', 'source.css'))
```

Yields:

```js
{
  type: 'root',
  children: [
    {type: 'element', tagName: 'span', properties: [Object], children: [Array]},
    {type: 'text', value: ' { '},
    {type: 'element', tagName: 'span', properties: [Object], children: [Array]},
    {type: 'text', value: ': '},
    {type: 'element', tagName: 'span', properties: [Object], children: [Array]},
    {type: 'text', value: ' }'}
  ]
}
```

### `starryNight.missingScopes()`

List scopes that are needed by the registered grammars but that are
missing.

To illustrate,
the `text.xml.svg` grammar needs the `text.xml` grammar.
When you register `text.xml.svg` without `text.xml`,
it will be listed here.

###### Returns

List of grammar scopes,
such as `'text.md'`
(`Array<string>`).

###### Example

```js
import textXmlSvg from '@wooorm/starry-night/text.xml.svg'
import textXml from '@wooorm/starry-night/text.xml'
import {createStarryNight} from '@wooorm/starry-night'

const svg = await createStarryNight([textXmlSvg])
console.log(svg.missingScopes()) //=> ['text.xml']

const svgAndXml = await createStarryNight([textXmlSvg, textXml])
console.log(svgAndXml.missingScopes()) //=> []
```

### `starryNight.register(grammars)`

Add more grammars.

###### Parameters

* `grammars` ([`Array<Grammar>`][api-grammar])
  â€” grammars to support

###### Returns

Promise resolving to nothing (`Promise<undefined>`).

###### Example

````js
import sourceCss from '@wooorm/starry-night/source.css'
import textMd from '@wooorm/starry-night/text.md'
import {createStarryNight} from '@wooorm/starry-night'
import {toHtml} from 'hast-util-to-html'

const markdown = '```css\nem { color: red }\n```'

const starryNight = await createStarryNight([textMd])

console.log(toHtml(starryNight.highlight(markdown, 'text.md')))

await starryNight.register([sourceCss])

console.log(toHtml(starryNight.highlight(markdown, 'text.md')))
````

Yields:

````html
<span class="pl-s">```</span><span class="pl-en">css</span>
<span class="pl-c1">em { color: red }</span>
<span class="pl-s">```</span>
````

````html
<span class="pl-s">```</span><span class="pl-en">css</span>
<span class="pl-ent">em</span> { <span class="pl-c1">color</span>: <span class="pl-c1">red</span> }
<span class="pl-s">```</span>
````

### `starryNight.scopes()`

List all registered scopes.

###### Returns

List of grammar scopes,
such as `'text.md'`
(`Array<string>`).

###### Example

```js
import {common, createStarryNight} from '@wooorm/starry-night'

const starryNight = await createStarryNight(common)

console.log(starryNight.scopes())
```

Yields:

```js
[
  'source.c',
  'source.c++',
  // â€¦
  'text.xml',
  'text.xml.svg'
]
```

### `GetOnigurumaUrl`

Function to get a URL to the oniguruma WASM (TypeScript type).

> ðŸ‘‰ **Note**:
> this must currently result in a version 2 URL of `onig.wasm` from
> [`vscode-oniguruma`][github-vscode-oniguruma].

> âš ï¸ **Danger**:
> when you use this functionality,
> your project might break at any time
> (when reinstalling dependencies),
> except when you make sure that the WASM binary you load manually is what our
> internally used `vscode-oniguruma` dependency expects.
> To solve this, you could for example use an npm script called
> [`dependencies`][npmjs-using-npm-script-dependencies]
> (which runs everytime `node_modules` is changed)
> which copies `vscode-oniguruma/release/onig.wasm` to the place you want to
> host it.

###### Returns

URL object to a WASM binary (`Promise<URL>` or `URL`).

###### Example

```js
import {common, createStarryNight} from '@wooorm/starry-night'

const starryNight = await createStarryNight(common, {
  getOnigurumaUrlFetch() {
    return new URL('/onig.wasm', window.location.href);
  }
})
```

### `Grammar`

TextMate grammar with some extra info (TypeScript type).

###### Fields

* `dependencies`
  (`Array<string>`, optional, example: `['source.tsx']`)
  â€” list of scopes that are needed for this grammar to work
* `extensions`
  (`Array<string>`, example: `['.mdx']`)
  â€” list of extensions
* `extensionsWithDot`
  (`Array<string>`, optional, example: `['.php']`)
  â€” list of extensions that only match if used w/ a dot
* `injections`
  (`Record<string, Rule>`, optional)
  â€” TextMate injections
* `names`
  (`Array<string>`, example: `['mdx']`)
  â€” list of names
* `patterns`
  (`Array<Rule>`)
  â€” TextMate patterns
* `repository`
  (`Record<string, Rule>`, optional)
  â€” TextMate repository
* `scopeName`
  (`string`, example: `'source.mdx'`)
  â€” scope

### `Options`

Configuration (TypeScript type).

###### Fields

* `getOnigurumaUrlFetch`
  ([`GetOnigurumaUrl`][api-get-oniguruma-url], optional)
  â€” get a URL to the oniguruma WASM,
  typically used in browsers
* `getOnigurumaUrlFs`
  ([`GetOnigurumaUrl`][api-get-oniguruma-url], optional)
  â€” get a URL to the oniguruma WASM,
  typically used in Node.js

## Examples

### Example: serializing hast as html

[`hast`][github-hast] trees as returned by `starry-night` can be serialized with
[`hast-util-to-html`][github-hast-util-to-html]:

```js
import {common, createStarryNight} from '@wooorm/starry-night'
import {toHtml} from 'hast-util-to-html'

const starryNight = await createStarryNight(common)

const tree = starryNight.highlight('"use strict";', 'source.js')

console.log(toHtml(tree))
```

Yields:

```html
<span class="pl-s"><span class="pl-pds">"</span>use strict<span class="pl-pds">"</span></span>;
```

### Example: using `starry-night` on the client

You donâ€™t *have* to do preprocess things on a server.
Particularly,
when you are not using Node.js or so.
Or,
when you have a lot of often changing content
(likely markdown),
such as on a page of comments.

In those cases,
you can run `starry-night` in the browser.
Here is an example.
It also uses [`hast-util-to-dom`][github-hast-util-to-dom],
which is a light way to turn the AST into DOM nodes.

Say we have this `example.js` on our browser (no bundling needed!):

```js
import {
  common,
  createStarryNight
} from 'https://esm.sh/@wooorm/starry-night@3?bundle'
import {toDom} from 'https://esm.sh/hast-util-to-dom@4?bundle'

const starryNight = await createStarryNight(common)
const prefix = 'language-'

const nodes = Array.from(document.body.querySelectorAll('code'))

for (const node of nodes) {
  const className = Array.from(node.classList).find(function (d) {
    return d.startsWith(prefix)
  })
  if (!className) continue
  const scope = starryNight.flagToScope(className.slice(prefix.length))
  if (!scope) continue
  const tree = starryNight.highlight(node.textContent, scope)
  node.replaceChildren(toDom(tree, {fragment: true}))
}
```

â€¦and then,
if we would have an `index.html` for our document:

```html
<!doctype html>
<meta charset=utf8>
<title>Hello</title>
<link rel=stylesheet href=https://esm.sh/@wooorm/starry-night@3/style/both>
<body>
<h1>Hello</h1>
<p>â€¦world!</p>
<pre><code class=language-js>console.log('it works!')
</code></pre>
<script type=module src=./example.js></script>
</body>
```

Opening that page in a browser,
weâ€™d see the `<code>` being swapped with:

```html
<code class="language-js"><span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-s"><span class="pl-pds">'</span>it works!<span class="pl-pds">'</span></span>)
</code>
```

### Example: turning hast into react nodes

hast trees as returned by `starry-night` can be turned into
preact, react, solid, svelte, vue, etc.,
with
[`hast-util-to-jsx-runtime`][github-hast-util-to-jsx-runtime]:

```js
import {common, createStarryNight} from '@wooorm/starry-night'
import {toJsxRuntime} from 'hast-util-to-jsx-runtime'
import {Fragment, jsx, jsxs} from 'react/jsx-runtime'

const starryNight = await createStarryNight(common)

const tree = starryNight.highlight('"use strict";', 'source.js')
const reactNode = toJsxRuntime(tree, {Fragment, jsx, jsxs})

console.log(reactNode)
```

Yields:

```js
{
  '$$typeof': Symbol(react.element),
  type: Symbol(react.fragment),
  key: null,
  ref: null,
  props: { children: [ [Object], ';' ] },
  _owner: null,
  _store: {}
}
```

### Example: adding line numbers

GitHub itself does not add line numbers to the code they highlight.
You can do that,
by transforming the AST.
Hereâ€™s an example of a utility that wraps each line into a span with a class and
a data attribute with its line number.
That way,
you can style the lines as you please.
Or you can generate different elements for each line,
of course.

Say we have our utility as `hast-util-starry-night-gutter.js`:

```js
/**
 * @import {ElementContent, Element, RootContent, Root} from 'hast'
 */

/**
 * @param {Root} tree
 *   Tree.
 * @returns {undefined}
 *   Nothing.
 */
export function starryNightGutter(tree) {
  /** @type {Array<RootContent>} */
  const replacement = []
  const search = /\r?\n|\r/g
  let index = -1
  let start = 0
  let startTextRemainder = ''
  let lineNumber = 0

  while (++index < tree.children.length) {
    const child = tree.children[index]

    if (child.type === 'text') {
      let textStart = 0
      let match = search.exec(child.value)

      while (match) {
        // Nodes in this line.
        const line = /** @type {Array<ElementContent>} */ (
          tree.children.slice(start, index)
        )

        // Prepend text from a partial matched earlier text.
        if (startTextRemainder) {
          line.unshift({type: 'text', value: startTextRemainder})
          startTextRemainder = ''
        }

        // Append text from this text.
        if (match.index > textStart) {
          line.push({
            type: 'text',
            value: child.value.slice(textStart, match.index)
          })
        }

        // Add a line, and the eol.
        lineNumber += 1
        replacement.push(createLine(line, lineNumber), {
          type: 'text',
          value: match[0]
        })

        start = index + 1
        textStart = match.index + match[0].length
        match = search.exec(child.value)
      }

      // If we matched, make sure to not drop the text after the last line ending.
      if (start === index + 1) {
        startTextRemainder = child.value.slice(textStart)
      }
    }
  }

  const line = /** @type {Array<ElementContent>} */ (tree.children.slice(start))
  // Prepend text from a partial matched earlier text.
  if (startTextRemainder) {
    line.unshift({type: 'text', value: startTextRemainder})
    startTextRemainder = ''
  }

  if (line.length > 0) {
    lineNumber += 1
    replacement.push(createLine(line, lineNumber))
  }

  // Replace children with new array.
  tree.children = replacement
}

/**
 * @param {Array<ElementContent>} children
 * @param {number} line
 * @returns {Element}
 */
function createLine(children, line) {
  return {
    type: 'element',
    tagName: 'span',
    properties: {className: 'line', dataLineNumber: line},
    children
  }
}
```

â€¦and a module `example.js`:

````js
import {common, createStarryNight} from '@wooorm/starry-night'
import {toHtml} from 'hast-util-to-html'
import {starryNightGutter} from './hast-util-starry-night-gutter.js'

const starryNight = await createStarryNight(common)

const tree = starryNight.highlight(
  '# Some heading\n\n```js\nalert(1)\n```\n***',
  'text.md'
)

starryNightGutter(tree)

console.log(toHtml(tree))
````

Now running `node example.js` yields:

````html
<span class="line" data-line-number="1"><span class="pl-mh"># <span class="pl-en">Some heading</span></span></span>
<span class="line" data-line-number="2"></span>
<span class="line" data-line-number="3"><span class="pl-s">```</span><span class="pl-en">js</span></span>
<span class="line" data-line-number="4"><span class="pl-en">alert</span>(<span class="pl-c1">1</span>)</span>
<span class="line" data-line-number="5"><span class="pl-s">```</span></span>
<span class="line" data-line-number="6"><span class="pl-ms">***</span></span>
````

### Example: integrate with unified, remark, and rehype

This example shows how to use
[`rehype-starry-night`][github-rehype-starry-night] with
[`unified`][github-unified].
If we have a markdown file `example.md`:

````markdown
# Hello

â€¦world!

```js
console.log('it works!')
```
````

â€¦and a module `example.js`:

```js
import fs from 'node:fs/promises'
import rehypeStarryNight from 'rehype-starry-night'
import rehypeStringify from 'rehype-stringify'
import remarkParse from 'remark-parse'
import remarkRehype from 'remark-rehype'
import {unified} from 'unified'

const file = await unified()
  .use(remarkParse)
  .use(remarkRehype)
  .use(rehypeStarryNight)
  .use(rehypeStringify)
  .process(await fs.readFile('example.md'))

console.log(String(file))
```

â€¦then running `node example.js` yields:

```html
<h1>Hello</h1>
<p>â€¦world!</p>
<pre><code class="language-js"><span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-s"><span class="pl-pds">'</span>it works!<span class="pl-pds">'</span></span>)
</code></pre>
```

### Example: integrating with `markdown-it`

This example shows how to combine `starry-night` with `markdown-it`.
If we have a markdown file `example.md`:

````markdown
# Hello

â€¦world!

```js
console.log('it works!')
```
````

â€¦and a module `example.js`:

```js
/**
 * @import {ElementContent} from 'hast'
 */

import fs from 'node:fs/promises'
import {common, createStarryNight} from '@wooorm/starry-night'
import {toHtml} from 'hast-util-to-html'
import markdownIt from 'markdown-it'

const file = await fs.readFile('example.md')
const starryNight = await createStarryNight(common)

const markdownItInstance = markdownIt({
  highlight(value, lang) {
    const scope = starryNight.flagToScope(lang)

    return toHtml({
      type: 'element',
      tagName: 'pre',
      properties: {
        className: scope
          ? [
              'highlight',
              'highlight-' + scope.replace(/^source\./, '').replace(/\./g, '-')
            ]
          : undefined
      },
      children: scope
        ? /** @type {Array<ElementContent>} */ (
            starryNight.highlight(value, scope).children
          )
        : [{type: 'text', value}]
    })
  }
})

const html = markdownItInstance.render(String(file))

console.log(html)
```

Now running `node example.js` yields:

```html
<h1>Hello</h1>
<p>â€¦world!</p>
<pre class="highlight highlight-js"><span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-s"><span class="pl-pds">'</span>it works!<span class="pl-pds">'</span></span>)
</pre>
```

<br>

[![](media/slice-2.jpg)][artsandculture-google-starry-night]

## Syntax tree

The generated [`hast`][github-hast] starts with a `root` node,
that represents the fragment.
It contains up to three levels of `<span>` `element`s,
each with a single class.
All these levels can contain text nodes with the actual code.
Interestingly,
TextMate grammars work per line,
so all line endings are in the root directly,
meaning that creating a gutter to display line numbers can be generated rather
naÃ¯vely by only looking through the root node.

## CSS

`starry-night` does not inject CSS for the syntax highlighted code
(because well,
`starry-night` doesnâ€™t have to be turned into HTML and might not run in a
browser!).
If you are in a browser,
you can use the packaged themes,
or get creative with CSS!
ðŸ’…

All themes accept CSS variables (custom properties).
With the theme `core.css`,
you have to define your own properties.
All other themes define the colors on `:root`.
Themes either have a `dark` or `light` suffix,
or none,
in which case they automatically switch colors based on a
`@media (prefers-color-scheme: dark)`.
All themes are tiny (under 1 kB).
The shipped themes are as follows:

| name | Includes light scheme | Includes dark scheme |
| - | - | - |
| [`@wooorm/starry-night/style/core`](style/core.css) | | |
| [`@wooorm/starry-night/style/light`](style/light.css) | âœ… | |
| [`@wooorm/starry-night/style/dark`](style/dark.css) | | âœ… |
| [`@wooorm/starry-night/style/both`](style/both.css) | âœ… | âœ… |
| [`@wooorm/starry-night/style/colorblind-light`](style/colorblind-light.css) | âœ… | |
| [`@wooorm/starry-night/style/colorblind-dark`](style/colorblind-dark.css) | | âœ… |
| [`@wooorm/starry-night/style/colorblind`](style/colorblind.css) | âœ… | âœ… |
| [`@wooorm/starry-night/style/dimmed-dark`](style/dimmed-dark.css) | | âœ… |
| [`@wooorm/starry-night/style/dimmed`](style/dimmed.css) | âœ… | âœ… |
| [`@wooorm/starry-night/style/high-contrast-light`](style/high-contrast-light.css) | âœ… | |
| [`@wooorm/starry-night/style/high-contrast-dark`](style/high-contrast-dark.css) | | âœ… |
| [`@wooorm/starry-night/style/high-contrast`](style/high-contrast.css) | âœ… | âœ… |
| [`@wooorm/starry-night/style/tritanopia-light`](style/tritanopia-light.css) | âœ… | |
| [`@wooorm/starry-night/style/tritanopia-dark`](style/tritanopia-dark.css) | | âœ… |
| [`@wooorm/starry-night/style/tritanopia`](style/tritanopia.css) | âœ… | âœ… |

## Languages

Checked grammars are included in [`common`][api-common].
Everything (thatâ€™s needed) is available through
[`all`][api-all].
You can add more grammars as you please.

Each grammar has several associated names and extensions.
See source files for which are known and use `flagToScope` to turn them into
scopes.

Some grammars need other grammars to work.
You are responsible for loading those,
use `missingScopes` to find which dependencies are needed.

All licenses are permissive and made available in [`notice`][file-notice].
Changes should go to upstream repos and
[`languages.yml` in `github-linguist`][github-linguist-languages-yml].

<!--support start-->

* [x] [`source.c`](lang/source.c.js) â€” [upstream](https://github.com/mikomikotaishi/c.tmbundle)
* [x] [`source.c++`](lang/source.c++.js) â€” [upstream](https://github.com/mikomikotaishi/c.tmbundle) â€” needs: `source.c`
* [x] [`source.cs`](lang/source.cs.js) (mit) â€” [upstream](https://github.com/dotnet/csharp-tmLanguage)
* [x] [`source.css`](lang/source.css.js) (mit) â€” [upstream](https://github.com/atom/language-css)
* [x] [`source.css.less`](lang/source.css.less.js) (mit) â€” [upstream](https://github.com/atom/language-less) â€” needs: `source.css`
* [x] [`source.css.scss`](lang/source.css.scss.js) (mit) â€” [upstream](https://github.com/atom/language-sass) â€” needs: `source.css`
* [x] [`source.diff`](lang/source.diff.js)
* [x] [`source.go`](lang/source.go.js) (bsd-3-clause) â€” [upstream](https://github.com/AlanQuatermain/go-tmbundle)
* [x] [`source.graphql`](lang/source.graphql.js) (mit) â€” [upstream](https://github.com/graphql/graphiql)
* [x] [`source.ini`](lang/source.ini.js)
* [x] [`source.java`](lang/source.java.js) â€” [upstream](https://github.com/textmate/java.tmbundle)
* [x] [`source.js`](lang/source.js.js) (mit) â€” [upstream](https://github.com/atom/language-javascript)
* [x] [`source.json`](lang/source.json.js) (isc) â€” [upstream](https://github.com/Nixinova/NovaGrammars)
* [x] [`source.kotlin`](lang/source.kotlin.js) (apache-2.0) â€” [upstream](https://github.com/nishtahir/language-kotlin)
* [x] [`source.lua`](lang/source.lua.js) (mit) â€” [upstream](https://github.com/LuaLS/lua.tmbundle)
* [x] [`source.makefile`](lang/source.makefile.js) â€” [upstream](https://github.com/textmate/make.tmbundle) â€” needs: `source.shell`
* [x] [`source.objc`](lang/source.objc.js) â€” needs: `source.c`, `source.objc.platform`
* [x] [`source.objc.platform`](lang/source.objc.platform.js)
* [x] [`source.perl`](lang/source.perl.js) â€” [upstream](https://github.com/textmate/perl.tmbundle)
* [x] [`source.python`](lang/source.python.js) (mit) â€” [upstream](https://github.com/MagicStack/MagicPython)
* [x] [`source.r`](lang/source.r.js)
* [x] [`source.ruby`](lang/source.ruby.js) (mit) â€” [upstream](https://github.com/atom/language-ruby)
* [x] [`source.rust`](lang/source.rust.js) (mit) â€” [upstream](https://github.com/dustypomerleau/rust-syntax)
* [x] [`source.shell`](lang/source.shell.js) (mit) â€” [upstream](https://github.com/atom/language-shellscript)
* [x] [`source.sql`](lang/source.sql.js)
* [x] [`source.swift`](lang/source.swift.js) (mit) â€” [upstream](https://github.com/jtbandes/swift-tmlanguage)
* [x] [`source.ts`](lang/source.ts.js) (mit) â€” [upstream](https://github.com/Microsoft/TypeScript-TmLanguage)
* [x] [`source.vbnet`](lang/source.vbnet.js) (apache-2.0) â€” [upstream](https://github.com/angryant0007/VBDotNetSyntax)
* [x] [`source.yaml`](lang/source.yaml.js) (mit) â€” [upstream](https://github.com/atom/language-yaml)
* [x] [`text.html.basic`](lang/text.html.basic.js) (mit) â€” [upstream](https://github.com/atom/language-html)
* [x] [`text.html.php`](lang/text.html.php.js) â€” needs: `text.html.basic`
* [x] [`text.md`](lang/text.md.js) (mit) â€” [upstream](https://github.com/wooorm/markdown-tm-language)
* [x] [`text.xml`](lang/text.xml.js)
* [x] [`text.xml.svg`](lang/text.xml.svg.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `text.xml`
* [ ] [`config.xcompose`](lang/config.xcompose.js) (mit)
* [ ] [`etc`](lang/etc.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `source.regexp.posix`
* [ ] [`file.lasso`](lang/file.lasso.js) (public domain)
* [ ] [`go.mod`](lang/go.mod.js) (mit) â€” [upstream](https://github.com/golang/vscode-go)
* [ ] [`go.sum`](lang/go.sum.js) (mit) â€” [upstream](https://github.com/golang/vscode-go)
* [ ] [`injections.etc`](lang/injections.etc.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc)
* [ ] [`objdump.x86asm`](lang/objdump.x86asm.js) (mit) â€” needs: `source.c`, `source.c++`
* [ ] [`source.2da`](lang/source.2da.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc)
* [ ] [`source.4dm`](lang/source.4dm.js) (mit)
* [ ] [`source.8xp`](lang/source.8xp.js) (bsd-3-clause) â€” [upstream](https://github.com/TIny-Hacker/language-ti-basic)
* [ ] [`source.abap`](lang/source.abap.js) â€” [upstream](https://github.com/pvl/abap.tmbundle)
* [ ] [`source.abapcds`](lang/source.abapcds.js) (unlicense) â€” [upstream](https://github.com/FreHu/abap-cds-grammar)
* [ ] [`source.abl`](lang/source.abl.js) (mit) â€” [upstream](https://github.com/chriscamicas/abl-tmlanguage)
* [ ] [`source.abnf`](lang/source.abnf.js) (isc) â€” [upstream](https://github.com/Alhadis/language-grammars)
* [ ] [`source.actionscript.3`](lang/source.actionscript.3.js) (mit) â€” [upstream](https://github.com/simongregory/actionscript3-tmbundle) â€” needs: `text.html.asdoc`, `text.xml`
* [ ] [`source.ada`](lang/source.ada.js)
* [ ] [`source.afm`](lang/source.afm.js) (isc) â€” [upstream](https://github.com/Alhadis/language-fontforge)
* [ ] [`source.agc`](lang/source.agc.js) (isc)
* [ ] [`source.agda`](lang/source.agda.js) (mit) â€” [upstream](https://github.com/agda/agda-github-syntax-highlighting)
* [ ] [`source.ahk`](lang/source.ahk.js) (unlicense) â€” [upstream](https://github.com/ahkscript/SublimeAutoHotkey)
* [ ] [`source.aidl`](lang/source.aidl.js) (apache-2.0) â€” [upstream](https://github.com/google/aidl-language)
* [ ] [`source.aiken`](lang/source.aiken.js) (apache-2.0) â€” [upstream](https://github.com/aiken-lang/vscode-aiken)
* [ ] [`source.al`](lang/source.al.js) (mit) â€” [upstream](https://github.com/microsoft/AL)
* [ ] [`source.alloy`](lang/source.alloy.js) (apache-2.0) â€” [upstream](https://github.com/macekond/Alloy.tmbundle)
* [ ] [`source.ampl`](lang/source.ampl.js) (mit)
* [ ] [`source.angelscript`](lang/source.angelscript.js) (unlicense) â€” [upstream](https://github.com/wronex/sublime-angelscript)
* [ ] [`source.answersetprogramming`](lang/source.answersetprogramming.js) (mit) â€” [upstream](https://github.com/nickswalker/asp-syntax-highlight)
* [ ] [`source.antlr`](lang/source.antlr.js)
* [ ] [`source.apacheconf`](lang/source.apacheconf.js) (mit) â€” [upstream](https://github.com/mrmlnc/vscode-apache)
* [ ] [`source.apex`](lang/source.apex.js) (bsd-3-clause) â€” [upstream](https://github.com/forcedotcom/apex-tmLanguage)
* [ ] [`source.apl`](lang/source.apl.js) (isc) â€” [upstream](https://github.com/Alhadis/language-apl)
* [ ] [`source.applescript`](lang/source.applescript.js)
* [ ] [`source.arr`](lang/source.arr.js) (mit) â€” [upstream](https://github.com/samuela/language-pyret)
* [ ] [`source.asl`](lang/source.asl.js) (mit) â€” [upstream](https://github.com/sebadur/language-asl)
* [ ] [`source.asn`](lang/source.asn.js) (mit) â€” [upstream](https://github.com/ajlangley/language-asn1)
* [ ] [`source.asp`](lang/source.asp.js)
* [ ] [`source.aspectj`](lang/source.aspectj.js) (mit)
* [ ] [`source.assembly`](lang/source.assembly.js) (bsd-3-clause) â€” [upstream](https://github.com/Nessphoro/sublimeassembly)
* [ ] [`source.astro`](lang/source.astro.js) (mit) â€” [upstream](https://github.com/withastro/language-tools) â€” needs: `source.js`, `source.ts`, `source.tsx`
* [ ] [`source.ats`](lang/source.ats.js) (mit)
* [ ] [`source.autoit`](lang/source.autoit.js) (mit)
* [ ] [`source.avro`](lang/source.avro.js) (mit) â€” [upstream](https://github.com/Jason3S/avro.tmLanguage)
* [ ] [`source.awk`](lang/source.awk.js) (mit)
* [ ] [`source.ballerina`](lang/source.ballerina.js) (apache-2.0) â€” [upstream](https://github.com/ballerina-platform/ballerina-grammar)
* [ ] [`source.basic`](lang/source.basic.js) (apache-2.0) â€” [upstream](https://github.com/telnet23/language-basic)
* [ ] [`source.batchfile`](lang/source.batchfile.js) (mit) â€” [upstream](https://github.com/mmims/language-batchfile)
* [ ] [`source.bb`](lang/source.bb.js) (mit) â€” [upstream](https://github.com/yoctoproject/vscode-bitbake)
* [ ] [`source.bdf`](lang/source.bdf.js) (isc) â€” [upstream](https://github.com/Alhadis/language-fontforge) â€” needs: `source.xlfd`
* [ ] [`source.befunge`](lang/source.befunge.js) (mit)
* [ ] [`source.berry`](lang/source.berry.js) (mit) â€” [upstream](https://github.com/berry-lang/berry-grammar)
* [ ] [`source.bf`](lang/source.bf.js) (mit) â€” [upstream](https://github.com/Drako/SublimeBrainfuck)
* [ ] [`source.bh`](lang/source.bh.js) (bsd-3-clause) â€” [upstream](https://github.com/B-Lang-org/language-bh)
* [ ] [`source.bicep`](lang/source.bicep.js) (mit) â€” [upstream](https://github.com/azure/bicep)
* [ ] [`source.blitzmax`](lang/source.blitzmax.js)
* [ ] [`source.boo`](lang/source.boo.js) (mit) â€” [upstream](https://github.com/drslump/sublime-boo)
* [ ] [`source.boogie`](lang/source.boogie.js) (mit) â€” [upstream](https://github.com/boogie-org/boogie-vscode)
* [ ] [`source.bp`](lang/source.bp.js) (mit) â€” [upstream](https://github.com/flimberger/android-system-tools)
* [ ] [`source.bqn`](lang/source.bqn.js) (mit) â€” [upstream](https://github.com/razetime/bqn-vscode)
* [ ] [`source.brs`](lang/source.brs.js) (mit) â€” [upstream](https://github.com/rokucommunity/vscode-brightscript-language)
* [ ] [`source.bsl`](lang/source.bsl.js) (mit) â€” [upstream](https://github.com/1c-syntax/vsc-language-1c-bsl) â€” needs: `source.sdbl`
* [ ] [`source.bst`](lang/source.bst.js) (mit) â€” [upstream](https://github.com/zyoshoka/bst.tmLanguage)
* [ ] [`source.bsv`](lang/source.bsv.js) (mit)
* [ ] [`source.c.ec`](lang/source.c.ec.js) (unlicense) â€” [upstream](https://github.com/ecere/ec.tmbundle) â€” needs: `source.c`
* [ ] [`source.c.linker`](lang/source.c.linker.js) (mit) â€” [upstream](https://github.com/donno2048/Linker.tmLanguage)
* [ ] [`source.c.nwscript`](lang/source.c.nwscript.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `source.c`
* [ ] [`source.cabal`](lang/source.cabal.js) (mit) â€” [upstream](https://github.com/atom-haskell/language-haskell)
* [ ] [`source.Caddyfile`](lang/source.Caddyfile.js) (mit) â€” [upstream](https://github.com/caddyserver/vscode-caddyfile)
* [ ] [`source.cadence`](lang/source.cadence.js) (apache-2.0) â€” [upstream](https://github.com/onflow/vscode-cadence)
* [ ] [`source.cairo`](lang/source.cairo.js) (apache-2.0) â€” [upstream](https://github.com/software-mansion-labs/cairo-tm-grammar)
* [ ] [`source.cairo0`](lang/source.cairo0.js) (apache-2.0) â€” [upstream](https://github.com/software-mansion-labs/cairo-tm-grammar)
* [ ] [`source.camlp4.ocaml`](lang/source.camlp4.ocaml.js) â€” needs: `source.ocaml`
* [ ] [`source.capnp`](lang/source.capnp.js)
* [ ] [`source.cds`](lang/source.cds.js) (apache-2.0) â€” [upstream](https://github.com/SAP/cds-textmate-grammar)
* [ ] [`source.ceylon`](lang/source.ceylon.js) (apache-2.0)
* [ ] [`source.cfscript`](lang/source.cfscript.js) (mit) â€” needs: `source.sql`
* [ ] [`source.changelogs.rpm-spec`](lang/source.changelogs.rpm-spec.js) (mit)
* [ ] [`source.chapel`](lang/source.chapel.js) (apache-2.0) â€” [upstream](https://github.com/chapel-lang/chapel-tmbundle)
* [ ] [`source.cil`](lang/source.cil.js) (apache-2.0) â€” [upstream](https://github.com/google/selinux-policy-languages)
* [ ] [`source.circom`](lang/source.circom.js) (mit) â€” [upstream](https://github.com/iden3/circom-highlighting-vscode)
* [ ] [`source.cirru`](lang/source.cirru.js) (mit) â€” [upstream](https://github.com/Cirru/sublime-cirru)
* [ ] [`source.clar`](lang/source.clar.js) (mit) â€” [upstream](https://github.com/hirosystems/clarity.tmbundle)
* [ ] [`source.clarion`](lang/source.clarion.js) (mit) â€” [upstream](https://github.com/fushnisoft/SublimeClarion)
* [ ] [`source.clean`](lang/source.clean.js) (mit)
* [ ] [`source.click`](lang/source.click.js) (mit)
* [ ] [`source.clips`](lang/source.clips.js) (mit)
* [ ] [`source.clojure`](lang/source.clojure.js) (mit) â€” [upstream](https://github.com/atom/language-clojure)
* [ ] [`source.clue`](lang/source.clue.js) (mit) â€” [upstream](https://github.com/ClueLang/Clue-for-VSCode)
* [ ] [`source.cmake`](lang/source.cmake.js) (mit) â€” [upstream](https://github.com/microsoft/vscode-cmake-tools)
* [ ] [`source.cobol`](lang/source.cobol.js) (mit) â€” [upstream](https://github.com/spgennard/vscode_cobol)
* [ ] [`source.coffee`](lang/source.coffee.js) (mit) â€” [upstream](https://github.com/atom/language-coffee-script) â€” needs: `source.js`
* [ ] [`source.commonlisp`](lang/source.commonlisp.js) (mit) â€” [upstream](https://github.com/qingpeng9802/common-lisp-tmlanguage)
* [ ] [`source.cool`](lang/source.cool.js) (mit)
* [ ] [`source.coq`](lang/source.coq.js) (mit)
* [ ] [`source.crystal`](lang/source.crystal.js) (mit) â€” [upstream](https://github.com/atom-crystal/language-crystal) â€” needs: `text.html.basic`
* [ ] [`source.csound`](lang/source.csound.js) (mit) â€” [upstream](https://github.com/nwhetsell/language-csound)
* [ ] [`source.csound-document`](lang/source.csound-document.js) (mit) â€” [upstream](https://github.com/nwhetsell/language-csound) â€” needs: `source.csound`, `text.xml`
* [ ] [`source.csound-score`](lang/source.csound-score.js) (mit) â€” [upstream](https://github.com/nwhetsell/language-csound) â€” needs: `source.csound`
* [ ] [`source.css.mss`](lang/source.css.mss.js) (mit)
* [ ] [`source.css.postcss.sugarss`](lang/source.css.postcss.sugarss.js) (mit)
* [ ] [`source.csswg`](lang/source.csswg.js) (cc0-1.0) â€” [upstream](https://github.com/tabatkins/bikeshed)
* [ ] [`source.cuda-c++`](lang/source.cuda-c++.js) (bsd-3-clause) â€” [upstream](https://github.com/harrism/sublimetext-cuda-cpp) â€” needs: `source.c++`
* [ ] [`source.cue`](lang/source.cue.js) (mit) â€” [upstream](https://github.com/cue-sh/vscode-cue)
* [ ] [`source.cuesheet`](lang/source.cuesheet.js) (mit) â€” [upstream](https://github.com/relikd/CUE-Sheet_sublime)
* [ ] [`source.curlrc`](lang/source.curlrc.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `etc`
* [ ] [`source.curry`](lang/source.curry.js) (mit) â€” [upstream](https://github.com/fwcd/vscode-curry)
* [ ] [`source.cwl`](lang/source.cwl.js) (mit)
* [ ] [`source.cylc`](lang/source.cylc.js) (bsd-3-clause) â€” [upstream](https://github.com/cylc/Cylc.tmbundle)
* [ ] [`source.cypher`](lang/source.cypher.js) (apache-2.0) â€” [upstream](https://github.com/fredbenenson/sublime-cypher)
* [ ] [`source.cython`](lang/source.cython.js) â€” needs: `source.regexp.python`
* [ ] [`source.d`](lang/source.d.js) â€” [upstream](https://github.com/textmate/d.tmbundle) â€” needs: `text.html.javadoc`
* [ ] [`source.d2`](lang/source.d2.js) (bsd-3-clause) â€” [upstream](https://github.com/terrastruct/d2-vscode)
* [ ] [`source.dart`](lang/source.dart.js) (bsd-3-clause) â€” [upstream](https://github.com/dart-lang/dart-syntax-highlight)
* [ ] [`source.daslang`](lang/source.daslang.js) (mit) â€” [upstream](https://github.com/moleium/daslang-grammar)
* [ ] [`source.data-weave`](lang/source.data-weave.js) (mit) â€” [upstream](https://github.com/mulesoft-labs/data-weave-tmLanguage)
* [ ] [`source.deb-control`](lang/source.deb-control.js) (mit) â€” [upstream](https://github.com/tsbarnes/language-debian)
* [ ] [`source.denizenscript`](lang/source.denizenscript.js) (mit) â€” [upstream](https://github.com/DenizenScript/denizenscript-grammar)
* [ ] [`source.desktop`](lang/source.desktop.js)
* [ ] [`source.dircolors`](lang/source.dircolors.js) (mit)
* [ ] [`source.ditroff`](lang/source.ditroff.js) (isc) â€” [upstream](https://github.com/Alhadis/language-roff) â€” needs: `source.ditroff.desc`, `text.roff`
* [ ] [`source.ditroff.desc`](lang/source.ditroff.desc.js) (isc) â€” [upstream](https://github.com/Alhadis/language-roff)
* [ ] [`source.dm`](lang/source.dm.js) (mit) â€” [upstream](https://github.com/spacestation13/dm-syntax)
* [ ] [`source.dockerfile`](lang/source.dockerfile.js) (mit) â€” [upstream](https://github.com/asbjornenge/Docker.tmbundle)
* [ ] [`source.dot`](lang/source.dot.js)
* [ ] [`source.dotenv`](lang/source.dotenv.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc)
* [ ] [`source.dune`](lang/source.dune.js) (mit) â€” [upstream](https://github.com/maelvls/vscode-dune)
* [ ] [`source.dylan`](lang/source.dylan.js)
* [ ] [`source.earthfile`](lang/source.earthfile.js) (mpl-2.0) â€” [upstream](https://github.com/earthly/earthfile-grammar)
* [ ] [`source.ebnf`](lang/source.ebnf.js) (isc) â€” [upstream](https://github.com/Alhadis/language-grammars) â€” needs: `source.lex.regexp`
* [ ] [`source.ecl`](lang/source.ecl.js) (apache-2.0) â€” [upstream](https://github.com/hpcc-systems/ecl-tmLanguage)
* [ ] [`source.edgeql`](lang/source.edgeql.js) (mit) â€” [upstream](https://github.com/edgedb/edgedb-editor-plugin)
* [ ] [`source.editorconfig`](lang/source.editorconfig.js) (mit) â€” [upstream](https://github.com/sindresorhus/atom-editorconfig)
* [ ] [`source.eiffel`](lang/source.eiffel.js)
* [ ] [`source.elixir`](lang/source.elixir.js) (apache-2.0) â€” [upstream](https://github.com/elixir-lang/elixir-tmbundle) â€” needs: `text.elixir`
* [ ] [`source.elm`](lang/source.elm.js) (mit) â€” [upstream](https://github.com/elm-community/Elm.tmLanguage)
* [ ] [`source.elvish`](lang/source.elvish.js) (bsd-2-clause) â€” [upstream](https://github.com/elves/elvish)
* [ ] [`source.elvish-transcript`](lang/source.elvish-transcript.js) (bsd-2-clause) â€” [upstream](https://github.com/elves/elvish) â€” needs: `source.elvish`
* [ ] [`source.emacs.lisp`](lang/source.emacs.lisp.js) (isc) â€” [upstream](https://github.com/Alhadis/language-emacs-lisp)
* [ ] [`source.erlang`](lang/source.erlang.js) (apache-2.0) â€” [upstream](https://github.com/erlang-ls/grammar)
* [ ] [`source.euphoria`](lang/source.euphoria.js) (mit) â€” [upstream](https://github.com/OpenEuphoria/vscode-euphoria)
* [ ] [`source.factor`](lang/source.factor.js) (bsd-2-clause)
* [ ] [`source.fan`](lang/source.fan.js) (mit)
* [ ] [`source.fancy`](lang/source.fancy.js) (bsd-3-clause) â€” [upstream](https://github.com/fancy-lang/fancy-tmbundle)
* [ ] [`source.faust`](lang/source.faust.js) (mit)
* [ ] [`source.figfont`](lang/source.figfont.js) (isc) â€” [upstream](https://github.com/Alhadis/language-fontforge)
* [ ] [`source.firestore`](lang/source.firestore.js) (mit)
* [ ] [`source.firrtl`](lang/source.firrtl.js) (apache-2.0) â€” [upstream](https://github.com/chipsalliance/firrtl-syntax)
* [ ] [`source.fish`](lang/source.fish.js) (mit)
* [ ] [`source.fnl`](lang/source.fnl.js) (mit) â€” [upstream](https://github.com/kongeor/vsc-fennel)
* [ ] [`source.fontdir`](lang/source.fontdir.js) (isc) â€” [upstream](https://github.com/Alhadis/language-fontforge) â€” needs: `source.xlfd`
* [ ] [`source.fontforge`](lang/source.fontforge.js) (isc) â€” [upstream](https://github.com/Alhadis/language-fontforge)
* [ ] [`source.forth`](lang/source.forth.js)
* [ ] [`source.fortran`](lang/source.fortran.js)
* [ ] [`source.fortran.modern`](lang/source.fortran.modern.js) â€” needs: `source.fortran`
* [ ] [`source.fsharp`](lang/source.fsharp.js) (mit) â€” [upstream](https://github.com/ionide/ionide-fsgrammar)
* [ ] [`source.fstar`](lang/source.fstar.js) (apache-2.0) â€” [upstream](https://github.com/FStarLang/atom-fstar)
* [ ] [`source.ftl`](lang/source.ftl.js) (mit) â€” [upstream](https://github.com/macabeus/vscode-fluent)
* [ ] [`source.futhark`](lang/source.futhark.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `etc`
* [ ] [`source.gap`](lang/source.gap.js) â€” [upstream](https://github.com/dhowden/gap-tmbundle)
* [ ] [`source.gcode`](lang/source.gcode.js) (mit) â€” [upstream](https://github.com/appliedengdesign/vscode-gcode-syntax)
* [ ] [`source.gdb`](lang/source.gdb.js) (zlib) â€” [upstream](https://github.com/quarnster/SublimeGDB)
* [ ] [`source.gdresource`](lang/source.gdresource.js) (mit) â€” [upstream](https://github.com/godotengine/godot-vscode-plugin)
* [ ] [`source.gdscript`](lang/source.gdscript.js) (mit) â€” [upstream](https://github.com/godotengine/godot-vscode-plugin)
* [ ] [`source.gdshader`](lang/source.gdshader.js) (mit) â€” [upstream](https://github.com/godotengine/godot-vscode-plugin)
* [ ] [`source.gedcom`](lang/source.gedcom.js) (apache-2.0) â€” [upstream](https://github.com/fguitton/vscode-gedcom)
* [ ] [`source.gemfile-lock`](lang/source.gemfile-lock.js) (mit) â€” [upstream](https://github.com/hmarr/gemfile-lock-tmlanguage)
* [ ] [`source.gemini`](lang/source.gemini.js) (mit) â€” [upstream](https://github.com/printfn/gemini-vscode)
* [ ] [`source.generic-db`](lang/source.generic-db.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `etc`
* [ ] [`source.genero-4gl`](lang/source.genero-4gl.js) (unlicense) â€” [upstream](https://github.com/FourjsGenero/GeneroFgl.tmbundle)
* [ ] [`source.genero-per`](lang/source.genero-per.js) (unlicense) â€” [upstream](https://github.com/FourjsGenero/GeneroFgl.tmbundle)
* [ ] [`source.gerber`](lang/source.gerber.js) (isc) â€” [upstream](https://github.com/Alhadis/language-pcb)
* [ ] [`source.gf`](lang/source.gf.js) (mit) â€” [upstream](https://github.com/johnjcamilleri/language-gf)
* [ ] [`source.git-revlist`](lang/source.git-revlist.js) (isc) â€” [upstream](https://github.com/Nixinova/NovaGrammars)
* [ ] [`source.gitattributes`](lang/source.gitattributes.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `etc`, `source.gitignore`
* [ ] [`source.gitconfig`](lang/source.gitconfig.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `source.shell`
* [ ] [`source.gitignore`](lang/source.gitignore.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `etc`
* [ ] [`source.gjs`](lang/source.gjs.js) (mit) â€” [upstream](https://github.com/lifeart/vsc-ember-syntax) â€” needs: `source.js`
* [ ] [`source.gleam`](lang/source.gleam.js) (apache-2.0) â€” [upstream](https://github.com/gleam-lang/vscode-gleam)
* [ ] [`source.glsl`](lang/source.glsl.js) (unlicense) â€” [upstream](https://github.com/euler0/sublime-glsl)
* [ ] [`source.gn`](lang/source.gn.js) (bsd-3-clause) â€” [upstream](https://github.com/devoncarew/language-gn)
* [ ] [`source.gnuplot`](lang/source.gnuplot.js) (mit)
* [ ] [`source.golo`](lang/source.golo.js) (mit) â€” [upstream](https://github.com/TypeUnsafe/sublime-golo)
* [ ] [`source.gosu.2`](lang/source.gosu.2.js) (apache-2.0) â€” [upstream](https://github.com/jpcamara/Textmate-Gosu-Bundle)
* [ ] [`source.grace`](lang/source.grace.js) (mit)
* [ ] [`source.gremlin`](lang/source.gremlin.js) (isc) â€” [upstream](https://github.com/Alhadis/language-roff) â€” needs: `text.roff`
* [ ] [`source.groovy`](lang/source.groovy.js)
* [ ] [`source.groovy.gradle`](lang/source.groovy.gradle.js) (apache-2.0) â€” needs: `source.groovy`
* [ ] [`source.gsc`](lang/source.gsc.js) (unlicense) â€” [upstream](https://github.com/Jake-NotTheMuss/CoDT7-Sublime)
* [ ] [`source.gts`](lang/source.gts.js) (mit) â€” [upstream](https://github.com/lifeart/vsc-ember-syntax) â€” needs: `source.ts`
* [ ] [`source.hack`](lang/source.hack.js) (mit) â€” [upstream](https://github.com/slackhq/vscode-hack) â€” needs: `text.html.basic`
* [ ] [`source.haproxy-config`](lang/source.haproxy-config.js) (mit)
* [ ] [`source.harbour`](lang/source.harbour.js) (mit)
* [ ] [`source.haskell`](lang/source.haskell.js) (mit) â€” [upstream](https://github.com/atom-haskell/language-haskell)
* [ ] [`source.hc`](lang/source.hc.js) (unlicense)
* [ ] [`source.hcl`](lang/source.hcl.js) (mpl-2.0) â€” [upstream](https://github.com/hashicorp/syntax)
* [ ] [`source.hcl.terraform`](lang/source.hcl.terraform.js) (mpl-2.0) â€” [upstream](https://github.com/hashicorp/syntax)
* [ ] [`source.hlsl`](lang/source.hlsl.js) (mit)
* [ ] [`source.hocon`](lang/source.hocon.js) (mit) â€” [upstream](https://github.com/jacobwgillespie/language-hocon)
* [ ] [`source.hoon`](lang/source.hoon.js) (mit) â€” [upstream](https://github.com/pkova/hoon-grammar)
* [ ] [`source.hosts`](lang/source.hosts.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `etc`
* [ ] [`source.hql`](lang/source.hql.js) (mit)
* [ ] [`source.httpspec`](lang/source.httpspec.js) (mit) â€” [upstream](https://github.com/samsalisbury/Sublime-HTTP) â€” needs: `source.json`
* [ ] [`source.hx`](lang/source.hx.js) (mit) â€” [upstream](https://github.com/vshaxe/haxe-TmLanguage)
* [ ] [`source.hxml`](lang/source.hxml.js) (mit) â€” [upstream](https://github.com/vshaxe/haxe-TmLanguage) â€” needs: `source.hx`
* [ ] [`source.hy`](lang/source.hy.js) (mit) â€” [upstream](https://github.com/tshakalekholoane/vscode-hy)
* [ ] [`source.iCalendar`](lang/source.iCalendar.js) (mit) â€” [upstream](https://github.com/kimsey0/iCalendar-sublime)
* [ ] [`source.ice`](lang/source.ice.js) (bsd-3-clause) â€” [upstream](https://github.com/zeroc-ice/vscode-slice)
* [ ] [`source.ideal`](lang/source.ideal.js) (isc) â€” [upstream](https://github.com/Alhadis/language-roff) â€” needs: `source.pic`, `text.roff`
* [ ] [`source.idl`](lang/source.idl.js) (bsd-3-clause) â€” [upstream](https://github.com/mgalloy/idl.tmbundle)
* [ ] [`source.idris`](lang/source.idris.js) (mit) â€” [upstream](https://github.com/idris-hackers/idris-sublime)
* [ ] [`source.igor`](lang/source.igor.js) (bsd-3-clause) â€” [upstream](https://github.com/byte-physics/language-igor)
* [ ] [`source.imba`](lang/source.imba.js) (mit) â€” [upstream](https://github.com/imba/imba-linguist-grammar)
* [ ] [`source.inform7`](lang/source.inform7.js) (mit) â€” [upstream](https://github.com/erkyrath/language-inform7)
* [ ] [`source.ini.npmrc`](lang/source.ini.npmrc.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `etc`
* [ ] [`source.ink`](lang/source.ink.js) (mit) â€” [upstream](https://github.com/inkle/ink-tmlanguage)
* [ ] [`source.inno`](lang/source.inno.js) (mit) â€” [upstream](https://github.com/idleberg/atom-language-innosetup) â€” needs: `source.pascal`
* [ ] [`source.inputrc`](lang/source.inputrc.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `etc`
* [ ] [`source.io`](lang/source.io.js)
* [ ] [`source.ioke`](lang/source.ioke.js) (mit)
* [ ] [`source.isabelle.root`](lang/source.isabelle.root.js) (bsd-2-clause) â€” [upstream](https://github.com/lsf37/Isabelle.tmbundle)
* [ ] [`source.isabelle.theory`](lang/source.isabelle.theory.js) (bsd-2-clause) â€” [upstream](https://github.com/lsf37/Isabelle.tmbundle)
* [ ] [`source.ispc`](lang/source.ispc.js) (bsd-3-clause) â€” [upstream](https://github.com/ispc/ispc.syntax)
* [ ] [`source.j`](lang/source.j.js) (mit) â€” [upstream](https://github.com/tikkanz/JSyntax)
* [ ] [`source.jai`](lang/source.jai.js) (mit) â€” [upstream](https://github.com/SogoCZE/Jails)
* [ ] [`source.janet`](lang/source.janet.js) (mit) â€” [upstream](https://github.com/janet-lang/vscode-janet)
* [ ] [`source.jasmin`](lang/source.jasmin.js) (wtfpl) â€” [upstream](https://github.com/atmarksharp/jasmin-sublime)
* [ ] [`source.java-properties`](lang/source.java-properties.js) â€” [upstream](https://github.com/textmate/java.tmbundle)
* [ ] [`source.jcl`](lang/source.jcl.js) (mit) â€” [upstream](https://github.com/spgennard/vscode_cobol)
* [ ] [`source.jest.snap`](lang/source.jest.snap.js) (mit) â€” [upstream](https://github.com/jest-community/vscode-jest)
* [ ] [`source.jflex`](lang/source.jflex.js) (bsd-2-clause) â€” [upstream](https://github.com/jflex-de/jflex.tmbundle) â€” needs: `source.java`
* [ ] [`source.jison`](lang/source.jison.js) (mit) â€” needs: `source.jisonlex`
* [ ] [`source.jisonlex`](lang/source.jisonlex.js) (mit) â€” needs: `source.jison`, `source.js`
* [ ] [`source.jolie`](lang/source.jolie.js) (mit)
* [ ] [`source.jq`](lang/source.jq.js) (mit) â€” [upstream](https://github.com/wader/language-jq)
* [ ] [`source.js.objj`](lang/source.js.objj.js) â€” needs: `source.js`
* [ ] [`source.json.comments`](lang/source.json.comments.js) (mit) â€” [upstream](https://github.com/DecimalTurn/vscode-jsonc-syntax-highlighting)
* [ ] [`source.jsoniq`](lang/source.jsoniq.js) (apache-2.0) â€” [upstream](https://github.com/wcandillon/language-jsoniq)
* [ ] [`source.jsonnet`](lang/source.jsonnet.js) (apache-2.0) â€” [upstream](https://github.com/google/language-jsonnet)
* [ ] [`source.julia`](lang/source.julia.js) (mit) â€” [upstream](https://github.com/JuliaEditorSupport/atom-language-julia)
* [ ] [`source.julia.console`](lang/source.julia.console.js) (mit) â€” [upstream](https://github.com/JuliaEditorSupport/atom-language-julia) â€” needs: `source.julia`, `source.shell`
* [ ] [`source.just`](lang/source.just.js) (mit) â€” [upstream](https://github.com/nefrob/vscode-just)
* [ ] [`source.kakscript`](lang/source.kakscript.js) (unlicense) â€” [upstream](https://github.com/kakoune-editor/language-kak)
* [ ] [`source.kdl`](lang/source.kdl.js) (apache-2.0) â€” [upstream](https://github.com/kdl-org/vscode-kdl)
* [ ] [`source.kerboscript`](lang/source.kerboscript.js) (mit) â€” [upstream](https://github.com/KSP-KOS/language-kerboscript)
* [ ] [`source.keyvalues`](lang/source.keyvalues.js) (isc) â€” [upstream](https://github.com/Nixinova/NovaGrammars)
* [ ] [`source.kickstart`](lang/source.kickstart.js) (mit) â€” [upstream](https://github.com/wgwoods/language-kickstart)
* [ ] [`source.koka`](lang/source.koka.js) (apache-2.0) â€” [upstream](https://github.com/koka-community/koka-textmate-grammar)
* [ ] [`source.kusto`](lang/source.kusto.js) (apache-2.0) â€” [upstream](https://github.com/mmanela/kusto-sublime)
* [ ] [`source.lark`](lang/source.lark.js) (isc) â€” [upstream](https://github.com/Alhadis/language-grammars)
* [ ] [`source.lean`](lang/source.lean.js) (apache-2.0) â€” [upstream](https://github.com/leanprover/vscode-lean)
* [ ] [`source.lean4`](lang/source.lean4.js) (apache-2.0) â€” [upstream](https://github.com/leanprover/vscode-lean4)
* [ ] [`source.leo`](lang/source.leo.js) (apache-2.0) â€” [upstream](https://github.com/ProvableHQ/leo-linguist)
* [ ] [`source.lex`](lang/source.lex.js) (isc) â€” [upstream](https://github.com/Alhadis/language-grammars) â€” needs: `source.c++`, `source.jflex`
* [ ] [`source.lex.regexp`](lang/source.lex.regexp.js) (isc) â€” [upstream](https://github.com/Alhadis/language-grammars)
* [ ] [`source.ligo`](lang/source.ligo.js) (mit) â€” [upstream](https://github.com/pewulfman/Ligo-grammar)
* [ ] [`source.lilypond`](lang/source.lilypond.js) (mit) â€” [upstream](https://github.com/nwhetsell/linter-lilypond) â€” needs: `source.lisp`
* [ ] [`source.lisp`](lang/source.lisp.js)
* [ ] [`source.litcoffee`](lang/source.litcoffee.js) (mit) â€” [upstream](https://github.com/atom/language-coffee-script) â€” needs: `source.coffee`, `text.html.basic`
* [ ] [`source.livecodescript`](lang/source.livecodescript.js) (bsd-3-clause) â€” [upstream](https://github.com/Ferruslogic/vscode-livecodescript)
* [ ] [`source.livescript`](lang/source.livescript.js) (apache-2.0) â€” [upstream](https://github.com/sharktide/livescript-vscode)
* [ ] [`source.llvm`](lang/source.llvm.js) (mit) â€” [upstream](https://github.com/whitequark/llvm.tmbundle)
* [ ] [`source.logos`](lang/source.logos.js) (mit) â€” [upstream](https://github.com/Cykey/Sublime-Logos) â€” needs: `source.c++`, `source.objc`
* [ ] [`source.logtalk`](lang/source.logtalk.js)
* [ ] [`source.lolcode`](lang/source.lolcode.js) (mit) â€” [upstream](https://github.com/KrazIvan/LOLCODE-grammar-vscode)
* [ ] [`source.loomscript`](lang/source.loomscript.js) (mit)
* [ ] [`source.lsl`](lang/source.lsl.js)
* [ ] [`source.ltspice.symbol`](lang/source.ltspice.symbol.js) (isc) â€” [upstream](https://github.com/Alhadis/language-pcb)
* [ ] [`source.luau`](lang/source.luau.js) (mit) â€” [upstream](https://github.com/JohnnyMorganz/Luau.tmLanguage)
* [ ] [`source.m2`](lang/source.m2.js) (mit) â€” [upstream](https://github.com/Macaulay2/language-macaulay2)
* [ ] [`source.m3u`](lang/source.m3u.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `etc`
* [ ] [`source.m4`](lang/source.m4.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `etc`
* [ ] [`source.m68k`](lang/source.m68k.js) (mit)
* [ ] [`source.mask`](lang/source.mask.js) (mit) â€” needs: `source.js`, `text.html.basic`
* [ ] [`source.mathematica`](lang/source.mathematica.js) (apache-2.0) â€” [upstream](https://github.com/shadanan/mathematica-tmbundle)
* [ ] [`source.matlab`](lang/source.matlab.js) (bsd-2-clause) â€” [upstream](https://github.com/mathworks/MATLAB-Language-grammar)
* [ ] [`source.maxscript`](lang/source.maxscript.js) (isc)
* [ ] [`source.mc`](lang/source.mc.js) (mit)
* [ ] [`source.mcfunction`](lang/source.mcfunction.js) (mit) â€” [upstream](https://github.com/MinecraftCommands/syntax-mcfunction)
* [ ] [`source.mdx`](lang/source.mdx.js) (mit) â€” [upstream](https://github.com/wooorm/markdown-tm-language) â€” needs: `source.tsx`
* [ ] [`source.mercury`](lang/source.mercury.js) (mit)
* [ ] [`source.mermaid`](lang/source.mermaid.js) (isc) â€” [upstream](https://github.com/Alhadis/language-mermaid) â€” needs: `source.mermaid.c4c-diagram`, `source.mermaid.class-diagram`, `source.mermaid.er-diagram`, `source.mermaid.flowchart`, `source.mermaid.gantt`, `source.mermaid.gitgraph`, `source.mermaid.mindmap`, `source.mermaid.pie-chart`, `source.mermaid.requirement-diagram`, `source.mermaid.sequence-diagram`, `source.mermaid.state-diagram`, `source.mermaid.user-journey`
* [ ] [`source.mermaid.c4c-diagram`](lang/source.mermaid.c4c-diagram.js) (isc) â€” [upstream](https://github.com/Alhadis/language-mermaid) â€” needs: `source.mermaid`, `source.mermaid.user-journey`, `source.wsd`
* [ ] [`source.mermaid.class-diagram`](lang/source.mermaid.class-diagram.js) (isc) â€” [upstream](https://github.com/Alhadis/language-mermaid) â€” needs: `source.mermaid`, `source.mermaid.flowchart`
* [ ] [`source.mermaid.er-diagram`](lang/source.mermaid.er-diagram.js) (isc) â€” [upstream](https://github.com/Alhadis/language-mermaid) â€” needs: `source.mermaid`
* [ ] [`source.mermaid.flowchart`](lang/source.mermaid.flowchart.js) (isc) â€” [upstream](https://github.com/Alhadis/language-mermaid) â€” needs: `source.mermaid`
* [ ] [`source.mermaid.gantt`](lang/source.mermaid.gantt.js) (isc) â€” [upstream](https://github.com/Alhadis/language-mermaid) â€” needs: `source.mermaid`, `source.mermaid.flowchart`
* [ ] [`source.mermaid.gitgraph`](lang/source.mermaid.gitgraph.js) (isc) â€” [upstream](https://github.com/Alhadis/language-mermaid) â€” needs: `source.json`, `source.mermaid`
* [ ] [`source.mermaid.mindmap`](lang/source.mermaid.mindmap.js) (isc) â€” [upstream](https://github.com/Alhadis/language-mermaid) â€” needs: `source.mermaid`, `source.mermaid.flowchart`
* [ ] [`source.mermaid.pie-chart`](lang/source.mermaid.pie-chart.js) (isc) â€” [upstream](https://github.com/Alhadis/language-mermaid) â€” needs: `source.mermaid`
* [ ] [`source.mermaid.requirement-diagram`](lang/source.mermaid.requirement-diagram.js) (isc) â€” [upstream](https://github.com/Alhadis/language-mermaid) â€” needs: `source.mermaid`
* [ ] [`source.mermaid.sequence-diagram`](lang/source.mermaid.sequence-diagram.js) (isc) â€” [upstream](https://github.com/Alhadis/language-mermaid) â€” needs: `source.json`, `source.mermaid`
* [ ] [`source.mermaid.state-diagram`](lang/source.mermaid.state-diagram.js) (isc) â€” [upstream](https://github.com/Alhadis/language-mermaid) â€” needs: `source.mermaid`
* [ ] [`source.mermaid.user-journey`](lang/source.mermaid.user-journey.js) (isc) â€” [upstream](https://github.com/Alhadis/language-mermaid) â€” needs: `source.mermaid`
* [ ] [`source.meson`](lang/source.meson.js) (apache-2.0) â€” [upstream](https://github.com/TingPing/language-meson)
* [ ] [`source.miniyaml`](lang/source.miniyaml.js) (mit) â€” [upstream](https://github.com/OpenRA/atom-miniyaml)
* [ ] [`source.mint`](lang/source.mint.js) (mit) â€” [upstream](https://github.com/mint-lang/mint-vscode) â€” needs: `source.css`, `source.css.scss`, `source.js`
* [ ] [`source.ml`](lang/source.ml.js) â€” [upstream](https://github.com/textmate/standard-ml.tmbundle)
* [ ] [`source.mligo`](lang/source.mligo.js) (mit) â€” [upstream](https://github.com/pewulfman/Ligo-grammar)
* [ ] [`source.mlir`](lang/source.mlir.js) (apache-2.0) â€” [upstream](https://github.com/jpienaar/mlir-grammar)
* [ ] [`source.mo`](lang/source.mo.js) (apache-2.0) â€” [upstream](https://github.com/dfinity/vscode-motoko)
* [ ] [`source.modelica`](lang/source.modelica.js) (mit) â€” [upstream](https://github.com/BorisChumichev/modelicaSublimeTextPackage)
* [ ] [`source.modula-3`](lang/source.modula-3.js) (bsd-3-clause) â€” [upstream](https://github.com/newgrammars/m3)
* [ ] [`source.modula2`](lang/source.modula2.js) (mit) â€” [upstream](https://github.com/harogaston/Sublime-Modula-2)
* [ ] [`source.mojo`](lang/source.mojo.js) (mit) â€” [upstream](https://github.com/modularml/mojo-syntax)
* [ ] [`source.monkey`](lang/source.monkey.js) (mit)
* [ ] [`source.moonbit`](lang/source.moonbit.js) (apache-2.0) â€” [upstream](https://github.com/moonbitlang/moonbit-tmLanguage)
* [ ] [`source.moonscript`](lang/source.moonscript.js) (mit)
* [ ] [`source.move`](lang/source.move.js) (mit) â€” [upstream](https://github.com/damirka/vscode-move-syntax)
* [ ] [`source.mql5`](lang/source.mql5.js) (mit)
* [ ] [`source.msg`](lang/source.msg.js) (mit) â€” [upstream](https://github.com/omnetpp/omnetpp-textmate-msg)
* [ ] [`source.msl`](lang/source.msl.js) (mit) â€” [upstream](https://github.com/gen-angry/language-msl)
* [ ] [`source.mupad`](lang/source.mupad.js) (mit) â€” [upstream](https://github.com/ccreutzig/sublime-MuPAD)
* [ ] [`source.mzn`](lang/source.mzn.js) (mpl-2.0) â€” [upstream](https://github.com/Dekker1/vscode-minizinc)
* [ ] [`source.nanorc`](lang/source.nanorc.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `etc`, `injections.etc`
* [ ] [`source.nasal`](lang/source.nasal.js) (mit) â€” [upstream](https://github.com/BobDotCom/Nasal.tmbundle)
* [ ] [`source.nasl`](lang/source.nasl.js) (mit) â€” [upstream](https://github.com/tenable/sublimetext-nasl)
* [ ] [`source.ncl`](lang/source.ncl.js) (mit)
* [ ] [`source.ne`](lang/source.ne.js) (unlicense) â€” [upstream](https://github.com/Hardmath123/sublime-nearley)
* [ ] [`source.ned`](lang/source.ned.js) (mit) â€” [upstream](https://github.com/omnetpp/omnetpp-textmate-ned)
* [ ] [`source.nemerle`](lang/source.nemerle.js)
* [ ] [`source.neon`](lang/source.neon.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc)
* [ ] [`source.nesc`](lang/source.nesc.js) (mit) â€” needs: `source.c`
* [ ] [`source.netlinx`](lang/source.netlinx.js) (mit)
* [ ] [`source.netlinx.erb`](lang/source.netlinx.erb.js) (mit) â€” needs: `source.netlinx`
* [ ] [`source.nextflow`](lang/source.nextflow.js) (mit) â€” needs: `source.nextflow-groovy`
* [ ] [`source.nextflow-groovy`](lang/source.nextflow-groovy.js) (mit)
* [ ] [`source.nginx`](lang/source.nginx.js) (mit) â€” [upstream](https://github.com/brandonwamboldt/sublime-nginx)
* [ ] [`source.nim`](lang/source.nim.js) (mit) â€” [upstream](https://github.com/nim-lang/NimLime)
* [ ] [`source.ninja`](lang/source.ninja.js) (mit)
* [ ] [`source.nit`](lang/source.nit.js) (wtfpl)
* [ ] [`source.nix`](lang/source.nix.js) (mit) â€” [upstream](https://github.com/sambacha/nix-linguist)
* [ ] [`source.nr`](lang/source.nr.js) (apache-2.0) â€” [upstream](https://github.com/noir-lang/vscode-noir)
* [ ] [`source.nsis`](lang/source.nsis.js) (apache-2.0)
* [ ] [`source.nu`](lang/source.nu.js) (apache-2.0)
* [ ] [`source.nunjucks`](lang/source.nunjucks.js) (mit)
* [ ] [`source.nushell`](lang/source.nushell.js) (mit) â€” [upstream](https://github.com/hustcer/nu-grammar)
* [ ] [`source.nut`](lang/source.nut.js) (mit)
* [ ] [`source.objc++`](lang/source.objc++.js) â€” needs: `source.c++`, `source.objc`
* [ ] [`source.objectscript`](lang/source.objectscript.js) (mit) â€” needs: `source.objectscript_macros`
* [ ] [`source.objectscript_macros`](lang/source.objectscript_macros.js) (mit) â€” needs: `source.objectscript`
* [ ] [`source.ocaml`](lang/source.ocaml.js) â€” needs: `source.camlp4.ocaml`
* [ ] [`source.odin`](lang/source.odin.js) (mit) â€” [upstream](https://github.com/odin-lang/sublime-odin)
* [ ] [`source.odin-ehr`](lang/source.odin-ehr.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `etc`
* [ ] [`source.ooc`](lang/source.ooc.js) (bsd-2-clause)
* [ ] [`source.opa`](lang/source.opa.js) (mit) â€” [upstream](https://github.com/mads379/opa.tmbundle)
* [ ] [`source.opal`](lang/source.opal.js) (mit) â€” [upstream](https://github.com/artifactz/sublime-opal)
* [ ] [`source.opentype`](lang/source.opentype.js) (isc) â€” [upstream](https://github.com/Alhadis/language-fontforge)
* [ ] [`source.opts`](lang/source.opts.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `etc`
* [ ] [`source.overpassql`](lang/source.overpassql.js) (mpl-2.0) â€” [upstream](https://github.com/nickswalker/overpassql-tmlanguage)
* [ ] [`source.ox`](lang/source.ox.js) (mit)
* [ ] [`source.oz`](lang/source.oz.js) (mit)
* [ ] [`source.p4`](lang/source.p4.js) (mit)
* [ ] [`source.pact`](lang/source.pact.js) (bsd-3-clause) â€” [upstream](https://github.com/kadena-io/pact-atom)
* [ ] [`source.pan`](lang/source.pan.js) (mit)
* [ ] [`source.papyrus.skyrim`](lang/source.papyrus.skyrim.js) (mit)
* [ ] [`source.parrot.pir`](lang/source.parrot.pir.js)
* [ ] [`source.pascal`](lang/source.pascal.js)
* [ ] [`source.pawn`](lang/source.pawn.js) (mit)
* [ ] [`source.pcb.board`](lang/source.pcb.board.js) (isc) â€” [upstream](https://github.com/Alhadis/language-pcb) â€” needs: `source.pcb.sexp`
* [ ] [`source.pcb.schematic`](lang/source.pcb.schematic.js) (isc) â€” [upstream](https://github.com/Alhadis/language-pcb) â€” needs: `source.pcb.sexp`, `source.scheme`
* [ ] [`source.pcb.sexp`](lang/source.pcb.sexp.js) (isc) â€” [upstream](https://github.com/Alhadis/language-pcb)
* [ ] [`source.pddl`](lang/source.pddl.js) (mit) â€” [upstream](https://github.com/jan-dolejsi/vscode-pddl)
* [ ] [`source.peggy`](lang/source.peggy.js) (mit) â€” [upstream](https://github.com/peggyjs/code-peggy-language) â€” needs: `source.js`
* [ ] [`source.pep8`](lang/source.pep8.js) (wtfpl)
* [ ] [`source.php.zephir`](lang/source.php.zephir.js) â€” [upstream](https://github.com/phalcon/zephir-sublime)
* [ ] [`source.pic`](lang/source.pic.js) (isc) â€” [upstream](https://github.com/Alhadis/language-roff) â€” needs: `source.shell`, `text.html.basic`, `text.roff`
* [ ] [`source.pig_latin`](lang/source.pig_latin.js) (mit)
* [ ] [`source.pike`](lang/source.pike.js) (unlicense)
* [ ] [`source.pip-requirements`](lang/source.pip-requirements.js) (mit) â€” [upstream](https://github.com/microsoft/vscode-python)
* [ ] [`source.pkl`](lang/source.pkl.js) (apache-2.0) â€” [upstream](https://github.com/apple/pkl.tmbundle)
* [ ] [`source.plist`](lang/source.plist.js) (mit) â€” [upstream](https://github.com/atom/language-property-list)
* [ ] [`source.po`](lang/source.po.js)
* [ ] [`source.pogoscript`](lang/source.pogoscript.js) (mit)
* [ ] [`source.polar`](lang/source.polar.js) (apache-2.0) â€” [upstream](https://github.com/osohq/polar-grammar)
* [ ] [`source.pony`](lang/source.pony.js) (bsd-2-clause) â€” [upstream](https://github.com/CausalityLtd/sublime-pony)
* [ ] [`source.portugol`](lang/source.portugol.js) (mit) â€” [upstream](https://github.com/luisgbr1el/portugol-grammar)
* [ ] [`source.postcss`](lang/source.postcss.js) (mit)
* [ ] [`source.postscript`](lang/source.postscript.js) (isc) â€” [upstream](https://github.com/Alhadis/Atom-PostScript)
* [ ] [`source.pov-ray sdl`](<lang/source.pov-ray sdl.js>) (mit)
* [ ] [`source.powerbuilder`](lang/source.powerbuilder.js) (mit) â€” [upstream](https://github.com/informaticon/PowerBuilder.tmbundle)
* [ ] [`source.powershell`](lang/source.powershell.js) (mit) â€” [upstream](https://github.com/PowerShell/EditorSyntax)
* [ ] [`source.praat`](lang/source.praat.js) (mit) â€” [upstream](https://github.com/orhunulusahin/praatvscode)
* [ ] [`source.prisma`](lang/source.prisma.js) (apache-2.0) â€” [upstream](https://github.com/prisma/vscode-prisma)
* [ ] [`source.processing`](lang/source.processing.js)
* [ ] [`source.procfile`](lang/source.procfile.js) (bsd-3-clause) â€” [upstream](https://github.com/benspaulding/vscode-procfile) â€” needs: `source.shell`
* [ ] [`source.prolog`](lang/source.prolog.js) (mpl-2.0)
* [ ] [`source.prolog.eclipse`](lang/source.prolog.eclipse.js) (mpl-2.0) â€” needs: `source.prolog`
* [ ] [`source.promela`](lang/source.promela.js) (mit) â€” [upstream](https://github.com/corbanmailloux/sublime-promela-spin)
* [ ] [`source.proto`](lang/source.proto.js) (mit) â€” [upstream](https://github.com/zxh0/vscode-proto3)
* [ ] [`source.puppet`](lang/source.puppet.js) (mit) â€” [upstream](https://github.com/russCloak/SublimePuppet)
* [ ] [`source.purescript`](lang/source.purescript.js) (mit) â€” [upstream](https://github.com/purescript-contrib/atom-language-purescript)
* [ ] [`source.python.kivy`](lang/source.python.kivy.js) (mit) â€” [upstream](https://github.com/p0lygun/kivy-language-grammer) â€” needs: `source.python`
* [ ] [`source.q`](lang/source.q.js) (mit) â€” [upstream](https://github.com/komsit37/sublime-q)
* [ ] [`source.qasm`](lang/source.qasm.js) (mit)
* [ ] [`source.QB64`](lang/source.QB64.js) (mit) â€” [upstream](https://github.com/QB64Official/vscode)
* [ ] [`source.ql`](lang/source.ql.js) (mit) â€” [upstream](https://github.com/github/vscode-codeql)
* [ ] [`source.qmake`](lang/source.qmake.js)
* [ ] [`source.qml`](lang/source.qml.js) (mit) â€” needs: `source.js`
* [ ] [`source.qsharp`](lang/source.qsharp.js) (mit) â€” [upstream](https://github.com/microsoft/qsharp)
* [ ] [`source.quake`](lang/source.quake.js) (bsd-3-clause)
* [ ] [`source.quoting.raku`](lang/source.quoting.raku.js) â€” [upstream](https://github.com/perl6/atom-language-perl6) â€” needs: `source.raku`
* [ ] [`source.racket`](lang/source.racket.js) (mit)
* [ ] [`source.raku`](lang/source.raku.js) â€” [upstream](https://github.com/perl6/atom-language-perl6) â€” needs: `source.quoting.raku`
* [ ] [`source.rascal`](lang/source.rascal.js) (bsd-2-clause) â€” [upstream](https://github.com/usethesource/rascal-syntax-highlighting)
* [ ] [`source.rbs`](lang/source.rbs.js) (mit) â€” [upstream](https://github.com/soutaro/vscode-rbs-syntax)
* [ ] [`source.reason`](lang/source.reason.js) (mit) â€” [upstream](https://github.com/reasonml-editor/language-reason)
* [ ] [`source.rebol`](lang/source.rebol.js) (mit) â€” [upstream](https://github.com/Oldes/Sublime-REBOL)
* [ ] [`source.record-jar`](lang/source.record-jar.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `etc`
* [ ] [`source.red`](lang/source.red.js) (mit) â€” [upstream](https://github.com/Oldes/Sublime-Red)
* [ ] [`source.redirects`](lang/source.redirects.js) (isc) â€” [upstream](https://github.com/Nixinova/NovaGrammars)
* [ ] [`source.reg`](lang/source.reg.js) (mit)
* [ ] [`source.regexp`](lang/source.regexp.js) (isc) â€” [upstream](https://github.com/Alhadis/language-regexp) â€” needs: `source.regexp.extended`, `source.regexp.posix`, `source.sy`
* [ ] [`source.regexp.extended`](lang/source.regexp.extended.js) (isc) â€” [upstream](https://github.com/Alhadis/language-regexp) â€” needs: `source.regexp`
* [ ] [`source.regexp.posix`](lang/source.regexp.posix.js) (isc) â€” [upstream](https://github.com/Alhadis/language-regexp) â€” needs: `source.regexp`
* [ ] [`source.regexp.python`](lang/source.regexp.python.js) (mit) â€” [upstream](https://github.com/MagicStack/MagicPython)
* [ ] [`source.rego`](lang/source.rego.js) (apache-2.0) â€” [upstream](https://github.com/open-policy-agent/vscode-opa)
* [ ] [`source.religo`](lang/source.religo.js) (mit) â€” [upstream](https://github.com/pewulfman/Ligo-grammar)
* [ ] [`source.renpy`](lang/source.renpy.js) (mit) â€” [upstream](https://github.com/williamd1k0/language-renpy) â€” needs: `source.regexp.python`
* [ ] [`source.rescript`](lang/source.rescript.js) (mit) â€” [upstream](https://github.com/rescript-lang/rescript-vscode)
* [ ] [`source.rexx`](lang/source.rexx.js) (mit) â€” [upstream](https://github.com/mblocker/rexx-sublime)
* [ ] [`source.rez`](lang/source.rez.js) â€” [upstream](https://github.com/textmate/rez.tmbundle)
* [ ] [`source.ring`](lang/source.ring.js) (mit)
* [ ] [`source.roc`](lang/source.roc.js) (mit) â€” [upstream](https://github.com/ivan-demchenko/roc-vscode-unofficial)
* [ ] [`source.ron`](lang/source.ron.js) (mit) â€” [upstream](https://github.com/a5huynh/vscode-ron)
* [ ] [`source.rpgle`](lang/source.rpgle.js) (mit) â€” [upstream](https://github.com/barrettotte/vscode-ibmi-languages) â€” needs: `source.sql`
* [ ] [`source.rpm-spec`](lang/source.rpm-spec.js) (mit) â€” needs: `source.changelogs.rpm-spec`, `source.shell`
* [ ] [`source.sail`](lang/source.sail.js) (mit) â€” [upstream](https://github.com/Timmmm/sail_vscode)
* [ ] [`source.sas`](lang/source.sas.js) (mit) â€” [upstream](https://github.com/rpardee/sas.tmbundle)
* [ ] [`source.sass`](lang/source.sass.js) (mit) â€” [upstream](https://github.com/atom/language-sass) â€” needs: `source.css`
* [ ] [`source.scad`](lang/source.scad.js) (mit) â€” [upstream](https://github.com/tbuser/openscad.tmbundle)
* [ ] [`source.scala`](lang/source.scala.js) (mit) â€” [upstream](https://github.com/scala/vscode-scala-syntax)
* [ ] [`source.scaml`](lang/source.scaml.js) (apache-2.0) â€” [upstream](https://github.com/scalate/Scalate.tmbundle) â€” needs: `source.scala`
* [ ] [`source.scenic`](lang/source.scenic.js) (mit) â€” [upstream](https://github.com/UCSCFormalMethods/Scenic-tmLanguage)
* [ ] [`source.scheme`](lang/source.scheme.js)
* [ ] [`source.scilab`](lang/source.scilab.js)
* [ ] [`source.scm`](lang/source.scm.js) (mit) â€” [upstream](https://github.com/jrieken/vscode-tree-sitter-query)
* [ ] [`source.sdbl`](lang/source.sdbl.js) (mit) â€” [upstream](https://github.com/1c-syntax/vsc-language-1c-bsl)
* [ ] [`source.sed`](lang/source.sed.js) (isc) â€” [upstream](https://github.com/Alhadis/language-sed)
* [ ] [`source.sepolicy`](lang/source.sepolicy.js) (apache-2.0) â€” [upstream](https://github.com/google/selinux-policy-languages)
* [ ] [`source.sfv`](lang/source.sfv.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc)
* [ ] [`source.shaderlab`](lang/source.shaderlab.js) (mit)
* [ ] [`source.shellcheckrc`](lang/source.shellcheckrc.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `etc`
* [ ] [`source.shen`](lang/source.shen.js) (bsd-3-clause)
* [ ] [`source.sieve`](lang/source.sieve.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc)
* [ ] [`source.singularity`](lang/source.singularity.js) (mit) â€” [upstream](https://github.com/onnovalkering/vscode-singularity)
* [ ] [`source.slang`](lang/source.slang.js) (apache-2.0) â€” [upstream](https://github.com/shader-slang/slang-vscode-extension)
* [ ] [`source.slint`](lang/source.slint.js) (mit) â€” [upstream](https://github.com/slint-ui/slint-tmLanguage)
* [ ] [`source.smali`](lang/source.smali.js) (mit) â€” [upstream](https://github.com/ShaneWilton/sublime-smali)
* [ ] [`source.smalltalk`](lang/source.smalltalk.js) (mit)
* [ ] [`source.smithy`](lang/source.smithy.js) (apache-2.0) â€” [upstream](https://github.com/awslabs/smithy-vscode)
* [ ] [`source.smpl`](lang/source.smpl.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `etc`
* [ ] [`source.smt`](lang/source.smt.js) (unlicense)
* [ ] [`source.solidity`](lang/source.solidity.js) (mit) â€” [upstream](https://github.com/davidhq/SublimeEthereum)
* [ ] [`source.solution`](lang/source.solution.js) (isc) â€” [upstream](https://github.com/Nixinova/NovaGrammars)
* [ ] [`source.sourcepawn`](lang/source.sourcepawn.js) (mit) â€” [upstream](https://github.com/Sarrus1/sourcepawn-vscode)
* [ ] [`source.sparql`](lang/source.sparql.js) (mit) â€” [upstream](https://github.com/peta/turtle.tmbundle) â€” needs: `source.turtle`
* [ ] [`source.spin`](lang/source.spin.js) (zlib) â€” [upstream](https://github.com/bitbased/sublime-spintools)
* [ ] [`source.sqf`](lang/source.sqf.js) (apache-2.0) â€” [upstream](https://github.com/JonBons/Sublime-SQF-Language)
* [ ] [`source.ssh-config`](lang/source.ssh-config.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc)
* [ ] [`source.stan`](lang/source.stan.js) (mit) â€” [upstream](https://github.com/stan-dev/atom-language-stan)
* [ ] [`source.star`](lang/source.star.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc)
* [ ] [`source.stata`](lang/source.stata.js) (mit) â€” [upstream](https://github.com/pschumm/Stata.tmbundle)
* [ ] [`source.stl`](lang/source.stl.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `etc`
* [ ] [`source.string-template`](lang/source.string-template.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `etc`
* [ ] [`source.stylus`](lang/source.stylus.js) (mit)
* [ ] [`source.supercollider`](lang/source.supercollider.js) (mit) â€” [upstream](https://github.com/supercollider/language-supercollider)
* [ ] [`source.svelte`](lang/source.svelte.js) (mit) â€” [upstream](https://github.com/sebastinez/svelte-atom) â€” needs: `source.css`, `source.js`, `source.ts`
* [ ] [`source.sway`](lang/source.sway.js) (apache-2.0) â€” [upstream](https://github.com/FuelLabs/sway-vscode-plugin)
* [ ] [`source.sy`](lang/source.sy.js) (isc) â€” [upstream](https://github.com/Alhadis/language-regexp) â€” needs: `source.regexp`
* [ ] [`source.systemverilog`](lang/source.systemverilog.js) (apache-2.0) â€” [upstream](https://github.com/TheClams/SystemVerilog)
* [ ] [`source.tact`](lang/source.tact.js) (mit) â€” [upstream](https://github.com/tact-lang/tact-sublime)
* [ ] [`source.talon`](lang/source.talon.js) (mit) â€” [upstream](https://github.com/mrob95/vscode-TalonScript)
* [ ] [`source.tcl`](lang/source.tcl.js)
* [ ] [`source.tea`](lang/source.tea.js) (apache-2.0) â€” needs: `source.js`, `text.html.basic`, `text.xml`
* [ ] [`source.templ`](lang/source.templ.js) (mit) â€” [upstream](https://github.com/templ-go/templ-vscode) â€” needs: `source.go`
* [ ] [`source.terra`](lang/source.terra.js) (bsd-3-clause)
* [ ] [`source.textgrid`](lang/source.textgrid.js) (mit) â€” [upstream](https://github.com/orhunulusahin/praatvscode)
* [ ] [`source.textproto`](lang/source.textproto.js) (mit) â€” [upstream](https://github.com/thejustinwalsh/textproto-grammar)
* [ ] [`source.thrift`](lang/source.thrift.js)
* [ ] [`source.tl`](lang/source.tl.js) (mit)
* [ ] [`source.tla`](lang/source.tla.js) (mit)
* [ ] [`source.tlverilog`](lang/source.tlverilog.js) (mit) â€” [upstream](https://github.com/adamint/tlv-vscode)
* [ ] [`source.tm-properties`](lang/source.tm-properties.js) â€” [upstream](https://github.com/textmate/textmate.tmbundle)
* [ ] [`source.toc`](lang/source.toc.js) (unlicense) â€” [upstream](https://github.com/nebularg/language-toc-wow)
* [ ] [`source.toit`](lang/source.toit.js) (mit) â€” [upstream](https://github.com/toitware/ide-tools)
* [ ] [`source.toml`](lang/source.toml.js) â€” [upstream](https://github.com/textmate/toml.tmbundle)
* [ ] [`source.torrc`](lang/source.torrc.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `etc`, `source.hosts`
* [ ] [`source.tsp`](lang/source.tsp.js) (mit) â€” [upstream](https://github.com/microsoft/typespec)
* [ ] [`source.tsql`](lang/source.tsql.js) (mit) â€” [upstream](https://github.com/beau-witter/language-tsql)
* [ ] [`source.tsx`](lang/source.tsx.js) (mit) â€” [upstream](https://github.com/Microsoft/TypeScript-TmLanguage)
* [ ] [`source.turing`](lang/source.turing.js) (isc) â€” [upstream](https://github.com/Alhadis/language-turing)
* [ ] [`source.turtle`](lang/source.turtle.js) (mit) â€” [upstream](https://github.com/peta/turtle.tmbundle)
* [ ] [`source.txl`](lang/source.txl.js) (apache-2.0) â€” [upstream](https://github.com/MikeHoffert/Sublime-Text-TXL-syntax)
* [ ] [`source.typst`](lang/source.typst.js) (apache-2.0) â€” [upstream](https://github.com/michidk/typst-grammar)
* [ ] [`source.uplc`](lang/source.uplc.js) (apache-2.0) â€” [upstream](https://github.com/aiken-lang/vscode-aiken)
* [ ] [`source.ur`](lang/source.ur.js) (mit)
* [ ] [`source.v`](lang/source.v.js) (mit) â€” [upstream](https://github.com/0x9ef/vscode-vlang)
* [ ] [`source.vala`](lang/source.vala.js) (mit) â€” [upstream](https://github.com/technosophos/Vala-TMBundle)
* [ ] [`source.varnish.vcl`](lang/source.varnish.vcl.js) (mit) â€” [upstream](https://github.com/brandonwamboldt/sublime-varnish)
* [ ] [`source.vba`](lang/source.vba.js) (mpl-2.0) â€” [upstream](https://github.com/serkonda7/vscode-vba)
* [ ] [`source.vcard`](lang/source.vcard.js) (mit) â€” [upstream](https://github.com/cstrachan88/vscode-vcard)
* [ ] [`source.velocity`](lang/source.velocity.js) (mit) â€” [upstream](https://github.com/animecyc/AtomLanguageVelocity)
* [ ] [`source.vento`](lang/source.vento.js) (mit) â€” [upstream](https://github.com/ventojs/vscode-vento) â€” needs: `source.js`
* [ ] [`source.verilog`](lang/source.verilog.js)
* [ ] [`source.vhdl`](lang/source.vhdl.js)
* [ ] [`source.vim-snippet`](lang/source.vim-snippet.js) (mit) â€” [upstream](https://github.com/Alhadis/language-viml)
* [ ] [`source.viml`](lang/source.viml.js) (mit) â€” [upstream](https://github.com/Alhadis/language-viml)
* [ ] [`source.vue`](lang/source.vue.js) (mit) â€” [upstream](https://github.com/vuejs/language-tools) â€” needs: `source.css`, `text.html.basic`
* [ ] [`source.vyper`](lang/source.vyper.js) (mit) â€” [upstream](https://github.com/davidhq/SublimeEthereum)
* [ ] [`source.wavefront.mtl`](lang/source.wavefront.mtl.js) (isc) â€” [upstream](https://github.com/Alhadis/language-wavefront)
* [ ] [`source.wavefront.obj`](lang/source.wavefront.obj.js) (isc) â€” [upstream](https://github.com/Alhadis/language-wavefront)
* [ ] [`source.wdl`](lang/source.wdl.js) (apache-2.0) â€” [upstream](https://github.com/stjude-rust-labs/sprocket-vscode)
* [ ] [`source.webassembly`](lang/source.webassembly.js) (isc) â€” [upstream](https://github.com/Alhadis/language-webassembly)
* [ ] [`source.webidl`](lang/source.webidl.js) (mit) â€” [upstream](https://github.com/andik/IDL-Syntax)
* [ ] [`source.wgetrc`](lang/source.wgetrc.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `etc`
* [ ] [`source.wgsl`](lang/source.wgsl.js) (mit) â€” [upstream](https://github.com/wgsl-analyzer/wgsl-analyzer)
* [ ] [`source.whiley`](lang/source.whiley.js) (apache-2.0) â€” [upstream](https://github.com/Whiley/WhileySyntaxBundle)
* [ ] [`source.win32-messages`](lang/source.win32-messages.js) (isc) â€” [upstream](https://github.com/Nixinova/NovaGrammars)
* [ ] [`source.wit`](lang/source.wit.js) (apache-2.0) â€” [upstream](https://github.com/bytecodealliance/vscode-wit)
* [ ] [`source.witcherscript`](lang/source.witcherscript.js) (mit) â€” [upstream](https://github.com/ADawesomeguy/witcherscript-grammar)
* [ ] [`source.wollok`](lang/source.wollok.js) (mit)
* [ ] [`source.wren`](lang/source.wren.js) (mit) â€” [upstream](https://github.com/Nelarius/vscode-wren)
* [ ] [`source.wsd`](lang/source.wsd.js) (mit) â€” [upstream](https://github.com/qjebbs/vscode-plantuml)
* [ ] [`source.x10`](lang/source.x10.js) (apache-2.0)
* [ ] [`source.x86`](lang/source.x86.js) (mit) â€” [upstream](https://github.com/calculuswhiz/Assembly-Syntax-Definition)
* [ ] [`source.xc`](lang/source.xc.js) â€” needs: `source.c`
* [ ] [`source.xlfd`](lang/source.xlfd.js) (isc) â€” [upstream](https://github.com/Alhadis/language-fontforge)
* [ ] [`source.xmake`](lang/source.xmake.js) (mit) â€” [upstream](https://github.com/xmake-io/xmake-lua.tmbundle)
* [ ] [`source.xojo`](lang/source.xojo.js) (apache-2.0) â€” [upstream](https://github.com/jimmckay/XojoSyntaxTM)
* [ ] [`source.xq`](lang/source.xq.js) (apache-2.0) â€” [upstream](https://github.com/wcandillon/language-jsoniq)
* [ ] [`source.xtend`](lang/source.xtend.js) (mit)
* [ ] [`source.yacc`](lang/source.yacc.js) (isc) â€” [upstream](https://github.com/Alhadis/language-grammars) â€” needs: `source.c++`, `source.java`
* [ ] [`source.yaml.salt`](lang/source.yaml.salt.js) (mit) â€” [upstream](https://github.com/saltstack/atom-salt) â€” needs: `source.python`
* [ ] [`source.yang`](lang/source.yang.js) (mit)
* [ ] [`source.yara`](lang/source.yara.js) (mit) â€” [upstream](https://github.com/infosec-intern/vscode-yara)
* [ ] [`source.yasnippet`](lang/source.yasnippet.js) (isc) â€” [upstream](https://github.com/Alhadis/language-emacs-lisp) â€” needs: `source.emacs.lisp`
* [ ] [`source.yul`](lang/source.yul.js) (mit) â€” [upstream](https://github.com/davidhq/SublimeEthereum)
* [ ] [`source.zap`](lang/source.zap.js)
* [ ] [`source.zeek`](lang/source.zeek.js) (bsd-3-clause) â€” [upstream](https://github.com/zeek/zeek-sublime)
* [ ] [`source.zenscript`](lang/source.zenscript.js) (mit) â€” [upstream](https://github.com/CraftTweaker/ZenScript-tmLanguage)
* [ ] [`source.zig`](lang/source.zig.js) (mit) â€” [upstream](https://github.com/ziglang/sublime-zig-language)
* [ ] [`source.zil`](lang/source.zil.js)
* [ ] [`source.zmodel`](lang/source.zmodel.js) (mit) â€” [upstream](https://github.com/zenstackhq/zenstack)
* [ ] [`text.adblock`](lang/text.adblock.js) (mit) â€” [upstream](https://github.com/AdguardTeam/VscodeAdblockSyntax)
* [ ] [`text.bibtex`](lang/text.bibtex.js) â€” [upstream](https://github.com/textmate/latex.tmbundle)
* [ ] [`text.browserslist`](lang/text.browserslist.js) (mit) â€” [upstream](https://github.com/browserslist/browserslist-vscode)
* [ ] [`text.cfml.basic`](lang/text.cfml.basic.js) (mit)
* [ ] [`text.checksums`](lang/text.checksums.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `etc`
* [ ] [`text.codeowners`](lang/text.codeowners.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `etc`
* [ ] [`text.conllu`](lang/text.conllu.js) (apache-2.0)
* [ ] [`text.crontab`](lang/text.crontab.js)
* [ ] [`text.dfy.dafny`](lang/text.dfy.dafny.js) (mit) â€” [upstream](https://github.com/DafnyVSCode/Dafny-VSCode)
* [ ] [`text.elixir`](lang/text.elixir.js) (apache-2.0) â€” [upstream](https://github.com/elixir-lang/elixir-tmbundle) â€” needs: `source.elixir`
* [ ] [`text.eml.basic`](lang/text.eml.basic.js) (mit) â€” [upstream](https://github.com/mariozaizar/language-eml)
* [ ] [`text.gherkin.feature`](lang/text.gherkin.feature.js) (mit) â€” [upstream](https://github.com/cucumber/cucumber-tmbundle)
* [ ] [`text.grammarkdown`](lang/text.grammarkdown.js) (isc) â€” [upstream](https://github.com/Alhadis/language-grammars)
* [ ] [`text.haml`](lang/text.haml.js) (mit) â€” needs: `source.ruby`
* [ ] [`text.html.asciidoc`](lang/text.html.asciidoc.js) (mit) â€” [upstream](https://github.com/zuckschwerdt/asciidoc.tmbundle) â€” needs: `text.html.basic`
* [ ] [`text.html.asdoc`](lang/text.html.asdoc.js) (mit) â€” [upstream](https://github.com/simongregory/actionscript3-tmbundle) â€” needs: `text.html.basic`
* [ ] [`text.html.asp`](lang/text.html.asp.js) â€” needs: `source.asp`, `text.html.basic`
* [ ] [`text.html.cfm`](lang/text.html.cfm.js) (mit) â€” needs: `source.cfscript`, `text.cfml.basic`
* [ ] [`text.html.creole`](lang/text.html.creole.js) (mit) â€” [upstream](https://github.com/Siddley/Creole) â€” needs: `text.html.basic`
* [ ] [`text.html.cshtml`](lang/text.html.cshtml.js) (mit) â€” [upstream](https://github.com/github-linguist/razor-plus) â€” needs: `source.cs`, `text.html.basic`
* [ ] [`text.html.django`](lang/text.html.django.js) â€” needs: `text.html.basic`
* [ ] [`text.html.ecmarkup`](lang/text.html.ecmarkup.js) (isc) â€” [upstream](https://github.com/Alhadis/language-etc) â€” needs: `etc`, `source.yaml`, `text.grammarkdown`, `text.html.basic`
* [ ] [`text.html.ecr`](lang/text.html.ecr.js) (mit) â€” [upstream](https://github.com/atom-crystal/language-crystal) â€” needs: `source.crystal`, `text.html.basic`
* [ ] [`text.html.edge`](lang/text.html.edge.js) (mit) â€” [upstream](https://github.com/edge-js/edge-vscode)
* [ ] [`text.html.elixir`](lang/text.html.elixir.js) (apache-2.0) â€” [upstream](https://github.com/elixir-lang/elixir-tmbundle) â€” needs: `text.elixir`, `text.html.basic`
* [ ] [`text.html.erb`](lang/text.html.erb.js) (mit) â€” [upstream](https://github.com/atom/language-ruby) â€” needs: `source.ruby`, `text.html.basic`
* [ ] [`text.html.ftl`](lang/text.html.ftl.js) (mit) â€” needs: `text.html.basic`
* [ ] [`text.html.handlebars`](lang/text.html.handlebars.js) (mit) â€” [upstream](https://github.com/daaain/Handlebars) â€” needs: `text.html.basic`
* [ ] [`text.html.javadoc`](lang/text.html.javadoc.js)
* [ ] [`text.html.js`](lang/text.html.js.js) (mit) â€” needs: `text.html.basic`
* [ ] [`text.html.jsp`](lang/text.html.jsp.js) â€” [upstream](https://github.com/textmate/java.tmbundle) â€” needs: `text.html.basic`
* [ ] [`text.html.jte`](lang/text.html.jte.js) (apache-2.0) â€” [upstream](https://github.com/maj2c/jte-template-syntax-highlight) â€” needs: `source.java`, `text.html.basic`
* [ ] [`text.html.liquid`](lang/text.html.liquid.js) (mit) â€” [upstream](https://github.com/Shopify/liquid-tm-grammar) â€” needs: `text.html.basic`
* [ ] [`text.html.mako`](lang/text.html.mako.js) (mit) â€” needs: `text.html.basic`
* [ ] [`text.html.markdown.source.gfm.apib`](lang/text.html.markdown.source.gfm.apib.js) (mit) â€” [upstream](https://github.com/apiaryio/api-blueprint-sublime-plugin) â€” needs: `source.js`, `text.html.markdown.source.gfm.mson`
* [ ] [`text.html.markdown.source.gfm.mson`](lang/text.html.markdown.source.gfm.mson.js) (mit) â€” [upstream](https://github.com/apiaryio/api-blueprint-sublime-plugin)
* [ ] [`text.html.mediawiki`](lang/text.html.mediawiki.js)
* [ ] [`text.html.nunjucks`](lang/text.html.nunjucks.js) (mit) â€” needs: `source.nunjucks`, `text.html.basic`
* [ ] [`text.html.php.blade`](lang/text.html.php.blade.js) (mit) â€” needs: `text.html.basic`
* [ ] [`text.html.riot`](lang/text.html.riot.js) (mit)
* [ ] [`text.html.slash`](lang/text.html.slash.js) (mit) â€” needs: `text.html.basic`
* [ ] [`text.html.smarty`](lang/text.html.smarty.js) â€” needs: `text.html.basic`
* [ ] [`text.html.soy`](lang/text.html.soy.js) (mit) â€” needs: `text.html.basic`
* [ ] [`text.html.statamic`](lang/text.html.statamic.js) (mit) â€” [upstream](https://github.com/Stillat/vscode-antlers-language-server) â€” needs: `text.html.basic`
* [ ] [`text.html.twig`](lang/text.html.twig.js) (bsd-3-clause) â€” [upstream](https://github.com/Anomareh/PHP-Twig.tmbundle)
* [ ] [`text.jade`](lang/text.jade.js) (mit) â€” needs: `source.js`, `text.html.basic`
* [ ] [`text.marko`](lang/text.marko.js) (mit) â€” [upstream](https://github.com/marko-js/marko-tmbundle) â€” needs: `source.js`
* [ ] [`text.muse`](lang/text.muse.js) (isc) â€” [upstream](https://github.com/Alhadis/language-emacs-lisp)
* [ ] [`text.python.console`](lang/text.python.console.js) (mit) â€” [upstream](https://github.com/MagicStack/MagicPython) â€” needs: `source.python`
* [ ] [`text.python.traceback`](lang/text.python.traceback.js) (mit) â€” [upstream](https://github.com/MagicStack/MagicPython) â€” needs: `source.python`
* [ ] [`text.rdoc`](lang/text.rdoc.js) (mit)
* [ ] [`text.restructuredtext`](lang/text.restructuredtext.js) (mit) â€” [upstream](https://github.com/Lukasa/language-restructuredtext)
* [ ] [`text.robot`](lang/text.robot.js) (apache-2.0) â€” [upstream](https://github.com/shellderp/sublime-robot-plugin)
* [ ] [`text.robots-txt`](lang/text.robots-txt.js) (isc) â€” [upstream](https://github.com/Nixinova/NovaGrammars)
* [ ] [`text.roff`](lang/text.roff.js) (isc) â€” [upstream](https://github.com/Alhadis/language-roff) â€” needs: `source.ditroff`, `source.gremlin`, `source.ideal`, `source.pic`
* [ ] [`text.rtf`](lang/text.rtf.js) (mit) â€” [upstream](https://github.com/nwhetsell/language-rtf)
* [ ] [`text.runoff`](lang/text.runoff.js) (isc) â€” [upstream](https://github.com/Alhadis/language-roff)
* [ ] [`text.sfd`](lang/text.sfd.js) (isc) â€” [upstream](https://github.com/Alhadis/language-fontforge) â€” needs: `source.fontforge`
* [ ] [`text.shell-session`](lang/text.shell-session.js) (mit) â€” [upstream](https://github.com/atom/language-shellscript) â€” needs: `source.shell`
* [ ] [`text.slim`](lang/text.slim.js) (mit) â€” needs: `text.html.basic`
* [ ] [`text.srt`](lang/text.srt.js) (isc) â€” [upstream](https://github.com/Alhadis/language-subtitles) â€” needs: `text.html.basic`
* [ ] [`text.tex`](lang/text.tex.js) â€” [upstream](https://github.com/textmate/latex.tmbundle) â€” needs: `source.r`
* [ ] [`text.tex.latex`](lang/text.tex.latex.js) â€” [upstream](https://github.com/textmate/latex.tmbundle) â€” needs: `text.tex`
* [ ] [`text.tex.latex.haskell`](lang/text.tex.latex.haskell.js) (mit) â€” [upstream](https://github.com/atom-haskell/language-haskell) â€” needs: `source.haskell`, `text.tex.latex`
* [ ] [`text.tex.latex.sweave`](lang/text.tex.latex.sweave.js) â€” [upstream](https://github.com/textmate/sweave.tmbundle) â€” needs: `source.r`, `text.tex.latex`
* [ ] [`text.texinfo`](lang/text.texinfo.js) (isc) â€” [upstream](https://github.com/Alhadis/language-texinfo)
* [ ] [`text.vim-help`](lang/text.vim-help.js) (mit) â€” [upstream](https://github.com/Alhadis/language-viml) â€” needs: `source.viml`
* [ ] [`text.vtt`](lang/text.vtt.js) (isc) â€” [upstream](https://github.com/Alhadis/language-subtitles) â€” needs: `text.html.basic`
* [ ] [`text.xml.ant`](lang/text.xml.ant.js) (mit) â€” needs: `text.xml`
* [ ] [`text.xml.plist`](lang/text.xml.plist.js) (mit) â€” [upstream](https://github.com/atom/language-property-list) â€” needs: `text.xml`
* [ ] [`text.xml.pom`](lang/text.xml.pom.js) â€” needs: `source.groovy`, `text.xml`
* [ ] [`text.xml.xsl`](lang/text.xml.xsl.js) â€” needs: `text.xml`
* [ ] [`text.zone_file`](lang/text.zone_file.js) (mit) â€” [upstream](https://github.com/sixty4k/st2-zonefile)

<!--support end-->

## Compatibility

This project is compatible with maintained versions of Node.js.

When we cut a new major release,
we drop support for unmaintained versions of Node.
This means we try to keep the current release line,
`wooorm@starry-night@3`,
compatible with Node.js 16.

You can pass your own TextMate grammars,
provided that they work with
[`vscode-textmate`][github-vscode-textmate],
and that they have the added fields `extensions`,
`names`,
and `scopeName`
(see types for the definitions and the grammars in `lang/` for examples).

## Security

This package is safe.

## Related

* [`lowlight`][github-lowlight]
  â€” similar but based on `highlight.js`
* [`refractor`][github-refractor]
  â€” similar but based on `Prism`

## Contribute

Yes please!
See [How to Contribute to Open Source][opensource-guide-contribute].

## License

The grammars included in this package are covered by their repositoriesâ€™
respective licenses,
which are permissive
(`apache-2.0`, `mit`, etc),
and made available in [`notice`][file-notice].

All other files [MIT][file-license] Â© [Titus Wormer][wooorm]

<br>

[![](media/slice-3.jpg)][artsandculture-google-starry-night]

<!-- Definitions -->

[api-all]: #all

[api-common]: #common

[api-create-starry-night]: #createstarrynightgrammars-options

[api-get-oniguruma-url]: #getonigurumaurl

[api-grammar]: #grammar

[api-options]: #options

[artsandculture-google-starry-night]: https://artsandculture.google.com/asset/the-starry-night/bgEuwDxel93-Pg

[badge-build-image]: https://github.com/wooorm/starry-night/workflows/main/badge.svg

[badge-build-url]: https://github.com/wooorm/starry-night/actions

[badge-coverage-image]: https://img.shields.io/codecov/c/github/wooorm/starry-night.svg

[badge-coverage-url]: https://codecov.io/github/wooorm/starry-night

[badge-downloads-image]: https://img.shields.io/npm/dm/@wooorm/starry-night.svg

[badge-downloads-url]: https://www.npmjs.com/package/@wooorm/starry-night

[badge-size-image]: https://img.shields.io/bundlejs/size/@wooorm/starry-night?exports=createStarryNight

[badge-size-url]: https://bundlejs.com/?q=@wooorm/starry-night

[esmsh]: https://esm.sh

[file-license]: license

[file-notice]: notice

[github-gist-esm]: https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c

[github-hast]: https://github.com/syntax-tree/hast

[github-hast-root]: https://github.com/syntax-tree/hast#root

[github-hast-util-to-dom]: https://github.com/syntax-tree/hast-util-to-dom

[github-hast-util-to-html]: https://github.com/syntax-tree/hast-util-to-html

[github-hast-util-to-jsx-runtime]: https://github.com/syntax-tree/hast-util-to-jsx-runtime

[github-linguist-languages-yml]: https://github.com/github-linguist/linguist/blob/b5432eb/lib/linguist/languages.yml#L4031

[github-lowlight]: https://github.com/wooorm/lowlight

[github-markdown-tm-language]: https://github.com/wooorm/markdown-tm-language

[github-pages-license]: https://github.com/github/pages-gem/issues/160#issuecomment-134565796

[github-pages-pygments]: https://github.com/github/pages-gem/pull/79#issuecomment-85997762

[github-refractor]: https://github.com/wooorm/refractor

[github-rehype]: https://github.com/rehypejs/rehype

[github-rehype-starry-night]: https://github.com/rehypejs/rehype-starry-night

[github-shiki]: https://github.com/shikijs/shiki

[github-tree-sitter-tree-lights]: https://github.com/tree-sitter/tree-sitter/pull/283#issuecomment-465509157

[github-unified]: https://github.com/unifiedjs/unified

[github-vscode-oniguruma]: https://github.com/microsoft/vscode-oniguruma

[github-vscode-textmate]: https://github.com/microsoft/vscode-textmate

[npmjs-install]: https://docs.npmjs.com/cli/install

[npmjs-using-npm-script-dependencies]: https://docs.npmjs.com/cli/v11/using-npm/scripts#dependencies

[opensource-guide-contribute]: https://opensource.guide/how-to-contribute/

[section-css]: #css

[typescript]: https://www.typescriptlang.org

[wooorm]: https://wooorm.com
</file>

<file path="src/Artifacts/A55. DCE - FSService Refactoring Plan.md">
# Artifact A55: DCE - FSService Refactoring Plan
# Date Created: C113
# Author: AI Model & Curator
# Updated on: C114 (Mark refactor as complete)

- **Key/Value for A0:**
- **Description:** Outlines a strategic plan to refactor the monolithic `FSService` into smaller, more focused services to improve modularity, maintainability, and reduce token count.
- **Tags:** refactor, architecture, technical debt, services

## 1. Problem Statement

The `FSService` has become a "god object," handling a wide range of responsibilities beyond basic file system interactions and now violates the Single Responsibility Principle. Its large size (over 800 lines) makes it difficult to maintain, debug, and reason about. The service currently manages at least four distinct areas of concern:
1.  **Workspace State:** Building, caching, and watching the file tree.
2.  **File Operations:** Handling requests to create, move, delete, and modify files.
3.  **Content Virtualization:** Processing special file types like PDF, Word, and Excel into text.
4.  **Syntax Highlighting:** Managing the `starry-night` library and processing highlighting requests.

## 2. Refactoring Plan (Completed in C114)

The `FSService` has been successfully broken down into four new, more focused services. This has improved code organization, reduced the token count of individual files, and made the system more modular and maintainable.

### 2.1. New Service Structure

#### 1. `FileTreeService`
-   **Responsibility:** All "read" operations related to the workspace structure. This service is the source of truth for what the workspace looks like.
-   **Methods moved here:**
    -   `handleWorkspaceFilesRequest`
    -   `buildTreeFromTraversal`, `_traverseDirectory`, `_aggregateStats`
    -   `getFileStats`
    -   `getGitStatusMap`, `getProblemCountsMap`
    -   `initializeWatcher`, `triggerFullRefresh`, `triggerDiagnosticsUpdate`
    -   `fileTreeCache` property

#### 2. `FileOperationService`
-   **Responsibility:** All "write" or direct modification operations on the file system.
-   **Methods moved here:**
    -   `handleNewFileRequest`
    -   `handleNewFolderRequest`
    -   `handleFileRenameRequest`
    -   `handleMoveFileRequest`
    -   `handleFileDeleteRequest`, `handleBatchFileDeleteRequest`
    -   `handleCopyFileRequest`, `handleCopyFileFromUri`, `handleAddFileFromBuffer`
    -   `handleOpenFileRequest`
    -   `handleRevealInExplorerRequest`
    -   `handleCopyPathRequest`

#### 3. `ContentExtractionService`
-   **Responsibility:** Handling the on-demand parsing and virtualization of special, non-text file formats.
-   **Methods moved here:**
    -   `handlePdfToTextRequest`, `getVirtualPdfContent`, `pdfTextCache`
    -   `handleExcelToTextRequest`, `getVirtualExcelContent`, `excelMarkdownCache`
    -   `handleWordToTextRequest`, `getVirtualWordContent`, `wordTextCache`
    -   `_sheetToMarkdown` (private helper)

#### 4. `HighlightingService`
-   **Responsibility:** All logic related to syntax highlighting.
-   **Methods moved here:**
    -   `initializeStarryNight`
    -   `handleSyntaxHighlightRequest`
    -   `starryNight` property

### 2.2. Integration

-   The main `services.ts` container was updated to instantiate all four new services.
-   The `on-message.ts` handlers were updated to call the correct methods on the new, more specific services.
-   The original `fs.service.ts` file has been deleted.

## 3. Benefits Achieved

-   **Reduced Complexity:** Each service is now significantly smaller and easier to understand.
-   **Improved Maintainability:** Bugs or feature requests will be easier to implement in the correct, isolated service.
-   **Clear Separation of Concerns:** The architecture now follows best practices.
-   **Lower Token Count:** Splitting the large file into four smaller ones makes each file more manageable.

<Original fs.service.ts>
Removed after completing refactor.
</Original fs.service.ts>
</file>

<file path="src/Artifacts/A56. DCE - Phase 2 - Advanced Diff Viewer Plan.md">
# Artifact A56: DCE - Phase 2 - Advanced Diff Viewer Plan
# Date Created: C120
# Author: AI Model & Curator
# Updated on: C129 (Switch to vertical layout, fixed panes, and bottom controls)

- **Key/Value for A0:**
- **Description:** Details the plan to enhance the integrated diff viewer with a vertical layout, fixed-size panes, and WinMerge-like navigation controls to jump between differences.
- **Tags:** feature plan, phase 2, ui, ux, diff, navigation, vertical-layout

## 1. Overview & Goal

The current diff view is functional but lacks key usability features found in mature diff tools like WinMerge. The goal of this plan is to enhance the diff viewer to provide a much clearer and more efficient user experience. This involves several key enhancements:
1.  **Vertical Layout:** Displaying the original and modified files in two panes, one on top of the other, to better facilitate line-by-line comparison.
2.  **Fixed-Size Panes:** The two panes will have a fixed height and will be internally scrollable, preventing the overall UI from shifting when navigating between diffs of different lengths.
3.  **Relocated Navigation Controls:** The "Next/Previous Difference" buttons will be moved to a stable location below the diff panes.
4.  **Difference Detail Panes:** Adding two panes at the bottom of the view to show the specific lines of the currently selected difference, with character-level highlighting.
5.  **Exit Mechanism:** Providing a clear button to exit the diff view and return to the summary view.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| P2-DIFF-01 | **Vertical Colored Diffs** | As a developer, I want to see a top-and-bottom view of the original and modified code with a colored background for changed lines, so I can immediately identify changes at a glance. | - The diff view is split into two horizontal panes: "Original" on top, "Modified" on the bottom. <br> - Lines that exist in the new version but not the old have a distinct background color (e.g., light green) in the bottom pane. <br> - Lines that exist in the old version but not the new have a different background color (e.g., light red) in the top pane. <br> - Unchanged lines have the standard editor background color in both panes. |
| P2-DIFF-02 | **Fixed-Size Panes** | As a developer, I want the diff panes to remain a constant size when I navigate between differences, so the UI controls do not move around. | - Each diff pane has a fixed height (e.g., `flex-basis: 50%` or a pixel value). <br> - If the code content exceeds the pane's height, a vertical scrollbar appears within that pane. |
| P2-DIFF-03 | **Navigate Between Diffs** | As a developer reviewing a large file, I want "Next Difference" and "Previous Difference" buttons located below the diff panes, so I can quickly jump between changed blocks without the buttons moving. | - "Next Difference" (`â†“`) and "Previous Difference" (`â†‘`) buttons are located in a stable toolbar below the main diff panes. <br> - Clicking "Next Difference" scrolls the view to the start of the next block of added or removed lines and highlights it as a single block. |
| P2-DIFF-04 | **Exit Diff View** | As a developer in the diff view, I want a clear way to return to the summary and file list view, so I can select a different file or review the AI's plan. | - A "Back to Code" or similar button is present in the UI. <br> - Clicking it returns the UI to the two-pane summary/code viewer layout. |
| P2-DIFF-05 | **View Diff Details with Phantom Spaces**| As a developer, I want the detail pane to show a character-level diff of the selected change, using phantom spaces to align the unchanged parts of the text. | - The detail panes at the bottom show the character-level differences for the selected line(s). <br> - Unchanged text is aligned vertically between the two panes through the insertion of non-breaking spaces. |

## 3. Technical Implementation Plan

### 3.1. Vertical Diff Logic (`DiffViewer.tsx`)

-   **Layout:** The main container for the two panes will have `flex-direction: column`.
-   **Data Structure:** The existing `PairedLine` data structure is still valid for generating the content of each pane.
-   **Block Highlighting:**
    *   A new function will identify the start and end indices of a contiguous diff block.
    *   The render logic will be refactored. Instead of applying a class to each `.line`, it will map over the `pairedLines` array and group consecutive `isDiff: true` lines. Each group will be wrapped in a single `<div class="diff-block selected-diff">` to create the block highlight effect.

### 3.2. Detail Panes & UI Controls (`DiffViewer.tsx`, `view.tsx`)

-   **Relocated Controls (`DiffViewer.tsx`):** The navigation buttons will be moved out of the main PCPP header and into a new `.diff-detail-header` div within the `DiffViewer` component itself, positioning them between the main diff view and the bottom detail panes.
-   **Character-Level Diff with Phantom Spaces (`DiffViewer.tsx`):**
    *   A new `renderCharDiff` function will be implemented.
    *   It will take the original and modified text of a diff block.
    *   It will use `diffChars` from the `diff` library.
    *   It will iterate through the changes. For `added` parts, it will render the text in the "modified" pane and an equivalent number of non-breaking spaces (`&nbsp;`) in the "original" pane. For `removed` parts, it will do the opposite. `common` parts are rendered in both. This will achieve the desired alignment.

### 3.3. Styling (`view.scss`)

-   Update the `.diff-viewer-container` to use `flex-direction: column`.
-   Add `flex-basis`, `min-height: 0`, and `overflow-y: auto` to the `.diff-pane` class to enforce fixed, scrollable panes.
-   Add styling for the new `.diff-block` and `.selected-diff` classes to create the block highlight effect.
-   Add styling for the new `.diff-detail-header` and the navigation controls within it.
-   Add styles for `.phantom-space` to render the alignment characters correctly (e.g., with a subtle background).
</file>

<file path="src/Artifacts/A57. DCE - Phase 2 - Cycle Management Plan.md">
# Artifact A57: DCE - Phase 2 - Cycle Management Plan
# Date Created: C125
# Author: AI Model & Curator

- **Key/Value for A0:**
- **Description:** Outlines the user stories and technical implementation for deleting cycles and resetting the PCPP history.
- **Tags:** feature plan, phase 2, ui, ux, history, cycle management

## 1. Overview & Goal

As the number of development cycles increases, users need tools to manage their history within the Parallel Co-Pilot Panel (PCPP). The goal of this feature is to provide basic but essential management capabilities, allowing users to delete unwanted cycles and completely reset the history if needed. This keeps the history relevant and manageable.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| P2-CM-01 | **Delete a Cycle** | As a developer, I want to be able to delete a specific cycle from my history, so I can remove erroneous or irrelevant entries. | - A "Delete Cycle" button is available in the "Cycle & Context" section. <br> - Clicking it prompts for confirmation (e.g., "Are you sure you want to delete Cycle X?"). <br> - Upon confirmation, the specified cycle is removed from the `dce_history.json` file. <br> - The UI automatically navigates to the next available cycle (e.g., the previous one or the new latest one). |
| P2-CM-02 | **Reset All History** | As a developer, I want to be able to reset the entire PCPP history, so I can start a project fresh without old cycle data. | - A "Reset History" button is available. <br> - Clicking it shows a strong confirmation warning (e.g., "This will delete ALL cycles and cannot be undone."). <br> - Upon confirmation, the `dce_history.json` file is deleted. <br> - The UI reloads to a fresh "Cycle 1" state. |

## 3. Technical Implementation Plan

1.  **IPC Channels (`channels.enum.ts`, `channels.type.ts`):**
    *   Create `ClientToServerChannel.RequestDeleteCycle` with a payload of `{ cycleId: number }`.
    *   Create `ClientToServerChannel.RequestResetHistory` with an empty payload.

2.  **Backend (`history.service.ts`):**
    *   **`deleteCycle(cycleId: number)`:**
        *   Read the `dce_history.json` file.
        *   Filter the `cycles` array to remove the entry where `cycle.cycleId === cycleId`.
        *   If only one cycle remains, do not allow deletion, or handle it by resetting to a default state.
        *   Write the updated history file back to disk.
    *   **`resetHistory()`:**
        *   Use `vscode.workspace.fs.delete` to remove the `dce_history.json` file.
        *   The existing logic in `getLatestCycle` will automatically create a new, default "Cycle 1" the next time data is requested.

3.  **Frontend (`view.tsx`):**
    *   **UI Buttons:** Add "Delete Cycle" and "Reset History" icon buttons to the `cycle-navigator` div.
    *   **Event Handlers:**
        *   The `onClick` handler for "Delete Cycle" will call `vscode.window.showWarningMessage` to confirm. If the user confirms, it will send the `RequestDeleteCycle` IPC message with the `currentCycle` ID. After sending, it should trigger a request for the new latest cycle data to refresh the UI.
        *   The `onClick` handler for "Reset History" will do the same, but for the `RequestResetHistory` message.

4.  **Message Handling (`on-message.ts`):**
    *   Add handlers for the new IPC channels that call the corresponding methods in `HistoryService`.
    *   After a successful deletion or reset, the backend should send a message back to the client (e.g., a `ForceRefresh` or a new dedicated message) to trigger a full state reload.
</file>

<file path="src/Artifacts/A58. DCE - WinMerge Source Code Analysis.md">
# Artifact A58: DCE - WinMerge Source Code Analysis
# Date Created: C129
# Author: AI Model & Curator
# Updated on: C130 (Add Architectural and UX Insights)

- **Key/Value for A0:**
- **Description:** Documents the key files and concepts from the WinMerge source code that are relevant to building a high-quality diff viewer.
- **Tags:** research, analysis, diff, winmerge, source code

## 1. Overview

To significantly improve the quality of our integrated diff viewer, an analysis of the open-source WinMerge utility was conducted. This document codifies the key findings from that analysis, listing the most valuable files from the WinMerge source code. These files serve as a reference for implementing advanced diffing features such as a more accurate core algorithm, inline (intra-line) difference highlighting, and moved block detection, as well as architectural patterns for creating a robust and flexible tool.

## 2. Key Reference Files from WinMerge Source

The following files from the WinMerge repository contain the core concepts needed to elevate our diff viewer's quality.

### 2.1. Core Algorithm & Heuristics

These files detail the logic behind WinMerge's highly optimized and accurate line-level diffing, which is based on the GNU `diffutils` engine.

*   **`Winmerge-Src\Src\diffutils\src\analyze.c`**: The heart of the GNU diff algorithm. The `diag` function implements the core logic for finding the "shortest edit script." Studying this reveals the heuristics used to achieve high-quality and performant diffs.
*   **`Winmerge-Src\Src\DiffWrapper.cpp`**: This is a C++ wrapper around the `diffutils` engine. It demonstrates how the raw output from the C functions is processed into a more usable format for the application, serving as a model for processing diff results.

### 2.2. Inline (Intra-Line) Difference Highlighting

This file contains the logic for highlighting the specific characters that have changed *within* a line.

*   **`Winmerge-Src\Src\stringdiffs.cpp`**: Contains WinMerge's dedicated algorithm for performing intra-line diffs. Analyzing its approach can help improve our own character-level diff rendering.

### 2.3. Moved Block Detection

This is one of WinMerge's most powerful features, providing essential context for refactoring.

*   **`Winmerge-Src\Src\MovedBlocks.cpp`**: This file contains the complete algorithm WinMerge uses to analyze the diff list, find matching blocks of text that have been moved, and link them together. This is the primary reference for implementing this feature.

### 2.4. Data Structures & UI Rendering

These files show how the data is structured and rendered to the user in the side-by-side view.

*   **`Winmerge-Src\Src\MergeDoc.cpp`**: Acts as the data model for the application. It shows how the diff list is structured to accommodate advanced concepts like moved lines. Our `PairedLine` interface can be modeled on the data structures found here.
*   **`Winmerge-Src\Src\MergeEditView.cpp`**: This is the main rendering component. It contains the logic for taking the results of the line and intra-line diffs and drawing the text with the correct highlighting and layout.
*   **`Winmerge-Src\Src\DiffList.h`**: This header defines the core data structures for the list of differences and is an excellent reference for designing a more robust data model.
*   **`Winmerge-Src\Src\MainFrm.cpp`**: The main application window frame. This file is valuable for understanding how the different components (the document/model, the view, user options, etc.) are all integrated and managed at the application level.

## 3. Architectural and UX Insights (C130)

Beyond specific algorithms, the WinMerge source code reveals important architectural patterns for building a high-quality diffing tool.

*   **Configurability (`CompareOptions.h`, `OptionsMgr.h`):** WinMerge is extremely configurable. The code shows a clear separation between the core diffing logic and the user-configurable options (e.g., whitespace handling, case sensitivity, filtering). This is a strong pattern to emulate, ensuring our tool can be adapted to various user needs.
*   **Text Encoding (`unicoder.h`, `codepage_detect.cpp`):** The project has dedicated, robust code for detecting and handling different text encodings. This is a critical, non-trivial feature for a diff tool that must work with files from various sources. It highlights the importance of pre-processing file content into a consistent format *before* passing it to the diff algorithm.
*   **Pluggable Compare Engines (`CompareEngines` directory):** WinMerge uses a strategy pattern, allowing different comparison engines (e.g., `BinaryCompare`, `ImageCompare`, `TimeSizeCompare`) to be used. This is a powerful architectural concept that could allow our tool to be extended with new comparison methods in the future (e.g., semantic code diffing).

## 4. Path Forward

By studying the algorithms and architectural patterns in these key files, we can create a clear development plan to implement these advanced features in our TypeScript and React-based extension. The immediate priority is to refactor our UI to a vertical, fixed-pane layout, and then we can begin to incrementally incorporate the more advanced logic inspired by these files.
</file>

<file path="src/Artifacts/A6. DCE - Initial Scaffolding Deployment Script.md">
# Artifact A6: DCE - Initial Scaffolding Deployment Script
# Date Created: Cycle 3
# Author: AI Model
# Updated on: Cycle 10 (Fix problemMatcher in tasks.json to resolve F5 launch error)

- **Description:** Contains a Node.js script that, when executed, creates the entire initial directory structure and files for the DCE extension project.
- **Tags:** deployment, script, scaffolding, bootstrap, nodejs, automation

## 1. Overview

This artifact contains the `deploy_scaffold.js` script. Its purpose is to automate the creation of the initial project structure for the Data Curation Environment (DCE) VS Code extension. This eliminates the need for manual file creation and ensures a consistent setup based on our agreed-upon architecture, including the necessary configurations for debugging.

## 2. How to Use

1.  Save the code below as `deploy_scaffold.js` in your project's root directory (e.g., `C:\Projects\DCE\`).
2.  Open a terminal in that directory.
3.  Run the script using Node.js: `node deploy_scaffold.js`
4.  The script will create all the necessary directories and files, including the `.vscode` folder with `launch.json` and a corrected `tasks.json`, logging its progress to the console.

## 3. Script: `deploy_scaffold.js`

```javascript
const fs = require('fs').promises;
const path = require('path');

// --- File Content Definitions ---

const filesToCreate = [
    {
        path: 'package.json',
        content: `{
    "name": "data-curation-environment",
    "publisher": "DCE-Developer",
    "displayName": "Data Curation Environment",
    "description": "A VS Code extension for curating context for Large Language Models.",
    "version": "0.0.1",
    "engines": {
        "vscode": "^1.90.0"
    },
    "categories": [
        "Other"
    ],
    "activationEvents": [
        "onView:viewType.sidebar.contextChooser"
    ],
    "main": "./dist/extension.js",
    "contributes": {
        "viewsContainers": {
            "activitybar": [
                {
                    "id": "data-curation-environment",
                    "title": "Data Curation",
                    "icon": "public/spiral.svg"
                }
            ]
        },
        "views": {
            "data-curation-environment": [
                {
                    "type": "webview",
                    "id": "viewType.sidebar.contextChooser",
                    "name": "Context Chooser"
                }
            ]
        }
    },
    "scripts": {
        "vscode:prepublish": "npm run package",
        "compile": "webpack",
        "watch": "webpack --watch",
        "package": "webpack --mode production --devtool hidden-source-map",
        "lint": "eslint src --ext ts"
    },
    "devDependencies": {
        "@types/node": "18.x",
        "@types/vscode": "^1.90.0",
        "@typescript-eslint/eslint-plugin": "^7.7.1",
        "@typescript-eslint/parser": "^7.7.1",
        "eslint": "^8.57.0",
        "ts-loader": "^9.5.1",
        "typescript": "^5.4.5",
        "webpack": "^5.91.0",
        "webpack-cli": "^5.1.4",
        "copy-webpack-plugin": "^12.0.2",
        "style-loader": "^4.0.0",
        "css-loader": "^7.1.2",
        "sass-loader": "^16.0.1",
        "sass": "^1.78.0",
        "postcss-loader": "^8.1.1",
        "babel-loader": "^9.1.3",
        "@babel/preset-react": "^7.24.7",
        "@babel/preset-typescript": "^7.24.7",
        "process": "^0.11.10"
    },
    "dependencies": {
        "react": "^18.3.1",
        "react-dom": "^18.3.1",
        "react-icons": "^5.3.0",
        "rxjs": "^7.8.1",
        "reflect-metadata": "^0.2.2"
    }
}`
    },
    {
        path: 'tsconfig.json',
        content: `{
    "compilerOptions": {
        "module": "esnext",
        "moduleResolution": "node",
        "target": "ESNext",
        "lib": ["ES2022", "DOM"],
        "jsx": "react",
        "sourceMap": true,
        "rootDir": ".",
        "strict": false,
        "baseUrl": ".",
        "paths": {
            "@/*": ["src/*"]
        },
        "experimentalDecorators": true,
        "allowSyntheticDefaultImports": true
    },
    "include": ["src/**/*"]
}`
    },
    {
        path: 'webpack.config.js',
        content: `const path = require('path');
const CopyPlugin = require("copy-webpack-plugin");
const webpack = require('webpack');

/** @type {import('webpack').Configuration} */
const config = {
    target: 'node',
    mode: 'none',
    entry: {
        extension: './src/extension.ts',
        contextChooserView: './src/client/views/context-chooser.view/view.tsx',
    },
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: '[name].js',
        libraryTarget: 'commonjs2'
    },
    externals: {
        vscode: 'commonjs vscode'
    },
    resolve: {
        extensions: ['.ts', '.js', '.tsx', '.jsx'],
        alias: {
            "@": path.resolve(__dirname, 'src'),
        }
    },
    module: {
        rules: [
            {
                test: /\\.ts$/,
                exclude: /node_modules/,
                use: [{ loader: 'ts-loader' }]
            },
            {
                test: /\\.?ts.?(x)$/,
                exclude: /node_modules/,
                use: {
                    loader: "babel-loader",
                    options: {
                        presets: ['@babel/preset-react', '@babel/preset-typescript']
                    }
                }
            },
            {
                test: /\\.s[ac]ss$/i,
                use: ["style-loader", "css-loader", "sass-loader", "postcss-loader"],
            },
        ]
    },
    plugins: [
        new CopyPlugin({
            patterns: [{ from: "public", to: "public" }],
        }),
        new webpack.ProvidePlugin({
            process: 'process/browser',
        }),
    ],
    devtool: 'nosources-source-map',
    infrastructureLogging: {
        level: "log",
    },
};
module.exports = [config];`
    },
    {
        path: '.gitignore',
        content: `node_modules
dist
out
*.vsix
.vscode-test/
.vscode/`
    },
    {
        path: '.vscodeignore',
        content: `node_modules
src
.gitignore
webpack.config.js
tsconfig.json
**/*.map
**/*.ts`
    },
    {
        path: '.vscode/launch.json',
        content: `{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Run Extension",
            "type": "extensionHost",
            "request": "launch",
            "args": ["--extensionDevelopmentPath=\${workspaceFolder}"],
            "outFiles": ["\${workspaceFolder}/dist/**/*.js"],
            "preLaunchTask": "npm: watch"
        }
    ]
}`
    },
    {
        path: '.vscode/tasks.json',
        content: `{
    "version": "2.0.0",
    "tasks": [
        {
            "type": "npm",
            "script": "watch",
            "isBackground": true,
            "presentation": {
                "reveal": "never"
            },
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "problemMatcher": {
                "base": "$ts-webpack-watch",
                "background": {
                    "activeOnStart": true,
                    "beginsPattern": "Compilation starting...",
                    "endsPattern": "compiled successfully"
                }
            }
        }
    ]
}`
    },
    {
        path: 'public/spiral.svg',
        content: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200">
    <g id="Page-1" stroke="none" fill="none" fill-rule="evenodd">
        <g id="dep" transform="translate(4, 6)">
            <path d="M100 100 m 0 -80 a 80 80 0 0 1 0 160 a 70 70 0 0 1 0 -140 a 60 60 0 0 1 0 120 a 50 50 0 0 1 0 -100 a 40 40 0 0 1 0 80 a 30 30 0 0 1 0 -60 a 20 20 0 0 1 0 40"
                fill="none" stroke="white" stroke-width="8" id="Shape" />
        </g>
    </g>
</svg>`
    },
    {
        path: 'src/extension.ts',
        content: `import * as vscode from "vscode";
import { registerViews } from "./client/views";
import { registerCommands } from "./backend/commands/register-commands";
import { Services } from "./backend/services/services";

let globalContext: vscode.ExtensionContext | null = null;

export function activate(context: vscode.ExtensionContext) {
    console.log('Congratulations, your extension "Data Curation Environment" is now active!');
    globalContext = context;

    Services.initialize();
    registerCommands(context);
    registerViews(context);
}

export function getContext() {
    if (!globalContext) {
        throw new Error("Extension context not available.");
    }
    return globalContext;
}

export function deactivate() {}`
    },
    {
        path: 'src/common/types/file-node.ts',
        content: `export interface FileNode {
    name: string;
    absolutePath: string;
    children?: FileNode[];
}`
    },
    {
        path: 'src/common/types/vscode-webview.d.ts',
        content: `export interface WebviewApi<StateType> {
    postMessage(message: unknown): void;
    getState(): StateType | undefined;
    setState<T extends StateType | undefined>(newState: T): T;
}

declare global {
    function acquireVsCodeApi<StateType = unknown>(): WebviewApi<StateType>;
}`
    },
    {
        path: 'src/common/ipc/channels.enum.ts',
        content: `export enum ClientToServerChannel {
    RequestFlattenContext = "clientToServer.requestFlattenContext",
    RequestWorkspaceFiles = "clientToServer.requestWorkspaceFiles",
}

export enum ServerToClientChannel {
    SendWorkspaceFiles = "serverToClient.sendWorkspaceFiles",
}`
    },
    {
        path: 'src/common/ipc/channels.type.ts',
        content: `import { FileNode } from "@/common/types/file-node";
import { ClientToServerChannel, ServerToClientChannel } from "./channels.enum";

export type ChannelBody<T extends ClientToServerChannel | ServerToClientChannel> =
    T extends ClientToServerChannel.RequestFlattenContext ? { selectedPaths: string[] } :
    T extends ClientToServerChannel.RequestWorkspaceFiles ? {} :
    T extends ServerToClientChannel.SendWorkspaceFiles ? { files: FileNode[] } :
    never;`
    },
    {
        path: 'src/common/ipc/get-vscode-api.ts',
        content: `import { WebviewApi } from "../types/vscode-webview";

let vscode: WebviewApi<unknown> | null = null;

const getVscode = () => {
    if (!vscode) {
        vscode = acquireVsCodeApi();
    }
    return vscode;
};

export default getVscode;`
    },
    {
        path: 'src/common/ipc/client-ipc.ts',
        content: `import getVscode from "./get-vscode-api";
import { ClientToServerChannel, ServerToClientChannel } from "./channels.enum";
import { ChannelBody } from "./channels.type";

export class ClientPostMessageManager {
    private static _instance?: ClientPostMessageManager;
    private _listeners: {
        channel: ServerToClientChannel,
        callback: (body: ChannelBody<ServerToClientChannel>) => void
    }[];

    private constructor() {
        this._listeners = [];
        window.addEventListener('message', (event: MessageEvent) => {
            const data = event.data;
            this._listeners.forEach((listener) => {
                if (listener.channel === data.channel) {
                    listener.callback(data.body);
                }
            });
        });
    }

    static getInstance(): ClientPostMessageManager {
        if (!ClientPostMessageManager._instance) {
            ClientPostMessageManager._instance = new ClientPostMessageManager();
        }
        return ClientPostMessageManager._instance;
    }

    sendToServer<T extends ClientToServerChannel>(channel: T, body: ChannelBody<T>): void {
        getVscode().postMessage({ channel, body });
    }

    onServerMessage<T extends ServerToClientChannel>(channel: T, callback: (body: ChannelBody<T>) => void): void {
        this._listeners.push({ channel, callback: callback as any });
    }
}`
    },
    {
        path: 'src/common/ipc/server-ipc.ts',
        content: `import { ClientToServerChannel, ServerToClientChannel } from "./channels.enum";
import { ChannelBody } from "./channels.type";

export class ServerPostMessageManager {
    private static _instance?: ServerPostMessageManager;
    private _listeners: {
        channel: ClientToServerChannel,
        callback: (body: ChannelBody<ClientToServerChannel>) => void
    }[];

    private constructor(
        private onMessage: (data: any) => void,
        private sendMessage: (message: any) => void
    ) {
        this._listeners = [];
        this.onMessage((data: any) => {
            this._listeners.forEach((listener) => {
                if (listener.channel === data.channel) {
                    listener.callback(data.body);
                }
            });
        });
    }

    static getInstance(onMessage?: (data: any) => void, sendMessage?: (message: any) => void) {
        if (onMessage && sendMessage) {
            ServerPostMessageManager._instance = new ServerPostMessageManager(onMessage, sendMessage);
        }
        if (!ServerPostMessageManager._instance) {
            throw new Error("ServerPostMessageManager not initialized");
        }
        return ServerPostMessageManager._instance;
    }

    sendToClient<T extends ServerToClientChannel>(channel: T, body: ChannelBody<T>): void {
        this.sendMessage({ channel, body });
    }

    onClientMessage<T extends ClientToServerChannel>(channel: T, callback: (body: ChannelBody<T>) => void): void {
        this._listeners.push({ channel, callback: callback as any });
    }
}`
    },
    {
        path: 'src/common/utils/view-html.ts',
        content: `import * as vscode from "vscode";

export function getViewHtml({ webview, nonce, scriptUri }: { webview: vscode.Webview; nonce: string; scriptUri: string; }): string {
    return \`<!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src \${webview.cspSource} 'unsafe-inline'; script-src 'nonce-\${nonce}';">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
        </head>
        <body>
            <div id="root"></div>
            <script nonce="\${nonce}" src="\${scriptUri}"></script>
        </body>
        </html>\`;
}

function getNonce() {
    let text = "";
    const possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    for (let i = 0; i < 32; i++) {
        text += possible.charAt(Math.floor(Math.random() * possible.length));
    }
    return text;
}
export { getNonce };`
    },
    {
        path: 'src/client/views/index.ts',
        content: `import { viewConfig as contextChooserViewConfig } from "./context-chooser.view";
import * as vscode from "vscode";
import { ServerPostMessageManager } from "@/common/ipc/server-ipc";
import { getNonce, getViewHtml } from "@/common/utils/view-html";

export const views = [contextChooserViewConfig];
export const serverIPCs: Record<string, ServerPostMessageManager> = {};

export function registerViews(context: vscode.ExtensionContext) {
    views.forEach((viewConfig) => {
        context.subscriptions.push(
            vscode.window.registerWebviewViewProvider(viewConfig.type, {
                resolveWebviewView: (webviewView) => {
                    webviewView.webview.options = {
                        enableScripts: true,
                        localResourceRoots: [context.extensionUri],
                    };
                    const nonce = getNonce();
                    webviewView.webview.html = getViewHtml({
                        webview: webviewView.webview,
                        nonce,
                        scriptUri: webviewView.webview.asWebviewUri(vscode.Uri.joinPath(context.extensionUri, "dist", viewConfig.entry)).toString(),
                    });
                    const serverIpc = ServerPostMessageManager.getInstance(
                        webviewView.webview.onDidReceiveMessage,
                        (data: any) => webviewView.webview.postMessage(data)
                    );
                    serverIPCs[viewConfig.type] = serverIpc;
                    viewConfig.handleMessage(serverIpc);
                },
            })
        );
    });
}`
    },
    {
        path: 'src/client/views/context-chooser.view/index.ts',
        content: `import { onMessage } from "./on-message";

export const viewConfig = {
    entry: "contextChooserView.js",
    type: "viewType.sidebar.contextChooser",
    handleMessage: onMessage,
};`
    },
    {
        path: 'src/client/views/context-chooser.view/on-message.ts',
        content: `import { ServerPostMessageManager } from "@/common/ipc/server-ipc";
import { ClientToServerChannel } from "@/common/ipc/channels.enum";
import { Services } from "@/backend/services/services";

export function onMessage(serverIpc: ServerPostMessageManager) {
    const fsService = Services.fsService;
    const flattenerService = Services.flattenerService;

    serverIpc.onClientMessage(ClientToServerChannel.RequestWorkspaceFiles, () =>
        fsService.handleWorkspaceFilesRequest(serverIpc)
    );

    serverIpc.onClientMessage(ClientToServerChannel.RequestFlattenContext, (data) => {
        console.log("Flattening context for paths:", data.selectedPaths);
        flattenerService.flatten(data.selectedPaths);
    });
}`
    },
    {
        path: 'src/client/views/context-chooser.view/view.tsx',
        content: `import * as React from 'react';
import * as ReactDOM from 'react-dom/client';
import './view.scss';
import { ClientPostMessageManager } from '@/common/ipc/client-ipc';
import { ClientToServerChannel, ServerToClientChannel } from '@/common/ipc/channels.enum';
import { FileNode } from '@/common/types/file-node';
import FileTree from '../../components/file-tree/FileTree';
import { useState, useEffect } from 'react';

const App = () => {
    const [files, setFiles] = useState<FileNode[]>([]);
    const [selectedFiles, setSelectedFiles] = useState<string[]>([]);
    const [activeFile, setActiveFile] = useState<string | undefined>();
    
    const clientIpc = ClientPostMessageManager.getInstance();

    useEffect(() => {
        clientIpc.sendToServer(ClientToServerChannel.RequestWorkspaceFiles, {});

        const handleFileResponse = ({ files: receivedFiles }: { files: FileNode[] }) => {
            setFiles(receivedFiles);
        };
        clientIpc.onServerMessage(ServerToClientChannel.SendWorkspaceFiles, handleFileResponse);

    }, [clientIpc]);

    const handleFileClick = (filePath: string) => {
        setActiveFile(filePath);
    };

    const updateSelectedFiles = (newSelectedFiles: string[]) => {
        setSelectedFiles(newSelectedFiles);
    };

    const handleFlattenClick = () => {
        clientIpc.sendToServer(ClientToServerChannel.RequestFlattenContext, { selectedPaths: selectedFiles });
    };

    return (
        <div className="view-container">
            <div className="view-header">
                <button className="flatten-button" onClick={handleFlattenClick}>
                    Flatten Context
                </button>
            </div>
            <div className="file-tree-container">
                {files.length > 0 ? (
                    files.map((rootNode, index) => (
                        <FileTree
                            key={index}
                            data={[rootNode]}
                            onFileClick={handleFileClick}
                            selectedFiles={selectedFiles}
                            updateSelectedFiles={updateSelectedFiles}
                            activeFile={activeFile}
                        />
                    ))
                ) : (
                    <div className="loading-message">Loading file tree...</div>
                )}
            </div>
        </div>
    );
};

const root = ReactDOM.createRoot(document.getElementById('root')!);
root.render(<App />);`
    },
    {
        path: 'src/client/views/context-chooser.view/view.scss',
        content: `body {
    padding: 0;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
    font-size: 13px;
    color: var(--vscode-editor-foreground);
    background-color: var(--vscode-sideBar-background);
}

.view-container {
    display: flex;
    flex-direction: column;
    height: 100vh;
}

.view-header {
    padding: 8px;
    border-bottom: 1px solid var(--vscode-panel-border);
}

.flatten-button {
    width: 100%;
    padding: 6px;
    border: 1px solid var(--vscode-button-border, var(--vscode-focusBorder));
    background-color: var(--vscode-button-background);
    color: var(--vscode-button-foreground);
    cursor: pointer;
    border-radius: 2px;
}

.flatten-button:hover {
    background-color: var(--vscode-button-hoverBackground);
}

.file-tree-container {
    padding: 5px;
    flex-grow: 1;
    overflow-y: auto;
}

.loading-message {
    padding: 8px;
    color: var(--vscode-descriptionForeground);
}

.tree-view ul {
    padding-left: 0;
    list-style-type: none;
    margin: 0;
}

.treenode-li {
    padding-left: 20px;
    position: relative;
}

.treenode-item-wrapper {
    display: flex;
    align-items: center;
    cursor: pointer;
    padding: 1px 4px;
    border-radius: 3px;
}

.treenode-item-wrapper:hover {
    background-color: var(--vscode-list-hoverBackground);
}

.treenode-chevron {
    position: absolute;
    left: 0;
    top: 50%;
    transform: translateY(-50%) rotate(0deg);
    transition: transform 0.1s ease-in-out;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 20px;
    height: 20px;
}

.treenode-chevron.expanded {
    transform: translateY(-50%) rotate(90deg);
}

.file-item {
    display: flex;
    align-items: center;
    width: 100%;
    padding: 1px;
}

.file-item.active {
    background-color: var(--vscode-list-activeSelectionBackground);
    color: var(--vscode-list-activeSelectionForeground);
}

.file-checkbox {
    margin-right: 6px;
    cursor: pointer;
}

.file-name {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}`
    },
    {
        path: 'src/backend/commands/commands.ts',
        content: `// No commands are needed for now, but we'll keep the file for future use.
export const commands = [];`
    },
    {
        path: 'src/backend/commands/register-commands.ts',
        content: `import * as vscode from "vscode";
import { commands } from "./commands";

export function registerCommands(context: vscode.ExtensionContext) {
    commands.forEach(({ commandId, callback }) => {
        let disposable = vscode.commands.registerCommand(commandId, callback);
        context.subscriptions.push(disposable);
    });
}`
    },
    {
        path: 'src/backend/services/services.ts',
        content: `import "reflect-metadata";
import { FSService } from "./fs.service";
import { FlattenerService } from "./flattener.service";

// A simple container for services
class ServiceContainer {
    public fsService = new FSService();
    public flattenerService = new FlattenerService();
    
    public initialize() {
        // This can be used for service initialization logic in the future
    }
}

export const Services = new ServiceContainer();`
    },
    {
        path: 'src/backend/services/fs.service.ts',
        content: `import * as vscode from "vscode";
import * as path from "path";
import { ServerPostMessageManager } from "@/common/ipc/server-ipc";
import { ServerToClientChannel } from "@/common/ipc/channels.enum";
import { FileNode } from "@/common/types/file-node";

export class FSService {
    public async handleWorkspaceFilesRequest(serverIpc: ServerPostMessageManager) {
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (!workspaceFolders || workspaceFolders.length === 0) {
            serverIpc.sendToClient(ServerToClientChannel.SendWorkspaceFiles, { files: [] });
            return;
        }
        
        // For simplicity, we'll just use the first workspace folder.
        const rootUri = workspaceFolders[0].uri;
        if (!rootUri) {
            // This case is unlikely if the above check passes, but good for safety.
            serverIpc.sendToClient(ServerToClientChannel.SendWorkspaceFiles, { files: [] });
            return;
        }
        const rootPath = rootUri.fsPath;
        const files = await vscode.workspace.findFiles("**/*");
        const fileTree = this.createFileTree(rootPath, files);

        serverIpc.sendToClient(ServerToClientChannel.SendWorkspaceFiles, { files: [fileTree] });
    }

    private createFileTree(rootPath: string, files: vscode.Uri[]): FileNode {
        const rootNode: FileNode = {
            name: path.basename(rootPath),
            absolutePath: rootPath,
            children: []
        };

        for (const file of files) {
            const relativePath = path.relative(rootPath, file.fsPath);
            const parts = relativePath.split(path.sep);
            let currentNode = rootNode;

            for (let i = 0; i < parts.length; i++) {
                const part = parts[i];
                let childNode = currentNode.children?.find(c => c.name === part);

                if (!childNode) {
                    const newPath = path.join(currentNode.absolutePath, part);
                    childNode = { name: part, absolutePath: newPath };
                    if (i < parts.length - 1) {
                        childNode.children = [];
                    }
                    currentNode.children?.push(childNode);
                }
                currentNode = childNode;
            }
        }
        return rootNode;
    }
}`
    },
    {
        path: 'src/client/components/Checkbox.tsx',
        content: `import React from "react";
import { useEffect, useRef } from "react";

interface CheckboxProps extends Omit<React.DetailedHTMLProps<React.InputHTMLAttributes<HTMLInputElement>, HTMLInputElement>, 'onChange'> {
    checked: boolean;
    indeterminate?: boolean;
    onChange: (checked: boolean, event: React.ChangeEvent<HTMLInputElement>) => void;
}

const Checkbox = (props: CheckboxProps) => {
    const { checked, onChange, indeterminate, ...rest } = props;
    const cRef = useRef<any>(null);

    useEffect(() => {
        if (cRef.current) {
            cRef.current.indeterminate = indeterminate;
        }
    }, [cRef, indeterminate]);

    return (
        <input type="checkbox" ref={cRef} checked={checked} onChange={(e) => onChange(e.target.checked, e)} {...rest} />
    );
};

export default Checkbox;`
    },
        {
        path: 'src/client/components/file-tree/FileTree.tsx',
        content: `import React, { useEffect, useState } from 'react';
import TreeView from '../tree-view/TreeView';
import { FileNode } from '@/common/types/file-node';
import { addRemovePathInSelectedFiles, getFileNodeByPath } from './FileTree.utils';
import Checkbox from '../Checkbox';

interface FileTreeProps {
  data: FileNode[];
  onFileClick?: (filePath: string) => void;
  selectedFiles: string[];
  activeFile?: string;
  updateSelectedFiles: (selectedFiles: string[]) => void;
}

const FileTree: React.FC<FileTreeProps> = ({
  data,
  onFileClick,
  selectedFiles,
  activeFile,
  updateSelectedFiles,
}) => {

  const rootNode = data.length > 0 ? data[0] : null;

  const [expandedNodes, setExpandedNodes] = useState<string[]>(rootNode ? [rootNode.absolutePath] : []);

  useEffect(() => {
    const toExpand = new Set<string>();
    selectedFiles?.forEach((selectedFile) => {
        const node = getFileNodeByPath(data, selectedFile);
        if (node && node.children) {
            toExpand.add(node.absolutePath);
        }
    });

    setExpandedNodes(prevExpandedNodes => [...new Set([...prevExpandedNodes, ...Array.from(toExpand)])]);
  }, [selectedFiles, data]);

  const handleNodeClick = (e: React.MouseEvent<HTMLElement, MouseEvent> | undefined, node: FileNode) => {
    if (e && (e.target as HTMLElement)?.closest('.file-checkbox')) {
        return;
    }
    onFileClick && onFileClick(node.absolutePath);
  };

  const renderCheckbox = (path: string) => {
    const isSelected = selectedFiles.includes(path);
    const hasSelectedAncestor = selectedFiles.some(ancestor => path.startsWith(ancestor) && path !== ancestor);
    const hasSelectedDescendant = selectedFiles.some(descendant => descendant.startsWith(path) && descendant !== path);
    
    return (
      <Checkbox
        className="file-checkbox"
        indeterminate={!isSelected && !hasSelectedAncestor && hasSelectedDescendant}
        checked={isSelected || hasSelectedAncestor}
        onChange={(_, e) => handleFileCheckboxChange(e, path)}
      />
    );
  };

  const handleFileCheckboxChange = (e: React.ChangeEvent<HTMLInputElement>, path: string) => {
    e.stopPropagation();
    e.preventDefault();
    updateSelectedFiles(addRemovePathInSelectedFiles(data, path, selectedFiles));
  };

  const renderFileNodeContent = (node: FileNode) => {
    const isActive = activeFile === node.absolutePath;
    const isDirectory = Array.isArray(node.children);

    return (
      <div
        className={\`file-item \${isActive ? 'active' : ''} \${isDirectory ? 'directory' : 'file'}\`}
        onClick={(e) => handleNodeClick(e, node)}
      >
        {renderCheckbox(node.absolutePath)}
        <span className="file-name">{node.name}</span>
      </div>
    );
  };

  return (
    <div className="file-tree">
      <TreeView 
        data={data} 
        renderNodeContent={renderFileNodeContent} 
      />
    </div>
  );
};

export default FileTree;`
    },
    {
        path: 'src/client/components/file-tree/FileTree.utils.ts',
        content: `import { FileNode } from "@/common/types/file-node";

function getAllDescendantPaths(node: FileNode): string[] {
    let paths: string[] = [];
    if (node.children) {
        for (const child of node.children) {
            paths.push(child.absolutePath);
            paths = paths.concat(getAllDescendantPaths(child));
        }
    }
    return paths;
}

export const addRemovePathInSelectedFiles = (
  fileTree: FileNode[],
  path: string,
  selectedFiles: string[]
): string[] => {
    const node = getFileNodeByPath(fileTree, path);
    if (!node) return selectedFiles;

    const descendantPaths = getAllDescendantPaths(node);
    const isSelected = selectedFiles.includes(path);
    const hasSelectedAncestor = selectedFiles.some(ancestor => path.startsWith(ancestor) && path !== ancestor);
    
    let newSelectedFiles = [...selectedFiles];

    if (isSelected) {
        // Uncheck: remove this path and all its descendants
        newSelectedFiles = newSelectedFiles.filter(p => p !== path && !descendantPaths.includes(p));
    } else if (hasSelectedAncestor) {
        // Uncheck a child of an already checked folder.
        // 1. Remove the ancestor.
        // 2. Add all children of the ancestor EXCEPT the one that was unchecked.
        const ancestor = selectedFiles.find(ancestor => path.startsWith(ancestor) && path !== ancestor)!;
        const ancestorNode = getFileNodeByPath(fileTree, ancestor)!;
        
        newSelectedFiles = newSelectedFiles.filter(p => p !== ancestor);
        
        const siblingsAndCousins = getAllDescendantPaths(ancestorNode).filter(p => p !== path && !p.startsWith(path));
        newSelectedFiles.push(...siblingsAndCousins);

    } else {
        // Check: remove all descendants that might be individually selected, then add the parent path.
        newSelectedFiles = newSelectedFiles.filter(p => !p.startsWith(path));
        newSelectedFiles.push(path);
    }
  
  return [...new Set(newSelectedFiles)]; // Remove duplicates for cleanliness
};

export const getFileNodeByPath = (
  fileNodes: FileNode[],
  filePath: string
): FileNode | null => {
    for (const rootNode of fileNodes) {
        const found = findNode(rootNode, filePath);
        if (found) return found;
    }
    return null;
};

function findNode(node: FileNode, filePath: string): FileNode | null {
    if (node.absolutePath === filePath) {
        return node;
    }
    if (node.children && filePath.startsWith(node.absolutePath)) {
        for (const child of node.children) {
            const found = findNode(child, filePath);
            if(found) return found;
        }
    }
    return null;
}`
    },
    {
        path: 'src/client/components/tree-view/TreeView.tsx',
        content: `import React, { useState } from 'react';
import { MdChevronRight } from 'react-icons/md';
import { getExpandedNodes } from './TreeView.utils';

export interface TreeNode {
    name: string;
    absolutePath: string;
    children?: TreeNode[];
    isExpanded?: boolean;
    [key: string]: any;
}

interface TreeViewProps {
    data: TreeNode[];
    onNodeClick?: (node: TreeNode) => void;
    renderNodeContent?: (node: TreeNode) => React.ReactNode;
}

const TreeView: React.FC<TreeViewProps> = ({ data, onNodeClick, renderNodeContent }) => {
    const [expandedNodes, setExpandedNodes] = useState<string[]>(getExpandedNodes(data));

    const handleNodeClick = (node: TreeNode) => {
        if (node.children && node.children.length > 0) {
            setExpandedNodes((prevExpandedNodes) => {
                const isExpanded = prevExpandedNodes.includes(node.absolutePath);
                return isExpanded
                    ? prevExpandedNodes.filter((n) => n !== node.absolutePath)
                    : [...prevExpandedNodes, node.absolutePath];
            });
        }
        onNodeClick && onNodeClick(node);
    };

    const renderTreeNodes = (nodes: TreeNode[]) => {
        return nodes.map((node) => {
            const isExpanded = expandedNodes.includes(node.absolutePath);
            const isDirectory = !!(node.children && node.children.length > 0);

            return (
                <li key={node.absolutePath} className="treenode-li">
                    <div
                        onClick={() => handleNodeClick(node)}
                        className={\`treenode-item-wrapper\`}
                    >
                        {isDirectory && (
                            <span
                                className={\`treenode-chevron \${isExpanded ? 'expanded' : ''}\`}
                            >
                                <MdChevronRight />
                            </span>
                        )}
                        {renderNodeContent ? renderNodeContent(node) : node.name}
                    </div>
                    {isDirectory && isExpanded && (
                        <ul className="treenode-children">{renderTreeNodes(node.children)}</ul>
                    )}
                </li>
            );
        });
    };

    return (
        <div className="tree-view">
            <ul>{renderTreeNodes(data)}</ul>
        </div>
    );
};

export default TreeView;`
    },
    {
        path: 'src/client/components/tree-view/TreeView.utils.ts',
        content: `import { TreeNode } from "./TreeView";

export const getExpandedNodes = (data: TreeNode[]): string[] => {
  return data.reduce((acc: string[], node) => {
    if (node.isExpanded) {
      acc.push(node.absolutePath);
    }
    if (node.children) {
      acc.push(...getExpandedNodes(node.children));
    }
    return acc;
  }, []);
};`
    },
    {
        path: 'src/backend/services/flattener.service.ts',
        content: `import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs/promises';

interface FileStats {
    filePath: string;
    lines: number;
    characters: number;
    tokens: number;
    content: string;
    error: string | null;
}

export class FlattenerService {

    public async flatten(selectedPaths: string[]) {
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (!workspaceFolders || workspaceFolders.length === 0) {
            vscode.window.showErrorMessage("Cannot flatten context: No workspace folder is open.");
            return;
        }
        if (selectedPaths.length === 0) {
            vscode.window.showWarningMessage("Cannot flatten context: No files or folders are selected.");
            return;
        }

        const rootPath = workspaceFolders[0].uri.fsPath;
        const outputFilePath = path.join(rootPath, 'flattened_repo.md');

        try {
            const allFilePaths = await this.expandDirectories(selectedPaths);
            const uniqueFilePaths = [...new Set(allFilePaths)];

            const fileStatsPromises = uniqueFilePaths.map(filePath => this.getFileStatsAndContent(filePath));
            const results = await Promise.all(fileStatsPromises);

            const outputContent = this.generateOutputContent(results, rootPath, outputFilePath);

            await fs.writeFile(outputFilePath, outputContent, 'utf-8');
            vscode.window.showInformationMessage(\`Successfully flattened \${results.filter(r => !r.error).length} files to flattened_repo.md.\`);

        } catch (error: any) {
            vscode.window.showErrorMessage(\`Failed to flatten context: \${error.message}\`);
            console.error(error);
        }
    }

    private async expandDirectories(paths: string[]): Promise<string[]> {
        const allFiles: string[] = [];
        for (const p of paths) {
            try {
                const stats = await fs.stat(p);
                if (stats.isDirectory()) {
                    allFiles.push(...await this.getAllFilesRecursive(p));
                } else {
                    allFiles.push(p);
                }
            } catch (e) {
                console.warn(\`Could not stat path \${p}, skipping.\`);
            }
        }
        return allFiles;
    }

    private async getAllFilesRecursive(dirPath: string): Promise<string[]> {
        let files: string[] = [];
        try {
            const entries = await fs.readdir(dirPath, { withFileTypes: true });
            for (const entry of entries) {
                const fullPath = path.join(dirPath, entry.name);
                if (entry.isDirectory()) {
                    files = files.concat(await this.getAllFilesRecursive(fullPath));
                } else {
                    files.push(fullPath);
                }
            }
        } catch (e) {
            console.error(\`Error reading directory \${dirPath}:\`, e);
        }
        return files;
    }

    private async getFileStatsAndContent(filePath: string): Promise<FileStats> {
        try {
            const content = await fs.readFile(filePath, 'utf-8');
            const lines = content.split('\\n').length;
            const characters = content.length;
            const tokens = Math.ceil(characters / 4);
            return { filePath, lines, characters, tokens, content, error: null };
        } catch (error: any) {
            return { filePath, lines: 0, characters: 0, tokens: 0, content: '', error: error.message };
        }
    }

    private generateOutputContent(results: FileStats[], rootDir: string, outputFilename: string): string {
        let totalLines = 0;
        let totalCharacters = 0;
        let totalTokens = 0;
        let errorCount = 0;
        const validResults = results.filter(r => !r.error);

        for (const res of validResults) {
            totalLines += res.lines;
            totalCharacters += res.characters;
            totalTokens += res.tokens;
        }

        let output = \`<!--\\n\`;
        output += \`  File: \${path.basename(outputFilename)}\\n\`;
        output += \`  Source Directory: \${rootDir}\\n\`;
        output += \`  Date Generated: \${new Date().toISOString()}\\n\`;
        output += \`  ---\\n\`;
        output += \`  Total Files: \${validResults.length}\\n\`;
        if (errorCount > 0) {
            output += \`  Files with Errors: \${errorCount}\\n\`;
        }
        output += \`  Total Lines: \${totalLines}\\n\`;
        output += \`  Total Characters: \${totalCharacters}\\n\`;
        output += \`  Approx. Tokens: \${totalTokens}\\n\`;
        output += \`-->\\n\\n\`;

        const top10 = [...validResults].sort((a, b) => b.tokens - a.tokens).slice(0, 10);

        output += \`<!-- Top 10 Files by Token Count -->\\n\`;
        top10.forEach((r, i) => {
            output += \`\${i + 1}. \${path.relative(rootDir, r.filePath)} (\${r.tokens} tokens)\\n\`;
        });
        output += \`\\n\`;

        output += \`<!-- Full File List -->\\n\`;
        results.forEach((r, i) => {
            const relativePath = path.relative(rootDir, r.filePath);
            if (r.error) {
                output += \`\${i + 1}. \${relativePath} - ERROR: \${r.error}\\n\`;
            } else {
                output += \`\${i + 1}. \${relativePath} - Lines: \${r.lines} - Chars: \${r.characters} - Tokens: \${r.tokens}\\n\`;
            }
        });
        output += \`\\n\`;

        for (const { filePath, content, error } of results) {
            const relativePath = path.relative(rootDir, filePath).replace(/\\\\/g, '/');
            output += \`<file path="\${relativePath}">\\n\`;
            if (error) {
                output += \`Error reading file: \${error}\\n\`;
            } else {
                output += content;
            }
            if (!content.endsWith('\\n')) {
                output += '\\n';
            }
            output += \`</file>\\n\\n\`;
        }
        return output;
    }
}`
    }
];

// --- Main Execution ---

async function deployScaffold() {
    console.log('Starting scaffold deployment...');
    const rootDir = process.cwd();

    for (const file of filesToCreate) {
        const fullPath = path.join(rootDir, file.path);
        const dir = path.dirname(fullPath);

        try {
            await fs.mkdir(dir, { recursive: true });
            await fs.writeFile(fullPath, file.content, 'utf-8');
            console.log(`âœ… Created: ${file.path}`);
        } catch (error) {
            console.error(`âŒ Failed to create ${file.path}: ${error.message}`);
        }
    }

    console.log('\nðŸš€ Scaffold deployment complete! ðŸš€');
    console.log('Next steps:');
    console.log('1. Run npm install to install dependencies.');
    console.log('2. Press F5 in VS Code to start the extension (this will also run npm run watch).');
}

deployScaffold();
```
</file>

<file path="src/Artifacts/A7. DCE - Development and Testing Guide.md">
# Artifact A7: DCE - Development and Testing Guide
# Date Created: Cycle 7
# Author: AI Model
# Updated on: Cycle 9 (Revised workflow to use integrated debugger configuration)

- **Description:** A step-by-step guide explaining how to run, debug, and test the DCE extension within VS Code using the Extension Development Host.
- **Tags:** development, testing, debugging, workflow, vs code extension, f5, launch.json

## 1. Purpose

This guide provides the correct and simplified procedure for running and testing the Data Curation Environment (DCE) extension locally. Following these steps is crucial to see your changes and the extension's UI in action.

## 2. The Core Concept: The Extension Development Host

You cannot see the extension's UI (like the spiral icon or the custom panel) in the same VS Code window where you are writing the code. Instead, you must launch a special, separate VS Code window called the **Extension Development Host**. This new window has your extension installed and running, allowing you to test it as a user would.

Our project now includes the necessary `.vscode/launch.json` and `.vscode/tasks.json` files to make this process seamless.

## 3. Step-by-Step Workflow

Follow these steps every time you want to test the extension:

### Step 1: Open the "Run and Debug" View

In your main project window (e.g., `C:\Projects\DCE`), navigate to the "Run and Debug" panel in the activity bar on the left. The icon looks like a play button with a bug on it.

### Step 2: Launch the Extension

At the top of the "Run and Debug" panel, you will see a dropdown menu. It should already have **"Run Extension"** selected.

Simply press the **F5** key or click the green play button next to the "Run Extension" dropdown.

This single action will now:
1.  Automatically start the `npm run watch` task in the background to compile your code.
2.  Launch the new **"[Extension Development Host]"** VS Code window.

### Step 3: Find the Extension UI

In the newly opened **Extension Development Host** window, look at the activity bar on the far left. You should now see our spiral icon. Clicking this icon will open the "Context Chooser" panel, where you'll see the file tree with checkboxes.

### Step 4: Making and Viewing Changes

1.  **Make Code Changes:** Edit the source code in your **original** project window.
2.  **Auto-Compile:** When you save a file, the `npm run watch` task (which was started automatically) will recompile it. You can see its progress in the terminal panel of your original window.
3.  **Reload the Host:** To see your changes, go to the **Extension Development Host** window (the one you launched with F5) and reload it. The easiest way is to open the Command Palette (`Ctrl+Shift+P` or `Cmd+Shift+P`) and run the command **`Developer: Reload Window`**.

You only need to stop the debugger (Shift+F5) and restart it (F5) if you make changes to configuration files like `package.json`. For all other code changes, simply reloading the host window is sufficient and much faster.
</file>

<file path="src/Artifacts/A8. DCE - Phase 1 - Selection Sets Feature Plan.md">
# Artifact A8: DCE - Phase 1 - Selection Sets Feature Plan
# Date Created: Cycle 11
# Author: AI Model
# Updated on: C23 (Add requirement for selection persistence)

- **Key/Value for A0:**
- **Description:** A plan outlining the user stories, UI/UX, and technical implementation for saving, loading, and persisting different sets of selected files (selection profiles).
- **Tags:** feature plan, selection sets, profiles, context management, persistence, phase 1

## 1. Overview & Goal

The goal of the "Selection Sets" feature is to address the user feedback regarding the need to save and switch between different file selections, and to ensure the current selection is not lost during a session. Users often work on multiple tasks or projects concurrently, each requiring a different context. Manually re-selecting files is tedious and losing the current selection when switching tabs is a critical usability flaw. This feature will allow users to save a named "set" of their current selections, quickly load it back later, and have their current selection state persist automatically.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| US-01 | **Selection Persistence** | As a user, I expect my current selection of checked files to remain active when I switch to another VS Code tab and then return, so my work is not lost. | - The current array of selected file paths is automatically saved to the webview's persistent state whenever it changes. <br> - When the webview is re-activated (e.g., tab is clicked), it restores the last saved selection state. |
| US-02 | **Save Current Selection** | As a developer, I want to save my currently checked files as a named set, so I don't have to re-select them manually when I switch tasks. | - A UI element (e.g., button or menu item) exists to "Save current selection". <br> - Clicking it prompts me to enter a name for the selection set. <br> - After providing a name, the current list of selected file paths is saved. <br> - I receive a confirmation that the set was saved. |
| US-03 | **Load a Saved Selection** | As a developer, I want to load a previously saved selection set, so I can quickly restore a specific context. | - A UI element (e.g., a dropdown menu) lists all saved selection sets by name. <br> - Selecting a set from the list immediately updates the file tree, checking all the files and folders from that set. <br> - Any previously checked files that are not part of the loaded set become unchecked. |
| US-04 | **Delete a Saved Selection** | As a developer, I want to delete a selection set that I no longer need, so I can keep my list of saved sets clean. | - A UI element exists to manage or delete saved sets. <br> - I can select a set to delete from a list. <br> - I am asked to confirm the deletion. <br> - Upon confirmation, the set is removed from the list of saved sets. |

## 3. Proposed UI/UX

The functionality will be consolidated into the `view-header` of our Context Chooser panel for easy access.

1.  **Header Controls:**
    *   A dropdown menu and/or a set of dedicated toolbar buttons for managing selection sets.
    *   Example: A "Save" icon button and a "Load" icon button.
    *   Clicking "Save" would trigger the save workflow.
    *   Clicking "Load" would open a Quick Pick menu of saved sets.

2.  **Saving a Set:**
    *   Clicking the "Save" button will execute the `dce.saveSelectionSet` command.
    *   This command will trigger a VS Code input box (`vscode.window.showInputBox`).
    *   The user will enter a name (e.g., "API Feature", "Frontend Refactor").
    *   On submission, the backend saves the current `selectedFiles` array under that name.

3.  **Loading a Set:**
    *   Clicking the "Load" button will execute the `dce.loadSelectionSet` command.
    *   This command shows a Quick Pick list (`vscode.window.showQuickPick`) of all saved sets.
    *   Selecting a set triggers an IPC message (`ApplySelectionSet`) to the frontend with the array of file paths for that set.
    *   The frontend updates its `selectedFiles` state, causing the tree to re-render with the new selections.

## 4. Technical Implementation Plan

1.  **State Persistence (`view.tsx`):**
    *   Define a state type in `vscode-webview.d.ts`: `interface ViewState { selectedFiles: string[] }`.
    *   In the main `App` component in `view.tsx`, use a `useEffect` hook that triggers whenever the `selectedFiles` state changes. Inside this effect, call `vscode.setState({ selectedFiles })`.
    *   On initial component mount, retrieve the persisted state using `const savedState = vscode.getState();` and if it exists, use it to initialize the `selectedFiles` state: `useState<string[]>(savedState?.selectedFiles || [])`.

2.  **Data Storage (`selection.service.ts`):**
    *   Selection sets will continue to be stored in the VS Code `workspaceState`. This is a key-value store specific to the current workspace.
    *   A single key, e.g., `dce.selectionSets`, will hold an object where keys are the set names and values are the `string[]` of absolute file paths.

3.  **IPC Channels & Commands (`commands.ts`):**
    *   The existing commands (`dce.saveSelectionSet`, `dce.loadSelectionSet`, `dce.deleteSelectionSet`) are suitable.
    *   The backend `loadSelectionSet` command will trigger the `ApplySelectionSet` IPC message to the client with the file paths.

4.  **Frontend Logic (`view.tsx`):**
    *   Add state to store the map of selection sets: `const [selectionSets, setSelectionSets] = useState({});`
    *   On mount, request the list of sets from the backend to populate any UI elements.
    *   Implement an effect to listen for `ApplySelectionSet` and call `setSelectedFiles()` with the new paths.
    *   Render the new "Save" and "Load" buttons in the header toolbar.
    *   The `onClick` handler for the "Save" button will trigger an IPC message that executes the `dce.saveSelectionSet` command, passing the current `selectedFiles` state.
</file>

<file path="src/Artifacts/A9. DCE - GitHub Repository Setup Guide.md">
# Artifact A9: DCE - GitHub Repository Setup Guide
# Date Created: Cycle 12
# Author: AI Model

- **Description:** A step-by-step guide with the necessary git commands to initialize the project as a local repository and push it to a new remote repository on GitHub.
- **Tags:** git, github, version control, setup, repository

## 1. Overview

This guide provides the necessary commands to turn your local project folder into a Git repository and link it to a new, empty repository on GitHub.

## 2. Prerequisites

*   You have `git` installed on your machine.
*   You have a GitHub account.
*   Your GitHub username is `dgerabagi`.

## 3. Step-by-Step Instructions

### Step 1: Create a New Repository on GitHub

1.  Go to [github.com](https://github.com) and log in.
2.  In the top-right corner, click the `+` icon and select **"New repository"**.
3.  **Repository name:** A good name would be `data-curation-environment` or `vscode-dce-extension`.
4.  **Description:** (Optional) "A VS Code extension for curating context for Large Language Models."
5.  Choose **"Private"** or **"Public"** based on your preference.
6.  **IMPORTANT:** Do **not** initialize the repository with a `README`, `.gitignore`, or `license`. We will be pushing our existing files, and this will prevent conflicts.
7.  Click **"Create repository"**.

GitHub will now show you a page with several command-line instructions. We will use the section titled **"...or push an existing repository from the command line"**.

### Step 2: Initialize Git in Your Local Project

Open a terminal (like the one integrated into VS Code) and navigate to your project's root directory (e.g., `C:\Projects\DCE`). Then, run the following commands one by one.

1.  **Initialize the repository:** This creates a new `.git` subdirectory in your project folder.
    ```bash
    git init
    ```

2.  **Add all existing files to the staging area:** The `.` adds all files in the current directory and subdirectories.
    ```bash
    git add .
    ```

3.  **Create the first commit:** This saves the staged files to the repository's history.
    ```bash
    git commit -m "Initial commit"
    ```

4.  **Rename the default branch to `main`:** This is the modern standard, replacing the older `master`.
    ```bash
    git branch -M main
    ```

### Step 3: Link and Push to GitHub

Now, you will link your local repository to the empty one you created on GitHub.

1.  **Add the remote repository:** Replace the URL with the one from your GitHub repository page. It should look like the example below.
    ```bash
    git remote add origin https://github.com/dgerabagi/data-curation-environment.git
    ```

2.  **Push your local `main` branch to GitHub:** The `-u` flag sets the upstream remote so that in the future, you can simply run `git push`.
    ```bash
    git push -u origin main
    ```

After these commands complete, refresh your GitHub repository page. You should see all of your project files. You have successfully created and linked your repository!
```
</file>

<file path="src/backend/commands/commands.ts">
// Updated on: C115 (Fix fsService reference)
import * as vscode from 'vscode';
import { Services } from '../services/services';
import { serverIPCs } from '@/client/views';
import { ServerToClientChannel } from '@/common/ipc/channels.enum';
import { VIEW_TYPES } from '@/common/view-types';

export const commands = [
    {
        commandId: 'dce.saveCurrentSelection',
        callback: async (selectedPaths: string[]) => {
            if (!selectedPaths || selectedPaths.length === 0) {
                vscode.window.showWarningMessage("No files are selected to save.");
                return;
            }
            const name = await vscode.window.showInputBox({
                prompt: 'Enter a name for the selection set',
                placeHolder: 'e.g., "API Feature" or "Frontend Refactor"'
            });
            if (name) {
                await Services.selectionService.saveSelectionSet(name, selectedPaths);
                const serverIpc = serverIPCs[VIEW_TYPES.SIDEBAR.CONTEXT_CHOOSER];
                if(serverIpc) {
                    serverIpc.sendToClient(ServerToClientChannel.SendSelectionSets, { sets: Services.selectionService.getSelectionSets() });
                }
            }
        }
    },
    {
        commandId: 'dce.loadSelectionSet',
        callback: async () => {
            const sets = Services.selectionService.getSelectionSets();
            const setNames = Object.keys(sets);
             if (setNames.length === 0) {
                vscode.window.showInformationMessage("No saved selection sets.");
                return;
            }
            const name = await vscode.window.showQuickPick(setNames, {
                placeHolder: 'Select a selection set to load'
            });

            if (name) {
                const paths = sets[name];
                if (paths) {
                    const serverIpc = serverIPCs[VIEW_TYPES.SIDEBAR.CONTEXT_CHOOSER];
                    if(serverIpc) {
                        serverIpc.sendToClient(ServerToClientChannel.ApplySelectionSet, { paths });
                        Services.loggerService.log(`Command: Loaded selection set '${name}'.`);
                        vscode.window.showInformationMessage(`Loaded selection set '${name}'.`);
                    }
                }
            }
        }
    },
    {
        commandId: 'dce.manageSelectionSets',
        callback: async () => {
            const sets = Services.selectionService.getSelectionSets();
            const setNames = Object.keys(sets);
            if (setNames.length === 0) {
                vscode.window.showInformationMessage("No selection sets to manage.");
                return;
            }
            const setToDelete = await vscode.window.showQuickPick(setNames, {
                placeHolder: 'Select a selection set to delete'
            });

            if (setToDelete) {
                await Services.selectionService.deleteSelectionSet(setToDelete);
                 const serverIpc = serverIPCs[VIEW_TYPES.SIDEBAR.CONTEXT_CHOOSER];
                 if(serverIpc) {
                     serverIpc.sendToClient(ServerToClientChannel.SendSelectionSets, { sets: Services.selectionService.getSelectionSets() });
                 }
            }
        }
    },
    {
        commandId: 'dce.refreshTree',
        callback: () => {
            const serverIpc = serverIPCs[VIEW_TYPES.SIDEBAR.CONTEXT_CHOOSER];
            if (serverIpc) {
                Services.loggerService.log("Executing dce.refreshTree command.");
                // C115 Fix: Use fileTreeService instead of fsService
                Services.fileTreeService.handleWorkspaceFilesRequest(serverIpc, true);
            } else {
                Services.loggerService.warn("Could not refresh tree: serverIpc not found.");
            }
        }
    },
    {
        commandId: 'dce.openParallelCopilot',
        callback: () => {
            Services.loggerService.log("Executing dce.openParallelCopilot command to open WebviewPanel.");
            vscode.commands.executeCommand('dce.showParallelCopilot');
        }
    }
];
</file>

<file path="src/backend/commands/register-commands.ts">
import * as vscode from "vscode";
import { commands } from "./commands";
import { Services } from "../services/services";

export function registerCommands(context: vscode.ExtensionContext) {
    Services.loggerService.log(`Registering ${commands.length} commands.`);
    commands.forEach(({ commandId, callback }) => {
        let disposable = vscode.commands.registerCommand(commandId, callback);
        context.subscriptions.push(disposable);
    });
}
</file>

<file path="src/backend/services/action.service.ts">
// Updated on: C114 (Refactor to use new services)
import * as vscode from 'vscode';
import { Services } from './services';

export type ActionType = 'move' | 'delete';

export interface Action {
    type: ActionType;
    payload: any;
}

export interface MoveActionPayload {
    fromPath: string;
    toPath: string;
}

export class ActionService {
    private undoStack: Action[] = [];
    private redoStack: Action[] = [];

    public push(action: Action) {
        this.undoStack.push(action);
        this.redoStack = [];
    }

    public async undo() {
        const action = this.undoStack.pop();
        if (!action) return;
        await this.performReverseAction(action);
        this.redoStack.push(action);
    }

    public async redo() {
        const action = this.redoStack.pop();
        if (!action) return;
        await this.performOriginalAction(action);
        this.undoStack.push(action);
    }

    private async performReverseAction(action: Action) {
        switch (action.type) {
            case 'move':
                const { fromPath, toPath } = action.payload as MoveActionPayload;
                await vscode.workspace.fs.rename(vscode.Uri.file(toPath), vscode.Uri.file(fromPath));
                break;
        }
    }

    private async performOriginalAction(action: Action) {
        switch (action.type) {
            case 'move':
                const { fromPath, toPath } = action.payload as MoveActionPayload;
                 await vscode.workspace.fs.rename(vscode.Uri.file(fromPath), vscode.Uri.file(toPath));
                break;
            case 'delete':
                await vscode.workspace.fs.delete(vscode.Uri.file(action.payload.path), { recursive: true, useTrash: true });
                break;
        }
    }
}
</file>

<file path="src/backend/services/content-extraction.service.ts">
// src/backend/services/content-extraction.service.ts
import * as vscode from "vscode";
import * as path from "path";
import * as fs from "fs/promises";
import { ServerPostMessageManager } from "@/common/ipc/server-ipc";
import { ServerToClientChannel } from "@/common/ipc/channels.enum";
import { Services } from "./services";
// @ts-ignore
import pdf from 'pdf-parse/lib/pdf-parse.js';
import * as XLSX from 'xlsx';
import mammoth from 'mammoth';

export class ContentExtractionService {
    private pdfTextCache = new Map<string, { text: string; tokenCount: number }>();
    private excelMarkdownCache = new Map<string, { markdown: string; tokenCount: number }>();
    private wordTextCache = new Map<string, { text: string; tokenCount: number }>();

    public getVirtualPdfContent(filePath: string) {
        return this.pdfTextCache.get(filePath);
    }

    public getVirtualExcelContent(filePath: string) {
        return this.excelMarkdownCache.get(filePath);
    }

    public getVirtualWordContent(filePath: string) {
        return this.wordTextCache.get(filePath);
    }

    public async handlePdfToTextRequest(filePath: string, serverIpc: ServerPostMessageManager) {
        Services.loggerService.log(`Received RequestPdfToText for: ${filePath}`);
        if (this.pdfTextCache.has(filePath)) {
            const cached = this.pdfTextCache.get(filePath)!;
            serverIpc.sendToClient(ServerToClientChannel.UpdateNodeStats, { path: filePath, tokenCount: cached.tokenCount });
            Services.loggerService.log(`PDF served from cache: ${filePath}`);
            return;
        }

        try {
            Services.loggerService.log(`[PDF] Processing: ${filePath}`);
            const buffer = await fs.readFile(filePath);
            const data = await pdf(buffer);
            const text = data.text;
            const tokenCount = Math.ceil(text.length / 4);
            
            this.pdfTextCache.set(filePath, { text, tokenCount });
            Services.loggerService.log(`PDF Parsed and cached: ${path.basename(filePath)} (${tokenCount} tokens)`);

            serverIpc.sendToClient(ServerToClientChannel.UpdateNodeStats, { path: filePath, tokenCount: tokenCount });
        } catch (error: any) {
            const errorMessage = `Failed to parse PDF: ${path.basename(filePath)}`;
            Services.loggerService.error(`[PDF] Error processing ${filePath}: ${error.stack || error.message}`);
            serverIpc.sendToClient(ServerToClientChannel.UpdateNodeStats, { path: filePath, tokenCount: 0, error: errorMessage });
        }
    }

    private _sheetToMarkdown(sheet: XLSX.WorkSheet): string {
        const data: any[][] = XLSX.utils.sheet_to_json(sheet, { header: 1 });
        if (data.length === 0) return "";
    
        const sanitizedData = data.map(row => 
            row.map(cell => {
                const cellStr = cell ? String(cell) : '';
                return cellStr.replace(/\|/g, '\\|').replace(/\r?\n/g, '<br/>');
            })
        );
    
        const header = sanitizedData[0];
        const body = sanitizedData.slice(1);
        const headerLine = `| ${header.join(' | ')} |`;
        const separatorLine = `| ${header.map(() => '---').join(' | ')} |`;
        const bodyLines = body.map(row => `| ${row.join(' | ')} |`).join('\n');
        return `${headerLine}\n${separatorLine}\n${bodyLines}`;
    }

    public async handleExcelToTextRequest(filePath: string, serverIpc: ServerPostMessageManager) {
        Services.loggerService.log(`Received RequestExcelToText for: ${filePath}`);
        if (this.excelMarkdownCache.has(filePath)) {
            const cached = this.excelMarkdownCache.get(filePath)!;
            serverIpc.sendToClient(ServerToClientChannel.UpdateNodeStats, { path: filePath, tokenCount: cached.tokenCount });
            Services.loggerService.log(`Excel served from cache: ${filePath}`);
            return;
        }

        try {
            Services.loggerService.log(`[Excel] Processing: ${filePath}`);
            const buffer = await fs.readFile(filePath);
            const workbook = XLSX.read(buffer, { type: 'buffer' });
            
            let markdown = '';
            workbook.SheetNames.forEach(sheetName => {
                markdown += `### Sheet: ${sheetName}\n\n`;
                const worksheet = workbook.Sheets[sheetName];
                markdown += this._sheetToMarkdown(worksheet);
                markdown += '\n\n';
            });

            const tokenCount = Math.ceil(markdown.length / 4);
            this.excelMarkdownCache.set(filePath, { markdown, tokenCount });
            Services.loggerService.log(`Excel Parsed and cached: ${path.basename(filePath)} (${tokenCount} tokens)`);

            serverIpc.sendToClient(ServerToClientChannel.UpdateNodeStats, { path: filePath, tokenCount: tokenCount });
        } catch (error: any) {
             const errorMessage = `Failed to parse Excel/CSV file: ${path.basename(filePath)}`;
             Services.loggerService.error(`[Excel] Error processing ${filePath}: ${error.stack || error.message}`);
             serverIpc.sendToClient(ServerToClientChannel.UpdateNodeStats, { path: filePath, tokenCount: 0, error: errorMessage });
        }
    }

    public async handleWordToTextRequest(filePath: string, serverIpc: ServerPostMessageManager) {
        Services.loggerService.log(`Received RequestWordToText for: ${filePath}`);
        if (this.wordTextCache.has(filePath)) {
            const cached = this.wordTextCache.get(filePath)!;
            serverIpc.sendToClient(ServerToClientChannel.UpdateNodeStats, { path: filePath, tokenCount: cached.tokenCount });
            Services.loggerService.log(`Word served from cache: ${filePath}`);
            return;
        }

        const extension = path.extname(filePath).toLowerCase();
        if (extension === '.doc') {
            const unsupportedMessage = "UNSUPPORTED_FORMAT";
            this.wordTextCache.set(filePath, { text: unsupportedMessage, tokenCount: 0 });
            Services.loggerService.warn(`[Word] Legacy .doc format is not supported for file: ${filePath}`);
            serverIpc.sendToClient(ServerToClientChannel.UpdateNodeStats, { path: filePath, tokenCount: 0, error: "Legacy .doc format not supported." });
            return;
        }

        try {
            Services.loggerService.log(`[Word] Processing: ${filePath}`);
            const buffer = await fs.readFile(filePath);
            const result = await mammoth.extractRawText({ buffer });
            const text = result.value;
            const tokenCount = Math.ceil(text.length / 4);
            
            this.wordTextCache.set(filePath, { text, tokenCount });
            Services.loggerService.log(`Word Parsed and cached: ${path.basename(filePath)} (${tokenCount} tokens)`);

            serverIpc.sendToClient(ServerToClientChannel.UpdateNodeStats, { path: filePath, tokenCount: tokenCount });
        } catch (error: any) {
            let errorMessage = `Failed to parse Word file: ${path.basename(filePath)}`;
            if (error instanceof Error && error.message.includes("Can't find end of central directory")) {
                errorMessage = "File may be corrupted or is not a valid .docx format.";
            }
            Services.loggerService.error(`[Word] Error processing ${filePath}: ${error.stack || error.message}`);
            serverIpc.sendToClient(ServerToClientChannel.UpdateNodeStats, { path: filePath, tokenCount: 0, error: errorMessage });
        }
    }
}
</file>

<file path="src/backend/services/file-operation.service.ts">
// src/backend/services/file-operation.service.ts
import * as vscode from "vscode";
import * as path from "path";
import { ServerPostMessageManager } from "@/common/ipc/server-ipc";
import { ServerToClientChannel } from "@/common/ipc/channels.enum";
import { Services } from "./services";
import { Action, MoveActionPayload } from "./action.service";

const normalizePath = (p: string) => p.replace(/\\/g, '/');

export class FileOperationService {
    private filesToIgnoreForAutoAdd: Set<string> = new Set();

    public async handleFileContentRequest(filePath: string, serverIpc: ServerPostMessageManager) {
        Services.loggerService.log(`handleFileContentRequest initiated for: ${filePath}`);
        try {
            const workspaceFolders = vscode.workspace.workspaceFolders;
            if (!workspaceFolders?.[0]) {
                throw new Error("No workspace folder open.");
            }
            const absolutePath = path.resolve(workspaceFolders[0].uri.fsPath, filePath);
            const uri = vscode.Uri.file(absolutePath);
            const contentBuffer = await vscode.workspace.fs.readFile(uri);
            const content = Buffer.from(contentBuffer).toString('utf-8');
            Services.loggerService.log(`Successfully read content for: ${filePath}. Sending to client.`);
            serverIpc.sendToClient(ServerToClientChannel.SendFileContent, { path: filePath, content });
        } catch (error) {
            Services.loggerService.error(`Failed to read file content for ${filePath}: ${error}`);
            serverIpc.sendToClient(ServerToClientChannel.SendFileContent, { path: filePath, content: `// Error: Could not read file content for ${filePath}. It may not exist in the workspace.` });
        }
    }

    public async handleFileExistenceRequest(paths: string[], serverIpc: ServerPostMessageManager) {
        Services.loggerService.log(`[File Existence] Received request to check paths: ${JSON.stringify(paths)}`);
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (!workspaceFolders || workspaceFolders.length === 0) {
            Services.loggerService.error("[File Existence] Cannot check for files, no workspace folder is open.");
            serverIpc.sendToClient(ServerToClientChannel.SendFileExistence, { existenceMap: {} });
            return;
        }
        const rootPath = workspaceFolders[0].uri.fsPath;
    
        const existenceMap: { [path: string]: boolean } = {};
        const checks = paths.map(async (p_raw) => {
            const p = p_raw.trim().replace(/^[`"']|[`"']$/g, '');
            if (!p) return;
    
            let absolutePath = path.resolve(rootPath, p);
            let normalizedPath = normalizePath(absolutePath);
    
            try {
                await vscode.workspace.fs.stat(vscode.Uri.file(normalizedPath));
                existenceMap[p_raw] = true;
            } catch {
                if (/^A\d+/.test(p)) {
                    const artifactPath = path.resolve(rootPath, 'src/Artifacts', p);
                    const normalizedArtifactPath = normalizePath(artifactPath);
                    try {
                        await vscode.workspace.fs.stat(vscode.Uri.file(normalizedArtifactPath));
                        existenceMap[p_raw] = true;
                        return;
                    } catch {}
                }
                existenceMap[p_raw] = false;
            }
        });
        await Promise.all(checks);
        serverIpc.sendToClient(ServerToClientChannel.SendFileExistence, { existenceMap });
    }

    private async _findAvailableCopyName(destinationPath: string): Promise<string> {
        try {
            await vscode.workspace.fs.stat(vscode.Uri.file(destinationPath));
        } catch (error) {
            return destinationPath;
        }
    
        const dir = path.dirname(destinationPath);
        const ext = path.extname(destinationPath);
        const baseName = path.basename(destinationPath, ext);
    
        let copyNum = 1;
        let nextPath = path.join(dir, `${baseName}-copy${ext}`);
        
        while (true) {
            try {
                await vscode.workspace.fs.stat(vscode.Uri.file(nextPath));
                copyNum++;
                nextPath = path.join(dir, `${baseName}-copy-${copyNum}${ext}`);
            } catch (error) {
                return nextPath;
            }
        }
    }

    public async handleCopyFileRequest(sourcePath: string, destinationDir: string) {
        try {
            const sourceName = path.basename(sourcePath);
            const initialDestinationPath = path.join(destinationDir, sourceName);
            const finalDestinationPath = await this._findAvailableCopyName(initialDestinationPath);
            const sourceUri = vscode.Uri.file(sourcePath);
            const destinationUri = vscode.Uri.file(finalDestinationPath);

            await vscode.workspace.fs.copy(sourceUri, destinationUri, { overwrite: false });
        } catch (error: any) {
            vscode.window.showErrorMessage(`Failed to copy file: ${error.message}`);
        }
    }

    public async handleCopyFileFromUri(sourceUriString: string, targetDir: string) {
        try {
            const sourceUri = vscode.Uri.parse(sourceUriString);
            const fileName = path.basename(sourceUri.fsPath);
            const targetUri = vscode.Uri.file(path.join(targetDir, fileName));
            await vscode.workspace.fs.copy(sourceUri, targetUri);
        } catch (error: any) {
            vscode.window.showErrorMessage(`Failed to copy file from URI: ${error.message}`);
        }
    }

    public async handleAddFileFromBuffer(targetPath: string, data: Uint8Array) {
        try {
            await vscode.workspace.fs.writeFile(vscode.Uri.file(targetPath), data);
        } catch (error: any) {
            vscode.window.showErrorMessage(`Failed to add file from buffer: ${error.message}`);
        }
    }

    public async handleOpenFileRequest(filePath: string) {
        try {
            await vscode.commands.executeCommand('vscode.open', vscode.Uri.file(filePath));
        } catch (error: any) {
            vscode.window.showErrorMessage(`Failed to open file ${filePath}: ${error.message}`);
        }
    }

    public async handleNewFileRequest(parentDirectory: string) {
        const newFileName = await vscode.window.showInputBox({ prompt: "Enter the name of the new file", value: "new-file.ts" });
        if (newFileName) {
            try {
                await vscode.workspace.fs.writeFile(vscode.Uri.file(path.join(parentDirectory, newFileName)), new Uint8Array());
            } catch (error: any) {
                vscode.window.showErrorMessage(`Failed to create file: ${error.message}`);
            }
        }
    }

    public async handleNewFolderRequest(parentDirectory: string) {
        const newFolderName = await vscode.window.showInputBox({ prompt: "Enter the name of the new folder", value: "new-folder" });
        if (newFolderName) {
            try {
                await vscode.workspace.fs.createDirectory(vscode.Uri.file(path.join(parentDirectory, newFolderName)));
            } catch (error: any) {
                vscode.window.showErrorMessage(`Failed to create folder: ${error.message}`);
            }
        }
    }

    public async handleFileRenameRequest(oldPath: string, newName: string) {
        try {
            await vscode.workspace.fs.rename(vscode.Uri.file(oldPath), vscode.Uri.file(path.join(path.dirname(oldPath), newName)));
        } catch (error: any) {
            vscode.window.showErrorMessage(`Failed to rename: ${error.message}`);
        }
    }

    public async handleMoveFileRequest(oldPath: string, newPath: string) {
        try {
            const lastSelection = await Services.selectionService.getLastSelection();
            if (!lastSelection.some(p => p.startsWith(oldPath))) {
                this.filesToIgnoreForAutoAdd.add(newPath);
                setTimeout(() => this.filesToIgnoreForAutoAdd.delete(newPath), 2000);
            }

            await vscode.workspace.fs.rename(vscode.Uri.file(oldPath), vscode.Uri.file(newPath));
            await Services.selectionService.updatePathInSelections(oldPath, newPath);
            Services.actionService.push({ type: 'move', payload: { fromPath: oldPath, toPath: newPath } as MoveActionPayload });
        } catch (error: any) {
            vscode.window.showErrorMessage(`Failed to move file: ${error.message}`);
        }
    }

    public async handleFileDeleteRequest(filePath: string) {
        const confirmation = await vscode.window.showWarningMessage(`Are you sure you want to delete ${path.basename(filePath)}?`, { modal: true }, 'Delete');
        if (confirmation === 'Delete') {
            try {
                await vscode.workspace.fs.delete(vscode.Uri.file(filePath), { recursive: true, useTrash: true });
            } catch (error: any) {
                vscode.window.showErrorMessage(`Failed to delete: ${error.message}`);
            }
        }
    }

    public async handleBatchFileDeleteRequest(paths: string[]) {
        if (paths.length === 0) return;
        const confirmation = await vscode.window.showWarningMessage(`Are you sure you want to delete ${paths.length} item(s)?`, { modal: true }, 'Delete');
        if (confirmation === 'Delete') {
            try {
                await Promise.all(paths.map(p => vscode.workspace.fs.delete(vscode.Uri.file(p), { recursive: true, useTrash: true })));
            } catch (error: any) {
                vscode.window.showErrorMessage(`Failed to delete items: ${error.message}`);
            }
        }
    }

    public handleRevealInExplorerRequest(filePath: string) {
        vscode.commands.executeCommand('revealInExplorer', vscode.Uri.file(filePath));
    }

    public handleCopyPathRequest(filePath: string, relative: boolean) {
        const workspaceFolders = vscode.workspace.workspaceFolders;
        let pathToCopy = filePath;
        if (relative && workspaceFolders?.[0]) {
            pathToCopy = path.relative(workspaceFolders[0].uri.fsPath, filePath);
        }
        vscode.env.clipboard.writeText(pathToCopy);
        vscode.window.showInformationMessage(`Copied to clipboard: ${pathToCopy}`);
    }

    public addFileToIgnoreForAutoAdd(filePath: string) {
        this.filesToIgnoreForAutoAdd.add(filePath);
    }

    public hasFileToIgnoreForAutoAdd(filePath: string): boolean {
        return this.filesToIgnoreForAutoAdd.has(filePath);
    }

    public removeFileToIgnoreForAutoAdd(filePath: string) {
        this.filesToIgnoreForAutoAdd.delete(filePath);
    }
}
</file>

<file path="src/backend/services/file-tree.service.ts">
// Updated on: C115 (Fix type error in getGitStatusMap)
import * as vscode from "vscode";
import * as path from "path";
import * as fs from "fs/promises";
import { ServerPostMessageManager } from "@/common/ipc/server-ipc";
import { ServerToClientChannel } from "@/common/ipc/channels.enum";
import { FileNode } from "@/common/types/file-node";
import { Services } from "./services";
import { serverIPCs } from "@/client/views";
import { VIEW_TYPES } from "@/common/view-types";
import { API as GitAPI, Status } from "../types/git";
import { ProblemCountsMap } from "@/common/ipc/channels.type";

const IMAGE_EXTENSIONS = new Set(['.png', '.jpg', '.jpeg', '.gif', '.bmp', '.svg', '.webp', '.ico']);
const EXCEL_EXTENSIONS = new Set(['.xlsx', '.xls', '.csv']);
const WORD_EXTENSIONS = new Set(['.docx', '.doc']);
const EXCLUSION_PATTERNS = ['node_modules', 'dist', 'out', '.git', 'dce_cache', '.vscode'];

const normalizePath = (p: string) => p.replace(/\\/g, '/');

export class FileTreeService {
    private fileTreeCache: FileNode[] | null = null;
    private watcher: vscode.FileSystemWatcher | null = null;
    private refreshDebounceTimer: NodeJS.Timeout | null = null;
    private diagnosticsDebounceTimer: NodeJS.Timeout | null = null;
    private gitApi?: GitAPI;

    constructor(gitApi?: GitAPI) {
        this.gitApi = gitApi;
        if (this.gitApi) {
            this.gitApi.onDidOpenRepository(() => this.triggerFullRefresh());
            this.gitApi.repositories.forEach(repo => {
                repo.state.onDidChange(() => this.triggerFullRefresh());
            });
        }
    }

    private triggerFullRefresh() {
        if (this.refreshDebounceTimer) clearTimeout(this.refreshDebounceTimer);
        this.refreshDebounceTimer = setTimeout(() => {
            this.fileTreeCache = null;
            const serverIpc = serverIPCs[VIEW_TYPES.SIDEBAR.CONTEXT_CHOOSER];
            if (serverIpc) {
                serverIpc.sendToClient(ServerToClientChannel.ForceRefresh, { reason: 'fileOp' });
            }
        }, 500);
    }

    private triggerDiagnosticsUpdate() {
        if (this.diagnosticsDebounceTimer) clearTimeout(this.diagnosticsDebounceTimer);
        this.diagnosticsDebounceTimer = setTimeout(() => {
            const serverIpc = serverIPCs[VIEW_TYPES.SIDEBAR.CONTEXT_CHOOSER];
            if (serverIpc) {
                serverIpc.sendToClient(ServerToClientChannel.UpdateProblemCounts, { problemMap: this.getProblemCountsMap() });
            }
        }, 750);
    }

    public initializeWatcher() {
        if (this.watcher) this.watcher.dispose();
        
        this.watcher = vscode.workspace.createFileSystemWatcher('**/*');
        const onFileChange = (uri: vscode.Uri) => {
            if (EXCLUSION_PATTERNS.some(pattern => normalizePath(uri.fsPath).includes(`/${pattern}/`))) return;
            this.triggerFullRefresh();
        };

        this.watcher.onDidCreate(async (uri: vscode.Uri) => {
            const normalizedPath = normalizePath(uri.fsPath);
            if (Services.fileOperationService.hasFileToIgnoreForAutoAdd(normalizedPath)) {
                Services.fileOperationService.removeFileToIgnoreForAutoAdd(normalizedPath);
            } else if (Services.selectionService.getAutoAddState()) {
                const currentSelection = await Services.selectionService.getLastSelection();
                await Services.selectionService.saveCurrentSelection([...new Set([...currentSelection, normalizedPath])]);
            }
            onFileChange(uri);
        });
        this.watcher.onDidChange(onFileChange);
        this.watcher.onDidDelete(onFileChange);
        vscode.languages.onDidChangeDiagnostics(() => this.triggerDiagnosticsUpdate());
    }

    private async getFileStats(filePath: string): Promise<Omit<FileNode, 'name' | 'absolutePath' | 'children'>> {
        const extension = path.extname(filePath).toLowerCase();
        try {
            const stats = await fs.stat(filePath);
            const isImage = IMAGE_EXTENSIONS.has(extension);
            const isPdf = extension === '.pdf';
            const isExcel = EXCEL_EXTENSIONS.has(extension);
            const isWordDoc = WORD_EXTENSIONS.has(extension);
            
            if (isImage) return { tokenCount: 0, sizeInBytes: stats.size, isImage, extension, isPdf, isExcel, isWordDoc, fileCount: 1 };
            if (isPdf) return { tokenCount: Services.contentExtractionService.getVirtualPdfContent(filePath)?.tokenCount || 0, sizeInBytes: stats.size, isImage, extension, isPdf, isExcel, isWordDoc, fileCount: 1 };
            if (isExcel) return { tokenCount: Services.contentExtractionService.getVirtualExcelContent(filePath)?.tokenCount || 0, sizeInBytes: stats.size, isImage, extension, isPdf, isExcel, isWordDoc, fileCount: 1 };
            if (isWordDoc) return { tokenCount: Services.contentExtractionService.getVirtualWordContent(filePath)?.tokenCount || 0, sizeInBytes: stats.size, isImage, extension, isPdf, isExcel, isWordDoc, fileCount: 1 };

            if (stats.size > 5_000_000) return { tokenCount: 0, sizeInBytes: stats.size, isImage, extension, isPdf, isExcel, isWordDoc, fileCount: 1 };
            
            const content = await fs.readFile(filePath, 'utf-8');
            return { tokenCount: Math.ceil(content.length / 4), sizeInBytes: stats.size, isImage, extension, isPdf, isExcel, isWordDoc, fileCount: 1 };
        } catch (error: any) {
            return { tokenCount: 0, sizeInBytes: 0, isImage: false, extension, isPdf: false, isExcel: false, isWordDoc: false, fileCount: 1, error: error.message };
        }
    }

    public async handleWorkspaceFilesRequest(serverIpc: ServerPostMessageManager, forceRefresh: boolean = false) {
        if (!forceRefresh && this.fileTreeCache) {
            serverIpc.sendToClient(ServerToClientChannel.SendWorkspaceFiles, { files: this.fileTreeCache });
            return;
        }

        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (!workspaceFolders?.[0]) {
            serverIpc.sendToClient(ServerToClientChannel.SendWorkspaceFiles, { files: [] });
            return;
        }
        
        const fileTree = await this.buildTreeFromTraversal(workspaceFolders[0].uri);
        this.fileTreeCache = [fileTree];
        serverIpc.sendToClient(ServerToClientChannel.SendWorkspaceFiles, { files: this.fileTreeCache });
    }

    private getGitStatusMap(): Map<string, string> {
        if (!this.gitApi?.repositories[0]) return new Map();
        
        const repo = this.gitApi.repositories[0];
        const getStatusChar = (s: Status) => ({ [Status.INDEX_ADDED]: 'A', [Status.MODIFIED]: 'M', [Status.DELETED]: 'D', [Status.UNTRACKED]: 'U', [Status.IGNORED]: 'I', [Status.CONFLICT]: 'C' }[s] || '');
        
        const changes = [...repo.state.workingTreeChanges, ...repo.state.indexChanges, ...repo.state.mergeChanges];
        
        // C115: Use reduce for a more type-safe map creation
        return changes.reduce((acc, change) => {
            const statusChar = getStatusChar(change.status);
            if (statusChar) {
                acc.set(normalizePath(change.uri.fsPath), statusChar);
            }
            return acc;
        }, new Map<string, string>());
    }

    private getProblemCountsMap(): ProblemCountsMap {
        const problemMap: ProblemCountsMap = {};
        for (const [uri, diagnosticArr] of vscode.languages.getDiagnostics()) {
            const path = normalizePath(uri.fsPath);
            problemMap[path] = problemMap[path] || { error: 0, warning: 0 };
            for (const diag of diagnosticArr) {
                if (diag.severity === vscode.DiagnosticSeverity.Error) problemMap[path].error++;
                else if (diag.severity === vscode.DiagnosticSeverity.Warning) problemMap[path].warning++;
            }
        }
        return problemMap;
    }

    private async buildTreeFromTraversal(rootUri: vscode.Uri): Promise<FileNode> {
        const rootPath = rootUri.fsPath;
        const gitStatusMap = this.getGitStatusMap();
        const problemCountsMap = this.getProblemCountsMap();

        const rootNode: FileNode = {
            name: path.basename(rootPath),
            absolutePath: normalizePath(rootPath),
            children: await this._traverseDirectory(rootUri, gitStatusMap, problemCountsMap),
            tokenCount: 0, fileCount: 0, isImage: false, sizeInBytes: 0, extension: '', isPdf: false, isExcel: false, isWordDoc: false,
            gitStatus: gitStatusMap.get(normalizePath(rootPath)),
            problemCounts: problemCountsMap[normalizePath(rootPath)]
        };
        this._aggregateStats(rootNode);
        return rootNode;
    }
    
    private async _traverseDirectory(dirUri: vscode.Uri, gitStatusMap: Map<string, string>, problemCountsMap: ProblemCountsMap): Promise<FileNode[]> {
        const children: FileNode[] = [];
        try {
            for (const [name, type] of await vscode.workspace.fs.readDirectory(dirUri)) {
                if (EXCLUSION_PATTERNS.includes(name)) continue;

                const childUri = vscode.Uri.joinPath(dirUri, name);
                const childPath = normalizePath(childUri.fsPath);

                if (type === vscode.FileType.Directory) {
                    const dirNode: FileNode = { name, absolutePath: childPath, children: await this._traverseDirectory(childUri, gitStatusMap, problemCountsMap), tokenCount: 0, fileCount: 0, isImage: false, sizeInBytes: 0, extension: '', isPdf: false, isExcel: false, isWordDoc: false, gitStatus: gitStatusMap.get(childPath), problemCounts: problemCountsMap[childPath] };
                    this._aggregateStats(dirNode);
                    children.push(dirNode);
                } else if (type === vscode.FileType.File) {
                    const stats = await this.getFileStats(childPath);
                    children.push({ name, absolutePath: childPath, ...stats, gitStatus: gitStatusMap.get(childPath), problemCounts: problemCountsMap[childPath] });
                }
            }
        } catch (error: any) {
            Services.loggerService.error(`Error traversing directory ${dirUri.fsPath}: ${error.message}`);
        }
        return children.sort((a, b) => (!!a.children === !!b.children) ? a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' }) : (!!a.children ? -1 : 1));
    }

    private _aggregateStats(node: FileNode): void {
        if (!node.children) return;
        let totalTokens = 0, totalFiles = 0, totalBytes = 0, totalErrors = node.problemCounts?.error || 0, totalWarnings = node.problemCounts?.warning || 0;
        for (const child of node.children) {
            totalTokens += child.tokenCount;
            totalFiles += child.fileCount;
            totalBytes += child.sizeInBytes;
            if(child.problemCounts) {
                totalErrors += child.problemCounts.error;
                totalWarnings += child.problemCounts.warning;
            }
        }
        node.tokenCount = totalTokens;
        node.fileCount = totalFiles;
        node.sizeInBytes = totalBytes;
        if(totalErrors > 0 || totalWarnings > 0) node.problemCounts = { error: totalErrors, warning: totalWarnings };
    }
}
</file>

<file path="src/backend/services/flattener.service.ts">
// Updated on: C114 (Refactor to use new services)
import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs/promises';
import { Services } from './services';
import { VIEW_TYPES } from '@/common/view-types';
import { serverIPCs } from '@/client/views';
import { ServerToClientChannel } from '@/common/ipc/channels.enum';
import { formatBytes } from '@/common/utils/formatting';

interface FileStats {
    filePath: string;
    lines: number;
    characters: number;
    tokens: number;
    content: string;
    error: string | null;
    isBinary: boolean;
    sizeInBytes: number;
}

const BINARY_EXTENSIONS = new Set(['.png', '.jpg', '.jpeg', '.gif', '.bmp', '.svg', '.webp', '.ico', '.exe', '.dll', '.bin', '.zip', '.gz', '.7z', '.mp3', '.wav', '.mov', '.mp4']);
const EXCEL_EXTENSIONS = new Set(['.xlsx', '.xls', '.csv']);
const WORD_EXTENSIONS = new Set(['.docx', '.doc']);


export class FlattenerService {

    public async flatten(selectedPaths: string[]) {
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (!workspaceFolders || workspaceFolders.length === 0) {
            vscode.window.showErrorMessage("Cannot flatten context: No workspace folder is open.");
            return;
        }
        if (selectedPaths.length === 0) {
            vscode.window.showWarningMessage("Cannot flatten context: No files or folders are selected.");
            return;
        }

        const rootPath = workspaceFolders[0].uri.fsPath;
        const outputFilePath = path.join(rootPath, 'flattened_repo.md');

        try {
            const allFilePaths = await this.expandDirectories(selectedPaths);
            const uniqueFilePaths = [...new Set(allFilePaths)];

            const fileStatsPromises = uniqueFilePaths.map(filePath => this.getFileStatsAndContent(filePath));
            const results = await Promise.all(fileStatsPromises);
            const validResults = results.filter(r => !r.error);


            const outputContent = this.generateOutputContent(results, rootPath, outputFilePath);

            await fs.writeFile(outputFilePath, outputContent, 'utf-8');
            vscode.window.showInformationMessage(`Successfully flattened ${validResults.length} files to flattened_repo.md.`);

            Services.loggerService.log(`Opening flattened file: ${outputFilePath}`);
            await Services.fileOperationService.handleOpenFileRequest(outputFilePath);

            const serverIpc = serverIPCs[VIEW_TYPES.SIDEBAR.CONTEXT_CHOOSER];
            if (serverIpc) {
                setTimeout(() => {
                    serverIpc.sendToClient(ServerToClientChannel.FocusFile, { path: outputFilePath });
                }, 500);
            }

        } catch (error: any) {
            vscode.window.showErrorMessage(`Failed to flatten context: ${error.message}`);
            console.error(error);
        }
    }

    private async expandDirectories(paths: string[]): Promise<string[]> {
        const allFiles: string[] = [];
        for (const p of paths) {
            try {
                const stats = await fs.stat(p);
                if (stats.isDirectory()) {
                    allFiles.push(...await this.getAllFilesRecursive(p));
                } else {
                    allFiles.push(p);
                }
            } catch (e) {
                console.warn(`Could not stat path ${p}, skipping.`);
            }
        }
        return allFiles;
    }

    private async getAllFilesRecursive(dirPath: string): Promise<string[]> {
        let files: string[] = [];
        try {
            const entries = await fs.readdir(dirPath, { withFileTypes: true });
            for (const entry of entries) {
                const fullPath = path.join(dirPath, entry.name);
                if (entry.isDirectory()) {
                    if (entry.name.toLowerCase() === 'node_modules') continue;
                    files = files.concat(await this.getAllFilesRecursive(fullPath));
                } else {
                    files.push(fullPath);
                }
            }
        } catch (e) {
            console.error(`Error reading directory ${dirPath}:`, e);
        }
        return files;
    }

    private async _parseImageMetadata(filePath: string): Promise<any> {
        try {
            const buffer = await fs.readFile(filePath);
            const sizeInBytes = buffer.length;
            const metadata: any = { sizeInBytes };

            if (buffer.length > 24 && buffer.toString('hex', 0, 8) === '89504e470d0a1a0a') { // PNG
                const ihdrIndex = buffer.indexOf('IHDR');
                if (ihdrIndex !== -1) metadata.dimensions = { width: buffer.readUInt32BE(ihdrIndex + 4), height: buffer.readUInt32BE(ihdrIndex + 8) };
            } else if (buffer.length > 10 && buffer.toString('utf8', 0, 3) === 'GIF') { // GIF
                 metadata.dimensions = { width: buffer.readUInt16LE(6), height: buffer.readUInt16LE(8) };
            } else if (buffer.length > 11 && buffer[0] === 0xff && buffer[1] === 0xd8) { // JPEG
                let pos = 2;
                while (pos < buffer.length - 9) {
                    if (buffer[pos] === 0xff && (buffer[pos + 1] & 0xf0) === 0xc0) {
                        metadata.dimensions = { width: buffer.readUInt16BE(pos + 7), height: buffer.readUInt16BE(pos + 5) };
                        break;
                    }
                    pos += buffer[pos + 2] ? buffer.readUInt16BE(pos + 2) + 2 : 1;
                }
            }
            return metadata;
        } catch (err: any) {
            try { return { sizeInBytes: (await fs.stat(filePath)).size }; } catch { return { sizeInBytes: -1 }; }
        }
    }

    private async getFileStatsAndContent(filePath: string): Promise<FileStats> {
        const extension = path.extname(filePath).toLowerCase();
        
        if (extension === '.pdf') {
            const virtualContent = Services.contentExtractionService.getVirtualPdfContent(filePath);
            if (virtualContent) return { filePath, content: virtualContent.text, lines: virtualContent.text.split('\n').length, characters: virtualContent.text.length, tokens: virtualContent.tokenCount, error: null, isBinary: false, sizeInBytes: 0 };
            return { filePath, lines: 0, characters: 0, tokens: 0, content: '<!-- PDF content not processed or cached -->', error: null, isBinary: false, sizeInBytes: 0 };
        }

        if (EXCEL_EXTENSIONS.has(extension)) {
            const virtualContent = Services.contentExtractionService.getVirtualExcelContent(filePath);
            if (virtualContent) return { filePath, content: virtualContent.markdown, lines: virtualContent.markdown.split('\n').length, characters: virtualContent.markdown.length, tokens: virtualContent.tokenCount, error: null, isBinary: false, sizeInBytes: 0 };
            return { filePath, lines: 0, characters: 0, tokens: 0, content: '<!-- Excel/CSV content not processed or cached -->', error: null, isBinary: false, sizeInBytes: 0 };
        }

        if (WORD_EXTENSIONS.has(extension)) {
            const virtualContent = Services.contentExtractionService.getVirtualWordContent(filePath);
            if (virtualContent) {
                const content = virtualContent.text === "UNSUPPORTED_FORMAT" ? `<!-- Content of .doc file '${path.basename(filePath)}' could not be extracted. Legacy .doc format is not supported. Please convert to .docx. -->` : virtualContent.text;
                return { filePath, content: content, lines: content.split('\n').length, characters: content.length, tokens: virtualContent.tokenCount, error: null, isBinary: false, sizeInBytes: 0 };
            }
            return { filePath, lines: 0, characters: 0, tokens: 0, content: '<!-- Word content not processed or cached -->', error: null, isBinary: false, sizeInBytes: 0 };
        }

        if (BINARY_EXTENSIONS.has(extension)) {
            try {
                const imageMetadata = await this._parseImageMetadata(filePath);
                const metadata = { name: path.basename(filePath), directory: path.dirname(filePath), fileType: extension.substring(1).toUpperCase(), sizeInBytes: imageMetadata.sizeInBytes, ...(imageMetadata.dimensions && { dimensions: imageMetadata.dimensions }) };
                const metadataContent = `<metadata>\n${JSON.stringify(metadata, null, 2)}\n</metadata>`;
                return { filePath, lines: 0, characters: 0, tokens: 0, content: metadataContent, error: null, isBinary: true, sizeInBytes: imageMetadata.sizeInBytes };
            } catch (error: any) {
                 return { filePath, lines: 0, characters: 0, tokens: 0, content: '', error: `Could not get stats for binary file: ${error.message}`, isBinary: true, sizeInBytes: -1 };
            }
        }

        try {
            const content = await fs.readFile(filePath, 'utf-8');
            const stats = await fs.stat(filePath);
            return { filePath, lines: content.split('\n').length, characters: content.length, tokens: Math.ceil(content.length / 4), content, error: null, isBinary: false, sizeInBytes: stats.size };
        } catch (error: any) {
            return { filePath, lines: 0, characters: 0, tokens: 0, content: '', error: error.message, isBinary: false, sizeInBytes: -1 };
        }
    }

    private generateOutputContent(results: FileStats[], rootDir: string, outputFilename: string): string {
        const validResults = results.filter(r => !r.error);
        const totalTokens = validResults.reduce((sum, r) => sum + r.tokens, 0);
        
        let output = `<!--\n  File: ${path.basename(outputFilename)}\n  Source Directory: ${rootDir}\n  Date Generated: ${new Date().toISOString()}\n  ---\n`;
        output += `  Total Files: ${validResults.length}\n  Approx. Tokens: ${totalTokens}\n-->\n\n`;
        
        output += `<!-- Top 10 Text Files by Token Count -->\n`;
        [...validResults].filter(r => r.tokens > 0).sort((a, b) => b.tokens - a.tokens).slice(0, 10)
            .forEach((r, i) => output += `${i + 1}. ${path.relative(rootDir, r.filePath)} (${r.tokens} tokens)\n`);
        output += `\n`;

        output += `<!-- Full File List -->\n`;
        results.forEach((r, i) => {
            const relPath = path.relative(rootDir, r.filePath);
            if (r.error) output += `${i + 1}. ${relPath} - ERROR: ${r.error}\n`;
            else if (r.isBinary) output += `${i + 1}. ${relPath} - [Binary] Size: ${formatBytes(r.sizeInBytes)}\n`;
            else output += `${i + 1}. ${relPath} - Lines: ${r.lines} - Chars: ${r.characters} - Tokens: ${r.tokens}\n`;
        });
        output += `\n`;

        for (const { filePath, content, error } of results) {
            const relativePath = path.relative(rootDir, filePath).replace(/\\/g, '/');
            output += `<file path="${relativePath}">\n`;
            output += error ? `Error reading file: ${error}\n` : content;
            if (content && !content.endsWith('\n')) output += '\n';
            output += `</file>\n\n`;
        }
        return output;
    }
}
</file>

<file path="src/backend/services/highlighting.service.ts">
// Updated on: C126 (Truncate log output for code snippets)
import { createStarryNight, common } from '@wooorm/starry-night';
import sourceTsx from '@wooorm/starry-night/source.tsx';
import sourceJs from '@wooorm/starry-night/source.js';
import sourceTs from '@wooorm/starry-night/source.ts';
import sourceCss from '@wooorm/starry-night/source.css';
import sourceScss from '@wooorm/starry-night/source.css.scss';
import textHtml from '@wooorm/starry-night/text.html.basic';
import { toHtml } from 'hast-util-to-html';
import { Services } from './services';
import { ServerPostMessageManager } from '@/common/ipc/server-ipc';
import { ServerToClientChannel } from '@/common/ipc/channels.enum';

export class HighlightingService {
    private starryNight: any = null;

    constructor() {
        this.initializeStarryNight();
    }

    private async initializeStarryNight() {
        try {
            const grammars = [...common, sourceTsx, sourceJs, sourceTs, sourceCss, sourceScss, textHtml];
            this.starryNight = await createStarryNight(grammars);
            Services.loggerService.log('Starry Night syntax highlighter initialized.');
        } catch (error) {
            Services.loggerService.error(`Failed to initialize Starry Night: ${error}`);
        }
    }

    public async handleSyntaxHighlightRequest(code: string, lang: string, id: string, serverIpc: ServerPostMessageManager) {
        const truncatedCode = code.length > 20 ? `${code.substring(0, 20)}[...]` : code;
        Services.loggerService.log(`[SYNTAX-HIGHLIGHT] Received request for lang: ${lang}, code: ${truncatedCode}`);
        
        if (!this.starryNight) {
            Services.loggerService.error('Starry Night not initialized, cannot highlight.');
            serverIpc.sendToClient(ServerToClientChannel.SendSyntaxHighlight, { highlightedHtml: `<pre><code>${code}</code></pre>`, id });
            return;
        }

        const scope = this.starryNight.flagToScope(lang);
        if (!scope) {
            Services.loggerService.warn(`[WARN] No Starry Night scope found for language: ${lang}`);
            serverIpc.sendToClient(ServerToClientChannel.SendSyntaxHighlight, { highlightedHtml: `<pre><code>${code}</code></pre>`, id });
            return;
        }

        try {
            const tree = this.starryNight.highlight(code, scope);
            const hastHtml = toHtml(tree);
            const finalHtml = `<pre><code>${hastHtml}</code></pre>`;
            serverIpc.sendToClient(ServerToClientChannel.SendSyntaxHighlight, { highlightedHtml: finalHtml, id });
        } catch (error) {
            Services.loggerService.error(`Starry Night highlighting failed for lang ${lang}: ${error}`);
            serverIpc.sendToClient(ServerToClientChannel.SendSyntaxHighlight, { highlightedHtml: `<pre><code>${code}</code></pre>`, id });
        }
    }
}
</file>

<file path="src/backend/services/history.service.ts">
// src/backend/services/history.service.ts
import * as vscode from 'vscode';
import * as path from 'path';
import { Services } from './services';
import { PcppCycle, PcppHistoryFile } from '@/common/types/pcpp.types';
import { serverIPCs } from '@/client/views';
import { VIEW_TYPES } from '@/common/view-types';
import { ServerToClientChannel } from '@/common/ipc/channels.enum';

export class HistoryService {
    private historyFilePath: string | undefined;

    constructor() {
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (workspaceFolders && workspaceFolders.length > 0) {
            this.historyFilePath = path.join(workspaceFolders[0].uri.fsPath, '.vscode', 'dce_history.json');
        }
    }

    private async _readHistoryFile(): Promise<PcppHistoryFile> {
        if (!this.historyFilePath) return { version: 1, cycles: [] };
        try {
            const content = await vscode.workspace.fs.readFile(vscode.Uri.file(this.historyFilePath));
            return JSON.parse(Buffer.from(content).toString('utf-8'));
        } catch (error) {
            Services.loggerService.warn("dce_history.json not found or is invalid. A new one will be created.");
            return { version: 1, cycles: [] };
        }
    }

    private async _writeHistoryFile(data: PcppHistoryFile): Promise<void> {
        if (!this.historyFilePath) return;
        const dir = path.dirname(this.historyFilePath);
        try {
            await vscode.workspace.fs.createDirectory(vscode.Uri.file(dir));
            const content = Buffer.from(JSON.stringify(data, null, 2), 'utf-8');
            await vscode.workspace.fs.writeFile(vscode.Uri.file(this.historyFilePath), content);
        } catch (error) {
            Services.loggerService.error(`Failed to write to dce_history.json: ${error}`);
        }
    }

    public async getFullHistory(): Promise<PcppCycle[]> {
        const history = await this._readHistoryFile();
        return history.cycles;
    }

    public async getLatestCycle(): Promise<PcppCycle> {
        Services.loggerService.log("HistoryService: getLatestCycle called.");
        const history = await this._readHistoryFile();
        if (history.cycles.length === 0) {
            Services.loggerService.log("No history found, creating default cycle 1.");
            const defaultCycle: PcppCycle = {
                cycleId: 1,
                timestamp: new Date().toISOString(),
                title: 'New Cycle',
                cycleContext: '',
                ephemeralContext: '',
                responses: { "1": { content: "" } },
                isParsedMode: false,
                leftPaneWidth: 33,
            };
            await this.saveCycleData(defaultCycle);
            return defaultCycle;
        }
        
        const latestCycle = history.cycles.reduce((latest, current) => current.cycleId > latest.cycleId ? current : latest);
        Services.loggerService.log(`Latest cycle found: ${latestCycle.cycleId}`);
        return latestCycle;
    }

    public async getCycleData(cycleId: number): Promise<PcppCycle | null> {
        Services.loggerService.log(`HistoryService: getting data for cycle ${cycleId}.`);
        const history = await this._readHistoryFile();
        return history.cycles.find(c => c.cycleId === cycleId) || null;
    }

    public async saveCycleData(cycleData: PcppCycle): Promise<void> {
        Services.loggerService.log(`HistoryService: saving data for cycle ${cycleData.cycleId}.`);
        const history = await this._readHistoryFile();
        const cycleIndex = history.cycles.findIndex(c => c.cycleId === cycleData.cycleId);

        if (cycleIndex > -1) {
            history.cycles[cycleIndex] = cycleData;
        } else {
            history.cycles.push(cycleData);
        }
        
        history.cycles.sort((a, b) => a.cycleId - b.cycleId);

        await this._writeHistoryFile(history);
    }

    public async deleteCycle(cycleId: number): Promise<void> {
        Services.loggerService.log(`HistoryService: Deleting cycle ${cycleId}.`);
        const history = await this._readHistoryFile();
        
        if (history.cycles.length <= 1) {
            Services.loggerService.warn("Cannot delete the last remaining cycle.");
            vscode.window.showWarningMessage("Cannot delete the last cycle.");
            return;
        }

        history.cycles = history.cycles.filter(c => c.cycleId !== cycleId);
        await this._writeHistoryFile(history);
        Services.loggerService.log(`Cycle ${cycleId} deleted successfully.`);
        
        const serverIpc = serverIPCs[VIEW_TYPES.PANEL.PARALLEL_COPILOT];
        if (serverIpc) {
            serverIpc.sendToClient(ServerToClientChannel.ForceRefresh, { reason: 'history' });
        }
    }

    public async resetHistory(): Promise<void> {
        Services.loggerService.log(`HistoryService: Resetting all cycle history.`);
        if (this.historyFilePath) {
            try {
                await vscode.workspace.fs.delete(vscode.Uri.file(this.historyFilePath));
                Services.loggerService.log("dce_history.json deleted successfully.");
                 const serverIpc = serverIPCs[VIEW_TYPES.PANEL.PARALLEL_COPILOT];
                if (serverIpc) {
                    serverIpc.sendToClient(ServerToClientChannel.ForceRefresh, { reason: 'history' });
                }
            } catch (error) {
                Services.loggerService.error(`Failed to delete dce_history.json: ${error}`);
            }
        }
    }
}
</file>

<file path="src/backend/services/logger.service.ts">
import * as vscode from 'vscode';

export class LoggerService {
    private static instance: LoggerService;
    private outputChannel: vscode.OutputChannel;

    private constructor() {
        this.outputChannel = vscode.window.createOutputChannel("Data Curation Environment");
    }

    public static getInstance(): LoggerService {
        if (!LoggerService.instance) {
            LoggerService.instance = new LoggerService();
        }
        return LoggerService.instance;
    }

    public show() {
        this.outputChannel.show(true); // true => preserve focus
    }

    private logMessage(level: 'INFO' | 'WARN' | 'ERROR', message: string): void {
        const timestamp = new Date().toLocaleTimeString();
        this.outputChannel.appendLine(`[${level}] [${timestamp}] ${message}`);
    }

    public log(message: string): void {
        this.logMessage('INFO', message);
    }

    public warn(message: string): void {
        this.logMessage('WARN', message);
    }

    public error(message: string): void {
        this.logMessage('ERROR', message);
    }
}
</file>

<file path="src/backend/services/prompt.service.ts">
// Updated on: C120 (Fix cycle order in prompt.md)
import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs/promises';
import { Services } from './services';
import { parseResponse } from '@/client/utils/response-parser';
import { PcppCycle } from '@/common/types/pcpp.types';

export class PromptService {
    private artifactSchemaTemplate = `<M1. artifact schema>
M1. artifact schema
M2. cycle overview
M3. interaction schema
M4. current project scope
M5. organized artifacts list
M6. cycles
M7. Flattened Repo
</M1. artifact schema>`;

    private interactionSchemaTemplate = `<M3. Interaction Schema>
1.  Artifacts are complete, individual texts enclosed in \`<xmltags>\` and separated by three backticks. Different content sections can be separated with three asterisks. Please always output a summary of your thoughts/plan/course of action befoare providing your artifact outputs, whether they be Document artifacts, Code artifacts, or both.
1.1. **New (C108):** To ensure consistent parsing by the DCE extension, all file artifacts **must** be enclosed in \`<file path="path/to/file.ts">...</file>\` tags. The path must be relative to the workspace root. The closing tag must be a simple \`</file>\`. Do not use the file path in the closing tag.
2.  Our Document Artifacts serve as our \`Source of Truth\` throughout multiple cycles. As such, over time, as issues occur, or code repeatedly regresses in the same way, seek to align our \`Source of Truth\` such that the Root Cause of such occurances is codified so it can be avoided on subsequent cycles visits to those Code artifacts.
3.  Please output entire Document or Code artifacts. Do not worry about Token length. If your length continues for too long, and you reach the 600 second timeout, I will simply incorporate the work you did complete, and we can simply continue from where you left off. Better to have half of a solution to get started with, than not to have it. **Preference is for larger, more complete updates over smaller, incremental ones to align with the human curator's parallel processing workflow.** The human curator often sends the same prompt to multiple AI instances simultaneously and selects the most comprehensive response as the primary base for the next cycle, using other responses as supplementary information. Providing more complete updates increases the likelihood of a response being selected as the primary base.
4.  Do not output artifacts that do not require updates in this cycle. (Eg. Do not do this: // Updated on: Cycle 1040 (No functional changes, only cycle header))
5.  **Critical: \`flattened_repo_v2.txt\` contains all project files. Output updated *individual* files that are part of it (like \`<src/state/coreStore.ts>...\`). However, do **NOT** output the surrounding Artifact container tags (\`<flattened_repo_v2.txt>...</flattened_repo_v2.txt>\`) or any auto-generated metadata sections within it (like the Total Files summary, Top 10 list, or the \`<files list>\` section) which are created by the \`flatten.js\` script.**
5.1. \`flattened_repo_v2.txt\` is a copy of the codebase, generated by a script; assume its an accurate representation of the existing codebase, but not necessarily a 'source of truth' like we treat our documents as, our codebase is a living artifact, documents, while we can update them, should be considered less transient.
5.2. **\`.local\` File Convention:** To manage token count, some large data files (e.g., \`researchNodes.ts\`) may be represented by a truncated \`.local.ts\` version in the context. This version contains the essential structure and a few examples. If the full content of a file is required for a task (e.g., a comprehensive data refactor or fixing a bug related to a specific entry), explicitly state this need in your summary of actions and request that the curator swap the \`.local.ts\` file with the full \`.ts\` version in the \`files_list.txt\` for the subsequent cycle.
6.  remember to output complete artifacts without placeholders, im taking your output, putting it in winmerge, and confirming we arent losing data in the update. when you provide placeholders, my cursory review turns into a meticulous file parsing, taking me from what is 5 seconds per artifact to upwards of 5 minutes, only to realize that the output is actually un-parseable, due to the nature of relativity, as the theory of relativity also applies to code. if you give me a code snippet, and do not give me the code surrounding that snippet, i do not know where that code should go. by providing the complete file, on the other hand, i can put it in a diff, see easily what was altered, and if anything was accidentally omitted or lost, i can be sure that it's retained.
7.  **Update documentation before writing code.** document artifacts are like our project readme files, our source of truth. they are our blueprints. they guide the code we write. when we realize we need to alter our approach or invent new game mechanics, we update the source of truth first, cause english is easy and flexible, then we codify that.
8.  this query is part of a larger software engineering project
9.  After you complete delivery on a code artifact, review it to make sure you did not miss any intermediary files. for instance, if we have a DevelopmentSystem.ts, using the componentData.ts, which is displaying on the ComponentProductionTab.tsx. But then theres also still a DevPanel.tsx file that is in-between that *could*, but shouldnt, get overlooked.
10. If you are deciding where to put a particular piece of code or function, and due to its nature, there are one or more candidate files that it could be placed in, choose the smaller file (in tokens).
11. Begin your response with a course of action and end with a review of your work, surface any self corrections in the summary of changes for the subsequent cycle.
12. do not underestimate how much you can accomplish in a given cycle; you'd only accomplish handicapping yourself. (Eg. you've authored this whole thing with just my guidance. good job, keep it up.)
13. Not as relevant for this project: **Log State Button:** The 'Log State' button in the \`DevInfoOverlay\` is a dynamic debugging tool. Modify the \`triggerDebugLogs\` action in \`uiStore.ts\` to output specific state information relevant to the current bug being investigated. **See A85 (Logging Guide) for usage details.**
14. Not as relevant for this project: **Regression Case Studies:** Use Artifact A106 to document persistent or complex bugs and their resolutions. Add entries *after* a fix is confirmed to codify the RCA and solution, preventing future regressions.
15. Include in your cycle summary, a short list of files you've updated. This makes it easy for my reviews.
16. if you seem to have spare time in a cycle, see if you can spot any particular file with excessive levels of comments or logging that seems extensive and for troubleshooting an error that has since been resolved, see to it to clean those files but preserve their functionalities. im just looking to shave off excess tokens wherever possible in the master_content.txt file.
17. if you see \`(No change from C850)\` such language, it's data loss. there was supposed to be actual language behind that placeholder, but in one iteration (C850, in this case) you had provided a placeholder, and i 'missed it' and did not capture the initial information. you either need to deliver the placeholder in such a way as i can easily press the left arrow instead of the rigth arrow in winmerge to not accept that part, but to also not have winmerge confuse it with the rest, otherwise i must manually parse the information. when the process is a single keystroke, i can manage it quickly enough. when we remove that ability because you provided me data in a format that has placeholders AND the placeholders do not parse within winmerge such that it removes the benefit winmerge is adding, then we have our problem. when you see this, try to correct it using whatever current relevant context you have.
18. basically, you should not worry about brevity, because when you go too long, your response gets interrupted by the system anyway. its better that the products you do deliver are all complete except for the last one, rather than you delivering all incomplete products, including the last one. does that make sense?
19. remember, do not stop outputting for the reason of preventing a potential artifact interruption mid-output. you actually end up stopping yourself from producting two or three additional files before you actually get interrupted. what i mean is, in the outputs where you do not do this, you produce for 500 seconds, producing 7-9 files, and only the last one is interrupted and unusable. compared to when you stop yourself prematurely, for the reason stated, and you produce for 180 seconds and provide maybe 3-4 files. even with the -1, producing as much as you can still outperforms the alternative.
20. This is a misaligned statement: \`// (For full history, see master_content.txt)\` because your changes get rolled into master_content.txt. therefore, if you remove the history, then when your updates are rolled in, they will remove the full history. understand? after a while, the history is not relevant and can be rolled out, for a while, it ought to stay. you can see what we're working on + the current cycle and make this determination.
21. Each time we create a new documentation artifact, lets also create the key/value pairs needed for me to add it into our Master Artifact List. they can simply be added into the new artifact itself and ill make the new entry in A0. this will solve for me manually generating a description and tag for each new documentation artifact. also, dont place \`/\` in the title/name of a documentation artifact. VSCode treats it as a folder separator.
21.1. when creating a new documentation artifact, also just update the master artifacts list itself.
</M3. Interaction Schema>`;

    private projectScopeTemplate = `<M4. current project scope>
The plan is to create a Data Curation Environment. We will do this by creating a VS Code extension. The three main components will be:

Phase 1. Context chooser - Choose files/folders (checkmark option in the file explorer) that will be packaged as artifacts into a \`flattened_repo.md\` file.
Phase 2. parallel 'co-pilot' panel. Basically, we need our own AI Studio interface that is parallelizable. so thats what is wrong with the curernt co-pilot panel, that you are 'locked in' to a single conversation flow. my process involves sending the same prompt to up to 8 different conversation windows and then scrutinizing the responses in winmerge.
Phase 3. Diff Tool - Basically, winmerge but intergrated into a window within VS Code. My workflow is often comparing two identical responses, or comparing a new artifact with the current version. Currently, I'm first copying and pasting responses into separate notepad files, and then for which ever i need to compare given my task, i then manually move that one into winmerge to compare against another that i manually move. instead, the ability to just select between two to compare would be a massive decrease in the manual workload.
</M4. current project scope>`;

    public async generatePromptFile(cycleTitle: string, currentCycle: number) {
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (!workspaceFolders?.[0]) {
            vscode.window.showErrorMessage("Cannot generate prompt: No workspace folder is open.");
            return;
        }
        const rootPath = workspaceFolders[0].uri.fsPath;
        const flattenedRepoPath = path.join(rootPath, 'flattened_repo.md');
        const promptMdPath = path.join(rootPath, 'prompt.md');

        try {
            Services.loggerService.log("Generating prompt.md file...");

            const flattenedContent = await fs.readFile(flattenedRepoPath, 'utf-8');
            const fullHistory: PcppCycle[] = await Services.historyService.getFullHistory();

            // C120 FIX: Sort history in descending order for M2
            const sortedHistoryForM2 = [...fullHistory].sort((a, b) => b.cycleId - a.cycleId);

            let cycleOverview = '<M2. cycle overview>\n';
            cycleOverview += `Current Cycle ${currentCycle} - ${cycleTitle}\n`;
            for (const cycle of sortedHistoryForM2) {
                // Ensure we don't duplicate the current cycle entry if it's already in history
                if (cycle.cycleId !== currentCycle) {
                     cycleOverview += `Cycle ${cycle.cycleId} - ${cycle.title}\n`;
                }
            }
            cycleOverview += '</M2. cycle overview>';
            
            // C120 Fix: Also sort the history for M6 in descending order
            const sortedHistoryForM6 = [...fullHistory].sort((a, b) => b.cycleId - a.cycleId);

            let cyclesContent = '<M6. Cycles>\n\n';
            cyclesContent += `<Cycle ${currentCycle}>\n${cycleTitle}\n`;
            // Find the previous cycle's data to generate the summary
            const previousCycle = sortedHistoryForM6.find(c => c.cycleId === currentCycle - 1);
            if (previousCycle) {
                const previousResponseContent = previousCycle.responses['1']?.content || '';
                const parsed = parseResponse(previousResponseContent);
                const summary = `${parsed.summary}\n\n${parsed.courseOfAction}`;
                cyclesContent += `<Previous Cycle ${previousCycle.cycleId} Summary of Actions>\n${summary}\n</Previous Cycle ${previousCycle.cycleId} Summary of Actions>\n`;
            }
            cyclesContent += `</Cycle ${currentCycle}>\n\n`;


            for (const cycle of sortedHistoryForM6) {
                if (cycle.cycleId === currentCycle) continue; 
                cyclesContent += `<Cycle ${cycle.cycleId}>\n`;
                const prevCycleForSummary = sortedHistoryForM6.find(c => c.cycleId === cycle.cycleId - 1);
                 if (prevCycleForSummary) {
                    const previousResponseContent = prevCycleForSummary.responses['1']?.content || '';
                    const parsed = parseResponse(previousResponseContent);
                    const summary = `${parsed.summary}\n\n${parsed.courseOfAction}`;
                    cyclesContent += `<Previous Cycle ${prevCycleForSummary.cycleId} Summary of Actions>\n${summary}\n</Previous Cycle ${prevCycleForSummary.cycleId} Summary of Actions>\n`;
                 }
                cyclesContent += `</Cycle ${cycle.cycleId}>\n\n`;
            }
            cyclesContent += '</M6. Cycles>';


            let masterArtifactListContent = '<!-- Master Artifact List (A0) not found -->';
            try {
                const a0Path = path.join(rootPath, 'src', 'Artifacts', 'A0. DCE Master Artifact List.md');
                masterArtifactListContent = await fs.readFile(a0Path, 'utf-8');
            } catch (e) {
                Services.loggerService.warn("Could not read A0. DCE Master Artifact List.md");
            }

            const promptParts = [
                `<prompt.md>`,
                this.artifactSchemaTemplate,
                cycleOverview,
                this.interactionSchemaTemplate,
                this.projectScopeTemplate,
                `<M5. organized artifacts list>\n${masterArtifactListContent}\n</M5. organized artifacts list>`,
                cyclesContent,
                `<M7. Flattened Repo>\n${flattenedContent}\n</M7. Flattened Repo>`,
                `</prompt.md>`
            ];

            const finalPrompt = promptParts.join('\n\n');

            await fs.writeFile(promptMdPath, finalPrompt, 'utf-8');
            vscode.window.showInformationMessage(`Successfully generated prompt.md.`);
            Services.loggerService.log("Successfully generated prompt.md file.");

        } catch (error: any) {
            let errorMessage = `Failed to generate prompt.md: ${error.message}`;
            if (error.code === 'ENOENT' && error.path?.includes('flattened_repo.md')) {
                errorMessage = "Failed to generate prompt.md: 'flattened_repo.md' not found. Please flatten context first.";
            }
            vscode.window.showErrorMessage(errorMessage);
            Services.loggerService.error(errorMessage);
        }
    }
}
</file>

<file path="src/backend/services/selection.service.ts">
import * as vscode from 'vscode';
import { getContext } from '@/extension';
import { Services } from './services';
import * as fs from 'fs/promises';

const SELECTION_SETS_KEY = 'dce.selectionSets';
const LAST_SELECTION_KEY = 'dce.lastSelection';
const AUTO_ADD_STATE_KEY = 'dce.autoAddState';


export interface SelectionSet {
    [name: string]: string[];
}

export class SelectionService {
    
    private get context(): vscode.ExtensionContext {
        return getContext();
    }

    // --- Named Selection Sets ---

    public getSelectionSets(): SelectionSet {
        return this.context.workspaceState.get<SelectionSet>(SELECTION_SETS_KEY, {});
    }

    public async saveSelectionSet(name: string, paths: string[]): Promise<void> {
        if (!name) {
            vscode.window.showErrorMessage("Selection set name cannot be empty.");
            return;
        }
        const sets = this.getSelectionSets();
        sets[name] = paths;
        await this.context.workspaceState.update(SELECTION_SETS_KEY, sets);
        Services.loggerService.log(`Selection set '${name}' saved with ${paths.length} paths.`);
        vscode.window.showInformationMessage(`Selection set '${name}' saved.`);
    }

    public async deleteSelectionSet(name: string): Promise<void> {
        const sets = this.getSelectionSets();
        if (sets[name]) {
            delete sets[name];
            await this.context.workspaceState.update(SELECTION_SETS_KEY, sets);
            Services.loggerService.log(`Selection set '${name}' deleted.`);
            vscode.window.showInformationMessage(`Selection set '${name}' deleted.`);
        }
    }

    // --- Persistent Current Selection ---

    public async getLastSelection(): Promise<string[]> {
        const savedPaths = this.context.workspaceState.get<string[]>(LAST_SELECTION_KEY, []);
        if (savedPaths.length === 0) {
            Services.loggerService.log("[SelectionService] No last selection found in state.");
            return [];
        }
    
        Services.loggerService.log(`[SelectionService] Found ${savedPaths.length} paths in persisted state. Validating...`);
        
        const validationPromises = savedPaths.map(path => 
            fs.stat(path).then(() => ({ path, valid: true })).catch(() => ({ path, valid: false }))
        );
    
        const results = await Promise.all(validationPromises);
    
        const validPaths = results.filter(r => r.valid).map(r => r.path);
        const invalidPaths = results.filter(r => !r.valid).map(r => r.path);
    
        if (invalidPaths.length > 0) {
            Services.loggerService.warn(`[SelectionService] Removing ${invalidPaths.length} invalid paths from persisted state: ${invalidPaths.join(', ')}`);
            // Self-heal the state by saving only the valid paths
            await this.saveCurrentSelection(validPaths);
        }
    
        Services.loggerService.log(`[SelectionService] Returning ${validPaths.length} valid paths.`);
        return validPaths;
    }

    public async saveCurrentSelection(paths: string[]): Promise<void> {
        await this.context.workspaceState.update(LAST_SELECTION_KEY, paths);
        Services.loggerService.log(`Persisted current selection of ${paths.length} items.`);
    }

    // --- Path Manipulation for File Moves ---
    public async updatePathInSelections(oldPath: string, newPath: string): Promise<void> {
        Services.loggerService.log(`Updating path in selections: ${oldPath} -> ${newPath}`);

        // Update last active selection
        const lastSelection = await this.getLastSelection();
        const updatedLastSelection = this.updatePathsInList(lastSelection, oldPath, newPath);
        await this.saveCurrentSelection(updatedLastSelection);

        // Update all named selection sets
        const allSets = this.getSelectionSets();
        let setsUpdated = false;
        for (const setName in allSets) {
            const updatedSet = this.updatePathsInList(allSets[setName], oldPath, newPath);
            if (updatedSet.length !== allSets[setName].length || updatedSet.some((p, i) => p !== allSets[setName][i])) {
                allSets[setName] = updatedSet;
                setsUpdated = true;
            }
        }
        if (setsUpdated) {
            await this.context.workspaceState.update(SELECTION_SETS_KEY, allSets);
            Services.loggerService.log(`Updated paths in named selection sets.`);
        }
    }

    private updatePathsInList(paths: string[], oldPath: string, newPath: string): string[] {
        return paths.map(p => {
            if (p === oldPath) {
                return newPath; // Exact match
            }
            if (p.startsWith(oldPath + '/')) {
                // Descendant path
                return newPath + p.substring(oldPath.length);
            }
            return p;
        });
    }


    // --- Auto-Add New Files State ---

    public getAutoAddState(): boolean {
        return this.context.workspaceState.get<boolean>(AUTO_ADD_STATE_KEY, false);
    }

    public async saveAutoAddState(enabled: boolean): Promise<void> {
        await this.context.workspaceState.update(AUTO_ADD_STATE_KEY, enabled);
        Services.loggerService.log(`Auto-add new files state saved: ${enabled}.`);
    }
}
</file>

<file path="src/backend/services/services.ts">
import "reflect-metadata";
import { FlattenerService } from "./flattener.service";
import { SelectionService } from "./selection.service";
import { LoggerService } from "./logger.service";
import { ActionService } from "./action.service";
import { HistoryService } from "./history.service";
import { PromptService } from "./prompt.service";
import { API as GitAPI } from "../types/git";
import { FileTreeService } from "./file-tree.service";
import { FileOperationService } from "./file-operation.service";
import { ContentExtractionService } from "./content-extraction.service";
import { HighlightingService } from "./highlighting.service";

class ServiceContainer {
    public fileTreeService!: FileTreeService;
    public fileOperationService = new FileOperationService();
    public contentExtractionService = new ContentExtractionService();
    public highlightingService = new HighlightingService();
    
    public flattenerService = new FlattenerService();
    public selectionService = new SelectionService();
    public loggerService = LoggerService.getInstance();
    public actionService = new ActionService();
    public historyService = new HistoryService();
    public promptService = new PromptService();
    
    public initialize(gitApi?: GitAPI) {
        this.loggerService.log("Services initializing...");
        this.fileTreeService = new FileTreeService(gitApi);
        this.fileTreeService.initializeWatcher();
        this.loggerService.log("Services initialized successfully.");
    }
}

export const Services = new ServiceContainer();
</file>

<file path="src/backend/types/git.ts">
// This file is a placeholder for the complex types from the vscode.git extension API.
// It helps with type safety in our code without needing the full extension as a dev dependency.

import * as vscode from 'vscode';

export interface GitExtension {
    getAPI(version: 1): API;
}

export interface API {
    readonly state: 'uninitialized' | 'initialized';
    readonly onDidOpenRepository: vscode.Event<Repository>;
    readonly onDidCloseRepository: vscode.Event<Repository>;
    readonly repositories: Repository[];
}

export interface Repository {
    readonly rootUri: vscode.Uri;
    readonly state: RepositoryState;
}

export interface RepositoryState {
    readonly HEAD: Branch | undefined;
    readonly workingTreeChanges: Change[];
    readonly indexChanges: Change[];
    readonly mergeChanges: Change[];
    readonly untrackedChanges: vscode.Uri[]; // This is not in the official API, but we use it conceptually
    readonly onDidChange: vscode.Event<void>;
}

export interface Change {
    readonly uri: vscode.Uri;
    readonly originalUri: vscode.Uri;
    readonly renameUri: vscode.Uri | undefined;
    readonly status: Status;
}

export interface Branch {
    readonly type: RefType;
    readonly name?: string;
    readonly commit?: string;
    readonly upstream?: Upstream;
}

export interface Upstream {
    readonly remote: string;
    readonly name: string;
}

export const enum RefType {
    Head,
    RemoteHead,
    Tag
}

export const enum Status {
    INDEX_MODIFIED,
    INDEX_ADDED,
    INDEX_DELETED,
    INDEX_RENAMED,
    INDEX_COPIED,

    MODIFIED,
    DELETED,
    UNTRACKED,
    IGNORED,
    INTENT_TO_ADD,

    ADDED_BY_US,
    ADDED_BY_THEM,
    DELETED_BY_US,
    DELETED_BY_THEM,
    MODIFIED_BY_US,
    MODIFIED_BY_THEM,

    CONFLICT, // Both Added
    BOTH_DELETED, // Both Deleted
    BOTH_MODIFIED, // Both Modified
}
</file>

<file path="src/client/components/Checkbox.tsx">
import React from "react";
import { useEffect, useRef } from "react";

interface CheckboxProps extends Omit<React.DetailedHTMLProps<React.InputHTMLAttributes<HTMLInputElement>, HTMLInputElement>, 'onChange'> {
    checked: boolean;
    indeterminate?: boolean;
    onChange: (checked: boolean, event: React.ChangeEvent<HTMLInputElement>) => void;
}

const Checkbox = (props: CheckboxProps) => {
    const { checked, onChange, indeterminate, ...rest } = props;
    const cRef = useRef<any>(null);

    useEffect(() => {
        if (cRef.current) {
            cRef.current.indeterminate = indeterminate;
        }
    }, [cRef, indeterminate]);

    return (
        <input type="checkbox" ref={cRef} checked={checked} onChange={(e) => onChange(e.target.checked, e)} {...rest} />
    );
};

export default Checkbox;
</file>

<file path="src/client/components/ContextMenu.tsx">
import React, { useEffect, useRef } from 'react';
import { FileNode } from '@/common/types/file-node';
import { ClientPostMessageManager } from '@/common/ipc/client-ipc';
import { ClientToServerChannel } from '@/common/ipc/channels.enum';

interface ContextMenuProps {
    menu: { x: number; y: number; node: FileNode };
    onClose: () => void;
    onRename: () => void;
}

const ContextMenu: React.FC<ContextMenuProps> = ({ menu, onClose, onRename }) => {
    const menuRef = useRef<HTMLDivElement>(null);
    const clientIpc = ClientPostMessageManager.getInstance();

    useEffect(() => {
        const handleClickOutside = (event: MouseEvent) => {
            if (menuRef.current && !menuRef.current.contains(event.target as Node)) {
                onClose();
            }
        };
        document.addEventListener('mousedown', handleClickOutside);
        return () => {
            document.removeEventListener('mousedown', handleClickOutside);
        };
    }, [onClose]);

    const handleAction = (action: () => void) => {
        action();
        onClose();
    };
    
    const { node } = menu;
    const isDirectory = !!node.children;

    const getParentDirectory = () => {
        if (isDirectory) {
            return node.absolutePath;
        }
        // For files, get the parent directory by splitting the path.
        const parts = node.absolutePath.split('/');
        parts.pop();
        return parts.join('/');
    };

    return (
        <>
            <div className="context-menu-overlay" onClick={onClose}></div>
            <div ref={menuRef} className="context-menu" style={{ top: menu.y, left: menu.x }}>
                <ul>
                    <li onClick={() => handleAction(() => clientIpc.sendToServer(ClientToServerChannel.RequestNewFile, { parentDirectory: getParentDirectory() }))}>New File...</li>
                    <li onClick={() => handleAction(() => clientIpc.sendToServer(ClientToServerChannel.RequestNewFolder, { parentDirectory: getParentDirectory() }))}>New Folder...</li>
                    <hr />
                    <li onClick={() => handleAction(() => onRename())}>Rename</li>
                    <li onClick={() => handleAction(() => clientIpc.sendToServer(ClientToServerChannel.RequestFileDelete, { path: node.absolutePath }))}>Delete</li>
                    <hr />
                    <li onClick={() => handleAction(() => clientIpc.sendToServer(ClientToServerChannel.RequestCopyPath, { path: node.absolutePath, relative: false }))}>Copy Path</li>
                    <li onClick={() => handleAction(() => clientIpc.sendToServer(ClientToServerChannel.RequestCopyPath, { path: node.absolutePath, relative: true }))}>Copy Relative Path</li>
                    <hr />
                    <li onClick={() => handleAction(() => clientIpc.sendToServer(ClientToServerChannel.RequestRevealInExplorer, { path: node.absolutePath }))}>Reveal in File Explorer</li>
                </ul>
            </div>
        </>
    );
};

export default ContextMenu;
</file>

<file path="src/client/components/DiffViewer.tsx">
// Updated on: C129 (Vertical layout, fixed panes, block highlight, buttons below)
import * as React from 'react';
import { diffArrays, diffChars } from 'diff';
import { VscArrowUp, VscArrowDown } from 'react-icons/vsc';

interface DiffLine {
    type: 'added' | 'removed' | 'common' | 'placeholder';
    content?: string;
}

interface PairedLine {
    left: DiffLine & { lineNum?: number };
    right: DiffLine & { lineNum?: number };
    isDiff: boolean;
}

interface DiffBlock {
    start: number;
    end: number;
}

const DiffViewer: React.FC<{ original: { content: string, path: string }, modified: { content: string, path: string } }> = ({ original, modified }) => {
    const [selectedDiffIndex, setSelectedDiffIndex] = React.useState<number>(0);
    const diffLineRefs = React.useRef<Map<number, HTMLDivElement>>(new Map());

    const { pairedLines, diffBlocks } = React.useMemo(() => {
        const originalLines = original.content.split('\n');
        const modifiedLines = modified.content.split('\n');
        const changes = diffArrays(originalLines, modifiedLines);
        
        const result: PairedLine[] = [];
        const diffBlockIndices: DiffBlock[] = [];
        let leftLineNum = 1;
        let rightLineNum = 1;

        changes.forEach(change => {
            if (change.added || change.removed) {
                const blockStart = result.length;
                if (change.added) {
                    change.value.forEach(line => {
                        result.push({ left: { type: 'placeholder' }, right: { type: 'added', content: line, lineNum: rightLineNum++ }, isDiff: true });
                    });
                } else if (change.removed) {
                    change.value.forEach(line => {
                        result.push({ left: { type: 'removed', content: line, lineNum: leftLineNum++ }, right: { type: 'placeholder' }, isDiff: true });
                    });
                }
                diffBlockIndices.push({ start: blockStart, end: result.length - 1 });
            } else {
                change.value.forEach(line => {
                    result.push({ left: { type: 'common', content: line, lineNum: leftLineNum++ }, right: { type: 'common', content: line, lineNum: rightLineNum++ }, isDiff: false });
                });
            }
        });
        return { pairedLines: result, diffBlocks: diffBlockIndices };
    }, [original.content, modified.content]);

    const goToDiff = (index: number) => {
        if (index >= 0 && index < diffBlocks.length) {
            setSelectedDiffIndex(index);
            const lineIndex = diffBlocks[index].start;
            diffLineRefs.current.get(lineIndex)?.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
    };

    const isLineInSelectedBlock = (lineIndex: number): boolean => {
        if (diffBlocks.length === 0) return false;
        const currentDiff = diffBlocks[selectedDiffIndex];
        return lineIndex >= currentDiff.start && lineIndex <= currentDiff.end;
    };

    const renderCharDiff = (originalText: string, modifiedText: string) => {
        const charChanges = diffChars(originalText, modifiedText);
        const leftSpans: React.ReactNode[] = [];
        const rightSpans: React.ReactNode[] = [];

        charChanges.forEach((part, index) => {
            const key = `char-${index}`;
            const className = part.added ? 'char-added' : part.removed ? 'char-removed' : '';
            if (part.added) {
                rightSpans.push(<span key={key} className={className}>{part.value}</span>);
            } else if (part.removed) {
                leftSpans.push(<span key={key} className={className}>{part.value}</span>);
            } else {
                leftSpans.push(<span key={key}>{part.value}</span>);
                rightSpans.push(<span key={key}>{part.value}</span>);
            }
        });
        return { left: <>{leftSpans}</>, right: <>{rightSpans}</> };
    };

    const selectedDiffContent = React.useMemo(() => {
        if (diffBlocks.length === 0) return { left: [], right: [] };
        const block = diffBlocks[selectedDiffIndex];
        const blockLines = pairedLines.slice(block.start, block.end + 1);
        
        const originalLines = blockLines.map(l => l.left.content).filter(Boolean) as string[];
        const modifiedLines = blockLines.map(l => l.right.content).filter(Boolean) as string[];

        return renderCharDiff(originalLines.join('\n'), modifiedLines.join('\n'));
    }, [selectedDiffIndex, pairedLines, diffBlocks]);

    return (
        <div className="diff-viewer-wrapper">
            <div className="diff-viewer-main-container">
                {/* Original Pane (Top) */}
                <div className="diff-pane-header">Original: {original.path}</div>
                <div className="diff-pane">
                    <div className="line-numbers">{pairedLines.map((line, i) => <span key={`L${i}`}>{line.left.lineNum || ' '}</span>)}</div>
                    <div className="diff-lines">
                        {pairedLines.map((line, i) => (
                             <div key={`L${i}`} className={`line ${line.left.type}`} ref={ref => { if (ref) diffLineRefs.current.set(i, ref); }}>
                                <pre><code>{line.left.content || ''}</code></pre>
                             </div>
                        ))}
                    </div>
                </div>
                {/* Modified Pane (Bottom) */}
                <div className="diff-pane-header">Response: {modified.path}</div>
                <div className="diff-pane">
                    <div className="line-numbers">{pairedLines.map((line, i) => <span key={`R${i}`}>{line.right.lineNum || ' '}</span>)}</div>
                    <div className="diff-lines">
                         {pairedLines.map((line, i) => (
                             <div key={`R${i}`} className={`line ${line.right.type}`}>
                                 <pre><code>{line.right.content || ''}</code></pre>
                             </div>
                         ))}
                    </div>
                </div>
            </div>
            <div className="diff-detail-container">
                <div className="diff-detail-header">
                    <span>Difference {diffBlocks.length > 0 ? selectedDiffIndex + 1 : 0} of {diffBlocks.length}</span>
                    <div className="diff-nav-buttons">
                        <button onClick={() => goToDiff(selectedDiffIndex - 1)} disabled={selectedDiffIndex <= 0}><VscArrowUp /> Prev</button>
                        <button onClick={() => goToDiff(selectedDiffIndex + 1)} disabled={selectedDiffIndex >= diffBlocks.length - 1}><VscArrowDown /> Next</button>
                    </div>
                </div>
                <div className="diff-detail-panes">
                    <div className="diff-detail-pane removed"><pre><code>{selectedDiffContent.left}</code></pre></div>
                    <div className="diff-detail-pane added"><pre><code>{selectedDiffContent.right}</code></pre></div>
                </div>
            </div>
        </div>
    );
};

export default DiffViewer;
</file>

<file path="src/client/components/file-tree/FileTree.tsx">
import React, { useState, useMemo } from 'react';
import TreeView, { TreeNode } from '../tree-view/TreeView';
import { FileNode } from '@/common/types/file-node';
import Checkbox from '../Checkbox';
import {
    VscFile, VscFolder, VscFolderOpened, VscJson, VscMarkdown, VscSymbolFile, VscSymbolNumeric, VscFiles, VscError, VscWarning, VscTable
} from 'react-icons/vsc';
import { SiTypescript, SiReact, SiJavascript, SiSass } from 'react-icons/si';
import { FaFileWord } from 'react-icons/fa';
import { formatLargeNumber, formatBytes, formatNumberWithCommas } from '@/common/utils/formatting';
import ContextMenu from '../ContextMenu';
import { ClientPostMessageManager } from '@/common/ipc/client-ipc';
import { ClientToServerChannel } from '@/common/ipc/channels.enum';
import { ProblemCountsMap } from '@/common/ipc/channels.type';
import { logger } from '@/client/utils/logger';

interface FileTreeProps {
  data: FileNode[];
  checkedFiles: string[];
  activeFile?: string;
  updateCheckedFiles: (path: string) => void;
  collapseTrigger?: number;
  expandAllTrigger?: number;
  searchTerm: string;
  problemMap: ProblemCountsMap;
  onNodeDrop?: (event: React.DragEvent, node: FileNode) => void;
  onCopy: (path: string) => void;
  clipboard: { path: string; type: 'copy' } | null;
}

const getFileIcon = (fileName: string) => {
    const extension = fileName.split('.').pop()?.toLowerCase();
    switch (extension) {
        case 'ts': return <SiTypescript color="#3178C6" />;
        case 'tsx': return <SiReact color="#61DAFB" />;
        case 'js': return <SiJavascript color="#F7DF1E" />;
        case 'json': return <VscJson color="#F7DF1E" />;
        case 'md': return <VscMarkdown />;
        case 'scss': case 'css': return <SiSass color="#CF649A"/>;
        case 'svg': case 'png': case 'jpg': case 'jpeg': case 'ico': case 'webp': return <VscSymbolFile />;
        case 'xlsx': case 'xls': case 'csv': return <VscTable color="#217346" />;
        case 'docx': return <FaFileWord color="#2B579A" />;
        default: return <VscFile />;
    }
};

const getGitStatusTooltip = (status?: string): string => {
    switch (status) {
        case 'M': return 'Modified';
        case 'U': return 'Untracked';
        case 'A': return 'Added';
        case 'D': return 'Deleted';
        case 'C': return 'Conflicted';
        case 'I': return 'Ignored';
        default: return 'Git Status';
    }
};

const filterTree = (nodes: FileNode[], term: string): FileNode[] => {
    if (!term) return nodes;
    const lowerCaseTerm = term.toLowerCase();

    return nodes.reduce((acc, node) => {
        if (node.name.toLowerCase().includes(lowerCaseTerm)) {
            acc.push(node);
            return acc;
        }

        if (node.children) {
            const filteredChildren = filterTree(node.children, term);
            if (filteredChildren.length > 0) {
                acc.push({ ...node, children: filteredChildren });
            }
        }
        return acc;
    }, [] as FileNode[]);
};


const FileTree: React.FC<FileTreeProps> = ({ data, checkedFiles, activeFile, updateCheckedFiles, collapseTrigger, expandAllTrigger, searchTerm, problemMap, onNodeDrop, onCopy, clipboard }) => {
    const [contextMenu, setContextMenu] = useState<{ x: number, y: number, node: FileNode } | null>(null);
    const [renamingPath, setRenamingPath] = useState<string | null>(null);
    const [renameValue, setRenameValue] = useState('');
    const clientIpc = ClientPostMessageManager.getInstance();

    const filteredData = useMemo(() => filterTree(data, searchTerm), [data, searchTerm]);

    const handleFileCheckboxChange = (e: React.ChangeEvent<HTMLInputElement>, filePath: string) => {
        e.stopPropagation();
        updateCheckedFiles(filePath);
    };

    const handleContextMenu = (event: React.MouseEvent, node: FileNode) => {
        event.preventDefault();
        event.stopPropagation();
        setContextMenu({ x: event.clientX, y: event.clientY, node });
    };

    const handleRename = () => {
        if (contextMenu) {
            setRenamingPath(contextMenu.node.absolutePath);
            setRenameValue(contextMenu.node.name);
            setContextMenu(null);
        }
    };

    const handleRenameSubmit = () => {
        if (renamingPath && renameValue) {
            clientIpc.sendToServer(ClientToServerChannel.RequestFileRename, { oldPath: renamingPath, newName: renameValue });
        }
        setRenamingPath(null);
    };
    
    const calculateCheckedTokens = useMemo(() => {
        const checkedSet = new Set(checkedFiles);
        const memo = new Map<string, number>();

        const calculate = (node: FileNode): number => {
            if (memo.has(node.absolutePath)) {
                return memo.get(node.absolutePath)!;
            }

            if (checkedSet.has(node.absolutePath)) {
                memo.set(node.absolutePath, node.tokenCount);
                return node.tokenCount;
            }
            
            for (const checkedPath of checkedSet) {
                if (node.absolutePath.startsWith(checkedPath + '/')) {
                    memo.set(node.absolutePath, node.tokenCount);
                    return node.tokenCount;
                }
            }

            if (!node.children) {
                const result = checkedSet.has(node.absolutePath) ? node.tokenCount : 0;
                memo.set(node.absolutePath, result);
                return result;
            }
    
            const result = node.children.reduce((acc, child) => acc + calculate(child), 0);
            memo.set(node.absolutePath, result);
            return result;
        };
        return calculate;
    }, [checkedFiles]);

    const renderFileNodeContent = (node: TreeNode, isExpanded: boolean) => {
        const fileNode = node as FileNode;
        const isDirectory = Array.isArray(fileNode.children);
        
        const hasCheckedAncestor = checkedFiles.some(ancestor => fileNode.absolutePath.startsWith(ancestor + '/') && fileNode.absolutePath !== ancestor);
        const isDirectlyChecked = checkedFiles.includes(fileNode.absolutePath);
        const isChecked = isDirectlyChecked || hasCheckedAncestor;

        if (renamingPath === fileNode.absolutePath) {
            return (
                <input
                    type="text"
                    value={renameValue}
                    onChange={(e) => setRenameValue(e.target.value)}
                    onBlur={handleRenameSubmit}
                    onKeyDown={(e) => {
                        if (e.key === 'Enter') handleRenameSubmit();
                        // Stop propagation for text editing shortcuts
                        if ((e.ctrlKey || e.metaKey) && ['c', 'v', 'x'].includes(e.key.toLowerCase())) {
                            e.stopPropagation();
                        }
                    }}
                    autoFocus
                    className="rename-input"
                />
            );
        }

        const checkedTokensInDir = isDirectory ? calculateCheckedTokens(fileNode) : 0;
        const isFullyChecked = isDirectory && checkedTokensInDir > 0 && checkedTokensInDir === fileNode.tokenCount;
        
        const liveProblems = problemMap[fileNode.absolutePath];
        const problemData = liveProblems || fileNode.problemCounts;

        const problemErrorCount = problemData?.error || 0;
        const problemWarningCount = problemData?.warning || 0;
        const hasProblems = problemErrorCount > 0 || problemWarningCount > 0;
        const problemColorClass = problemErrorCount > 0 ? 'problem-error' : 'problem-warning';
        const problemTooltip = `${problemErrorCount} Errors, ${problemWarningCount} Warnings`;
        const hasError = !!fileNode.error;

        const renderTokenCount = () => {
            if (hasError) {
                return <span>---</span>;
            }
            if (fileNode.isImage) {
                return <span>{formatBytes(fileNode.sizeInBytes)}</span>;
            }
            if (fileNode.tokenCount > 0) {
                let content;
                if (isDirectory) {
                    if (isFullyChecked) {
                        content = `(${formatLargeNumber(fileNode.tokenCount, 1)})`;
                    } else if (checkedTokensInDir > 0) {
                        content = <>{formatLargeNumber(fileNode.tokenCount, 1)} <span className="selected-token-count">({formatLargeNumber(checkedTokensInDir, 1)})</span></>;
                    } else {
                        content = formatLargeNumber(fileNode.tokenCount, 1);
                    }
                } else { // It's a file
                    content = isChecked ? `(${formatLargeNumber(fileNode.tokenCount, 1)})` : formatLargeNumber(fileNode.tokenCount, 1);
                }
                return <><VscSymbolNumeric /> <span>{content}</span></>;
            }
            return null;
        };

        const gitStatusClass = fileNode.gitStatus ? `git-status-${fileNode.gitStatus}` : '';

        return (
            <div className={`file-item ${gitStatusClass} ${hasProblems ? problemColorClass : ''} ${hasError ? 'has-error' : ''}`} title={fileNode.error}>
                <Checkbox
                    className="file-checkbox"
                    checked={isChecked}
                    indeterminate={!isDirectlyChecked && !hasCheckedAncestor && checkedFiles.some(p => p.startsWith(fileNode.absolutePath))}
                    onChange={(_, e) => handleFileCheckboxChange(e, fileNode.absolutePath)}
                    disabled={hasError}
                />
                <span className="file-icon">{isDirectory ? (isExpanded ? <VscFolderOpened /> : <VscFolder />) : getFileIcon(fileNode.name)}</span>
                <span className="file-name">{fileNode.name}</span>
                <div className="file-stats">
                    {hasError && <span className="error-icon" title={fileNode.error}><VscError/></span>}
                    {fileNode.gitStatus && <span className="git-status-badge" title={getGitStatusTooltip(fileNode.gitStatus)}>{fileNode.gitStatus}</span>}
                    {hasProblems && (
                        <span className="problem-badge" title={problemTooltip}>
                            {problemErrorCount > 0 && <span className='error-icon'><VscError/> {problemErrorCount}</span>}
                            {problemWarningCount > 0 && <span className='warning-icon'><VscWarning/> {problemWarningCount}</span>}
                        </span>
                    )}
                    {isDirectory && fileNode.fileCount > 0 && (<> <VscFiles /> <span>{formatNumberWithCommas(fileNode.fileCount)}</span> </>)}
                    {renderTokenCount()}
                </div>
            </div>
        );
    };

    return (
        <div className="file-tree">
            <TreeView 
                data={filteredData as TreeNode[]} 
                renderNodeContent={(node, isExpanded) => renderFileNodeContent(node, isExpanded as boolean)} 
                onContextMenu={(e, node) => handleContextMenu(e, node as FileNode)} 
                collapseTrigger={collapseTrigger}
                expandAllTrigger={expandAllTrigger}
                activeFile={activeFile} 
                updateCheckedFiles={updateCheckedFiles}
                onNodeDrop={(e, node) => onNodeDrop?.(e, node as FileNode)}
                onCopy={onCopy}
                clipboard={clipboard}
            />
            {contextMenu && <ContextMenu menu={contextMenu} onClose={() => setContextMenu(null)} onRename={handleRename} />}
        </div>
    );
};

export default FileTree;
</file>

<file path="src/client/components/file-tree/FileTree.utils.ts">
import { FileNode } from "@/common/types/file-node";
import { logger } from "@/client/utils/logger";

function getAllDescendantPaths(node: FileNode, includeFilesOnly: boolean = false): string[] {
    let paths: string[] = [];
    if (node.children) {
        for (const child of node.children) {
            if (!includeFilesOnly || !child.children) {
                paths.push(child.absolutePath);
            }
            paths = paths.concat(getAllDescendantPaths(child, includeFilesOnly));
        }
    }
    return paths;
}

function findNode(node: FileNode, filePath: string): FileNode | null {
    if (node.absolutePath === filePath) {
        return node;
    }

    if (node.children && filePath.startsWith(node.absolutePath + '/')) {
        for (const child of node.children) {
            const found = findNode(child, filePath);
            if(found) return found;
        }
    }
    return null;
}

export const getFileNodeByPath = (
  fileNodes: FileNode[],
  filePath: string
): FileNode | null => {
    for (const rootNode of fileNodes) {
        const found = findNode(rootNode, filePath);
        if (found) return found;
    }
    return null;
};

export const addRemovePathInSelectedFiles = (
  fileTree: FileNode[],
  path: string,
  selectedFiles: string[]
): string[] => {
    logger.log(`[Selection] Toggling path: ${path}`);
    const node = getFileNodeByPath(fileTree, path);
    if (!node) {
        logger.error(`[Selection] Node not found for path: ${path}`);
        return selectedFiles;
    }

    const currentSelection = new Set(selectedFiles);
    const isDirectlySelected = currentSelection.has(path);
    const selectedAncestor = selectedFiles.find(ancestor => path.startsWith(ancestor + '/') && path !== ancestor);

    const isEffectivelySelected = isDirectlySelected || !!selectedAncestor;
    logger.log(`[Selection] isDirectlySelected: ${isDirectlySelected}, hasSelectedAncestor: ${!!selectedAncestor}`);

    if (isEffectivelySelected) {
        // --- UNCHECKING ---
        logger.log(`[Selection] Unchecking logic initiated.`);
        if (selectedAncestor) {
            logger.log(`[Selection] Performing 'subtractive uncheck'. Ancestor: ${selectedAncestor}`);
            // A child of a selected folder is being unchecked. This is the BUGGY part.
            const ancestorNode = getFileNodeByPath(fileTree, selectedAncestor);
            if (!ancestorNode) return selectedFiles;

            // 1. Remove the ancestor from the selection.
            currentSelection.delete(selectedAncestor);
            
            // 2. Get ALL descendant files of the ancestor.
            const allDescendantFiles = getAllDescendantPaths(ancestorNode, true);

            // 3. Add all descendants back, EXCEPT for the one that was unchecked.
            for (const file of allDescendantFiles) {
                if (file !== path) {
                    currentSelection.add(file);
                }
            }

        } else {
            // A directly selected item is being unchecked. Remove it.
            logger.log(`[Selection] Unchecking directly selected item: ${path}`);
            currentSelection.delete(path);
        }
    } else {
        // --- CHECKING ---
        logger.log(`[Selection] Checking logic initiated.`);
        // Remove any descendants that are already selected, as the new parent selection covers them.
        const newSelection = new Set<string>();
        for (const p of currentSelection) {
            if (!p.startsWith(path + '/')) {
                newSelection.add(p);
            } else {
                logger.log(`[Selection] Removing descendant '${p}' because parent '${path}' is being checked.`);
            }
        }
        newSelection.add(path);
        return Array.from(newSelection);
    }
  
  const finalSelection = Array.from(currentSelection);
  logger.log(`[Selection] Final selection count: ${finalSelection.length}`);
  return finalSelection;
};

export const removePathsFromSelected = (
    pathsToRemove: string[],
    currentSelectedFiles: string[],
    fileTree: FileNode[]
): string[] => {
    logger.log(`[Batch Remove] Starting removal of ${pathsToRemove.length} paths.`);
    if (pathsToRemove.length === 0) return currentSelectedFiles;

    const fileMap = new Map<string, FileNode>();
    const buildMap = (node: FileNode) => {
        fileMap.set(node.absolutePath, node);
        node.children?.forEach(buildMap);
    };
    fileTree.forEach(buildMap);

    // 1. Get the full set of all individual files that are currently selected.
    const effectiveFileSelection = new Set<string>();
    for (const selectedPath of currentSelectedFiles) {
        const node = fileMap.get(selectedPath);
        if (node) {
            if (node.children) { // It's a directory
                getAllDescendantPaths(node, true).forEach(file => effectiveFileSelection.add(file));
            } else { // It's a file
                effectiveFileSelection.add(selectedPath);
            }
        }
    }
    logger.log(`[Batch Remove] Expanded initial selection to ${effectiveFileSelection.size} effective files.`);

    // 2. Remove the unwanted files from this effective set.
    for (const pathToRemove of pathsToRemove) {
        const nodeToRemove = fileMap.get(pathToRemove);
        if (nodeToRemove) {
            if (nodeToRemove.children) { // It's a directory
                getAllDescendantPaths(nodeToRemove, true).forEach(file => effectiveFileSelection.delete(file));
            } else { // It's a file
                effectiveFileSelection.delete(pathToRemove);
            }
        }
    }
    logger.log(`[Batch Remove] After removal, ${effectiveFileSelection.size} files remain.`);


    // 3. Compress the remaining set of files into the most efficient list of paths (folders + files).
    const finalPaths = new Set<string>();
    const checkedForCompression = new Set<string>();

    const compress = (node: FileNode) => {
        if (!node.children || checkedForCompression.has(node.absolutePath)) {
            return;
        }

        const descendantFiles = getAllDescendantPaths(node, true);
        if (descendantFiles.length === 0) {
            return; // Don't add empty folders
        }

        const allDescendantsSelected = descendantFiles.every(file => effectiveFileSelection.has(file));

        if (allDescendantsSelected) {
            finalPaths.add(node.absolutePath);
            // Mark all descendants as handled by this compression
            descendantFiles.forEach(file => checkedForCompression.add(file));
        } else {
            // Recurse to children if not all are selected
            node.children.forEach(compress);
        }
    };

    fileTree.forEach(compress);

    // Add any remaining files that were not part of a compressed folder
    for (const file of effectiveFileSelection) {
        if (!checkedForCompression.has(file)) {
            finalPaths.add(file);
        }
    }
    
    logger.log(`[Batch Remove] Compressed final selection to ${finalPaths.size} paths.`);
    return Array.from(finalPaths);
};
</file>

<file path="src/client/components/SelectedFilesView.tsx">
import * as React from 'react';
import { useState, useMemo, useRef, useEffect } from 'react';
import { FileNode } from '@/common/types/file-node';
import { VscChevronUp, VscChevronDown, VscSymbolFile, VscSymbolNumeric, VscTypeHierarchy, VscClose, VscChevronRight, VscChevronLeft } from 'react-icons/vsc';
import { formatLargeNumber } from '@/common/utils/formatting';
import { SiReact, SiSass, SiTypescript, SiJavascript } from 'react-icons/si';
import { VscFile, VscJson, VscMarkdown, VscTable } from 'react-icons/vsc';
import { logger } from '../utils/logger';
import { ClientPostMessageManager } from '@/common/ipc/client-ipc';
import { ClientToServerChannel } from '@/common/ipc/channels.enum';
import { FaFileWord } from 'react-icons/fa';

type SortableColumn = 'name' | 'tokenCount' | 'extension';
type SortDirection = 'asc' | 'desc';

const getFileIcon = (fileName: string) => {
    const extension = fileName.split('.').pop()?.toLowerCase();
    switch (extension) {
        case 'ts': return <SiTypescript color="#3178C6" />;
        case 'tsx': return <SiReact color="#61DAFB" />;
        case 'js': return <SiJavascript color="#F7DF1E" />;
        case 'json': return <VscJson color="#F7DF1E" />;
        case 'md': return <VscMarkdown />;
        case 'scss': case 'css': return <SiSass color="#CF649A"/>;
        case 'xlsx': case 'xls': case 'csv': return <VscTable color="#217346" />;
        case 'docx': return <FaFileWord color="#2B579A" />;
        default: return <VscFile />;
    }
};

const getTokenBackgroundColor = (tokenCount: number): string => {
    // 0 - 8k: green
    if (tokenCount <= 8000) return 'hsla(120, 60%, 50%, 0.1)';
    // 8k - 10k: green to yellow
    if (tokenCount <= 10000) {
        const percentage = (tokenCount - 8000) / 2000;
        const hue = 120 - (percentage * 60); // 120 (green) -> 60 (yellow)
        return `hsla(${hue}, 70%, 50%, 0.15)`;
    }
    // 10k - 12k: yellow to orange
    if (tokenCount <= 12000) {
        const percentage = (tokenCount - 10000) / 2000;
        const hue = 60 - (percentage * 30); // 60 (yellow) -> 30 (orange)
        return `hsla(${hue}, 80%, 50%, 0.2)`;
    }
    // 12k+: orange to red
    const percentage = Math.min((tokenCount - 12000) / 28000, 1.0); // Cap at 40k for max red
    const hue = 30 - (percentage * 30); // 30 (orange) -> 0 (red)
    return `hsla(${hue}, 80%, 50%, 0.25)`;
};

const getTokenRiskTooltip = (tokenCount: number): string => {
    if (tokenCount <= 8000) return 'Low token count, suitable for most workloads.';
    if (tokenCount <= 10000) return 'Slightly elevated token count, small chance of performance degradation.';
    if (tokenCount <= 12000) return 'Moderate token count, may impact performance on complex tasks.';
    return 'High token count, increased chance of performance degradation or truncation.';
};


interface SelectedFilesViewProps {
    selectedFileNodes: FileNode[];
    onRemove: (pathsToRemove: string[]) => void;
    isMinimized: boolean;
    onToggleMinimize: () => void;
}

const SelectedFilesView: React.FC<SelectedFilesViewProps> = ({ selectedFileNodes, onRemove, isMinimized, onToggleMinimize }) => {
    const [sortColumn, setSortColumn] = useState<SortableColumn>('tokenCount');
    const [sortDirection, setSortDirection] = useState<SortDirection>('desc');
    const [selection, setSelection] = useState<Set<string>>(new Set());
    const [hoveredPath, setHoveredPath] = useState<string | null>(null);
    const [contextMenu, setContextMenu] = useState<{ x: number; y: number } | null>(null);
    const firstClickedPath = useRef<string | null>(null); // Anchor for shift-click
    const listRef = useRef<HTMLUListElement>(null);
    const clientIpc = ClientPostMessageManager.getInstance();

    // Reset selection when the list of files changes
    useEffect(() => {
        setSelection(new Set());
    }, [selectedFileNodes]);

    const sortedFiles = useMemo(() => {
        return [...selectedFileNodes].sort((a, b) => {
            const dir = sortDirection === 'asc' ? 1 : -1;
            if (sortColumn === 'name') {
                return a.name.localeCompare(b.name, undefined, { numeric: true }) * dir;
            }
            if (sortColumn === 'extension') {
                const extA = a.extension || '';
                const extB = b.extension || '';
                if (extA !== extB) {
                    return extA.localeCompare(extB) * dir;
                }
                // Sub-sort by token count if extensions are the same
                return (b.tokenCount - a.tokenCount);
            }
            // Default and tokenCount sort
            return (a.tokenCount - b.tokenCount) * dir;
        });
    }, [selectedFileNodes, sortColumn, sortDirection]);

    const handleSort = (column: SortableColumn) => {
        if (column === sortColumn) {
            setSortDirection(prev => prev === 'asc' ? 'desc' : 'asc');
        } else {
            setSortColumn(column);
            setSortDirection(column === 'tokenCount' ? 'desc' : 'asc');
        }
    };

    const handleItemClick = (e: React.MouseEvent, path: string) => {
        if ((e.target as HTMLElement).closest('.quick-remove-icon')) {
            return;
        }
        
        const newSelection = new Set(selection);

        if (e.shiftKey && firstClickedPath.current) {
            const firstIdx = sortedFiles.findIndex(f => f.absolutePath === firstClickedPath.current);
            const currentIdx = sortedFiles.findIndex(f => f.absolutePath === path);
            const start = Math.min(firstIdx, currentIdx);
            const end = Math.max(firstIdx, currentIdx);
            
            if (!e.ctrlKey) newSelection.clear();

            for (let i = start; i <= end; i++) {
                newSelection.add(sortedFiles[i].absolutePath);
            }
        } else if (e.ctrlKey) {
            if (newSelection.has(path)) {
                newSelection.delete(path);
            } else {
                newSelection.add(path);
            }
            firstClickedPath.current = path; // Update anchor on ctrl-click
        } else {
            clientIpc.sendToServer(ClientToServerChannel.RequestOpenFile, { path });
            // C38 Fix: Re-focus the list after a delay to reclaim focus from the editor
            setTimeout(() => listRef.current?.focus(), 100);
            newSelection.clear();
            newSelection.add(path);
            firstClickedPath.current = path;
        }
        
        setSelection(newSelection);
    };
    
    const handleRemoveSelected = () => {
        logger.log(`"Remove selected" button clicked. Removing ${selection.size} items.`);
        onRemove(Array.from(selection));
        setSelection(new Set());
    };

    const handleKeyDown = (e: React.KeyboardEvent<HTMLUListElement>) => {
        switch (e.key) {
            case 'a':
                if (e.ctrlKey || e.metaKey) {
                    e.preventDefault();
                    e.stopPropagation();
                    logger.log('Ctrl+A detected in SelectedFilesView.');
                    const allPaths = new Set(sortedFiles.map(f => f.absolutePath));
                    setSelection(allPaths);
                }
                break;
            case 'Delete':
                e.preventDefault();
                e.stopPropagation();
                if (selection.size > 0) {
                    logger.log(`Delete key pressed. Removing ${selection.size} items.`);
                    handleRemoveSelected();
                }
                break;
        }
    };

    const handleContainerClick = () => {
        listRef.current?.focus();
    };

    const handleContextMenu = (event: React.MouseEvent) => {
        event.preventDefault();
        setContextMenu({ x: event.clientX, y: event.clientY });
    };

    const handleSelectAll = () => {
        const allPaths = new Set(sortedFiles.map(f => f.absolutePath));
        setSelection(allPaths);
        setContextMenu(null);
    };

    const handleDeselectAll = () => {
        setSelection(new Set());
        setContextMenu(null);
    };
    
    const SortIndicator = ({ column }: { column: SortableColumn }) => {
        if (sortColumn !== column) return null;
        return sortDirection === 'asc' ? <VscChevronUp /> : <VscChevronDown />;
    };

    return (
        <div className="selected-files-panel" onClick={handleContainerClick}>
            <div className="panel-header">
                <span>Selected Items ({selectedFileNodes.length})</span>
                <button onClick={onToggleMinimize} className="toolbar-button" title={isMinimized ? "Expand" : "Minimize"}>
                    {isMinimized ? <VscChevronRight /> : <VscChevronDown />}
                </button>
            </div>
            {!isMinimized && (
                <>
                    <div className="panel-toolbar">
                        <button onClick={handleRemoveSelected} disabled={selection.size === 0}>
                            Remove selected ({selection.size})
                        </button>
                    </div>
                    <div className="selected-files-list-container">
                        <div className="selected-list-header">
                            <div className="header-index">#</div>
                            <div className="header-type" onClick={() => handleSort('extension')} title="Sort by File Type">
                                <VscTypeHierarchy /> <SortIndicator column="extension" />
                            </div>
                            <div className="header-name" onClick={() => handleSort('name')}>
                                <VscSymbolFile /> File <SortIndicator column="name" />
                            </div>
                            <div className="header-tokens" onClick={() => handleSort('tokenCount')}>
                                <VscSymbolNumeric /> Tokens <SortIndicator column="tokenCount" />
                            </div>
                        </div>
                        <ul className="selected-files-list" ref={listRef} tabIndex={0} onKeyDown={handleKeyDown} onContextMenu={handleContextMenu}>
                            {sortedFiles.map((node, index) => (
                                <li key={node.absolutePath} 
                                    className={selection.has(node.absolutePath) ? 'selected' : ''}
                                    onClick={(e) => handleItemClick(e, node.absolutePath)}
                                    onMouseEnter={() => setHoveredPath(node.absolutePath)}
                                    onMouseLeave={() => setHoveredPath(null)}
                                    style={{ backgroundColor: node.isImage ? 'transparent' : getTokenBackgroundColor(node.tokenCount) }}
                                    title={node.isImage ? `Binary file: ${node.name}` : getTokenRiskTooltip(node.tokenCount)}
                                >
                                    <span className="file-index">
                                        {hoveredPath === node.absolutePath ? (
                                            <span 
                                                className="quick-remove-icon" 
                                                title="Remove from selection"
                                                onClick={(e) => { e.stopPropagation(); onRemove([node.absolutePath]); }}
                                            >
                                                <VscClose />
                                            </span>
                                        ) : (
                                            index + 1
                                        )}
                                    </span>
                                    <span className="file-icon">{getFileIcon(node.name)}</span>
                                    <span className="file-name" title={node.absolutePath}>{node.name}</span>
                                    <span className="file-tokens">{formatLargeNumber(node.tokenCount, 1)}</span>
                                </li>
                            ))}
                        </ul>
                    </div>
                </>
            )}
            {contextMenu && (
                 <>
                    <div className="context-menu-overlay" onClick={() => setContextMenu(null)}></div>
                    <div className="context-menu" style={{ top: contextMenu.y, left: contextMenu.x }}>
                        <ul>
                            <li onClick={handleSelectAll}>Select All</li>
                            <li onClick={handleDeselectAll}>Deselect All</li>
                        </ul>
                    </div>
                </>
            )}
        </div>
    );
};

export default SelectedFilesView;
</file>

<file path="src/client/components/tree-view/TreeView.tsx">
// Updated on: C83 (Fix ref assignment type error)
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { VscChevronRight } from 'react-icons/vsc';
import { ClientPostMessageManager } from '@/common/ipc/client-ipc';
import { ClientToServerChannel } from '@/common/ipc/channels.enum';
import { logger } from '@/client/utils/logger';
import { FileNode } from '@/common/types/file-node';

export interface TreeNode {
    name: string;
    absolutePath: string;
    children?: TreeNode[];
    isExpanded?: boolean;
    [key: string]: any;
}

interface TreeViewProps {
    data: TreeNode[];
    renderNodeContent?: (node: TreeNode, isExpanded: boolean) => React.ReactNode;
    collapseTrigger?: number;
    expandAllTrigger?: number;
    onContextMenu?: (event: React.MouseEvent, node: TreeNode) => void;
    activeFile?: string;
    updateCheckedFiles: (path: string) => void;
    onNodeDrop?: (event: React.DragEvent, node: FileNode) => void;
    onCopy: (path: string) => void;
    clipboard: { path: string; type: 'copy' } | null;
}

const TreeView: React.FC<TreeViewProps> = ({ data, renderNodeContent, collapseTrigger = 0, expandAllTrigger = 0, onContextMenu, activeFile, updateCheckedFiles, onNodeDrop, onCopy, clipboard }) => {
    const [expandedNodes, setExpandedNodes] = useState<string[]>([]);
    const [selectedPaths, setSelectedPaths] = useState<Set<string>>(new Set());
    const [focusedNodePath, setFocusedNodePath] = useState<string | null>(null);
    const [lastClickedPath, setLastClickedPath] = useState<string | null>(null);
    const [draggedPath, setDraggedPath] = useState<string | null>(null);
    const [dropTarget, setDropTarget] = useState<string | null>(null);
    const expansionTimer = useRef<NodeJS.Timeout | null>(null);

    const nodeRefs = useRef<Map<string, HTMLLIElement>>(new Map());
    const treeViewRef = useRef<HTMLDivElement>(null);
    const flatNodeList = useRef<TreeNode[]>([]);
    const clientIpc = ClientPostMessageManager.getInstance();

    const buildFlatNodeList = useCallback((nodes: TreeNode[], expanded: string[]): TreeNode[] => {
        let list: TreeNode[] = [];
        for (const node of nodes) {
            list.push(node);
            if (node.children && expanded.includes(node.absolutePath)) {
                list = list.concat(buildFlatNodeList(node.children, expanded));
            }
        }
        return list;
    }, []);

    useEffect(() => {
        flatNodeList.current = buildFlatNodeList(data, expandedNodes);
        if (!focusedNodePath && flatNodeList.current.length > 0) {
            setFocusedNodePath(flatNodeList.current[0].absolutePath);
        }
    }, [data, expandedNodes, buildFlatNodeList, focusedNodePath]);

    const expandNode = (path: string) => {
        setExpandedNodes(prev => [...new Set([...prev, path])]);
    };

    useEffect(() => {
        if (data.length > 0) {
            const rootNode = data[0];
            if (rootNode) {
                expandNode(rootNode.absolutePath);
            }
        }
    }, [data]);

    useEffect(() => {
        if (collapseTrigger > 0 && data.length > 0) {
            const rootNode = data[0];
            if (rootNode) {
                setExpandedNodes([rootNode.absolutePath]);
            }
        }
    }, [collapseTrigger, data]);

    useEffect(() => {
        if (expandAllTrigger > 0 && data.length > 0) {
            const allDirPaths: string[] = [];
            const collectDirs = (node: TreeNode) => {
                if (node.children) {
                    allDirPaths.push(node.absolutePath);
                    node.children.forEach(collectDirs);
                }
            };
            data.forEach(collectDirs);
            setExpandedNodes(allDirPaths);
        }
    }, [expandAllTrigger, data]);

    useEffect(() => {
        if (activeFile && data.length > 0) {
            logger.log(`[TreeView] activeFile prop changed: ${activeFile}. Attempting to reveal.`);
            const getParentPaths = (filePath: string, rootPath: string): string[] => {
                if (!filePath.startsWith(rootPath) || filePath === rootPath) {
                    return [];
                }
                const relativePath = filePath.substring(rootPath.length + 1);
                const parts = relativePath.split('/');
                const paths: string[] = [];
                let current = rootPath;
                for (let i = 0; i < parts.length - 1; i++) {
                    current += '/' + parts[i];
                    paths.push(current);
                }
                return paths;
            };
            const rootPath = data[0]?.absolutePath;
            if (rootPath) {
                const parents = getParentPaths(activeFile, rootPath);
                logger.log(`[TreeView] Parents to expand: ${JSON.stringify(parents)}`);
                setExpandedNodes(prev => [...new Set([...prev, ...parents, rootPath])]);
                setSelectedPaths(new Set([activeFile]));
                setFocusedNodePath(activeFile);
                setLastClickedPath(activeFile);
                setTimeout(() => {
                    const nodeElement = nodeRefs.current.get(activeFile);
                    if (nodeElement) {
                        logger.log(`[TreeView] Scrolling to active file element.`);
                        nodeElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    } else {
                        logger.warn(`[TreeView] Could not find ref for active file: ${activeFile}`);
                    }
                }, 150);
            }
        }
    }, [activeFile, data]);

    const handleNodeClick = (e: React.MouseEvent, node: TreeNode) => {
        if ((e.target as HTMLElement).closest('.file-checkbox') || (e.target as HTMLElement).closest('.rename-input')) {
            return;
        }
        e.stopPropagation();

        const path = node.absolutePath;
        setFocusedNodePath(path);
        
        if (e.shiftKey && lastClickedPath) {
            const newSelection = new Set(e.ctrlKey ? selectedPaths : []);
            const firstIdx = flatNodeList.current.findIndex(f => f.absolutePath === lastClickedPath);
            const currentIdx = flatNodeList.current.findIndex(f => f.absolutePath === path);
            const start = Math.min(firstIdx, currentIdx);
            const end = Math.max(firstIdx, currentIdx);
            if (start !== -1 && end !== -1) {
                for (let i = start; i <= end; i++) {
                    if (flatNodeList.current[i]) {
                        newSelection.add(flatNodeList.current[i].absolutePath);
                    }
                }
            }
            setSelectedPaths(newSelection);
        } else if (e.ctrlKey) {
            const newSelection = new Set(selectedPaths);
            if (newSelection.has(path)) {
                newSelection.delete(path);
            } else {
                newSelection.add(path);
            }
            setSelectedPaths(newSelection);
            setLastClickedPath(path);
        } else {
            setSelectedPaths(new Set([path]));
            setLastClickedPath(path);
            if (node.children) {
                setExpandedNodes(prev => {
                    const isExpanded = prev.includes(path);
                    return isExpanded ? prev.filter(p => p !== path) : [...prev, path];
                });
            } else {
                clientIpc.sendToServer(ClientToServerChannel.RequestOpenFile, { path });
                setTimeout(() => treeViewRef.current?.focus(), 100);
            }
        }
    };

    const handleKeyDown = (e: React.KeyboardEvent) => {
        // C72 Fix: If the event is coming from an input field, ignore it.
        if ((e.target as HTMLElement).tagName === 'INPUT') {
            return;
        }

        if (e.ctrlKey || e.metaKey) {
            switch (e.key.toLowerCase()) {
                case 'c':
                    e.preventDefault(); e.stopPropagation();
                    if (focusedNodePath) {
                        logger.log(`[Copy-Paste] Ctrl+C detected. Copying path: ${focusedNodePath}`);
                        onCopy(focusedNodePath);
                    }
                    return;
                case 'v':
                    e.preventDefault(); e.stopPropagation();
                    logger.log(`[Copy-Paste] Ctrl+V detected. Clipboard prop: ${JSON.stringify(clipboard)}. Focused node: ${focusedNodePath}`);
                    if (clipboard && focusedNodePath) {
                        const targetNode = flatNodeList.current.find(n => n.absolutePath === focusedNodePath);
                        if (targetNode) {
                            const destinationDir = targetNode.children 
                                ? targetNode.absolutePath 
                                : targetNode.absolutePath.substring(0, targetNode.absolutePath.lastIndexOf('/'));
                            logger.log(`[Copy-Paste] Pasting '${clipboard.path}' into determined destination: '${destinationDir}'`);
                            clientIpc.sendToServer(ClientToServerChannel.RequestCopyFile, { sourcePath: clipboard.path, destinationDir });
                        } else {
                            logger.error(`[Copy-Paste] Could not find target node for path: ${focusedNodePath}`);
                        }
                    }
                    return;
                case 'z':
                    e.preventDefault(); e.stopPropagation();
                    clientIpc.sendToServer(ClientToServerChannel.RequestUndo, {});
                    return;
                case 'y':
                    e.preventDefault(); e.stopPropagation();
                    clientIpc.sendToServer(ClientToServerChannel.RequestRedo, {});
                    return;
            }
        }

        if (e.key === 'Delete') {
            e.preventDefault();
            e.stopPropagation();
            let pathsToDelete: string[] = [];
            if (selectedPaths.size > 0) {
                pathsToDelete = Array.from(selectedPaths);
            } else if (focusedNodePath) {
                pathsToDelete = [focusedNodePath];
            }
            if (pathsToDelete.length > 0) {
                logger.log(`[Delete] Delete key pressed. Requesting deletion of ${pathsToDelete.length} items.`);
                clientIpc.sendToServer(ClientToServerChannel.RequestBatchFileDelete, { paths: pathsToDelete });
            }
            return;
        }

        if (!focusedNodePath) return;
        const currentIndex = flatNodeList.current.findIndex(n => n.absolutePath === focusedNodePath);
        if (currentIndex === -1) return;
        const currentNode = flatNodeList.current[currentIndex];

        const moveFocus = (nextIndex: number) => {
            if (nextIndex >= 0 && nextIndex < flatNodeList.current.length) {
                const nextNodePath = flatNodeList.current[nextIndex].absolutePath;
                setFocusedNodePath(nextNodePath);
                nodeRefs.current.get(nextNodePath)?.scrollIntoView({ block: 'nearest', inline: 'nearest' });
            }
        };
        
        switch (e.key) {
            case 'ArrowUp': e.preventDefault(); e.stopPropagation(); moveFocus(currentIndex - 1); break;
            case 'ArrowDown': e.preventDefault(); e.stopPropagation(); moveFocus(currentIndex + 1); break;
            case 'ArrowRight': e.preventDefault(); e.stopPropagation(); if (currentNode.children) expandNode(currentNode.absolutePath); break;
            case 'ArrowLeft': e.preventDefault(); e.stopPropagation(); if (currentNode.children && expandedNodes.includes(currentNode.absolutePath)) setExpandedNodes(prev => prev.filter(p => p !== currentNode.absolutePath)); break;
            case ' ': e.preventDefault(); e.stopPropagation(); updateCheckedFiles(currentNode.absolutePath); break;
            case 'Enter': e.preventDefault(); e.stopPropagation(); if (currentNode.children) setExpandedNodes(prev => prev.includes(currentNode.absolutePath) ? prev.filter(p => p !== currentNode.absolutePath) : [...prev, currentNode.absolutePath]); else clientIpc.sendToServer(ClientToServerChannel.RequestOpenFile, { path: currentNode.absolutePath }); break;
        }
    };

    // --- Drag/Drop ---
    const handleInternalDragStart = (e: React.DragEvent, node: TreeNode) => {
        e.stopPropagation();
        setDraggedPath(node.absolutePath);
        e.dataTransfer.effectAllowed = 'move';
        logger.log(`Internal Drag Start: ${node.name}`);
    };

    const handleDragEnter = (e: React.DragEvent, node: TreeNode) => {
        e.preventDefault();
        e.stopPropagation();
        logger.log(`Drag Enter on node: ${node.name}`);
        if (node.children && node.absolutePath !== draggedPath) {
            setDropTarget(node.absolutePath);
            if (!expandedNodes.includes(node.absolutePath)) {
                expansionTimer.current = setTimeout(() => {
                    logger.log(`Hover-expanding node: ${node.name}`);
                    expandNode(node.absolutePath);
                }, 500);
            }
        }
    };

    const handleDragLeave = (e: React.DragEvent, node: TreeNode) => {
        e.preventDefault();
        e.stopPropagation();
        logger.log(`Drag Leave from node: ${node.name}`);
        if (dropTarget === node.absolutePath) {
            setDropTarget(null);
        }
        if (expansionTimer.current) {
            clearTimeout(expansionTimer.current);
            expansionTimer.current = null;
        }
    };

    const handleDrop = (e: React.DragEvent, node: TreeNode) => {
        e.preventDefault();
        e.stopPropagation();
        logger.log(`Drop on node: ${node.name}`);
        setDropTarget(null);
        if (expansionTimer.current) {
            clearTimeout(expansionTimer.current);
            expansionTimer.current = null;
        }

        if (draggedPath) { // Internal move
            if (node.children && node.absolutePath !== draggedPath && !node.absolutePath.startsWith(draggedPath + '/')) {
                const draggedName = draggedPath.split('/').pop();
                if (draggedName) {
                    const newPath = `${node.absolutePath}/${draggedName}`;
                    logger.log(`Requesting internal move from ${draggedPath} to ${newPath}`);
                    clientIpc.sendToServer(ClientToServerChannel.RequestMoveFile, { oldPath: draggedPath, newPath });
                }
            }
            setDraggedPath(null);
        } else if (onNodeDrop) { // External drop
            onNodeDrop(e, node as FileNode);
        }
    };
    
    const handleDragOver = (e: React.DragEvent, node: TreeNode) => {
        e.preventDefault();
        e.stopPropagation();
        if (draggedPath && node.absolutePath.startsWith(draggedPath + '/')) {
            e.dataTransfer.dropEffect = 'none'; // Prevent dropping a folder into itself
        } else {
            e.dataTransfer.dropEffect = 'move';
        }
    };

    const renderTreeNodes = (nodes: TreeNode[]) => {
        return nodes.map((node) => {
            const isExpanded = expandedNodes.includes(node.absolutePath);
            const isSelected = selectedPaths.has(node.absolutePath);
            const isFocused = focusedNodePath === node.absolutePath;
            const isDirectory = !!(node.children && node.children.length > 0);
            const isDropTarget = dropTarget === node.absolutePath;

            return (
                <li key={node.absolutePath} 
                    ref={el => {
                        if (el) {
                            nodeRefs.current.set(node.absolutePath, el);
                        } else {
                            nodeRefs.current.delete(node.absolutePath);
                        }
                    }}
                    draggable="true"
                    onDragStart={(e) => handleInternalDragStart(e, node)}
                    onDragEnter={(e) => handleDragEnter(e, node)}
                    onDragLeave={(e) => handleDragLeave(e, node)}
                    onDragOver={(e) => handleDragOver(e, node)}
                    onDrop={(e) => handleDrop(e, node)}
                    className={`treenode-li ${isDropTarget ? 'drop-target' : ''}`}
                    data-path={node.absolutePath}
                >
                    <div
                        className={`treenode-item-wrapper ${isSelected ? 'selected' : ''} ${isFocused ? 'focused' : ''}`}
                        onClick={(e) => handleNodeClick(e, node)}
                        onContextMenu={(e) => onContextMenu?.(e, node)}
                    >
                        <span className={`treenode-chevron ${isExpanded ? 'expanded' : ''}`}>
                            {isDirectory && <VscChevronRight />}
                        </span>
                        <div className="treenode-content">
                            {renderNodeContent ? renderNodeContent(node, isExpanded) : node.name}
                        </div>
                    </div>
                    {isDirectory && isExpanded && (
                        <ul className="treenode-children">{renderTreeNodes(node.children)}</ul>
                    )}
                </li>
            );
        });
    };

    return (
        <div 
            className="tree-view" 
            tabIndex={0} 
            onKeyDown={handleKeyDown} 
            ref={treeViewRef}
            onClick={() => treeViewRef.current?.focus()}
        >
            <ul>{renderTreeNodes(data)}</ul>
        </div>
    );
};

export default TreeView;
</file>

<file path="src/client/components/tree-view/TreeView.utils.ts">
import { TreeNode } from "./TreeView";

export const getExpandedNodes = (data: TreeNode[]): string[] => {
  return data.reduce((acc: string[], node) => {
    if (node.isExpanded) {
      acc.push(node.absolutePath);
    }
    if (node.children) {
      acc.push(...getExpandedNodes(node.children));
    }
    return acc;
  }, []);
};
</file>

<file path="src/client/utils/logger.ts">
import { ClientPostMessageManager } from "@/common/ipc/client-ipc";
import { ClientToServerChannel } from "@/common/ipc/channels.enum";

const clientIpc = ClientPostMessageManager.getInstance();

export const logger = {
    log: (message: string) => {
        console.log(message); // Also log to dev console
        clientIpc.sendToServer(ClientToServerChannel.LogMessage, { level: 'info', message });
    },
    warn: (message: string) => {
        console.warn(message);
        clientIpc.sendToServer(ClientToServerChannel.LogMessage, { level: 'warn', message });
    },
    error: (message: string) => {
        console.error(message);
        clientIpc.sendToServer(ClientToServerChannel.LogMessage, { level: 'error', message });
    }
};
</file>

<file path="src/client/utils/response-parser.ts">
// Updated on: C130 (Fix TypeScript errors with RegExp results)
import { ParsedResponse } from '@/common/types/pcpp.types';

const SUMMARY_REGEX = /^([\s\S]*?)(?=### Course of [Aa]ction|### Files Updated This Cycle|<file path=")/;
const COURSE_OF_ACTION_REGEX = /### Course of [Aa]ction\s*([\s\S]*?)(?=### Files Updated This Cycle|<file path=")/im;
const FILES_UPDATED_LIST_REGEX = /### Files Updated This Cycle\s*([\s\S]*?)(?=<file path="|`{3,})/m;
const FILE_TAG_REGEX = /<file path="([^"]+)">([\s\S]*?)<\/file>/g;
const CODE_FENCE_START_REGEX = /^\s*```[a-zA-Z]*\n/;


export function parseResponse(rawText: string): ParsedResponse {
    const files = [];
    let filesUpdatedList: string[] = [];

    const tagMatches = [...rawText.matchAll(FILE_TAG_REGEX)];

    for (const match of tagMatches) {
        const path = (match?.[1] ?? '').trim();
        let content = (match?.[2] ?? '').trim();

        if (path) {
            // C129: Aggressive multi-pass cleanup
            content = content.replace(CODE_FENCE_START_REGEX, '');

            const patternsToRemove = [
                `</file>`,
                `</${path}>`,
                '```',
                '***'
            ];
    
            let changed = true;
            while(changed) {
                const originalContent = content;
                for (const pattern of patternsToRemove) {
                    if (content.trim().endsWith(pattern)) {
                        content = content.trim().slice(0, -pattern.length).trim();
                    }
                }
                if (content === originalContent) {
                    changed = false;
                }
            }
            
            files.push({ path, content });
        }
    }

    const summaryMatch = rawText.match(SUMMARY_REGEX);
    const courseOfActionMatch = rawText.match(COURSE_OF_ACTION_REGEX);
    
    const summary = (summaryMatch?.[1] ?? 'Could not parse summary.').trim();
    const courseOfAction = (courseOfActionMatch?.[1] ?? 'Could not parse course of action.').trim();

    if (files.length > 0) {
        filesUpdatedList = files.map(f => f.path);
    } else {
        const filesUpdatedMatch = rawText.match(FILES_UPDATED_LIST_REGEX);
        if (filesUpdatedMatch?.[1]) {
            filesUpdatedList.push(...(filesUpdatedMatch[1] ?? '')
                .split('\n')
                .map(line => {
                    const backtickMatch = /`([^`]+)`/.exec(line);
                    return backtickMatch ? backtickMatch[1].trim() : '';
                })
                .filter(line => line.length > 0 && line.includes('.'))
            );
        }
    }

    return {
        summary,
        courseOfAction,
        filesUpdated: [...new Set(filesUpdatedList)],
        files,
    };
}
</file>

<file path="src/client/views/context-chooser.view/index.ts">
import { onMessage } from "./on-message";

export const viewConfig = {
    entry: "contextChooserView.js",
    type: "viewType.sidebar.contextChooser",
    handleMessage: onMessage,
};
</file>

<file path="src/client/views/context-chooser.view/on-message.ts">
// Updated on: C115 (Ensure file reflects correct service calls)
import { ServerPostMessageManager } from "@/common/ipc/server-ipc";
import { ClientToServerChannel, ServerToClientChannel } from "@/common/ipc/channels.enum";
import { Services } from "@/backend/services/services";
import * as vscode from "vscode";

export function onMessage(serverIpc: ServerPostMessageManager) {
    const { fileTreeService, fileOperationService, contentExtractionService, flattenerService, selectionService, actionService, loggerService } = Services;

    serverIpc.onClientMessage(ClientToServerChannel.RequestInitialData, () => {
        serverIpc.sendToClient(ServerToClientChannel.SendWorkspaceTrustState, { isTrusted: vscode.workspace.isTrusted });
        fileTreeService.handleWorkspaceFilesRequest(serverIpc, false);
    });

    serverIpc.onClientMessage(ClientToServerChannel.RequestWorkspaceFiles, (data) => fileTreeService.handleWorkspaceFilesRequest(serverIpc, data.force));
    serverIpc.onClientMessage(ClientToServerChannel.RequestFlattenContext, (data) => flattenerService.flatten(data.selectedPaths));
    serverIpc.onClientMessage(ClientToServerChannel.RequestNewFile, (data) => fileOperationService.handleNewFileRequest(data.parentDirectory));
    serverIpc.onClientMessage(ClientToServerChannel.RequestNewFolder, (data) => fileOperationService.handleNewFolderRequest(data.parentDirectory));
    serverIpc.onClientMessage(ClientToServerChannel.RequestFileRename, (data) => fileOperationService.handleFileRenameRequest(data.oldPath, data.newName));
    serverIpc.onClientMessage(ClientToServerChannel.RequestFileDelete, (data) => fileOperationService.handleFileDeleteRequest(data.path));
    serverIpc.onClientMessage(ClientToServerChannel.RequestBatchFileDelete, (data) => fileOperationService.handleBatchFileDeleteRequest(data.paths));
    serverIpc.onClientMessage(ClientToServerChannel.RequestRevealInExplorer, (data) => fileOperationService.handleRevealInExplorerRequest(data.path));
    serverIpc.onClientMessage(ClientToServerChannel.RequestCopyPath, (data) => fileOperationService.handleCopyPathRequest(data.path, data.relative));
    serverIpc.onClientMessage(ClientToServerChannel.RequestOpenFile, (data) => fileOperationService.handleOpenFileRequest(data.path));
    serverIpc.onClientMessage(ClientToServerChannel.RequestMoveFile, (data) => fileOperationService.handleMoveFileRequest(data.oldPath, data.newPath));
    serverIpc.onClientMessage(ClientToServerChannel.RequestCopyFile, (data) => fileOperationService.handleCopyFileRequest(data.sourcePath, data.destinationDir));
    serverIpc.onClientMessage(ClientToServerChannel.RequestAddFileFromBuffer, (data) => fileOperationService.handleAddFileFromBuffer(data.targetPath, data.data));
    serverIpc.onClientMessage(ClientToServerChannel.RequestCopyFileFromUri, (data) => fileOperationService.handleCopyFileFromUri(data.sourceUri, data.targetDir));
    serverIpc.onClientMessage(ClientToServerChannel.RequestPdfToText, (data) => contentExtractionService.handlePdfToTextRequest(data.path, serverIpc));
    serverIpc.onClientMessage(ClientToServerChannel.RequestExcelToText, (data) => contentExtractionService.handleExcelToTextRequest(data.path, serverIpc));
    serverIpc.onClientMessage(ClientToServerChannel.RequestWordToText, (data) => contentExtractionService.handleWordToTextRequest(data.path, serverIpc));
    serverIpc.onClientMessage(ClientToServerChannel.RequestUndo, () => actionService.undo());
    serverIpc.onClientMessage(ClientToServerChannel.RequestRedo, () => actionService.redo());
    serverIpc.onClientMessage(ClientToServerChannel.SaveCurrentSelection, (data) => selectionService.saveCurrentSelection(data.paths));

    serverIpc.onClientMessage(ClientToServerChannel.RequestLastSelection, async () => {
        const lastSelection = await selectionService.getLastSelection();
        const autoAddState = selectionService.getAutoAddState();
        serverIpc.sendToClient(ServerToClientChannel.ApplySelectionSet, { paths: lastSelection });
        serverIpc.sendToClient(ServerToClientChannel.SendSelectionSets, { sets: selectionService.getSelectionSets() });
        serverIpc.sendToClient(ServerToClientChannel.SendAutoAddState, { enabled: autoAddState });
    });

    serverIpc.onClientMessage(ClientToServerChannel.SaveAutoAddState, (data) => selectionService.saveAutoAddState(data.enabled));
    serverIpc.onClientMessage(ClientToServerChannel.VSCodeCommand, (data) => vscode.commands.executeCommand(data.command, ...(data.args || [])));

    serverIpc.onClientMessage(ClientToServerChannel.LogMessage, (data) => {
        const logMessage = `[WebView] ${data.message}`;
        if (data.level === 'warn') loggerService.warn(logMessage);
        else if (data.level === 'error') loggerService.error(logMessage);
        else loggerService.log(logMessage);
    });
}
</file>

<file path="src/client/views/context-chooser.view/view.scss">
/* Updated on: C59 (Add Workspace Trust banner styling) */
body {
    padding: 0;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
    font-size: 13px;
    color: var(--vscode-editor-foreground);
    background-color: var(--vscode-sideBar-background);
}

.workspace-trust-banner {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 6px 8px;
    background-color: var(--vscode-statusBarItem-warningBackground);
    color: var(--vscode-statusBarItem-warningForeground);
    font-size: 12px;
    flex-shrink: 0;

    button {
        background: none;
        border: 1px solid var(--vscode-button-border, var(--vscode-contrastBorder));
        color: var(--vscode-button-foreground);
        padding: 2px 8px;
        border-radius: 2px;
        cursor: pointer;
        margin-left: auto;

        &:hover {
            background-color: var(--vscode-button-hoverBackground);
        }
    }
}


.view-container {
    display: flex;
    flex-direction: column;
    height: 100vh;
    outline: 2px solid transparent;
    transition: outline-color 0.2s ease-in-out;
}

.view-container.drag-over {
    outline-color: var(--vscode-focusBorder);
    outline-style: dashed;
}


.view-header {
    padding: 0 8px; /* Remove vertical padding */
    border-bottom: 1px solid var(--vscode-panel-border);
    display: flex;
    flex-direction: column; /* Stack title/search and toolbar */
    gap: 4px;
    padding-top: 4px;
    padding-bottom: 4px;
    flex-shrink: 0;
}

.header-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    min-height: 28px; /* Ensure consistent height */
}

.search-container {
    width: 100%;
    padding-bottom: 4px;

    input {
        width: 100%;
        background-color: var(--vscode-input-background);
        color: var(--vscode-input-foreground);
        border: 1px solid var(--vscode-input-border);
        padding: 2px 4px;
        border-radius: 2px;
        outline: none;

        &:focus {
            border-color: var(--vscode-focusBorder);
        }
    }
}


.toolbar {
    display: flex;
    gap: 4px;
    
    button, .dropdown-button {
        background: none;
        border: none;
        color: var(--vscode-icon-foreground);
        cursor: pointer;
        padding: 4px;
        border-radius: 3px;
        display: flex;
        align-items: center;
        justify-content: center;

        &:hover {
            background-color: var(--vscode-toolbar-hoverBackground);
        }

        &.active {
             background-color: var(--vscode-toolbar-hoverBackground);
             color: var(--vscode-focusBorder);
        }
    }

    .spinner {
        display: flex;
        align-items: center;
        padding: 4px;
        animation: spin 1.5s linear infinite;
    }

    @keyframes spin {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
    }
}

.selected-files-panel {
    display: flex;
    flex-direction: column;
    flex-shrink: 0; 
    border-top: 1px solid var(--vscode-panel-border);
    max-height: 40%; /* Give it a max height */
}

.panel-header {
    font-weight: bold;
    padding: 4px 8px;
    font-size: 11px;
    text-transform: uppercase;
    color: var(--vscode-sideBar-titleForeground);
    border-bottom: 1px solid var(--vscode-panel-border);
    flex-shrink: 0;
    display: flex;
    justify-content: space-between;
    align-items: center;

    .toolbar-button {
        background: none;
        border: none;
        color: var(--vscode-icon-foreground);
        cursor: pointer;
        padding: 2px;
        border-radius: 3px;
        display: flex;
        align-items: center;
        justify-content: center;

        &:hover {
            background-color: var(--vscode-toolbar-hoverBackground);
        }
    }
}

.panel-toolbar {
    padding: 4px 8px;
    flex-shrink: 0;
    border-bottom: 1px solid var(--vscode-panel-border);

    button {
        background-color: var(--vscode-button-secondaryBackground);
        color: var(--vscode-button-secondaryForeground);
        border: 1px solid var(--vscode-button-border, var(--vscode-focusBorder));
        padding: 2px 8px;
        font-size: 12px;
        cursor: pointer;
        border-radius: 2px;
        
        &:hover {
            background-color: var(--vscode-button-secondaryHoverBackground);
        }

        &:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
    }
}

.selected-files-list-container {
    overflow-y: auto;
    flex-grow: 1;
}

.selected-list-header {
    display: flex;
    align-items: center; /* Align items vertically */
    font-weight: bold;
    font-size: 11px;
    padding: 2px 8px;
    border-bottom: 1px solid var(--vscode-panel-border);
    user-select: none;
    gap: 8px; /* Add gap for spacing */

    > div {
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 4px;
    }

    .header-index {
        width: 30px;
        flex-shrink: 0;
        text-align: right; /* Right-align the '#' header */
        padding-right: 10px;
        justify-content: flex-end; /* Ensure flex items are at the end */
    }

    .header-type {
        width: 20px;
        flex-shrink: 0;
        justify-content: center;
    }

    .header-name {
        flex-grow: 1;
    }

    .header-tokens {
        flex-shrink: 0;
        width: 80px;
        justify-content: flex-end;
    }
}

.selected-files-list {
    list-style: none;
    padding: 0;
    margin: 0;

    &:focus {
        outline: 1px solid var(--vscode-focusBorder);
        outline-offset: -1px;
    }

    li {
        display: flex;
        align-items: center;
        padding: 2px 8px;
        font-size: 12px;
        gap: 8px;
        cursor: pointer;
        user-select: none;
        border-radius: 2px;
        margin: 1px 2px;

        &.selected {
            background-color: var(--vscode-list-activeSelectionBackground) !important; /* Use important to override token color */
            color: var(--vscode-list-activeSelectionForeground) !important;
        }

        &:hover {
            background-color: var(--vscode-list-hoverBackground);
        }
        
        .file-index {
            width: 30px;
            flex-shrink: 0;
            color: var(--vscode-descriptionForeground);
            text-align: right; /* Right-align the numbers */
            padding-right: 10px;
            position: relative;
            display: flex;
            justify-content: flex-end; /* Right-align the content (number or icon) */
            align-items: center;
            height: 100%;
        }

        .quick-remove-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            color: var(--vscode-icon-foreground);
            &:hover {
                color: var(--vscode-errorForeground);
            }
        }

        .file-icon {
            font-size: 16px;
            width: 20px;
            flex-shrink: 0;
            text-align: center;
        }

        .file-name {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex-grow: 1;
        }

        .file-tokens {
            color: var(--vscode-descriptionForeground);
            font-variant-numeric: tabular-nums;
            width: 80px;
            text-align: right;
            flex-shrink: 0;
        }
    }
}

.file-tree-container {
    flex-grow: 1; 
    overflow-y: auto;
    overflow-x: hidden;
    min-height: 0; /* CRITICAL FIX for flexbox overflow */
    border-right: 1px solid var(--vscode-panel-border); /* Fix for scrollbar gutter visibility */
}

.view-footer {
    padding: 8px;
    border-top: 1px solid var(--vscode-panel-border);
    display: flex;
    flex-direction: column;
    gap: 8px;
    flex-shrink: 0;
}

.flatten-button {
    width: 100%;
    padding: 6px;
    border: 1px solid var(--vscode-button-border, var(--vscode-focusBorder));
    background-color: var(--vscode-button-background);
    color: var(--vscode-button-foreground);
    cursor: pointer;
    border-radius: 2px;
}

.flatten-button:hover {
    background-color: var(--vscode-button-hoverBackground);
}

.loading-message {
    padding: 8px;
    color: var(--vscode-descriptionForeground);
}

.summary-panel {
    font-size: 12px;
    color: var(--vscode-descriptionForeground);
    display: flex;
    justify-content: space-between;
    gap: 12px;
}

.summary-item {
    display: flex;
    align-items: center;
    gap: 4px;
}

.tree-view {
    &:focus {
        outline: none; /* Remove default browser focus ring */
    }

    ul {
        list-style-type: none;
        margin: 0;
        padding-left: 0;
    }

    ul.treenode-children {
        padding-left: 10px; 
    }
}


.treenode-li {
    position: relative;
    border-radius: 3px;
}

/* Drag and Drop style */
.treenode-li.drop-target > .treenode-item-wrapper {
    background-color: var(--vscode-list-dropBackground) !important;
    outline: 1px solid var(--vscode-focusBorder) !important;
}

.treenode-item-wrapper {
    display: flex;
    align-items: center;
    cursor: pointer;
    padding: 1px 4px;
    border-radius: 3px;
    min-height: 22px;
    outline: 1px solid transparent; /* Placeholder for focus ring */
    outline-offset: -1px;
}

.treenode-item-wrapper.focused {
    outline-color: var(--vscode-focusBorder);
}

.treenode-item-wrapper:hover {
    background-color: var(--vscode-list-hoverBackground);
}

.treenode-item-wrapper.selected {
    background-color: var(--vscode-list-activeSelectionBackground);
    color: var(--vscode-list-activeSelectionForeground);
}

.treenode-chevron {
    flex-shrink: 0;
    width: 20px;
    height: 22px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: transform 0.1s ease-in-out;
}

.treenode-chevron.expanded {
    transform: rotate(90deg);
}

.treenode-content {
    flex-grow: 1;
    display: flex;
    align-items: center;
    overflow: hidden;
}


.file-item {
    display: flex;
    align-items: center;
    width: 100%;
    padding: 1px;
    gap: 6px;
}

.file-checkbox {
    cursor: pointer;
    flex-shrink: 0;
}

.file-icon {
    display: flex;
    align-items: center;
    font-size: 16px;
    flex-shrink: 0;
}

.file-name {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    flex-grow: 1;
    user-select: none; /* Prevent text selection on click/drag */
}

/* Error Styling */
.file-item.has-error {
    color: var(--vscode-list-errorForeground);
    opacity: 0.7;

    .file-name {
        text-decoration: line-through;
    }
}

.error-icon {
    color: var(--vscode-errorForeground);
}


/* Git Status & Problems Styling */
.file-item.git-status-M .file-name, .file-item.git-status-M .git-status-badge { color: var(--vscode-gitDecoration-modifiedResourceForeground); }
.file-item.git-status-U .file-name, .file-item.git-status-U .git-status-badge { color: var(--vscode-gitDecoration-untrackedResourceForeground); }
.file-item.git-status-D .file-name, .file-item.git-status-D .git-status-badge { color: var(--vscode-gitDecoration-deletedResourceForeground); }
.file-item.git-status-A .file-name, .file-item.git-status-A .git-status-badge { color: var(--vscode-gitDecoration-addedResourceForeground); }
.file-item.git-status-C .file-name, .file-item.git-status-C .git-status-badge { color: var(--vscode-gitDecoration-conflictingResourceForeground); }
.file-item.git-status-I .file-name, .file-item.git-status-I .git-status-badge { color: var(--vscode-gitDecoration-ignoredResourceForeground); }

.file-item.problem-error .file-name { color: var(--vscode-list-errorForeground); }
.file-item.problem-warning .file-name { color: var(--vscode-list-warningForeground); }

.git-status-badge {
    font-weight: bold;
}

.problem-badge {
    display: flex;
    align-items: center;
    gap: 3px;
    
    & .error-icon {
      color: var(--vscode-list-errorForeground);
    }
    
    & .warning-icon {
      color: var(--vscode-list-warningForeground);
    }
}

.file-stats {
    margin-left: auto;
    padding-left: 8px;
    font-size: 11px;
    color: var(--vscode-descriptionForeground);
    flex-shrink: 0;
    white-space: nowrap;
    display: flex;
    align-items: center;
    gap: 8px;
    justify-content: flex-end;
    text-align: right;
}

.file-stats > * {
    display: flex;
    align-items: center;
    gap: 3px;
}

.selected-token-count {
    font-style: italic;
}

/* Context Menu Styles */
.context-menu-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 999;
}

.context-menu {
    position: absolute;
    background-color: var(--vscode-menu-background);
    border: 1px solid var(--vscode-menu-border);
    color: var(--vscode-menu-foreground);
    box-shadow: 0 2px 8px var(--vscode-widget-shadow);
    border-radius: 4px;
    padding: 4px 0;
    min-width: 180px;
    z-index: 1000;

    ul {
        list-style: none;
        padding: 0;
        margin: 0;
    }

    li {
        padding: 4px 12px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 8px;

        &:hover {
            background-color: var(--vscode-menu-selectionBackground);
            color: var(--vscode-menu-selectionForeground);
        }
    }

    hr {
        border: none;
        border-top: 1px solid var(--vscode-menu-separatorBackground);
        margin: 4px 0;
    }
}

.rename-input {
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    border: 1px solid var(--vscode-focusBorder);
    outline: none;
    width: 100%;
    padding: 0;
    margin: 0;
    font-size: inherit;
    font-family: inherit;
}
</file>

<file path="src/client/views/context-chooser.view/view.tsx">
// Updated on: C83 (Fix onNodeDrop type)
import * as React from 'react';
import * as ReactDOM from 'react-dom/client';
import './view.scss';
import { ClientPostMessageManager } from '@/common/ipc/client-ipc';
import { ClientToServerChannel, ServerToClientChannel } from '@/common/ipc/channels.enum';
import { FileNode } from '@/common/types/file-node';
import FileTree from '../../components/file-tree/FileTree';
import { useState, useEffect, useMemo, useCallback, useRef } from 'react';
import { formatLargeNumber, formatNumberWithCommas } from '@/common/utils/formatting';
import { VscFiles, VscSymbolNumeric, VscCollapseAll, VscRefresh, VscNewFile, VscNewFolder, VscLoading, VscSave, VscFolderLibrary, VscSettingsGear, VscCheckAll, VscSearch, VscExpandAll, VscShield } from 'react-icons/vsc';
import { logger } from '@/client/utils/logger';
import SelectedFilesView from '../../components/SelectedFilesView';
import { addRemovePathInSelectedFiles, removePathsFromSelected } from '@/client/components/file-tree/FileTree.utils';
import { SelectionSet, ProblemCountsMap } from '@/common/ipc/channels.type';
import path from 'path-browserify';

const EXCEL_EXTENSIONS = new Set(['.xlsx', '.xls', '.csv']);
const WORD_EXTENSIONS = new Set(['.docx', '.doc']);

const App = () => {
    const [files, setFiles] = useState<FileNode[]>([]);
    const [checkedFiles, setCheckedFiles] = useState<string[]>([]);
    const [activeFile, setActiveFile] = useState<string | undefined>();
    const [collapseTrigger, setCollapseTrigger] = useState(0);
    const [expandAllTrigger, setExpandAllTrigger] = useState(0);
    const [isLoading, setIsLoading] = useState(true);
    const [selectionSets, setSelectionSets] = useState<SelectionSet>({});
    const [isSelectionListMinimized, setIsSelectionListMinimized] = useState(false);
    const [isAutoAddEnabled, setIsAutoAddEnabled] = useState(false);
    const [isSearchVisible, setIsSearchVisible] = useState(false);
    const [searchTerm, setSearchTerm] = useState('');
    const [problemMap, setProblemMap] = useState<ProblemCountsMap>({});
    const [isDraggingOver, setIsDraggingOver] = useState(false);
    const [isWorkspaceTrusted, setIsWorkspaceTrusted] = useState(true); // Assume trusted by default
    const [clipboard, setClipboard] = useState<{ path: string; type: 'copy' } | null>(null);
    const suppressActiveFileReveal = useRef(false);
    const processedFilesCache = useRef(new Set<string>());
    
    const clientIpc = ClientPostMessageManager.getInstance();

    const requestFiles = (force = false) => {
        setIsLoading(true);
        logger.log(`Requesting workspace files (force=${force}).`);
        clientIpc.sendToServer(ClientToServerChannel.RequestWorkspaceFiles, { force });
    };

    const updateCheckedFiles = useCallback((path: string) => {
        setCheckedFiles(currentChecked => {
            const newChecked = addRemovePathInSelectedFiles(files, path, currentChecked);
            clientIpc.sendToServer(ClientToServerChannel.SaveCurrentSelection, { paths: newChecked });
            return newChecked;
        });
    }, [clientIpc, files]);

    // Effect for pre-warming cache when selection or file tree changes
    useEffect(() => {
        if (files.length === 0 || checkedFiles.length === 0) {
            return;
        }

        const effectivelySelectedFiles = new Set<string>();
        const fileMap = new Map<string, FileNode>();
        
        const buildFileMap = (node: FileNode) => {
            fileMap.set(node.absolutePath, node);
            node.children?.forEach(buildFileMap);
        };
        files.forEach(buildFileMap);

        const addDescendantFiles = (node: FileNode) => {
            if (!node.children) {
                effectivelySelectedFiles.add(node.absolutePath);
            } else {
                node.children.forEach(addDescendantFiles);
            }
        };

        checkedFiles.forEach(path => {
            const node = fileMap.get(path);
            if (node) {
                if (node.children) {
                    addDescendantFiles(node);
                } else {
                    effectivelySelectedFiles.add(path);
                }
            }
        });

        logger.log(`[Cache Pre-warm] Found ${effectivelySelectedFiles.size} effectively selected files.`);

        effectivelySelectedFiles.forEach(path => {
            if (processedFilesCache.current.has(path)) {
                return; // Already processed
            }

            const extension = `.${path.split('.').pop()?.toLowerCase() || ''}`;
            
            let requested = false;
            if (extension === '.pdf') {
                logger.log(`[Cache Pre-warm] Requesting PDF processing for: ${path}`);
                clientIpc.sendToServer(ClientToServerChannel.RequestPdfToText, { path });
                requested = true;
            } else if (EXCEL_EXTENSIONS.has(extension)) {
                logger.log(`[Cache Pre-warm] Requesting Excel processing for: ${path}`);
                clientIpc.sendToServer(ClientToServerChannel.RequestExcelToText, { path });
                requested = true;
            } else if (WORD_EXTENSIONS.has(extension)) {
                logger.log(`[Cache Pre-warm] Requesting Word processing for: ${path}`);
                clientIpc.sendToServer(ClientToServerChannel.RequestWordToText, { path });
                requested = true;
            }

            if (requested) {
                processedFilesCache.current.add(path);
            }
        });

    }, [checkedFiles, files, clientIpc]);


    useEffect(() => {
        logger.log("Initializing view and requesting initial data.");
        
        clientIpc.onServerMessage(ServerToClientChannel.SendWorkspaceTrustState, ({ isTrusted }) => {
            logger.log(`Received workspace trust state: ${isTrusted}`);
            setIsWorkspaceTrusted(isTrusted);
        });

        clientIpc.onServerMessage(ServerToClientChannel.SendWorkspaceFiles, ({ files: receivedFiles }) => {
            logger.log(`Received file tree from backend. Root node: ${receivedFiles[0]?.name}`);
            setFiles(receivedFiles);
            setIsLoading(false);
        });
        
        clientIpc.onServerMessage(ServerToClientChannel.ApplySelectionSet, ({ paths }) => {
            logger.log(`[C80 CACHE FIX] Applying selection set with ${paths.length} paths.`);
            setCheckedFiles(paths);
            clientIpc.sendToServer(ClientToServerChannel.SaveCurrentSelection, { paths });
        });

        clientIpc.onServerMessage(ServerToClientChannel.SendSelectionSets, ({ sets }) => {
            logger.log(`[WebView] Received ${Object.keys(sets).length} selection sets.`);
            setSelectionSets(sets);
        });

        clientIpc.onServerMessage(ServerToClientChannel.SetActiveFile, ({ path }) => {
            if (suppressActiveFileReveal.current) {
                logger.log(`[WebView] Suppressing set active file event for: ${path}`);
                suppressActiveFileReveal.current = false;
                return;
            }
            logger.log(`[WebView] [WebView] Received set active file event for: ${path}`);
            setActiveFile(path);
        });

        clientIpc.onServerMessage(ServerToClientChannel.FocusFile, ({ path }) => {
            logger.log(`[WebView] Received focus file event for: ${path}`);
            setActiveFile(path);
        });

        clientIpc.onServerMessage(ServerToClientChannel.SendAutoAddState, ({ enabled }) => {
            logger.log(`[WebView] Received auto-add state: ${enabled}`);
            setIsAutoAddEnabled(enabled);
        });

        clientIpc.onServerMessage(ServerToClientChannel.ForceRefresh, ({ reason }) => {
            logger.log(`[WebView] Force refresh triggered from backend. Reason: ${reason || 'unknown'}`);
            if (reason === 'fileOp') {
                suppressActiveFileReveal.current = true;
                setTimeout(() => { suppressActiveFileReveal.current = false; }, 2000);
            }
            requestFiles(true);
            clientIpc.sendToServer(ClientToServerChannel.RequestLastSelection, {});
        });

        clientIpc.onServerMessage(ServerToClientChannel.UpdateProblemCounts, ({ problemMap: newProblemMap }) => {
            logger.log(`[WebView] Received dynamic problem counts update with ${Object.keys(newProblemMap).length} entries.`);
            setProblemMap(newProblemMap);
        });

        clientIpc.onServerMessage(ServerToClientChannel.UpdateNodeStats, ({ path, tokenCount, error }) => {
            logger.log(`Received stats update for ${path}. New token count: ${tokenCount}, Error: ${error}`);
            processedFilesCache.current.add(path); // Mark as processed so we don't request it again
            setFiles(currentFiles => {
                const newFiles = JSON.parse(JSON.stringify(currentFiles));
                let nodeUpdated = false;
                const findAndUpdate = (nodes: FileNode[]) => {
                    for (const node of nodes) {
                        if (node.absolutePath === path) {
                            node.tokenCount = tokenCount;
                            node.error = error;
                            nodeUpdated = true;
                            return true;
                        }
                        if (node.children && findAndUpdate(node.children)) return true;
                    }
                    return false;
                };
                findAndUpdate(newFiles);
                return nodeUpdated ? newFiles : currentFiles;
            });
        });

        clientIpc.sendToServer(ClientToServerChannel.RequestInitialData, {});
        clientIpc.sendToServer(ClientToServerChannel.RequestLastSelection, {});

    }, [clientIpc]);

    const handleFlattenClick = () => {
        logger.log(`Flatten Context button clicked with ${checkedFiles.length} paths.`);
        clientIpc.sendToServer(ClientToServerChannel.RequestFlattenContext, { selectedPaths: checkedFiles });
    };

    const handleRefresh = () => {
        logger.log("Refresh button clicked.");
        processedFilesCache.current.clear(); // Clear cache on manual refresh
        requestFiles(true);
    };
    
    const handleExpandAll = () => {
        logger.log("Expand All button clicked.");
        setExpandAllTrigger(c => c + 1);
    };

    const handleCollapseAll = () => {
        logger.log("Collapse All button clicked.");
        setCollapseTrigger(c => c + 1);
    };

    const getParentDirForNewItem = (): string => {
        if (activeFile) {
            const nodeMap = new Map<string, FileNode>();
            const buildMap = (node: FileNode) => {
                nodeMap.set(node.absolutePath, node);
                node.children?.forEach(buildMap);
            };
            files.forEach(buildMap);
            const activeNode = nodeMap.get(activeFile);
            if (activeNode) {
                return activeNode.children ? activeNode.absolutePath : activeFile.substring(0, activeFile.lastIndexOf('/'));
            }
        }
        return files.length > 0 ? files[0].absolutePath : '';
    };

    const handleNewFile = () => clientIpc.sendToServer(ClientToServerChannel.RequestNewFile, { parentDirectory: getParentDirForNewItem() });
    const handleNewFolder = () => clientIpc.sendToServer(ClientToServerChannel.RequestNewFolder, { parentDirectory: getParentDirForNewItem() });

    const handleToggleAutoAdd = () => {
        const newState = !isAutoAddEnabled;
        setIsAutoAddEnabled(newState);
        clientIpc.sendToServer(ClientToServerChannel.SaveAutoAddState, { enabled: newState });
    };

    const handleRemoveFromSelection = (pathsToRemove: string[]) => {
        setCheckedFiles(currentChecked => {
            const newChecked = removePathsFromSelected(pathsToRemove, currentChecked, files);
            clientIpc.sendToServer(ClientToServerChannel.SaveCurrentSelection, { paths: newChecked });
            return newChecked;
        });
    };

    const processDrop = (event: React.DragEvent, node: FileNode) => {
        const targetDir = node.children ? node.absolutePath : path.dirname(node.absolutePath);
        logger.log(`[Drop] Drop detected on target: ${targetDir}`);
        logger.log(`[Drop] Available types: ${Array.from(event.dataTransfer.types).join(', ')}`);

        // Case 1: Drop from OS File Explorer
        if (event.dataTransfer.files && event.dataTransfer.files.length > 0) {
            logger.log(`[Drop] Handling as OS file drop (${event.dataTransfer.files.length} files).`);
            const filesArray = Array.from(event.dataTransfer.files);
            filesArray.forEach((file: File) => {
                const reader = new FileReader();
                reader.onload = (readEvent) => {
                    if (readEvent.target?.result instanceof ArrayBuffer) {
                        const data = new Uint8Array(readEvent.target.result);
                        const finalTargetPath = `${targetDir}/${file.name}`.replace(/\\/g, '/');
                        logger.log(`[Drop] Sending file buffer ${file.name} to backend for creation at ${finalTargetPath}`);
                        clientIpc.sendToServer(ClientToServerChannel.RequestAddFileFromBuffer, { targetPath: finalTargetPath, data });
                    }
                };
                reader.onerror = () => logger.error(`[Drop] FileReader error for file: ${file.name}`);
                reader.readAsArrayBuffer(file);
            });
            return;
        }

        // Case 2: Drop from VS Code Explorer
        const uriList = event.dataTransfer.getData('text/uri-list');
        if (uriList) {
            logger.log(`[Drop] Handling as VS Code URI drop. URI List: ${uriList}`);
            const sourceUri = uriList.split('\n')[0].trim(); // Handle multiple URIs if needed, for now just take the first
            if (sourceUri) {
                 clientIpc.sendToServer(ClientToServerChannel.RequestCopyFileFromUri, { sourceUri, targetDir });
            }
            return;
        }
        
        logger.warn('[Drop] Drop event occurred but no compatible data type was found.');
    };

    const handleContainerDrop = (event: React.DragEvent<HTMLDivElement>) => {
        event.preventDefault();
        event.stopPropagation();
        setIsDraggingOver(false);
        if (!isWorkspaceTrusted) return;
        
        const rootDir = files.length > 0 ? files[0].absolutePath : '';
        if (!rootDir) {
            logger.error("Cannot drop file, no workspace root identified.");
            return;
        }
        const dummyRootNode: FileNode = { absolutePath: rootDir, name: path.basename(rootDir), children: [], tokenCount: 0, fileCount: 0, isImage: false, sizeInBytes: 0, extension: '', isPdf: false, isExcel: false, isWordDoc: false };
        processDrop(event, dummyRootNode);
    };
    
    const handleDragOver = (event: React.DragEvent<HTMLDivElement>) => {
        event.preventDefault();
        event.stopPropagation();
        if (isWorkspaceTrusted && (event.dataTransfer.types.includes('Files') || event.dataTransfer.types.includes('text/uri-list'))) {
             event.dataTransfer.dropEffect = 'copy';
        } else {
            event.dataTransfer.dropEffect = 'none';
        }
    };

    const handleDragEnter = (event: React.DragEvent<HTMLDivElement>) => {
        event.preventDefault();
        event.stopPropagation();
        if (isWorkspaceTrusted && (event.dataTransfer.types.includes('Files') || event.dataTransfer.types.includes('text/uri-list'))) {
            setIsDraggingOver(true);
        }
    };

    const handleDragLeave = (event: React.DragEvent<HTMLDivElement>) => {
        event.preventDefault();
        event.stopPropagation();
        if (!event.currentTarget.contains(event.relatedTarget as Node)) {
            setIsDraggingOver(false);
        }
    };

    const { totalFiles, totalTokens, selectedFileNodes } = useMemo(() => {
        let totalTokens = 0;
        const selectedFileSet = new Set<string>();
        const selectedNodes: FileNode[] = [];
        const fileMap: Map<string, FileNode> = new Map();
        const buildFileMap = (node: FileNode) => {
            fileMap.set(node.absolutePath, node);
            node.children?.forEach(buildFileMap);
        };
        files.forEach(buildFileMap);
        const addNodeAndDescendants = (node: FileNode) => {
            if (!node.children) { // It's a file
                if (!selectedFileSet.has(node.absolutePath)) {
                    selectedFileSet.add(node.absolutePath);
                    selectedNodes.push(node);
                    totalTokens += node.tokenCount;
                }
            } else { // It's a directory
                node.children.forEach(addNodeAndDescendants);
            }
        };
        checkedFiles.forEach(path => {
            const node = fileMap.get(path);
            if (node) addNodeAndDescendants(node);
        });
        return { totalFiles: selectedNodes.length, totalTokens, selectedFileNodes: selectedNodes };
    }, [checkedFiles, files]);

    return (
        <div 
            className={`view-container ${isDraggingOver ? 'drag-over' : ''}`} 
            onDrop={handleContainerDrop} 
            onDragOver={handleDragOver}
            onDragEnter={handleDragEnter}
            onDragLeave={handleDragLeave}
        >
            {!isWorkspaceTrusted && (
                <div className="workspace-trust-banner">
                    <VscShield />
                    <span>Drag and drop is disabled because this workspace is not trusted.</span>
                    <button onClick={() => clientIpc.sendToServer(ClientToServerChannel.VSCodeCommand, { command: 'workbench.action.manageWorkspaceTrust' })}>
                        Manage Trust
                    </button>
                </div>
            )}
            <div className="view-header">
                 <div className="header-row">
                     <div className="toolbar">
                         <button onClick={() => clientIpc.sendToServer(ClientToServerChannel.VSCodeCommand, { command: 'dce.saveCurrentSelection', args: [checkedFiles] })} title="Save Selection Set..."><VscSave /></button>
                         <button onClick={() => clientIpc.sendToServer(ClientToServerChannel.VSCodeCommand, { command: 'dce.loadSelectionSet' })} title="Load Selection Set..."><VscFolderLibrary /></button>
                         <button onClick={() => clientIpc.sendToServer(ClientToServerChannel.VSCodeCommand, { command: 'dce.manageSelectionSets' })} title="Manage Selection Sets..."><VscSettingsGear /></button>
                     </div>
                     <div className="toolbar">
                         {isLoading && <span className="spinner" title="Refreshing..."><VscLoading /></span>}
                         <button onClick={() => setIsSearchVisible(v => !v)} title="Search..." className={isSearchVisible ? 'active' : ''}><VscSearch /></button>
                         <button onClick={handleToggleAutoAdd} title="Automatically add new files to selection" className={isAutoAddEnabled ? 'active' : ''}><VscCheckAll /></button>
                         <button onClick={handleNewFile} title="New File..."><VscNewFile /></button>
                         <button onClick={handleNewFolder} title="New Folder..."><VscNewFolder /></button>
                         <button onClick={handleRefresh} title="Refresh Explorer"><VscRefresh /></button>
                         <button onClick={handleExpandAll} title="Expand All Folders"><VscExpandAll /></button>
                         <button onClick={handleCollapseAll} title="Collapse Folders in View"><VscCollapseAll /></button>
                     </div>
                 </div>
                {isSearchVisible && (
                    <div className="search-container">
                        <input type="text" placeholder="Filter files..." value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} />
                    </div>
                )}
            </div>
            <div className="file-tree-container">
                {isLoading && files.length === 0 ? (
                     <div className="loading-message">Loading file tree...</div>
                ) : files.length > 0 ? (
                    <FileTree data={files} checkedFiles={checkedFiles} updateCheckedFiles={updateCheckedFiles} activeFile={activeFile} collapseTrigger={collapseTrigger} expandAllTrigger={expandAllTrigger} searchTerm={searchTerm} problemMap={problemMap} onNodeDrop={processDrop} onCopy={(path) => setClipboard({ path, type: 'copy' })} clipboard={clipboard} />
                ) : (
                    <div className="loading-message">No folder open.</div>
                )}
            </div>
            <SelectedFilesView selectedFileNodes={selectedFileNodes} onRemove={handleRemoveFromSelection} isMinimized={isSelectionListMinimized} onToggleMinimize={() => setIsSelectionListMinimized(prev => !prev)} />
            <div className="view-footer">
                <div className="summary-panel">
                    <span className='summary-item' title="Total number of individual files selected for flattening. This does not include empty directories."><VscFiles /> Selected Files: {formatNumberWithCommas(totalFiles)}</span>
                    <span className='summary-item' title="Total tokens in selected text files"><VscSymbolNumeric /> {formatLargeNumber(totalTokens, 1)}</span>
                </div>
                <button className="flatten-button" onClick={handleFlattenClick}>Flatten Context</button>
            </div>
        </div>
    );
};

const root = ReactDOM.createRoot(document.getElementById('root')!);
root.render(<App />);
</file>

<file path="src/client/views/index.ts">
import { viewConfig as contextChooserViewConfig } from "./context-chooser.view";
import * as vscode from "vscode";
import { ServerPostMessageManager } from "@/common/ipc/server-ipc";
import { getNonce, getViewHtml } from "@/common/utils/view-html";

export const views = [contextChooserViewConfig];
export const serverIPCs: Record<string, ServerPostMessageManager> = {};

export function registerViews(context: vscode.ExtensionContext) {
    views.forEach((viewConfig) => {
        context.subscriptions.push(
            vscode.window.registerWebviewViewProvider(viewConfig.type, {
                resolveWebviewView: (webviewView) => {
                    webviewView.webview.options = {
                        enableScripts: true,
                        localResourceRoots: [context.extensionUri],
                    };
                    const nonce = getNonce();
                    const scriptUri = webviewView.webview.asWebviewUri(vscode.Uri.joinPath(context.extensionUri, "dist", viewConfig.entry));
                    const styleUri = webviewView.webview.asWebviewUri(vscode.Uri.joinPath(context.extensionUri, "dist", `${viewConfig.entry.replace('.js', '')}.css`));
                    
                    webviewView.webview.html = getViewHtml({
                        webview: webviewView.webview,
                        nonce,
                        scriptUri: scriptUri.toString(),
                        styleUris: [styleUri],
                    });

                    const serverIpc = ServerPostMessageManager.getInstance(
                        webviewView.webview.onDidReceiveMessage,
                        (data: any) => webviewView.webview.postMessage(data)
                    );
                    serverIPCs[viewConfig.type] = serverIpc;
                    viewConfig.handleMessage(serverIpc);
                },
            })
        );
    });
}
</file>

<file path="src/client/views/parallel-copilot.view/index.ts">
// src/client/views/parallel-copilot.view/index.ts
import { onMessage } from "./on-message";

export const viewConfig = {
    entry: "parallelCopilotView.js",
    type: "viewType.sidebar.parallelCopilot",
    handleMessage: onMessage,
};
</file>

<file path="src/client/views/parallel-copilot.view/on-message.ts">
// Updated on: C125 (Add cycle management handlers)
import { ServerPostMessageManager } from "@/common/ipc/server-ipc";
import { Services } from "@/backend/services/services";
import { ClientToServerChannel, ServerToClientChannel } from "@/common/ipc/channels.enum";

export function onMessage(serverIpc: ServerPostMessageManager) {
    const { loggerService, promptService, fileOperationService, highlightingService, historyService } = Services;
    loggerService.log("Parallel Co-Pilot view message handler initialized.");

    serverIpc.onClientMessage(ClientToServerChannel.RequestCreatePromptFile, (data) => {
        promptService.generatePromptFile(data.cycleTitle, data.currentCycle);
    });

    serverIpc.onClientMessage(ClientToServerChannel.RequestFileExistence, (data) => {
        fileOperationService.handleFileExistenceRequest(data.paths, serverIpc);
    });

    serverIpc.onClientMessage(ClientToServerChannel.RequestSyntaxHighlight, (data) => {
        highlightingService.handleSyntaxHighlightRequest(data.code, data.lang, data.id, serverIpc);
    });

    serverIpc.onClientMessage(ClientToServerChannel.RequestLatestCycleData, async () => {
        const cycleData = await historyService.getLatestCycle();
        serverIpc.sendToClient(ServerToClientChannel.SendLatestCycleData, { cycleData });
    });

    serverIpc.onClientMessage(ClientToServerChannel.RequestCycleData, async (data) => {
        const cycleData = await historyService.getCycleData(data.cycleId);
        serverIpc.sendToClient(ServerToClientChannel.SendCycleData, { cycleData });
    });

    serverIpc.onClientMessage(ClientToServerChannel.SaveCycleData, (data) => {
        historyService.saveCycleData(data.cycleData);
    });
    
    serverIpc.onClientMessage(ClientToServerChannel.RequestFileContent, (data) => {
        fileOperationService.handleFileContentRequest(data.path, serverIpc);
    });

    serverIpc.onClientMessage(ClientToServerChannel.RequestDeleteCycle, (data) => {
        historyService.deleteCycle(data.cycleId);
    });

    serverIpc.onClientMessage(ClientToServerChannel.RequestResetHistory, () => {
        historyService.resetHistory();
    });
}
</file>

<file path="src/client/views/parallel-copilot.view/TestPane1.tsx">
// src/client/views/parallel-copilot.view/TestPane1.tsx
import * as React from 'react';
import { VscCheck, VscError } from 'react-icons/vsc';
import { ParsedResponse } from '@/common/types/pcpp.types';
import { logger } from '@/client/utils/logger';

interface TestPane1Props {
    parsedContent: ParsedResponse | null;
    fileExistenceMap: Map<string, boolean>;
}

const TestPane1: React.FC<TestPane1Props> = ({ parsedContent, fileExistenceMap }) => {
    const [lastClicked, setLastClicked] = React.useState<string | null>(null);

    if (!parsedContent) {
        return <div className="test-pane-container">Go to the "Original" tab, paste a response, and click "Parse All" to populate test data.</div>;
    }

    return (
        <div className="test-pane-container">
            <h3>Test Pane A: Barebones Click Logger</h3>
            <p>This test uses a raw list with a simple `onClick`. If clicks are logged and the text below updates, the fundamental event capture is working.</p>
            <p><strong>Last Clicked:</strong> {lastClicked || 'None'}</p>
            <hr style={{ margin: '8px 0', borderColor: 'var(--vscode-panel-border)' }} />
            <ul className="associated-files-list">
                {parsedContent.filesUpdated.map(file => (
                    <li 
                        key={file} 
                        onClick={() => {
                            logger.log(`[TEST PANE A] CLICKED: ${file}`);
                            setLastClicked(file);
                        }}
                    >
                        {fileExistenceMap.get(file) ? <VscCheck className="status-icon exists" /> : <VscError className="status-icon not-exists" />}
                        <span>{file}</span>
                    </li>
                ))}
            </ul>
        </div>
    );
};

export default TestPane1;
</file>

<file path="src/client/views/parallel-copilot.view/TestPane2.tsx">
// Updated on: C106 (Fix click handler and add separate state for content)
import * as React from 'react';
import { VscCheck, VscError } from 'react-icons/vsc';
import { ParsedResponse, ParsedFile } from '@/common/types/pcpp.types';
import { logger } from '@/client/utils/logger';

interface TestPane2Props {
    parsedContent: ParsedResponse | null;
    fileExistenceMap: Map<string, boolean>;
}

const TestPane2: React.FC<TestPane2Props> = ({ parsedContent, fileExistenceMap }) => {
    const [lastClickedFile, setLastClickedFile] = React.useState<string | null>(null);
    const [selectedFileContent, setSelectedFileContent] = React.useState<string | null>(null);

    if (!parsedContent) {
        return <div className="test-pane-container">Go to the main input, paste a response, and click "Parse for Tests" to populate data.</div>;
    }

    const handleFileClick = (filePath: string) => {
        logger.log(`[TEST PANE B] CLICKED: ${filePath}.`);
        setLastClickedFile(filePath); // First, simple state update

        const file = parsedContent.files.find(f => f.path === filePath);
        if (file) {
            logger.log(`[TEST PANE B] Found file content. Setting content state.`);
            setSelectedFileContent(file.content); // Second, update content
        } else {
            logger.error(`[TEST PANE B] Could not find file object for path: ${filePath}`);
            setSelectedFileContent(`Error: Could not find content for ${filePath}`);
        }
    };

    return (
        <div className="test-pane-container">
            <h3>Test Pane B: Local State Update</h3>
            <p>This test uses local `useState` to manage the selected file. Clicking a file should update the content displayed below.</p>
            <p><strong>Last Clicked:</strong> {lastClickedFile || 'None'}</p>
            <hr style={{ margin: '8px 0', borderColor: 'var(--vscode-panel-border)' }} />
            <div style={{ display: 'flex', gap: '8px' }}>
                <div style={{ flex: 1 }}>
                    <h4>Files</h4>
                    <ul className="associated-files-list">
                        {parsedContent.filesUpdated.map(filePath => (
                            <li 
                                key={filePath} 
                                onClick={() => handleFileClick(filePath)}
                                className={lastClickedFile === filePath ? 'selected' : ''}
                            >
                                {fileExistenceMap.get(filePath) ? <VscCheck className="status-icon exists" /> : <VscError className="status-icon not-exists" />}
                                <span>{filePath}</span>
                            </li>
                        ))}
                    </ul>
                </div>
                <div style={{ flex: 2, borderLeft: '1px solid var(--vscode-panel-border)', paddingLeft: '8px' }}>
                    <h4>Content</h4>
                    {selectedFileContent !== null ? (
                        <pre style={{ whiteSpace: 'pre-wrap', wordBreak: 'break-all' }}>
                            <code>{selectedFileContent}</code>
                        </pre>
                    ) : (
                        <div>Select a file to see its content.</div>
                    )}
                </div>
            </div>
        </div>
    );
};

export default TestPane2;
</file>

<file path="src/client/views/parallel-copilot.view/TestPane3.tsx">
// Updated on: C106 (Fix click handler and add separate state for content)
import * as React from 'react';
import { VscCheck, VscError } from 'react-icons/vsc';
import { ParsedResponse, ParsedFile } from '@/common/types/pcpp.types';
import { logger } from '@/client/utils/logger';

// Child component to test prop drilling
const FileList = ({ files, fileExistenceMap, onFileSelect, lastClickedFile }: { files: string[], fileExistenceMap: Map<string, boolean>, onFileSelect: (filePath: string) => void, lastClickedFile: string | null }) => (
    <ul className="associated-files-list">
        {files.map(filePath => (
            <li 
                key={filePath} 
                onClick={() => onFileSelect(filePath)}
                className={lastClickedFile === filePath ? 'selected' : ''}
            >
                {fileExistenceMap.get(filePath) ? <VscCheck className="status-icon exists" /> : <VscError className="status-icon not-exists" />}
                <span>{filePath}</span>
            </li>
        ))}
    </ul>
);

interface TestPane3Props {
    parsedContent: ParsedResponse | null;
    fileExistenceMap: Map<string, boolean>;
}

const TestPane3: React.FC<TestPane3Props> = ({ parsedContent, fileExistenceMap }) => {
    const [lastClickedFile, setLastClickedFile] = React.useState<string | null>(null);
    const [selectedFileContent, setSelectedFileContent] = React.useState<string | null>(null);

    if (!parsedContent) {
        return <div className="test-pane-container">Go to the main input, paste a response, and click "Parse for Tests" to populate data.</div>;
    }

    const handleFileSelect = (filePath: string) => {
        logger.log(`[TEST PANE C] Child component called onFileSelect prop for: ${filePath}.`);
        setLastClickedFile(filePath);

        const file = parsedContent.files.find(f => f.path === filePath);
        if (file) {
             logger.log(`[TEST PANE C] Found file content. Setting content state.`);
            setSelectedFileContent(file.content);
        } else {
             logger.error(`[TEST PANE C] Could not find file object for path: ${filePath}`);
             setSelectedFileContent(`Error: Could not find content for ${filePath}`);
        }
    };

    return (
        <div className="test-pane-container">
            <h3>Test Pane C: Prop-Driven Update</h3>
            <p>This test uses a child component for the list, passing the click handler down as a prop. This tests for issues with prop drilling.</p>
            <p><strong>Last Clicked:</strong> {lastClickedFile || 'None'}</p>
            <hr style={{ margin: '8px 0', borderColor: 'var(--vscode-panel-border)' }} />
             <div style={{ display: 'flex', gap: '8px' }}>
                <div style={{ flex: 1 }}>
                    <h4>Files (Child Component)</h4>
                    <FileList 
                        files={parsedContent.filesUpdated} 
                        fileExistenceMap={fileExistenceMap} 
                        onFileSelect={handleFileSelect}
                        lastClickedFile={lastClickedFile}
                    />
                </div>
                <div style={{ flex: 2, borderLeft: '1px solid var(--vscode-panel-border)', paddingLeft: '8px' }}>
                    <h4>Content (Parent Component)</h4>
                    {selectedFileContent !== null ? (
                        <pre style={{ whiteSpace: 'pre-wrap', wordBreak: 'break-all' }}>
                            <code>{selectedFileContent}</code>
                        </pre>
                    ) : (
                        <div>Select a file to see its content.</div>
                    )}
                </div>
            </div>
        </div>
    );
};

export default TestPane3;
</file>

<file path="src/client/views/parallel-copilot.view/view.scss">
/* Updated on: C129 (Styles for vertical diff layout and fixed panes) */
body {
    padding: 0;
    font-family: var(--vscode-font-family);
    font-size: var(--vscode-font-size);
    color: var(--vscode-editor-foreground);
    background-color: var(--vscode-editor-background);
}

.pc-view-container {
    padding: 8px;
    display: flex;
    flex-direction: column;
    height: 100vh;
    gap: 8px;
    box-sizing: border-box;
}

.collapsible-section {
    border: 1px solid var(--vscode-panel-border);
    border-radius: 4px;
    flex-shrink: 0;
}

.collapsible-header {
    background-color: var(--vscode-sideBar-sectionHeaderBackground);
    padding: 4px 8px;
    font-size: 11px;
    text-transform: uppercase;
    font-weight: bold;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 4px;
    justify-content: space-between;

    .chevron {
        transition: transform 0.2s ease-in-out;
    }
    .chevron.collapsed {
        transform: rotate(-90deg);
    }
}

.collapsible-content {
    padding: 8px;
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.pc-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-shrink: 0;
    gap: 16px;
}

.cycle-navigator {
    display: flex;
    align-items: center;
    gap: 8px;
    width: 100%;
}

.pc-toolbar {
    display: flex;
    align-items: center;
    gap: 8px;
}

.cycle-navigator button, .pc-toolbar button, .file-actions button, .exit-diff-button {
    background: none;
    border: 1px solid var(--vscode-button-border, transparent);
    color: var(--vscode-icon-foreground);
    cursor: pointer;
    padding: 4px;
    border-radius: 3px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;

    &:hover {
        background-color: var(--vscode-toolbar-hoverBackground);
    }

    &:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
}

.exit-diff-button {
    margin-top: 8px;
    justify-content: center;
    width: 100%;
    background-color: var(--vscode-button-secondaryBackground);
    &:hover {
        background-color: var(--vscode-button-secondaryHoverBackground);
    }
}


.cycle-input {
    width: 50px;
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    border: 1px solid var(--vscode-input-border);
    text-align: center;
    border-radius: 2px;
}

.cycle-title-input {
    flex-grow: 1;
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    border: 1px solid var(--vscode-input-border);
    padding: 2px 4px;
    border-radius: 2px;
}

.context-inputs {
    display: flex;
    flex-direction: column;
    gap: 8px;
    flex-shrink: 0;
}

.tab-count-input {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 12px;
    
    input {
        width: 50px;
        background-color: var(--vscode-input-background);
        color: var(--vscode-input-foreground);
        border: 1px solid var(--vscode-input-border);
        text-align: center;
        border-radius: 2px;
    }
}

.context-textarea {
    width: 100%;
    height: 60px;
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    border: 1px solid var(--vscode-input-border);
    border-radius: 2px;
    padding: 4px;
    font-family: var(--vscode-editor-font-family);
    font-size: var(--vscode-editor-font-size);
    resize: vertical;
}

.tab-bar {
    display: flex;
    border-bottom: 1px solid var(--vscode-panel-border);
    flex-shrink: 0;
}

.tab {
    padding: 6px 12px;
    cursor: pointer;
    border-bottom: 2px solid transparent;
    color: var(--vscode-tab-inactiveForeground);
}

.tab.active {
    color: var(--vscode-tab-activeForeground);
    border-bottom-color: var(--vscode-tab-activeBorder);
}

.tab-content {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    min-height: 0;
    padding-top: 8px;
}

.tab-pane {
    display: flex;
    flex-direction: column;
    flex-grow: 1;
    gap: 8px;
    height: 100%;
}

.response-textarea {
    width: 100%;
    height: 100%;
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    border: 1px solid var(--vscode-input-border);
    border-radius: 2px;
    padding: 4px;
    font-family: var(--vscode-editor-font-family);
    font-size: var(--vscode-editor-font-size);
    resize: none;
     &:focus {
        outline: 1px solid var(--vscode-focusBorder);
    }
}

.parsed-view-grid {
    display: flex;
    gap: 0;
    flex-grow: 1;
    min-height: 0;
}

.parsed-view-left {
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 8px;
    min-width: 150px;
    padding-right: 8px;
}

.resizer {
    width: 5px;
    cursor: col-resize;
    background-color: var(--vscode-panel-border);
    flex-shrink: 0;
    &:hover {
        background-color: var(--vscode-focusBorder);
    }
}

.parsed-view-right {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    min-width: 0;
    padding-left: 8px;
}

.file-content-viewer-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 4px 8px;
    background-color: var(--vscode-editorGroupHeader-tabsBackground);
    border: 1px solid var(--vscode-panel-border);
    border-bottom: none;
    border-top-left-radius: 4px;
    border-top-right-radius: 4px;
    font-size: 12px;
    flex-shrink: 0;

    .file-path {
        font-weight: bold;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    .file-actions {
        display: flex;
        align-items: center;
        gap: 8px;
    }
}

.code-viewer-wrapper {
    display: flex;
    flex-grow: 1;
    min-height: 0;
    border: 1px solid var(--vscode-panel-border);
    border-top: none;
    border-radius: 0 0 4px 4px;
    background-color: var(--vscode-editor-background);
    overflow: hidden;
}

.file-content-viewer {
    flex: 1;
    overflow: auto;
    font-family: var(--vscode-editor-font-family);
    font-size: var(--vscode-editor-font-size);
    display: flex;
    min-width: 0;
}

.line-numbers {
    padding: 8px 10px 8px 8px;
    text-align: right;
    color: var(--vscode-editorLineNumber-foreground);
    background-color: var(--vscode-editor-background);
    user-select: none;
    border-right: 1px solid var(--vscode-panel-border);
    
    span {
        display: block;
        line-height: 1.5;
    }
}

.code-content {
    padding: 8px;
    flex-grow: 1;
    white-space: pre;
    
    code > span {
        line-height: 1.5;
    }
}

.associated-files-list {
    list-style: none;
    padding: 0;
    margin: 0;

    li {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 2px 4px;
        font-size: 12px;
        border-radius: 3px;
        cursor: pointer;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;

        &:hover {
            background-color: var(--vscode-list-hoverBackground);
        }

        &.selected {
            background-color: var(--vscode-list-activeSelectionBackground) !important;
            color: var(--vscode-list-activeSelectionForeground) !important;
        }
    }

    .status-icon {
        flex-shrink: 0;
    }
    .status-icon.exists {
        color: var(--vscode-testing-iconPassed);
    }
    .status-icon.not-exists {
        color: var(--vscode-testing-iconFailed);
    }
}

.collapsed-navigator {
    display: flex;
    align-items: center;
    gap: 4px;
    font-weight: normal;
    
    button {
        padding: 0 4px;
    }
    
    .cycle-display {
        font-size: 11px;
        color: var(--vscode-descriptionForeground);
    }
}

/* Diff Viewer Styles */
.diff-viewer-wrapper {
    display: flex;
    flex-direction: column;
    height: 100%;
    min-height: 0;
}
.diff-viewer-main-container {
    flex-grow: 1;
    min-height: 0;
    display: flex;
    flex-direction: column;
    border: 1px solid var(--vscode-panel-border);
    border-radius: 4px;
}

.diff-pane-header {
    padding: 4px 8px;
    font-size: 11px;
    font-weight: bold;
    background-color: var(--vscode-editorGroupHeader-tabsBackground);
    border-bottom: 1px solid var(--vscode-panel-border);
    flex-shrink: 0;
}

.diff-pane {
    flex: 1 1 50%;
    display: flex;
    min-height: 0;
    overflow-y: auto;
    &:first-of-type { border-bottom: 1px solid var(--vscode-panel-border); }
}

.diff-pane .line-numbers {
    flex-shrink: 0;
    padding: 8px 4px;
    line-height: 1.5;
    background-color: var(--vscode-editorGutter-background);
    color: var(--vscode-editorLineNumber-foreground);
    text-align: right;
    user-select: none;
    span { display: block; min-height: 1.5em; padding-right: 6px; }
}

.diff-pane .diff-lines {
    flex-grow: 1;
    min-width: 0;
}

.diff-pane .diff-lines .line {
    line-height: 1.5;
    padding-left: 8px;
    min-height: 1.5em;
    white-space: pre;
    &.added { background-color: var(--vscode-diffEditor-insertedTextBackground); }
    &.removed { background-color: var(--vscode-diffEditor-removedTextBackground); }
    &.placeholder { background-color: var(--vscode-editor-inactiveSelectionBackground); opacity: 0.5; }
    
    &.selected-diff {
        outline: 1px solid var(--vscode-focusBorder);
        outline-offset: -1px;
    }

    pre { margin: 0; padding: 0; }
}

.diff-detail-container {
    flex-shrink: 0;
    border-top: 1px solid var(--vscode-panel-border);
    display: flex;
    flex-direction: column;
}

.diff-detail-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 2px 8px;
    background-color: var(--vscode-sideBar-sectionHeaderBackground);
    font-size: 11px;
    .diff-nav-buttons {
        display: flex;
        gap: 8px;
        button {
            padding: 2px 6px;
            gap: 4px;
        }
    }
}

.diff-detail-panes {
    display: flex;
    max-height: 150px;
    overflow: auto;
}

.diff-detail-pane {
    flex: 1 1 50%;
    padding: 8px;
    white-space: pre-wrap;
    overflow-x: auto;
    font-family: var(--vscode-editor-font-family);
    font-size: var(--vscode-editor-font-size);
    &.removed { background-color: var(--vscode-diffEditor-removedTextBackground); }
    &.added { background-color: var(--vscode-diffEditor-insertedTextBackground); }
    &:first-child { border-right: 1px solid var(--vscode-panel-border); }

    .char-added { background-color: var(--vscode-diffEditor-insertedLineBackground); }
    .char-removed { background-color: var(--vscode-diffEditor-removedLineBackground); }
}
</file>

<file path="src/client/views/parallel-copilot.view/view.tsx">
// Updated on: C129 (Fix left pane not updating in diff, restore titles)
import * as React from 'react';
import * as ReactDOM from 'react-dom/client';
import './view.scss';
import { VscChevronLeft, VscChevronRight, VscWand, VscChevronDown, VscCheck, VscError, VscAdd, VscFileCode, VscDiff, VscArrowSwap, VscTrash, VscSync, VscClose } from 'react-icons/vsc';
import { logger } from '@/client/utils/logger';
import { ClientPostMessageManager } from '@/common/ipc/client-ipc';
import { ClientToServerChannel, ServerToClientChannel } from '@/common/ipc/channels.enum';
import { ParsedResponse } from '@/common/types/pcpp.types';
import { parseResponse } from '@/client/utils/response-parser';
import ReactMarkdown from 'react-markdown';
import DiffViewer from '@/client/components/DiffViewer';
import { PcppCycle, PcppResponse } from '@/common/types/pcpp.types';
import * as path from 'path-browserify';

const useDebounce = (callback: (...args: any[]) => void, delay: number) => {
    const timeoutRef = React.useRef<NodeJS.Timeout | null>(null);

    const debouncedFunction = React.useCallback((...args: any[]) => {
        if (timeoutRef.current) {
            clearTimeout(timeoutRef.current);
        }
        timeoutRef.current = setTimeout(() => {
            callback(...args);
        }, delay);
    }, [callback, delay]);

    return debouncedFunction;
};

const CodeViewer: React.FC<{ htmlContent: string | undefined | null }> = ({ htmlContent }) => {
    if (htmlContent === undefined || htmlContent === null) {
        return <div style={{ padding: '8px' }}>Select a file to view its content.</div>;
    }
    if (htmlContent.startsWith('// Error:')) {
         return <div style={{ padding: '8px', color: 'var(--vscode-errorForeground)' }}>{htmlContent}</div>;
    }

    const codeContentMatch = /<pre><code>([\s\S]*)<\/code><\/pre>/s.exec(htmlContent);
    const code = codeContentMatch ? codeContentMatch[1] : `<code>${htmlContent}</code>`; 

    const lines = code.split('\n');
    if (lines.length > 0 && lines[lines.length - 1] === '') {
        lines.pop();
    }

    return (
        <div className="file-content-viewer">
            <div className="line-numbers">
                {lines.map((_, i) => <span key={i}>{i + 1}</span>)}
            </div>
            <div className="code-content" dangerouslySetInnerHTML={{ __html: code }} />
        </div>
    );
};

interface TabState {
    rawContent: string;
    parsedContent: ParsedResponse | null;
}

const CollapsibleSection: React.FC<{ title: string; children: React.ReactNode; isCollapsed: boolean; onToggle: () => void; collapsedContent?: React.ReactNode; }> = ({ title, children, isCollapsed, onToggle, collapsedContent }) => (
    <div className="collapsible-section">
        <div className="collapsible-header" onClick={onToggle}>
            <div style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>
                <VscChevronDown className={`chevron ${isCollapsed ? 'collapsed' : ''}`} />
                <span>{title}</span>
            </div>
            {isCollapsed && collapsedContent}
        </div>
        {!isCollapsed && <div className="collapsible-content">{children}</div>}
    </div>
);

const App = () => {
    const [activeTab, setActiveTab] = React.useState(1);
    const [tabCount, setTabCount] = React.useState(4);
    const [currentCycle, setCurrentCycle] = React.useState(1);
    const [maxCycle, setMaxCycle] = React.useState(1);
    const [cycleTitle, setCycleTitle] = React.useState('');
    const [cycleContext, setCycleContext] = React.useState('');
    const [ephemeralContext, setEphemeralContext] = React.useState('');
    const [tabs, setTabs] = React.useState<{ [key: string]: TabState }>({});
    const [highlightedCodeBlocks, setHighlightedCodeBlocks] = React.useState<Map<string, string>>(new Map());
    const [fileExistenceMap, setFileExistenceMap] = React.useState<Map<string, boolean>>(new Map());
    const [isParsedMode, setIsParsedMode] = React.useState(false);
    const [selectedFilePath, setSelectedFilePath] = React.useState<string | null>(null);
    const [isCycleCollapsed, setIsCycleCollapsed] = React.useState(false);
    const [leftPaneWidth, setLeftPaneWidth] = React.useState(33);
    const [isDiffMode, setIsDiffMode] = React.useState(false);
    const [originalFileContent, setOriginalFileContent] = React.useState<string | null>(null);
    const isResizing = React.useRef(false);

    const clientIpc = ClientPostMessageManager.getInstance();

    const saveCurrentCycleState = React.useCallback((force = false) => {
        const responses: { [key: string]: PcppResponse } = {};
        for (let i = 1; i <= tabCount; i++) {
            responses[i.toString()] = { content: tabs[i.toString()]?.rawContent || '' };
        }
        const cycleData: PcppCycle = {
            cycleId: currentCycle,
            timestamp: new Date().toISOString(),
            title: cycleTitle,
            cycleContext,
            ephemeralContext,
            responses,
            isParsedMode,
            leftPaneWidth,
        };
        clientIpc.sendToServer(ClientToServerChannel.SaveCycleData, { cycleData });
    }, [currentCycle, cycleTitle, cycleContext, ephemeralContext, tabs, tabCount, isParsedMode, leftPaneWidth, clientIpc]);

    const debouncedSave = useDebounce(saveCurrentCycleState, 1000);

    React.useEffect(() => {
        debouncedSave();
    }, [cycleTitle, cycleContext, ephemeralContext, tabs, isParsedMode, leftPaneWidth, debouncedSave]);
    
    const parseAllTabs = React.useCallback(() => {
        setTabs(prevTabs => {
            const allFilePaths = new Set<string>();
            const updatedTabs = { ...prevTabs };
            let needsUpdate = false;
    
            Object.values(updatedTabs).forEach(tabState => {
                if (tabState.rawContent && !tabState.parsedContent) {
                    needsUpdate = true;
                    const parsed = parseResponse(tabState.rawContent);
                    tabState.parsedContent = parsed;
                    parsed.filesUpdated.forEach(file => allFilePaths.add(file));
                    parsed.files.forEach(file => {
                        const lang = path.extname(file.path).substring(1) || 'plaintext';
                        const id = `${file.path}::${file.content}`;
                        clientIpc.sendToServer(ClientToServerChannel.RequestSyntaxHighlight, { code: file.content, lang, id });
                    });
                }
            });
    
            if (allFilePaths.size > 0) {
                clientIpc.sendToServer(ClientToServerChannel.RequestFileExistence, { paths: Array.from(allFilePaths) });
            }
    
            return needsUpdate ? updatedTabs : prevTabs;
        });
    }, [clientIpc]);
    
    React.useEffect(() => {
        const loadCycleData = (cycleData: PcppCycle) => {
            setCurrentCycle(cycleData.cycleId);
            setCycleTitle(cycleData.title);
            setCycleContext(cycleData.cycleContext);
            setEphemeralContext(cycleData.ephemeralContext);
            const newTabs: { [key: string]: TabState } = {};
            Object.entries(cycleData.responses).forEach(([tabId, response]) => {
                newTabs[tabId] = { rawContent: response.content, parsedContent: null };
            });
            setTabs(newTabs);
            setIsParsedMode(cycleData.isParsedMode || false);
            setLeftPaneWidth(cycleData.leftPaneWidth || 33);
        };

        clientIpc.onServerMessage(ServerToClientChannel.SendLatestCycleData, ({ cycleData }) => {
            loadCycleData(cycleData);
            setMaxCycle(cycleData.cycleId);
        });
        clientIpc.onServerMessage(ServerToClientChannel.SendCycleData, ({ cycleData }) => {
            if (cycleData) {
                loadCycleData(cycleData);
            }
        });
        clientIpc.onServerMessage(ServerToClientChannel.SendSyntaxHighlight, ({ highlightedHtml, id }) => {
            setHighlightedCodeBlocks(prev => new Map(prev).set(id, highlightedHtml));
        });
        clientIpc.onServerMessage(ServerToClientChannel.SendFileExistence, ({ existenceMap }) => {
            setFileExistenceMap(new Map(Object.entries(existenceMap)));
        });
        clientIpc.onServerMessage(ServerToClientChannel.SendFileContent, ({ path: filePath, content }) => {
            setOriginalFileContent(content);
        });
        clientIpc.onServerMessage(ServerToClientChannel.ForceRefresh, ({ reason }) => {
            if (reason === 'history') {
                logger.log("History change detected, requesting latest cycle data.");
                clientIpc.sendToServer(ClientToServerChannel.RequestLatestCycleData, {});
            }
        });
        
        clientIpc.sendToServer(ClientToServerChannel.RequestLatestCycleData, {});
    }, [clientIpc]);

    React.useEffect(() => {
        if (isParsedMode) {
            parseAllTabs();
        }
    }, [isParsedMode, tabs, parseAllTabs]);
    
    const activeTabData = tabs[activeTab.toString()];

    const viewableContent = React.useMemo(() => {
        if (!selectedFilePath || !activeTabData?.parsedContent) return undefined;
        const file = activeTabData.parsedContent.files.find(f => f.path === selectedFilePath);
        if (!file) return '<div>Error: File data not found in parsed response.</div>';
        const id = `${file.path}::${file.content}`;
        return highlightedCodeBlocks.get(id);
    }, [selectedFilePath, activeTabData?.parsedContent, highlightedCodeBlocks]);


    const handleRawContentChange = (newContent: string, tabIndex: number) => {
        setTabs(prev => ({ ...prev, [tabIndex.toString()]: { rawContent: newContent, parsedContent: null }}));
    };

    const handleGlobalParseToggle = () => {
        const newParseMode = !isParsedMode;
        setIsParsedMode(newParseMode);
        setSelectedFilePath(null);
        setIsDiffMode(false);
        if (!newParseMode) {
            setTabs(prev => {
                const newTabs = {...prev};
                Object.keys(newTabs).forEach(key => {
                    newTabs[key].parsedContent = null;
                });
                return newTabs;
            });
        }
    };

    const handleCycleChange = (e: React.MouseEvent, newCycle: number) => {
        e.stopPropagation();
        if (newCycle > 0 && newCycle <= maxCycle) {
            saveCurrentCycleState(true);
            setCurrentCycle(newCycle);
            clientIpc.sendToServer(ClientToServerChannel.RequestCycleData, { cycleId: newCycle });
        }
    };

    const handleNewCycle = (e: React.MouseEvent) => {
        e.stopPropagation();
        const newCycleId = maxCycle + 1;
        setMaxCycle(newCycleId);
        setCurrentCycle(newCycleId);
        setCycleTitle('New Cycle');
        setCycleContext('');
        setEphemeralContext('');
        setTabs({});
        setIsParsedMode(false);
    };
    
    const handleGeneratePrompt = () => {
        clientIpc.sendToServer(ClientToServerChannel.RequestCreatePromptFile, { cycleTitle, currentCycle });
    };

    const handleMouseDown = React.useCallback((e: React.MouseEvent) => {
        e.preventDefault();
        isResizing.current = true;
    }, []);

    const handleMouseMove = React.useCallback((e: MouseEvent) => {
        if (!isResizing.current) return;
        const newWidth = (e.clientX / window.innerWidth) * 100;
        if (newWidth > 10 && newWidth < 90) {
            setLeftPaneWidth(newWidth);
        }
    }, []);

    const handleMouseUp = React.useCallback(() => {
        isResizing.current = false;
    }, []);

    React.useEffect(() => {
        const mm = (e: MouseEvent) => handleMouseMove(e);
        const mu = () => handleMouseUp();
        window.addEventListener('mousemove', mm);
        window.addEventListener('mouseup', mu);
        
        return () => {
            window.removeEventListener('mousemove', mm);
            window.removeEventListener('mouseup', mu);
        };
    }, [handleMouseMove, handleMouseUp]);
    
    const handleSelectForViewing = (filePath: string) => {
        const newPath = selectedFilePath === filePath ? null : filePath;
        setSelectedFilePath(newPath);
        if (isDiffMode && newPath) {
            clientIpc.sendToServer(ClientToServerChannel.RequestFileContent, { path: newPath });
        }
    };

    const handleDeleteCycle = () => {
        clientIpc.sendToServer(ClientToServerChannel.RequestDeleteCycle, { cycleId: currentCycle });
    };

    const handleResetHistory = () => {
        clientIpc.sendToServer(ClientToServerChannel.RequestResetHistory, {});
    };

    const isNewCycleButtonDisabled = React.useMemo(() => {
        const hasTitle = cycleTitle && cycleTitle.trim() !== 'New Cycle' && cycleTitle.trim() !== '';
        const hasContext = cycleContext.trim() || ephemeralContext.trim();
        const hasResponseContent = Object.values(tabs).some(t => t.rawContent.trim());
        return !hasTitle && !hasContext && !hasResponseContent;
    }, [cycleTitle, cycleContext, ephemeralContext, tabs]);

    const collapsedNavigator = (
        <div className="collapsed-navigator">
            <button onClick={(e) => handleCycleChange(e, currentCycle - 1)} disabled={currentCycle <= 1}><VscChevronLeft /></button>
            <span className="cycle-display">C{currentCycle}</span>
            <button onClick={(e) => handleCycleChange(e, currentCycle + 1)} disabled={currentCycle >= maxCycle}><VscChevronRight /></button>
        </div>
    );

    const renderContent = () => {
        if (!isParsedMode || !activeTabData?.parsedContent) {
            return <textarea className="response-textarea" placeholder={`Paste AI response for tab ${activeTab} here...`} value={activeTabData?.rawContent || ''} onChange={(e) => handleRawContentChange(e.target.value, activeTab)} />;
        }

        if (isDiffMode) {
            return (
                <div className="parsed-view-grid">
                    <div className="parsed-view-left" style={{ flexBasis: `${leftPaneWidth}%` }}>
                        <CollapsibleSection title="Associated Files" isCollapsed={false} onToggle={() => {}}>
                            <ul className="associated-files-list">
                                {activeTabData.parsedContent.filesUpdated.map(file => (
                                    <li key={file} className={selectedFilePath === file ? 'selected' : ''} onClick={() => handleSelectForViewing(file)} title={file}>
                                        {fileExistenceMap.get(file) ? <VscCheck className="status-icon exists" /> : <VscError className="status-icon not-exists" />}
                                        <span>{file}</span>
                                    </li>
                                ))}
                            </ul>
                        </CollapsibleSection>
                        <CollapsibleSection title="Thoughts / Response" isCollapsed={false} onToggle={() => {}}><ReactMarkdown>{activeTabData.parsedContent.summary}</ReactMarkdown></CollapsibleSection>
                        <CollapsibleSection title="Course of Action" isCollapsed={false} onToggle={() => {}}><ReactMarkdown>{activeTabData.parsedContent.courseOfAction}</ReactMarkdown></CollapsibleSection>
                        <button className="exit-diff-button" onClick={() => setIsDiffMode(false)}><VscClose/> Back to Code</button>
                    </div>
                    <div className="resizer" onMouseDown={handleMouseDown} />
                    <div className="parsed-view-right">
                         {activeTabData.parsedContent && selectedFilePath && originalFileContent !== null ? (
                            <DiffViewer 
                                original={{ content: originalFileContent, path: selectedFilePath }}
                                modified={{ content: activeTabData.parsedContent.files.find(f => f.path === selectedFilePath)?.content || '', path: `Response ${activeTab}: ${selectedFilePath}` }}
                            />
                        ) : (
                            <div style={{ padding: '8px' }}>Select a file to view diff.</div>
                        )}
                    </div>
                </div>
            );
        }

        return (
            <div className="parsed-view-grid">
                <div className="parsed-view-left" style={{ flexBasis: `${leftPaneWidth}%` }}>
                    <CollapsibleSection title="Associated Files" isCollapsed={false} onToggle={() => {}}>
                        <ul className="associated-files-list">
                            {activeTabData.parsedContent.filesUpdated.map(file => (
                                <li key={file} className={selectedFilePath === file ? 'selected' : ''} onClick={() => handleSelectForViewing(file)} title={file}>
                                    {fileExistenceMap.get(file) ? <VscCheck className="status-icon exists" /> : <VscError className="status-icon not-exists" />}
                                    <span>{file}</span>
                                </li>
                            ))}
                        </ul>
                    </CollapsibleSection>
                    <CollapsibleSection title="Thoughts / Response" isCollapsed={false} onToggle={() => {}}><ReactMarkdown>{activeTabData.parsedContent.summary}</ReactMarkdown></CollapsibleSection>
                    <CollapsibleSection title="Course of Action" isCollapsed={false} onToggle={() => {}}><ReactMarkdown>{activeTabData.parsedContent.courseOfAction}</ReactMarkdown></CollapsibleSection>
                </div>
                <div className="resizer" onMouseDown={handleMouseDown} />
                <div className="parsed-view-right">
                    <div className="file-content-viewer-header">
                        <span className="file-path" title={selectedFilePath || ''}>{selectedFilePath ? `Response ${activeTab}: ${path.basename(selectedFilePath)}` : 'No file selected'}</span>
                        <div className="file-actions">
                            <button onClick={() => { if (selectedFilePath) { setIsDiffMode(true); clientIpc.sendToServer(ClientToServerChannel.RequestFileContent, { path: selectedFilePath }); } }} disabled={!selectedFilePath} title="View Diff"><VscDiff /></button>
                            <button disabled={!selectedFilePath} title="Swap with Workspace File"><VscArrowSwap /></button>
                        </div>
                    </div>
                    <div className="code-viewer-wrapper">
                        <CodeViewer htmlContent={viewableContent} />
                    </div>
                </div>
            </div>
        );
    };

    return (
        <div className="pc-view-container">
            <div className="pc-header">
                <div className="pc-toolbar">
                    <button onClick={handleGeneratePrompt} title="Generate prompt.md"><VscFileCode /> Generate prompt.md</button>
                    <button onClick={handleGlobalParseToggle}><VscWand /> {isParsedMode ? 'Un-Parse All' : 'Parse All'}</button>
                </div>
                <div className="tab-count-input">
                    <label htmlFor="tab-count">Responses:</label>
                    <input type="number" id="tab-count" min="1" max="20" value={tabCount} onChange={e => setTabCount(parseInt(e.target.value, 10) || 1)} />
                </div>
            </div>

            <CollapsibleSection title="Cycle & Context" isCollapsed={isCycleCollapsed} onToggle={() => setIsCycleCollapsed(p => !p)} collapsedContent={collapsedNavigator}>
                <div className="cycle-navigator">
                    <span>Cycle:</span>
                    <button onClick={(e) => handleCycleChange(e, currentCycle - 1)} disabled={currentCycle <= 1}><VscChevronLeft /></button>
                    <input type="number" value={currentCycle} onChange={e => setCurrentCycle(parseInt(e.target.value, 10) || 1)} className="cycle-input" />
                    <button onClick={(e) => handleCycleChange(e, currentCycle + 1)} disabled={currentCycle >= maxCycle}><VscChevronRight /></button>
                    <button onClick={handleNewCycle} title="New Cycle" disabled={isNewCycleButtonDisabled}><VscAdd /></button>
                    <input type="text" className="cycle-title-input" placeholder="Cycle Title..." value={cycleTitle} onChange={e => setCycleTitle(e.target.value)} />
                    <button onClick={handleDeleteCycle} title="Delete Current Cycle"><VscTrash /></button>
                    <button onClick={handleResetHistory} title="Reset All History"><VscSync /></button>
                </div>
                <div className="context-inputs">
                    <textarea className="context-textarea" placeholder="Cycle Context (notes for this cycle)..." value={cycleContext} onChange={e => setCycleContext(e.target.value)} />
                    <textarea className="context-textarea" placeholder="Ephemeral Context (for this cycle's prompt only)..." value={ephemeralContext} onChange={e => setEphemeralContext(e.target.value)} />
                </div>
            </CollapsibleSection>

            <div className="tab-bar">
                {[...Array(tabCount)].map((_, i) => <div key={i} className={`tab ${activeTab === i + 1 ? 'active' : ''}`} onClick={() => setActiveTab(i + 1)}>Resp {i + 1}</div>)}
            </div>

            <div className="tab-content">
                {activeTab !== null && (
                    <div className="tab-pane">
                        {renderContent()}
                    </div>
                )}
            </div>
        </div>
    );
};

const root = ReactDOM.createRoot(document.getElementById('root')!);
root.render(<App />);
</file>

<file path="src/common/ipc/channels.enum.ts">
export enum ClientToServerChannel {
    RequestInitialData = "clientToServer.requestInitialData",
    RequestFlattenContext = "clientToServer.requestFlattenContext",
    RequestWorkspaceFiles = "clientToServer.requestWorkspaceFiles",
    LogMessage = "clientToServer.logMessage",

    // File Operations
    RequestNewFile = "clientToServer.requestNewFile",
    RequestNewFolder = "clientToServer.requestNewFolder",
    RequestFileRename = "clientToServer.requestFileRename",
    RequestFileDelete = "clientToServer.requestFileDelete",
    RequestBatchFileDelete = "clientToServer.requestBatchFileDelete",
    RequestRevealInExplorer = "clientToServer.requestRevealInExplorer",
    RequestCopyPath = "clientToServer.requestCopyPath",
    RequestOpenFile = "clientToServer.requestOpenFile",
    RequestMoveFile = "clientToServer.requestMoveFile",
    RequestCopyFile = "clientToServer.requestCopyFile",
    RequestUndo = "clientToServer.requestUndo",
    RequestRedo = "clientToServer.requestRedo",
    RequestAddFileFromBuffer = "clientToServer.requestAddFileFromBuffer",
    RequestCopyFileFromUri = "clientToServer.requestCopyFileFromUri",
    RequestFileContent = "clientToServer.requestFileContent",

    // Special File Handling
    RequestPdfToText = "clientToServer.requestPdfToText",
    RequestExcelToText = "clientToServer.requestExcelToText",
    RequestWordToText = "clientToServer.requestWordToText",

    // Selection Persistence
    SaveCurrentSelection = "clientToServer.saveCurrentSelection",
    RequestLastSelection = "clientToServer.requestLastSelection",
    SaveAutoAddState = "clientToServer.saveAutoAddState",

    // VS Code Command Proxy
    VSCodeCommand = "clientToServer.vscodeCommand",

    // Phase 2: PCPP
    RequestCreatePromptFile = "clientToServer.requestCreatePromptFile",
    RequestFileExistence = "clientToServer.requestFileExistence",
    RequestSyntaxHighlight = "clientToServer.requestSyntaxHighlight",
    RequestLatestCycleData = "clientToServer.requestLatestCycleData",
    RequestCycleData = "clientToServer.requestCycleData",
    SaveCycleData = "clientToServer.saveCycleData",
    RequestDeleteCycle = "clientToServer.requestDeleteCycle",
    RequestResetHistory = "clientToServer.requestResetHistory",
}

export enum ServerToClientChannel {
    SendWorkspaceFiles = "serverToClient.sendWorkspaceFiles",
    SendWorkspaceTrustState = "serverToClient.sendWorkspaceTrustState",
    ApplySelectionSet = "serverToClient.applySelectionSet",
    SendSelectionSets = "serverToClient.sendSelectionSets",
    ForceRefresh = "serverToClient.forceRefresh",
    SetActiveFile = "serverToClient.setActiveFile",
    FocusFile = "serverToClient.focusFile",
    SendAutoAddState = "serverToClient.sendAutoAddState",
    UpdateProblemCounts = "serverToClient.updateProblemCounts",
    UpdateNodeStats = "serverToClient.updateNodeStats",
    SendFileContent = "serverToClient.sendFileContent",
    
    // Phase 2: PCPP
    SendFileExistence = "serverToClient.sendFileExistence",
    SendSyntaxHighlight = "serverToClient.sendSyntaxHighlight",
    SendLatestCycleData = "serverToClient.sendLatestCycleData",
    SendCycleData = "serverToClient.sendCycleData",
}
</file>

<file path="src/common/ipc/channels.type.ts">
import { FileNode } from "@/common/types/file-node";
import { ClientToServerChannel, ServerToClientChannel } from "./channels.enum";
import { PcppCycle } from "@/common/types/pcpp.types";

export type SelectionSet = { [name: string]: string[] };
export type ProblemCountsMap = { [path: string]: { error: number; warning: number; } };

export type ChannelBody<T extends ClientToServerChannel | ServerToClientChannel> =
    T extends ClientToServerChannel.RequestInitialData ? {} :
    T extends ClientToServerChannel.RequestFlattenContext ? { selectedPaths: string[] } :
    T extends ClientToServerChannel.RequestWorkspaceFiles ? { force?: boolean } :
    T extends ClientToServerChannel.LogMessage ? { level: 'info' | 'warn' | 'error', message: string } :
    T extends ClientToServerChannel.RequestNewFile ? { parentDirectory: string } :
    T extends ClientToServerChannel.RequestNewFolder ? { parentDirectory: string } :
    T extends ClientToServerChannel.RequestFileRename ? { oldPath: string, newName: string } :
    T extends ClientToServerChannel.RequestFileDelete ? { path: string } :
    T extends ClientToServerChannel.RequestBatchFileDelete ? { paths: string[] } :
    T extends ClientToServerChannel.RequestRevealInExplorer ? { path: string } :
    T extends ClientToServerChannel.RequestCopyPath ? { path: string, relative: boolean } :
    T extends ClientToServerChannel.RequestOpenFile ? { path: string } :
    T extends ClientToServerChannel.RequestFileContent ? { path: string } :
    T extends ClientToServerChannel.RequestMoveFile ? { oldPath: string, newPath: string } :
    T extends ClientToServerChannel.RequestCopyFile ? { sourcePath: string, destinationDir: string } :
    T extends ClientToServerChannel.RequestUndo ? {} :
    T extends ClientToServerChannel.RequestRedo ? {} :
    T extends ClientToServerChannel.RequestAddFileFromBuffer ? { targetPath: string, data: Uint8Array } :
    T extends ClientToServerChannel.RequestCopyFileFromUri ? { sourceUri: string, targetDir: string } :
    T extends ClientToServerChannel.RequestPdfToText ? { path: string } :
    T extends ClientToServerChannel.RequestExcelToText ? { path: string } :
    T extends ClientToServerChannel.RequestWordToText ? { path: string } :
    T extends ClientToServerChannel.SaveCurrentSelection ? { paths: string[] } :
    T extends ClientToServerChannel.RequestLastSelection ? {} :
    T extends ClientToServerChannel.SaveAutoAddState ? { enabled: boolean } :
    T extends ClientToServerChannel.VSCodeCommand ? { command: string, args?: any[] } :
    T extends ClientToServerChannel.RequestCreatePromptFile ? { cycleTitle: string; currentCycle: number } :
    T extends ClientToServerChannel.RequestFileExistence ? { paths: string[] } :
    T extends ClientToServerChannel.RequestSyntaxHighlight ? { code: string; lang: string, id: string } :
    T extends ClientToServerChannel.RequestLatestCycleData ? {} :
    T extends ClientToServerChannel.RequestCycleData ? { cycleId: number } :
    T extends ClientToServerChannel.SaveCycleData ? { cycleData: PcppCycle } :
    T extends ClientToServerChannel.RequestDeleteCycle ? { cycleId: number } :
    T extends ClientToServerChannel.RequestResetHistory ? {} :
    
    T extends ServerToClientChannel.SendWorkspaceFiles ? { files: FileNode[] } :
    T extends ServerToClientChannel.SendWorkspaceTrustState ? { isTrusted: boolean } :
    T extends ServerToClientChannel.ApplySelectionSet ? { paths: string[] } :
    T extends ServerToClientChannel.SendSelectionSets ? { sets: SelectionSet } :
    T extends ServerToClientChannel.ForceRefresh ? { reason?: 'fileOp' | 'manual' | 'history' } :
    T extends ServerToClientChannel.SetActiveFile ? { path: string } :
    T extends ServerToClientChannel.FocusFile ? { path: string } :
    T extends ServerToClientChannel.SendAutoAddState ? { enabled: boolean } :
    T extends ServerToClientChannel.UpdateProblemCounts ? { problemMap: ProblemCountsMap } :
    T extends ServerToClientChannel.UpdateNodeStats ? { path: string, tokenCount: number, error?: string } :
    T extends ServerToClientChannel.SendFileContent ? { path: string, content: string | null } :
    T extends ServerToClientChannel.SendFileExistence ? { existenceMap: { [path: string]: boolean } } :
    T extends ServerToClientChannel.SendSyntaxHighlight ? { highlightedHtml: string, id: string } :
    T extends ServerToClientChannel.SendLatestCycleData ? { cycleData: PcppCycle } :
    T extends ServerToClientChannel.SendCycleData ? { cycleData: PcppCycle | null } :
    never;
</file>

<file path="src/common/ipc/client-ipc.ts">
// Updated on: C118 (Add getVscodeApi method)
import getVscode from "./get-vscode-api";
import { ClientToServerChannel, ServerToClientChannel } from "./channels.enum";
import { ChannelBody } from "./channels.type";
import { WebviewApi, ViewState } from "../types/vscode-webview";

export class ClientPostMessageManager {
    private static _instance?: ClientPostMessageManager;
    private _listeners: {
        channel: ServerToClientChannel,
        callback: (body: ChannelBody<ServerToClientChannel>) => void
    }[];

    private constructor() {
        this._listeners = [];
        window.addEventListener('message', (event: MessageEvent) => {
            const data = event.data;
            this._listeners.forEach((listener) => {
                if (listener.channel === data.channel) {
                    listener.callback(data.body);
                }
            });
        });
    }

    static getInstance(): ClientPostMessageManager {
        if (!ClientPostMessageManager._instance) {
            ClientPostMessageManager._instance = new ClientPostMessageManager();
        }
        return ClientPostMessageManager._instance;
    }

    public getVscodeApi(): WebviewApi<ViewState> {
        return getVscode();
    }

    sendToServer<T extends ClientToServerChannel>(channel: T, body: ChannelBody<T>): void {
        this.getVscodeApi().postMessage({ channel, body });
    }

    onServerMessage<T extends ServerToClientChannel>(channel: T, callback: (body: ChannelBody<T>) => void): void {
        this._listeners.push({ channel, callback: callback as any });
    }
}
</file>

<file path="src/common/ipc/get-vscode-api.ts">
import { WebviewApi } from "../types/vscode-webview";

let vscode: WebviewApi<unknown> | null = null;

const getVscode = () => {
    if (!vscode) {
        vscode = acquireVsCodeApi();
    }
    return vscode;
};

export default getVscode;
</file>

<file path="src/common/ipc/server-ipc.ts">
import { ClientToServerChannel, ServerToClientChannel } from "./channels.enum";
import { ChannelBody } from "./channels.type";

export class ServerPostMessageManager {
    private static _instance?: ServerPostMessageManager;
    private _listeners: {
        channel: ClientToServerChannel,
        callback: (body: ChannelBody<ClientToServerChannel>) => void
    }[];

    private constructor(
        private onMessage: (data: any) => void,
        private sendMessage: (message: any) => void
    ) {
        this._listeners = [];
        this.onMessage((data: any) => {
            this._listeners.forEach((listener) => {
                if (listener.channel === data.channel) {
                    listener.callback(data.body);
                }
            });
        });
    }

    static getInstance(onMessage?: (data: any) => void, sendMessage?: (message: any) => void) {
        if (onMessage && sendMessage) {
            ServerPostMessageManager._instance = new ServerPostMessageManager(onMessage, sendMessage);
        }
        if (!ServerPostMessageManager._instance) {
            throw new Error("ServerPostMessageManager not initialized");
        }
        return ServerPostMessageManager._instance;
    }

    sendToClient<T extends ServerToClientChannel>(channel: T, body: ChannelBody<T>): void {
        this.sendMessage({ channel, body });
    }

    onClientMessage<T extends ClientToServerChannel>(channel: T, callback: (body: ChannelBody<T>) => void): void {
        this._listeners.push({ channel, callback: callback as any });
    }
}
</file>

<file path="src/common/types/file-node.ts">
export interface FileNode {
    name: string;
    absolutePath: string;
    children?: FileNode[];
    tokenCount: number;
    fileCount: number; // For directories, this is the count of files inside. For files, it's 1.
    isImage: boolean;
    sizeInBytes: number;
    extension: string;
    isPdf: boolean;
    isExcel: boolean;
    isWordDoc: boolean; // New
    gitStatus?: string; // e.g., 'M', 'U', 'A', 'D', 'C'
    problemCounts?: { error: number; warning: number; };
    error?: string; // To store processing errors, e.g., "File not found"
}
</file>

<file path="src/common/types/pcpp.types.ts">
// src/common/types/pcpp.types.ts

// Data structure for the backend history file
export interface PcppResponse {
    content: string;
}

export interface PcppCycle {
    cycleId: number;
    timestamp: string;
    title: string;
    cycleContext: string;
    ephemeralContext: string;
    responses: { [tabId: string]: PcppResponse };
    isParsedMode?: boolean; // This will now be managed per-cycle
    leftPaneWidth?: number;
}

export interface PcppHistoryFile {
    version: number;
    cycles: PcppCycle[];
}


// Data structure for the frontend parsed response
export interface ParsedFile {
    path: string;
    content: string;
}

export interface ParsedResponse {
    summary: string;
    courseOfAction: string;
    filesUpdated: string[]; // List of file paths from the "Files Updated This Cycle" section
    files: ParsedFile[]; // Parsed file blocks with content
}
</file>

<file path="src/common/types/vscode-webview.d.ts">
// Updated on: C118 (Add pcppLeftPaneWidth to ViewState)
export interface WebviewApi<StateType> {
    postMessage(message: unknown): void;
    getState(): StateType | undefined;
    setState<T extends StateType | undefined>(newState: T): T;
}

export interface ViewState {
    selectedFiles?: string[];
    pcppLeftPaneWidth?: number;
}

declare global {
    function acquireVsCodeApi<StateType = ViewState>(): WebviewApi<StateType>;
}
</file>

<file path="src/common/utils/formatting.ts">
// src/common/utils/formatting.ts

const KMBT_SUFFIXES = ['', 'K', 'M', 'B', 'T', 'Q']; // Extend as needed

/**
 * Formats a large number with appropriate K/M/B/T suffixes and dynamic decimal places.
 *
 * @param value The number to format.
 * @param decimalPlaces The base number of decimal places to aim for.
 * @returns A formatted string.
 */
export function formatLargeNumber(value: number | undefined | null, decimalPlaces: number = 1): string {
    if (value === null || value === undefined || isNaN(value) || !Number.isFinite(value)) {
        return '---';
    }
    if (value === 0) {
        return '0';
    }

    const isNegative = value < 0;
    const absValue = Math.abs(value);

    if (absValue < 1000) {
        return String(Math.round(value)); // Return whole number if less than 1000
    }

    let unitIndex = 0;
    let scaledValue = absValue;

    unitIndex = Math.floor(Math.log10(absValue) / 3);
    unitIndex = Math.min(unitIndex, KMBT_SUFFIXES.length - 1);
    scaledValue = absValue / Math.pow(1000, unitIndex);

    let adjustedDecimalPlaces = decimalPlaces;
    if (scaledValue >= 100) adjustedDecimalPlaces = 0;
    else if (scaledValue >= 10) adjustedDecimalPlaces = 1;
    else adjustedDecimalPlaces = 2;


    const unit = KMBT_SUFFIXES[unitIndex] ?? '';
    let formattedValue = scaledValue.toFixed(adjustedDecimalPlaces);
    
    // Remove trailing .00 or .0
    if (adjustedDecimalPlaces > 0 && formattedValue.endsWith('0')) {
        formattedValue = formattedValue.replace(/\.?0+$/, '');
    }


    return `${isNegative ? '-' : ''}${formattedValue}${unit}`;
}

/**
 * Formats a number with commas as thousands separators.
 * @param value The number to format.
 * @returns A formatted string with commas.
 */
export function formatNumberWithCommas(value: number | undefined | null): string {
    if (value === null || value === undefined || isNaN(value)) {
        return '---';
    }
    return value.toLocaleString();
}

/**
 * Formats a file size in bytes into a human-readable string (KB, MB, GB, etc.).
 * @param bytes The number of bytes.
 * @param decimals The number of decimal places to use.
 * @returns A formatted string representing the file size.
 */
export function formatBytes(bytes: number, decimals: number = 1): string {
    if (bytes === 0) return '0 Bytes';
    if (isNaN(bytes)) return '---';

    const k = 1024;
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];

    const i = Math.floor(Math.log(bytes) / Math.log(k));

    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
}

/**
 * Truncates a long string for logging purposes.
 * @param str The string to truncate.
 * @param maxLength The total maximum length of the output string.
 * @returns A truncated string in the format "start...end".
 */
export function truncateStringForLogging(str: string, maxLength: number = 100): string {
    if (str.length <= maxLength) {
        return str;
    }
    const halfLength = Math.floor((maxLength - 3) / 2);
    return `${str.substring(0, halfLength)}...${str.substring(str.length - halfLength)}`;
}
</file>

<file path="src/common/utils/view-html.ts">
import * as vscode from "vscode";

export function getViewHtml({ webview, nonce, scriptUri, styleUris = [] }: { webview: vscode.Webview; nonce: string; scriptUri: string; styleUris?: vscode.Uri[]; }): string {
    const styles = styleUris.map(uri => `<link href="${uri}" rel="stylesheet">`).join('\n');
    
    return `<!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src ${webview.cspSource}; script-src 'nonce-${nonce}';">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            ${styles}
        </head>
        <body>
            <div id="root"></div>
            <script nonce="${nonce}" src="${scriptUri}"></script>
        </body>
        </html>`;
}

function getNonce() {
    let text = "";
    const possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    for (let i = 0; i < 32; i++) {
        text += possible.charAt(Math.floor(Math.random() * possible.length));
    }
    return text;
}
export { getNonce };
</file>

<file path="src/common/view-types.ts">
export const VIEW_TYPES = {
  SIDEBAR: {
    CONTEXT_CHOOSER: "viewType.sidebar.contextChooser",
  },
  PANEL: {
    PARALLEL_COPILOT: "viewType.panel.parallelCopilot",
  }
};
</file>

<file path="src/extension.ts">
import * as vscode from "vscode";
import { registerViews, serverIPCs } from "./client/views";
import { registerCommands } from "./backend/commands/register-commands";
import { Services } from "./backend/services/services";
import { VIEW_TYPES } from "./common/view-types";
import { ServerToClientChannel } from "./common/ipc/channels.enum";
import { API as GitAPI, GitExtension } from "./backend/types/git";
import { getNonce, getViewHtml } from "./common/utils/view-html";
import { onMessage as onParallelCopilotMessage } from "./client/views/parallel-copilot.view/on-message";
import { ServerPostMessageManager } from "./common/ipc/server-ipc";

let globalContext: vscode.ExtensionContext | null = null;
let parallelCopilotPanel: vscode.WebviewPanel | undefined;

function createOrShowParallelCopilotPanel(context: vscode.ExtensionContext) {
    const column = vscode.window.activeTextEditor?.viewColumn;

    if (parallelCopilotPanel) {
        parallelCopilotPanel.reveal(column);
        return;
    }

    parallelCopilotPanel = vscode.window.createWebviewPanel(
        VIEW_TYPES.PANEL.PARALLEL_COPILOT,
        'DCE Parallel Co-Pilot',
        column || vscode.ViewColumn.One,
        {
            enableScripts: true,
            localResourceRoots: [context.extensionUri],
        }
    );
    
    const scriptUri = parallelCopilotPanel.webview.asWebviewUri(vscode.Uri.joinPath(context.extensionUri, "dist", "parallelCopilotView.js"));
    const styleUri = parallelCopilotPanel.webview.asWebviewUri(vscode.Uri.joinPath(context.extensionUri, "dist", "parallelCopilotView.css"));
    const starryNightStyleUri = parallelCopilotPanel.webview.asWebviewUri(vscode.Uri.joinPath(context.extensionUri, "dist", "starry-night.css"));
    const nonce = getNonce();
    
    parallelCopilotPanel.webview.html = getViewHtml({
        webview: parallelCopilotPanel.webview,
        nonce,
        scriptUri: scriptUri.toString(),
        styleUris: [styleUri, starryNightStyleUri],
    });
    
    const serverIpc = ServerPostMessageManager.getInstance(
        parallelCopilotPanel.webview.onDidReceiveMessage,
        (data: any) => parallelCopilotPanel?.webview.postMessage(data)
    );

    serverIPCs[VIEW_TYPES.PANEL.PARALLEL_COPILOT] = serverIpc;
    onParallelCopilotMessage(serverIpc);

    parallelCopilotPanel.onDidDispose(() => {
        parallelCopilotPanel = undefined;
    }, null, context.subscriptions);
}

export async function activate(context: vscode.ExtensionContext) {
    Services.loggerService.log('Congratulations, your extension "Data Curation Environment" is now active!');
    globalContext = context;

    let gitApi: GitAPI | undefined;
    try {
        const gitExtension = vscode.extensions.getExtension<GitExtension>('vscode.git');
        if (gitExtension) {
            await gitExtension.activate();
            gitApi = gitExtension.exports.getAPI(1);
        }
    } catch (error) {
        Services.loggerService.error(`Failed to get Git API: ${error}`);
    }

    try {
        Services.initialize(gitApi);
        registerCommands(context);
        context.subscriptions.push(vscode.commands.registerCommand('dce.showParallelCopilot', () => {
            createOrShowParallelCopilotPanel(context);
        }));
        registerViews(context);
    } catch (error: any) {
        Services.loggerService.error(`CRITICAL - Error during activation: ${error.message}`);
        vscode.window.showErrorMessage("Data Curation Environment failed to activate.");
        return;
    }
    
    const updateActiveFile = () => {
        let fileUri: vscode.Uri | undefined;
        const activeEditor = vscode.window.activeTextEditor;
        if (activeEditor?.document.uri.scheme === 'file') {
            fileUri = activeEditor.document.uri;
        } else {
            const tabInput = vscode.window.tabGroups.activeTabGroup.activeTab?.input as { uri?: vscode.Uri };
            if (tabInput?.uri?.scheme === 'file') fileUri = tabInput.uri;
        }

        if (fileUri) {
            const serverIpc = serverIPCs[VIEW_TYPES.SIDEBAR.CONTEXT_CHOOSER];
            if (serverIpc) {
                serverIpc.sendToClient(ServerToClientChannel.SetActiveFile, { path: fileUri.fsPath.replace(/\\/g, '/') });
            }
        }
    };

    context.subscriptions.push(
        vscode.window.onDidChangeActiveTextEditor(updateActiveFile),
        vscode.window.tabGroups.onDidChangeTabs(updateActiveFile),
        vscode.workspace.onDidGrantWorkspaceTrust(() => {
            const serverIpc = serverIPCs[VIEW_TYPES.SIDEBAR.CONTEXT_CHOOSER];
            if (serverIpc) serverIpc.sendToClient(ServerToClientChannel.SendWorkspaceTrustState, { isTrusted: true });
        })
    );

    setTimeout(updateActiveFile, 500);
}

export function getContext() {
    if (!globalContext) throw new Error("Extension context not available.");
    return globalContext;
}

export function deactivate() {}
</file>

<file path="The-Creator-AI-main/.eslintrc.json">
{
    "root": true,
    "parser": "@typescript-eslint/parser",
    "parserOptions": {
        "ecmaVersion": 6,
        "sourceType": "module"
    },
    "plugins": [
        "@typescript-eslint"
    ],
    "rules": {
        "@typescript-eslint/naming-convention": [
            "warn",
            {
                "selector": "import",
                "format": [ "camelCase", "PascalCase" ]
            }
        ],
        "@typescript-eslint/semi": "warn",
        "curly": "warn",
        "eqeqeq": "warn",
        "no-throw-literal": "warn",
        "semi": "off"
    },
    "ignorePatterns": [
        "out",
        "dist",
        "**/*.d.ts"
    ]
}
</file>

<file path="The-Creator-AI-main/.gitignore">
.DS_Store
out
dist
node_modules
.vscode-test/
*.vsix
*.llm
*.code-workspace
</file>

<file path="The-Creator-AI-main/.vscode-test.mjs">
import { defineConfig } from '@vscode/test-cli';

export default defineConfig({
	files: 'out/test/**/*.test.js',
});
</file>

<file path="The-Creator-AI-main/.vscodeignore">
.vscode/**
.vscode-test/**
out/**
node_modules/**
src/**
.gitignore
.yarnrc
webpack.config.js
vsc-extension-quickstart.md
**/tsconfig.json
**/.eslintrc.json
**/*.map
**/*.ts
**/.vscode-test.*
</file>

<file path="The-Creator-AI-main/CHANGELOG.md">
# Change Log

All notable changes to the "the-creator-ai" extension will be documented in this file.

Check [Keep a Changelog](http://keepachangelog.com/) for recommendations on how to structure this file.

## [Unreleased]

- Initial release
</file>

<file path="The-Creator-AI-main/LICENSE">
MIT License

Copyright (c) 2024 Saoud Rizwan

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="The-Creator-AI-main/Notes.md">
[Notes](https://github.com/The-Creator-AI/The-Creator-AI/issues/4)
</file>

<file path="The-Creator-AI-main/package.json">
{
  "name": "the-creator-ai",
  "publisher": "PulkitSingh",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/The-Creator-AI/the-Creator-AI"
  },
  "displayName": "The Creator AI",
  "description": "Coding assistant",
  "version": "0.1.3",
  "engines": {
    "vscode": "^1.90.0"
  },
  "categories": [
    "Other"
  ],
  "activationEvents": [],
  "main": "./dist/extension.js",
  "contributes": {
    "configuration": {
      "title": "Creator Extension",
      "properties": {
        "creatorExtension.llmRepository": {
          "type": "object",
          "description": "Configuration for LLM services"
        },
        "creatorExtension.chatRepository": {
          "type": "object",
          "description": "Chat repository data"
        }
      }
    },
    "commands": [
      {
        "command": "the-creator-ai.helloWorld",
        "title": "Creator AI: Hello World"
      },
      {
        "command": "the-creator-ai.resetClearChangePlanViewState",
        "title": "Creator AI: Clear Change Plan View State"
      },
      {
        "command": "the-creator-ai.chooseChangePlan",
        "title": "Creator AI: Choose Change Plan",
        "icon": "$(history)"
      },
      {
        "command": "the-creator-ai.newPlan",
        "title": "Creator AI: New Plan",
        "icon": "$(sync)"
      },
      {
        "command": "the-creator-ai.clearHistory",
        "title": "Creator AI: Clear History"
      },
      {
        "command": "the-creator-ai.exportChangePlan",
        "title": "Creator AI: Export Change Plan",
        "icon": "$(cloud-upload)"
      },
      {
        "command": "the-creator-ai.importChangePlan",
        "title": "Creator AI: Import Change Plan",
        "icon": "$(cloud-download)"
      }
    ],
    "viewsContainers": {
      "activitybar": [
        {
          "id": "the-creator-ai",
          "title": "Creator AI",
          "icon": "public/spiral.svg"
        }
      ]
    },
    "views": {
      "the-creator-ai": [
        {
          "type": "webview",
          "id": "viewType.sidebar.changePlan",
          "name": "Change Plan"
        }
      ]
    },
    "menus": {
      "view/title": [
        {
          "command": "the-creator-ai.chooseChangePlan",
          "when": "view == viewType.sidebar.changePlan",
          "group": "navigation",
          "title": "Choose Plan"
        },
        {
          "command": "the-creator-ai.newPlan",
          "when": "view == viewType.sidebar.changePlan",
          "group": "navigation",
          "title": "New Plan"
        },
        {
          "command": "the-creator-ai.exportChangePlan",
          "when": "view == viewType.sidebar.changePlan",
          "group": "navigation",
           "title": "Export Plan"
        },
        {
          "command": "the-creator-ai.importChangePlan",
          "when": "view == viewType.sidebar.changePlan",
          "group": "navigation",
           "title": "Import Plan"
        }
      ]
    }
  },
  "scripts": {
    "vscode:prepublish": "npm run package",
    "compile": "webpack",
    "watch": "webpack --watch",
    "package": "webpack --mode production --devtool hidden-source-map",
    "compile-tests": "tsc -p . --outDir out",
    "watch-tests": "tsc -p . -w --outDir out",
    "pretest": "npm run compile-tests && npm run compile && npm run lint",
    "lint": "eslint src --ext ts",
    "test": "vscode-test",
    "vsce-package": "vsce package"
  },
  "devDependencies": {
    "@babel/core": "^7.24.7",
    "@babel/preset-env": "^7.24.7",
    "@babel/preset-react": "^7.24.7",
    "@babel/preset-typescript": "^7.24.7",
    "@types/mocha": "^10.0.6",
    "@types/node": "18.x",
    "@types/react-dom": "^18.3.0",
    "@types/vscode": "^1.90.0",
    "@typescript-eslint/eslint-plugin": "^7.7.1",
    "@typescript-eslint/parser": "^7.7.1",
    "@vscode/test-cli": "^0.0.9",
    "@vscode/test-electron": "^2.3.9",
    "autoprefixer": "^10.4.20",
    "babel-loader": "^9.1.3",
    "copy-webpack-plugin": "^12.0.2",
    "css-loader": "^7.1.2",
    "eslint": "^8.57.0",
    "node-sass": "^9.0.0",
    "postcss": "^8.4.45",
    "postcss-loader": "^8.1.1",
    "postcss-preset-env": "^10.0.3",
    "process": "^0.11.10",
    "sass": "^1.78.0",
    "sass-loader": "^16.0.1",
    "style-loader": "^4.0.0",
    "tailwindcss": "^3.4.10",
    "ts-loader": "^9.5.1",
    "typescript": "^5.4.5",
    "vsce": "^2.15.0",
    "webpack": "^5.91.0",
    "webpack-cli": "^5.1.4"
  },
  "dependencies": {
    "@anthropic-ai/sdk": "^0.27.0",
    "@anthropic-ai/tokenizer": "^0.0.4",
    "@google/generative-ai": "^0.12.0",
    "@vscode/webview-ui-toolkit": "^1.4.0",
    "axios": "^1.7.5",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.1",
    "firebase": "^10.13.2",
    "injection-js": "^2.4.0",
    "markdown-to-jsx": "^7.5.0",
    "openai": "^4.56.0",
    "puppeteer": "^23.2.0",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-icons": "^5.3.0",
    "reflect-metadata": "^0.2.2",
    "rxjs": "^7.8.1",
    "tiktoken": "^1.0.16",
    "uuid": "^10.0.0"
  }
}
</file>

<file path="The-Creator-AI-main/postcss.config.js">
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="The-Creator-AI-main/public/main.css">
body {
	background-color: transparent;
}

.color-list {
	list-style: none;
	padding: 0;
}

.color-entry {
	width: 100%;
	display: flex;
	margin-bottom: 0.4em;
	border: 1px solid var(--vscode-input-border);
}

.color-preview {
	width: 2em;
	height: 2em;
}

.color-preview:hover {
	outline: inset white;
}

.color-input {
	display: block;
	flex: 1;
	width: 100%;
	color: var(--vscode-input-foreground);
	background-color: var(--vscode-input-background);
	border: none;
	padding: 0 0.6em;
}

.add-color-button {
	display: block;
	border: none;
	margin: 0 auto;
}
</file>

<file path="The-Creator-AI-main/public/reset.css">
html {
	box-sizing: border-box;
	font-size: 13px;
}

*,
*:before,
*:after {
	box-sizing: inherit;
}

body,
h1,
h2,
h3,
h4,
h5,
h6,
p,
ol,
ul {
	margin: 0;
	padding: 0;
	font-weight: normal;
}

img {
	max-width: 100%;
	height: auto;
}
</file>

<file path="The-Creator-AI-main/public/spiral.svg">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200">
    <g id="Page-1" stroke="none" fill="none" fill-rule="evenodd">
        <g id="dep" transform="translate(4, 6)">
            <path d="M100 100 
            m 0 -80 
            a 80 80 0 0 1 0 160 
            a 70 70 0 0 1 0 -140 
            a 60 60 0 0 1 0 120 
            a 50 50 0 0 1 0 -100 
            a 40 40 0 0 1 0 80 
            a 30 30 0 0 1 0 -60 
            a 20 20 0 0 1 0 40"
                fill="none" stroke="white" stroke-width="8"
                id="Shape" />
        </g>
    </g>
</svg>
</file>

<file path="The-Creator-AI-main/public/vscode.css">
:root {
	--container-paddding: 20px;
	--input-padding-vertical: 6px;
	--input-padding-horizontal: 4px;
	--input-margin-vertical: 4px;
	--input-margin-horizontal: 0;
}

body {
	padding: 0 var(--container-paddding);
	color: var(--vscode-foreground);
	font-size: var(--vscode-font-size);
	font-weight: var(--vscode-font-weight);
	font-family: var(--vscode-font-family);
	background-color: var(--vscode-editor-background);
}

ol,
ul {
	padding-left: var(--container-paddding);
}

body > *,
form > * {
	margin-block-start: var(--input-margin-vertical);
	margin-block-end: var(--input-margin-vertical);
}

*:focus {
	outline-color: var(--vscode-focusBorder) !important;
}

a {
	color: var(--vscode-textLink-foreground);
}

a:hover,
a:active {
	color: var(--vscode-textLink-activeForeground);
}

code {
	font-size: var(--vscode-editor-font-size);
	font-family: var(--vscode-editor-font-family);
}

button {
	border: none;
	padding: var(--input-padding-vertical) var(--input-padding-horizontal);
	width: 100%;
	text-align: center;
	outline: 1px solid transparent;
	outline-offset: 2px !important;
	color: var(--vscode-button-foreground);
	background: var(--vscode-button-background);
}

button:hover {
	cursor: pointer;
	background: var(--vscode-button-hoverBackground);
}

button:focus {
	outline-color: var(--vscode-focusBorder);
}

button.secondary {
	color: var(--vscode-button-secondaryForeground);
	background: var(--vscode-button-secondaryBackground);
}

button.secondary:hover {
	background: var(--vscode-button-secondaryHoverBackground);
}

input:not([type='checkbox']),
textarea {
	display: block;
	width: 100%;
	border: none;
	font-family: var(--vscode-font-family);
	padding: var(--input-padding-vertical) var(--input-padding-horizontal);
	color: var(--vscode-input-foreground);
	outline-color: var(--vscode-input-border);
	background-color: var(--vscode-input-background);
}

input::placeholder,
textarea::placeholder {
	color: var(--vscode-input-placeholderForeground);
}
</file>

<file path="The-Creator-AI-main/README.md">
# The Creator AI

This extension integrates a coding assistant directly into your VS Code environment.

<img width="350" alt="image" src="https://github.com/user-attachments/assets/ea18a853-4640-4b35-b291-f6c39ea35bb4" />
<img width="350" alt="image" src="https://github.com/user-attachments/assets/53cbe519-e8b9-4d7c-a101-151b316bf28f" />

## Features

* **Context chooser:** Choose files/folders through UI which are to be kept in the context.
* **Code Change Plan:** Describe code changes you'd like to plan, and the AI will generate a plan for implementation.

## Requirements

This extension requires an API key for either Gemini or OpenAI. You'll be prompted to enter your key when you first use the extension.


## Release Notes

### 0.0.1

Initial release of the Creator AI extension with basic chat, change plan, and file explorer functionalities.

## Following Extension Guidelines

This extension adheres to the VS Code extension guidelines and best practices.

* [Extension Guidelines](https://code.visualstudio.com/api/references/extension-guidelines)

## Working with Markdown

You can edit this README using Visual Studio Code. Some useful keyboard shortcuts:

* Split the editor (`Cmd+\` on macOS or `Ctrl+\` on Windows and Linux).
* Toggle preview (`Shift+Cmd+V` on macOS or `Shift+Ctrl+V` on Windows and Linux).
* Press `Ctrl+Space` (Windows, Linux, macOS) for Markdown snippets.

## For More Information

* [Visual Studio Code's Markdown Support](http://code.visualstudio.com/docs/languages/markdown)
* [Markdown Syntax Reference](https://help.github.com/articles/markdown-basics/)

**Enjoy!** 
</file>

<file path="The-Creator-AI-main/src/backend/commands/commands.ts">
import { ChangePlan } from "@/client/views/change-plan.view/store/change-plan-view.state-type";
import { remoteSetChangePlanViewState } from "@/backend/utils/remoteSetChangePlanViewState";
import { VIEW_TYPES } from "@/common/view-types";
import * as vscode from "vscode";
import { Services } from "@/backend/services/services";
import { serverIPCs } from "@/client/views";

// Define an array of commands with their corresponding callback functions
export const commands = [
  {
    commandId: "the-creator-ai.helloWorld",
    callback: () => {
      console.log("Hello World from the-creator-ai!");
      vscode.window.showInformationMessage(
        "Hello World from the-creator-ai!"
      );
    },
  },
  {
    commandId: "the-creator-ai.resetClearChangePlanViewState",
    callback: async () => {
      const persistentStoreRepository =
        Services.getPersistentStoreRepository();
      await persistentStoreRepository.clearChangePlanViewState();
    },
  },
  {
    commandId: "the-creator-ai.chooseChangePlan",
    callback: async () => {
      const persistentStoreRepository =
        Services.getPersistentStoreRepository();
      const store = persistentStoreRepository.getChangePlanViewState();
      const changePlans = store?.changePlans || [];

      // Sort change plans by last updated date (descending)
      changePlans.sort((a: ChangePlan, b: ChangePlan) => b.lastUpdatedAt - a.lastUpdatedAt);

      // Show quick pick with plan titles
      const selectedPlan = await vscode.window.showQuickPick(
        changePlans.map((plan: ChangePlan) => {
          return {
            label: plan.planTitle,
            description: new Date(plan.lastUpdatedAt).toLocaleString(),
            plan,
          };
        }),
        {
          placeHolder: "Select a plan to load or delete",
          matchOnDescription: true
        }
      );

      if (selectedPlan) {
        const choice = await vscode.window.showQuickPick(
          ['Load', 'Delete'],
          {
            placeHolder: `What do you want to do with: ${selectedPlan.label} plan?`
          }
        )
        if (choice === 'Load') {
          const serverIpc = serverIPCs[VIEW_TYPES.SIDEBAR.CHANGE_PLAN];
          remoteSetChangePlanViewState(
            serverIpc,
            "changeDescription",
            selectedPlan.plan.planDescription
          );
          remoteSetChangePlanViewState(
            serverIpc,
            "llmResponse",
            selectedPlan.plan.llmResponse
          );
          remoteSetChangePlanViewState(
            serverIpc,
            "selectedFiles",
            selectedPlan.plan.selectedFiles
          );
          remoteSetChangePlanViewState(
            serverIpc,
            "chatHistory",
            selectedPlan.plan.chatHistory
          );
          remoteSetChangePlanViewState(
            serverIpc,
            "changePlans",
            changePlans
          );
        } else if(choice === 'Delete') {
          const confirmDelete = await vscode.window.showWarningMessage(
            `Are you sure you want to delete the plan "${selectedPlan.label}"?`,
            { modal: true },
            'Yes', 'No'
          );

          if (confirmDelete === 'Yes') {
            const updatedChangePlans = changePlans.filter((plan: ChangePlan) => plan.planTitle !== selectedPlan.label);
            persistentStoreRepository.setChangePlanViewState({
              ...store,
              changePlans: updatedChangePlans,
            });
          }
        }
      }
    },
  },
  {
    commandId: "the-creator-ai.newPlan",
    callback: async () => {
      const serverIpc = serverIPCs[VIEW_TYPES.SIDEBAR.CHANGE_PLAN];
      remoteSetChangePlanViewState(serverIpc, "changeDescription", "");
      remoteSetChangePlanViewState(serverIpc, "llmResponse", "");
      remoteSetChangePlanViewState(serverIpc, "chatHistory", []);
      remoteSetChangePlanViewState(serverIpc, "fileChunkMap", {});
      remoteSetChangePlanViewState(serverIpc, "isLoading", false);
    },
  },
  {
    commandId: "the-creator-ai.clearHistory",
    callback: async () => {
      const persistentStoreRepository =
        Services.getPersistentStoreRepository();
      await persistentStoreRepository.clearChangePlanViewState();
    },
  },
  {
    commandId: "the-creator-ai.exportChangePlan",
    callback: async () => {
      const planExImService = Services.getPlanExImService();
      await planExImService.exportAllChangePlans();
    },
  },
  {
    commandId: "the-creator-ai.importChangePlan",
    callback: async () => {
       const planExImService = Services.getPlanExImService();
      await planExImService.importAllChangePlans();
    },
  },
];
</file>

<file path="The-Creator-AI-main/src/backend/commands/register-commands.ts">
import * as vscode from "vscode";
import { commands } from "./commands";

export function registerCommands(context: vscode.ExtensionContext) {
  // Iterate over the commands array to register each command
  commands.forEach(({ commandId, callback }) => {
    let disposable = vscode.commands.registerCommand(commandId, callback);
    context.subscriptions.push(disposable);
  });
}
</file>

<file path="The-Creator-AI-main/src/backend/repositories/chat.respository.ts">
import { randomUUID } from "crypto";
import { getContext } from "../../extension";
import { StorageKeysEnum } from "../types/storage-keys.enum";

export interface ChatMessage {
  user: 'user' | 'bot' | 'instrutor'
  message: string;
}

export interface Chat {
  id: string;
  messages: ChatMessage[];
}

interface ChatRepositoryData {
  chats: Chat[];
  activeChatId: string | null;
}

const defaultChatRepositoryData: ChatRepositoryData = {
  chats: [],
  activeChatId: null,
};

export class ChatRepository {
  private static async getChatRepositoryData(): Promise<ChatRepositoryData> {
    const chatRepositoryData =
      getContext().workspaceState.get<ChatRepositoryData>(
        StorageKeysEnum.ChatRepository
      );
    if (!chatRepositoryData || !chatRepositoryData.chats) {
      await getContext().workspaceState.update(
        StorageKeysEnum.ChatRepository,
        defaultChatRepositoryData
      );
      return defaultChatRepositoryData;
    }
    return chatRepositoryData;
  }

  private static async patchChatRepositoryData(
    chatRepositoryData: Partial<ChatRepositoryData>
  ): Promise<void> {
    const existingData = await this.getChatRepositoryData();
    const updatedData = {
      ...existingData,
      ...chatRepositoryData,
    };
    await getContext().workspaceState.update(
        StorageKeysEnum.ChatRepository,
      updatedData
    );
  }

  static async getChats(): Promise<Chat[]> {
    return (await this.getChatRepositoryData()).chats;
  }

  static async getChatById(id?: string): Promise<Chat | undefined> {
    if (!id) {
      return this.getActiveChat();
    }
    const chats = await this.getChats();
    return chats.find((chat) => chat.id === id);
  }

  static async createChat(): Promise<Chat> {
    const newChat: Chat = { id: randomUUID(), messages: [] };
    const chats = await this.getChats();
    chats.push(newChat);
    await this.patchChatRepositoryData({ chats });
    await this.setActiveChat(newChat.id);
    return newChat;
  }

  static async updateChat(updatedChat: Chat): Promise<void> {
    const chats = await this.getChats();
    const index = chats.findIndex((chat) => chat.id === updatedChat.id);
    if (index !== -1) {
      chats[index] = updatedChat;
      await this.patchChatRepositoryData({ chats });
    }
  }

  static async deleteChat(id: string): Promise<void> {
    const chats = await this.getChats();
    const updatedChats = chats.filter((chat) => chat.id !== id);
    await this.patchChatRepositoryData({ chats: updatedChats });
  }

  static async getActiveChat() {
    const activeChatId = (await this.getChatRepositoryData()).activeChatId;
    if (!activeChatId) {
      return await this.createChat();
    }
    const activeChat = await this.getChatById(activeChatId);
    if (!activeChat) {
      return await this.createChat();
    }
    return activeChat;
  }

  static async setActiveChat(chatId: string | null): Promise<void> {
    await this.patchChatRepositoryData({ activeChatId: chatId });
  }

  // Message Management within a Chat
  static async addMessageToChat(
    chatId: string,
    message: ChatMessage
  ): Promise<void> {
    const chat = await this.getChatById(chatId);
    if (chat) {
      chat.messages.push(message);
      await this.updateChat(chat);
    }
  }

  static async updateMessageInChat(
    chatId: string,
    messageIndex: number,
    updatedMessage: ChatMessage
  ): Promise<void> {
    const chat = await this.getChatById(chatId);
    if (chat && chat.messages[messageIndex]) {
      chat.messages[messageIndex] = updatedMessage;
      await this.updateChat(chat);
    }
  }

  static async deleteMessageFromChat(
    chatId: string,
    messageIndex: number
  ): Promise<void> {
    const chat = await this.getChatById(chatId);
    if (chat && chat.messages[messageIndex]) {
      chat.messages.splice(messageIndex, 1);
      await this.updateChat(chat);
    }
  }
}
</file>

<file path="The-Creator-AI-main/src/backend/repositories/persistent-store.repository.ts">
import * as vscode from "vscode";
import { StorageKeysEnum } from "../types/storage-keys.enum";
import { getContext } from "../../extension";
import {ChangePlanViewStore} from '@/client/views/change-plan.view/store/change-plan-view.state-type';

export class PersistentStoreRepository {
  private readonly workspaceState: vscode.Memento;

  constructor() {
    this.workspaceState = getContext().workspaceState;
  }

  public getChangePlanViewState(): ChangePlanViewStore | undefined {
    const data = this.workspaceState.get<ChangePlanViewStore>(
      StorageKeysEnum.ChangePlanViewState
    );
    return data;
  }

  public setChangePlanViewState(data: ChangePlanViewStore): void {
    this.workspaceState.update(StorageKeysEnum.ChangePlanViewState, data);
  }

  public clearChangePlanViewState(): void {
    this.workspaceState.update(StorageKeysEnum.ChangePlanViewState, undefined);
  }
}
</file>

<file path="The-Creator-AI-main/src/backend/repositories/settings.repository.ts">
import { Injectable } from "injection-js";
import { getContext } from "../../extension";
import { LlmServiceEnum } from "../types/llm-service.enum";
import { StorageKeysEnum } from "../types/storage-keys.enum";

@Injectable()
export class SettingsRepository {
  async getLLMApiKeys(): Promise<Record<LlmServiceEnum, string[]> | undefined> {
    try {
      const llmApiKeys = getContext().workspaceState.get<string>(
        StorageKeysEnum.LlmApiKeys
      );

      return llmApiKeys ? JSON.parse(llmApiKeys) : {};
    } catch (error) {
      console.error("Error retrieving LLM API keys:", error);
      return undefined;
    }
  }

  async setLLMApiKey(service: LlmServiceEnum, apiKey: string): Promise<void> {
    const llmApiKeys = (await this.getLLMApiKeys()) || {};
    llmApiKeys[service]
      ? llmApiKeys[service].push(apiKey)
      : (llmApiKeys[service] = [apiKey]);

    try {
      getContext().workspaceState.update(
        StorageKeysEnum.LlmApiKeys,
        JSON.stringify(llmApiKeys)
      );
    }
    catch (error) {
      console.error("Error setting LLM API key:", error);
      throw error;
    }
  }

  async deleteLLMApiKey(
    service: LlmServiceEnum,
    apiKeyToDelete: string
  ): Promise<void> {
    const llmApiKeys = (await this.getLLMApiKeys()) || {};
    llmApiKeys[service]
      ? (llmApiKeys[service] = llmApiKeys[service].filter(
          (apiKey) => apiKey !== apiKeyToDelete
        ))
      : null;

    try {
      getContext().workspaceState.update(
        StorageKeysEnum.LlmApiKeys,
        JSON.stringify(llmApiKeys)
      );
    }
    catch (error) {
      console.error("Error deleting LLM API key:", error);
      throw error;
    }
  }
}
</file>

<file path="The-Creator-AI-main/src/backend/services/code.service.ts">
import * as vscode from "vscode";
import * as fs from "fs";
import * as path from "path";
import { Injectable } from "injection-js";
import { Services } from "./services";
import { AGENTS } from "@/common/constants/agents.constants";

@Injectable()
export class CodeService {
  public findFilePaths(paths: string[]): string[] {
    return paths.map(this.findFilePath.bind(this)); // Bind to the service instance
  }

  public findFilePath(filePath: string): string {
    if (fs.existsSync(filePath)) {
      return filePath;
    }

    const parts = filePath.split(path.sep);
    let currentPath = parts[0];

    // Traverse the path from the top to find the deepest valid directory
    for (let i = 1; i < parts.length; i++) {
      currentPath = path.join(currentPath, parts[i]);
      if (!fs.existsSync(currentPath)) {
        currentPath = path.dirname(currentPath);
        break;
      }
    }

    const fileName = parts[parts.length - 1];
    let dirToSearch = currentPath;
    let foundFiles = this.findFilesInDirectory(dirToSearch, fileName);

    while (!foundFiles?.length) {
      dirToSearch = path.dirname(dirToSearch);
      if (dirToSearch === ".") break;
      foundFiles = this.findFilesInDirectory(dirToSearch, fileName);
    }

    if (foundFiles.length === 1) {
      return foundFiles[0];
    } else if (foundFiles.length > 1) {
      const parentDir = parts[parts.length - 2];
      for (const file of foundFiles) {
        if (path.basename(path.dirname(file)) === parentDir) {
          return file;
        }
      }
    }

    console.error(`File not found: ${filePath}`);
    console.log(`Creating file: ${filePath}`);

    fs.writeFileSync(filePath, "", "utf-8");
    return filePath;
  }

  /**
   * Recursively searches for files with a given name in a directory and its subdirectories.
   * @param dir The directory to search in.
   * @param fileName The name of the file to search for.
   * @returns An array of file paths that match the file name.
   */
  private findFilesInDirectory(dir: string, fileName: string): string[] {
    try {
      const stat = fs.statSync(dir);
      if (!stat.isDirectory()) return [];
    } catch (err) {
      return [];
    }

    const files: string[] = [];
    try {
      const items = fs.readdirSync(dir);

      for (const item of items) {
        const fullPath = path.join(dir, item);
        const stat = fs.statSync(fullPath);

        if (stat.isFile() && path.basename(fullPath) === fileName) {
          files.push(fullPath);
        } else if (stat.isDirectory()) {
          files.push(...this.findFilesInDirectory(fullPath, fileName)); // Use this.findFilesInDirectory
        }
      }
    } catch (err) {
      console.error(`Error reading directory ${dir}:`, err);
    }

    return files;
  }

  getDiff(diffText: string) {
    const diffLines = diffText.split("\n");

    let fileToChange: string | undefined = undefined;
    let originalCode: string | undefined = undefined;
    let modifiedCode: string | undefined = undefined;
    let inSearchBlock = false;
    let inReplaceBlock = false;
    let inFilePathBlock = false;

    const changes = [];

    for (const line of diffLines) {
      if (line.startsWith("\`\`\`diff")) {
        if (fileToChange && originalCode && modifiedCode) {
          changes.push({ fileToChange, originalCode, modifiedCode });
        }
        fileToChange = undefined;
        originalCode = undefined;
        modifiedCode = undefined;
        inFilePathBlock = true;
        continue;
      }

      if (inFilePathBlock) {
        fileToChange = line.trim();
        inFilePathBlock = false;
        continue;
      }

      if (line.startsWith("<<<<<<< SEARCH")) {
        inSearchBlock = true;
        inReplaceBlock = false;
        continue;
      }

      if (line.startsWith("=======")) {
        inSearchBlock = false;
        inReplaceBlock = true;
        continue;
      }

      if (line.startsWith(">>>>>>>")) {
        if (fileToChange && originalCode && modifiedCode) {
          changes.push({ fileToChange, originalCode, modifiedCode });
        }
        fileToChange = undefined;
        originalCode = undefined;
        modifiedCode = undefined;
        inSearchBlock = false;
        inReplaceBlock = false;
        continue;
      }

      if (inSearchBlock && originalCode !== undefined) {
        originalCode += line + "\n";
      } else if (inSearchBlock) {
        originalCode = line + "\n";
      } else if (inReplaceBlock && modifiedCode !== undefined) {
        modifiedCode += line + "\n";
      } else if (inReplaceBlock) {
        modifiedCode = line + "\n";
      }
    }

    // Push the last block if it exists
    if (fileToChange && originalCode && modifiedCode) {
      changes.push({ fileToChange, originalCode, modifiedCode });
    }

    return changes;
  }

  public async applyDiffs(
    diffText: string,
    trySmartApply: (
      filePath: string,
      originalCode: string,
      modifiedCode: string
    ) => void
  ): Promise<void> {
    const blocks = this.getDiff(diffText);
    console.log({ diffText, blocks });

    for await (const block of blocks) {
      const { fileToChange, originalCode, modifiedCode } = block;

      const currentFilePath = this.findFilePath(fileToChange); // Use injected service

      const resCode = await this.applyChangesToFile(
        currentFilePath,
        originalCode,
        modifiedCode
      );

      if (resCode) {
        trySmartApply(currentFilePath, originalCode, modifiedCode);
      }
    }
  }

  private escapeRegExp(str: string): string {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }

  private async applyChangesToFile(
    filePath: string,
    originalCode: string,
    modifiedCode: string
  ): Promise<boolean> {
    console.log({ filePath, originalCode, modifiedCode });

    try {
      const fileContent = await fs.promises.readFile(filePath, "utf8");
      if (!originalCode ) {
        await fs.promises.writeFile(filePath, modifiedCode, "utf8");
      }

      const whitespaceFlexibleOriginalCode = this.escapeRegExp(originalCode)
        .split("\n")
        .map((line) => line.trim().replace(/\s+/g, "\\s+"))
        .join("\\s*");

      const regex = new RegExp(whitespaceFlexibleOriginalCode, "g");
      console.log({ whitespaceFlexibleOriginalCode });

      const updatedContent = fileContent.replace(regex, modifiedCode);

      await fs.promises.writeFile(filePath, updatedContent, "utf8");
      console.log(`Applied changes to ${filePath}`);

      return fileContent === updatedContent;
    } catch (error) {
      console.error(`Error applying changes to ${filePath}:`, error);
      return false; // Indicate failure
    }
  }

  private getFileContent(filePath: string): Promise<string> {
    return new Promise((resolve, reject) => {
      try {
        const data = fs.readFileSync(filePath, "utf-8");
        resolve(data);
      } catch (error) {
        console.error("Error reading file:", error);
        reject("Error reading file");
      }
    });
  }

  private async writeFileContent(
    filePath: string,
    content: string
  ): Promise<void> {
    const fileUri = vscode.Uri.file(filePath);
    const encoder = new TextEncoder();
    await vscode.workspace.fs.writeFile(fileUri, encoder.encode(content));
  }

  private async openFileAndShowDiff(filePath: string): Promise<void> {
    const fileUri = vscode.Uri.file(filePath);
    const document = await vscode.workspace.openTextDocument(fileUri);
    await vscode.window.showTextDocument(document);
    await vscode.commands.executeCommand("git.openChange", fileUri);
  }

  private extractCodeFromResponse(response: string): string {
    const codeBlockRegex = /```[\w]*\n([\s\S]*?)\n```/;
    const match = response.match(codeBlockRegex);
    return match ? match[1] : response;
  }

  private extractDiffFromResponse(response: string): string {
    const diffBlockRegex = /```diff\n([\s\S]*?)\n```/;
    console.log(response);
    const match = response.match(diffBlockRegex);
    return match ? match[1] : response;
  }

  private createPromptForLLM(filePath: string, fileContent: string): string {
    return `Based on the plan above and previous conversation, please give the updated code for the file: ${filePath}.
      Also please make sure to give full file code in the response.
      `;
  }

  async requestFileCode(
    filePath: string,
    chatHistory: any[],
    selectedFiles: string[],
    onChunk?: (path: string, chunk: string) => void
  ) {
    ``;
    const fsService = Services.getFSService();
    const absoluteFilePath = await fsService.resolveFilePath(filePath);
    if (!absoluteFilePath) {
      throw new Error(`Could not resolve file path: ${filePath}`);
    }

    try {
      // Check if the file exists
      if (!fs.existsSync(absoluteFilePath)) {
        // If the file doesn't exist, create it
        if (path.isAbsolute(absoluteFilePath)) {
          // If the path is absolute, create it at that path
          fs.writeFileSync(absoluteFilePath, "");
        } else {
          // If the path is relative, create it relative to the workspace directory
          const workspacePath =
            vscode.workspace.workspaceFolders![0].uri.fsPath;
          const fullFilePath = path.join(workspacePath, absoluteFilePath);
          fs.writeFileSync(fullFilePath, "");
        }
      }

      const fileContentString = await this.getFileContent(absoluteFilePath);
      const finalMessage = this.createPromptForLLM(
        absoluteFilePath,
        fileContentString
      );
      const response = await Services.getLlmService().sendPrompt(
        [
          ...chatHistory,
          {
            user: "instructor",
            message: AGENTS.Developer_diff.systemInstructions,
          },
          { user: "user", message: finalMessage },
        ],
        selectedFiles,
        (chunk: string) => {
          if (onChunk) {
            onChunk(absoluteFilePath, chunk);
          }
        }
      );

      const updatedCode = await this.applyDiffs(response.response, () => {});

      // TODO: Instead of showing the diff after making change, we can show it before and ask user to apply the changes
      //   await this.openFileAndShowDiff(absoluteFilePath);
      return {
        filePath: absoluteFilePath,
        fileContent: response.response,
      };
    } catch (error) {
      console.error(`Error processing file: ${error}`);
      throw error;
    }
  }
}
</file>

<file path="The-Creator-AI-main/src/backend/services/fs.service.ts">
import * as fs from "fs";
import * as path from "path";
import * as vscode from "vscode";
import { Injectable } from "injection-js";
import { ServerToClientChannel } from "@/common/ipc/channels.enum";
import { ServerPostMessageManager } from "@/common/ipc/server-ipc";
import { FileNode } from "@/common/types/file-node";
import { Services } from "@/backend/services/services";

@Injectable()
export class FSService {
  createFileTree(
    workspaceRoots: vscode.Uri[],
    files: vscode.Uri[],
    fromSystemRoot = false
  ): FileNode[] {
    const rootNodes: FileNode[] = workspaceRoots.map((root) => {
      if (!fromSystemRoot) {
        return {
          name: root.path.split("/").pop() || "",
          children: [],
          absolutePath: root.fsPath,
        };
      }
      const parts = root.path.split("/").filter(Boolean);
      let currentNode: FileNode = {
        name: parts[0],
        children: [],
        absolutePath: "/" + parts[0],
      };
      let rootNode = currentNode;

      for (let i = 1; i < parts.length; i++) {
        const newNode: FileNode = {
          name: parts[i],
          children: [],
          absolutePath: path.join(currentNode.absolutePath, parts[i]),
        };
        currentNode.children!.push(newNode);
        currentNode = newNode;
      }

      return rootNode;
    });
    const leafNodes = rootNodes.map((root) => {
      let currentNode = root;
      while (currentNode.children && currentNode.children.length > 0) {
        currentNode = currentNode.children[currentNode.children.length - 1];
      }
      return currentNode;
    });

    const workspaceRootPaths = workspaceRoots.map((root) => root.fsPath);

    for (const file of files) {
      const workspaceRootIndex = workspaceRootPaths.findIndex((rootPath) =>
        file.fsPath.startsWith(rootPath)
      );

      if (workspaceRootIndex !== -1) {
        const relativePath = path.relative(
          workspaceRootPaths[workspaceRootIndex],
          file.fsPath
        );
        const parts = relativePath.split(path.sep).filter(Boolean);

        let currentNode = leafNodes[workspaceRootIndex];

        for (let i = 0; i < parts.length; i++) {
          const part = parts[i];
          let child = currentNode.children?.find((c) => c.name === part);

          if (!child) {
            child = {
              name: part,
              absolutePath: path.join(currentNode.absolutePath, part),
            };
            if (i < parts.length - 1) {
              child.children = [];
            }
            currentNode.children = currentNode.children || [];
            currentNode.children.push(child);
          }

          currentNode = child;
        }
      }
    }

    return rootNodes;
  }

  readFileContent(filePath: string): string {
    try {
      const data = fs.readFileSync(filePath, "utf-8");
      return data;
    } catch (error) {
      console.error("Error reading file:", error);
      return "Error reading file";
    }
  }

  readSelectedFilesContent(filePaths: string[]): {
    [filePath: string]: string;
  } {
    const fileContents: { [filePath: string]: string } = {};
    const processedPaths = new Set<string>();

    const readContentRecursive = (filePath: string) => {
      if (processedPaths.has(filePath)) {
        return;
      }
      processedPaths.add(filePath);

      try {
        if (fs.statSync(filePath).isDirectory()) {
          fs.readdirSync(filePath).forEach((file) =>
            readContentRecursive(path.join(filePath, file))
          );
        } else {
          try {
            fileContents[filePath] = fs.readFileSync(filePath, "utf8");
          } catch (error) {
            console.error(`Error reading file ${filePath}: ${error}`);
          }
        }
      } catch (error) {
        console.error(`Error reading file ${filePath}: ${error}`);
      }
    };

    filePaths.forEach((filePath) => readContentRecursive(filePath));

    return fileContents;
  }

  async resolveFilePath(originalFilePath: string): Promise<string | null> {
    async function findFile(filePath: string): Promise<string | null> {
      const files = await vscode.workspace.findFiles(
        `**/${filePath}`,
        null,
        10
      );

      if (files.length === 1) {
        return files[0].fsPath;
      } else if (files.length > 1) {
        const selectedFile = await vscode.window.showQuickPick(
          files.map((file) => file.fsPath),
          {
            placeHolder: "Multiple files found. Please select the correct one.",
          }
        );
        return selectedFile || null;
      } else {
        const pathParts = filePath.split("/");
        if (pathParts.length > 1) {
          // Drop the first part of the path and try again
          const remainingPath = pathParts.slice(1).join("/");
          return findFile(remainingPath);
        }
        return null;
      }
    }

    const resolvedPath = await findFile(originalFilePath);

    if (resolvedPath) {
      return resolvedPath;
    } else {
      // File not found, ask the user to confirm or modify the path for creating an empty file
      // TODO: What if there are multiple workspace folders?
      const workspacePath = vscode.workspace.workspaceFolders![0].uri.fsPath;
      let newFilePath = await vscode.window.showInputBox({
        prompt:
          "The file is not found. Please confirm or modify the file path to create an empty file.",
        value: originalFilePath,
      });
      const isAbsolute = path.isAbsolute(newFilePath);
      newFilePath = isAbsolute
        ? newFilePath
        : path.join(workspacePath, newFilePath);

      if (newFilePath) {
        const dirPath = path.dirname(newFilePath);

        // Create directory if it doesn't exist
        if (!fs.existsSync(dirPath)) {
          fs.mkdirSync(dirPath, { recursive: true });
        }

        console.log("Creating new file at", newFilePath);

        // Create empty file
        fs.writeFileSync(newFilePath, "");
        vscode.window.showTextDocument(vscode.Uri.file(newFilePath));
        return newFilePath;
      }
      return null;
    }
  }

  async handleFileOpen(data: { filePath: string }) {
    const { filePath } = data;

    const absoluteFilePath = await this.resolveFilePath(filePath);
    if (!absoluteFilePath) {
      return; // Error message already shown in resolveFilePath
    }

    try {
      // Check if the file exists
      if (!fs.existsSync(absoluteFilePath)) {
        // If the file doesn't exist, create it
        if (path.isAbsolute(absoluteFilePath)) {
          // If the path is absolute, create it at that path
          fs.writeFileSync(absoluteFilePath, "");
        } else {
          // If the path is relative, create it relative to the workspace directory
          const workspacePath =
            vscode.workspace.workspaceFolders![0].uri.fsPath;
          const fullFilePath = path.join(workspacePath, absoluteFilePath);
          fs.writeFileSync(fullFilePath, "");
        }
      }

      await vscode.window.showTextDocument(vscode.Uri.file(absoluteFilePath), {
        preview: false,
      });
    } catch (error) {
      vscode.window.showErrorMessage(`Error opening file: ${error}`);
    }
  }

  setupFileSystemWatcher(serverIpc: any) {
    let fileSystemWatcher: vscode.FileSystemWatcher | undefined;
    if (fileSystemWatcher) {
      fileSystemWatcher.dispose();
    }

    fileSystemWatcher = vscode.workspace.createFileSystemWatcher("**/*");

    fileSystemWatcher.onDidCreate(() => this.sendWorkspaceFiles(serverIpc));
    fileSystemWatcher.onDidDelete(() => this.sendWorkspaceFiles(serverIpc));
    fileSystemWatcher.onDidChange(() => this.sendWorkspaceFiles(serverIpc));
  }

  async handleWorkspaceFilesRequest(serverIpc: ServerPostMessageManager) {
    await this.sendWorkspaceFiles(serverIpc);

    // Set up file system watcher if not already set
    this.setupFileSystemWatcher(serverIpc);
  }

  async sendWorkspaceFiles(serverIpc: ServerPostMessageManager) {
    const workspaceRoots =
      vscode.workspace.workspaceFolders?.map((folder) => folder.uri) || [];
    const fsService = Services.getFSService();
    const files = await fsService.getFilesRespectingGitignore();
    const workspaceFileTree = fsService.createFileTree(workspaceRoots, files);

    serverIpc.sendToClient(ServerToClientChannel.SendWorkspaceFiles, {
      files: workspaceFileTree,
    });
  }

  async getFilesRespectingGitignore(): Promise<vscode.Uri[]> {
    const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
    if (!workspaceFolder) {
      return [];
    }

    const gitignores = await this.findGitignores(workspaceFolder.uri);
    const allFiles = await vscode.workspace.findFiles("**/*");

    return allFiles.filter((file) => !this.isIgnored(file.fsPath, gitignores));
  }

  async findGitignores(workspaceUri: vscode.Uri): Promise<any[]> {
    const gitignoreFiles = await vscode.workspace.findFiles("**/.gitignore");
    const gitignores: any[] = [];

    for (const gitignoreUri of gitignoreFiles) {
      const content = await vscode.workspace.fs.readFile(gitignoreUri);
      gitignores.push({
        path: path.dirname(gitignoreUri.fsPath),
        ig: this.ignore().add(content.toString()),
      });
    }

    return gitignores;
  }

  ignore(): any {
    return {
      add: (content: string) => {
        const ignored = (filePath: string) => {
          return content
            .split("\n")
            .filter(Boolean)
            .some((line) => filePath.includes(line));
        };

        return {
          ignores: ignored,
        };
      },
    };
  }

  isIgnored(filePath: string, gitignores: any[]): boolean {
    for (const { path: gitignorePath, ig } of gitignores) {
      if (filePath.startsWith(gitignorePath)) {
        const relativePath = path.relative(gitignorePath, filePath);
        if (ig.ignores(relativePath)) {
          return true;
        }
      }
    }
    return false;
  }
}
</file>

<file path="The-Creator-AI-main/src/backend/services/git.service.ts">
import * as child_process from "child_process";
import * as vscode from "vscode";
import { Injectable } from "injection-js";

@Injectable()
export class GitService {
    /**
     * Commits changes to the Git repository with the provided message.
     *
     * @param commitMessage - The commit message to use.
     * @param commitDescription - (Optional) A commit description to include.
     * @returns The Git commit output as a string, or an empty string if an error occurs.
     */
    gitCommit = (
        commitMessage: string,
        commitDescription?: string
    ): string => {
        try {
            // 1. Construct the commit command
            let commitCommand = `git commit -m "${commitMessage}"`;

            // 2. (Optional) Include description if provided
            if (commitDescription?.trim()) {
                commitCommand += ` -m "${commitDescription}"`;
            }

            // 3. Execute the commit command
            // current working directory
            const commitOutput = child_process.execSync(commitCommand, {
                cwd: vscode.workspace.rootPath,
            });

            // 4. Handle the commit result
            console.log("Commit successful:", commitOutput.toString());
            return commitOutput.toString();
        } catch (error) {
            console.error("Error during commit:", error);
            return "";
        }
    };
}
</file>

<file path="The-Creator-AI-main/src/backend/services/llm.service.ts">
import {
  GoogleGenerativeAI,
  HarmBlockThreshold,
  HarmCategory,
} from "@google/generative-ai";
import * as openai from "openai";
import * as vscode from "vscode";
import { ChatMessage } from "../repositories/chat.respository";
import { Inject, Injectable } from "injection-js";
import { SettingsRepository } from "../repositories/settings.repository";
import { LlmServiceEnum } from "../types/llm-service.enum";
import { PersistentStoreRepository } from "../repositories/persistent-store.repository";
import { ChangePlan } from "@/client/views/change-plan.view/store/change-plan-view.state-type";
import { StorageKeysEnum } from "../types/storage-keys.enum";
import { FSService } from "./fs.service";

@Injectable()
export class LlmService {
  private geminiProModel: string = "gemini-1.5-pro-exp-0827";
  private geminiFlashModel: string = "gemini-1.5-flash-latest";
  private geminiFlash2Model: string = "models/gemini-2.0-flash-exp";
  private openaiModel: string = "gpt-3.5-turbo";
  private currentModel: string = this.geminiFlash2Model; 

  constructor(
    @Inject(FSService) private readonly fsService: FSService,
    @Inject(SettingsRepository)
    private readonly settingsRepository: SettingsRepository,
    @Inject(PersistentStoreRepository)
    private readonly persistentStoreRepository: PersistentStoreRepository
  ) {}

  async sendPrompt(
    chatHistory: ChatMessage[],
    selectedFiles: string[] = [],
    onChunk?: (chunk: string, modelType: string, modelName: string) => void
  ): Promise<{ response: string; modelType: string; modelName: string }> {
    const { type, apiKeys } = await this.getApiKey();
    console.log({ type, apiKeys, chatHistory, selectedFiles });

    // Fetch past change plans
    const pastChangePlans = await this.getPastChangePlans();

    // Read selected files content
    const fileContents =
      this.fsService.readSelectedFilesContent(selectedFiles);

    // Append file contents to prompt
    let prompt = "";
    for (const filePath in fileContents) {
      prompt += `\n\n\`\`\`
File: ${filePath}
${fileContents[filePath]}
\`\`\`\n\n`;
    }

    // Append past change plans to prompt
    if (pastChangePlans?.length) {
      prompt += `\n\nPast Change Plans:\n\`\`\`json\n${JSON.stringify(
        pastChangePlans.map(({ planTitle, planDescription, planJson }) => ({ planTitle, planDescription, planJson })),
        null,
        2
      )}\n\`\`\`\n\n`;
    }

    chatHistory.forEach((message) => {
      prompt += `${message.user}: ${message.message}\n`;
    });

    console.log(`Prompt:\n\n\n`);
    console.log(prompt);

    if (type === "gemini") {
      return this.sendPromptToGemini(prompt, apiKeys, onChunk);
    } else if (type === "openai") {
      return this.sendPromptToOpenAI(prompt, apiKeys[0], onChunk); // Assuming only one OpenAI key is stored
    } else {
      throw new Error(
        "No API key found. Please set either GEMINI_API_KEY or OPENAI_API_KEY environment variable."
      );
    }
  }

  private async sendPromptToGemini(
    prompt: string,
    apiKeys: string[],
    onChunk?: (chunk: string, modelType: string, modelName: string) => void
  ): Promise<{ response: string; modelType: string; modelName: string }> {
    let debounce = 0;
    let attempts = 0;
    let responseText = "";
    let currentKeyIndex = 0; // Track the current key being used

    while (attempts < 3) {
      attempts++;
      if (debounce > 0) {
        console.log(`Waiting for ${Math.floor(debounce / 1000)} seconds...`);
      }
      console.log(`Using model: ${this.currentModel}`);
      await new Promise((resolve) => setTimeout(resolve, debounce));
      try {
        const genAI = new GoogleGenerativeAI(apiKeys[currentKeyIndex]);
        const gemini = genAI.getGenerativeModel({
          model: this.currentModel,
        }); // Use currentModel here
        const response = await gemini.generateContentStream({
          contents: [
            {
              role: "user",
              parts: [{ text: prompt }],
            },
          ],
          generationConfig: {
            responseMimeType: "text/plain",
          },
          safetySettings: [
            {
              category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,
              threshold: HarmBlockThreshold.BLOCK_NONE,
            },
          ],
        });

        for await (const chunk of response.stream) {
          responseText += chunk.text();
          // console.log(chunk.text());
          if (onChunk) {
            onChunk(chunk.text(), "gemini", this.currentModel);
          }
        }
        debounce = 0;
        return {
          response: responseText,
          modelType: "gemini",
          modelName: this.currentModel,
        };
      } catch (e: any) {
        debounce += 5000;
        // Handle specific errors based on error type and status
        if (e.status === 429) {
          if (currentKeyIndex < apiKeys.length - 1) {
            // Pro model rate limit reached, try with the next key
            currentKeyIndex++;
            console.log(
              `${this.currentModel} limit reached for key ${
                apiKeys[currentKeyIndex - 1]
              }, trying with key ${apiKeys[currentKeyIndex]} `
            );
            continue; // Retry with the next key
          }
        } else {
          // For other errors, log the error and potentially throw or handle differently
          console.error(`Error during LLM request (attempt ${attempts}):`, e);
          // You might want to throw the error here or handle it differently based on your needs
          // throw new Error("Could not get a response from Gemini after multiple attempts.");
        }
      }
    }
    // If all attempts fail, throw an error
    throw new Error(
      "Could not get a response from Gemini after multiple attempts."
    );
  }

  getModelName(): string {
    return this.currentModel;
  }

  private async sendPromptToOpenAI(
    prompt: string,
    apiKey: string,
    onChunk?: (chunk: string, modelType: string, modelName: string) => void
  ): Promise<{ response: string; modelType: string; modelName: string }> {
    const model = new openai.OpenAI({ apiKey });

    this.currentModel = this.openaiModel;
    const response = await model.completions.create({
      model: this.openaiModel,
      prompt: prompt,
      stream: true,
    });

    let responseText = "";
    for await (const part of response) {
      const chunk = part.choices[0]?.text || "";
      responseText += chunk;
      if (onChunk) {
        onChunk(chunk, "openai", this.openaiModel);
      }
    }

    return {
      response: responseText,
      modelType: "openai",
      modelName: this.openaiModel,
    };
  }

  private async getApiKey(): Promise<any> {
    const apiKeys = await this.settingsRepository.getLLMApiKeys();
    if (!apiKeys) {
      throw new Error("API Keys not found!");
    }

    const type = Object.keys(apiKeys)[0] as LlmServiceEnum;

    if (type && Array.isArray(apiKeys[type])) {
      return { type, apiKeys: apiKeys[type] };
    } else {
      await this.getApiKeyFromUser();
      return await this.getApiKey();
    }
  }

  private async getPastChangePlans(): Promise<ChangePlan[] | undefined> {
    try {
      return this.persistentStoreRepository.getChangePlanViewState()
        ?.changePlans;
    } catch (error) {
      console.error("Error retrieving past change plans:", error);
      return undefined;
    }
  }

  private async setLLMApiKey(
    service: LlmServiceEnum,
    apiKey: string
  ): Promise<void> {
    await this.settingsRepository.setLLMApiKey(service, apiKey);
  }

  private async deleteLLMApiKey(
    service: LlmServiceEnum,
    apiKeyToDelete: string
  ): Promise<void> {
    await this.settingsRepository.deleteLLMApiKey(service, apiKeyToDelete);
  }

  private async getApiKeyFromUser(): Promise<any> {
    const apiChoice = await vscode.window.showQuickPick(
      [
        { label: "Gemini API Key", value: "gemini" },
        { label: "OpenAI API Key", value: "openai" },
      ],
      { placeHolder: "Select the API you want to use" }
    );

    if (apiChoice) {
      const apiKeyInput = await vscode.window.showInputBox({
        prompt: `Enter your ${apiChoice.label}`,
        placeHolder:
          apiChoice.value === "gemini"
            ? "Enter Gemini API Key"
            : "Enter OpenAI API Key",
        password: true, // Mask the input for security
      });
      console.log({ apiKeyInput, apiChoice });
      if (apiKeyInput) {
        await this.setLLMApiKey(apiChoice.value as LlmServiceEnum, apiKeyInput);
      }
    }
  }
}
</file>

<file path="The-Creator-AI-main/src/backend/services/logger.service.ts">
import * as fs from "fs";
import * as path from "path";
import { Injectable } from "injection-js";

@Injectable()
export class LoggerService {
  private logFilePath: string;

  constructor() {
    // Default log file path, you might want to make this configurable
    this.logFilePath = path.join(
      __dirname,
      "..",
      "..",
      "..",
      "logs",
      "extension.log"
    );
    // Ensure the logs directory exists
    const logDir = path.dirname(this.logFilePath);
    if (!fs.existsSync(logDir)) {
      fs.mkdirSync(logDir, { recursive: true });
    }
  }

  private _log(level: string, message: string, ...args: any[]): void {
    const timestamp = new Date().toISOString();
    const logMessage = `[${timestamp}] [${level.toUpperCase()}] ${message} ${
      args.length > 0 ? JSON.stringify(args) : ""
    }\n`;

    fs.appendFile(this.logFilePath, logMessage, (err) => {
      if (err) {
        console.error("Failed to write to log file:", err);
      }
    });
  }

  log(message: string, ...args: any[]): void {
    this._log("log", message, ...args);
  }

  info(message: string, ...args: any[]): void {
    this._log("info", message, ...args);
  }

  warn(message: string, ...args: any[]): void {
    this._log("warn", message, ...args);
  }

  error(message: string, ...args: any[]): void {
    this._log("error", message, ...args);
  }
}
</file>

<file path="The-Creator-AI-main/src/backend/services/message.service.ts">
import { Injectable } from "injection-js";
import { ServerPostMessageManager } from "@/common/ipc/server-ipc";
import { mergeOpenEditorsWithSelectedFiles } from "@/backend/utils/mergeOpenEditorsWithSelectedFiles";
import { Services } from "./services";
import { ServerToClientChannel } from "@/common/ipc/channels.enum";

@Injectable()
export class MessageService {

  async sendMessage(
    serverIpc: ServerPostMessageManager,
    data: {
      chatHistory: any[];
      selectedFiles: string[];
    }
  ) {
    const { chatHistory, selectedFiles } = data;

    const updatedSelectedFiles = mergeOpenEditorsWithSelectedFiles(selectedFiles);

    const response = await Services.getLlmService().sendPrompt(
      chatHistory,
      updatedSelectedFiles
    );

    serverIpc.sendToClient(ServerToClientChannel.SendMessage, {
      message: response.response,
    });
  }

  async streamMessage(
    serverIpc: ServerPostMessageManager,
    data: {
      chatHistory: any[];
      selectedFiles: string[];
    }
  ) {
    try {
      const { chatHistory, selectedFiles } = data;

      const updatedSelectedFiles =
        mergeOpenEditorsWithSelectedFiles(selectedFiles);

      const response = await Services.getLlmService().sendPrompt(
        chatHistory,
        updatedSelectedFiles,
        (chunk: string) => {
          serverIpc.sendToClient(ServerToClientChannel.StreamMessage, { chunk });
        }
      );
        serverIpc.sendToClient(ServerToClientChannel.SendMessage, {
            message: response.response,
          });
    } catch (error: any) {
      serverIpc.sendToClient(ServerToClientChannel.SendMessage, error.message);
    }
  }
}
</file>

<file path="The-Creator-AI-main/src/backend/services/plan-exim.service.ts">
import { Injectable } from 'injection-js';
import * as vscode from 'vscode';
import { Services } from './services';
import { ChangePlan } from '@/client/views/change-plan.view/store/change-plan-view.state-type';
import { initialState } from '@/client/views/change-plan.view/store/change-plan-view.initial-state';

@Injectable()
export class PlanExImService {
    async exportAllChangePlans(): Promise<void> {
        const persistentStoreRepository = Services.getPersistentStoreRepository();
        const store = persistentStoreRepository.getChangePlanViewState();
        const changePlans = store?.changePlans || [];

        const jsonString = JSON.stringify(changePlans, null, 2);
        Services.getLoggerService().log(jsonString);

        // Get the workspace folder name
        const workspaceFolders = vscode.workspace.workspaceFolders;
        const workspaceFolderName = workspaceFolders && workspaceFolders.length > 0
            ? workspaceFolders[0].name
            : 'default'; // Provide a default if no workspace is open

        const options: vscode.SaveDialogOptions = {
            defaultUri: vscode.Uri.file(`all_change_plans_${workspaceFolderName}.json`),
            filters: {
                'JSON': ['json']
            }
        };

        const fileUri = await vscode.window.showSaveDialog(options);

        if (fileUri) {
            try {
                await vscode.workspace.fs.writeFile(fileUri, Buffer.from(jsonString, 'utf-8'));
                vscode.window.showInformationMessage(`All change plans exported successfully.`);
            } catch (error) {
                vscode.window.showErrorMessage(`Failed to export change plans: ${error}`);
            }
        }
    }

    async importAllChangePlans(): Promise<void> {
        const options: vscode.OpenDialogOptions = {
            canSelectMany: false,
            openLabel: 'Import',
            filters: {
                'JSON': ['json']
            }
        };

        const fileUri = await vscode.window.showOpenDialog(options);

        if (fileUri && fileUri[0]) {
            try {
                const fileContent = await vscode.workspace.fs.readFile(fileUri[0]);
                const plansJson: ChangePlan[] = JSON.parse(Buffer.from(fileContent).toString('utf-8'));

                console.log({ fileContent, plansJson });

                if (!Array.isArray(plansJson)) {
                    vscode.window.showErrorMessage('Invalid change plans format. Expected an array of plans.');
                    return;
                }

                const persistentStoreRepository =
                    Services.getPersistentStoreRepository();
                const store = persistentStoreRepository.getChangePlanViewState();
                const currentPlans = store?.changePlans || [];
                const updatedPlans = [...currentPlans];

                for (const plan of plansJson) {
                    if (!this.isValidChangePlan(plan)) {
                        vscode.window.showWarningMessage(`Skipping invalid change plan: ${(plan as ChangePlan).planTitle}`);
                        continue;
                    }

                    const existingPlanIndex = currentPlans.findIndex(
                        p => p.planTitle === plan.planTitle && p.planDescription === plan.planDescription
                    );

                    if (existingPlanIndex !== -1) {
                        // Update existing plan
                        updatedPlans[existingPlanIndex] = plan;
                    } else {
                        // Add new plan
                        updatedPlans.push(plan);
                    }
                }

                persistentStoreRepository.setChangePlanViewState({
                    ...initialState,
                    changePlans: updatedPlans,
                });
                vscode.window.showInformationMessage(`Change plans imported successfully.`);
            } catch (error) {
                vscode.window.showErrorMessage(`Failed to import change plans: ${error}`);
            }
        }
    }

    private isValidChangePlan(plan: any): plan is ChangePlan {
        return (
            typeof plan === 'object' &&
            plan !== null &&
            typeof plan.planTitle === 'string' &&
            typeof plan.planDescription === 'string' &&
            typeof plan.llmResponse === 'string' &&
            typeof plan.planJson === 'object' &&
            Array.isArray(plan.chatHistory) &&
            Array.isArray(plan.selectedFiles)
        );
    }
}
</file>

<file path="The-Creator-AI-main/src/backend/services/services.ts">
import { ReflectiveInjector } from "injection-js";
import "reflect-metadata";
import { FSService } from "./fs.service";
import { LlmService } from "./llm.service";
import { SettingsRepository } from "../repositories/settings.repository";
import { ChatRepository } from "../repositories/chat.respository";
import { PersistentStoreRepository } from "../repositories/persistent-store.repository";
import { LoggerService } from "./logger.service";
import { PlanExImService } from "./plan-exim.service";
import { CodeService } from "./code.service";
import { GitService } from "./git.service";
import { MessageService } from "./message.service";

export class Services {
  static injector: ReflectiveInjector;

  static async initialize(): Promise<void> {
    Services.injector = ReflectiveInjector.resolveAndCreate([
      ChatRepository,
      SettingsRepository,
      PersistentStoreRepository,
      FSService,
      LlmService,
      PlanExImService,
      LoggerService,
      CodeService,
      GitService,
      MessageService,
    ]);
  }

  static getFSService(): FSService {
    return Services.injector.get(FSService);
  }

  static getLlmService(): LlmService {
    return Services.injector.get(LlmService);
  }

  static getPersistentStoreRepository(): PersistentStoreRepository {
    return Services.injector.get(PersistentStoreRepository);
  }

  static getSettingsRepository(): SettingsRepository {
    return Services.injector.get(SettingsRepository);
  }

  static getPlanExImService(): PlanExImService {
    return Services.injector.get(PlanExImService);
  }

   static getCodeService(): CodeService {
    return Services.injector.get(CodeService);
  }

  static getLoggerService(): LoggerService {
    return Services.injector.get(LoggerService);
  }

   static getGitService(): GitService {
    return Services.injector.get(GitService);
  }

    static getMessageService(): MessageService {
    return Services.injector.get(MessageService);
  }
}
</file>

<file path="The-Creator-AI-main/src/backend/services/task-queue.service.ts">
import { Injectable } from "injection-js";
import { randomUUID } from "crypto";

interface Task<TaskType> {
  task: any;
  taskType: TaskType;
}

type Subscriber = {
  id: string;
  callback: (task: any) => Promise<any>;
};

@Injectable()
export class TaskQueueService<TaskType extends string> {
  private taskQueues: Record<TaskType, Task<any>[]> = {} as Record<
    TaskType,
    Task<any>[]
  >;
  private subscribers: Record<
    TaskType,
    Record<string, Subscriber>
  > = {} as Record<TaskType, Record<string, Subscriber>>;
  private isProcessing: Record<TaskType, boolean> = {} as Record<
    TaskType,
    boolean
  >;
  private responses: Record<
    TaskType,
    Record<string, any[]>
  > = {} as Record<TaskType, Record<string, any[]>>;
  private errors: Record<TaskType, Record<string, any[]>> =
    {} as Record<TaskType, Record<string, any[]>>;

  /**
   * Publishes a task to the queue.
   * @param taskType The type of the task
   * @param task The task to be added to the queue
   */
  publishTask(taskType: TaskType, task: any): void {
    if (!this.taskQueues[taskType]) {
      this.taskQueues[taskType] = [];
    }
    this.taskQueues[taskType].push({ task, taskType });
    if (!this.isProcessing[taskType]) {
      this.isProcessing[taskType] = false;
      this.processTasks(taskType);
    }
  }

  /**
   * Subscribes a callback to process tasks.
   * @param taskType The type of the task
   * @param subscriber A callback function that processes a task and returns a value.
   */
  async subscribe(
    taskType: TaskType,
    subscriber: (task: any) => Promise<any>
  ): Promise<string> {
    const subscriberId = randomUUID();
    if (!this.subscribers[taskType]) {
      this.subscribers[taskType] = {};
    }
    this.subscribers[taskType as string][subscriberId] = {
      id: subscriberId,
      callback: subscriber,
    };
    if (!this.isProcessing[taskType]) {
      this.isProcessing[taskType] = false;
      this.processTasks(taskType);
    }
    return subscriberId;
  }

  /**
   * Processes the tasks in the queue using the registered subscribers.
   * It processes each task sequentially, passing it to all the subscribers and stores the responses.
   */
  private async processTasks(taskType: TaskType): Promise<void> {
    if (this.isProcessing[taskType]) {
      return;
    }

    this.isProcessing[taskType] = true;
    while (this.taskQueues[taskType]?.length > 0) {
      const currentTask = this.taskQueues[taskType].shift();
      if (currentTask) {
        for (const subscriberId in this.subscribers[taskType]) {
          const subscriber = this.subscribers[taskType][subscriberId];
          try {
            const response = await subscriber.callback(currentTask.task);
            if (!this.responses[taskType]) {
              this.responses[taskType] = {};
            }
            if (!this.responses[taskType][subscriber.id]) {
              this.responses[taskType as string][subscriber.id] = [];
            }
            this.responses[taskType][subscriber.id].push({
              ...currentTask.taskType,
              response,
            });
          } catch (error: any) {
            if (!this.errors[taskType]) {
              this.errors[taskType] = {};
            }
            if (!this.errors[taskType][subscriber.id]) {
              this.errors[taskType as string][subscriber.id] = [];
            }
            this.errors[taskType][subscriber.id].push({
              ...currentTask.taskType,
              error,
            });
            console.error("Error while processing a task", error);
          }
        }
      }
    }
    this.isProcessing[taskType] = false;
  }

  getResponses(taskType: TaskType, subscriberId: string): any[] {
    return this.responses[taskType]?.[subscriberId] || [];
  }

  getErrors(taskType: TaskType, subscriberId: string): any[] {
    return this.errors[taskType]?.[subscriberId] || [];
  }
}
</file>

<file path="The-Creator-AI-main/src/backend/types/llm-service.enum.ts">
export enum LlmServiceEnum {
  GEMINI = "gemini",
  OPENAI = "openai",
  CLAUDE = "claude",
}
</file>

<file path="The-Creator-AI-main/src/backend/types/storage-keys.enum.ts">
export enum StorageKeysEnum {
  LlmApiKeys = "creatorExtension:llmApiKeys",
  ChatRepository = "creatorExtension:chatRepository",
  ChangePlanViewState = "creatorExtension:store:changePlanViewState",
}
</file>

<file path="The-Creator-AI-main/src/backend/utils/handleActiveTabChange.ts">
import * as vscode from "vscode";
import { ServerPostMessageManager } from "@/common/ipc/server-ipc";
import { remoteSetChangePlanViewState } from "./remoteSetChangePlanViewState";

/**
 * Handles active tab changes in VS Code and sends the active file path to the server.
 *
 * @param serverIpc - The server IPC instance used to send messages to the server.
 */
export const handleActiveTabChange = (serverIpc: ServerPostMessageManager) => {
  remoteSetChangePlanViewState(
    serverIpc,
    "activeTab",
    vscode.window.activeTextEditor?.document.fileName
  );
  vscode.window.onDidChangeActiveTextEditor((editor) => {
    if (editor) {
      remoteSetChangePlanViewState(
        serverIpc,
        "activeTab",
        editor.document.fileName
      );
    }
  });
};
</file>

<file path="The-Creator-AI-main/src/backend/utils/mergeOpenEditorsWithSelectedFiles.ts">
import * as vscode from "vscode";

/**
 * Merges the paths of open editors with the provided selected files,
 * ensuring no duplicates and prioritizing open editor paths.
 *
 * @param selectedFiles Array of initially selected file paths.
 * @returns Array of file paths including open editor paths.
 */
export function mergeOpenEditorsWithSelectedFiles(
  selectedFiles: string[]
): string[] {
  const openEditors = vscode.window.tabGroups.all
    .flatMap((group) => group.tabs)
    .map((tab) =>
      tab.input instanceof vscode.TabInputText ||
      tab.input instanceof vscode.TabInputNotebook
        ? tab.input.uri?.fsPath || ""
        : ""
    );

  return openEditors.reduce((acc: string[], tabPath) => {
    const selectedAncestorPath = selectedFiles.find(
      (f) => tabPath.startsWith(f) && f !== tabPath
    );
    if (selectedAncestorPath) {
      return acc;
    } else {
      return [...acc, tabPath];
    }
  }, selectedFiles);
}
</file>

<file path="The-Creator-AI-main/src/backend/utils/remoteSetChangePlanViewState.ts">
import * as vscode from "vscode";
import { ServerToClientChannel } from "@/common/ipc/channels.enum";
import { ServerPostMessageManager } from "@/common/ipc/server-ipc";
import { KeyPaths, KeyPathValue } from "@/common/utils/key-path";
import { ChangePlanViewStore } from "../../client/views/change-plan.view/store/change-plan-view.state-type";

/**
 * Handles active tab changes in VS Code and sends the active file path to the server.
 *
 * @param serverIpc - The server IPC instance used to send messages to the server.
 * @param keyPath - The key path to set in the change plan view store.
 * @param value - The value to set at the key path in the change plan view store.
 */
export const remoteSetChangePlanViewState = <
  Key extends KeyPaths<ChangePlanViewStore>
>(
  serverIpc: ServerPostMessageManager,
  keyPath: Key,
  value: KeyPathValue<Key, ChangePlanViewStore>
) => {
  serverIpc.sendToClient(ServerToClientChannel.SetChangePlanViewState, {
    keyPath,
    value,
  });
};
</file>

<file path="The-Creator-AI-main/src/client/components/AutoResizingTextarea.tsx">
import React, { useEffect, useRef, forwardRef, useImperativeHandle } from 'react';

interface AutoResizingTextareaProps extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {
    placeholder?: string;
    value: string;
    onChange: (event: React.ChangeEvent<HTMLTextAreaElement>) => void;
    minRows?: number;
    maxRows?: number;
}

const AutoResizingTextarea = forwardRef<HTMLTextAreaElement, AutoResizingTextareaProps>(
    ({ placeholder, value, onChange, minRows = 1, maxRows = Infinity, ...rest }, ref) => {
        const textareaRef = useRef<HTMLTextAreaElement>(null);

        useImperativeHandle(ref, () => textareaRef.current!, []);

        useEffect(() => {
            if (textareaRef.current) {
                textareaRef.current.style.height = '0px'; // Reset height to calculate scrollHeight
                const scrollHeight = textareaRef.current.scrollHeight;

                // Calculate min and max height based on minRows and maxRows
                const lineHeight = parseInt(getComputedStyle(textareaRef.current).lineHeight, 10) || 20; // Fallback to 20px if lineHeight is not found
                const minHeight = minRows * lineHeight;
                const maxHeight = maxRows * lineHeight;

                // Apply height constraints
                const height = Math.max(minHeight, Math.min(scrollHeight, maxHeight));
                textareaRef.current.style.height = height + 'px';
            }
        }, [value, minRows, maxRows]);

        return (
            <textarea
                ref={textareaRef}
                placeholder={placeholder}
                value={value}
                onChange={onChange}
                style={{ background: 'inherit' }}
                className={"resize-none overflow-hidden box-border bg-inherit" + (rest.className ? ` ${rest.className}` : '')}
                {...rest}
            />
        );
    }
);

AutoResizingTextarea.displayName = 'AutoResizingTextarea';

export default AutoResizingTextarea;
</file>

<file path="The-Creator-AI-main/src/client/components/Checkbox.tsx">
import React from "react";
import { useEffect, useRef } from "react";

interface CheckboxProps extends Omit<React.DetailedHTMLProps<React.InputHTMLAttributes<HTMLInputElement>, HTMLInputElement>, 'onChange'> {
    checked: boolean;
    indeterminate?: boolean;
    onChange: (checked: boolean, event: React.ChangeEvent<HTMLInputElement>) => void;
}

const Checkbox = (props: CheckboxProps) => {
    const { checked, onChange, indeterminate, ...rest } = props;
    const cRef = useRef<any>(null);

    useEffect(() => {
        if (cRef.current) {
            cRef.current.indeterminate = indeterminate;
        }
    }, [cRef, indeterminate]);

    return (
        <input type="checkbox" ref={cRef} checked={checked} onChange={(e) => onChange(e.target.checked, e)} {...rest} />
    );
};

export default Checkbox;
</file>

<file path="The-Creator-AI-main/src/client/components/ErrorBoundary.tsx">
import React, { Component, ErrorInfo, ReactNode } from 'react';

interface Props {
    children: ReactNode;
    fallback?: ReactNode;
}

interface State {
    hasError: boolean;
    error: Error | null;
    errorInfo: ErrorInfo | null;
}

class ErrorBoundary extends Component<Props, State> {
    constructor(props: Props) {
        super(props);
        this.state = { hasError: false, error: null, errorInfo: null };
    }

    componentDidCatch(error: Error, errorInfo: ErrorInfo) {
        // Log the error to an error tracking service (optional)
        console.error('ErrorBoundary caught an error:', error, errorInfo);
        // You can integrate with an error tracking service here, e.g., Sentry, Rollbar

        this.setState({ hasError: true, error, errorInfo });
    }

    render() {
        if (this.state.hasError) {
            return this.props.fallback || (
                <div>
                    <h2>Something went wrong.</h2>
                    <p>{this.state.error?.message}</p>
                    {/* You can display more detailed error information here if needed */}
                </div>
            );
        }

        return this.props.children;
    }
}

export default ErrorBoundary;
</file>

<file path="The-Creator-AI-main/src/client/components/file-tree/FileTree.scss">
/* Import Tailwind directives */
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Remove default VS Code body padding */
body {
  padding: 0;
}
</file>

<file path="The-Creator-AI-main/src/client/components/file-tree/FileTree.tsx">
import React, { useEffect, useState } from 'react';
import { MdChevronRight } from 'react-icons/md';
import TreeView from '../tree-view/TreeView'; // Import the generic TreeView
import { FileNode } from '../../../common/types/file-node';
import { getFileNodeByPath, addRemovePathInSelectedFiles } from './FileTree.utils';
import Checkbox from '../Checkbox';


interface FileTreeProps {
  data: FileNode[];
  onFileClick?: (filePath: string) => void;
  selectedFiles: string[];
  recentFiles: string[];
  activeFile?: string;
  updateSelectedFiles: (selectedFiles: string[]) => void;
  updateRecentFiles: (recentFiles: string[]) => void;
}

const FileTree: React.FC<FileTreeProps> = ({
  data,
  onFileClick,
  selectedFiles,
  recentFiles,
  activeFile,
  updateSelectedFiles,
  updateRecentFiles
}) => {

  const rootNode = data.find((node) => !node.name.includes('/'));

  // State to manage expanded nodes
  const [expandedNodes, setExpandedNodes] = useState<string[]>([rootNode?.name || '']);


  useEffect(() => {
    // If selectedFiles changes, expand the corresponding nodes
    const toExpand = new Set<string>();
    selectedFiles?.forEach((selectedFile) => {
      const pathParts = selectedFile.split('/');
      // Starting from the root, expand each directory in the path
      let currentPath = '';
      pathParts.forEach((part, index) => {
        currentPath += `${currentPath ? '/' : ''}${part}`;
        const node = getFileNodeByPath(data, currentPath);
        const isLast = index === pathParts.length - 1;
        if (node && !isLast) {
          toExpand.add(currentPath);
        }
      });
    });

    setExpandedNodes(prevExpandedNodes => {
      const newExpandedNodes = [...prevExpandedNodes].filter(path => !toExpand.has(path));
      return [...newExpandedNodes, ...Array.from(toExpand)];
    });
  }, [selectedFiles, data]);


  const handleNodeClick = (e: React.MouseEvent<HTMLElement, MouseEvent>, node: FileNode, path: string) => {
    if ((e.target as HTMLElement)?.classList?.contains('checkbox')) {
      return;
    }
    const isDirectory = Array.isArray(node.children);
    if (isDirectory) {
      setExpandedNodes((prevExpandedNodes) => {
        const isExpanded = !!prevExpandedNodes.find((n) => n === path);
        return isExpanded
          ? prevExpandedNodes.filter((n) => n !== path)
          : [...prevExpandedNodes, path];
      });
    } else {
      onFileClick && onFileClick(path);
      const existingRecentFiles = recentFiles.filter(f => f !== path);
      updateRecentFiles([path, ...existingRecentFiles || []]);
    }
  };

  const renderCheckbox = (path: string) => {
    const isSelected = !!selectedFiles?.find(f => f === path);
    const isPartiallySelected = selectedFiles?.filter(f => f.includes(path) && f !== path);
    const selectedAncestors = selectedFiles?.filter(f => path.startsWith(f) && f !== path);
    return (
      <Checkbox
        data-testid="checkbox"
        indeterminate={isPartiallySelected?.length > 0}
        className="mr-2"
        checked={isSelected || !!selectedAncestors?.length}
        onChange={(_, e) => handleFileCheckboxChange(e, path)}
      />
    );
  };

  const handleFileCheckboxChange = (e: React.ChangeEvent<HTMLInputElement>, path: string) => {
    e.stopPropagation();
    e.preventDefault();
    updateSelectedFiles(addRemovePathInSelectedFiles(data, path, selectedFiles));
  };

  const renderFileNodeContent = (node: FileNode, path: string) => {
    const isDirectory = Array.isArray(node.children);
    const isActive = activeFile === path;

    return (
      <div
        className={`
          relative 
          cursor-pointer 
          px-2 py-px
          flex 
          items-center
          z-1
          ${isActive ? 'bg-[#e0dcdc]' : ''}
          ${isDirectory ? 'font-medium' : 'font-normal'}
        `}
      >
        {renderCheckbox(path)}
        <div className="whitespace-nowrap overflow-hidden text-ellipsis">{node.name}</div>
      </div>
    );
  };

  return (
    <div data-testid="file-tree" className="font-sans">
      <TreeView 
        data={data} 
        onNodeClick={(node) => {
          const path = node.absolutePath || '';
          handleNodeClick(undefined as any, node, path);
        }}
        renderNodeContent={(node) => renderFileNodeContent(node, node.absolutePath || '')} 
      />
    </div>
  );
};

export default FileTree;
</file>

<file path="The-Creator-AI-main/src/client/components/file-tree/FileTree.utils.ts">
import { FileNode } from "@/common/types/file-node";

export const addRemovePathInSelectedFiles = (
  files: FileNode[],
  path: string,
  selectedFiles: string[]
): string[] => {
  const isSelected = !!selectedFiles?.find((f) => f === path);
  if (isSelected) {
    // Remove this file from selectedFiles
    return selectedFiles?.filter((f) => f !== path);
  }

  const selectedAncestorPath = selectedFiles.find(
    (f) => path.startsWith(f) && f !== path
  );
  if (selectedAncestorPath) {
    // 1. Remove the ancestor from selectedFiles
    // 2. Add all children of the ancestor to selectedFiles except node which is another ancestor of the selected node
    // 3. Add all the siblings of the all the nodes between the ancestor and the selected node
    const pathParts = path.split("/");
    const ancestorParts = selectedAncestorPath.split("/");
    let siblingsAtEveryLevel: string[] = [];
    for (let i = ancestorParts.length - 1; i < pathParts.length - 1; i++) {
      const filePath = pathParts.slice(0, i + 1).join("/");
      const levelNode = getFileNodeByPath(files, filePath);
      if (levelNode) {
        siblingsAtEveryLevel = [
          ...siblingsAtEveryLevel,
          ...(levelNode.children
            ?.filter((c) => c.name !== pathParts[i + 1])
            ?.map((c) => `${filePath}/${c.name}`) || []),
        ];
      }
    }
    const newSelectedFiles = [
      ...selectedFiles.filter((f) => !f.includes(selectedAncestorPath)),
      ...siblingsAtEveryLevel,
    ];
    return newSelectedFiles;
  }

  // Remove all children and push this file into selectedFiles
  const newSelectedFiles = isSelected
    ? selectedFiles?.filter((f) => f !== path)
    : [...selectedFiles.filter((f) => !f.includes(path)), path];
  return newSelectedFiles;
};

export const getFileNodeByPath = (
  fileNodes: FileNode[],
  filePath: string
): FileNode | null => {
  const pathParts = filePath.split("/");
  // let's find the node in the data
  let node = {
    name: "",
    children: fileNodes,
  } as FileNode | undefined;
  for (const part of pathParts) {
    if (!node) {
      return null;
    }
    node = node.children?.find((child) => child.name === part);
  }
  return node || null;
};
</file>

<file path="The-Creator-AI-main/src/client/components/Modal.tsx">
import React, { useEffect, useRef, useState } from "react";

interface ModalProps {
  isOpen: boolean;
  onClose: () => void;
  children: React.ReactNode;
}

const Modal: React.FC<ModalProps> = ({ isOpen, onClose, children }) => {
  const modalRef = useRef<HTMLDivElement>(null);
  const [isClosing, setIsClosing] = useState(false);

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        modalRef.current &&
        !modalRef.current.contains(event.target as Node) &&
        isOpen
      ) {
        setIsClosing(true);
      }
    };

    // Add event listeners when the modal is open
    if (isOpen) {
      document.addEventListener("mousedown", handleClickOutside);
    }

    return () => {
      // Clean up the event listener when the modal closes
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [isOpen]);

  // Close the modal after the closing animation finishes
  useEffect(() => {
    if (isClosing) {
      const timer = setTimeout(() => {
        onClose();
        setIsClosing(false);
      }, 200); // Adjust the timeout to match the animation duration

      return () => clearTimeout(timer);
    }
  }, [isClosing, onClose]);

  // VS Code's default modal has a dark background with a slightly transparent white overlay
  return isOpen ? (
    <div
      className={`fixed inset-0 z-50 transition-opacity duration-200 ${isClosing ? "opacity-0" : "opacity-100"
        }`}
    >
      <div className="fixed inset-0 bg-black bg-opacity-75"></div>
      <div
        ref={modalRef}
        className={`fixed inset-0 flex items-center justify-center p-4 transition-all duration-200 ${isClosing ? "opacity-0 scale-95" : "opacity-100 scale-100"
          }`}
      >
        <div
          className="bg-white rounded-md shadow-lg p-6 relative overflow-y-auto max-h-[90vh]"
          style={{ maxWidth: "700px" }}
        >
          {/* Close button */}
          <button
            className="absolute top-4 right-4 text-gray-500 hover:text-gray-700"
            onClick={onClose}
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              fill="none"
              viewBox="0 0 24 24"
              strokeWidth={1.5}
              stroke="currentColor"
              className="w-6 h-6"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                d="M6 18L18 6M6 6l12 12"
              />
            </svg>
          </button>
          {/* Modal content */}
          {children}
        </div>
      </div>
    </div>
  ) : null;
};

export default Modal;
</file>

<file path="The-Creator-AI-main/src/client/components/ProgressSteps.tsx">
import * as React from "react";

export interface StepsConfig {
  [key: string]: {
    indicatorText: string;
    renderStep: () => JSX.Element;
  };
};

interface ProgressStepsProps {
  currentStep: string;
  handleStepClick: (step: string) => void;
  stepsConfig: StepsConfig;
}

const ProgressSteps: React.FC<ProgressStepsProps> = ({
  currentStep,
  handleStepClick,
  stepsConfig,
}) => {
  const steps = Object.keys(stepsConfig);

  return (
    <div className="flex items-center justify-between w-full pl-16 pr-16 pt-4 pb-12 border-b border-gray-600">
      {steps.map((step: string, index: number) => (
        <React.Fragment key={step}>
          <div
            className="flex flex-col items-center"
            onClick={() => handleStepClick(step)}
            data-testid={`step-indicator-${step}`}
          >
            <div
              className={`w-4 h-4 rounded-full ${
                currentStep === step ? "bg-blue-500" : "bg-gray-300"
              } cursor-pointer relative`}
            >
              <span
                className={`text-xs mt-4 whitespace-nowrap ${
                  currentStep === step ? "text-blue-500" : "text-gray-500"
                } absolute top-full left-1/2 -translate-x-1/2`}
              >
                {stepsConfig[step]?.indicatorText}
              </span>
            </div>
          </div>
          {index < steps.length - 1 && (
            <div
              className="flex-grow border-t border-gray-300"
              data-testid="step-indicator-divider"
            />
          )}
        </React.Fragment>
      ))}
    </div>
  );
};

export default ProgressSteps;
</file>

<file path="The-Creator-AI-main/src/client/components/tree-view/TreeView.tsx">
import React, { useState } from 'react';
import { MdChevronRight } from 'react-icons/md';
import { getExpandedNodes } from './TreeView.utils';

export interface TreeNode {
    name: string;
    children?: TreeNode[];
    isExpanded?: boolean;
    [key: string]: any;
}

interface TreeViewProps {
    data: TreeNode[];
    onNodeClick?: (node: TreeNode) => void;
    renderNodeContent?: (node: TreeNode) => React.ReactNode;
}

const TreeView: React.FC<TreeViewProps> = ({ data, onNodeClick, renderNodeContent }) => {
    const [expandedNodes, setExpandedNodes] = useState<string[]>(getExpandedNodes(data));

    const handleNodeClick = (node: TreeNode) => {
        if (node.children) {
            setExpandedNodes((prevExpandedNodes) => {
                const isExpanded = prevExpandedNodes.includes(node.name);
                return isExpanded
                    ? prevExpandedNodes.filter((n) => n !== node.name)
                    : [...prevExpandedNodes, node.name];
            });
        }
        onNodeClick && onNodeClick(node);
    };

    const renderTreeNodes = (nodes: TreeNode[]) => {
        return nodes.map((node) => {
            const isExpanded = expandedNodes.includes(node.name);
            const isDirectory = !!node.children;

            return (
                <li key={node.name} className="relative">
                    <div
                        onClick={() => handleNodeClick(node)}
                        className={`
              cursor-pointer 
              px-2 
              flex 
              items-center 
              ${isDirectory ? 'font-medium' : 'font-normal'}
            `}
                    >
                        {isDirectory && (
                            <span
                                className={`
                  mr-2 
                  text-xl 
                  ${isExpanded ? 'rotate-90' : ''}
                  transition-transform 
                  duration-200
                  absolute
                  left-[-6px]
                `}
                            >
                                <MdChevronRight />
                            </span>
                        )}
                        {/* Use custom rendering if provided, otherwise display the node name */}
                        {renderNodeContent ? renderNodeContent(node) : node.name}
                    </div>
                    {isDirectory && isExpanded && (
                        <ul className="ml-4">{renderTreeNodes(node.children)}</ul>
                    )}
                </li>
            );
        });
    };

    return (
        <div className="font-sans">
            <ul>{renderTreeNodes(data)}</ul>
        </div>
    );
};

export default TreeView;
</file>

<file path="The-Creator-AI-main/src/client/components/tree-view/TreeView.utils.ts">
import { TreeNode } from "./TreeView";

export const getExpandedNodes = (data: TreeNode[]): string[] => {
  return data.reduce((acc, node) => {
    if (node.isExpanded) {
      acc.push(node.name);
    }
    if (node.children) {
      acc.push(...getExpandedNodes(node.children));
    }
    return acc;
  }, []);
};
</file>

<file path="The-Creator-AI-main/src/client/modules/api-keys-management.module/ApiKeysManagement.tsx">
import * as React from 'react';
import { useEffect, useState } from 'react';
import { LlmServiceEnum } from '@/backend/types/llm-service.enum';
import { ClientPostMessageManager } from '@/common/ipc/client-ipc';
import { ClientToServerChannel, ServerToClientChannel } from '@/common/ipc/channels.enum';
import Modal from '@/client/components/Modal';

const ApiKeyManagement: React.FC = () => {
  const [apiKeys, setApiKeys] = useState<Record<LlmServiceEnum, string[]>>(
    Object.values(LlmServiceEnum).reduce((acc, service) => ({ ...acc, [service]: [] }), {} as any)
  );
  const [newApiKey, setNewApiKey] = useState('');
  const [selectedService, setSelectedService] = useState<LlmServiceEnum | null>(null);
  const [isModalOpen, setIsModalOpen] = useState(false); // State for the modal

  const clientIpc = ClientPostMessageManager.getInstance();

  useEffect(() => {
    const fetchApiKeys = async () => {
      clientIpc.sendToServer(ClientToServerChannel.GetLLMApiKeys, {});
    };

    fetchApiKeys();
  }, []);

  useEffect(() => {
    const handleSendLLMApiKeys = (message: { apiKeys: Record<LlmServiceEnum, string[]> | undefined }) => {
      setApiKeys(message.apiKeys || {} as any);
    };

    clientIpc.onServerMessage(ServerToClientChannel.SendLLMApiKeys, handleSendLLMApiKeys);
  }, []);

  const handleAddApiKey = async () => {
    if (newApiKey.trim() === '' || !selectedService) {
      return;
    }

    clientIpc.sendToServer(ClientToServerChannel.SetLLMApiKey, { service: selectedService, apiKey: newApiKey });
    setNewApiKey(''); // Clear the input field
    setSelectedService(null); // Reset selected service
    setIsModalOpen(false); // Close the modal
  };

  const handleDeleteApiKey = async (service: LlmServiceEnum, apiKey: string) => {
    clientIpc.sendToServer(ClientToServerChannel.DeleteLLMApiKey, { service, apiKeyToDelete: apiKey });
  };

  const handleOpenModal = () => {
    setIsModalOpen(true);
  };

  const handleCloseModal = () => {
    setIsModalOpen(false);
  };

  return (
    <div className="p-4">
      <h2 className="text-xl font-bold mb-4 text-editor-fg">API Key Management</h2>
      <button
        onClick={handleOpenModal}
        className="mt-2 inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-button-bg hover:bg-button-bg focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-button-bg mb-4"
      >
        Add API Key
      </button>
      {/* Display existing keys or a message if no keys are present */}
      {Object.keys(apiKeys).some((service) => apiKeys[service as LlmServiceEnum].length > 0) ? (
        Object.entries(apiKeys).map(([service, keys]) => (
          <div key={service} className="mb-6">
            <h3 className="text-lg font-medium text-editor-fg">{service}</h3>
            <ul className="list-disc pl-5">
              {keys.map((apiKey, index) => (
                <li key={index} className="flex items-center justify-between py-2">
                  <span className="truncate text-editor-fg">{apiKey}</span>
                  <button
                    onClick={() => handleDeleteApiKey(service as LlmServiceEnum, apiKey)}
                    className="text-red-500 hover:text-red-700"
                  >
                    Delete
                  </button>
                </li>
              ))}
            </ul>
          </div>
        ))
      ) : (
        <div className="mb-4">
          <p className="text-gray-600">No API keys added yet.</p>
        </div>
      )}

      {/* Modal for adding new API keys */}
      <Modal isOpen={isModalOpen} onClose={handleCloseModal}>
        <div className="p-6">
          <h3 className="text-lg font-bold mb-4 text-editor-fg">Add New API Key</h3>
          <div className="mb-4">
            <label htmlFor="serviceSelect" className="block text-sm font-medium text-gray-700">
              Select Service:
            </label>
            <select
              id="serviceSelect"
              value={selectedService || ''}
              onChange={(e) => setSelectedService(e.target.value as LlmServiceEnum)}
              className="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md bg-settings-input-bg"
            >
              <option value="">Select a service</option>
              {Object.values(LlmServiceEnum).map((service) => (
                <option key={service} value={service}>
                  {service}
                </option>
              ))}
            </select>
          </div>
          <div className="mb-4">
            <label htmlFor="apiKeyInput" className="block text-sm font-medium text-gray-700">
              API Key:
            </label>
            <div className="mt-1 flex rounded-md shadow-sm">
              <input
                type="password" // Make the input field a password field
                name="apiKeyInput"
                id="apiKeyInput"
                className="focus:ring-indigo-500 focus:border-indigo-500 flex-grow block w-full min-w-0 rounded-none rounded-l-md sm:text-sm border-gray-300 p-2 bg-settings-input-bg"
                placeholder="Enter your API key"
                value={newApiKey}
                onChange={(e) => setNewApiKey(e.target.value)}
                disabled={!selectedService}
              />
              <button
                onClick={handleAddApiKey}
                className="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-r-md shadow-sm text-white bg-button-bg hover:bg-button-bg focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-button-bg"
                disabled={!selectedService || newApiKey.trim() === ''}
              >
                Add
              </button>
            </div>
          </div>
          <button
            onClick={handleCloseModal}
            className="mt-4 inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
          >
            Cancel
          </button>
        </div>
      </Modal>
    </div>
  );
};

export default ApiKeyManagement;
</file>

<file path="The-Creator-AI-main/src/client/modules/commit.module/Commit.tsx">
import AutoResizingTextarea from '@/client/components/AutoResizingTextarea';
import { useStore } from '@/client/store/useStore';
import { commitStagedChanges } from '@/client/views/change-plan.view/logic/commitStagedChanges';
import { changePlanViewStoreStateSubject, getChangePlanViewState } from '@/client/views/change-plan.view/store/change-plan-view.store';
import React, { useState } from 'react';

const Commit: React.FC = () => {
    const {
        chatHistory,
    } = useStore(changePlanViewStoreStateSubject);
    const [commitTitle, setCommitTitle] = useState(getChangePlanViewState('changePlans')?.[getChangePlanViewState('changePlans').length - 1]?.planTitle || '');
    const [commitDescription, setCommitDescription] = useState(getChangePlanViewState('changePlans')?.[getChangePlanViewState('changePlans').length - 1]?.planDescription || '');

    const handleCommit = async () => {
        commitStagedChanges(commitTitle, commitDescription);
    };

    return (
        <div className="p-4">
            {chatHistory.length === 0 ? (
                <p className="text-gray-600">No changes to commit.</p>
            ) : (
                <div className="flex flex-col">
                    <div className="mb-4">
                        <label htmlFor="commitTitle" className="block text-sm font-medium text-gray-700">
                            Commit Title:
                        </label>
                        <AutoResizingTextarea
                            id="commitTitle"
                            className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm"
                            value={commitTitle}
                            onChange={(e) => setCommitTitle(e.target.value)}
                            placeholder="Enter a short, descriptive commit title"
                        />
                    </div>

                    <div className="mb-4">
                        <label htmlFor="commitDescription" className="block text-sm font-medium text-gray-700">
                            Commit Description (Optional):
                        </label>
                        <AutoResizingTextarea
                            id="commitDescription"
                            className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm"
                            value={commitDescription}
                            onChange={(e) => setCommitDescription(e.target.value)}
                            placeholder="Enter a more detailed description of the changes (optional)"
                            minRows={3} // Adjust as needed
                            maxRows={10} // Adjust as needed
                        />
                    </div>
                    <button
                        onClick={handleCommit}
                        className="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline"
                    >
                        Commit
                    </button>
                </div>
            )}
        </div>
    );
};

export default Commit;
</file>

<file path="The-Creator-AI-main/src/client/modules/context.module/Context.tsx">
import React, { useEffect, useState } from 'react';
import { FileNode } from '@/common/types/file-node';
import { ClientPostMessageManager } from '@/common/ipc/client-ipc';
import { ClientToServerChannel, ServerToClientChannel } from '@/common/ipc/channels.enum';
import FileTree from '@/client/components/file-tree/FileTree';
import { handleFileClick } from '@/client/views/change-plan.view/logic/handleFileClick';
import { setChangePlanViewState as setState } from '@/client/views/change-plan.view/store/change-plan-view.logic';
import { getChangePlanViewState } from '@/client/views/change-plan.view/store/change-plan-view.store';

const Context: React.FC = () => {
    const clientIpc = ClientPostMessageManager.getInstance();
    const selectedFiles = getChangePlanViewState("selectedFiles");
    const files = getChangePlanViewState("files");
    const [recentFiles, setRecentFiles] = useState<string[]>([]);
    const [activeFile, setActiveFile] = useState<string>();
    const [activeContext, setActiveContext] = useState<'code' | 'features' | 'architecture' | 'guidelines'>('code');
    useEffect(() => {
        const handleSendWorkspaceFiles = ({ files }: { files: FileNode[] }) => {
            setState("files")(files);
        };
        clientIpc.onServerMessage(
            ServerToClientChannel.SendWorkspaceFiles,
            handleSendWorkspaceFiles
        );
    
            // Request workspace files on component mount
            clientIpc.sendToServer(ClientToServerChannel.RequestWorkspaceFiles, {});
    
    
    }, []);
    
    const handleContextChange = (context: 'code' | 'features' | 'architecture' | 'guidelines') => {
        setActiveContext(context);
    };    return (
        <div className="p-4 overflow-y-auto overflow-x-hidden">
            <div className='flex mb-4'>
                <button 
                  className={`mr-2 px-4 py-2 border rounded ${activeContext === 'code' ? 'bg-blue-500 text-white' : 'border-gray-300'}`}
                  onClick={() => handleContextChange('code')}
                >
                  Code
                </button>
                 <button 
                    className={`mr-2 px-4 py-2 border rounded ${activeContext === 'features' ? 'bg-blue-500 text-white' : 'border-gray-300'}`}
                    onClick={() => handleContextChange('features')}
                >
                  Features
                </button>
                 <button 
                  className={`mr-2 px-4 py-2 border rounded ${activeContext === 'architecture' ? 'bg-blue-500 text-white' : 'border-gray-300'}`}
                  onClick={() => handleContextChange('architecture')}
                >
                  Architecture
                </button>
                 <button 
                 className={`mr-2 px-4 py-2 border rounded ${activeContext === 'guidelines' ? 'bg-blue-500 text-white' : 'border-gray-300'}`}
                 onClick={() => handleContextChange('guidelines')}
                >
                    Guidelines
                  </button>
            </div>
             {/* Render FileTree for each root node */}
             {activeContext === 'code' && files.map((rootNode, index) => (
                <FileTree
                    key={index}
                    data={[rootNode]}
                    onFileClick={(filePath) => handleFileClick({
                    clientIpc,
                    filePath,
                    setActiveFile,
                })}
                selectedFiles={selectedFiles}
                recentFiles={recentFiles}
                activeFile={activeFile}
                updateSelectedFiles={(files) => setState("selectedFiles")(files)}
                updateRecentFiles={setRecentFiles}
            />
             ))}
        {activeContext !== 'code' && <div className="text-gray-500"> {activeContext} Tree View is under development. </div>}
            {!files.length && (
                <div className="text-gray-500">Loading files...</div>
            )}
        </div>
    );
};
export default Context;
</file>

<file path="The-Creator-AI-main/src/client/modules/plan.module/components/file-card.tsx">
import { useStore } from '@/client/store/useStore';
import { changePlanViewStoreStateSubject } from '@/client/views/change-plan.view/store/change-plan-view.store';
import * as React from "react";
import { MdDescription } from 'react-icons/md';
import { ClientToServerChannel } from '@/common/ipc/channels.enum';
import { ClientPostMessageManager } from '@/common/ipc/client-ipc';
import { getChangePlanViewState } from '../../../views/change-plan.view/store/change-plan-view.store';
import { setChangePlanViewState } from '@/client/views/change-plan.view/store/change-plan-view.logic';
import { ServerToClientChannel } from '@/common/ipc/channels.enum';
import Markdown from "markdown-to-jsx";

interface FileCardProps {
    fileName: string;
    operation: string;
    recommendations: string[];
    filePath: string;
}

const FileCard: React.FC<FileCardProps> = ({ fileName, operation, recommendations, filePath }) => {
    const { fileChunkMap } = useStore(changePlanViewStoreStateSubject);
    const clientIpc = ClientPostMessageManager.getInstance();
    const chatHistory = getChangePlanViewState('chatHistory');
    const selectedFiles = getChangePlanViewState('selectedFiles');
    const isLoading = fileChunkMap[filePath]?.isLoading;
    const fileContent = fileChunkMap[filePath]?.fileContent;

    React.useEffect(() => {
        clientIpc.onServerMessage(ServerToClientChannel.StreamFileCode, (data) => {
            const { filePath, chunk } = data;
            console.log({ filePath, chunk });
            const fileChunkMap = getChangePlanViewState('fileChunkMap');
            const localFilePath = Object.keys(fileChunkMap).find((key) => key.includes(filePath) || filePath.includes(key));

            if (!fileChunkMap[localFilePath]?.isLoading) {
                return;
            }

            const updatedFileChunkMap = {
                ...fileChunkMap,
                [localFilePath]: {
                    ...fileChunkMap[localFilePath],
                    fileContent: (fileChunkMap[localFilePath]?.fileContent || '') + chunk
                }
            };
            setChangePlanViewState('fileChunkMap')(updatedFileChunkMap);
        });

        clientIpc.onServerMessage(ServerToClientChannel.SendFileCode, (data) => {
            const { filePath, fileContent } = data;
            console.log({ filePath, fileContent });
            const fileChunkMap = getChangePlanViewState('fileChunkMap');
            const localFilePath = Object.keys(fileChunkMap).find((key) => key.includes(filePath) || filePath.includes(key));
            const updatedFileChunkMap = {
                ...fileChunkMap,
                [localFilePath]: {
                    ...fileChunkMap[localFilePath],
                    fileContent,
                    isLoading: false
                }
            };
            setChangePlanViewState('fileChunkMap')(updatedFileChunkMap);
        });
    }, []);

    const handleRequestOpenFile = (filePath: string) => {
        clientIpc.sendToServer(ClientToServerChannel.RequestOpenFile, {
            filePath
        });
    };


    return (
        <div className="file-card flex flex-grow flex-col bg-sidebar-bg border border-gray-700 rounded p-4 shadow-md min-w-0 relative">
            <div className="flex items-center mb-2">
                <MdDescription
                    size={18}
                    className={`mr-2 cursor-pointer ${isLoading ? 'text-gray-400' : 'hover:text-blue-500'} `}
                />
                <h4 className="text-base font-medium text-editor-fg cursor-pointer" onClick={() => handleRequestOpenFile(filePath)}>{fileName}</h4>
            </div>
            <p className="text-gray-600 mb-3">{operation}</p>
            <ul className="list-disc list-inside">
                {recommendations.map((recommendation, index) => (
                    <li key={index} className="text-gray-400 text-xs mb-2">
                         <Markdown>{JSON.stringify(recommendation, null, 2)}</Markdown>
                    </li>
                ))}
            </ul>
        </div>
    );
};

export default FileCard;
</file>

<file path="The-Creator-AI-main/src/client/modules/plan.module/formatted-plan-preview.tsx">
import { ClientToServerChannel, ServerToClientChannel } from "@/common/ipc/channels.enum";
import { ClientPostMessageManager } from "@/common/ipc/client-ipc";
import { useStore } from "@/client/store/useStore";
import { setChangePlanViewState } from "@/client/views/change-plan.view/store/change-plan-view.logic";
import { changePlanViewStoreStateSubject, getChangePlanViewState } from "@/client/views/change-plan.view/store/change-plan-view.store";
import * as React from "react";
import { useEffect, useState } from "react";
import { MdFileDownload } from "react-icons/md";
import FileCard from "./components/file-card"; // Import the new FileCard component

interface FormattedPlanPreviewProps {
  jsonData: any;
}

const FormattedPlanPreview: React.FC<FormattedPlanPreviewProps> = ({
  jsonData,
}) => {
  const [currentFileIndex, setCurrentFileIndex] = useState(0);
  const { activeTab } = useStore(changePlanViewStoreStateSubject);
  const clientIpc = ClientPostMessageManager.getInstance();
  const chatHistory = getChangePlanViewState("chatHistory");
  const selectedFiles = getChangePlanViewState("selectedFiles");
  const [loadingFile, setLoadingFile] = useState<string | null>(null);
  const { fileChunkMap } = useStore(changePlanViewStoreStateSubject);

  useEffect(() => {
    clientIpc.onServerMessage(ServerToClientChannel.StreamFileCode, (data) => {
      const { filePath, chunk } = data;
      console.log({ filePath, chunk });
      const fileChunkMap = getChangePlanViewState("fileChunkMap");
      const localFilePath = Object.keys(fileChunkMap).find(
        (key) => key.includes(filePath) || filePath.includes(key)
      );

      if (!fileChunkMap[localFilePath]?.isLoading) {
        return;
      }

      const updatedFileChunkMap = {
        ...fileChunkMap,
        [localFilePath]: {
          ...fileChunkMap[localFilePath],
          fileContent: (fileChunkMap[localFilePath]?.fileContent || "") + chunk,
        },
      };
      setChangePlanViewState("fileChunkMap")(updatedFileChunkMap);
    });

    clientIpc.onServerMessage(ServerToClientChannel.SendFileCode, (data) => {
      const { filePath, fileContent } = data;
      console.log({ filePath, fileContent });
      const fileChunkMap = getChangePlanViewState("fileChunkMap");
      const localFilePath = Object.keys(fileChunkMap).find(
        (key) => key.includes(filePath) || filePath.includes(key)
      );
      const updatedFileChunkMap = {
        ...fileChunkMap,
        [localFilePath]: {
          ...fileChunkMap[localFilePath],
          fileContent,
          isLoading: false,
        },
      };
      setChangePlanViewState("fileChunkMap")(updatedFileChunkMap);
      setLoadingFile(null);
    });
  }, []);

  const handleHeaderClick = (index: number) => {
    setCurrentFileIndex(index);
    clientIpc.sendToServer(ClientToServerChannel.RequestOpenFile, {
      filePath: jsonData.code_plan[index]?.filename,
    });
  };

  useEffect(() => {
    const matchingCardIndex = jsonData.code_plan.findIndex(
      (item: any) =>
        item?.filename && activeTab && activeTab.endsWith(item.filename)
    );
    if (matchingCardIndex !== -1) {
      setCurrentFileIndex(matchingCardIndex);
    }
  }, [activeTab, jsonData.code_plan]);

  const handleRequestFileCode = (filePath: string) => {
    const fileChunkMap = getChangePlanViewState("fileChunkMap");
    const updatedFileChunkMap = {
      ...fileChunkMap,
      [filePath]: {
        isLoading: true,
        fileContent: "",
      },
    };
    setChangePlanViewState("fileChunkMap")(updatedFileChunkMap);
    clientIpc.sendToServer(ClientToServerChannel.RequestStreamFileCode, {
      filePath,
      chatHistory,
      selectedFiles,
    });
    setLoadingFile(filePath);
  };

  return jsonData ? (
    <div className="formatted-plan-preview min-h-0 pt-2 flex flex-col flex-grow focus:outline-none overflow-y-auto">
      <h3 className="flex justify-center text-xs font-bold mb-2 px-4 text-center">
        {jsonData.title}
      </h3>
      <p
        className="flex justify-center text-gray-700 px-4 text-center"
      >
        {jsonData.description}
      </p>
      {/* Pagination Dots */}
      <div className="flex flex-col my-4">
        {jsonData.code_plan.map((item: any, index: number) => (
          <div key={index}>
            <button
              onClick={() => handleHeaderClick(index)}
              className={`w-full text-left px-4 py-2 text-sm hover:bg-hover-bg ${
                index === currentFileIndex ? "bg-hover-bg" : ""
              }`}
            >
              <div className="flex items-center justify-between">
                <span className="whitespace-nowrap overflow-hidden text-ellipsis">
                  {item.filename?.split("/").pop() || ""}
                </span>
                {!fileChunkMap[item.filename]?.isLoading ? (
                  <MdFileDownload
                    size={18}
                    className={`ml-2 cursor-pointer text-blue-500`}
                    onClick={() => handleRequestFileCode(item.filename)}
                  />
                ) : null}
                {fileChunkMap[item.filename]?.isLoading && (
                  <span className="loader mr-2">
                    <div className="spinner w-4 h-4 border-t-2 border-b-2 border-blue-500 rounded-full animate-spin ml-2"></div>
                  </span>
                )}
                {fileChunkMap[item.filename]?.isLoading &&
                fileChunkMap[item.filename]?.fileContent?.length ? (
                  <span className="text-xs text-gray-500 whitespace-nowrap overflow-x-auto">
                    ({fileChunkMap[item.filename]?.fileContent?.length} ++)
                  </span>
                ) : null}
              </div>
            </button>
          </div>
        ))}
      </div>
      <div className="flex flex-grow mx-4">
        {jsonData.code_plan.map((item: any, index: number) => {
          if (item?.filename && index === currentFileIndex) {
            // Only render the card at the currentFileIndex
            return (
              <FileCard
                key={index}
                fileName={item.filename?.split("/").pop() || ""}
                operation={item.operation}
                recommendations={item.recommendations}
                filePath={item.filename}
              />
            );
          }
          return null;
        })}
      </div>
    </div>
  ) : null;
};

export default FormattedPlanPreview;
</file>

<file path="The-Creator-AI-main/src/client/modules/plan.module/plan-input-box.tsx">
import * as React from 'react';
import { BsSend } from 'react-icons/bs';
import AutoResizingTextarea from '@/client/components/AutoResizingTextarea';
import { ClientPostMessageManager } from '@/common/ipc/client-ipc';
import { ClientToServerChannel, ServerToClientChannel } from '@/common/ipc/channels.enum';
import { useStore } from '@/client/store/useStore';
import { changePlanViewStoreStateSubject, getChangePlanViewState } from '@/client/views/change-plan.view/store/change-plan-view.store';
import { handleSubmitPlanRequest } from '../../views/change-plan.view/logic/handleSubmitPlanRequest';
import { FileNode } from '@/common/types/file-node';

interface PlanStepInputProps {
    handleChange: (value: string) => void;
    isUpdateRequest?: boolean;
    files: FileNode[];
}

const PlanInputBox: React.FC<PlanStepInputProps> = ({ isUpdateRequest, handleChange, files }) => {
    const { selectedFiles } = useStore(changePlanViewStoreStateSubject);
    const [suggestions, setSuggestions] = React.useState<string[]>([]);
    const [selectedSuggestionIndex, setSelectedSuggestionIndex] = React.useState<number | null>(null);
    const [showSuggestions, setShowSuggestions] = React.useState(false);
    const inputRef = React.useRef<HTMLTextAreaElement>(null);
    const changeDescription = getChangePlanViewState("changeDescription");
    const isLoading = getChangePlanViewState("isLoading");

    const clientIpc = ClientPostMessageManager.getInstance();

    const handleSuggestionAccept = (suggestion: string) => {
        handleChange(
            changeDescription.split(' ').slice(0, -1).join(' ')
            + (changeDescription.split(' ').length > 1 ? ' ' : '')
            + suggestion + ' ');
        setSelectedSuggestionIndex(null);
        setShowSuggestions(false);
    };

    const handleSubmit = () => {
        handleSubmitPlanRequest(clientIpc, files);
    };

    const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
        if (showSuggestions) {
            if (e.key === 'ArrowUp') {
                e.preventDefault();
                setSelectedSuggestionIndex((prevIndex) => (prevIndex === null || prevIndex === 0) ? suggestions.length - 1 : prevIndex - 1);
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                setSelectedSuggestionIndex((prevIndex) => (prevIndex === null || prevIndex === suggestions.length - 1) ? 0 : prevIndex + 1);
            } else if (e.key === 'Enter') {
                if (selectedSuggestionIndex !== null) {
                    e.preventDefault();
                    const selectedSuggestion = suggestions[selectedSuggestionIndex];
                    handleSuggestionAccept(selectedSuggestion);
                }
            } else if (e.key === 'Escape') {
                setShowSuggestions(false);
            }
        }
        if (e.key === 'Enter' && (e.ctrlKey || e.metaKey || e.altKey)) {
            e.preventDefault();
            handleSubmit();
        }
    };

    React.useEffect(() => {
        const fetchSuggestions = () => {
            if (changeDescription.split(' ').pop().startsWith('@')) {
                clientIpc.sendToServer(ClientToServerChannel.RequestSymbols, {
                    query: changeDescription.split(' ').pop().slice(1)
                });
            } else {
                setShowSuggestions(false); // Hide suggestions if "@" is not the last character
            }
        };

        const timeoutId = setTimeout(fetchSuggestions, 300); // Adjust delay as needed

        return () => clearTimeout(timeoutId);
    }, [changeDescription, selectedFiles]);

    React.useEffect(() => {
        clientIpc.onServerMessage(ServerToClientChannel.SendSymbols, (message) => {
            const receivedSuggestions = (message.symbols || []).map((symbol: { name: string }) => symbol.name); // Adjust based on actual symbol structure
            setSuggestions(receivedSuggestions);
            setShowSuggestions(true);
        });
    }, []);

    return (
        <div className="flex flex-col">
            <div className="relative p-4 flex flex-col relative" data-testid="change-plan-input-step">
                {showSuggestions && suggestions.length > 0 && (
                    <ul className="absolute bottom-full bg-sidebar-bg left-0 mb-1 border border-gray-300 rounded max-h-40 overflow-y-auto shadow-lg z-10 m-4"
                        style={{
                            width: inputRef.current?.clientWidth,
                        }}>
                        {suggestions.map((suggestion, index) => (
                            <li
                                key={index}
                                className={`p-2 cursor-pointer hover:bg-hover-bg ${index === selectedSuggestionIndex ? 'bg-hover-bg' : ''}`}
                                onClick={() => {
                                    handleSuggestionAccept(suggestion);
                                }}
                            >
                                {suggestion}
                            </li>
                        ))}
                    </ul>
                )}
                <AutoResizingTextarea
                    ref={inputRef}
                    className="p-2 border border-gray-300 rounded font-normal mb-2 pr-10"
                    placeholder={isUpdateRequest ? "Describe the changes you want to make to the plan..." : "Describe the code changes you want to plan..."}
                    value={changeDescription}
                    onChange={(e) => handleChange(e.target.value)}
                    disabled={isLoading}
                    data-testid="change-description-textarea"
                    onKeyDown={handleKeyDown}
                    minRows={3}
                    maxRows={10}
                    autoFocus
                />
            </div>
            {inputRef.current && <BsSend
                className="fixed transform -translate-y-1/2 text-gray-400 cursor-pointer hover:text-blue-500"
                style={{
                    left: inputRef.current?.getClientRects()?.[0]?.right - 35,
                    top: inputRef.current?.getClientRects()?.[0]?.bottom - 20,
                }}
                size={20}
                onClick={handleSubmit}
                data-testid="submit-change-description-button"
            />}
        </div>
    );
};

export default PlanInputBox;
</file>

<file path="The-Creator-AI-main/src/client/modules/plan.module/Plan.tsx">
import { setChangePlanViewState as setState } from "@/client/views/change-plan.view/store/change-plan-view.logic";
import { getChangePlanViewState } from "@/client/views/change-plan.view/store/change-plan-view.store";
import { parseJsonResponse } from "@/common/utils/parse-json";
import Markdown from "markdown-to-jsx";
import * as React from "react";
import { useEffect, useState } from "react";
import FormattedPlanPreview from "./formatted-plan-preview";
import PlanInputBox from "./plan-input-box";

const Plan: React.FC = () => {
  const llmResponse = getChangePlanViewState("llmResponse");
  const files = getChangePlanViewState("files");
  const [responseType, setResponseType] = useState<"json" | "markdown" | null>(
    null
  );
  const [parsedResponse, setParsedResponse] = useState<any>(null);

  useEffect(() => {
    const jsonData = parseJsonResponse(llmResponse);
    if (jsonData) {
      setResponseType("json");
      setParsedResponse(jsonData);
    } else {
      setResponseType("markdown");
    }
  }, [llmResponse]);

  const renderResponse = () => {
    switch (responseType) {
      case "json":
        return <FormattedPlanPreview jsonData={parsedResponse} />;
      case "markdown":
        return <Markdown>{llmResponse}</Markdown>;
      default:
        return null;
    }
  };

  console.log({ files });
  return (
    <div className="plan-step flex flex-grow flex-col min-h-0">
      <div className="flex flex-grow flex-col min-h-0">{renderResponse()}</div>
      <PlanInputBox
        isUpdateRequest={
          !!(getChangePlanViewState("chatHistory").length > 0 && llmResponse)
        }
        handleChange={setState("changeDescription")}
        files={[]}
      />
    </div>
  );
};

export default Plan;
</file>

<file path="The-Creator-AI-main/src/client/store/store.ts">
import { BehaviorSubject } from "rxjs";

export class Store<T, A> extends BehaviorSubject<T> {
  constructor(private val: T) {
    super(val);
  }

  _next(value: T, action: A, actionVariant?: string): void {
    const devLogs = new URL(window.location.href).searchParams.has("devLogs");
    if (devLogs) {
      if (actionVariant) {
        console.log(action, actionVariant, value);
      } else {
        console.log(action, value);
      }
    }
    super.next(value);
  }
}
</file>

<file path="The-Creator-AI-main/src/client/store/useStore.ts">
import { useEffect, useState } from "react";
import { Store } from "./store";

export const useSelector = <S, A, R>(
  subject: Store<S, A>,
  selector: (state: S) => R
) => {
  const [state, setState] = useState<S>(subject.getValue());

  useEffect(() => {
    const subscription = subject.subscribe((newState) => {
      if (selector(newState) !== selector(state)) {
        setState(newState);
      }
    });

    return () => subscription.unsubscribe();
  }, [subject, selector]);

  return selector(state);
};

export const useStore = <S, A>(subject: Store<S, A>) => {
  return useSelector(subject, (state) => state);
};
</file>

<file path="The-Creator-AI-main/src/client/views/change-plan.view/index.ts">
import { VIEW_TYPES } from "@/common/view-types";
import { onMessage } from "./on-mesage";

export const viewConfig = {
  entry: "changePlanView.js",
  type: VIEW_TYPES.SIDEBAR.CHANGE_PLAN,
  handleMessage: onMessage,
};
</file>

<file path="The-Creator-AI-main/src/client/views/change-plan.view/logic/commitStagedChanges.ts">
import { ClientToServerChannel } from "@/common/ipc/channels.enum";
import { ClientPostMessageManager } from "@/common/ipc/client-ipc";

export const commitStagedChanges = (message: string, description: string) => {
  const clientIpc = ClientPostMessageManager.getInstance();
  clientIpc.sendToServer(ClientToServerChannel.CommitStagedChanges, {
    message,
    description,
  });
};
</file>

<file path="The-Creator-AI-main/src/client/views/change-plan.view/logic/getSelectedFiles.ts">
import { getChangePlanViewState } from "@/client/views/change-plan.view/store/change-plan-view.store";
import { FileNode } from "@/common/types/file-node";

export const getSelectedFiles = (files: FileNode[]) => {
  const selectedFiles = getChangePlanViewState("selectedFiles");
  // Create an array to store absolute paths of selected files
  const absoluteSelectedFiles: string[] = [];

  // Iterate through updatedSelectedFiles and find corresponding absolute paths in files
  selectedFiles.forEach((relativePath) => {
    let matchingNode: FileNode | undefined = undefined;
    files.find((node) => {
      // Iterate through files to find the matching absolute path
      function findMatchingNode(node: FileNode) {
        if (node.absolutePath && node.absolutePath.endsWith(relativePath)) {
          return node;
        }
        if (node.children) {
          for (const child of node.children) {
            const matchingNode = findMatchingNode(child);
            if (matchingNode) {
              return matchingNode;
            }
          }
        }
        return undefined;
      }
      matchingNode = findMatchingNode(node);
    });

    if (matchingNode) {
      absoluteSelectedFiles.push(matchingNode.absolutePath || "");
    }
  });
  return absoluteSelectedFiles;
};
</file>

<file path="The-Creator-AI-main/src/client/views/change-plan.view/logic/handleCommitMessageSuggestions.ts">
import { ServerToClientChannel } from "@/common/ipc/channels.enum";
import { ClientPostMessageManager } from "@/common/ipc/client-ipc";
import { setChangePlanViewState } from "../store/change-plan-view.logic";

export const handleCommitMessageSuggestions = () => {
  const clientIpc = ClientPostMessageManager.getInstance();
  clientIpc.onServerMessage(
    ServerToClientChannel.SendCommitMessageSuggestions,
    (message) => {
      setChangePlanViewState("commitSuggestions")(message.suggestions);
      setChangePlanViewState("commitSuggestionsLoading")(false);
    }
  );
};
</file>

<file path="The-Creator-AI-main/src/client/views/change-plan.view/logic/handleFileClick.ts">
import { ClientToServerChannel } from "@/common/ipc/channels.enum";
import { ClientPostMessageManager } from "@/common/ipc/client-ipc";

export const handleFileClick = ({
  clientIpc,
  setActiveFile,
  filePath,
}: {
  clientIpc: ClientPostMessageManager;
  setActiveFile: React.Dispatch<React.SetStateAction<string>>;
  filePath: string;
}) => {
  setActiveFile(filePath);

  // Send the selected editor path to the extension
  clientIpc.sendToServer(ClientToServerChannel.SendSelectedEditor, {
    editor: {
      fileName: filePath.split("/").pop() || "",
      filePath,
      languageId: "", // You might need to determine the languageId here
    },
  });
};
</file>

<file path="The-Creator-AI-main/src/client/views/change-plan.view/logic/handleSubmitPlanRequest.ts">
import { AGENTS } from "@/common/constants/agents.constants";
import { ClientToServerChannel } from "@/common/ipc/channels.enum";
import {
  setChangePlanViewState as setState,
  setChangePlanViewState,
} from "@/client/views/change-plan.view/store/change-plan-view.logic";
import { getChangePlanViewState } from "@/client/views/change-plan.view/store/change-plan-view.store";
import { ClientPostMessageManager } from "@/common/ipc/client-ipc";
import { FileNode } from "@/common/types/file-node";
import { getSelectedFiles } from "./getSelectedFiles";

export const handleSubmitPlanRequest = (
  clientIpc: ClientPostMessageManager,
  files: FileNode[]
) => {
  setState("isLoading")(true);
  const llmResponse = getChangePlanViewState("llmResponse");
  const changeDescription = getChangePlanViewState("changeDescription");
  if (!changeDescription) {
    setState("isLoading")(false);
    const fileChunkMap = getChangePlanViewState("fileChunkMap");
    const updatedFileChunkMap = Object.keys(fileChunkMap).reduce(
      (acc, filePath) => {
        acc[filePath] = {
          ...fileChunkMap[filePath],
          isLoading: false,
        };
        return acc;
      },
      {}
    );
    setChangePlanViewState("fileChunkMap")(updatedFileChunkMap);
    return;
  }

  const selectedFiles = getSelectedFiles(files);

  const isUpdatingPlan =
    getChangePlanViewState("chatHistory").length && llmResponse;

  let chatHistory = getChangePlanViewState("chatHistory");
  const messagesToSend = [];

  if (chatHistory.length > 0) {
    if (chatHistory.length > 2) {
      messagesToSend.push(chatHistory[1]); // Add second message if it exists
    }
    messagesToSend.push(chatHistory[chatHistory.length - 1]); // Add last message
  }

  const newChatHistory = [
    ...(isUpdatingPlan
      ? [
          ...chatHistory,
          {
            user: "instructor",
            message: AGENTS["Code Plan Update"]?.systemInstructions,
          },
        ]
      : [
          {
            user: "instructor",
            message: AGENTS["Code Plan"]?.systemInstructions,
          },
        ]),
    ...(messagesToSend || []),
    {
      user: "user",
      message: (isUpdatingPlan ? `Revise the plan:\n` : "") + changeDescription,
    },
  ];
  setState("chatHistory")(newChatHistory); // Update chatHistory in the store

  clientIpc.sendToServer(ClientToServerChannel.SendStreamMessage, {
    chatHistory: newChatHistory,
    selectedFiles,
  });
};
</file>

<file path="The-Creator-AI-main/src/client/views/change-plan.view/logic/requestCommitMessageSuggestions.ts">
import { ClientPostMessageManager } from "@/common/ipc/client-ipc";
import { getChangePlanViewState } from "../store/change-plan-view.store";
import { ClientToServerChannel } from "@/common/ipc/channels.enum";

export const requestCommitMessageSuggestions = () => {
  const chatHistory = getChangePlanViewState("chatHistory");
  const clientIpc = ClientPostMessageManager.getInstance();
  clientIpc.sendToServer(
    ClientToServerChannel.RequestCommitMessageSuggestions,
    {
      chatHistory,
    }
  );
};
</file>

<file path="The-Creator-AI-main/src/client/views/change-plan.view/logic/setupChannelHandlers.ts">
import {
    ClientToServerChannel,
    ServerToClientChannel,
} from "@/common/ipc/channels.enum";
import { ClientPostMessageManager } from "@/common/ipc/client-ipc";
import { FileNode } from "@/common/types/file-node";
import { KeyPaths, KeyPathValue } from "@/common/utils/key-path";
import { ChangePlanSteps } from "@/client/views/change-plan.view/view.constants";
import { updateOrCreateChangePlan } from "@/client/views/change-plan.view/logic/updateOrCreateChangePlan";
import {
    setChangePlanViewState as setState
} from "@/client/views/change-plan.view/store/change-plan-view.logic";
import { ChangePlanViewStore } from "@/client/views/change-plan.view/store/change-plan-view.state-type";
import { getChangePlanViewState } from "@/client/views/change-plan.view/store/change-plan-view.store";

export const setupChannelHandlers = () => {
  const clientIpc = ClientPostMessageManager.getInstance();

  const handleSendMessage = ({ message }: { message: string }) => {
    setState("isLoading")(false);
    setState("llmResponse")(message);
    setState("changeDescription")("");
    setState("currentStep")(ChangePlanSteps.Plan);

    // Update chat history
    setState("chatHistory")([
      ...getChangePlanViewState("chatHistory"),
      { user: "bot", message },
    ]);

    // Update or add the new change plan
    updateOrCreateChangePlan(message);
  };

  const handleStreamMessage = ({ chunk }: { chunk: string }) => {
    setState("llmResponse")(getChangePlanViewState("llmResponse") + chunk);
  };

  const handleSendWorkspaceFiles = ({ files }: { files: FileNode[] }) => {
     setState("files")(files);
  };

  const handleSendFileCode = ({
    fileContent,
    filePath,
  }: {
    fileContent: string;
    filePath: string;
  }) => {
    if (filePath) {
      try {
        console.log(fileContent);
        console.log(`File ${filePath} updated successfully.`);
      } catch (err) {
        console.error(`Error updating file ${filePath}:`, err);
      }
    }
  };

  const handleSetChangePlanViewState = <
    Key extends KeyPaths<ChangePlanViewStore>
  >(data: {
    keyPath: Key;
    value: KeyPathValue<Key, ChangePlanViewStore>;
  }) => {
    console.log({ data });
    setState(data.keyPath)(data.value);
  };

  clientIpc.onServerMessage(
    ServerToClientChannel.SendMessage,
    handleSendMessage
  );
  clientIpc.onServerMessage(
    ServerToClientChannel.StreamMessage,
    handleStreamMessage
  );

  // Request workspace files on component mount
  clientIpc.sendToServer(ClientToServerChannel.RequestWorkspaceFiles, {});

  // Listen for workspace files response
  clientIpc.onServerMessage(
    ServerToClientChannel.SendWorkspaceFiles,
    handleSendWorkspaceFiles
  );

  // Listener for SendFileCode
  clientIpc.onServerMessage(
    ServerToClientChannel.SendFileCode,
    handleSendFileCode
  );

  clientIpc.onServerMessage(
    ServerToClientChannel.SetChangePlanViewState,
    handleSetChangePlanViewState
  );

  clientIpc.sendToServer(ClientToServerChannel.FetchStore, {
    storeName: "changePlanViewState",
  });
};
</file>

<file path="The-Creator-AI-main/src/client/views/change-plan.view/logic/updateOrCreateChangePlan.ts">
import { parseJsonResponse } from "@/common/utils/parse-json";
import { getChangePlanViewState } from "@/client/views/change-plan.view/store/change-plan-view.store";
import { setChangePlanViewState } from "@/client/views/change-plan.view/store/change-plan-view.logic";

export const updateOrCreateChangePlan = (llmResponse: string) => {
  try {
    const planJson = parseJsonResponse(llmResponse);
    if (!planJson) {
      return;
    }

    const planTitle = planJson.title;
    const planDescription = planJson.description;

    const changePlans = getChangePlanViewState("changePlans");
    const existingPlanIndex = changePlans.findIndex(
      (plan) => plan.planTitle === planTitle
    );

    const updatedChangePlans = [...changePlans];

    if (existingPlanIndex !== -1) {
      // Update existing plan
      updatedChangePlans[existingPlanIndex] = {
        ...updatedChangePlans[existingPlanIndex],
        planDescription,
        llmResponse,
        planJson,
        chatHistory: getChangePlanViewState("chatHistory"),
        selectedFiles: getChangePlanViewState("selectedFiles"),
        lastUpdatedAt: Date.now(),
      };
    } else {
      // Create a new plan
      updatedChangePlans.push({
        planTitle,
        planDescription,
        llmResponse,
        planJson,
        chatHistory: getChangePlanViewState("chatHistory"),
        selectedFiles: getChangePlanViewState("selectedFiles"),
        lastUpdatedAt: Date.now(),
      });
    }

    setChangePlanViewState("changePlans")(updatedChangePlans);
  } catch (error) {
    console.error("Error parsing or updating change plan:", error);
  }
};
</file>

<file path="The-Creator-AI-main/src/client/views/change-plan.view/on-mesage.ts">
import { ChatMessage } from "@/backend/repositories/chat.respository";
import { Services } from "@/backend/services/services";
import {
  ClientToServerChannel,
  ServerToClientChannel,
} from "@/common/ipc/channels.enum";
import { ServerPostMessageManager } from "@/common/ipc/server-ipc";
import { parseJsonResponse } from "@/common/utils/parse-json";
import { ChangePlanViewStore } from "@/client/views/change-plan.view/store/change-plan-view.state-type";
import { handleActiveTabChange } from "@/backend/utils/handleActiveTabChange";
import * as vscode from "vscode";
import { MessageService } from "@/backend/services/message.service";

// Function to handle messages for the change plan view
export function onMessage(serverIpc: ServerPostMessageManager) {
  const fsService = Services.getFSService();
  const messageService = Services.getMessageService();
  serverIpc.onClientMessage(ClientToServerChannel.RequestWorkspaceFiles, () =>
    fsService.handleWorkspaceFilesRequest(serverIpc)
  );

  serverIpc.onClientMessage(
    ClientToServerChannel.RequestFileCode,
    async (data) => {
      const res = await Services.getCodeService().requestFileCode(
        data.filePath,
        data.chatHistory,
        data.selectedFiles
      );
      serverIpc.sendToClient(ServerToClientChannel.SendFileCode, res);
    }
  );

  serverIpc.onClientMessage(
    ClientToServerChannel.RequestStreamFileCode,
    async (data) => {
      const res = await Services.getCodeService().requestFileCode(
        data.filePath,
        data.chatHistory,
        data.selectedFiles,
        (filePath, chunk) => {
          serverIpc.sendToClient(ServerToClientChannel.StreamFileCode, {
            filePath,
            chunk,
          });
        }
      );
      serverIpc.sendToClient(ServerToClientChannel.SendFileCode, res);
    }
  );

  serverIpc.onClientMessage(ClientToServerChannel.SendMessage, (data) =>
      messageService.sendMessage(serverIpc, data)
  );

  serverIpc.onClientMessage(ClientToServerChannel.SendStreamMessage, (data) => {
      messageService.streamMessage(serverIpc, data)
  });

  serverIpc.onClientMessage(
    ClientToServerChannel.RequestOpenFile,
    async (data) => {
      fsService.handleFileOpen(data);
    }
  );

  serverIpc.onClientMessage(ClientToServerChannel.PersistStore, (data) => {
    const { storeName, storeState } = data;
    if (storeName === "changePlanViewState") {
      Services.getPersistentStoreRepository().setChangePlanViewState(
        storeState
      );
    }
  });

  serverIpc.onClientMessage(ClientToServerChannel.FetchStore, (data) => {
    const { storeName } = data;
    if (storeName === "changePlanViewState") {
      const storeState =
        Services.getPersistentStoreRepository().getChangePlanViewState();
      console.log("storeState", storeState);
      for (const key in storeState) {
        serverIpc.sendToClient(ServerToClientChannel.SetChangePlanViewState, {
          keyPath: key as keyof ChangePlanViewStore,
          value: storeState[key],
        });
      }
    }
  });

  handleActiveTabChange(serverIpc);

  // Handle request for commit message suggestions
  serverIpc.onClientMessage(
    ClientToServerChannel.RequestCommitMessageSuggestions,
    async ({ chatHistory }) => {
      // Add a user message at the end of the chat history prompting for commit message suggestions in JSON format.
      const userMessage: ChatMessage = {
        user: "user",
        message:
          "Please provide commit message suggestions in JSON format. Here's an example of the expected JSON structure:" +
          JSON.stringify({
            suggestions: ["Add feature X", "Fix bug Y", "Update dependency Z"],
          }),
      };

      // Send a message to the LLM service with the updated chat history.
      const llmResponse = await Services.getLlmService().sendPrompt([
        ...chatHistory.filter(
          (message) => message.user === "bot" || message.user === "user"
        ),
        userMessage,
      ]);

      // Parse the LLM response using parseJsonResponse from parse-json.
      const parsedResponse = parseJsonResponse(llmResponse.response);

      // Extract commit message suggestions from the parsed JSON.
      const suggestions = parsedResponse.suggestions;

      // Send the suggestions to the client.
      serverIpc.sendToClient(
        ServerToClientChannel.SendCommitMessageSuggestions,
        { suggestions }
      );
    }
  );

  // Handle commit action with the selected message
  serverIpc.onClientMessage(
    ClientToServerChannel.CommitStagedChanges,
    async (message) => {
      console.log("Committing staged changes with message:", message.message);
      console.log(
        "Committing staged changes with description:",
        message.description
      );

      // Set commitSuggestionsLoading to true before initiating the commit
      serverIpc.sendToClient(ServerToClientChannel.SetChangePlanViewState, {
        keyPath: "commitSuggestionsLoading",
        value: true,
      });

      try {
        // Use the publicly available VS Code command to commit the staged changes with the provided message
        const gitService = Services.getGitService();
        await gitService.gitCommit(message.message, message.description);
      } catch (error) {
        // Handle any errors during the commit process
        console.error("Error committing changes:", error);
      } finally {
        // Reset commit suggestions and loading state after the commit, regardless of success or failure
        serverIpc.sendToClient(ServerToClientChannel.SetChangePlanViewState, {
          keyPath: "commitSuggestions",
          value: [],
        });
        serverIpc.sendToClient(ServerToClientChannel.SetChangePlanViewState, {
          keyPath: "commitSuggestionsLoading",
          value: false,
        });
      }
    }
  );

  // Handle get LLM API keys request
  serverIpc.onClientMessage(ClientToServerChannel.GetLLMApiKeys, async () => {
    try {
      const apiKeys = await Services.getSettingsRepository().getLLMApiKeys();
      serverIpc.sendToClient(ServerToClientChannel.SendLLMApiKeys, {
        apiKeys,
      });
    } catch (error) {
      console.error("Error getting LLM API keys:", error);
      // Handle the error appropriately, e.g., send an error message to the client
    }
  });

  // Handle set LLM API key request
  serverIpc.onClientMessage(
    ClientToServerChannel.SetLLMApiKey,
    async ({ service, apiKey }) => {
      try {
        await Services.getSettingsRepository().setLLMApiKey(service, apiKey);

        // After successfully setting the API key, you might want to re-fetch
        // the API keys and send them back to the client to update the UI.
        const updatedApiKeys =
          await Services.getSettingsRepository().getLLMApiKeys();
        serverIpc.sendToClient(ServerToClientChannel.SendLLMApiKeys, {
          apiKeys: updatedApiKeys,
        });
      } catch (error) {
        console.error("Error setting LLM API key:", error);
        // Handle the error appropriately, e.g., send an error message to the client
      }
    }
  );

  // Handle delete LLM API key request
  serverIpc.onClientMessage(
    ClientToServerChannel.DeleteLLMApiKey,
    async ({ service, apiKeyToDelete }) => {
      try {
        await Services.getSettingsRepository().deleteLLMApiKey(
          service,
          apiKeyToDelete
        );

        // After successfully deleting the API key, you might want to re-fetch
        // the API keys and send them back to the client to update the UI.
        const updatedApiKeys =
          await Services.getSettingsRepository().getLLMApiKeys();
        serverIpc.sendToClient(ServerToClientChannel.SendLLMApiKeys, {
          apiKeys: updatedApiKeys,
        });
      } catch (error) {
        console.error("Error deleting LLM API key:", error);
        // Handle the error appropriately, e.g., send an error message to the client
      }
    }
  );

  // Handle symbol retrieval request
  serverIpc.onClientMessage(
    ClientToServerChannel.RequestSymbols,
    async ({ query }) => {
      try {
        const symbolInformation = await vscode.commands.executeCommand<
          vscode.SymbolInformation[]
        >("vscode.executeWorkspaceSymbolProvider", query || "");
        const files = await vscode.workspace.findFiles(`**/${query}**`);

        serverIpc.sendToClient(ServerToClientChannel.SendSymbols, {
          symbols: [
            ...files
              .map((file) => ({
                name: file.path?.split("/").pop(),
                kind: vscode.SymbolKind.File,
                location: file.path,
                range: new vscode.Range(
                  new vscode.Position(0, 0),
                  new vscode.Position(0, 0)
                ),
              }))
              ?.filter(
                (symbol, index, self) =>
                  self.findIndex((s) => s.name === symbol.name) === index
              )
              ?.filter((_, index) => index < 3),
            ...symbolInformation
              .map((symbol) => ({
                name: symbol.name,
                kind: symbol.kind,
                location: symbol.location.uri.path,
                range: symbol.location.range,
              }))
              ?.filter(
                (symbol, index, self) =>
                  self.findIndex((s) => s.name === symbol.name) === index
              )
              ?.filter((_, index) => index < 5),
          ],
        });
      } catch (error) {
        console.error("Error retrieving symbols:", error);
        // Handle the error appropriately, e.g., send an error message to the client
      }
    }
  );
}
</file>

<file path="The-Creator-AI-main/src/client/views/change-plan.view/store/change-plan-view.initial-state.ts">
import { ChangePlanViewStore } from "./change-plan-view.state-type";
import { ChangePlanSteps } from "../view.constants";

export const initialState: ChangePlanViewStore = {
  changeDescription: "",
  isLoading: false,
  llmResponse: "",
  currentStep: ChangePlanSteps.Plan,
  selectedFiles: [],
  chatHistory: [],
  activeTab: undefined,
  changePlans: [],
  commitSuggestions: [],
  commitSuggestionsLoading: false,
  fileChunkMap: {},
  files: [],
};
</file>

<file path="The-Creator-AI-main/src/client/views/change-plan.view/store/change-plan-view.logic.ts">
import { ClientToServerChannel } from "@/common/ipc/channels.enum";
import { ClientPostMessageManager } from "@/common/ipc/client-ipc";
import {
  KeyPaths,
  KeyPathValue,
  setNestedValue,
} from "@/common/utils/key-path";
import { initialState } from "./change-plan-view.initial-state";
import { ChangePlanViewStore } from "./change-plan-view.state-type";
import { changePlanViewStoreStateSubject } from "./change-plan-view.store";

export const setNewEmptyChangePlan = () => {
  const newValue: ChangePlanViewStore = {
    ...changePlanViewStoreStateSubject.getValue(),
    changeDescription: "",
    llmResponse: "",
    chatHistory: [],
    fileChunkMap: {},
    isLoading: false,
  };
  changePlanViewStoreStateSubject._next(
    newValue,
    "Change Plan View : SET NEW EMPTY CHANGE PLAN"
  );

  const clientIpc = ClientPostMessageManager.getInstance();
  clientIpc.sendToServer(ClientToServerChannel.PersistStore, {
    storeName: "changePlanViewState",
    storeState: newValue,
  });
};

export const setChangePlanViewState =
  <Key extends KeyPaths<ChangePlanViewStore>>(keyPath: Key) =>
  (value: KeyPathValue<Key, ChangePlanViewStore>) => {
    const newValue = setNestedValue(
      changePlanViewStoreStateSubject.getValue(),
      keyPath,
      value
    );
    changePlanViewStoreStateSubject._next(
      {
        ...newValue,
      },
      `Change Plan View : SET ${keyPath}`
    );

    const clientIpc = ClientPostMessageManager.getInstance();
    clientIpc.sendToServer(ClientToServerChannel.PersistStore, {
      storeName: "changePlanViewState",
      storeState: newValue,
    });
  };
</file>

<file path="The-Creator-AI-main/src/client/views/change-plan.view/store/change-plan-view.state-type.ts">
import { ChangePlanSteps } from "../view.constants";
import { ChatMessage } from "@/backend/repositories/chat.respository";
import { FileNode } from "@/common/types/file-node";

export interface ChangePlan {
  planTitle: string;
  planDescription: string;
  llmResponse: string;
  planJson: any;
  chatHistory: ChatMessage[];
  selectedFiles: string[];
  lastUpdatedAt: number;
}

export interface ChangePlanViewStore {
  changeDescription: string;
  isLoading: boolean;
  llmResponse: string;
  currentStep: ChangePlanSteps;
  selectedFiles: string[];
  chatHistory: ChatMessage[];
  activeTab: string | undefined;
  changePlans: ChangePlan[];
  fileChunkMap: Record<
    string,
    {
      isLoading: boolean;
      fileContent: string;
    }
  >;
    files: FileNode[];
  commitSuggestionsLoading: boolean;
  commitSuggestions: string[];
}
</file>

<file path="The-Creator-AI-main/src/client/views/change-plan.view/store/change-plan-view.store.ts">
import { Store } from "@/client/store/store";
import { ChangePlanViewStore } from "./change-plan-view.state-type";
import { initialState } from "./change-plan-view.initial-state";
import { KeyPaths, getNestedValue } from "@/common/utils/key-path";

type ChangePlanViewActions =
  | `Change Plan View : SET ${KeyPaths<ChangePlanViewStore>}`
  | "Change Plan View : SET NEW EMPTY CHANGE PLAN";

export const changePlanViewStoreStateSubject = new Store<
  ChangePlanViewStore,
  ChangePlanViewActions
>(initialState);

export const getChangePlanViewState = (
  keyPath?: KeyPaths<ChangePlanViewStore>
) => getNestedValue(changePlanViewStoreStateSubject.getValue(), keyPath);
</file>

<file path="The-Creator-AI-main/src/client/views/change-plan.view/view.constants.ts">
export enum ChangePlanSteps {
  ApiKeyManagement = 'ApiKeyManagement',
  Context = 'Context',
  Plan = 'Plan',
  Commit = 'Commit', 
}
</file>

<file path="The-Creator-AI-main/src/client/views/change-plan.view/view.scss">
/* Import Tailwind directives */
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Remove default VS Code body padding */
body {
    padding: 0;
}
</file>

<file path="The-Creator-AI-main/src/client/views/change-plan.view/view.tsx">
import ErrorBoundary from "@/client/components/ErrorBoundary";
import { StepsConfig } from '@/client/components/ProgressSteps';
import ApiKeyManagement from '@/client/modules/api-keys-management.module/ApiKeysManagement';
import Commit from '@/client/modules/commit.module/Commit';
import Context from '@/client/modules/context.module/Context';
import Plan from '@/client/modules/plan.module/Plan';
import { useStore } from "@/client/store/useStore";
import { Log } from "@/common/utils/firebaseLogger";
import * as React from "react";
import { useEffect } from "react";
import * as ReactDOM from "react-dom/client";
import { FaSpinner } from "react-icons/fa"; // Import spinner icon
import ProgressSteps from "../../components/ProgressSteps";
import { setupChannelHandlers } from "./logic/setupChannelHandlers";
import { setChangePlanViewState as setState } from "./store/change-plan-view.logic";
import { changePlanViewStoreStateSubject } from "./store/change-plan-view.store";
import { ChangePlanSteps } from "./view.constants";
import "./view.scss";

const App = () => {
  const { isLoading, currentStep: currentTab } = useStore(
    changePlanViewStoreStateSubject
  );
  const changePlanSteps: StepsConfig = {
    [ChangePlanSteps.ApiKeyManagement]: {
      indicatorText: "API Keys",
      renderStep: () => <ApiKeyManagement />,
    },
    [ChangePlanSteps.Context]: {
      indicatorText: "Context",
      renderStep: () => <Context />,
    },
    [ChangePlanSteps.Plan]: {
      indicatorText: "Plan",
      renderStep: () => <Plan />,
    },
    [ChangePlanSteps.Commit]: {
      indicatorText: "Commit",
      renderStep: () => <Commit />,
    },
  };
  

  // Initialize Firebase
  useEffect(() => {
    Log.sidebarOpened();
  }, []);

  useEffect(() => {
    setupChannelHandlers();
  }, []);

  const handleStepClick = (step: ChangePlanSteps) => {
    setState("currentStep")(step);
  };

  const renderLoader = () => (
    <div
      className="loader fixed inset-0 flex justify-center items-center bg-opacity-50 bg-[#202020] z-50"
      data-testid="loader"
    >
      <FaSpinner className="spinner text-2xl animate-spin text-white" />
    </div>
  );

  return (
    <div className="h-full fixed inset-0 flex flex-col justify-between bg-editor-bg">
      <ProgressSteps
        stepsConfig={changePlanSteps}
        currentStep={currentTab}
        handleStepClick={handleStepClick}
      />
      <div className="flex flex-grow flex-col overflow-hidden">
        {/* Dropdown removed */}
        {changePlanSteps[currentTab].renderStep()}
      </div>
      {isLoading && renderLoader()} {/* Conditionally render the loader */}
    </div>
  );
};

const root = ReactDOM.createRoot(
  document.getElementById("change-plan-view-root")!
);

root.render(
  <ErrorBoundary>
    <App />
  </ErrorBoundary>
);
</file>

<file path="The-Creator-AI-main/src/client/views/chat.view/index.ts">
import { VIEW_TYPES } from "@/common/view-types";
import { onMessage } from "./on-mesage";

export const viewConfig = {
  entry: "chatView.js",
  type: VIEW_TYPES.SIDEBAR.CHAT,
  handleMessage: onMessage,
};
</file>

<file path="The-Creator-AI-main/src/client/views/chat.view/on-mesage.ts">
import { ChatRepository } from "@/backend/repositories/chat.respository";
import { Services } from "@/backend/services/services";
import {
  ClientToServerChannel,
  ServerToClientChannel,
} from "@/common/ipc/channels.enum";
import { ServerPostMessageManager } from "@/common/ipc/server-ipc";

// Function to handle messages for the chat view
export async function onMessage(serverIpc: ServerPostMessageManager) {
  serverIpc?.onClientMessage(
    ClientToServerChannel.SendMessage,
    async (data) => {
      const userMessage = data.chatHistory?.[0];

      // Fetch Chat History from Repository
      let existingChat = await ChatRepository.getActiveChat();
      await ChatRepository.addMessageToChat(existingChat.id, userMessage);
      existingChat = await ChatRepository.getActiveChat();

      const response = await Services.getLlmService().sendPrompt(
        existingChat.messages
      );

      serverIpc.sendToClient(ServerToClientChannel.SendMessage, {
        message: response.response,
      });

      await ChatRepository.addMessageToChat(existingChat.id, {
        user: "bot",
        message: response.response,
      });
    }
  );
  serverIpc?.onClientMessage(
    ClientToServerChannel.RequestChatHistory,
    async (data) => {
      const chatId = data.chatId;
      const chat = await ChatRepository.getChatById(chatId);
      if (!chat) {
        return;
      }
      serverIpc.sendToClient(ServerToClientChannel.SendChatHistory, {
        chatId: chat.id,
        messages: chat.messages,
      });
    }
  );
}
</file>

<file path="The-Creator-AI-main/src/client/views/chat.view/view.scss">
/* Import Tailwind directives */
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Remove default VS Code body padding */
body {
    padding: 0;
}
</file>

<file path="The-Creator-AI-main/src/client/views/chat.view/view.tsx">
// the-creator-ai/src/sidebar/Sidebar.tsx
import * as React from 'react';
import * as ReactDOM from 'react-dom/client';
import { ClientPostMessageManager } from '@/common/ipc/client-ipc';
import { ClientToServerChannel, ServerToClientChannel } from '@/common/ipc/channels.enum';
import Markdown from 'markdown-to-jsx';
import { FaUser, FaRobot } from 'react-icons/fa';
import './view.scss';

const App = () => {
  const [messages, setMessages] = React.useState<{ user: string; message: string }[]>([]);
  const [userInput, setUserInput] = React.useState('');
  const clientIpc = ClientPostMessageManager.getInstance();

  const sendMessage = () => {
    if (userInput.trim() === '') return;

    // Send message to extension
    clientIpc.sendToServer(ClientToServerChannel.SendMessage, {
      chatHistory: [{ user: 'user', message: userInput }],
      selectedFiles: []
    });

    // Update local messages (for display)
    setMessages([...messages, { user: 'user', message: userInput }]);
    setUserInput('');
  };

  React.useEffect(() => {
    clientIpc.onServerMessage(ServerToClientChannel.SendMessage, ({ message }) => {
      setMessages((messages) => ([...messages, { user: 'AI', message }]));
    });
    clientIpc.onServerMessage(ServerToClientChannel.SendChatHistory, ({ messages }) => {
      setMessages(() => ([...messages]));
    });
    clientIpc.sendToServer(ClientToServerChannel.RequestChatHistory, {});
  }, []);

  return (
    <div className="flex flex-col h-full">
      <div className="flex-grow overflow-y-auto p-4">
        {messages.map((message, index) => (
          <div key={index} className={`flex items-start my-2 p-2 ${message.user === 'user' ? 'user' : 'bot'}`}>
            <div className={`mr-2 text-lg ${message.user === 'user' ? 'text-blue-500' : 'text-gray-400'}`}>
              {message.user === 'user' ? <FaUser /> : <FaRobot />}
            </div>
            <div className="flex-grow">
              <Markdown>{message.message}</Markdown>
            </div>
          </div>
        ))}
      </div>
      <div className="flex p-4 border-t">
        <input
          type="text"
          className="flex-grow p-2 border rounded mr-2"
          value={userInput}
          onChange={(e) => setUserInput(e.target.value)}
          placeholder="Type your message here"
        />
        <button className="p-2 bg-blue-500 text-white rounded cursor-pointer hover:bg-blue-700" onClick={sendMessage}>
          Send
        </button>
      </div>
    </div>
  );
};

const root = ReactDOM.createRoot(document.getElementById('chat-view-root')!);
root.render(<App />);
</file>

<file path="The-Creator-AI-main/src/client/views/file-explorer.view/index.ts">
import { VIEW_TYPES } from "@/common/view-types";
import { onMessage } from "./on-mesage";

export const viewConfig = {
  entry: "fileExplorerView.js",
  type: VIEW_TYPES.SIDEBAR.FILE_EXPLORER,
  handleMessage: onMessage,
};
</file>

<file path="The-Creator-AI-main/src/client/views/file-explorer.view/on-mesage.ts">
import { Services } from "@/backend/services/services";
import {
  ClientToServerChannel,
  ServerToClientChannel,
} from "@/common/ipc/channels.enum";
import { ServerPostMessageManager } from "@/common/ipc/server-ipc";
import * as vscode from "vscode";

// Function to handle messages for the file explorer view
export function onMessage(
  serverIpc: ServerPostMessageManager
) {onMessage
  serverIpc.onClientMessage(
    ClientToServerChannel.RequestWorkspaceFiles,
    async (data) => {
      const workspaceRoots =
      vscode.workspace.workspaceFolders?.map((folder) => folder.uri) || [];
      const fsService = Services.getFSService();
      const files = await fsService.getFilesRespectingGitignore();
      const fileTree = fsService.createFileTree(workspaceRoots, files);

      // Use the VSCode API to retrieve workspace files
      // const files = await vscode.workspace.findFiles("**/*");

      // // Format the files into the expected response structure
      // const formattedFiles = files.map((file) => ({
      //   name: file.path.split("/").pop() || "", // Extract file name from path
      //   path: file.fsPath, // Use fsPath for the actual file path
      //   // type: vscode.workspace.fs
      //   //   .stat(file)
      //   //   .then((stat) => (stat.isDirectory() ? "directory" : "file")),
      // }));

      // const fileTypes = await Promise.all(
      //   formattedFiles.map((file) => file.type)
      // );
      // Send the files back to the client
      serverIpc.sendToClient(ServerToClientChannel.SendWorkspaceFiles, {
        // files: formattedFiles.map((file, index) => ({
        //   ...file,
        //   // type: fileTypes[index],
        //   type: 'file'
        // })),
        files: fileTree
      });
    }
  );
}
</file>

<file path="The-Creator-AI-main/src/client/views/file-explorer.view/view.scss">
/* Import Tailwind directives */
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Remove default VS Code body padding */
body {
    padding: 0;
}
</file>

<file path="The-Creator-AI-main/src/client/views/file-explorer.view/view.tsx">
import * as React from 'react';
import * as ReactDOM from 'react-dom/client';
import './view.scss';
import { ClientPostMessageManager } from '@/common/ipc/client-ipc';
import { ClientToServerChannel, ServerToClientChannel } from '@/common/ipc/channels.enum';
import FileTree from '../../components/file-tree/FileTree';
import { useState, useEffect } from 'react';
import { FileNode } from '@/common/types/file-node';

const App = () => {
    const [files, setFiles] = useState<FileNode[]>([]);
    const [selectedFiles, setSelectedFiles] = useState<string[]>([]);
    const [recentFiles, setRecentFiles] = useState<string[]>([]);
    const [activeFile, setActiveFile] = useState<string>();

    const clientIpc = ClientPostMessageManager.getInstance();

    useEffect(() => {
        // Request workspace files on component mount
        clientIpc.sendToServer(ClientToServerChannel.RequestWorkspaceFiles, {});

        // Listen for workspace files response
        clientIpc.onServerMessage(ServerToClientChannel.SendWorkspaceFiles, ({ files }) => {
            setFiles(files);
        });
    }, []);

    const handleFileClick = (filePath: string) => {
        setActiveFile(filePath);
        // Send the selected editor path to the extension
        clientIpc.sendToServer(ClientToServerChannel.SendSelectedEditor, {
            editor: {
                fileName: filePath.split('/').pop() || '',
                filePath,
                languageId: '', // You might need to determine the languageId here
            },
        });
    };


    return (
        <div className="h-full overflow-y-auto">
            {files.length > 0 ? (
                <FileTree
                    data={files}
                    onFileClick={handleFileClick}
                    selectedFiles={selectedFiles}
                    recentFiles={recentFiles}
                    activeFile={activeFile}
                    updateSelectedFiles={setSelectedFiles}
                    updateRecentFiles={setRecentFiles}
                />
            ) : (
                <div className="p-4 text-gray-500">Loading files...</div>
            )}
        </div>
    );
};

const root = ReactDOM.createRoot(document.getElementById('file-explorer-root')!);
root.render(<App />);
</file>

<file path="The-Creator-AI-main/src/client/views/index.ts">
import { viewConfig as changePlanViewConfig } from "./change-plan.view";
import { viewConfig as chatViewConfig } from "./chat.view";
import { viewConfig as fileExplorerViewConfig } from "./file-explorer.view";
import * as vscode from "vscode";
import { ServerPostMessageManager } from "@/common/ipc/server-ipc";
import { getNonce, getViewHtml } from "@/common/utils/view-html";

export const views = [
  changePlanViewConfig,
  chatViewConfig,
  fileExplorerViewConfig,
];

export const serverIPCs: Record<string, ServerPostMessageManager> = {};

export function registerViews(context: vscode.ExtensionContext) {
  views.forEach((viewConfig) => {
    context.subscriptions.push(
      vscode.window.registerWebviewViewProvider(viewConfig.type, {
        resolveWebviewView: (webviewView, _, token) => {
          webviewView.webview.options = {
            enableScripts: true,
            localResourceRoots: [context.extensionUri],
          };

          const nonce = getNonce();
          webviewView.webview.html = getViewHtml({
            webview: webviewView.webview,
            nonce,
            scriptUri: webviewView.webview
              .asWebviewUri(
                vscode.Uri.joinPath(
                  context.extensionUri,
                  "dist",
                  viewConfig.entry
                )
              )
              .toString(),
          });

          const serverIpc = ServerPostMessageManager.getInstance(
            webviewView.webview.onDidReceiveMessage,
            (data: any) => webviewView.webview.postMessage(data)
          );

          serverIPCs[viewConfig.type] = serverIpc;

          viewConfig.handleMessage(serverIpc);
        },
      })
    );
  });
}
</file>

<file path="The-Creator-AI-main/src/common/constants/agents.constants.ts">
export const AGENTS = {
  "Stubbed Code": {
    id: 1,
    hidden: true,
    name: "Stubbed code",
    systemInstructions: `Now I want you to assist me by providing targeted code snippets from requested files, replacing irrelevant or lengthy sections of **existing code** with stubs for brevity and clarity. You should **not** generate stubs for new code that is intended to be written.
    
    **Output:** You will provide a code snippet in the same programming language as the requested file. The snippet should adhere to the following guidelines:
    
        *   **Include Relevant Code:** Present the code that directly addresses the user's request or the core logic of the file.
        *   **Replace with Stubs (Existing Code Only):** Substitute unrelated or lengthy sections of existing code with clear, concise stubs.
        *   **Do Not Stub New Code:** If the user's request involves writing new code, do not generate stubs for that code. Instead, clearly indicate where the new code should be placed within the existing code structure.
        *   **Maintain Structure:** Preserve the overall structure of the file, including import statements, comments, and the order of elements.
        *   **Use Comments for Clarity:** Add comments to explain the purpose of stubs or to indicate where omitted code would normally reside and where new code should be inserted.
    
    **Stub Creation (Existing Code Only):**
    
        *   **Identify Irrelevance:** Determine which parts of the existing code are not relevant to the user's request or the file's main purpose.
        *   **Summarize with Comments:** Replace lengthy code blocks with a comment briefly describing their function (e.g., "// Database connection setup").
        *   **Preserve Signatures:** For functions and classes, keep the signatures intact but replace their bodies with ellipses (\`...\`) or a comment (e.g., "// Function implementation").
        *   **Maintain Context:** Ensure that the remaining code is still understandable and provides context for the relevant parts.
    
    **Focus Areas (If Provided):**
    
        *   **Prioritize Focus:** If the user specifies particular focus areas, prioritize those sections in the output.
        *   **Highlight Context:** Include enough surrounding code to provide context for the focused areas.
    
    **Handling New Code:**
    
        *   **Indicate Insertion Points:** Clearly mark the locations where new code should be added. Use comments like "// Add new code here" or similar.
        *   **Describe Functionality:** Briefly describe the functionality of the new code that needs to be implemented.
    
    **Additional Considerations:**
    
        *   **Handle Errors:** If the file does not exist or cannot be accessed, return an appropriate error message.
        *   **Infer Language:** Attempt to infer the programming language of the file based on its extension or content. If unsure, request clarification from the user.
        *   **Balance Brevity and Information:** Aim to create a concise snippet that provides enough information to be useful without overwhelming the user.
    
    **Example Output (JavaScript):** This is just an example output, don't use it in your implementation.
    
    \`\`\`javascript
    // File path: src/components/LoginForm.js
    
    import React, { useState } from 'react';
    
    const LoginForm = () => {
      // ... (State variables for username, password, errors, etc.)
    
      const handleSubmit = (event) => {
        event.preventDefault();
        // Add code to handle form submission here
      };
    
      return (
        <form onSubmit={handleSubmit}>
          {/* ... (Form input fields for username and password) */}
          <button type="submit">Login</button>
        </form>
      );
    };
    
    export default LoginForm;
    \`\`\`
    
    In this example, the code related to form validation has been omitted, and a comment is added to indicate where the new form submission logic should be implemented.
    \n\n\n\n\n\n
    Now I call upon you handle what I have to say below (take into consideration the plan as well if we have some active plan) -
    \n\n\n
        `,
  },
  "Acceptance Criteria": {
    id: 2,
    name: "Acceptance Criteria",
    systemInstructions: `You are a specification assistant. Help us with the acceptance criteria of the requirements.
    
    **Output Format**
    
    \`\`\`json
    {
      "title": "Short title of the desired change",
      "description": "A description of the desired change.",
      "acceptance_criteria": [
        "Acceptance criteria 1",
        "Acceptance criteria 2",
        // ... more acceptance criteria as needed
      ]
    }
    \`\`\`
    
    ** Note **
    * Don't talk about technology. Just focus on the acceptance criteria.
        `,
  },
  "Acceptance Criteria Reviewer": {
    id: 3,
    name: "Acceptance Criteria Reviewer",
    systemInstructions: `You are an acceptance criteria reviewer. Your task is to analyze and review acceptance criteria to ensure they are clear, complete, and testable.
      
      **Review Goals**
      
      * Verify that each acceptance criterion is clear and specific.
      * Ensure that the criteria are measurable and testable.
      * Identify any missing information or potential ambiguities.
      * Provide a summary of feedback and suggestions for improving the criteria.
      
      **Note:** Acceptance criteria are expected to be high-level expectations. Do not criticize the criteria for lack of details on implementation, UI, or technical specifics.
      
      **Output Format (JSON)**
      
      \`\`\`json
      {
        "review_summary": "A summary of the review findings.",
        "feedback_and_suggestions": [
          "General feedback or areas where criteria could be improved.",
          "Suggestions for refining the criteria to make them more actionable."
        ]
      }
      \`\`\`
      
      **Example Output**
      
      \`\`\`json
      {
        "review_summary": "The acceptance criteria are generally clear and meet high-level expectations but could benefit from some refinement.",
        "feedback_and_suggestions": [
          "Ensure that each criterion includes specific success metrics or measurable outcomes.",
          "Clarify any criteria that may be ambiguous in terms of expected outcomes or scope.",
          "Provide additional context if necessary to avoid potential misunderstandings during implementation."
        ]
      }
      \`\`\`
      
      **Guidelines**
      
      * **Clarity and Specificity:** Ensure that each criterion is expressed in clear and specific terms.
      * **Testability:** Confirm that the criteria can be measured or tested to determine if they are met.
      * **Feedback and Suggestions:** Provide a summary of feedback and actionable suggestions to improve the criteria.
      * **High-Level Focus:** Do not criticize for lack of implementation, UI, or technical details; focus on the high-level expectations.`,
  },
  "User Story": {
    id: 4,
    name: "User Story",
    systemInstructions: `You are a user story creation assistant. Your task is to transform acceptance criteria and code insights into concise user stories that include a list of steps the user will take to achieve their goals.
      
      **User Story Goals**
      
      * Capture the user's perspective and goals based on the acceptance criteria and insights.
      * Include a clear sequence of steps the user will take, detailing their interaction with the application.
      * Emphasize user value and the benefits of the desired changes.
      
      **Output Format (JSON)**
      
      \`\`\`json
      {
        "user_stories_summary": "A brief summary of the user stories created from the analysis.",
        "user_stories": [
          {
            "title": "Title of User Story 1",
            "story": "As a [user role], I want to [goal] so that [reason].",
            "steps": [
              "Step 1: Brief description of what the user does first.",
              "Step 2: Brief description of the next user action.",
              // ... more steps as needed
              "Final Step: Brief description of the last action or result."
            ]
          },
          {
            "title": "Title of User Story 2",
            "story": "As a [user role], I want to [goal] so that [reason].",
            "steps": [
              "Step 1: Brief description of what the user does first.",
              "Step 2: Brief description of the next user action.",
              // ... more steps as needed
              "Final Step: Brief description of the last action or result."
            ]
          }
          // ... more user stories as needed
        ]
      }
      \`\`\`
      
      **Example Output**
      
      \`\`\`json
      {
        "user_stories_summary": "The user stories focus on enhancing authentication, real-time data handling, and error management to improve user satisfaction and performance.",
        "user_stories": [
          {
            "title": "Implement OAuth Authentication",
            "story": "As a user, I want to log in using my social media accounts so that I can access the application quickly and securely.",
            "steps": [
              "Step 1: Navigate to the login page.",
              "Step 2: Select the 'Login with Social Media' option.",
              "Step 3: Choose the preferred social media account.",
              "Step 4: Authorize the application to use account information.",
              "Final Step: Access the application with the authenticated session."
            ]
          },
          {
            "title": "Enable Real-Time Updates",
            "story": "As a user, I want to see live updates without refreshing the page so that I can stay informed of the latest data instantly.",
            "steps": [
              "Step 1: Open the dashboard to view data.",
              "Step 2: Observe the real-time updates as new data comes in.",
              "Final Step: Interact with the updated data immediately."
            ]
          },
          {
            "title": "Improve Error Handling",
            "story": "As an admin, I want to receive detailed error notifications so that I can address issues promptly and maintain system stability.",
            "steps": [
              "Step 1: Set up monitoring for the application.",
              "Step 2: Receive notifications for any errors detected.",
              "Step 3: Review detailed error information provided.",
              "Final Step: Take corrective actions based on the error details."
            ]
          }
        ]
      }
      \`\`\`
      
      **Guidelines**
      
      * **User-Centric:** Ensure the stories reflect the user's perspective, focusing on their needs and benefits.
      * **Concise and Clear:** Keep user stories and steps brief and easy to understand, avoiding technical jargon.
      * **Step-by-Step:** Provide a logical sequence of actions that the user will perform, ensuring clarity in user interactions.
      * **Value-Driven:** Highlight the value and reasons behind each user goal, emphasizing the impact on the user experience.
      * **Testable:** Ensure that the stories can be tested and verified in a controlled environment. Exclude user stories that are not testable.
      *               Not all the acceptance criteria can be converted into testable stories, feel free to skip those.
      `,
  },
  "Code Scout": {
    id: 5,
    name: "Code Scout",
    systemInstructions: `You are a Code Scout agent. Your task is to analyze the codebase and identify existing reference points, patterns, and implementations that are relevant to the current development task.
      
      **Scout Goals**
      
      * Identify relevant areas in the codebase that can serve as references for the current task.
      * List existing implementations or patterns that are similar or useful for the new functionality.
      * Highlight reusable components, functions, or design patterns that align with the desired changes.
      * Provide insights into the existing code structure and conventions that should be followed.
      
      **Output Format (JSON)**
      
      \`\`\`json
      {
        "scout_summary": "A summary of key reference points and patterns identified.",
        "reference_points": [
          {
            "file": "Path to the relevant file",
            "lines": "Line numbers or sections that are relevant",
            "description": "Brief explanation of why this section is relevant",
            "usage_example": "Description or snippet of how this is used in the codebase"
          },
          // ... more reference points as needed
        ],
        "existing_patterns": [
          {
            "pattern_name": "Name or description of the pattern",
            "description": "Explanation of the pattern and its relevance",
            "usage_examples": [
              {
                "file": "Path to the file using this pattern",
                "lines": "Line numbers or sections",
                "snippet": "Optional code snippet demonstrating the pattern"
              },
              // ... more usage examples as needed
            ]
          },
          // ... more patterns as needed
        ],
        "recommendations": [
          "Recommendation 1: Suggest using existing patterns or references",
          "Recommendation 2: Highlight areas to avoid based on current patterns",
          // ... more recommendations as needed
        ]
      }
      \`\`\`
      
      **Example Output**
      
      \`\`\`json
      {
        "scout_summary": "The codebase contains several relevant components and patterns that can aid in implementing the new feature.",
        "reference_points": [
          {
            "file": "src/components/UserProfile.js",
            "lines": "23-45",
            "description": "This section handles user data fetching, similar to the new feature requirements.",
            "usage_example": "Used for loading user profile details efficiently."
          },
          {
            "file": "src/utils/auth.js",
            "lines": "10-30",
            "description": "Contains authentication logic that may be reused for session management.",
            "usage_example": "Applied in the login process for token validation."
          }
        ],
        "existing_patterns": [
          {
            "pattern_name": "Observer Pattern",
            "description": "This pattern is used for handling event-driven data updates, which may be relevant for real-time features.",
            "usage_examples": [
              {
                "file": "src/components/LiveFeed.js",
                "lines": "15-50",
                "snippet": "const feedObserver = new Observer() {...}"
              }
            ]
          },
          {
            "pattern_name": "Singleton Pattern",
            "description": "Used for managing a single instance of configuration settings throughout the app.",
            "usage_examples": [
              {
                "file": "src/config/index.js",
                "lines": "5-20",
                "snippet": "class Config {...}"
              }
            ]
          }
        ],
        "recommendations": [
          "Consider reusing the authentication logic from src/utils/auth.js for consistent session management.",
          "Leverage the Observer Pattern found in src/components/LiveFeed.js for implementing real-time data features.",
          "Avoid duplicating user data fetching logic; refer to the implementation in src/components/UserProfile.js instead."
        ]
      }
      \`\`\`
      
      **Guidelines**
      
      * **Relevance and Context:** Focus on parts of the code that are directly relevant to the current implementation task.
      * **Clarity and Specificity:** Provide clear and specific descriptions of why each reference or pattern is useful.
      * **Actionable Recommendations:** Offer actionable advice on how to leverage existing code, avoiding redundant implementations.
      * **Avoid Overloading with Details:** Keep the focus on key insights and avoid unnecessary technical details.`,
  },
  "Code Analysis": {
    id: 6,
    name: "Code Analysis",
    systemInstructions: `You are an advanced code analysis assistant. Your task is to analyze the given codebase in relation to the provided acceptance criteria, extracting valuable insights that will aid in the development of a code plan.
      
      **Analysis Goals**
      
      * Evaluate how well the existing codebase meets the acceptance criteria as a whole.
      * Identify key areas that require modification or enhancement.
      * Highlight any potential issues or challenges in meeting the criteria.
      
      **Output Format (JSON)**
      
      \`\`\`json
      {
        "code_analysis_summary": "A brief summary of key insights gained from the analysis.",
        "code_analysis_list": [
          "Insight 1 based on the overall acceptance criteria analysis",
          "Insight 2 based on the overall acceptance criteria analysis",
          // ... more insights as needed
        ]
      }
      \`\`\`
      
      **Example Output**
      
      \`\`\`json
      {
        "code_analysis_summary": "The codebase partially meets the acceptance criteria, with significant gaps in real-time data handling and security measures.",
        "code_analysis_list": [
          "The current authentication system does not support OAuth, which is a key requirement.",
          "Real-time data updates are currently handled via polling; WebSocket integration is necessary for performance improvements.",
          "The application lacks comprehensive error handling, which may lead to stability issues.",
          "Code modularity needs enhancement to better support the new feature implementations."
        ]
      }
      \`\`\`
      
      **Guidelines**
      
      * **Holistic Analysis:** Evaluate the codebase as a whole, considering how well it aligns with all acceptance criteria collectively.
      * **Insightful and Concise:** Provide clear, actionable insights without delving into specific code implementations.
      * **Identify Key Areas:** Highlight areas where the codebase meets or falls short of the criteria.
      * **Avoid Code Solutions:** Focus on identifying issues and providing strategic insights rather than code-level solutions.
      `,
  },
  Architect: {
    id: 7,
    name: "Architect",
    systemInstructions: `You are a high-level code planning assistant. Your role is to make strategic decisions and outline a high-level plan based on non-technical considerations only. All technical decisions have already been made elsewhere. 
        **High-Level Plan Goals**
        
        * Define major decisions that do not involve technical details.
        * Focus solely on non-technical strategic decisions.
        
        **Output Format (JSON)**
        
        \`\`\`json
        {
          "architecture_summary": "A summary of key non-technical strategic decisions.",
          "architecture_plan": [
            {
              "decision": "Non-technical decision or strategic choice",
              "details": "Description or context related to the decision"
            },
            {
              "decision": "Another non-technical decision",
              "details": "Description or context related to this decision"
            }
            // ... more decisions as needed
          ]
        }
        \`\`\`
        
        **Example Output**
        
        \`\`\`json
        {
          "architecture_summary": "This high-level plan focuses on project management strategies and user experience improvements.",
          "architecture_plan": [
            {
              "decision": "Enhance user onboarding process",
              "details": "Update the onboarding experience to improve user engagement and retention."
            },
            {
              "decision": "Establish a feedback loop",
              "details": "Implement mechanisms for collecting user feedback to inform future enhancements."
            }
          ]
        }
        \`\`\`
        
        **Guidelines**
        
        * **Non-Technical Focus:** Concentrate on strategic and organizational decisions that are not related to specific technical implementations.
        * **Concise Descriptions:** Provide clear and brief descriptions of each decision.
        * **Avoid Technical Details:** Do not include technical aspects or implementation specifics.
        `,
  },
  "Architecture Reviewer": {
    id: 8,
    name: "Architecture Reviewer",
    systemInstructions: `You are an architecture reviewer. Your task is to analyze and review high-level architectural plans to ensure they are clear, complete, and strategically sound.
    
      **Review Goals**
      
      * Verify that each architectural decision is clear and well-defined.
      * Ensure that the decisions align with strategic goals and project requirements.
      * Identify any missing information or potential ambiguities.
      * Provide a summary of feedback and suggestions for improving the architectural plan.
      
      **Note:** Architectural plans are expected to focus on strategic decisions and high-level considerations. Do not criticize the plan for lack of technical details or implementation specifics.
      
      **Output Format (JSON)**
      
      \`\`\`json
      {
        "review_summary": "A summary of the review findings.",
        "feedback_and_suggestions": [
          "General feedback on the clarity and alignment of the architectural decisions.",
          "Suggestions for refining the plan to better meet strategic goals or address potential issues."
        ]
      }
      \`\`\`
      
      **Example Output**
      
      \`\`\`json
      {
        "review_summary": "The architectural plan is generally well-structured but could benefit from additional detail in certain areas.",
        "feedback_and_suggestions": [
          "Ensure that all major strategic goals are clearly addressed in the plan.",
          "Clarify any decisions that may have ambiguous impacts on project scope or objectives.",
          "Provide additional context or rationale for key decisions to ensure alignment with overall project vision."
        ]
      }
      \`\`\`
      
      **Guidelines**
      
      * **Clarity and Specificity:** Ensure that each architectural decision is expressed in clear and specific terms.
      * **Strategic Alignment:** Confirm that the decisions align with strategic goals and project requirements.
      * **Feedback and Suggestions:** Provide a summary of feedback and actionable suggestions to improve the architectural plan.
      * **High-Level Focus:** Do not criticize for lack of technical details or implementation specifics; focus on strategic and high-level considerations.`,
  },
  "Code Plan": {
    id: 9,
    name: "Code Plan",
    systemInstructions: `You are a code planning assistant designed to help developers plan changes to their codebase efficiently.
        You will analyze the requirements and provide a structured plan outlining the necessary modifications to each relevant file.
    
    
    **Output Format (JSON)**
    
    \`\`\`json
    {
      "title": "Short title of the desired code change",
      "description": "A description of the desired code change.",
      "code_plan": [
        {
          command: "[command to execute]",
          description: "[description of the command will do what it is supposed to do]",
        },
        {
          "filename": "[Fule path of the file to be modified]",
          "operation": "[Add, Modify, or Remove]",
          "recommendations": [
            "[Specific change 1]",
            "[Specific change 2]",
            // ... more changes as needed
          ]
        },
        // ... more file entries as needed
      ]
    }
    \`\`\`
    
    **Example Output**
    
    \`\`\`json
    {
      "title": "Add a sort_by_modified_date function to the data fetching utility",
      "description": "Add a \`sort_by_modified_date\` function to the data fetching utility.",
      "code_plan": [
        {
          "command": "pip install pandas",
          "description": "Install the pandas library for data manipulation."
        }.
        {
          "filename": "path/to/file/data_fetcher.py",
          "operation": "Add",
          "recommendations": [
            "Add a \`sort_by_modified_date\` function to the data fetching utility.",
            "Update the main data fetching function to call \`sort_by_modified_date\`."
          ]
        },
        {
          "filename": "path/to/second/file/settings.py",
          "operation": "Modify",
          "recommendations": [
            "Replace all magic numbers with descriptive constant variables."
          ]
        }
      ]
    }
    \`\`\`
    
    **Guidelines**
    
    *   **Concise and Specific:** Keep recommendations brief and focused on the action needed.
    *   **Action-Oriented:** Use verbs to clearly describe the change (e.g., "add," "modify," "refactor," "remove").
    *   **No Code:** Do not provide any code examples or snippets. Your role is to plan, not implement.
    *   **Assumptions:** If the change description is unclear, state any assumptions you make before providing recommendations.
    *   **Prioritize Impact:** If there are multiple ways to implement a change, focus on the most impactful or straightforward approaches.
    
    Note:
    * If a new file is to be added or created, you can provide the file path and its recommendations. We will take care of creating the file.
    * Follow the conventions and patterns of the existing codebase when applicable.
    `,
  },
  "Code Plan Update": {
    id: 10,
    name: "Code Plan Update",
    systemInstructions:  `You are a code planning assistant designed to help developers update their existing code plans efficiently.
    You will analyze the current code plan and the requested changes, then provide an updated structured plan incorporating these modifications.
    
    **Output Format (JSON)**
    
    \`\`\`json
    {
      "title": "Short title of the desired code change",
      "description": "A description of the desired code change.",
      "code_plan": [
        {
          command: "[command to execute]",
          description: "[description of the command will do what it is supposed to do]",
        },
        {
          "filename": "[Fule path of the file to be modified]",
          "operation": "[Add, Modify, or Remove]",
          "recommendations": [
            "[Specific change 1]",
            "[Specific change 2]",
            // ... more changes as needed
          ]
        },
        // ... more file entries as needed
      ]
    }
    \`\`\`
    
    **Example Output**
    
    \`\`\`json
    {
      "title": "Add a sort_by_modified_date function to the data fetching utility",
      "description": "Add a \`sort_by_modified_date\` function to the data fetching utility.",
      "code_plan": [
        {
          "command": "pip install pandas",
          "description": "Install the pandas library for data manipulation."
        }.
        {
          "filename": "path/to/file/data_fetcher.py",
          "operation": "Add",
          "recommendations": [
            "Add a \`sort_by_modified_date\` function to the data fetching utility.",
            "Update the main data fetching function to call \`sort_by_modified_date\`."
          ]
        },
        {
          "filename": "path/to/second/file/settings.py",
          "operation": "Modify",
          "recommendations": [
            "Replace all magic numbers with descriptive constant variables."
          ]
        }
      ]
    }
    \`\`\`
    
    Guidelines
    
    Highlight Changes: Use the "status" field to indicate whether an item is new, modified, or unchanged.
    Provide Context: In the "changelog" section, summarize significant changes made to the plan.
    Consistency: Ensure that the updated plan remains consistent with the original guidelines (concise, action-oriented, no code snippets).
    Clarity: Clearly indicate how the new requirements have been incorporated into the existing plan.
    Concise and Specific: Keep recommendations brief and focused on the action needed.
    Action-Oriented: Use verbs to clearly describe the change (e.g., "add," "modify," "refactor," "remove").
    No Code: Do not provide any code examples or snippets. Your role is to plan, not implement.
    Assumptions: If the change description is unclear, state any assumptions you make before providing recommendations.
    Prioritize Impact: If there are multiple ways to implement a change, focus on the most impactful or straightforward approaches. ` 
  },
  Developer: {
    id: 11,
    name: "Developer",
    systemInstructions: `# Full Code Agent Instructions
  
  You are now a Full Code Agent, tasked with providing complete, fully-implemented code snippets based on user requests. Your role is to generate functional, production-ready code that addresses the user's needs comprehensively.
  
  ## Output Guidelines:
  
  1. **Complete Implementation:** Provide fully functional code that addresses all aspects of the user's request. Do not use stubs or placeholders.
  
  2. **Language Consistency:** Use the programming language specified by the user or inferred from the context of the request.
  
  3. **Best Practices:** Adhere to coding best practices, including proper indentation, meaningful variable names, and appropriate comments.
  
  4. **Error Handling:** Implement robust error handling and input validation where applicable.
  
  5. **Modularity:** Write modular, reusable code when appropriate.
  
  6. **Documentation:** Include inline comments to explain complex logic or non-obvious implementations.
  
  7. **Imports and Dependencies:** Include all necessary import statements and specify any external dependencies.
  
  8. **Example Usage:** When beneficial, provide a brief example of how to use the implemented code.
  
  ## Handling Requests:
  
  1. **Clarification:** If the user's request is ambiguous, ask for clarification before proceeding with the implementation.
  
  2. **Scope Management:** If the request is too broad or complex for a single response, suggest breaking it down into smaller, manageable parts.
  
  3. **Alternatives:** If multiple implementation approaches are viable, briefly explain the options and implement the most suitable one.
  
  4. **Performance Considerations:** When relevant, mention any performance implications of the chosen implementation.
  
  5. **Security Awareness:** If the requested functionality involves security-sensitive operations, implement appropriate safeguards and mention any potential security considerations.
  
  ## Additional Considerations:
  
  1. **Compatibility:** Consider cross-platform or cross-browser compatibility if relevant to the user's needs.
  
  2. **Scalability:** When appropriate, implement code that can scale with increasing data or user load.
  
  3. **Testing:** If space allows, include basic unit tests or suggest testing strategies for the implemented code.
  
  4. **Limitations:** Clearly state any limitations or assumptions made in the implementation.
  
  5. **Further Improvements:** If applicable, suggest potential optimizations or enhancements that could be made to the code in the future.
  
  Remember, your goal is to provide code that is as close to production-ready as possible, requiring minimal modification from the user. Always prioritize correctness, readability, and maintainability in your implementations.
  
  ## Response Format:
  
  When providing code, use the following structure:
  
  Follow with the code in a properly formatted code block using the appropriate language identifier.
  
  ## Response Example:
  
  Here's an example of how you should respond to a user request:
  
  User: "Can you create a Python function that calculates the factorial of a number?"
  
  Agent Response:
  
  \`\`\`python
  def factorial(n):
      '''
      Calculate the factorial of a non-negative integer.
      
      Args:
      n (int): The number to calculate the factorial of.
      
      Returns:
      int: The factorial of n.
      
      Raises:
      ValueError: If n is negative.
      '''
      if not isinstance(n, int):
          raise TypeError('Input must be an integer')
      if n < 0:
          raise ValueError('Factorial is not defined for negative numbers')
      if n == 0 or n == 1:
          return 1
      else:
          return n * factorial(n - 1)
  \`\`\`

  **Output Format (code)**
  \`\`\`<language_code>
  // Your code here
  \`\`\`

  **Example Output**
  \`\`\`python
  def factorial(n):
      '''
      Calculate the factorial of a non-negative integer.
      
      Args:
      n (int): The number to calculate the factorial of.
      
      Returns:
      int: The factorial of n.
      
      Raises:
      ValueError: If n is negative.
      '''
      if not isinstance(n, int):
          raise TypeError('Input must be an integer')
      if n < 0:
          raise ValueError('Factorial is not defined for negative numbers')
      if n == 0 or n == 1:
          return 1
      else:
          return n * factorial(n - 1)
  \`\`\`
  
  Remember to adapt your responses to the specific requirements of each user request while maintaining this structure and level of completeness. Use the appropriate language identifier for the code block (e.g., \`\`\`python for Python, \`\`\`javascript for JavaScript, \`\`\`tsx for TypeScript React, etc.).
  
  Note:
  * Follow the conventions and patterns of the existing codebase when applicable.
  `,
  },
  Developer_diff: {
    id: 12,
    name: "Developer (diff)",
    systemInstructions: `# Developer (diff) instructions
  You are now a Diff Developer Agent, tasked with providing code diff to replace sections of content in an existing file using SEARCH/REPLACE blocks that define exact changes to specific parts of the file. This tool should be used when you need to make targeted changes to specific parts of a file.
  This is alsmost like git diff but in a more structured way. You will provide a diff block that shows the changes to be made in the file.

  Note: file path should be inside search block.
  
  ## Response Format:
  
  When providing code, use the following structure:
  
  Follow with the code in a properly formatted diff block.

  \`\`\`diff
<file-path>
<<<<<<< SEARCH
<original code>
=======
<modified code>
>>>>>>> REPLACE
\`\`\`

  
  ## Response Example:
  
  Here's an example of how you should respond to a user request:

Example:

Let's say this is the original file -
\`\`\`code
const divide = (a, b) => {
  return a / b;
};
const sum = (a, b) => {
  return a + b;
}
const multiply = (a, b) => {
  return a * b;
};
\`\`\`

User: Can you please make sum accept three arguments and return the sum of all three.

Agent response:

\`\`\`diff
I:\a\path\to\change.ts
<<<<<<< SEARCH
const sum = (a, b) => {
  return a + b;
}
=======
const sum = (a, b, c) => {
  return a + b + c;
}
>>>>>>> REPLACE
\`\`\`

Critical rules:
  1. SEARCH content must match the associated file section to find EXACTLY:
     * Match character-for-character including whitespace, indentation, line endings
     * Include all comments, docstrings, etc.
  2. SEARCH/REPLACE blocks will ONLY replace the first match occurrence.
     * Including multiple unique SEARCH/REPLACE blocks if you need to make multiple changes.
     * Include *just* enough lines in each SEARCH section to uniquely match each set of lines that need to change.
     * When using multiple SEARCH/REPLACE blocks, list them in the order they appear in the file.
  3. Keep SEARCH/REPLACE blocks concise:
     * Break large SEARCH/REPLACE blocks into a series of smaller blocks that each change a small portion of the file.
     * Include just the changing lines, and a few surrounding lines if needed for uniqueness.
     * Do not include long runs of unchanging lines in SEARCH/REPLACE blocks.
     * Each line must be complete. Never truncate lines mid-way through as this can cause matching failures.
  4. Special operations:
     * To move code: Use two SEARCH/REPLACE blocks (one to delete from original + one to insert at new location)
     * To delete code: Use empty REPLACE section
`
  }
};
</file>

<file path="The-Creator-AI-main/src/common/firebase.ts">
// Import the functions you need from the SDKs you need
import { initializeApp } from "firebase/app";
import { getAnalytics } from "firebase/analytics";
// TODO: Add SDKs for Firebase products that you want to use
// https://firebase.google.com/docs/web/setup#available-libraries

// Your web app's Firebase configuration
// For Firebase JS SDK v7.20.0 and later, measurementId is optional
const firebaseConfig = {
  apiKey: "AIzaSyCqkthuqSjfIYNphtVzaTfC9OrWkRdyInI",
  authDomain: "the-creator-ai---extension.firebaseapp.com",
  projectId: "the-creator-ai---extension",
  storageBucket: "the-creator-ai---extension.appspot.com",
  messagingSenderId: "880822858438",
  appId: "1:880822858438:web:858b3ee79f18fd7985ddc7",
  measurementId: "G-GHB1S5QL2Y"
};

// Initialize Firebase
export const app = initializeApp(firebaseConfig);
export const analytics = getAnalytics(app);
</file>

<file path="The-Creator-AI-main/src/common/ipc/channels.enum.ts">
export enum ClientToServerChannel {
  SendMessage = "clientToServer.sendMessage",
  RequestChatHistory = "clientToServer.requestChatHistory",
  RequestOpenEditors = "clientToServer.requestOpenEditors",
  SendSelectedEditor = "clientToServer.sendSelectedEditor",
  RequestWorkspaceFiles = "clientToServer.requestWorkspaceFiles",
  RequestFileCode = "clientToServer.requestFileCode",
  RequestOpenFile = "clientToServer.requestOpenFile",
  SendStreamMessage = "clientToServer.sendStreamMessage",
  PersistStore = "clientToServer.persistStore",
  FetchStore = "clientToServer.fetchStore",
  RequestCommitMessageSuggestions = "clientToServer.requestCommitMessageSuggestions",
  CommitStagedChanges = "clientToServer.commitStagedChanges",
  RequestStreamFileCode = "clientToServer.requestStreamFileCode",
  // New channels for API key management
  GetLLMApiKeys = "clientToServer.getLLMApiKeys",
  SetLLMApiKey = "clientToServer.setLLMApiKey",
  DeleteLLMApiKey = "clientToServer.deleteLLMApiKey",
  // New channels for symbol retrieval
  RequestSymbols = "clientToServer.requestSymbols" 
}

export enum ServerToClientChannel {
  SendMessage = "serverToClient.sendMessage",
  SendChatHistory = "serverToClient.sendChatHistory",
  SendOpenEditors = "serverToClient.sendOpenEditors",
  SendWorkspaceFiles = "serverToClient.sendWorkspaceFiles",
  SendFileCode = "serverToClient.sendFileCode",
  StreamMessage = "serverToClient.streamMessage",
  SetChangePlanViewState = "serverToClient.setChangePlanViewState", // Fixed typo here
  SendCommitMessageSuggestions = "serverToClient.sendCommitMessageSuggestions",
  StreamFileCode = "serverToClient.streamFileCode",
  // New channels for API key management
  SendLLMApiKeys = "serverToClient.sendLLMApiKeys",
  // New channel for sending symbols
  SendSymbols = "serverToClient.sendSymbols" 
}
</file>

<file path="The-Creator-AI-main/src/common/ipc/channels.type.ts">
import { FileNode } from "@/common/types/file-node";
import { ClientToServerChannel, ServerToClientChannel } from "./channels.enum";
import { ChatMessage } from "@/backend/repositories/chat.respository";
import { KeyPaths, KeyPathValue } from "@/common/utils/key-path";
import { ChangePlanViewStore } from "@/client/views/change-plan.view/store/change-plan-view.state-type";
import { LlmServiceEnum } from "@/backend/types/llm-service.enum";

export type ChannelBody<T extends ClientToServerChannel | ServerToClientChannel> =
  T extends ClientToServerChannel.SendMessage
    ? { chatHistory: ChatMessage[]; selectedFiles: string[] }
    : T extends ServerToClientChannel.SendMessage
    ? { message: string }
    : T extends ClientToServerChannel.SendStreamMessage
    ? { chatHistory: ChatMessage[]; selectedFiles: string[] }
    : T extends ServerToClientChannel.StreamMessage
    ? { chunk: string }
    : T extends ClientToServerChannel.RequestChatHistory
    ? {
        chatId?: string;
      }
    : T extends ServerToClientChannel.SendChatHistory
    ? {
        chatId: string;
        messages: {
          user: string;
          message: string;
        }[];
      }
    : T extends ClientToServerChannel.RequestOpenEditors
    ? {}
    : T extends ServerToClientChannel.SendOpenEditors
    ? {
        editors: {
          fileName: string;
          filePath: string;
          languageId: string;
        }[];
      }
    : T extends ClientToServerChannel.SendSelectedEditor
    ? {
        editor: {
          fileName: string;
          filePath: string;
          languageId: string;
        };
      }
    : T extends ClientToServerChannel.RequestWorkspaceFiles
    ? {
        // You can add options for filtering here if needed
        // e.g., fileTypes: string[];
      }
    : T extends ServerToClientChannel.SendWorkspaceFiles
    ? {
        files: FileNode[];
      }
    : T extends ClientToServerChannel.RequestOpenFile
    ? {
        filePath: string;
      }
    : T extends ClientToServerChannel.RequestFileCode
    ? {
        filePath: string;
        chatHistory: ChatMessage[];
        selectedFiles: string[];
      }
    : T extends ServerToClientChannel.SendFileCode
    ? {
        filePath: string;
        fileContent: string;
      }
    : T extends ClientToServerChannel.RequestStreamFileCode
    ? {
        filePath: string;
        chatHistory: ChatMessage[];
        selectedFiles: string[];
      }
    : T extends ServerToClientChannel.StreamFileCode
    ? {
        filePath: string;
        chunk: string;
      }
    : T extends ClientToServerChannel.PersistStore
    ? {
        storeName: string;
        storeState: any;
      }
    : T extends ClientToServerChannel.FetchStore
    ? {
        storeName: string;
      }
    : T extends ServerToClientChannel.SetChangePlanViewState
    ? {
        keyPath: KeyPaths<ChangePlanViewStore>;
        value: KeyPathValue<KeyPaths<ChangePlanViewStore>, ChangePlanViewStore>;
      }
    : T extends ClientToServerChannel.RequestCommitMessageSuggestions
    ? {
        chatHistory: ChatMessage[];
      }
    : T extends ServerToClientChannel.SendCommitMessageSuggestions
    ? {
        suggestions: string[];
      }
    : T extends ClientToServerChannel.CommitStagedChanges
    ? {
        message: string;
        description: string;
      }
    : T extends ClientToServerChannel.GetLLMApiKeys
    ? {}
    : T extends ClientToServerChannel.SetLLMApiKey
    ? { service: LlmServiceEnum; apiKey: string }
    : T extends ClientToServerChannel.DeleteLLMApiKey
    ? { service: LlmServiceEnum; apiKeyToDelete: string }
    : T extends ServerToClientChannel.SendLLMApiKeys
    ? { apiKeys: Record<LlmServiceEnum, string[]> | undefined }
    : T extends ClientToServerChannel.RequestSymbols
    ? {
        query?: string;
      }
    : T extends ServerToClientChannel.SendSymbols
    ? {
        symbols: any;
      }
    : never;
</file>

<file path="The-Creator-AI-main/src/common/ipc/client-ipc.ts">
import getVscode from "./get-vscode-api";
import { ClientToServerChannel, ServerToClientChannel } from "./channels.enum";
import { ChannelBody } from "./channels.type";

// Client-side PostMessageManager
export class ClientPostMessageManager {
  private static _instance?: ClientPostMessageManager;
  private _listeners: {
    channel: ServerToClientChannel,
    callback: (body: ChannelBody<ServerToClientChannel>) => void
  }[];

  private constructor() {
    this._listeners = [];
    window.addEventListener('message', (event: MessageEvent) => {
      const data = event.data;

      this._listeners.forEach((listener) => {
        if (listener.channel === data.channel) {
          listener.callback(data.body);
        }
      });
    });
  }

  static getInstance(): ClientPostMessageManager {
    if (!ClientPostMessageManager._instance) {
      ClientPostMessageManager._instance = new ClientPostMessageManager();
    }
    return ClientPostMessageManager._instance;
  }

  sendToServer<T extends ClientToServerChannel>(channel: T, body: ChannelBody<T>): void {
    const message = { channel, body };
    getVscode().postMessage(message);
  }

  onServerMessage<T extends ServerToClientChannel>(channel: T, callback: (body: ChannelBody<T>) => void): void {
    this._listeners.push({ channel, callback: callback as any });
  }
}
</file>

<file path="The-Creator-AI-main/src/common/ipc/get-vscode-api.ts">
import { WebviewApi } from "../types/vscode-webview";

let vscode: WebviewApi<unknown> | null = null;

const getVscode = () => {
    if (!vscode) {
        vscode = acquireVsCodeApi();
    }
    return vscode;
};

export default getVscode;
</file>

<file path="The-Creator-AI-main/src/common/ipc/server-ipc.ts">
import { ClientToServerChannel, ServerToClientChannel } from "./channels.enum";
import { ChannelBody } from "./channels.type";

export class ServerPostMessageManager {
    private static _instance?: ServerPostMessageManager;
    private _listeners: {
        channel: ClientToServerChannel,
        callback: (body: ChannelBody<ClientToServerChannel>) => void
    }[];
    private constructor(
        private onMessage: (data: any) => void,
        private sendMessage: (message: any) => void
    ) {
        this._listeners = [];
        this.onMessage((data: any) => {
            this._listeners.forEach((listener) => {
                if (listener.channel === data.channel) {
                    listener.callback(data.body);
                }
            });
        });
    }

    static getInstance(
        onMessage?: (data: any) => void,
        sendMessage?: (message: any) => void
    ) {
        if (onMessage && sendMessage) {
            ServerPostMessageManager._instance = new ServerPostMessageManager(onMessage, sendMessage);
        }
        return ServerPostMessageManager._instance;
    }

    // Server-to-Client communication 
    sendToClient<T extends ServerToClientChannel>(channel: T, body: ChannelBody<T>): void {
        const message = { channel, body };
        this.sendMessage(message);
    }

    onClientMessage<T extends ClientToServerChannel>(channel: T, callback: (body: ChannelBody<T>) => void): void {
        this._listeners.push({ channel, callback: callback as any });
    }
}
</file>

<file path="The-Creator-AI-main/src/common/types/file-node.ts">
export interface FileNode {
  name: string;
  children?: FileNode[];
  absolutePath?: string;
}
</file>

<file path="The-Creator-AI-main/src/common/types/vscode-webview.d.ts">
// Type definitions for non-npm package vscode-webview 1.57
// Project: https://code.visualstudio.com/api/extension-guides/webview
// Definitions by: Matt Bierner <https://github.com/mjbvz>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped
// Minimum TypeScript Version: 3.0

/**
 * API exposed to webviews.
 *
 * @template StateType Type of the persisted state stored for the webview.
 */
export interface WebviewApi<StateType> {
    /**
     * Post a message to the owner of the webview.
     *
     * @param message Data to post. Must be JSON serializable.
     */
    postMessage(message: unknown): void;

    /**
     * Get the persistent state stored for this webview.
     *
     * @return The current state or `undefined` if no state has been set.
     */
    getState(): StateType | undefined;

    /**
     * Set the persistent state stored for this webview.
     *
     * @param newState New persisted state. This must be a JSON serializable object. Can be retrieved
     * using {@link getState}.
     *
     * @return The new state.
     */
    setState<T extends StateType | undefined>(newState: T): T;
}

declare global {
    /**
     * Acquire an instance of the webview API.
     *
     * This may only be called once in a webview's context. Attempting to call `acquireVsCodeApi` after it has already
     * been called will throw an exception.
     *
     * @template StateType Type of the persisted state stored for the webview.
     */
    // tslint:disable-next-line:no-unnecessary-generics
    function acquireVsCodeApi<StateType = unknown>(): WebviewApi<StateType>;
}
</file>

<file path="The-Creator-AI-main/src/common/utils/firebaseLogger.ts">
import { analytics } from "@/common/firebase";
import { getAnalytics, logEvent } from "firebase/analytics";

// Enum for Firebase events
export enum FirebaseEvents {
  EXTENSION_ACTIVATED = "extension_activated",
  SIDEBAR_OPENED = "sidebar_opened",
  PLAN_FETCHED = "plan_fetched",
  FILE_CODE_REQUESTED = "file_code_requested",
  FILE_CODE_GENERATED = "file_code_generated",
}

// Class for logging events to Firebase
export class Log {
  static logEvent(event: FirebaseEvents, params?: Record<string, any>): void {
    logEvent(analytics, event, {
      app_name: "the-creator-ai",
      app_version: "0.1.1",
      ...params,
    });
  }

  static extensionActivated(): void {
    this.logEvent(FirebaseEvents.EXTENSION_ACTIVATED);
  }

  static sidebarOpened(): void {
    this.logEvent(FirebaseEvents.SIDEBAR_OPENED);
  }

  static planFetched(): void {
    this.logEvent(FirebaseEvents.PLAN_FETCHED);
  }

  static fileCodeRequested(): void {
    this.logEvent(FirebaseEvents.FILE_CODE_REQUESTED);
  }

  static fileCodeGenerated(): void {
    this.logEvent(FirebaseEvents.FILE_CODE_GENERATED);
  }
}
</file>

<file path="The-Creator-AI-main/src/common/utils/key-path.ts">
export type KeyPaths<T> = T extends object
  ? {
      [K in keyof Required<T>]: `${Exclude<K, symbol>}${
        | ""
        | (Required<T>[K] extends Array<infer U>
            ? ""
            : Required<T>[K] extends object
            ? `.${KeyPaths<Required<T>[K]>}`
            : "")}`;
    }[keyof T]
  : "";

export type KeyPathValue<KeyPath, Obj> =
  KeyPath extends `${infer K}.${infer Rest}`
    ? K extends keyof Obj
      ? KeyPathValue<Rest, Obj>
      : never
    : KeyPath extends keyof Obj
    ? Obj[KeyPath]
    : never;

export const getNestedValue = <T>(obj: T, path?: string): any => {
  return path
    ? path.split(".").reduce((acc: any, part: string) => acc && acc[part], obj)
    : obj;
};

export const setNestedValue = <T>(
  obj: T,
  keyPath: KeyPaths<T>,
  value: KeyPathValue<KeyPaths<T>, T>
): T => {
  const keys = keyPath.split(".");
  const lastKey = keys.pop();
  let newObj = obj;
  let ref = newObj;
  keys.forEach((key) => {
    ref = ref[key];
  });
  ref[lastKey] = value;
  return newObj;
};
</file>

<file path="The-Creator-AI-main/src/common/utils/parse-json.ts">
export const parseJsonResponse = (response: string): any | null => {
  try {
    if (!response) {
      return null;
    }
    const jsonStart = response.indexOf("```json");
    const jsonEnd = response.lastIndexOf("```") + 1;

    if (jsonStart !== -1 && jsonEnd !== -1) {
      const jsonStr = response
        .substring(jsonStart + 7, jsonEnd - 2)
        ?.replaceAll("\n", "");
      return JSON.parse(jsonStr);
    }
  } catch (error) {
    console.error("Error parsing JSON:", error);
  }
  return null;
};
</file>

<file path="The-Creator-AI-main/src/common/utils/view-html.ts">
import * as vscode from "vscode";

export function getViewHtml({
  webview,
  nonce,
  scriptUri,
}: {
  webview: vscode.Webview;
  nonce: string;
  scriptUri: string;
}): string {
  return `<!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src ${webview.cspSource} 'unsafe-inline'; script-src 'nonce-${nonce}' https://www.gstatic.com/firebasejs/ https://www.googletagmanager.com; connect-src https://firebaseinstallations.googleapis.com https://firebaseremoteconfig.googleapis.com https://firebaselogging.googleapis.com https://firebaseanalytics.googleapis.com;">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
            </head>
            <body>
                <div id="change-plan-view-root"></div>
                <script nonce="${nonce}" src="${scriptUri}"></script>
            </body>
            </html>`;
}

export function getNonce() {
  let text = "";
  const possible =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  for (let i = 0; i < 32; i++) {
    text += possible.charAt(Math.floor(Math.random() * possible.length));
  }
  return text;
}
</file>

<file path="The-Creator-AI-main/src/common/view-types.ts">
export const VIEW_TYPES = {
  SIDEBAR: {
    CHAT: "viewType.sidebar.chat",
    FILE_EXPLORER: "viewType.sidebar.fileExplorer",
    CHANGE_PLAN: "viewType.sidebar.changePlan",
  },
};
</file>

<file path="The-Creator-AI-main/src/extension.ts">
import * as vscode from "vscode";
import { registerViews } from "./client/views";
import { registerCommands } from "./backend/commands/register-commands";
import { Services } from "./backend/services/services";

let globalContext: vscode.ExtensionContext | null = null;
export function activate(context: vscode.ExtensionContext) {
  globalContext = context;

  console.log(
    'Congratulations, your extension "the-creator-ai" is now active!'
  );

  registerCommands(context);
  registerViews(context);
  Services.initialize();
}

export function getContext() {
  return globalContext;
}

export function deactivate() {}
</file>

<file path="The-Creator-AI-main/src/test/extension.test.ts">
import * as assert from 'assert';

// You can import and use all API from the 'vscode' module
// as well as import your extension to test it
import * as vscode from 'vscode';
// import * as myExtension from '../../extension';

suite('Extension Test Suite', () => {
	vscode.window.showInformationMessage('Start all tests.');

	test('Sample test', () => {
		assert.strictEqual(-1, [1, 2, 3].indexOf(5));
		assert.strictEqual(-1, [1, 2, 3].indexOf(0));
	});
});
</file>

<file path="The-Creator-AI-main/tailwind.config.js">
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: ["./src/**/*.{html,js,jsx,ts,tsx}"],
  theme: {
    extend: {
      colors: {
        'dropdown-bg': 'var(--vscode-dropdown-background)',
        'active-selection-bg': 'var(--vscode-list-activeSelectionBackground)',
        'focus-bg': 'var(--vscode-list-focusBackground)',
        'dropdown-list-bg': 'var(--vscode-dropdown-list-background)',
        'settings-input-bg': 'var(--vscode-settings-textInputBackground)',
        'inactive-selection-bg': 'var(--vscode-list-inactiveSelectionBackground)',
        'hover-bg': 'var(--vscode-list-hoverBackground)',
        'drop-bg': 'var(--vscode-list-dropBackground)',
        'highlight-fg': 'var(--vscode-list-highlightForeground)',
        'button-bg': 'var(--vscode-button-background)',
        'editor-bg': 'var(--vscode-editor-background)',
        'editor-fg': 'var(--vscode-editor-foreground)',
        'selection-bg': 'var(--vscode-selection-background)',
        'selection-highlight-bg': 'var(--vscode-editor-selectionHighlightBackground)',
        'editor-selection-bg': 'var(--vscode-editor-selectionBackground)',
        'word-highlight-bg': 'var(--vscode-editor-wordHighlightBackground)',
        'word-highlight-strong-bg': 'var(--vscode-editor-wordHighlightStrongBackground)',
        'line-highlight-bg': 'var(--vscode-editor-lineHighlightBackground)',
        'line-number-active-fg': 'var(--vscode-editorLineNumber-activeForeground)',
        'cursor-fg': 'var(--vscode-editorCursor-foreground)',
        'whitespace-fg': 'var(--vscode-editorWhitespace-foreground)',
        'indent-guide-bg': 'var(--vscode-editorIndentGuide-background)',
        'indent-guide-active-bg': 'var(--vscode-editorIndentGuide-activeBackground)',
        'editor-group-header-tabs-bg': 'var(--vscode-editorGroupHeader-tabsBackground)',
        'editor-group-drop-bg': 'var(--vscode-editorGroup-dropBackground)',
        'tab-inactive-bg': 'var(--vscode-tab-inactiveBackground)',
        'tab-border': 'var(--vscode-tab-border)',
        'tab-modified-border': 'var(--vscode-tab-modifiedBorder)',
        'tab-inactive-fg': 'var(--vscode-tab-inactiveForeground)',
        'widget-shadow': 'var(--vscode-widget-shadow)',
        'progress-bar-bg': 'var(--vscode-progressBar-background)',
        'badge-bg': 'var(--vscode-badge-background)',
        'badge-fg': 'var(--vscode-badge-foreground)',
        'line-number-fg': 'var(--vscode-editorLineNumber-foreground)',
        'panel-title-active-fg': 'var(--vscode-panelTitle-activeForeground)',
        'panel-title-active-border': 'var(--vscode-panelTitle-activeBorder)',
        'panel-title-inactive-fg': 'var(--vscode-panelTitle-inactiveForeground)',
        'panel-border': 'var(--vscode-panel-border)',
        'title-bar-active-bg': 'var(--vscode-titleBar-activeBackground)',
        'status-bar-bg': 'var(--vscode-statusBar-background)',
        'status-bar-no-folder-bg': 'var(--vscode-statusBar-noFolderBackground)',
        'status-bar-debugging-bg': 'var(--vscode-statusBar-debuggingBackground)',
        'activity-bar-bg': 'var(--vscode-activityBar-background)',
        'activity-bar-fg': 'var(--vscode-activityBar-foreground)',
        'activity-bar-drop-bg': 'var(--vscode-activityBar-dropBackground)',
        'sidebar-bg': 'var(--vscode-sideBar-background)',
        'sidebar-section-header-bg': 'var(--vscode-sideBarSectionHeader-background)',
        'menu-bg': 'var(--vscode-menu-background)',
        'menu-fg': 'var(--vscode-menu-foreground)',
        'picker-group-fg': 'var(--vscode-pickerGroup-foreground)',
        'input-bg': 'var(--vscode-input-background)',
        'input-option-active-border': 'var(--vscode-inputOption-activeBorder)',
        'focus-border': 'var(--vscode-focusBorder)',
        'editor-widget-bg': 'var(--vscode-editorWidget-background)',
        'debug-toolbar-bg': 'var(--vscode-debugToolBar-background)',
        'diff-editor-inserted-text-bg': 'var(--vscode-diffEditor-insertedTextBackground)',
        'diff-editor-removed-text-bg': 'var(--vscode-diffEditor-removedTextBackground)',
        'input-validation-error-bg': 'var(--vscode-inputValidation-errorBackground)',
        'input-validation-error-border': 'var(--vscode-inputValidation-errorBorder)',
        'input-validation-warning-bg': 'var(--vscode-inputValidation-warningBackground)',
        'input-validation-warning-border': 'var(--vscode-inputValidation-warningBorder)',
        'input-validation-info-bg': 'var(--vscode-inputValidation-infoBackground)',
        'input-validation-info-border': 'var(--vscode-inputValidation-infoBorder)',
        'editor-hover-widget-bg': 'var(--vscode-editorHoverWidget-background)',
        'editor-hover-widget-border': 'var(--vscode-editorHoverWidget-border)',
        'editor-suggest-widget-bg': 'var(--vscode-editorSuggestWidget-background)',
        'editor-suggest-widget-border': 'var(--vscode-editorSuggestWidget-border)',
        'editor-group-border': 'var(--vscode-editorGroup-border)',
        'peek-view-border': 'var(--vscode-peekView-border)',
        'peek-view-editor-bg': 'var(--vscode-peekViewEditor-background)',
        'peek-view-result-bg': 'var(--vscode-peekViewResult-background)',
        'peek-view-title-bg': 'var(--vscode-peekViewTitle-background)',
        'peek-view-result-selection-bg': 'var(--vscode-peekViewResult-selectionBackground)',
        'peek-view-result-match-highlight-bg': 'var(--vscode-peekViewResult-matchHighlightBackground)',
        'peek-view-editor-match-highlight-bg': 'var(--vscode-peekViewEditor-matchHighlightBackground)',
        'terminal-ansi-black': 'var(--vscode-terminal-ansiBlack)',
        'terminal-ansi-red': 'var(--vscode-terminal-ansiRed)',
        'terminal-ansi-green': 'var(--vscode-terminal-ansiGreen)',
        'terminal-ansi-yellow': 'var(--vscode-terminal-ansiYellow)',
        'terminal-ansi-blue': 'var(--vscode-terminal-ansiBlue)',
        'terminal-ansi-magenta': 'var(--vscode-terminal-ansiMagenta)',
        'terminal-ansi-cyan': 'var(--vscode-terminal-ansiCyan)',
        'terminal-ansi-white': 'var(--vscode-terminal-ansiWhite)',
        'terminal-ansi-bright-black': 'var(--vscode-terminal-ansiBrightBlack)',
        'terminal-ansi-bright-red': 'var(--vscode-terminal-ansiBrightRed)',
        'terminal-ansi-bright-green': 'var(--vscode-terminal-ansiBrightGreen)',
        'terminal-ansi-bright-yellow': 'var(--vscode-terminal-ansiBrightYellow)',
        'terminal-ansi-bright-blue': 'var(--vscode-terminal-ansiBrightBlue)',
        'terminal-ansi-bright-magenta': 'var(--vscode-terminal-ansiBrightMagenta)',
        'terminal-ansi-bright-cyan': 'var(--vscode-terminal-ansiBrightCyan)',
        'terminal-ansi-bright-white': 'var(--vscode-terminal-ansiBrightWhite)',
      },
    },
  },
  plugins: [],
}
</file>

<file path="The-Creator-AI-main/tsconfig.json">
{
	"compilerOptions": {
		"module": "esnext",
		"moduleResolution": "node",
		"target": "ESNext",
		"lib": [
			"ES2022",
			"DOM"
		],
		"jsx": "react",
		"sourceMap": true,
		"rootDir": ".",
		"strict": false, /* enable all strict type-checking options */
		"noImplicitAny": false,
		"noImplicitReturns": false,
		"noImplicitThis": false,
		/* Additional Checks */
		// "noImplicitReturns": true, /* Report error when not all code paths in function return a value. */
		// "noFallthroughCasesInSwitch": true, /* Report errors for fallthrough cases in switch statement. */
		// "noUnusedParameters": true,  /* Report errors on unused parameters. */
		"baseUrl": ".",
		"paths": {
			"@/*": ["src/*"]
		},
		"experimentalDecorators": true,
		"allowSyntheticDefaultImports": true
	},
	"include": [
		"src/**/*"
	]
}
</file>

<file path="The-Creator-AI-main/vsc-extension-quickstart.md">
# Welcome to your VS Code Extension

## What's in the folder

* This folder contains all of the files necessary for your extension.
* `package.json` - this is the manifest file in which you declare your extension and command.
  * The sample plugin registers a command and defines its title and command name. With this information VS Code can show the command in the command palette. It doesnâ€™t yet need to load the plugin.
* `src/extension.ts` - this is the main file where you will provide the implementation of your command.
  * The file exports one function, `activate`, which is called the very first time your extension is activated (in this case by executing the command). Inside the `activate` function we call `registerCommand`.
  * We pass the function containing the implementation of the command as the second parameter to `registerCommand`.

## Setup

* install the recommended extensions (amodio.tsl-problem-matcher, ms-vscode.extension-test-runner, and dbaeumer.vscode-eslint)


## Get up and running straight away

* Press `F5` to open a new window with your extension loaded.
* Run your command from the command palette by pressing (`Ctrl+Shift+P` or `Cmd+Shift+P` on Mac) and typing `Hello World`.
* Set breakpoints in your code inside `src/extension.ts` to debug your extension.
* Find output from your extension in the debug console.

## Make changes

* You can relaunch the extension from the debug toolbar after changing code in `src/extension.ts`.
* You can also reload (`Ctrl+R` or `Cmd+R` on Mac) the VS Code window with your extension to load your changes.


## Explore the API

* You can open the full set of our API when you open the file `node_modules/@types/vscode/index.d.ts`.

## Run tests

* Install the [Extension Test Runner](https://marketplace.visualstudio.com/items?itemName=ms-vscode.extension-test-runner)
* Run the "watch" task via the **Tasks: Run Task** command. Make sure this is running, or tests might not be discovered.
* Open the Testing view from the activity bar and click the Run Test" button, or use the hotkey `Ctrl/Cmd + ; A`
* See the output of the test result in the Test Results view.
* Make changes to `src/test/extension.test.ts` or create new test files inside the `test` folder.
  * The provided test runner will only consider files matching the name pattern `**.test.ts`.
  * You can create folders inside the `test` folder to structure your tests any way you want.

## Go further

* Reduce the extension size and improve the startup time by [bundling your extension](https://code.visualstudio.com/api/working-with-extensions/bundling-extension).
* [Publish your extension](https://code.visualstudio.com/api/working-with-extensions/publishing-extension) on the VS Code extension marketplace.
* Automate builds by setting up [Continuous Integration](https://code.visualstudio.com/api/working-with-extensions/continuous-integration).
</file>

<file path="The-Creator-AI-main/webpack.config.js">
//@ts-check

'use strict';

const path = require('path');
const CopyPlugin = require("copy-webpack-plugin");
const webpack = require('webpack');

//@ts-check
/** @typedef {import('webpack').Configuration} WebpackConfig **/

/** @type WebpackConfig */
const extensionConfig = {
  target: 'node', // VS Code extensions run in a Node.js-context ðŸ“– -> https://webpack.js.org/configuration/node/
	mode: 'none', // this leaves the source code as close as possible to the original (when packaging we set this to 'production')

  entry: {
    extension: './src/extension.ts',
    chatView: './src/client/views/chat.view/view.tsx',
    changePlanView: './src/client/views/change-plan.view/view.tsx',
    fileExplorerView: './src/client/views/file-explorer.view/view.tsx',
  },  
  output: {
    // the bundle is stored in the 'dist' folder (check package.json), ðŸ“– -> https://webpack.js.org/configuration/output/
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].js',
    libraryTarget: 'commonjs2'
  },
  externals: {
    vscode: 'commonjs vscode' // the vscode-module is created on-the-fly and must be excluded. Add other modules that cannot be webpack'ed, ðŸ“– -> https://webpack.js.org/configuration/externals/
    // modules added here also need to be added in the .vscodeignore file
  },
  resolve: {
    // support reading TypeScript and JavaScript files, ðŸ“– -> https://github.com/TypeStrong/ts-loader
    extensions: ['.ts', '.js', '.tsx', '.jsx'],
    alias: {
      "@": path.resolve(__dirname, 'src'),
    }
  },
  module: {
    rules: [
      {
        test: /\.ts$/,
        exclude: /node_modules/,
        use: [
          {
            loader: 'ts-loader'
          }
        ]
      },
      {
        test: /\.?ts.?(x)$/,
        exclude: /node_modules/,
        use: {
          loader: "babel-loader",
          options: {
            presets: ['@babel/preset-env', '@babel/preset-react', '@babel/preset-typescript']
          }
        }
      },
      {
        test: /\.m?js$/,
        resolve: {
          fullySpecified: false
        },
      },
      {
        test: /\.s[ac]ss$/i,
        use: [
          // Creates `style` nodes from JS strings
          "style-loader",
          // Translates CSS into CommonJS
          "css-loader",
          // Compiles Sass to CSS
          "sass-loader",
          // PostCSS (needed for Tailwind)
          "postcss-loader", 
        ],
      },
    ]
  },
  plugins: [
    new CopyPlugin({
      patterns: [
        { from: "public", to: "public" }
      ],
    }),
    new webpack.ProvidePlugin({
      process: 'process/browser',
  }),
  ],
  devtool: 'nosources-source-map',
  infrastructureLogging: {
    level: "log", // enables logging required for problem matchers
  },
};
module.exports = [ extensionConfig ];
</file>

<file path="tsconfig.json">
{
    "compilerOptions": {
        "module": "esnext",
        "moduleResolution": "bundler",
        "target": "ESNext",
        "lib": ["ES2022", "DOM"],
        "jsx": "react",
        "sourceMap": true,
        "rootDir": "src",
        "strict": false,
        "baseUrl": "./",
        "paths": {
            "@/*": ["src/*"]
        },
        "experimentalDecorators": true,
        "allowSyntheticDefaultImports": true
    },
    "include": [
        "src/**/*.ts",
        "src/**/*.tsx"
    ],
    "exclude": [
        "node_modules",
        ".vscode-test",
        "The-Creator-AI-main"
    ]
}
</file>

<file path="webpack.config.js">
const path = require('path');
const CopyPlugin = require("copy-webpack-plugin");
const webpack = require('webpack');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');

/** @type {import('webpack').Configuration} */
const baseConfig = {
    mode: 'none',
    resolve: {
        extensions: ['.ts', '.js', '.tsx', '.jsx'],
        alias: {
            "@": path.resolve(__dirname, 'src'),
        }
    },
    module: {
        rules: [
            {
                test: /\.ts$/,
                exclude: /node_modules/,
                use: [{ loader: 'ts-loader' }]
            },
            {
                test: /\.?ts.?(x)$/,
                exclude: /node_modules/,
                use: {
                    loader: "babel-loader",
                    options: {
                        presets: ['@babel/preset-react', '@babel/preset-typescript']
                    }
                }
            },
        ]
    },
    devtool: 'nosources-source-map',
    infrastructureLogging: {
        level: "log",
    },
};

/** @type {import('webpack').Configuration} */
const extensionConfig = {
    ...baseConfig,
    target: 'node',
    entry: {
        extension: './src/extension.ts',
    },
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'extension.js',
        libraryTarget: 'commonjs2'
    },
    externals: {
        vscode: 'commonjs vscode',
    },
};

/** @type {import('webpack').Configuration} */
const webviewConfig = {
    ...baseConfig,
    target: 'web',
    entry: {
        contextChooserView: './src/client/views/context-chooser.view/view.tsx',
        parallelCopilotView: './src/client/views/parallel-copilot.view/view.tsx',
    },
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: '[name].js',
        libraryTarget: 'commonjs2'
    },
    module: {
        ...baseConfig.module,
        rules: [
            ...baseConfig.module.rules,
            {
                test: /\.s[ac]ss$/i,
                use: [MiniCssExtractPlugin.loader, "css-loader", "sass-loader"],
            },
        ]
    },
    resolve: {
        ...baseConfig.resolve,
        fallback: {
            "path": require.resolve("path-browserify")
        }
    },
    plugins: [
        new MiniCssExtractPlugin({
            filename: '[name].css'
        }),
        new CopyPlugin({
            patterns: [
                { from: "public", to: "public" },
                // C118: Copy the starry-night CSS theme to the dist folder so it can be loaded in the webview.
                { from: "node_modules/@wooorm/starry-night/style/both.css", to: "starry-night.css" }
            ],
        }),
        new webpack.ProvidePlugin({
            process: 'process/browser',
        }),
    ],
};

module.exports = [extensionConfig, webviewConfig];
</file>

<file path="winmerge_flattened_repo.md">
<!--
  File: flattened_repo.md
  Source Directory: c:\Projects\DCE - Copy
  Date Generated: 2025-08-24T23:24:42.370Z
  ---
  Total Files: 510
  Approx. Tokens: 970699
-->

<!-- Top 10 Text Files by Token Count -->
1. Winmerge-Src\Src\DirView.cpp (37703 tokens)
2. Winmerge-Src\Src\MainFrm.cpp (33452 tokens)
3. Winmerge-Src\Src\MergeEditView.cpp (32038 tokens)
4. Winmerge-Src\Src\MergeDoc.cpp (27369 tokens)
5. Winmerge-Src\Src\FilterEngine\FilterParser.out (19913 tokens)
6. Winmerge-Src\Src\ImgMergeFrm.cpp (18677 tokens)
7. Winmerge-Src\Src\DirViewColItems.cpp (17961 tokens)
8. Winmerge-Src\Src\Common\BCMenu.cpp (14645 tokens)
9. Winmerge-Src\Src\Merge.cpp (14304 tokens)
10. Winmerge-Src\Src\DiffWrapper.cpp (13769 tokens)

<!-- Full File List -->
1. Winmerge-Src\Src\CompareEngines\BinaryCompare.cpp - Lines: 130 - Chars: 3391 - Tokens: 848
2. Winmerge-Src\Src\CompareEngines\BinaryCompare.h - Lines: 31 - Chars: 562 - Tokens: 141
3. Winmerge-Src\Src\CompareEngines\ByteComparator.cpp - Lines: 565 - Chars: 12578 - Tokens: 3145
4. Winmerge-Src\Src\CompareEngines\ByteComparator.h - Lines: 68 - Chars: 2364 - Tokens: 591
5. Winmerge-Src\Src\CompareEngines\ByteCompare.cpp - Lines: 291 - Chars: 7877 - Tokens: 1970
6. Winmerge-Src\Src\CompareEngines\ByteCompare.h - Lines: 42 - Chars: 871 - Tokens: 218
7. Winmerge-Src\Src\CompareEngines\CompareEngines.vcxitems - Lines: 56 - Chars: 2979 - Tokens: 745
8. Winmerge-Src\Src\CompareEngines\CompareEngines.vcxitems.filters - Lines: 51 - Chars: 1968 - Tokens: 492
9. Winmerge-Src\Src\CompareEngines\ImageCompare.cpp - Lines: 112 - Chars: 3267 - Tokens: 817
10. Winmerge-Src\Src\CompareEngines\ImageCompare.h - Lines: 39 - Chars: 924 - Tokens: 231
11. Winmerge-Src\Src\CompareEngines\TimeSizeCompare.cpp - Lines: 131 - Chars: 3863 - Tokens: 966
12. Winmerge-Src\Src\CompareEngines\TimeSizeCompare.h - Lines: 35 - Chars: 631 - Tokens: 158
13. Winmerge-Src\Src\CompareEngines\Wrap_DiffUtils.cpp - Lines: 255 - Chars: 6647 - Tokens: 1662
14. Winmerge-Src\Src\CompareEngines\Wrap_DiffUtils.h - Lines: 55 - Chars: 1350 - Tokens: 338
15. Winmerge-Src\Src\diffutils\config.h - Lines: 19 - Chars: 373 - Tokens: 94
16. Winmerge-Src\Src\diffutils\diffutils.vcxitems - Lines: 65 - Chars: 3013 - Tokens: 754
17. Winmerge-Src\Src\diffutils\diffutils.vcxitems.filters - Lines: 59 - Chars: 2133 - Tokens: 534
18. Winmerge-Src\Src\diffutils\GnuVersion.c - Lines: 6 - Chars: 94 - Tokens: 24
19. Winmerge-Src\Src\diffutils\lib\cmpbuf.c - Lines: 40 - Chars: 1181 - Tokens: 296
20. Winmerge-Src\Src\diffutils\lib\cmpbuf.h - Lines: 30 - Chars: 907 - Tokens: 227
21. Winmerge-Src\Src\diffutils\src\analyze.c - Lines: 1139 - Chars: 33114 - Tokens: 8279
22. Winmerge-Src\Src\diffutils\src\context.c - Lines: 405 - Chars: 11606 - Tokens: 2902
23. Winmerge-Src\Src\diffutils\src\Diff.cpp - Lines: 40 - Chars: 1333 - Tokens: 334
24. Winmerge-Src\Src\diffutils\src\diff.h - Lines: 401 - Chars: 12919 - Tokens: 3230
25. Winmerge-Src\Src\diffutils\src\ed.c - Lines: 195 - Chars: 5213 - Tokens: 1304
26. Winmerge-Src\Src\diffutils\src\ifdef.c - Lines: 415 - Chars: 9878 - Tokens: 2470
27. Winmerge-Src\Src\diffutils\src\io.c - Lines: 1138 - Chars: 37179 - Tokens: 9295
28. Winmerge-Src\Src\diffutils\src\mystat.cpp - Lines: 94 - Chars: 2569 - Tokens: 643
29. Winmerge-Src\Src\diffutils\src\normal.c - Lines: 76 - Chars: 2454 - Tokens: 614
30. Winmerge-Src\Src\diffutils\src\side.c - Lines: 276 - Chars: 6894 - Tokens: 1724
31. Winmerge-Src\Src\diffutils\src\system.h - Lines: 216 - Chars: 4356 - Tokens: 1089
32. Winmerge-Src\Src\diffutils\src\util.c - Lines: 967 - Chars: 23608 - Tokens: 5902
33. Winmerge-Src\Src\FilterEngine\FileContentRef.cpp - Lines: 192 - Chars: 4630 - Tokens: 1158
34. Winmerge-Src\Src\FilterEngine\FileContentRef.h - Lines: 18 - Chars: 415 - Tokens: 104
35. Winmerge-Src\Src\FilterEngine\FilterEngine.vcxitems - Lines: 67 - Chars: 3377 - Tokens: 845
36. Winmerge-Src\Src\FilterEngine\FilterEngine.vcxitems.filters - Lines: 59 - Chars: 2258 - Tokens: 565
37. Winmerge-Src\Src\FilterEngine\FilterError.h - Lines: 23 - Chars: 669 - Tokens: 168
38. Winmerge-Src\Src\FilterEngine\FilterExpression.cpp - Lines: 166 - Chars: 3995 - Tokens: 999
39. Winmerge-Src\Src\FilterEngine\FilterExpression.h - Lines: 42 - Chars: 1178 - Tokens: 295
40. Winmerge-Src\Src\FilterEngine\FilterExpressionNodes.h - Lines: 181 - Chars: 4650 - Tokens: 1163
41. Winmerge-Src\Src\FilterEngine\FilterLexer.cpp - Lines: 1685 - Chars: 27869 - Tokens: 6968
42. Winmerge-Src\Src\FilterEngine\FilterLexer.h - Lines: 57 - Chars: 1018 - Tokens: 255
43. Winmerge-Src\Src\FilterEngine\FilterLexer.re - Lines: 146 - Chars: 3674 - Tokens: 919
44. Winmerge-Src\Src\FilterEngine\FilterParser.cpp - Lines: 3 - Chars: 43 - Tokens: 11
45. Winmerge-Src\Src\FilterEngine\FilterParser.h - Lines: 31 - Chars: 1380 - Tokens: 345
46. Winmerge-Src\Src\FilterEngine\FilterParser.out - Lines: 1633 - Chars: 79650 - Tokens: 19913
47. Winmerge-Src\Src\FilterEngine\FilterParser.y - Lines: 180 - Chars: 6213 - Tokens: 1554
48. Winmerge-Src\Src\Common\AccentColor.cpp - Lines: 40 - Chars: 955 - Tokens: 239
49. Winmerge-Src\Src\Common\AccentColor.h - Lines: 25 - Chars: 559 - Tokens: 140
50. Winmerge-Src\Src\Common\BCMenu.cpp - Lines: 1997 - Chars: 58579 - Tokens: 14645
51. Winmerge-Src\Src\Common\BCMenu.h - Lines: 213 - Chars: 8083 - Tokens: 2021
52. Winmerge-Src\Src\Common\Bitmap.cpp - Lines: 267 - Chars: 9474 - Tokens: 2369
53. Winmerge-Src\Src\Common\Bitmap.h - Lines: 20 - Chars: 501 - Tokens: 126
54. Winmerge-Src\Src\Common\cio.cpp - Lines: 65 - Chars: 1395 - Tokens: 349
55. Winmerge-Src\Src\Common\cio.h - Lines: 44 - Chars: 1294 - Tokens: 324
56. Winmerge-Src\Src\Common\ClipBoard.cpp - Lines: 130 - Chars: 3452 - Tokens: 863
57. Winmerge-Src\Src\Common\ClipBoard.h - Lines: 41 - Chars: 1127 - Tokens: 282
58. Winmerge-Src\Src\Common\CMoveConstraint.cpp - Lines: 770 - Chars: 20316 - Tokens: 5079
59. Winmerge-Src\Src\Common\CMoveConstraint.h - Lines: 250 - Chars: 9134 - Tokens: 2284
60. Winmerge-Src\Src\Common\ColorButton.cpp - Lines: 51 - Chars: 967 - Tokens: 242
61. Winmerge-Src\Src\Common\ColorButton.h - Lines: 27 - Chars: 646 - Tokens: 162
62. Winmerge-Src\Src\Common\coretools.cpp - Lines: 25 - Chars: 344 - Tokens: 86
63. Winmerge-Src\Src\Common\coretools.h - Lines: 9 - Chars: 143 - Tokens: 36
64. Winmerge-Src\Src\Common\DebugNew.h - Lines: 9 - Chars: 337 - Tokens: 85
65. Winmerge-Src\Src\Common\ExConverter.cpp - Lines: 333 - Chars: 9587 - Tokens: 2397
66. Winmerge-Src\Src\Common\ExConverter.h - Lines: 35 - Chars: 1229 - Tokens: 308
67. Winmerge-Src\Src\Common\IatHook.h - Lines: 117 - Chars: 4072 - Tokens: 1018
68. Winmerge-Src\Src\Common\IMDITab.h - Lines: 10 - Chars: 103 - Tokens: 26
69. Winmerge-Src\Src\Common\IniOptionsMgr.cpp - Lines: 412 - Chars: 10749 - Tokens: 2688
70. Winmerge-Src\Src\Common\IniOptionsMgr.h - Lines: 55 - Chars: 1939 - Tokens: 485
71. Winmerge-Src\Src\Common\LanguageSelect.cpp - Lines: 1062 - Chars: 24635 - Tokens: 6159
72. Winmerge-Src\Src\Common\LanguageSelect.h - Lines: 52 - Chars: 1444 - Tokens: 361
73. Winmerge-Src\Src\Common\lwdisp.c - Lines: 832 - Chars: 21988 - Tokens: 5497
74. Winmerge-Src\Src\Common\lwdisp.h - Lines: 270 - Chars: 8067 - Tokens: 2017
75. Winmerge-Src\Src\Common\MDITabBar.cpp - Lines: 924 - Chars: 25180 - Tokens: 6295
76. Winmerge-Src\Src\Common\MDITabBar.h - Lines: 139 - Chars: 3980 - Tokens: 995
77. Winmerge-Src\Src\Common\memdc.h - Lines: 108 - Chars: 2781 - Tokens: 696
78. Winmerge-Src\Src\Common\MessageBoxDialog.h - Lines: 293 - Chars: 9963 - Tokens: 2491
79. Winmerge-Src\Src\Common\multiformatText.cpp - Lines: 655 - Chars: 16466 - Tokens: 4117
80. Winmerge-Src\Src\Common\multiformatText.h - Lines: 152 - Chars: 4661 - Tokens: 1166
81. Winmerge-Src\Src\Common\OptionsMgr.cpp - Lines: 870 - Chars: 21412 - Tokens: 5353
82. Winmerge-Src\Src\Common\OptionsMgr.h - Lines: 168 - Chars: 6011 - Tokens: 1503
83. Winmerge-Src\Src\Common\PidlContainer.cpp - Lines: 42 - Chars: 1197 - Tokens: 300
84. Winmerge-Src\Src\Common\PidlContainer.h - Lines: 61 - Chars: 1551 - Tokens: 388
85. Winmerge-Src\Src\Common\PreferencesDlg.cpp - Lines: 440 - Chars: 13603 - Tokens: 3401
86. Winmerge-Src\Src\Common\PreferencesDlg.h - Lines: 129 - Chars: 3720 - Tokens: 930
87. Winmerge-Src\Src\Common\PropertyPageHost.cpp - Lines: 388 - Chars: 8447 - Tokens: 2112
88. Winmerge-Src\Src\Common\PropertyPageHost.h - Lines: 78 - Chars: 2058 - Tokens: 515
89. Winmerge-Src\Src\Common\RegKey.cpp - Lines: 348 - Chars: 9220 - Tokens: 2305
90. Winmerge-Src\Src\Common\RegKey.h - Lines: 51 - Chars: 1582 - Tokens: 396
91. Winmerge-Src\Src\Common\RegOptionsMgr.cpp - Lines: 723 - Chars: 18445 - Tokens: 4612
92. Winmerge-Src\Src\Common\RegOptionsMgr.h - Lines: 56 - Chars: 1918 - Tokens: 480
93. Winmerge-Src\Src\Common\RoundedRectWithShadow.cpp - Lines: 215 - Chars: 7790 - Tokens: 1948
94. Winmerge-Src\Src\Common\RoundedRectWithShadow.h - Lines: 15 - Chars: 614 - Tokens: 154
95. Winmerge-Src\Src\Common\scbarcf.cpp - Lines: 175 - Chars: 5529 - Tokens: 1383
96. Winmerge-Src\Src\Common\scbarcf.h - Lines: 68 - Chars: 2056 - Tokens: 514
97. Winmerge-Src\Src\Common\scbarg.cpp - Lines: 244 - Chars: 7411 - Tokens: 1853
98. Winmerge-Src\Src\Common\scbarg.h - Lines: 101 - Chars: 2742 - Tokens: 686
99. Winmerge-Src\Src\Common\Shell.cpp - Lines: 52 - Chars: 1422 - Tokens: 356
100. Winmerge-Src\Src\Common\Shell.h - Lines: 13 - Chars: 290 - Tokens: 73
101. Winmerge-Src\Src\Common\ShellContextMenu.cpp - Lines: 258 - Chars: 6962 - Tokens: 1741
102. Winmerge-Src\Src\Common\ShellContextMenu.h - Lines: 173 - Chars: 6712 - Tokens: 1678
103. Winmerge-Src\Src\Common\ShellFileOperations.cpp - Lines: 284 - Chars: 7309 - Tokens: 1828
104. Winmerge-Src\Src\Common\ShellFileOperations.h - Lines: 55 - Chars: 1583 - Tokens: 396
105. Winmerge-Src\Src\Common\sizecbar.h - Lines: 228 - Chars: 7590 - Tokens: 1898
106. Winmerge-Src\Src\Common\SortHeaderCtrl.cpp - Lines: 174 - Chars: 4352 - Tokens: 1088
107. Winmerge-Src\Src\Common\SortHeaderCtrl.h - Lines: 52 - Chars: 937 - Tokens: 235
108. Winmerge-Src\Src\Common\SplitterWndEx.cpp - Lines: 480 - Chars: 12631 - Tokens: 3158
109. Winmerge-Src\Src\Common\SplitterWndEx.h - Lines: 57 - Chars: 1535 - Tokens: 384
110. Winmerge-Src\Src\Common\SuperComboBox.cpp - Lines: 606 - Chars: 15268 - Tokens: 3817
111. Winmerge-Src\Src\Common\SuperComboBox.h - Lines: 93 - Chars: 2058 - Tokens: 515
112. Winmerge-Src\Src\Common\SysColorHook.cpp - Lines: 176 - Chars: 5665 - Tokens: 1417
113. Winmerge-Src\Src\Common\SysColorHook.h - Lines: 21 - Chars: 475 - Tokens: 119
114. Winmerge-Src\Src\Common\unicoder.cpp - Lines: 1282 - Chars: 31007 - Tokens: 7752
115. Winmerge-Src\Src\Common\unicoder.h - Lines: 135 - Chars: 4058 - Tokens: 1015
116. Winmerge-Src\Src\Common\UnicodeString.cpp - Lines: 348 - Chars: 8621 - Tokens: 2156
117. Winmerge-Src\Src\Common\UnicodeString.h - Lines: 125 - Chars: 3817 - Tokens: 955
118. Winmerge-Src\Src\Common\UniFile.cpp - Lines: 906 - Chars: 20787 - Tokens: 5197
119. Winmerge-Src\Src\Common\UniFile.h - Lines: 315 - Chars: 7843 - Tokens: 1961
120. Winmerge-Src\Src\Common\ValidatingEdit.cpp - Lines: 161 - Chars: 3294 - Tokens: 824
121. Winmerge-Src\Src\Common\ValidatingEdit.h - Lines: 36 - Chars: 731 - Tokens: 183
122. Winmerge-Src\Src\Common\varprop.cpp - Lines: 185 - Chars: 3038 - Tokens: 760
123. Winmerge-Src\Src\Common\varprop.h - Lines: 72 - Chars: 1806 - Tokens: 452
124. Winmerge-Src\Src\Common\VersionInfo.cpp - Lines: 364 - Chars: 9972 - Tokens: 2493
125. Winmerge-Src\Src\Common\VersionInfo.h - Lines: 177 - Chars: 4401 - Tokens: 1101
126. Winmerge-Src\Src\res\Merge.rc2 - Lines: 15 - Chars: 462 - Tokens: 116
127. Winmerge-Src\Src\res\mg_cur.cur - Lines: 1 - Chars: 326 - Tokens: 82
128. Winmerge-Src\Src\res\WinMerge.exe.manifest - Lines: 50 - Chars: 1513 - Tokens: 379
129. Winmerge-Src\Src\res\WinMergeU.VisualElementsManifest.xml - Lines: 4 - Chars: 340 - Tokens: 85
130. Winmerge-Src\Src\7zCommon.cpp - Lines: 741 - Chars: 22544 - Tokens: 5636
131. Winmerge-Src\Src\7zCommon.h - Lines: 109 - Chars: 2521 - Tokens: 631
132. Winmerge-Src\Src\AboutDlg.cpp - Lines: 199 - Chars: 5116 - Tokens: 1279
133. Winmerge-Src\Src\AboutDlg.h - Lines: 33 - Chars: 550 - Tokens: 138
134. Winmerge-Src\Src\BasicFlatStatusBar.cpp - Lines: 169 - Chars: 4333 - Tokens: 1084
135. Winmerge-Src\Src\BasicFlatStatusBar.h - Lines: 34 - Chars: 772 - Tokens: 193
136. Winmerge-Src\Src\charsets.h - Lines: 30 - Chars: 975 - Tokens: 244
137. Winmerge-Src\Src\ClipboardHistory.cpp - Lines: 159 - Chars: 4398 - Tokens: 1100
138. Winmerge-Src\Src\ClipboardHistory.h - Lines: 23 - Chars: 396 - Tokens: 99
139. Winmerge-Src\Src\codepage_detect.cpp - Lines: 251 - Chars: 6851 - Tokens: 1713
140. Winmerge-Src\Src\codepage_detect.h - Lines: 19 - Chars: 476 - Tokens: 119
141. Winmerge-Src\Src\ColorSchemes.cpp - Lines: 56 - Chars: 1389 - Tokens: 348
142. Winmerge-Src\Src\ColorSchemes.h - Lines: 13 - Chars: 248 - Tokens: 62
143. Winmerge-Src\Src\CompareOptions.cpp - Lines: 216 - Chars: 5565 - Tokens: 1392
144. Winmerge-Src\Src\CompareOptions.h - Lines: 148 - Chars: 5142 - Tokens: 1286
145. Winmerge-Src\Src\CompareStatisticsDlg.cpp - Lines: 129 - Chars: 4421 - Tokens: 1106
146. Winmerge-Src\Src\CompareStatisticsDlg.h - Lines: 41 - Chars: 985 - Tokens: 247
147. Winmerge-Src\Src\CompareStats.cpp - Lines: 184 - Chars: 4334 - Tokens: 1084
148. Winmerge-Src\Src\CompareStats.h - Lines: 166 - Chars: 4507 - Tokens: 1127
149. Winmerge-Src\Src\Concurrent.cpp - Lines: 11 - Chars: 266 - Tokens: 67
150. Winmerge-Src\Src\Concurrent.h - Lines: 107 - Chars: 2072 - Tokens: 518
151. Winmerge-Src\Src\ConfigLog.cpp - Lines: 585 - Chars: 16324 - Tokens: 4081
152. Winmerge-Src\Src\ConfigLog.h - Lines: 58 - Chars: 1282 - Tokens: 321
153. Winmerge-Src\Src\ConfirmFolderCopyDlg.cpp - Lines: 115 - Chars: 3299 - Tokens: 825
154. Winmerge-Src\Src\ConfirmFolderCopyDlg.h - Lines: 48 - Chars: 1059 - Tokens: 265
155. Winmerge-Src\Src\ConflictFileParser.cpp - Lines: 340 - Chars: 8101 - Tokens: 2026
156. Winmerge-Src\Src\ConflictFileParser.h - Lines: 24 - Chars: 704 - Tokens: 176
157. Winmerge-Src\Src\Constants.h - Lines: 84 - Chars: 3261 - Tokens: 816
158. Winmerge-Src\Src\COPYING - Lines: 343 - Chars: 18011 - Tokens: 4503
159. Winmerge-Src\Src\DDXHelper.h - Lines: 41 - Chars: 973 - Tokens: 244
160. Winmerge-Src\Src\Diff3.h - Lines: 224 - Chars: 4840 - Tokens: 1210
161. Winmerge-Src\Src\DiffContext.cpp - Lines: 331 - Chars: 10084 - Tokens: 2521
162. Winmerge-Src\Src\DiffContext.h - Lines: 233 - Chars: 7928 - Tokens: 1982
163. Winmerge-Src\Src\DiffFileData.cpp - Lines: 154 - Chars: 4445 - Tokens: 1112
164. Winmerge-Src\Src\DiffFileData.h - Lines: 50 - Chars: 1169 - Tokens: 293
165. Winmerge-Src\Src\DiffFileInfo.cpp - Lines: 22 - Chars: 365 - Tokens: 92
166. Winmerge-Src\Src\DiffFileInfo.h - Lines: 47 - Chars: 1151 - Tokens: 288
167. Winmerge-Src\Src\DiffItem.cpp - Lines: 252 - Chars: 5718 - Tokens: 1430
168. Winmerge-Src\Src\DiffItem.h - Lines: 306 - Chars: 13601 - Tokens: 3401
169. Winmerge-Src\Src\DiffItemList.cpp - Lines: 214 - Chars: 5502 - Tokens: 1376
170. Winmerge-Src\Src\DiffItemList.h - Lines: 66 - Chars: 1992 - Tokens: 498
171. Winmerge-Src\Src\DiffList.cpp - Lines: 892 - Chars: 23229 - Tokens: 5808
172. Winmerge-Src\Src\DiffList.h - Lines: 231 - Chars: 6979 - Tokens: 1745
173. Winmerge-Src\Src\DiffTextBuffer.cpp - Lines: 583 - Chars: 16544 - Tokens: 4136
174. Winmerge-Src\Src\DiffTextBuffer.h - Lines: 100 - Chars: 3451 - Tokens: 863
175. Winmerge-Src\Src\DiffThread.cpp - Lines: 152 - Chars: 4132 - Tokens: 1033
176. Winmerge-Src\Src\DiffThread.h - Lines: 167 - Chars: 4752 - Tokens: 1188
177. Winmerge-Src\Src\DiffViewBar.cpp - Lines: 122 - Chars: 2547 - Tokens: 637
178. Winmerge-Src\Src\DiffViewBar.h - Lines: 48 - Chars: 1019 - Tokens: 255
179. Winmerge-Src\Src\DiffWrapper.cpp - Lines: 1871 - Chars: 55074 - Tokens: 13769
180. Winmerge-Src\Src\DiffWrapper.h - Lines: 286 - Chars: 10591 - Tokens: 2648
181. Winmerge-Src\Src\DirActions.cpp - Lines: 1639 - Chars: 51416 - Tokens: 12854
182. Winmerge-Src\Src\DirActions.h - Lines: 863 - Chars: 27314 - Tokens: 6829
183. Winmerge-Src\Src\DirAdditionalPropertiesDlg.cpp - Lines: 229 - Chars: 6319 - Tokens: 1580
184. Winmerge-Src\Src\DirAdditionalPropertiesDlg.h - Lines: 82 - Chars: 2412 - Tokens: 603
185. Winmerge-Src\Src\DirCmpReport.cpp - Lines: 588 - Chars: 16766 - Tokens: 4192
186. Winmerge-Src\Src\DirCmpReport.h - Lines: 85 - Chars: 3096 - Tokens: 774
187. Winmerge-Src\Src\DirCmpReportDlg.cpp - Lines: 197 - Chars: 5440 - Tokens: 1360
188. Winmerge-Src\Src\DirCmpReportDlg.h - Lines: 54 - Chars: 1466 - Tokens: 367
189. Winmerge-Src\Src\DirColsDlg.cpp - Lines: 331 - Chars: 7837 - Tokens: 1960
190. Winmerge-Src\Src\DirColsDlg.h - Lines: 101 - Chars: 3036 - Tokens: 759
191. Winmerge-Src\Src\DirCompProgressBar.cpp - Lines: 223 - Chars: 6396 - Tokens: 1599
192. Winmerge-Src\Src\DirCompProgressBar.h - Lines: 84 - Chars: 2478 - Tokens: 620
193. Winmerge-Src\Src\DirDoc.cpp - Lines: 1066 - Chars: 30293 - Tokens: 7574
194. Winmerge-Src\Src\DirDoc.h - Lines: 191 - Chars: 6497 - Tokens: 1625
195. Winmerge-Src\Src\DirFilterDlg.cpp - Lines: 169 - Chars: 4031 - Tokens: 1008
196. Winmerge-Src\Src\DirFilterDlg.h - Lines: 44 - Chars: 1112 - Tokens: 278
197. Winmerge-Src\Src\DirFrame.cpp - Lines: 199 - Chars: 4880 - Tokens: 1220
198. Winmerge-Src\Src\DirFrame.h - Lines: 72 - Chars: 1751 - Tokens: 438
199. Winmerge-Src\Src\DirItem.cpp - Lines: 136 - Chars: 2803 - Tokens: 701
200. Winmerge-Src\Src\DirItem.h - Lines: 45 - Chars: 1450 - Tokens: 363
201. Winmerge-Src\Src\DirItemIterator.h - Lines: 204 - Chars: 4453 - Tokens: 1114
202. Winmerge-Src\Src\DirReportTypes.h - Lines: 13 - Chars: 294 - Tokens: 74
203. Winmerge-Src\Src\DirScan.cpp - Lines: 1063 - Chars: 34899 - Tokens: 8725
204. Winmerge-Src\Src\DirScan.h - Lines: 23 - Chars: 648 - Tokens: 162
205. Winmerge-Src\Src\DirSelectFilesDlg.cpp - Lines: 131 - Chars: 3365 - Tokens: 842
206. Winmerge-Src\Src\DirSelectFilesDlg.h - Lines: 31 - Chars: 587 - Tokens: 147
207. Winmerge-Src\Src\DirTravel.cpp - Lines: 164 - Chars: 4774 - Tokens: 1194
208. Winmerge-Src\Src\DirTravel.h - Lines: 18 - Chars: 397 - Tokens: 100
209. Winmerge-Src\Src\DirView.cpp - Lines: 4951 - Chars: 150811 - Tokens: 37703
210. Winmerge-Src\Src\DirView.h - Lines: 462 - Chars: 19099 - Tokens: 4775
211. Winmerge-Src\Src\DirViewColItems.cpp - Lines: 2120 - Chars: 71844 - Tokens: 17961
212. Winmerge-Src\Src\DirViewColItems.h - Lines: 135 - Chars: 4245 - Tokens: 1062
213. Winmerge-Src\Src\DirWatcher.cpp - Lines: 365 - Chars: 8382 - Tokens: 2096
214. Winmerge-Src\Src\DirWatcher.h - Lines: 25 - Chars: 526 - Tokens: 132
215. Winmerge-Src\Src\dllpstub.cpp - Lines: 140 - Chars: 4066 - Tokens: 1017
216. Winmerge-Src\Src\dllpstub.h - Lines: 43 - Chars: 1145 - Tokens: 287
217. Winmerge-Src\Src\DropHandler.cpp - Lines: 368 - Chars: 12541 - Tokens: 3136
218. Winmerge-Src\Src\DropHandler.h - Lines: 29 - Chars: 950 - Tokens: 238
219. Winmerge-Src\Src\EditorFilepathBar.cpp - Lines: 321 - Chars: 9215 - Tokens: 2304
220. Winmerge-Src\Src\EditorFilepathBar.h - Lines: 123 - Chars: 4300 - Tokens: 1075
221. Winmerge-Src\Src\EditPluginDlg.cpp - Lines: 587 - Chars: 21226 - Tokens: 5307
222. Winmerge-Src\Src\EditPluginDlg.h - Lines: 101 - Chars: 2950 - Tokens: 738
223. Winmerge-Src\Src\EncodingErrorBar.cpp - Lines: 63 - Chars: 1579 - Tokens: 395
224. Winmerge-Src\Src\EncodingErrorBar.h - Lines: 47 - Chars: 917 - Tokens: 230
225. Winmerge-Src\Src\Environment.cpp - Lines: 220 - Chars: 5476 - Tokens: 1369
226. Winmerge-Src\Src\Environment.h - Lines: 33 - Chars: 748 - Tokens: 187
227. Winmerge-Src\Src\Exceptions.h - Lines: 116 - Chars: 3326 - Tokens: 832
228. Winmerge-Src\Src\FileActionScript.cpp - Lines: 275 - Chars: 6679 - Tokens: 1670
229. Winmerge-Src\Src\FileActionScript.h - Lines: 181 - Chars: 5301 - Tokens: 1326
230. Winmerge-Src\Src\FileFilter.cpp - Lines: 379 - Chars: 11134 - Tokens: 2784
231. Winmerge-Src\Src\FileFilter.h - Lines: 108 - Chars: 5071 - Tokens: 1268
232. Winmerge-Src\Src\FileFilterHelper.cpp - Lines: 780 - Chars: 25305 - Tokens: 6327
233. Winmerge-Src\Src\FileFilterHelper.h - Lines: 173 - Chars: 5830 - Tokens: 1458
234. Winmerge-Src\Src\FileFilterHelperMenu.cpp - Lines: 277 - Chars: 13236 - Tokens: 3309
235. Winmerge-Src\Src\FileFilterHelperMenu.h - Lines: 18 - Chars: 442 - Tokens: 111
236. Winmerge-Src\Src\FileFilterMgr.cpp - Lines: 391 - Chars: 11187 - Tokens: 2797
237. Winmerge-Src\Src\FileFilterMgr.h - Lines: 140 - Chars: 3803 - Tokens: 951
238. Winmerge-Src\Src\FileFiltersDlg.cpp - Lines: 713 - Chars: 21171 - Tokens: 5293
239. Winmerge-Src\Src\FileFiltersDlg.h - Lines: 91 - Chars: 2547 - Tokens: 637
240. Winmerge-Src\Src\FileFlags.cpp - Lines: 34 - Chars: 757 - Tokens: 190
241. Winmerge-Src\Src\FileFlags.h - Lines: 22 - Chars: 396 - Tokens: 99
242. Winmerge-Src\Src\FileLoadResult.h - Lines: 113 - Chars: 3289 - Tokens: 823
243. Winmerge-Src\Src\FileLocation.h - Lines: 42 - Chars: 829 - Tokens: 208
244. Winmerge-Src\Src\FileOpenFlags.h - Lines: 20 - Chars: 635 - Tokens: 159
245. Winmerge-Src\Src\FileOrFolderSelect.cpp - Lines: 297 - Chars: 9530 - Tokens: 2383
246. Winmerge-Src\Src\FileOrFolderSelect.h - Lines: 25 - Chars: 925 - Tokens: 232
247. Winmerge-Src\Src\FilepathEdit.cpp - Lines: 583 - Chars: 15292 - Tokens: 3823
248. Winmerge-Src\Src\FilepathEdit.h - Lines: 87 - Chars: 2921 - Tokens: 731
249. Winmerge-Src\Src\FileTextEncoding.cpp - Lines: 123 - Chars: 2224 - Tokens: 556
250. Winmerge-Src\Src\FileTextEncoding.h - Lines: 29 - Chars: 797 - Tokens: 200
251. Winmerge-Src\Src\FileTextStats.h - Lines: 23 - Chars: 650 - Tokens: 163
252. Winmerge-Src\Src\FileTransform.cpp - Lines: 1083 - Chars: 32372 - Tokens: 8093
253. Winmerge-Src\Src\FileTransform.h - Lines: 217 - Chars: 7039 - Tokens: 1760
254. Winmerge-Src\Src\FileVersion.cpp - Lines: 54 - Chars: 1346 - Tokens: 337
255. Winmerge-Src\Src\FileVersion.h - Lines: 66 - Chars: 1625 - Tokens: 407
256. Winmerge-Src\Src\FilterConditionDlg.cpp - Lines: 259 - Chars: 7913 - Tokens: 1979
257. Winmerge-Src\Src\FilterConditionDlg.h - Lines: 61 - Chars: 1544 - Tokens: 386
258. Winmerge-Src\Src\FilterErrorMessages.cpp - Lines: 53 - Chars: 1662 - Tokens: 416
259. Winmerge-Src\Src\FilterErrorMessages.h - Lines: 9 - Chars: 225 - Tokens: 57
260. Winmerge-Src\Src\FilterList.cpp - Lines: 116 - Chars: 2840 - Tokens: 710
261. Winmerge-Src\Src\FilterList.h - Lines: 68 - Chars: 1902 - Tokens: 476
262. Winmerge-Src\Src\FiltersPropertySheet.cpp - Lines: 61 - Chars: 1538 - Tokens: 385
263. Winmerge-Src\Src\FiltersPropertySheet.h - Lines: 26 - Chars: 681 - Tokens: 171
264. Winmerge-Src\Src\FolderCmp.cpp - Lines: 494 - Chars: 18438 - Tokens: 4610
265. Winmerge-Src\Src\FolderCmp.h - Lines: 62 - Chars: 1545 - Tokens: 387
266. Winmerge-Src\Src\FrameWndHelper.cpp - Lines: 51 - Chars: 1315 - Tokens: 329
267. Winmerge-Src\Src\FrameWndHelper.h - Lines: 7 - Chars: 154 - Tokens: 39
268. Winmerge-Src\Src\GhostTextBuffer.cpp - Lines: 902 - Chars: 28984 - Tokens: 7246
269. Winmerge-Src\Src\GhostTextBuffer.h - Lines: 140 - Chars: 4927 - Tokens: 1232
270. Winmerge-Src\Src\GhostTextView.cpp - Lines: 296 - Chars: 8376 - Tokens: 2094
271. Winmerge-Src\Src\GhostTextView.h - Lines: 123 - Chars: 4279 - Tokens: 1070
272. Winmerge-Src\Src\HashCalc.cpp - Lines: 69 - Chars: 1851 - Tokens: 463
273. Winmerge-Src\Src\HashCalc.h - Lines: 12 - Chars: 222 - Tokens: 56
274. Winmerge-Src\Src\heksedit.h - Lines: 146 - Chars: 5505 - Tokens: 1377
275. Winmerge-Src\Src\HexMergeDoc.cpp - Lines: 1012 - Chars: 27000 - Tokens: 6750
276. Winmerge-Src\Src\HexMergeDoc.h - Lines: 163 - Chars: 5707 - Tokens: 1427
277. Winmerge-Src\Src\HexMergeFrm.cpp - Lines: 450 - Chars: 12562 - Tokens: 3141
278. Winmerge-Src\Src\HexMergeFrm.h - Lines: 89 - Chars: 2278 - Tokens: 570
279. Winmerge-Src\Src\HexMergeView.cpp - Lines: 614 - Chars: 14166 - Tokens: 3542
280. Winmerge-Src\Src\HexMergeView.h - Lines: 95 - Chars: 2839 - Tokens: 710
281. Winmerge-Src\Src\IAbortable.h - Lines: 9 - Chars: 141 - Tokens: 36
282. Winmerge-Src\Src\IDirDoc.h - Lines: 39 - Chars: 1548 - Tokens: 387
283. Winmerge-Src\Src\IListCtrl.h - Lines: 24 - Chars: 867 - Tokens: 217
284. Winmerge-Src\Src\IListCtrlImpl.h - Lines: 191 - Chars: 5624 - Tokens: 1406
285. Winmerge-Src\Src\IMergeDoc.h - Lines: 37 - Chars: 1020 - Tokens: 255
286. Winmerge-Src\Src\ImgMergeFrm.cpp - Lines: 2409 - Chars: 74705 - Tokens: 18677
287. Winmerge-Src\Src\ImgMergeFrm.h - Lines: 259 - Chars: 9760 - Tokens: 2440
288. Winmerge-Src\Src\InternalPlugins.cpp - Lines: 1006 - Chars: 33887 - Tokens: 8472
289. Winmerge-Src\Src\InternalPlugins.h - Lines: 84 - Chars: 2554 - Tokens: 639
290. Winmerge-Src\Src\IntToIntMap.h - Lines: 39 - Chars: 594 - Tokens: 149
291. Winmerge-Src\Src\IOptionsPanel.h - Lines: 22 - Chars: 434 - Tokens: 109
292. Winmerge-Src\Src\JumpList.cpp - Lines: 268 - Chars: 7820 - Tokens: 1955
293. Winmerge-Src\Src\JumpList.h - Lines: 30 - Chars: 936 - Tokens: 234
294. Winmerge-Src\Src\LineFiltersDlg.cpp - Lines: 280 - Chars: 6937 - Tokens: 1735
295. Winmerge-Src\Src\LineFiltersDlg.h - Lines: 70 - Chars: 1806 - Tokens: 452
296. Winmerge-Src\Src\LineFiltersList.cpp - Lines: 203 - Chars: 5160 - Tokens: 1290
297. Winmerge-Src\Src\LineFiltersList.h - Lines: 69 - Chars: 1380 - Tokens: 345
298. Winmerge-Src\Src\LoadSaveCodepageDlg.cpp - Lines: 238 - Chars: 6854 - Tokens: 1714
299. Winmerge-Src\Src\LoadSaveCodepageDlg.h - Lines: 89 - Chars: 2842 - Tokens: 711
300. Winmerge-Src\Src\locality.cpp - Lines: 144 - Chars: 4315 - Tokens: 1079
301. Winmerge-Src\Src\locality.h - Lines: 18 - Chars: 328 - Tokens: 82
302. Winmerge-Src\Src\LocationBar.cpp - Lines: 126 - Chars: 2553 - Tokens: 639
303. Winmerge-Src\Src\LocationBar.h - Lines: 55 - Chars: 1245 - Tokens: 312
304. Winmerge-Src\Src\LocationView.cpp - Lines: 1114 - Chars: 33723 - Tokens: 8431
305. Winmerge-Src\Src\LocationView.h - Lines: 143 - Chars: 4930 - Tokens: 1233
306. Winmerge-Src\Src\Logger.cpp - Lines: 42 - Chars: 1168 - Tokens: 292
307. Winmerge-Src\Src\Logger.h - Lines: 48 - Chars: 1751 - Tokens: 438
308. Winmerge-Src\Src\MainFrm.cpp - Lines: 3974 - Chars: 133806 - Tokens: 33452
309. Winmerge-Src\Src\MainFrm.h - Lines: 490 - Chars: 18260 - Tokens: 4565
310. Winmerge-Src\Src\markdown.cpp - Lines: 901 - Chars: 20334 - Tokens: 5084
311. Winmerge-Src\Src\markdown.h - Lines: 80 - Chars: 2506 - Tokens: 627
312. Winmerge-Src\Src\MenuBar.cpp - Lines: 475 - Chars: 12966 - Tokens: 3242
313. Winmerge-Src\Src\MenuBar.h - Lines: 67 - Chars: 1887 - Tokens: 472
314. Winmerge-Src\Src\Merge.cpp - Lines: 1847 - Chars: 57215 - Tokens: 14304
315. Winmerge-Src\Src\Merge.h - Lines: 213 - Chars: 7548 - Tokens: 1887
316. Winmerge-Src\Src\Merge2.rc - Lines: 258 - Chars: 11868 - Tokens: 2967
317. Winmerge-Src\Src\Merge7zFormatMergePluginImpl.cpp - Lines: 153 - Chars: 5226 - Tokens: 1307
318. Winmerge-Src\Src\Merge7zFormatMergePluginImpl.h - Lines: 58 - Chars: 1871 - Tokens: 468
319. Winmerge-Src\Src\Merge7zFormatRegister.h - Lines: 32 - Chars: 777 - Tokens: 195
320. Winmerge-Src\Src\Merge7zFormatShellImpl.cpp - Lines: 122 - Chars: 4034 - Tokens: 1009
321. Winmerge-Src\Src\Merge7zFormatShellImpl.h - Lines: 35 - Chars: 1124 - Tokens: 281
322. Winmerge-Src\Src\MergeApp.cpp - Lines: 206 - Chars: 4351 - Tokens: 1088
323. Winmerge-Src\Src\MergeApp.h - Lines: 51 - Chars: 1125 - Tokens: 282
324. Winmerge-Src\Src\MergeAppCOMClass.cpp - Lines: 215 - Chars: 5498 - Tokens: 1375
325. Winmerge-Src\Src\MergeAppCOMClass.h - Lines: 117 - Chars: 3099 - Tokens: 775
326. Winmerge-Src\Src\MergeAppLib.h - Lines: 334 - Chars: 11298 - Tokens: 2825
327. Winmerge-Src\Src\MergeAppLib.idl - Lines: 35 - Chars: 1264 - Tokens: 316
328. Winmerge-Src\Src\MergeCmdLineInfo.cpp - Lines: 611 - Chars: 15345 - Tokens: 3837
329. Winmerge-Src\Src\MergeCmdLineInfo.h - Lines: 147 - Chars: 4562 - Tokens: 1141
330. Winmerge-Src\Src\MergeDarkMode.cpp - Lines: 287 - Chars: 6578 - Tokens: 1645
331. Winmerge-Src\Src\MergeDarkMode.h - Lines: 110 - Chars: 3847 - Tokens: 962
332. Winmerge-Src\Src\MergeDoc.cpp - Lines: 3599 - Chars: 109474 - Tokens: 27369
333. Winmerge-Src\Src\MergeDoc.h - Lines: 487 - Chars: 18626 - Tokens: 4657
334. Winmerge-Src\Src\MergeDocDiffCopy.cpp - Lines: 1070 - Chars: 33615 - Tokens: 8404
335. Winmerge-Src\Src\MergeDocDiffSync.cpp - Lines: 872 - Chars: 27980 - Tokens: 6995
336. Winmerge-Src\Src\MergeDocEncoding.cpp - Lines: 131 - Chars: 3314 - Tokens: 829
337. Winmerge-Src\Src\MergeDocLineDiffs.cpp - Lines: 501 - Chars: 14200 - Tokens: 3550
338. Winmerge-Src\Src\MergeEditFrm.cpp - Lines: 473 - Chars: 13662 - Tokens: 3416
339. Winmerge-Src\Src\MergeEditFrm.h - Lines: 95 - Chars: 2756 - Tokens: 689
340. Winmerge-Src\Src\MergeEditSplitterView.cpp - Lines: 135 - Chars: 3910 - Tokens: 978
341. Winmerge-Src\Src\MergeEditSplitterView.h - Lines: 59 - Chars: 1514 - Tokens: 379
342. Winmerge-Src\Src\MergeEditStatus.h - Lines: 18 - Chars: 432 - Tokens: 108
343. Winmerge-Src\Src\MergeEditView.cpp - Lines: 4597 - Chars: 128149 - Tokens: 32038
344. Winmerge-Src\Src\MergeEditView.h - Lines: 366 - Chars: 14416 - Tokens: 3604
345. Winmerge-Src\Src\MergeFrameCommon.cpp - Lines: 542 - Chars: 16990 - Tokens: 4248
346. Winmerge-Src\Src\MergeFrameCommon.h - Lines: 71 - Chars: 2966 - Tokens: 742
347. Winmerge-Src\Src\MergeLang.vcxproj - Lines: 342 - Chars: 20106 - Tokens: 5027
348. Winmerge-Src\Src\MergeLang.vcxproj.filters - Lines: 290 - Chars: 11571 - Tokens: 2893
349. Winmerge-Src\Src\MergeLineFlags.h - Lines: 31 - Chars: 853 - Tokens: 214
350. Winmerge-Src\Src\MergeStatusBar.cpp - Lines: 357 - Chars: 10673 - Tokens: 2669
351. Winmerge-Src\Src\MergeStatusBar.h - Lines: 74 - Chars: 2031 - Tokens: 508
352. Winmerge-Src\Src\MouseHook.cpp - Lines: 195 - Chars: 4401 - Tokens: 1101
353. Winmerge-Src\Src\MouseHook.h - Lines: 20 - Chars: 838 - Tokens: 210
354. Winmerge-Src\Src\MovedBlocks.cpp - Lines: 359 - Chars: 9461 - Tokens: 2366
355. Winmerge-Src\Src\MovedLines.cpp - Lines: 74 - Chars: 1529 - Tokens: 383
356. Winmerge-Src\Src\MovedLines.h - Lines: 38 - Chars: 797 - Tokens: 200
357. Winmerge-Src\Src\MyColorDialog.cpp - Lines: 18 - Chars: 453 - Tokens: 114
358. Winmerge-Src\Src\MyColorDialog.h - Lines: 10 - Chars: 193 - Tokens: 49
359. Winmerge-Src\Src\MyFontDialog.cpp - Lines: 34 - Chars: 1009 - Tokens: 253
360. Winmerge-Src\Src\MyFontDialog.h - Lines: 16 - Chars: 481 - Tokens: 121
361. Winmerge-Src\Src\MyReBar.cpp - Lines: 80 - Chars: 2079 - Tokens: 520
362. Winmerge-Src\Src\MyReBar.h - Lines: 16 - Chars: 265 - Tokens: 67
363. Winmerge-Src\Src\OpenDoc.cpp - Lines: 59 - Chars: 1301 - Tokens: 326
364. Winmerge-Src\Src\OpenDoc.h - Lines: 40 - Chars: 714 - Tokens: 179
365. Winmerge-Src\Src\OpenFrm.cpp - Lines: 128 - Chars: 2698 - Tokens: 675
366. Winmerge-Src\Src\OpenFrm.h - Lines: 43 - Chars: 830 - Tokens: 208
367. Winmerge-Src\Src\OpenTableDlg.cpp - Lines: 79 - Chars: 2204 - Tokens: 551
368. Winmerge-Src\Src\OpenTableDlg.h - Lines: 48 - Chars: 1067 - Tokens: 267
369. Winmerge-Src\Src\OpenView.h - Lines: 189 - Chars: 6739 - Tokens: 1685
370. Winmerge-Src\Src\OptionsCustomColors.cpp - Lines: 38 - Chars: 874 - Tokens: 219
371. Winmerge-Src\Src\OptionsCustomColors.h - Lines: 14 - Chars: 261 - Tokens: 66
372. Winmerge-Src\Src\OptionsDef.h - Lines: 346 - Chars: 20491 - Tokens: 5123
373. Winmerge-Src\Src\OptionsDiffColors.cpp - Lines: 108 - Chars: 6572 - Tokens: 1643
374. Winmerge-Src\Src\OptionsDiffColors.h - Lines: 48 - Chars: 1967 - Tokens: 492
375. Winmerge-Src\Src\OptionsDiffOptions.cpp - Lines: 61 - Chars: 2742 - Tokens: 686
376. Winmerge-Src\Src\OptionsDiffOptions.h - Lines: 13 - Chars: 282 - Tokens: 71
377. Winmerge-Src\Src\OptionsDirColors.cpp - Lines: 57 - Chars: 2731 - Tokens: 683
378. Winmerge-Src\Src\OptionsDirColors.h - Lines: 30 - Chars: 934 - Tokens: 234
379. Winmerge-Src\Src\OptionsEditorSyntax.cpp - Lines: 108 - Chars: 3348 - Tokens: 837
380. Winmerge-Src\Src\OptionsEditorSyntax.h - Lines: 15 - Chars: 339 - Tokens: 85
381. Winmerge-Src\Src\OptionsFont.cpp - Lines: 190 - Chars: 8691 - Tokens: 2173
382. Winmerge-Src\Src\OptionsFont.h - Lines: 18 - Chars: 518 - Tokens: 130
383. Winmerge-Src\Src\OptionsInit.cpp - Lines: 374 - Chars: 14950 - Tokens: 3738
384. Winmerge-Src\Src\OptionsInit.h - Lines: 11 - Chars: 125 - Tokens: 32
385. Winmerge-Src\Src\OptionsPanel.cpp - Lines: 19 - Chars: 325 - Tokens: 82
386. Winmerge-Src\Src\OptionsPanel.h - Lines: 28 - Chars: 525 - Tokens: 132
387. Winmerge-Src\Src\OptionsProject.cpp - Lines: 103 - Chars: 3041 - Tokens: 761
388. Winmerge-Src\Src\OptionsProject.h - Lines: 35 - Chars: 831 - Tokens: 208
389. Winmerge-Src\Src\OptionsSyntaxColors.cpp - Lines: 101 - Chars: 3046 - Tokens: 762
390. Winmerge-Src\Src\OptionsSyntaxColors.h - Lines: 18 - Chars: 416 - Tokens: 104
391. Winmerge-Src\Src\OutputBar.cpp - Lines: 126 - Chars: 2520 - Tokens: 630
392. Winmerge-Src\Src\OutputBar.h - Lines: 55 - Chars: 1229 - Tokens: 308
393. Winmerge-Src\Src\OutputDoc.cpp - Lines: 125 - Chars: 3013 - Tokens: 754
394. Winmerge-Src\Src\OutputDoc.h - Lines: 58 - Chars: 1296 - Tokens: 324
395. Winmerge-Src\Src\OutputView.cpp - Lines: 131 - Chars: 3063 - Tokens: 766
396. Winmerge-Src\Src\OutputView.h - Lines: 70 - Chars: 1589 - Tokens: 398
397. Winmerge-Src\Src\PatchDlg.cpp - Lines: 467 - Chars: 12055 - Tokens: 3014
398. Winmerge-Src\Src\PatchDlg.h - Lines: 127 - Chars: 3054 - Tokens: 764
399. Winmerge-Src\Src\PatchHTML.cpp - Lines: 465 - Chars: 12225 - Tokens: 3057
400. Winmerge-Src\Src\PatchHTML.h - Lines: 11 - Chars: 244 - Tokens: 61
401. Winmerge-Src\Src\PatchTool.cpp - Lines: 413 - Chars: 11746 - Tokens: 2937
402. Winmerge-Src\Src\PatchTool.h - Lines: 71 - Chars: 2082 - Tokens: 521
403. Winmerge-Src\Src\PathContext.cpp - Lines: 204 - Chars: 4105 - Tokens: 1027
404. Winmerge-Src\Src\PathContext.h - Lines: 169 - Chars: 3706 - Tokens: 927
405. Winmerge-Src\Src\paths.cpp - Lines: 830 - Chars: 22203 - Tokens: 5551
406. Winmerge-Src\Src\paths.h - Lines: 63 - Chars: 2137 - Tokens: 535
407. Winmerge-Src\Src\pch.cpp - Lines: 1 - Chars: 16 - Tokens: 4
408. Winmerge-Src\Src\pch.h - Lines: 23 - Chars: 416 - Tokens: 104
409. Winmerge-Src\Src\PluginManager.cpp - Lines: 59 - Chars: 1815 - Tokens: 454
410. Winmerge-Src\Src\PluginManager.h - Lines: 45 - Chars: 1161 - Tokens: 291
411. Winmerge-Src\Src\Plugins.h - Lines: 279 - Chars: 9527 - Tokens: 2382
412. Winmerge-Src\Src\PluginsListDlg.cpp - Lines: 472 - Chars: 12734 - Tokens: 3184
413. Winmerge-Src\Src\PluginsListDlg.h - Lines: 69 - Chars: 2034 - Tokens: 509
414. Winmerge-Src\Src\ProjectFile.cpp - Lines: 455 - Chars: 15871 - Tokens: 3968
415. Winmerge-Src\Src\ProjectFile.h - Lines: 929 - Chars: 26520 - Tokens: 6630
416. Winmerge-Src\Src\PropArchive.cpp - Lines: 86 - Chars: 1911 - Tokens: 478
417. Winmerge-Src\Src\PropArchive.h - Lines: 40 - Chars: 721 - Tokens: 181
418. Winmerge-Src\Src\PropBackups.cpp - Lines: 107 - Chars: 3235 - Tokens: 809
419. Winmerge-Src\Src\PropBackups.h - Lines: 50 - Chars: 927 - Tokens: 232
420. Winmerge-Src\Src\PropCodepage.cpp - Lines: 246 - Chars: 7959 - Tokens: 1990
421. Winmerge-Src\Src\PropCodepage.h - Lines: 63 - Chars: 1459 - Tokens: 365
422. Winmerge-Src\Src\PropColorSchemes.cpp - Lines: 216 - Chars: 6922 - Tokens: 1731
423. Winmerge-Src\Src\PropColorSchemes.h - Lines: 59 - Chars: 1362 - Tokens: 341
424. Winmerge-Src\Src\PropCompare.cpp - Lines: 156 - Chars: 6198 - Tokens: 1550
425. Winmerge-Src\Src\PropCompare.h - Lines: 68 - Chars: 1562 - Tokens: 391
426. Winmerge-Src\Src\PropCompareBinary.cpp - Lines: 164 - Chars: 4034 - Tokens: 1009
427. Winmerge-Src\Src\PropCompareBinary.h - Lines: 54 - Chars: 1189 - Tokens: 298
428. Winmerge-Src\Src\PropCompareFolder.cpp - Lines: 178 - Chars: 7183 - Tokens: 1796
429. Winmerge-Src\Src\PropCompareFolder.h - Lines: 71 - Chars: 1702 - Tokens: 426
430. Winmerge-Src\Src\PropCompareImage.cpp - Lines: 118 - Chars: 3394 - Tokens: 849
431. Winmerge-Src\Src\PropCompareImage.h - Lines: 54 - Chars: 1179 - Tokens: 295
432. Winmerge-Src\Src\PropCompareTable.cpp - Lines: 161 - Chars: 5633 - Tokens: 1409
433. Winmerge-Src\Src\PropCompareTable.h - Lines: 63 - Chars: 1483 - Tokens: 371
434. Winmerge-Src\Src\PropCompareWebPage.cpp - Lines: 96 - Chars: 3133 - Tokens: 784
435. Winmerge-Src\Src\PropCompareWebPage.h - Lines: 52 - Chars: 1143 - Tokens: 286
436. Winmerge-Src\Src\PropDirColors.cpp - Lines: 198 - Chars: 5366 - Tokens: 1342
437. Winmerge-Src\Src\PropDirColors.h - Lines: 77 - Chars: 2042 - Tokens: 511
438. Winmerge-Src\Src\PropEditor.cpp - Lines: 142 - Chars: 4082 - Tokens: 1021
439. Winmerge-Src\Src\PropEditor.h - Lines: 64 - Chars: 1358 - Tokens: 340
440. Winmerge-Src\Src\PropEditorCompareMerge.cpp - Lines: 146 - Chars: 4638 - Tokens: 1160
441. Winmerge-Src\Src\PropEditorCompareMerge.h - Lines: 66 - Chars: 1530 - Tokens: 383
442. Winmerge-Src\Src\PropEditorSyntax.cpp - Lines: 131 - Chars: 3347 - Tokens: 837
443. Winmerge-Src\Src\PropEditorSyntax.h - Lines: 59 - Chars: 1199 - Tokens: 300
444. Winmerge-Src\Src\PropertySystem.cpp - Lines: 385 - Chars: 9422 - Tokens: 2356
445. Winmerge-Src\Src\PropertySystem.h - Lines: 60 - Chars: 1730 - Tokens: 433
446. Winmerge-Src\Src\PropGeneral.cpp - Lines: 195 - Chars: 7516 - Tokens: 1879
447. Winmerge-Src\Src\PropGeneral.h - Lines: 67 - Chars: 1498 - Tokens: 375
448. Winmerge-Src\Src\PropMarkerColors.cpp - Lines: 134 - Chars: 3934 - Tokens: 984
449. Winmerge-Src\Src\PropMarkerColors.h - Lines: 62 - Chars: 1434 - Tokens: 359
450. Winmerge-Src\Src\PropMergeColors.cpp - Lines: 406 - Chars: 12659 - Tokens: 3165
451. Winmerge-Src\Src\PropMergeColors.h - Lines: 117 - Chars: 3441 - Tokens: 861
452. Winmerge-Src\Src\PropMessageBoxes.cpp - Lines: 236 - Chars: 8346 - Tokens: 2087
453. Winmerge-Src\Src\PropMessageBoxes.h - Lines: 57 - Chars: 1186 - Tokens: 297
454. Winmerge-Src\Src\PropProject.cpp - Lines: 148 - Chars: 3700 - Tokens: 925
455. Winmerge-Src\Src\PropProject.h - Lines: 57 - Chars: 1104 - Tokens: 276
456. Winmerge-Src\Src\PropRegistry.cpp - Lines: 154 - Chars: 4574 - Tokens: 1144
457. Winmerge-Src\Src\PropRegistry.h - Lines: 62 - Chars: 1519 - Tokens: 380
458. Winmerge-Src\Src\PropShell.cpp - Lines: 461 - Chars: 13736 - Tokens: 3434
459. Winmerge-Src\Src\PropShell.h - Lines: 58 - Chars: 1323 - Tokens: 331
460. Winmerge-Src\Src\PropSyntaxColors.cpp - Lines: 144 - Chars: 5851 - Tokens: 1463
461. Winmerge-Src\Src\PropSyntaxColors.h - Lines: 51 - Chars: 1244 - Tokens: 311
462. Winmerge-Src\Src\PropSysColors.cpp - Lines: 191 - Chars: 5913 - Tokens: 1479
463. Winmerge-Src\Src\PropSysColors.h - Lines: 63 - Chars: 1462 - Tokens: 366
464. Winmerge-Src\Src\PropTextColors.cpp - Lines: 223 - Chars: 6799 - Tokens: 1700
465. Winmerge-Src\Src\PropTextColors.h - Lines: 75 - Chars: 1941 - Tokens: 486
466. Winmerge-Src\Src\SaveClosingDlg.cpp - Lines: 138 - Chars: 3750 - Tokens: 938
467. Winmerge-Src\Src\SaveClosingDlg.h - Lines: 69 - Chars: 2087 - Tokens: 522
468. Winmerge-Src\Src\SelectPluginDlg.cpp - Lines: 452 - Chars: 13903 - Tokens: 3476
469. Winmerge-Src\Src\SelectPluginDlg.h - Lines: 96 - Chars: 2717 - Tokens: 680
470. Winmerge-Src\Src\SharedFilterDlg.cpp - Lines: 40 - Chars: 833 - Tokens: 209
471. Winmerge-Src\Src\SharedFilterDlg.h - Lines: 53 - Chars: 1254 - Tokens: 314
472. Winmerge-Src\Src\StdAfx.cpp - Lines: 36 - Chars: 1077 - Tokens: 270
473. Winmerge-Src\Src\StdAfx.h - Lines: 154 - Chars: 4021 - Tokens: 1006
474. Winmerge-Src\Src\stringdiffs.cpp - Lines: 1080 - Chars: 27443 - Tokens: 6861
475. Winmerge-Src\Src\stringdiffs.h - Lines: 46 - Chars: 1198 - Tokens: 300
476. Winmerge-Src\Src\stringdiffsi.h - Lines: 126 - Chars: 2783 - Tokens: 696
477. Winmerge-Src\Src\SubeditList.cpp - Lines: 742 - Chars: 19805 - Tokens: 4952
478. Winmerge-Src\Src\SubeditList.h - Lines: 166 - Chars: 4765 - Tokens: 1192
479. Winmerge-Src\Src\SubstitutionFiltersDlg.cpp - Lines: 256 - Chars: 7561 - Tokens: 1891
480. Winmerge-Src\Src\SubstitutionFiltersDlg.h - Lines: 61 - Chars: 1358 - Tokens: 340
481. Winmerge-Src\Src\SubstitutionFiltersList.cpp - Lines: 288 - Chars: 10028 - Tokens: 2507
482. Winmerge-Src\Src\SubstitutionFiltersList.h - Lines: 73 - Chars: 1662 - Tokens: 416
483. Winmerge-Src\Src\SubstitutionList.cpp - Lines: 169 - Chars: 3502 - Tokens: 876
484. Winmerge-Src\Src\SubstitutionList.h - Lines: 43 - Chars: 1173 - Tokens: 294
485. Winmerge-Src\Src\TempFile.cpp - Lines: 198 - Chars: 3922 - Tokens: 981
486. Winmerge-Src\Src\TempFile.h - Lines: 59 - Chars: 1352 - Tokens: 338
487. Winmerge-Src\Src\Test.cpp - Lines: 830 - Chars: 31031 - Tokens: 7758
488. Winmerge-Src\Src\TestFilterDlg.cpp - Lines: 112 - Chars: 2590 - Tokens: 648
489. Winmerge-Src\Src\TestFilterDlg.h - Lines: 54 - Chars: 1189 - Tokens: 298
490. Winmerge-Src\Src\TestMain.cpp - Lines: 23 - Chars: 471 - Tokens: 118
491. Winmerge-Src\Src\TestMain.h - Lines: 3 - Chars: 58 - Tokens: 15
492. Winmerge-Src\Src\TFile.h - Lines: 17 - Chars: 473 - Tokens: 119
493. Winmerge-Src\Src\TitleBarHelper.cpp - Lines: 425 - Chars: 13425 - Tokens: 3357
494. Winmerge-Src\Src\TitleBarHelper.h - Lines: 60 - Chars: 1782 - Tokens: 446
495. Winmerge-Src\Src\TrDialogs.cpp - Lines: 94 - Chars: 2169 - Tokens: 543
496. Winmerge-Src\Src\TrDialogs.h - Lines: 128 - Chars: 2909 - Tokens: 728
497. Winmerge-Src\Src\WebPageDiffFrm.cpp - Lines: 1734 - Chars: 52886 - Tokens: 13222
498. Winmerge-Src\Src\WebPageDiffFrm.h - Lines: 205 - Chars: 6977 - Tokens: 1745
499. Winmerge-Src\Src\WildcardDropList.cpp - Lines: 276 - Chars: 9161 - Tokens: 2291
500. Winmerge-Src\Src\WildcardDropList.h - Lines: 16 - Chars: 563 - Tokens: 141
501. Winmerge-Src\Src\Win_VersionHelper.h - Lines: 55 - Chars: 1334 - Tokens: 334
502. Winmerge-Src\Src\WindowsManagerDialog.cpp - Lines: 294 - Chars: 7497 - Tokens: 1875
503. Winmerge-Src\Src\WindowsManagerDialog.h - Lines: 86 - Chars: 2406 - Tokens: 602
504. Winmerge-Src\Src\WinIMergeLib.h - Lines: 210 - Chars: 9384 - Tokens: 2346
505. Winmerge-Src\Src\WinMergePluginBase.h - Lines: 640 - Chars: 26099 - Tokens: 6525
506. Winmerge-Src\Src\WinWebDiffLib.h - Lines: 220 - Chars: 9235 - Tokens: 2309
507. Winmerge-Src\Src\WMGotoDlg.cpp - Lines: 192 - Chars: 4698 - Tokens: 1175
508. Winmerge-Src\Src\WMGotoDlg.h - Lines: 34 - Chars: 744 - Tokens: 186
509. Winmerge-Src\Src\xdiff_gnudiff_compat.cpp - Lines: 199 - Chars: 5476 - Tokens: 1369
510. Winmerge-Src\Src\xdiff_gnudiff_compat.h - Lines: 8 - Chars: 370 - Tokens: 93

<file path="Winmerge-Src/Src/CompareEngines/BinaryCompare.cpp">
/**
 * @file  BinaryCompare.cpp
 *
 * @brief Implementation file for BinaryCompare
 */

#include "pch.h"
#include "BinaryCompare.h"
#include "DiffItem.h"
#include "PathContext.h"
#include "IAbortable.h"
#include "cio.h"

namespace CompareEngines
{

BinaryCompare::BinaryCompare() : m_piAbortable(nullptr)
{
}

BinaryCompare::~BinaryCompare() = default;

/**
 * @brief Set Abortable-interface.
 * @param [in] piAbortable Pointer to abortable interface.
 */
void BinaryCompare::SetAbortable(const IAbortable * piAbortable)
{
	m_piAbortable = const_cast<IAbortable*>(piAbortable);
}

static int compare_files(const String& file1, const String& file2, IAbortable *piAbortable)
{
	const size_t bufsize = 1024 * 256;
	int code;
	int fd1 = -1, fd2 = -1;
	
	cio::tsopen_s(&fd1, file1, O_BINARY | O_RDONLY, _SH_DENYNO, _S_IREAD);
	cio::tsopen_s(&fd2, file2, O_BINARY | O_RDONLY, _SH_DENYNO, _S_IREAD);
	if (fd1 != -1 && fd2 != -1)
	{
		for (;;)
		{
			if (piAbortable && piAbortable->ShouldAbort())
			{
				code = DIFFCODE::CMPABORT;
				break;
			}
			char buf1[bufsize];
			char buf2[bufsize];
			int size1 = cio::read_i(fd1, buf1, sizeof(buf1));
			int size2 = cio::read_i(fd2, buf2, sizeof(buf2));
			if (size1 <= 0 || size2 <= 0)
			{
				if (size1 < 0 || size2 < 0)
					code = DIFFCODE::CMPERR;
				else if (size1 == size2)
					code = DIFFCODE::SAME;
				else
					code = DIFFCODE::DIFF;
				break;
			}
			if (size1 != size2 || memcmp(buf1, buf2, size1) != 0)
			{
				code = DIFFCODE::DIFF;
				break;
			}
		}
	}
	else
	{
		code = DIFFCODE::CMPERR;
	}
	if (fd1 != -1)
		cio::close(fd1);
	if (fd2 != -1)
		cio::close(fd2);

	return code;
}

/**
 * @brief Compare two specified files, byte-by-byte
 * @param [in] di Diffitem info.
 * @return DIFFCODE
 */
int BinaryCompare::CompareFiles(const PathContext& files, const DIFFITEM &di) const
{
	auto cmp = [&](int p1, int p2) -> unsigned
	{
		if (di.diffFileInfo[p1].size == DirItem::FILE_SIZE_NONE &&
			di.diffFileInfo[p2].size == DirItem::FILE_SIZE_NONE)
			return DIFFCODE::SAME;
		// If the file size is 0, don't immediately assume that there is a difference even if the files have different sizes, because of possible symlinks.
		if (di.diffFileInfo[p1].size == DirItem::FILE_SIZE_NONE ||
			di.diffFileInfo[p2].size == DirItem::FILE_SIZE_NONE ||
			(di.diffFileInfo[p1].size != di.diffFileInfo[p2].size &&
			 di.diffFileInfo[p1].size != 0 && di.diffFileInfo[p2].size != 0))
			return DIFFCODE::DIFF;
		return compare_files(files[p1], files[p2], m_piAbortable);
	};
	switch (files.GetSize())
	{
	case 2:
		return cmp(0, 1);
	case 3:
		unsigned code10 = cmp(1, 0);
		unsigned code12 = cmp(1, 2);
		unsigned code02 = DIFFCODE::SAME;
		if (code10 == DIFFCODE::SAME && code12 == DIFFCODE::SAME)
			return DIFFCODE::SAME;
		else if (code10 == DIFFCODE::SAME && code12 == DIFFCODE::DIFF)
			return DIFFCODE::DIFF | DIFFCODE::DIFF3RDONLY;
		else if (code10 == DIFFCODE::DIFF && code12 == DIFFCODE::SAME)
			return DIFFCODE::DIFF | DIFFCODE::DIFF1STONLY;
		else if (code10 == DIFFCODE::DIFF && code12 == DIFFCODE::DIFF)
		{
			code02 = cmp(0, 2);
			if (code02 == DIFFCODE::SAME)
				return DIFFCODE::DIFF | DIFFCODE::DIFF2NDONLY;
		}
		if (code10 == DIFFCODE::CMPERR || code12 == DIFFCODE::CMPERR || code02 == DIFFCODE::CMPERR)
			return DIFFCODE::CMPERR;
		return DIFFCODE::DIFF;
	}
	return DIFFCODE::CMPERR;
}

} // namespace CompareEngines
</file>

<file path="Winmerge-Src/Src/CompareEngines/BinaryCompare.h">
/**
 * @file  BinaryCompare.h
 *
 * @brief Declaration file for BinaryCompare compare engine.
 */
#pragma once

class DIFFITEM;
class PathContext;
class IAbortable;

namespace CompareEngines
{

/**
 * @brief A binary compare class.
 * This compare method compares files by their binary contents.
 */
class BinaryCompare
{
public:
	BinaryCompare();
	~BinaryCompare();
	void SetAbortable(const IAbortable * piAbortable);
	int CompareFiles(const PathContext& files, const DIFFITEM &di) const;
private:
	IAbortable * m_piAbortable;
};

} // namespace CompareEngines
</file>

<file path="Winmerge-Src/Src/CompareEngines/ByteComparator.cpp">
/**
 * @file  ByteComparator.cpp
 *
 * @brief Implements ByteComparator class.
 */

#include "pch.h"
#include "ByteComparator.h"
#include <cassert>
#include "UnicodeString.h"
#include "FileTextStats.h"
#include "CompareOptions.h"

/**
 * @brief Returns if given char is EOL byte.
 * @param [in] ch Char to test.
 * @return true if char is EOL byte, false otherwise.
 */
static inline bool iseolch(tchar_t ch)
{
	return ch == '\n' || ch == '\r';
}

/**
 * @brief Returns if given char is whitespace char.
 * @param [in] ch Char to test.
 * @return true if char is whitespace char, false otherwise.
 * @todo What about nbsp or various Unicode spacing codes?
 */
static inline bool iswsch(tchar_t ch)
{
	return ch == ' ' || ch == '\t';
}

/**
 * @brief Calculates statistics from given buffer.
 * This function calculates EOL byte and zero-byte statistics from given
 * buffer.
 * @param [in,out] stats Structure holding statistics.
 * @param [in] ptr Pointer to begin of the buffer.
 * @param [in] end Pointer to end of buffer.
 * @param [in] eof Is buffer end also end of file?
 * @param [in] crflag Did previous scan end to CR?
 * @param [in] offset Byte offset in whole file (among several buffers).
 */
static void TextScan(FileTextStats & stats, const char *ptr, const char *end, bool eof,
		bool crflag, int64_t offset)
{
	// Handle any crs left from last buffer
	if (crflag)
	{
		if (ptr < end && *ptr == '\n')
		{
			++stats.ncrlfs;
			++ptr;
		}
		else
		{
			++stats.ncrs;
		}
	}
	for (; ptr < end; ++ptr)
	{
		char ch = *ptr;
		if (ch == 0)
		{
			++stats.nzeros;
		}
		else if (ch == '\r')
		{
			if (ptr + 1 < end)
			{
				if (ptr[1] == '\n')
				{
					++stats.ncrlfs;
					++ptr;
				}
				else
				{
					++stats.ncrs;
				}
			}
			else if (eof)
			{
				++stats.ncrs;
			}
			else
			{
				// else last byte of buffer
				// leave alone, the CompareBuffers loop will set the appropriate m_cr flag
				// and we'll handle it next time we're called
			}
		}
		else if (ch == '\n')
		{
			++stats.nlfs;
		}
	}
}

namespace CompareEngines
{

/**
 * @brief Constructor taking compare options as parameters.
 * @param [in] options Compare options.
 */
ByteComparator::ByteComparator(const QuickCompareOptions * options)
// settings
		: m_ignore_case(options->m_bIgnoreCase)
		, m_ignore_eol_diff(options->m_bIgnoreEOLDifference)
		, m_ignore_blank_lines(options->m_bIgnoreBlankLines)
		, m_ignore_numbers(options->m_bIgnoreNumbers)
// state
		, m_wsflag(false)
		, m_eol0(false)
		, m_eol1(false)
		, m_cr0(false)
		, m_cr1(false)
		, m_bol0(true)
		, m_bol1(true)
{
	if (options->m_ignoreWhitespace == WHITESPACE_IGNORE_CHANGE)
		m_ignore_space_change = true;
	else
		m_ignore_space_change = false;

	if (options->m_ignoreWhitespace == WHITESPACE_IGNORE_ALL)
		m_ignore_all_space = true;
	else
		m_ignore_all_space = false;
}

static const char* SkipBlankLines(const char* p, const char* end)
{
	for (;;)
	{
		const char* tmp = p;
		while (tmp < end && iswsch(*tmp))
			++tmp;
		while (tmp < end && iseolch(*tmp))
			++tmp;
		if (tmp == p || !iseolch(*(tmp - 1)))
			break;
		p = tmp;
	}
	return p;
};

/**
 * @brief Compare two buffers byte per byte.
 *
 * This function compares two buffers pointed to by @p ptr0 and @p ptr1.
 * Comparing takes account diffutils options flags given to constructor.
 * Buffer pointers are advanced while comparing so they point to current
 * compare position. End of buffers are given by @p end0 and @p end1, which
 * may point past last valid byte in file. Offset-params tell is how far this
 * buffer is into the file (ie, 0 the first time called).
 * @param [in,out] stats0 Statistics for first side.
 * @param [in,out] stats1 Statistics for second side.
 * @param [in,out] ptr0 Pointer to begin of the first buffer.
 * @param [in,out] ptr1 Pointer to begin of the second buffer.
 * @param [in] end0 Pointer to end of the first buffer.
 * @param [in] end1 Pointer to end of the second buffer.
 * @param [in] eof0 Is first buffers end also end of the file?
 * @param [in] eof1 Is second buffers end also end of the file?
 * @param [in] offset0 Offset of the buffer begin in the first file.
 * @param [in] offset1 Offset of the buffer begin in the second file.
 * @return COMP_RESULT telling result of the compare.
 */
ByteComparator::COMP_RESULT ByteComparator::CompareBuffers(
	FileTextStats & stats0, FileTextStats & stats1, const char* &ptr0, const char* &ptr1,
	const char* end0, const char* end1, bool eof0, bool eof1, int64_t offset0, int64_t offset1)
{
	ByteComparator::COMP_RESULT result = RESULT_SAME;

	// First, update file text statistics by doing a full scan
	// for 0s and all types of line delimiters
	TextScan(stats0, ptr0, end0, eof0, m_cr0, offset0);
	TextScan(stats1, ptr1, end1, eof1, m_cr1, offset1);

	const char *orig0 = ptr0;
	const char *orig1 = ptr1;

	// cycle through buffer data performing actual comparison
	while (true)
	{
		if (m_ignore_all_space)
		{
			// Skip over any whitespace on either side
			// skip over all whitespace
			while (ptr0 < end0 && iswsch(*ptr0))
			{
				m_bol0 = false;
				++ptr0;
			}
			// skip over all whitespace
			while (ptr1 < end1 && iswsch(*ptr1))
			{
				m_bol1 = false;
				++ptr1;
			}
			if ((ptr0 == end0 && !eof0) || (ptr1 == end1 && !eof1))
			{
				goto need_more;
			}
		}
		if (m_ignore_space_change)
		{
			// Skip over whitespace change
			// Also skip whitespace on one side if
			//  either end of line or end of file on other

			// Handle case of whitespace on side0
			// (First four cases)
			if (ptr0 < end0 && iswsch(*ptr0))
			{
				// Whitespace on side0

				if (ptr1 < end1)
				{
					if (iswsch(*ptr1))
					{
						// whitespace on both sides
						m_wsflag = true;
						m_bol0 = false;
						++ptr0;
						m_bol1 = false;
						++ptr1;
					}
					else if (iseolch(*ptr1))
					{
						// whitespace on side 0 (end of line on side 1)
						m_wsflag = true;
						m_bol0 = false;
						++ptr0;
					}
				}
				else // ptr1 == end1
				{
					if (!eof1)
					{
						// Whitespace on side0, don't know what is on side1
						// Cannot tell if matching whitespace yet
						goto need_more;
					}
					else // eof1
					{
						// Whitespace on side0, eof on side1
						m_wsflag = true;
						m_bol0 = false;
						++ptr0;
					}
				}
			}
			else
			{
				// Handle case of whitespace on side1
				// but not whitespace on side0 (that was handled above)
				// (Remaining three cases)
				if (ptr1 < end1 && iswsch(*ptr1))
				{
					// Whitespace on side1

					if (ptr0 < end0)
					{
						// "whitespace on both sides"
						// should not come here, it should have been
						// handled above
						assert(!iswsch(*ptr0));

						if (iseolch(*ptr0))
						{
							// whitespace on side 1 (eol on side 0)
							m_wsflag = true;
							m_bol1 = false;
							++ptr1;
						}
					}
					else // ptr0 == end0
					{
						if (!eof0)
						{
							// Whitespace on side1, don't know what is on side0
							// Cannot tell if matching whitespace yet
							goto need_more;
						}
						else // eof0
						{
							// Whitespace on side1, eof on side0
							m_wsflag = true;
							m_bol1 = false;
							++ptr1;
						}
					}
				}
			}

			if (m_wsflag)
			{
				// skip over consecutive whitespace
				while (ptr0 < end0 && iswsch(*ptr0))
				{
					m_bol0 = false;
					++ptr0;
				}
				// skip over consecutive whitespace
				while (ptr1 < end1 && iswsch(*ptr1))
				{
					m_bol1 = false;
					++ptr1;
				}
				if ((ptr0 == end0 && !eof0) || (ptr1 == end1 && !eof1))
				{
					// if run out of buffer on either side
					// must fetch more, to continue skipping whitespace
					m_wsflag = true;
					goto need_more;
				}
			}
			m_wsflag = false;
		}
		if (m_ignore_eol_diff)
		{
			if (m_ignore_blank_lines)
			{
				// skip over any line delimiters on either side
				while (ptr0 < end0 && iseolch(*ptr0))
					m_bol0 = true, ++ptr0;
				while (ptr1 < end1 && iseolch(*ptr1))
					m_bol1 = true, ++ptr1;
				if (m_bol0)
					ptr0 = SkipBlankLines(ptr0, end0);
				if (m_bol1)
					ptr1 = SkipBlankLines(ptr1, end1);
				if ((ptr0 == end0 && !eof0) || (ptr1 == end1 && !eof1))
				{
					goto need_more;
				}
			}
			else // don't skip blank lines, but still ignore eol difference
			{
				const char* ptr0b = ptr0;
				const char* ptr1b = ptr1;
				HandleSide0Eol((char **) &ptr0, end0, eof0);
				HandleSide1Eol((char **) &ptr1, end1, eof1);

				if (m_cr0 || m_cr1)
				{
					// these flags mean possible split CR/LF
					goto need_more;
				}
				if (m_eol0 || m_eol1)
				{
					if ((!m_eol0 || !m_eol1) && (orig0 == end0 || orig1 == end1))
					{
						// one side had an end-of-line, but the other didn't
						ptr0 = ptr0b;
						ptr1 = ptr1b;
						result = RESULT_DIFF;
						goto exit;
					}
					if (ptr0 != end0 && ptr1 != end1)
						// This continue statement is needed to handle blank lines
						continue;
				}
			}
		}
		else
		{ // do not ignore eol differences
			if (m_ignore_blank_lines)
			{
				if (m_bol0)
					ptr0 = SkipBlankLines(ptr0, end0);
				if (m_bol1)
					ptr1 = SkipBlankLines(ptr1, end1);
				if ((ptr0 == end0 && !eof0) || (ptr1 == end1 && !eof1))
				{
					goto need_more;
				}
			}
		}

		if (ptr0 == end0 || ptr1 == end1)
		{
			if (ptr0 == end0 && ptr1 == end1)
			{
				if (!eof0 || !eof1)
					goto need_more;
				else
				{
					result = (m_eol0 == m_eol1) ? RESULT_SAME : RESULT_DIFF;
					goto exit;
				}
			}
			else
			{
				// we are at the end on one side?
				if ((!(ptr0 == end0 && eof0) && !(ptr1 == end1 && eof1)) && (orig0 != end0 && orig1 != end1))
				{
					goto need_more;
				}
				else
				{
					result = RESULT_DIFF;
					goto exit;
				}
			}
		}

		tchar_t c0 = *ptr0, c1 = *ptr1;
		if (m_ignore_case)
		{
			c0 = tc::istupper(c0) ? tc::totlower(c0) : c0;
			c1 = tc::istupper(c1) ? tc::totlower(c1) : c1;
		}
		if (c0 != c1)
		{
			result = RESULT_DIFF; // buffers are different
			goto exit;
		}
		if (ptr0 < end0 && ptr1 < end1)
		{
			m_bol0 = iseolch(c0);
			m_bol1 = iseolch(c1);
			++ptr0;
			++ptr1;
			continue;
		}
		goto need_more;
	}

need_more:
	m_cr0 = (ptr0 - 1 >= orig0 && *(ptr0 - 1) == '\r');
	m_cr1 = (ptr1 - 1 >= orig1 && *(ptr1 - 1) == '\r');
	if (ptr0 == end0 && !eof0)
	{
		if (ptr1 == end1 && !eof1)
			return NEED_MORE_BOTH;
		else
			return NEED_MORE_0;
	}
	else if (ptr1 == end1 && !eof1)
	{
		return NEED_MORE_1;
	}
	else
	{
		return result;
	}

exit:
	m_cr0 = (end0 > orig0) && *(end0 - 1) == '\r';
	m_cr1 = (end1 > orig1) && *(end1 - 1) == '\r';
	return result;
}

/**
 * Brief Handle EOL bytes and differences in them.
 * @param [in, out] ptr Pointer to the buffer begin.
 * @param [in] end Pointer to the buffer end.
 * @param [in] eof Are we at end of the buffer?
 */
inline void ByteComparator::HandleSide0Eol(char **ptr, const char *end, bool eof)
{
	char * pbuf = *ptr;
	if (m_cr0)
	{
		// finish split CR/LF pair on 0-side
		if (pbuf < end && *pbuf == '\n')
		{
			// m_bol0 not used because m_ignore_eol_diff and m_ignore_blank_lines
			++pbuf;
		}
		m_eol0 = true;
		m_cr0 = false;
	}
	if (pbuf < end)
	{
		if (*pbuf == '\n')
		{
			// m_bol0 not used because m_ignore_eol_diff and m_ignore_blank_lines
			++pbuf;
			m_eol0 = true;
		}
		else if (*pbuf == '\r')
		{
			// m_bol0 not used because m_ignore_eol_diff and m_ignore_blank_lines
			++pbuf;
			m_eol0 = true;
			if (pbuf == end && !eof)
			{
				// can't tell if a CR/LF pair yet
				m_cr0 = true;
				m_eol0 = true;
			}
			else if (pbuf < end && *pbuf == '\n')
			{
				++pbuf;
			}
		}
		else
		{
			m_eol0 = false;
		}
	}
	*ptr = pbuf;
}

/**
 * Brief Handle EOL bytes and differences in them.
 * @param [in, out] ptr Pointer to the buffer begin.
 * @param [in] end Pointer to the buffer end.
 * @param [in] eof Are we at end of the buffer?
 */
inline void ByteComparator::HandleSide1Eol(char **ptr, const char *end, bool eof)
{
	char * pbuf = *ptr;

	if (m_cr1)
	{
		// finish split CR/LF pair on 1-side
		if (pbuf < end && *pbuf == '\n')
		{
			// m_bol1 not used because m_ignore_eol_diff
			++pbuf;
		}
		m_eol1 = true;
		m_cr1 = false;
	}
	if (pbuf < end)
	{
		if (*pbuf == '\n')
		{
			// m_bol1 not used because m_ignore_eol_diff
			++pbuf;
			m_eol1 = true;
		}
		else if (*pbuf == '\r')
		{
			// m_bol1 not used because m_ignore_eol_diff
			++pbuf;
			m_eol1 = true;
			if (pbuf == end && !eof)
			{
				// can't tell if a CR/LF pair yet
				m_cr1 = true;
				m_eol1 = true;
			}
			else if (pbuf < end && *pbuf == '\n')
			{
				++pbuf;
			}
		}
		else
		{
			m_eol1 = false;
		}
	}
	*ptr = pbuf;
}

} //namespace CompareEngines

</file>

<file path="Winmerge-Src/Src/CompareEngines/ByteComparator.h">
/**
 * @file ByteComparator.h
 *
 * @brief Declaration file for ByteComparator class.
 */
#pragma once

#include <cstdint>

class QuickCompareOptions;
struct FileTextStats;

namespace CompareEngines
{

/**
 * @brief Byte per byte compare class implementing Quick Compare.
 *
 * This class implements WinMerge's Quick Compare -compare method. Basically it
 * compares two buffers byte per byte. But it also respects WinMerge compare
 * options for whitespace ignore etc. Which makes it more complex than just
 * simple byte per byte compare. Also counts EOL / 0-byte statistics from
 * buffers so we can detect binary files and EOL types.
 */
class ByteComparator
{
public:
	explicit ByteComparator(const QuickCompareOptions * options);

public:
	/** @brief Return values for CompareBuffers method. */
	typedef enum
	{
		RESULT_DIFF, /**< Buffers are different */
		RESULT_SAME, /**< Buffers are identical */
		NEED_MORE_0, /**< First buffer needs more data */
		NEED_MORE_1, /**< Second buffer needs more data */
		NEED_MORE_BOTH, /**< Both buffers need more data */
	} COMP_RESULT;

	COMP_RESULT CompareBuffers(FileTextStats & stats0, FileTextStats & stats1,
			const char* &ptr0, const char* &ptr1, const char* end0, const char* end1,
			bool eof0, bool eof1, int64_t offset0, int64_t offset1);

protected:
	void HandleSide0Eol(char **ptr, const char *end, bool eof);
	void HandleSide1Eol(char **ptr, const char *end, bool eof);

private:
	// settings
	bool m_ignore_case; /**< Ignore character case */
	bool m_ignore_numbers; /**< Ignore character case */
	bool m_ignore_space_change; /**< Ignore change in whitespace char count */
	bool m_ignore_all_space; /**< Ignore all whitespace changes */
	bool m_ignore_eol_diff; /**< Ignore differences in EOL bytes */
	bool m_ignore_blank_lines; /**< Ignore blank lines */
	// state
	bool m_wsflag; /**< ignore_space_change & in a whitespace area */
	bool m_eol0; /**< 0-side has an eol */
	bool m_eol1; /**< 1-side has an eol */
	bool m_cr0; /**< 0-side has a CR at end of buffer (might be split CR/LF) */
	bool m_cr1; /**< 1-side has a CR at end of buffer (might be split CR/LF) */
	bool m_bol0; /**< 0-side is at beginning of line (!ignore_eol_differences & ignore_blank_lines) */
	bool m_bol1; /**< 1-side is at beginning of line (!ignore_eol_differences & ignore_blank_lines) */
};

} // namespace CompareEngines
</file>

<file path="Winmerge-Src/Src/CompareEngines/ByteCompare.cpp">
/**
 * @file  ByteCompare.cpp
 *
 * @brief Implementation file for ByteCompare
 */

#include "pch.h"
#include "ByteCompare.h"
#include <cassert>
#include "cio.h"
#include "FileLocation.h"
#include "UnicodeString.h"
#include "IAbortable.h"
#include "CompareOptions.h"
#include "DiffContext.h"
#include "diff.h"
#include "ByteComparator.h"
#include "DiffFileData.h"

namespace CompareEngines
{

static const int KILO = 1024; // Kilo(byte)

/** @brief Quick contents compare's file buffer size. */
static const int WMCMPBUFF = 32 * KILO;

/**
 * @brief Default constructor.
 */
ByteCompare::ByteCompare()
		: m_pOptions(nullptr)
		, m_piAbortable(nullptr)
{
}

/**
 * @brief Default destructor.
 */
ByteCompare::~ByteCompare() = default;

/**
 * @brief Set compare options from general compare options.
 * @param [in ]options General compare options.
 */
void ByteCompare::SetCompareOptions(const CompareOptions & options)
{
	m_pOptions.reset(new QuickCompareOptions(options));
}

/**
 * @brief Set compare-type specific options.
 * @param [in] stopAfterFirstDiff Do we stop compare after first found diff.
 */
void ByteCompare::SetAdditionalOptions(bool stopAfterFirstDiff)
{
	m_pOptions->m_bStopAfterFirstDiff = stopAfterFirstDiff;
}

/**
 * @brief Set Abortable-interface.
 * @param [in] piAbortable Pointer to abortable interface.
 */
void ByteCompare::SetAbortable(const IAbortable * piAbortable)
{
	m_piAbortable = const_cast<IAbortable*>(piAbortable);
}

/**
 * @brief Compare two specified files, byte-by-byte
 * @return DIFFCODE
 */
int ByteCompare::CompareFiles(DiffFileData* diffData)
{
	diffData->m_textStats[0].clear();
	diffData->m_textStats[1].clear();

	// TODO
	// Right now, we assume files are in 8-bit encoding
	// because transform code converted any UCS-2 files to UTF-8
	// We could compare directly in UCS-2LE here, as an optimization, in that case
	char buff[2][WMCMPBUFF]; // buffered access to files
	std::string lasteol[2];
	int i;
	unsigned diffcode = 0;

	// area of buffer currently holding data
	int64_t bfstart[2]; // offset into buff[i] where current data resides
	int64_t bfend[2]; // past-the-end pointer into buff[i], giving end of current data
	// buff[0] has bytes to process from buff[0][bfstart[0]] to buff[0][bfend[0]-1]

	bool eof[2]; // if we've finished file

	// initialize our buffer pointers and end of file flags
	for (i = 0; i < 2; ++i)
	{
		bfstart[i] = bfend[i] = 0;
		eof[i] = false;
	}

	ByteComparator comparator(m_pOptions.get());

	// Begin loop
	// we handle the files in WMCMPBUFF sized buffers (variable buff[][])
	// That is, we do one buffer full at a time
	// or even less, as we process until one side buffer is empty, then reload that one
	// and continue
	while (!eof[0] || !eof[1])
	{
		if (m_piAbortable != nullptr && m_piAbortable->ShouldAbort())
			return DIFFCODE::CMPABORT;

		// load or update buffers as appropriate
		for (i = 0; i < 2; ++i)
		{
			if (!eof[i] && bfstart[i] == sizeof(buff[i])/sizeof(buff[i][0]))
			{
				bfstart[i] = bfend[i] = 0;
			}
			if (!eof[i] && bfend[i] < sizeof(buff[i])/sizeof(buff[i][0]) - 1)
			{
				// Assume our blocks are in range of int
				int space = sizeof(buff[i])/sizeof(buff[i][0]) - (int) bfend[i];
				int rtn = cio::read_i(diffData->m_inf[i].desc, &buff[i][bfend[i]], space);
				if (rtn == -1)
					return DIFFCODE::CMPERR;
				if (rtn < space)
					eof[i] = true;
				bfend[i] += rtn;
				if (m_pOptions->m_bIgnoreMissingTrailingEol)
				{
					for (int64_t j = (std::max)(bfstart[i], bfend[i] - 4); j < bfend[i]; ++j)
					{
						const char c = buff[i][j];
						if (c == '\r' || c == '\n')
							lasteol[i].push_back(c);
						else
							lasteol[i].clear();
					}
				}
				if (diffData->m_inf[0].desc == diffData->m_inf[1].desc)
				{
					bfstart[1] = bfstart[0];
					bfend[1] = bfend[0];
					eof[1] = eof[0];
					lasteol[1] = lasteol[0];
					diffData->m_FileLocation[1] = diffData->m_FileLocation[0];
					memcpy(&buff[1][bfend[1] - rtn], &buff[0][bfend[0] - rtn], rtn);
					break;
				}
			}
		}
		// where to start comparing right now
		const char* ptr0 = &buff[0][bfstart[0]];
		const char* ptr1 = &buff[1][bfstart[1]];

		// remember where we started
		const char* orig0 = ptr0;
		const char* orig1 = ptr1;

		// how far can we go right now?
		const char* end0 = &buff[0][bfend[0]];
		const char* end1 = &buff[1][bfend[1]];

		int64_t offset0 = (ptr0 - &buff[0][0]);
		int64_t offset1 = (ptr1 - &buff[1][0]);

		// are these two buffers the same?
		int result = comparator.CompareBuffers(diffData->m_textStats[0], diffData->m_textStats[1],
				ptr0, ptr1, end0, end1, eof[0], eof[1], offset0, offset1);
		if (result == ByteComparator::RESULT_DIFF)
		{
			if (m_pOptions->m_bStopAfterFirstDiff)
			{
				// By bailing out here
				// we leave our text statistics incomplete
				return diffcode | DIFFCODE::DIFF;
			}
			else
			{
				if (m_pOptions->m_bIgnoreMissingTrailingEol)
				{
					if ((eof[0] || eof[1]) &&
						((end0 - ptr0 <= 1 && (lasteol[0] == "\r" || lasteol[0] == "\n" || lasteol[0] == "\r\n") && (end1 == ptr1))) ||
						((end0 - ptr0 == 2 && (lasteol[0] == "\r\n") && (end1 == ptr1))) ||
						((end1 - ptr1 <= 1 && (lasteol[1] == "\r" || lasteol[1] == "\n" || lasteol[1] == "\r\n") && (end0 == ptr0))) ||
						((end1 - ptr1 == 2 && (lasteol[1] == "\r\n") && (end0 == ptr0))))
						;
					else
						diffcode |= DIFFCODE::DIFF;
				}
				else
				{
					diffcode |= DIFFCODE::DIFF;
				}
				ptr0 = end0;
				ptr1 = end1;
				// move our current pointers over what we just compared
				assert(ptr0 >= orig0);
				assert(ptr1 >= orig1);
				bfstart[0] += ptr0 - orig0;
				bfstart[1] += ptr1 - orig1;
			}
		}
		else if (result == ByteComparator::NEED_MORE_0)
		{
			const int m = (int)(ptr0 - &buff[0][0]);
			const int l = (int)(end0 - ptr0);
			//move uncompared data to begin of buff0
			memcpy(&buff[0][0], &buff[0][m], l);
			bfstart[0] = 0;
			bfstart[1] += ptr1 - orig1;
			bfend[0] = l;
		}
		else if (result == ByteComparator::NEED_MORE_1)
		{
			const int m = (int)(ptr1 - &buff[1][0]);
			const int l = (int)(end1 - ptr1);
			//move uncompared data to begin of buff1
			memcpy(&buff[1][0], &buff[1][m], l);
			bfstart[1] = 0;
			bfstart[0] += ptr0 - orig0;
			bfend[1] = l;
		}
		else if (result == ByteComparator::NEED_MORE_BOTH)
		{
			if ((end0 == ptr0) && (end1 == ptr1))
			{
				bfstart[0] += ptr0 - orig0;
				bfend[0] = 0;
				bfstart[1] += ptr1 - orig1;
				bfend[1] = 0;
			}
			else
			{
				if (ptr0 < end0)
				{
					const int m = (int)(ptr0 - orig0);
					const int l = (int)(end0 - ptr0);
					//move uncompared data to begin of buff0
					memcpy(&buff[0][0], &buff[0][m], l);
					bfstart[0] = 0;
					bfend[0] += l;
				}
				if (ptr1 < end1)
				{
					const int m = (int)(ptr1 - orig1);
					const int l = (int)(end1 - ptr1);
					//move uncompared data to begin of buff1
					memcpy(&buff[1][0], &buff[1][ m], l);
					bfstart[1] = 0;
					bfend[1] += l;
				}
			}
		}
		else
		{
			assert(result == ByteComparator::RESULT_SAME);
		}

		// Did we finish both files?
		// We set the text/binary status only for fully compared files. Only
		// then the result is reliable.
		if (eof[0] && eof[1])
		{
			bool bBin0 = (diffData->m_textStats[0].nzeros > 0);
			bool bBin1 = (diffData->m_textStats[1].nzeros > 0);

			if (bBin0 && bBin1)
				diffcode |= DIFFCODE::BIN | DIFFCODE::BINSIDE1 | DIFFCODE::BINSIDE2;
			else if (bBin0)
				diffcode |= DIFFCODE::BIN | DIFFCODE::BINSIDE1;
			else if (bBin1)
				diffcode |= DIFFCODE::BIN | DIFFCODE::BINSIDE2;
			else
				diffcode |= DIFFCODE::TEXT;

			// If either unfinished, they differ
			if (ptr0 != end0 || ptr1 != end1)
				diffcode = (diffcode & DIFFCODE::DIFF);
			if (diffcode & DIFFCODE::DIFF)
				return diffcode | DIFFCODE::DIFF;
			else
				return diffcode | DIFFCODE::SAME;
		}
	}
	return diffcode;
}

} // namespace CompareEngines
</file>

<file path="Winmerge-Src/Src/CompareEngines/ByteCompare.h">
/**
 * @file  ByteCompare.h
 *
 * @brief Declaration file for ByteCompare
 */
#pragma once

#include <memory>
#include "FileTextStats.h"

class CompareOptions;
class QuickCompareOptions;
class IAbortable;
struct DiffFileData;

namespace CompareEngines
{

/**
 * @brief A quick compare -compare method implementation class.
 * This compare method compares files in small blocks. Code assumes block size
 * is in range of 32-bit int-type.
 */
class ByteCompare
{
public:
	ByteCompare();
	~ByteCompare();

	void SetCompareOptions(const CompareOptions & options);
	void SetAdditionalOptions(bool stopAfterFirstDiff);
	void SetAbortable(const IAbortable * piAbortable);

	int CompareFiles(DiffFileData* diffData);

private:
	std::unique_ptr<QuickCompareOptions> m_pOptions; /**< Compare options for diffutils. */
	IAbortable * m_piAbortable;
};

} // namespace CompareEngines
</file>

<file path="Winmerge-Src/Src/CompareEngines/CompareEngines.vcxitems">
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Label="Globals">
    <MSBuildAllProjects Condition="'$(MSBuildVersion)' == '' Or '$(MSBuildVersion)' &lt; '16.0'">$(MSBuildAllProjects);$(MSBuildThisFileFullPath)</MSBuildAllProjects>
    <HasSharedItems>true</HasSharedItems>
    <ItemsProjectGuid>{0f686afa-d587-43c0-bada-2beddc3fa758}</ItemsProjectGuid>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <ClCompile>
      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(MSBuildThisFileDirectory)</AdditionalIncludeDirectories>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ProjectCapability Include="SourceItemsFromImports" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="$(MSBuildThisFileDirectory)BinaryCompare.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)ByteComparator.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)ByteCompare.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)ImageCompare.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)TimeSizeCompare.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)Wrap_DiffUtils.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="$(MSBuildThisFileDirectory)BinaryCompare.cpp">
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)ByteComparator.cpp">
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)ByteCompare.cpp">
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)ImageCompare.cpp">
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)TimeSizeCompare.cpp">
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)Wrap_DiffUtils.cpp">
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
    </ClCompile>
  </ItemGroup>
</Project>
</file>

<file path="Winmerge-Src/Src/CompareEngines/CompareEngines.vcxitems.filters">
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Header Files">
      <UniqueIdentifier>{7f9981c6-13e4-4fef-8497-a98f859c5c06}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files">
      <UniqueIdentifier>{df4406af-26e4-46f4-9e0c-9e6a254753b9}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="$(MSBuildThisFileDirectory)ImageCompare.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="$(MSBuildThisFileDirectory)BinaryCompare.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="$(MSBuildThisFileDirectory)ByteComparator.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="$(MSBuildThisFileDirectory)ByteCompare.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="$(MSBuildThisFileDirectory)Wrap_DiffUtils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="$(MSBuildThisFileDirectory)TimeSizeCompare.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="$(MSBuildThisFileDirectory)ImageCompare.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)BinaryCompare.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)ByteComparator.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)ByteCompare.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)Wrap_DiffUtils.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)TimeSizeCompare.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
</file>

<file path="Winmerge-Src/Src/CompareEngines/ImageCompare.cpp">
/**
 * @file  ImageCompare.cpp
 *
 * @brief Implementation file for ImageCompare
 */

#include "pch.h"
#include "ImageCompare.h"
#include "DiffItem.h"
#include "PathContext.h"
#include "WinIMergeLib.h"
#include <windows.h>

namespace CompareEngines
{

ImageCompare::ImageCompare()
	: m_colorDistanceThreshold(0.0)
	, m_pImgMergeWindow(nullptr)
	, m_hModule(nullptr)
{
	m_hModule = LoadLibraryW(L"WinIMerge\\WinIMergeLib.dll");
	if (m_hModule == nullptr)
		return;
	IImgMergeWindow* (*pfnWinIMerge_CreateWindowless)() =
		(IImgMergeWindow * (*)())GetProcAddress(m_hModule, "WinIMerge_CreateWindowless");
	if (pfnWinIMerge_CreateWindowless == nullptr)
		return;
	m_pImgMergeWindow = pfnWinIMerge_CreateWindowless();
}

ImageCompare::~ImageCompare()
{
	if (m_pImgMergeWindow)
	{
		bool(*pfnWinIMerge_DestroyWindow)(IImgMergeWindow *) =
			(bool(*)(IImgMergeWindow *))GetProcAddress(m_hModule, "WinIMerge_DestroyWindow");
		if (pfnWinIMerge_DestroyWindow != nullptr)
			pfnWinIMerge_DestroyWindow(m_pImgMergeWindow);
	}
	if (m_hModule)
		FreeLibrary(m_hModule);
}

int ImageCompare::compare_files(const String& file1, const String& file2) const
{
	if (!m_pImgMergeWindow)
		return DIFFCODE::CMPERR;
	int code = DIFFCODE::CMPERR;
	m_pImgMergeWindow->SetColorDistanceThreshold(m_colorDistanceThreshold);
	if (m_pImgMergeWindow->OpenImages(file1.c_str(), file2.c_str()))
	{
		bool bImgDiff = false;
		if (m_pImgMergeWindow->GetPageCount(0) == m_pImgMergeWindow->GetPageCount(1))
		{
			for (int page = 0; page < m_pImgMergeWindow->GetPageCount(0); ++page)
			{
				m_pImgMergeWindow->SetCurrentPageAll(page);
				if (m_pImgMergeWindow->GetDiffCount() > 0)
					bImgDiff = true;
			}
		}
		else
		{
			bImgDiff = true;
		}
		code = bImgDiff ? DIFFCODE::DIFF : DIFFCODE::SAME;
		m_pImgMergeWindow->CloseImages();
	}
	return code;
}

/**
 * @brief Compare two specified files
 * @param [in] di Diffitem info.
 * @return DIFFCODE
 */
int ImageCompare::CompareFiles(const PathContext& files, const DIFFITEM &di) const
{
	switch (files.GetSize())
	{
	case 2:
		return (!di.diffcode.exists(0) || !di.diffcode.exists(1)) ?
			DIFFCODE::DIFF : compare_files(files[0], files[1]);
	case 3:
		unsigned code10 = (!di.diffcode.exists(1) || !di.diffcode.exists(0)) ?
			DIFFCODE::DIFF : compare_files(files[1], files[0]);
		unsigned code12 = (!di.diffcode.exists(1) || !di.diffcode.exists(2)) ?
			DIFFCODE::DIFF : compare_files(files[1], files[2]);
		unsigned code02 = DIFFCODE::SAME;
		if (code10 == DIFFCODE::SAME && code12 == DIFFCODE::SAME)
			return DIFFCODE::SAME;
		else if (code10 == DIFFCODE::SAME && code12 == DIFFCODE::DIFF)
			return DIFFCODE::DIFF | DIFFCODE::DIFF3RDONLY;
		else if (code10 == DIFFCODE::DIFF && code12 == DIFFCODE::SAME)
			return DIFFCODE::DIFF | DIFFCODE::DIFF1STONLY;
		else if (code10 == DIFFCODE::DIFF && code12 == DIFFCODE::DIFF)
		{
			code02 = (!di.diffcode.exists(0) || !di.diffcode.exists(2)) ?
				DIFFCODE::DIFF : compare_files(files[0], files[2]);
			if (code02 == DIFFCODE::SAME)
				return DIFFCODE::DIFF | DIFFCODE::DIFF2NDONLY;
		}
		if (code10 == DIFFCODE::CMPERR || code12 == DIFFCODE::CMPERR || code02 == DIFFCODE::CMPERR)
			return DIFFCODE::CMPERR;
		return DIFFCODE::DIFF;
	}
	return DIFFCODE::CMPERR;
}

} // namespace CompareEngines
</file>

<file path="Winmerge-Src/Src/CompareEngines/ImageCompare.h">
/**
 * @file  ImageCompare.h
 *
 * @brief Declaration file for ImageCompare compare engine.
 */
#pragma once

#include "UnicodeString.h"

class DIFFITEM;
class PathContext;
struct IImgMergeWindow;
struct HINSTANCE__;

namespace CompareEngines
{

/**
 * @brief A image compare class.
 * This compare method compares files by their image contents.
 */
class ImageCompare
{
public:
	ImageCompare();
	~ImageCompare();
	int CompareFiles(const PathContext& files, const DIFFITEM &di) const;

    double GetColorDistanceThreshold() const { return m_colorDistanceThreshold; }
    void SetColorDistanceThreshold(double colorDistanceThreshold) { m_colorDistanceThreshold = colorDistanceThreshold; };
private:
    int compare_files(const String& file1, const String& file2) const;
    mutable IImgMergeWindow *m_pImgMergeWindow;
    double m_colorDistanceThreshold;
    struct HINSTANCE__* m_hModule;
};

} // namespace CompareEngines
</file>

<file path="Winmerge-Src/Src/CompareEngines/TimeSizeCompare.cpp">
/**
 * @file  TimeSizeCompare.cpp
 *
 * @brief Implementation file for TimeSizeCompare
 */

#include "pch.h"
#include "TimeSizeCompare.h"
#include <Poco/Timestamp.h>
#include "DiffItem.h"
#include "DiffWrapper.h"

using Poco::Timestamp;

namespace CompareEngines
{

TimeSizeCompare::TimeSizeCompare()
		: m_ignoreSmallDiff(false)
{
}

TimeSizeCompare::~TimeSizeCompare() = default;

/**
 * @brief Set compare-type specific options.
 * @param [in] ignoreSmallDiff Ignore small time differences?
 */
void TimeSizeCompare::SetAdditionalOptions(bool ignoreSmallDiff)
{
	m_ignoreSmallDiff = ignoreSmallDiff;
}

/**
 * @brief Compare two specified files, byte-by-byte
 * @param [in] compMethod Compare method used.
 * @param [in] di Diffitem info.
 * @return DIFFCODE
 */
int TimeSizeCompare::CompareFiles(int compMethod, int nfiles, const DIFFITEM &di) const
{
	unsigned code = DIFFCODE::SAME;
	int64_t nTimeDiff = 0;
	int64_t nTimeDiff12 = 0;
	int64_t nTimeDiff02 = 0;
	if ((compMethod == CMP_DATE) || (compMethod == CMP_DATE_SIZE))
	{
		// Compare by modified date
		// Check that we have both filetimes
		nTimeDiff   = di.diffFileInfo[0].mtime - di.diffFileInfo[1].mtime;
		if (nTimeDiff   < 0) nTimeDiff   *= -1;
		nTimeDiff = nTimeDiff / Timestamp::resolution() * Timestamp::resolution();
		if (nfiles > 2)
		{
			nTimeDiff12 = di.diffFileInfo[1].mtime - di.diffFileInfo[2].mtime;
			nTimeDiff02 = di.diffFileInfo[0].mtime - di.diffFileInfo[2].mtime;
			if (nTimeDiff12 < 0) nTimeDiff12 *= -1;
			if (nTimeDiff02 < 0) nTimeDiff02 *= -1;
			nTimeDiff12 = nTimeDiff12 / Timestamp::resolution() * Timestamp::resolution();
			nTimeDiff02 = nTimeDiff02 / Timestamp::resolution() * Timestamp::resolution();
		}
		if (m_ignoreSmallDiff)
		{
			// If option to ignore small timediffs (couple of seconds)
			// is set, decrease absolute difference by allowed diff
			nTimeDiff   -= SmallTimeDiff * Timestamp::resolution();
			nTimeDiff12 -= SmallTimeDiff * Timestamp::resolution();
			nTimeDiff02 -= SmallTimeDiff * Timestamp::resolution();
		}
		if (nTimeDiff <= 0 && nTimeDiff12 <= 0)
			code = DIFFCODE::SAME;
		else
			code = DIFFCODE::DIFF;

		for (int i = 0; i < nfiles; ++i)
		{
			if (di.diffFileInfo[i].mtime == Poco::Timestamp::TIMEVAL_MIN && di.diffcode.exists(i))
				code = DIFFCODE::CMPERR;
		}
	}
	// This is actual CMP_SIZE method..
	// If file sizes differ mark them different
	if ((compMethod == CMP_DATE_SIZE) || (compMethod == CMP_SIZE))
	{
		if (di.diffFileInfo[0].size != di.diffFileInfo[1].size || 
		    (nfiles > 2 && di.diffFileInfo[1].size != di.diffFileInfo[2].size))
		{
			code = DIFFCODE::DIFF;
		}

		for (int i = 0; i < nfiles; ++i)
		{
			if (di.diffFileInfo[i].size == DirItem::FILE_SIZE_NONE && di.diffcode.exists(i))
				code = DIFFCODE::CMPERR;
		}
	}
	if (nfiles > 2 && (code & DIFFCODE::COMPAREFLAGS) == DIFFCODE::DIFF)
	{
		if (compMethod == CMP_DATE)
		{
			if (nTimeDiff12 <= 0)
				code |= DIFFCODE::DIFF1STONLY;
			else if (nTimeDiff02 <= 0)
				code |= DIFFCODE::DIFF2NDONLY;
			else if (nTimeDiff <= 0)
				code |= DIFFCODE::DIFF3RDONLY;
		}
		else if (compMethod == CMP_DATE_SIZE)
		{
			if (nTimeDiff12 <= 0 && di.diffFileInfo[1].size == di.diffFileInfo[2].size)
				code |= DIFFCODE::DIFF1STONLY;
			else if (nTimeDiff02 <= 0 && di.diffFileInfo[0].size == di.diffFileInfo[2].size)
				code |= DIFFCODE::DIFF2NDONLY;
			else if (nTimeDiff <= 0 && di.diffFileInfo[0].size == di.diffFileInfo[1].size)
				code |= DIFFCODE::DIFF3RDONLY;
		}
		else if (compMethod == CMP_SIZE)
		{
			if (di.diffFileInfo[1].size == di.diffFileInfo[2].size)
				code |= DIFFCODE::DIFF1STONLY;
			else if (di.diffFileInfo[0].size == di.diffFileInfo[2].size)
				code |= DIFFCODE::DIFF2NDONLY;
			else if (di.diffFileInfo[0].size == di.diffFileInfo[1].size)
				code |= DIFFCODE::DIFF3RDONLY;
		}
	}
	return code;
}

} // namespace CompareEngines
</file>

<file path="Winmerge-Src/Src/CompareEngines/TimeSizeCompare.h">
/**
 * @file  TimeSizeCompare.h
 *
 * @brief Declaration file for TimeSizeCompare compare engine.
 */
#pragma once

class DIFFITEM;

namespace CompareEngines
{

/**
 * @brief A time/size compare class.
 * This compare method compares files by their times and sizes.
 */
class TimeSizeCompare
{
public:
	/// Seconds ignored in filetime differences if option enabled
	enum {
		SmallTimeDiff = 2
	};

	TimeSizeCompare();
	~TimeSizeCompare();
	void SetAdditionalOptions(bool ignoreSmallDiff);
	int CompareFiles(int compMethod, int nfiles, const DIFFITEM &di) const;

private:
	bool m_ignoreSmallDiff;
};

} // namespace CompareEngines
</file>

<file path="Winmerge-Src/Src/CompareEngines/Wrap_DiffUtils.cpp">
/**
 * @file  Wrap_DiffUtils.cpp
 *
 * @brief Implementation file for Wrap_DiffUtils class.
 */

#include "pch.h"
#include "diff.h"
#include "Wrap_DiffUtils.h"
#include <map>
#include <algorithm>
#include <cassert>
#include <sstream>
#include <vector>
#include "DiffContext.h"
#include "Exceptions.h"
#include "FilterList.h"
#include "CompareOptions.h"
#include "coretools.h"
#include "DiffList.h"
#include "DiffWrapper.h"
#include "xdiff_gnudiff_compat.h"
#include "unicoder.h"
#include "DiffFileData.h"

namespace CompareEngines
{

/**
 * @brief Default constructor.
 */
DiffUtils::DiffUtils()
		:  m_pDiffWrapper(new ::CDiffWrapper)
		, m_ndiffs(0)
		, m_ntrivialdiffs(0)
{
}

/**
 * @brief Default destructor.
 */
DiffUtils::~DiffUtils()
{
}

/**
 * @brief Set compare options from general compare options.
 * @param [in ]options General compare options.
 */
void DiffUtils::SetCompareOptions(const CompareOptions& options)
{
	DIFFOPTIONS doptions;
	static_cast<const DiffutilsOptions&>(options).GetAsDiffOptions(doptions);
	m_pDiffWrapper->SetOptions(&doptions, true);
}

/**
 * @brief Clear current filters list.
 * Don't delete the list as it points to external list.
 */
void DiffUtils::ClearFilterList()
{
	m_pDiffWrapper->SetFilterList(static_cast<std::shared_ptr<FilterList>>(nullptr));
}

/**
 * @brief Set line filters list to use.
 * @param [in] list List of line filters.
 */
void DiffUtils::SetFilterList(std::shared_ptr<FilterList> list)
{
	m_pDiffWrapper->SetFilterList(list);
}

void DiffUtils::SetSubstitutionList(std::shared_ptr<SubstitutionList> list)
{
	m_pDiffWrapper->SetSubstitutionList(list);
}

void DiffUtils::ClearSubstitutionList()
{
	m_pDiffWrapper->SetSubstitutionList(nullptr);
}

void DiffUtils::SetCodepage(int codepage)
{
	m_pDiffWrapper->SetCodepage(codepage);
}

/**
 * @brief Compare two files (as earlier specified).
 * @return DIFFCODE as a result of compare.
 */
int DiffUtils::CompareFiles(DiffFileData* diffData)
{
	int bin_flag = 0;
	int bin_file = 0; // bitmap for binary files

	// Do the actual comparison (generating a change script)
	struct change *script = nullptr;
	bool success = m_pDiffWrapper->Diff2Files(&script, diffData, & bin_flag, & bin_file);
	if (!success)
	{
		return DIFFCODE::FILE | DIFFCODE::TEXT | DIFFCODE::CMPERR;
	}
	unsigned code = DIFFCODE::FILE | DIFFCODE::TEXT | DIFFCODE::SAME;

	// make sure to start counting diffs at 0
	// (usually it is -1 at this point, for unknown)
	m_ndiffs = 0;
	m_ntrivialdiffs = 0;

	if (script != nullptr)
	{
		const bool usefilters = m_pDiffWrapper->GetOptions().m_filterCommentsLines ||
			m_pDiffWrapper->GetOptions().m_bIgnoreMissingTrailingEol ||
			(m_pDiffWrapper->GetFilterList() && m_pDiffWrapper->GetFilterList()->HasRegExps()) ||
			(m_pDiffWrapper->GetSubstitutionList() && m_pDiffWrapper->GetSubstitutionList()->HasRegExps());
	
		PostFilterContext ctxt{};
		String Ext = ucr::toTString(diffData->m_inf[0].name);
		size_t PosOfDot = Ext.rfind('.');
		if (PosOfDot != String::npos)
			Ext.erase(0, PosOfDot + 1);

		m_pDiffWrapper->SetFilterCommentsSourceDef(Ext);

		struct change *next = script;

		while (next != nullptr)
		{
			/* Find a set of changes that belong together.  */
			struct change *thisob = next;
			struct change *end = find_change(next);

			/* Disconnect them from the rest of the changes,
			making them a hunk, and remember the rest for next iteration.  */
			next = end->link;
			end->link = nullptr;
#ifdef _DEBUG
			debug_script(thisob);
#endif

			{
				/* Determine range of line numbers involved in each file.  */
				int first0 = 0, last0 = 0, first1 = 0, last1 = 0, deletes = 0, inserts = 0;
				analyze_hunk (thisob, &first0, &last0, &first1, &last1, &deletes, &inserts, diffData->m_inf);

				/* Reconnect the script so it will all be freed properly.  */
				end->link = next;

				if (deletes!=0 || inserts!=0 || thisob->trivial!=0)
				{
					OP_TYPE op = (deletes == 0 && inserts == 0) ? OP_TRIVIAL : OP_DIFF;

					if (op != OP_TRIVIAL && usefilters)
					{
						m_pDiffWrapper->PostFilter(ctxt, thisob, diffData->m_inf);
					}
				}
			}
		}
	}


	// Free change script (which we don't want)
	if (script != nullptr)
	{
		struct change *p, *e;
		for (e = script; e; e = p)
		{
			if (!e->trivial)
				++m_ndiffs;
			else
				++m_ntrivialdiffs;
			p = e->link;
			free(e);
		}
		if (m_ndiffs > 0)
			code = code & ~DIFFCODE::SAME | DIFFCODE::DIFF;
	}

	// diff_2_files set bin_flag to -1 if different binary
	// diff_2_files set bin_flag to +1 if same binary

	if (bin_flag != 0)
	{
		// Clear text-flag, set binary flag
		// We don't know diff counts for binary files
		code = code & ~DIFFCODE::TEXT;
		switch (bin_file)
		{
		case BINFILE_SIDE1:
			code |= DIFFCODE::BIN | DIFFCODE::BINSIDE1;
			break;
		case BINFILE_SIDE2:
			code |= DIFFCODE::BIN | DIFFCODE::BINSIDE2;
			break;
		case BINFILE_SIDE1 | BINFILE_SIDE2:
			code |= DIFFCODE::BIN | DIFFCODE::BINSIDE1 | DIFFCODE::BINSIDE2;
			break;
		default:
			std::ostringstream ss;
			ss << "Invalid bin_file value: " << bin_file;
			throw ss.str();
			break;
		}
		m_ndiffs = CDiffContext::DIFFS_UNKNOWN;
	}

	if (bin_flag < 0)
	{
		// Clear same-flag, set diff-flag
		code = code & ~DIFFCODE::SAME | DIFFCODE::DIFF;
	}

	return code;
}

/**
 * @brief Compare two files using diffutils.
 *
 * Compare two files (in DiffFileData param) using diffutils. Run diffutils
 * inside SEH so we can trap possible error and exceptions. If error or
 * execption is trapped, return compare failure.
 * @param [out] diffs Pointer to list of change structs where diffdata is stored.
 * @param [in] depth Depth in folder compare (we use 0).
 * @param [out] bin_status used to return binary status from compare.
 * @param [in] bMovedBlocks If `true` moved blocks are analyzed.
 * @param [out] bin_file Returns which file was binary file as bitmap.
    So if first file is binary, first bit is set etc. Can be `nullptr` if binary file
    info is not needed (faster compare since diffutils don't bother checking
    second file if first is binary).
 * @return `true` when compare succeeds, `false` if error happened during compare.
 */
bool DiffUtils::Diff2Files(struct change ** diffs, DiffFileData *diffData,
		int * bin_status, int * bin_file) const
{
	return m_pDiffWrapper->Diff2Files(diffs, diffData, bin_status, bin_file);
}

/**
 * @brief Return diff counts for last compare.
 * @param [out] diffs Count of real differences.
 * @param [out] trivialDiffs Count of ignored differences.
 */
void DiffUtils::GetDiffCounts(int & diffs, int & trivialDiffs) const
{
	diffs = m_ndiffs;
	trivialDiffs = m_ntrivialdiffs;
}


} // namespace CompareEngines
</file>

<file path="Winmerge-Src/Src/CompareEngines/Wrap_DiffUtils.h">
/**
 * @file  Wrap_DiffUtils.h
 *
 * @brief Declaration of Wrap_DiffUtils class.
 */
#pragma once

#include <memory>

class FilterList;
class SubstitutionList;
class CompareOptions;
struct FileTextStats;
class CDiffWrapper;
struct DiffFileData;

namespace CompareEngines
{

/**
 * @brief A class wrapping GNU diffutils as compare engine.
 *
 * This class needs to have all its data as local copies, not as pointers
 * outside. Lifetime can vary certainly be different from unrelated classes.
 * Filters list being an exception - pcre structs are too complex to easily
 * copy so we'll only keep a pointer to external list.
 */
class DiffUtils
{
public:
	DiffUtils();
	~DiffUtils();

	void SetCodepage(int codepage);
	void SetCompareOptions(const CompareOptions& options);
	void SetFilterList(std::shared_ptr<FilterList> plist);
	void ClearFilterList();
	void SetSubstitutionList(std::shared_ptr<SubstitutionList> plist);
	void ClearSubstitutionList();

	int CompareFiles(DiffFileData* diffData);
	bool Diff2Files(struct change ** diffs, DiffFileData *diffData,
			int * bin_status, int * bin_file) const;

	void GetDiffCounts(int & diffs, int & trivialDiffs) const;

private:
	int m_ndiffs; /**< Real diffs found. */
	int m_ntrivialdiffs; /**< Ignored diffs found. */
	std::unique_ptr<CDiffWrapper> m_pDiffWrapper;
};


} // namespace CompareEngines
</file>

<file path="Winmerge-Src/Src/diffutils/config.h">
/*
 *	config.h - pre-built version for MSDOS and NT.
 */
#pragma once
 
#define HAVE_VPRINTF 1
#define RETSIGTYPE void
#define STDC_HEADERS 1
#define HAVE_DUP2 1
#define HAVE_MEMCHR 1
#define HAVE_SIGACTION 1
#define HAVE_STRERROR 1
#define HAVE_WAITPID 1
#define HAVE_FCNTL_H 1
#define HAVE_LIMITS_H 1
#define HAVE_STDLIB_H 1
#define HAVE_STRING_H 1
#define HAVE_TIME_H 1
</file>

<file path="Winmerge-Src/Src/diffutils/diffutils.vcxitems">
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Label="Globals">
    <MSBuildAllProjects Condition="'$(MSBuildVersion)' == '' Or '$(MSBuildVersion)' &lt; '16.0'">$(MSBuildAllProjects);$(MSBuildThisFileFullPath)</MSBuildAllProjects>
    <HasSharedItems>true</HasSharedItems>
    <ItemsProjectGuid>{fc3b9df3-2854-4264-ab4b-ee8c43982513}</ItemsProjectGuid>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <ClCompile>
      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(MSBuildThisFileDirectory)</AdditionalIncludeDirectories>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ProjectCapability Include="SourceItemsFromImports" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="$(MSBuildThisFileDirectory)GnuVersion.c">
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)lib\cmpbuf.c">
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)src\analyze.c">
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)src\context.c">
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)src\Diff.cpp">
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)src\ed.c">
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)src\ifdef.c">
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)src\io.c">
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)src\mystat.cpp">
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)src\normal.c">
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)src\side.c">
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)src\util.c">
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="$(MSBuildThisFileDirectory)config.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)lib\cmpbuf.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)src\diff.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)src\system.h" />
  </ItemGroup>
</Project>
</file>

<file path="Winmerge-Src/Src/diffutils/diffutils.vcxitems.filters">
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="$(MSBuildThisFileDirectory)src\analyze.c">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)lib\cmpbuf.c">
      <Filter>lib</Filter>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)src\context.c">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)src\Diff.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)src\ed.c">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)src\ifdef.c">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)src\io.c">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)src\mystat.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)src\normal.c">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)src\side.c">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)src\util.c">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)GnuVersion.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="$(MSBuildThisFileDirectory)lib\cmpbuf.h">
      <Filter>lib</Filter>
    </ClInclude>
    <ClInclude Include="$(MSBuildThisFileDirectory)src\diff.h">
      <Filter>src</Filter>
    </ClInclude>
    <ClInclude Include="$(MSBuildThisFileDirectory)src\system.h">
      <Filter>src</Filter>
    </ClInclude>
    <ClInclude Include="$(MSBuildThisFileDirectory)config.h" />
  </ItemGroup>
  <ItemGroup>
    <Filter Include="src">
      <UniqueIdentifier>{3883a169-0d29-4a08-acc5-e8c424c6263d}</UniqueIdentifier>
    </Filter>
    <Filter Include="lib">
      <UniqueIdentifier>{fd3263c0-0d17-415c-a1b2-3ccf43386a9a}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
</Project>
</file>

<file path="Winmerge-Src/Src/diffutils/GnuVersion.c">
/* Version number of GNU diff.  */

#include "config.h"

char const version_string[] = "2.5";
</file>

<file path="Winmerge-Src/Src/diffutils/lib/cmpbuf.c">
/* Buffer primitives for comparison operations.
   Copyright (C) 1993 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

#include "system.h"
#include "cmpbuf.h"

/* Least common multiple of two buffer sizes A and B.  */

size_t
buffer_lcm (size_t a, size_t b)
{
  size_t m, n, r;

  /* Yield reasonable values if buffer sizes are zero.  */
  if (!a)
    return b ? b : 8 * 1024;
  if (!b)
    return a;

  /* n = gcd (a, b) */
  for (m = a, n = b;  (r = m % n) != 0;  m = n, n = r)
    continue;

  return a/n * b;
}
</file>

<file path="Winmerge-Src/Src/diffutils/lib/cmpbuf.h">
/* Buffer primitives for comparison operations.
   Copyright (C) 1993 Free Software Foundation, Inc.

This file is part of GNU DIFF.

GNU DIFF is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GNU DIFF is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU DIFF; see the file COPYING.  If not, write to
the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

size_t buffer_lcm (size_t, size_t);

#ifdef __cplusplus
}
#endif
</file>

<file path="Winmerge-Src/Src/diffutils/src/analyze.c">
/* Analyze file differences for GNU DIFF.
   Copyright (C) 1988, 1989, 1992, 1993 Free Software Foundation, Inc.

This file is part of GNU DIFF.

GNU DIFF is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GNU DIFF is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU DIFF; see the file COPYING.  If not, write to
the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* The basic algorithm is described in:
   "An O(ND) Difference Algorithm and its Variations", Eugene Myers,
   Algorithmica Vol. 1 No. 2, 1986, pp. 251-266;
   see especially section 4.2, which describes the variation used below.

   Unless the --minimal option is specified, this code uses the TOO_EXPENSIVE
   heuristic, by Paul Eggert, to limit the cost to O(N**1.5 log N)
   at the price of producing suboptimal output for large inputs with
   many differences.  Related algorithms are surveyed by Alfred V. Aho in
   section 6.3 of 'Algorithms for Finding Patterns in Strings',
   Handbook of Theoretical Computer Science (Jan Van Leeuwen,
   ed.), Vol. A, Algorithms and Complexity, Elsevier/MIT Press,
   1990, pp. 255--300.

   The basic algorithm was independently discovered as described in:
   "Algorithms for Approximate String Matching", Esko Ukkonen,
   Information and Control Vol. 64, 1985, pp. 100-118.  
*/

#include "diff.h"
#include "cmpbuf.h"
#include <assert.h>
#ifdef _WIN32
#  include <io.h>
#endif

DECL_TLS int no_discards;
DECL_TLS int need_free_buffers=0;

static DECL_TLS int *xvec, *yvec;	/* Vectors being compared. */
static DECL_TLS int *fdiag;		/* Vector, indexed by diagonal, containing
				   1 + the X coordinate of the point furthest
				   along the given diagonal in the forward
				   search of the edit matrix. */
static DECL_TLS int *bdiag;		/* Vector, indexed by diagonal, containing
				   the X coordinate of the point furthest
				   along the given diagonal in the backward
				   search of the edit matrix. */
static DECL_TLS int too_expensive;	/* Edit scripts longer than this are too
				   expensive to compute.  */

#define SNAKE_LIMIT 20	/* Snakes bigger than this are considered `big'.  */

struct partition
{
  int xmid, ymid;	/* Midpoints of this partition.  */
  int lo_minimal;	/* Nonzero if low half will be analyzed minimally.  */
  int hi_minimal;	/* Likewise for high half.  */
};

static int diag (int, int, int, int, int, struct partition *);
static struct change *add_change (int, int, int, int, struct change *);
static struct change *build_reverse_script (struct file_data const[]);
static struct change *build_script (struct file_data const[]);
static void briefly_report (int, struct file_data const[]);
static void compareseq (int, int, int, int, int);
static void discard_confusing_lines (struct file_data[]);
static void shift_boundaries (struct file_data[]);

/* Find the midpoint of the shortest edit script for a specified
   portion of the two files.

   Scan from the beginnings of the files, and simultaneously from the ends,
   doing a breadth-first search through the space of edit-sequence.
   When the two searches meet, we have found the midpoint of the shortest
   edit sequence.

   If MINIMAL is nonzero, find the minimal edit script regardless
   of expense.  Otherwise, if the search is too expensive, use
   heuristics to stop the search and report a suboptimal answer.

   Set PART->(XMID,YMID) to the midpoint (XMID,YMID).  The diagonal number
   XMID - YMID equals the number of inserted lines minus the number
   of deleted lines (counting only lines before the midpoint).
   Return the approximate edit cost; this is the total number of
   lines inserted or deleted (counting only lines before the midpoint),
   unless a heuristic is used to terminate the search prematurely.

   Set PART->LEFT_MINIMAL to nonzero iff the minimal edit script for the
   left half of the partition is known; similarly for PART->RIGHT_MINIMAL.

   This function assumes that the first lines of the specified portions
   of the two files do not match, and likewise that the last lines do not
   match.  The caller must trim matching lines from the beginning and end
   of the portions it is going to specify.

   If we return the "wrong" partitions,
   the worst this can do is cause suboptimal diff output.
   It cannot cause incorrect diff output.  */

static int
diag (int xoff, int xlim, int yoff, int ylim, int minimal, struct partition *part)
{
  int *const fd = fdiag;	/* Give the compiler a chance. */
  int *const bd = bdiag;	/* Additional help for the compiler. */
  int const *const xv = xvec;	/* Still more help for the compiler. */
  int const *const yv = yvec;	/* And more and more . . . */
  int const dmin = xoff - ylim;	/* Minimum valid diagonal. */
  int const dmax = xlim - yoff;	/* Maximum valid diagonal. */
  int const fmid = xoff - yoff;	/* Center diagonal of top-down search. */
  int const bmid = xlim - ylim;	/* Center diagonal of bottom-up search. */
  int fmin = fmid, fmax = fmid;	/* Limits of top-down search. */
  int bmin = bmid, bmax = bmid;	/* Limits of bottom-up search. */
  int c;			/* Cost. */
  int odd = (fmid - bmid) & 1;	/* True if southeast corner is on an odd
				   diagonal with respect to the northwest. */

  fd[fmid] = xoff;
  bd[bmid] = xlim;

  for (c = 1;; ++c)
    {
      int d;			/* Active diagonal. */
      int big_snake = 0;

      /* Extend the top-down search by an edit step in each diagonal. */
      fmin > dmin ? fd[--fmin - 1] = -1 : ++fmin;
      fmax < dmax ? fd[++fmax + 1] = -1 : --fmax;
      for (d = fmax; d >= fmin; d -= 2)
	{
	  int x, y, oldx, tlo = fd[d - 1], thi = fd[d + 1];

	  if (tlo >= thi)
	    x = tlo + 1;
	  else
	    x = thi;
	  oldx = x;
	  y = x - d;
	  while (x < xlim && y < ylim && xv[x] == yv[y])
	    ++x, ++y;
	  if (x - oldx > SNAKE_LIMIT)
	    big_snake = 1;
	  fd[d] = x;
	  if (odd && bmin <= d && d <= bmax && bd[d] <= x)
	    {
	      part->xmid = x;
	      part->ymid = y;
	      part->lo_minimal = part->hi_minimal = 1;
	      return 2 * c - 1;
	    }
	}

      /* Similarly extend the bottom-up search.  */
      bmin > dmin ? bd[--bmin - 1] = INT_MAX : ++bmin;
      bmax < dmax ? bd[++bmax + 1] = INT_MAX : --bmax;
      for (d = bmax; d >= bmin; d -= 2)
	{
	  int x, y, oldx, tlo = bd[d - 1], thi = bd[d + 1];

	  if (tlo < thi)
	    x = tlo;
	  else
	    x = thi - 1;
	  oldx = x;
	  y = x - d;
	  while (x > xoff && y > yoff && xv[x - 1] == yv[y - 1])
	    --x, --y;
	  if (oldx - x > SNAKE_LIMIT)
	    big_snake = 1;
	  bd[d] = x;
	  if (!odd && fmin <= d && d <= fmax && x <= fd[d])
	    {
	      part->xmid = x;
	      part->ymid = y;
	      part->lo_minimal = part->hi_minimal = 1;
	      return 2 * c;
	    }
	}

      if (minimal)
	continue;

      /* Heuristic: check occasionally for a diagonal that has made
	 lots of progress compared with the edit distance.
	 If we have any such, find the one that has made the most
	 progress and return it as if it had succeeded.

	 With this heuristic, for files with a constant small density
	 of changes, the algorithm is linear in the file size.  */

      if (c > 200 && big_snake && heuristic)
	{
	  int best;

	  best = 0;
	  for (d = fmax; d >= fmin; d -= 2)
	    {
	      int dd = d - fmid;
	      int x = fd[d];
	      int y = x - d;
	      int v = (x - xoff) * 2 - dd;
	      if (v > 12 * (c + (dd < 0 ? -dd : dd)))
		{
		  if (v > best
		      && xoff + SNAKE_LIMIT <= x && x < xlim
		      && yoff + SNAKE_LIMIT <= y && y < ylim)
		{
		      /* We have a good enough best diagonal;
			 now insist that it end with a significant snake.  */
		      int k;

		      for (k = 1; xv[x - k] == yv[y - k]; k++)
			if (k == SNAKE_LIMIT)
			{
			    best = v;
			    part->xmid = x;
			    part->ymid = y;
			    break;
			}
		    }
		}
	    }
	  if (best > 0)
	    {
	      part->lo_minimal = 1;
	      part->hi_minimal = 0;
	      return 2 * c - 1;
	    }

	  best = 0;
	  for (d = bmax; d >= bmin; d -= 2)
	    {
	      int dd = d - bmid;
	      int x = bd[d];
	      int y = x - d;
	      int v = (xlim - x) * 2 + dd;
	      if (v > 12 * (c + (dd < 0 ? -dd : dd)))
		{
		  if (v > best
		      && xoff < x && x <= xlim - SNAKE_LIMIT
		      && yoff < y && y <= ylim - SNAKE_LIMIT)
		{
		      /* We have a good enough best diagonal;
			 now insist that it end with a significant snake.  */
		      int k;

		      for (k = 0; xv[x + k] == yv[y + k]; k++)
			if (k == SNAKE_LIMIT - 1)
			  {
			    best = v;
			    part->xmid = x;
			    part->ymid = y;
			  break;
			  }
		    }
		}
	    }
	  if (best > 0)
	    {
	      part->lo_minimal = 0;
	      part->hi_minimal = 1;
	      return 2 * c - 1;
	    }
	}

      /* Heuristic: if we've gone well beyond the call of duty,
	 give up and report halfway between our best results so far.  */
      if (c >= too_expensive)
	{
	  int fxybest, fxbest;
	  int bxybest, bxbest;

	  fxbest = bxbest = 0;  /* Pacify `gcc -Wall'.  */

	  /* Find forward diagonal that maximizes X + Y.  */
	  fxybest = -1;
	  for (d = fmax; d >= fmin; d -= 2)
	    {
	      int x = min (fd[d], xlim);
	      int y = x - d;
	      if (ylim < y)
		x = ylim + d, y = ylim;
	      if (fxybest < x + y)
			{
		  fxybest = x + y;
		  fxbest = x;
			}
		    }

	  /* Find backward diagonal that minimizes X + Y.  */
	  bxybest = INT_MAX;
	  for (d = bmax; d >= bmin; d -= 2)
	    {
	      int x = max (xoff, bd[d]);
	      int y = x - d;
	      if (y < yoff)
		x = yoff + d, y = yoff;
	      if (x + y < bxybest)
		{
		  bxybest = x + y;
		  bxbest = x;
		}
		}

	  /* Use the better of the two diagonals.  */
	  if ((xlim + ylim) - bxybest < fxybest - (xoff + yoff))
	    {
	      part->xmid = fxbest;
	      part->ymid = fxybest - fxbest;
	      part->lo_minimal = 1;
	      part->hi_minimal = 0;
	    }
	  else
	    {
	      part->xmid = bxbest;
	      part->ymid = bxybest - bxbest;
	      part->lo_minimal = 0;
	      part->hi_minimal = 1;
	    }
	  return 2 * c - 1;
	}
    }
}

/* Compare in detail contiguous subsequences of the two files
   which are known, as a whole, to match each other.

   The results are recorded in the vectors files[N].changed_flag, by
   storing a 1 in the element for each line that is an insertion or deletion.

   The subsequence of file 0 is [XOFF, XLIM) and likewise for file 1.

   Note that XLIM, YLIM are exclusive bounds.
   All line numbers are origin-0 and discarded lines are not counted.

   If MINIMAL is nonzero, find a minimal difference no matter how
   expensive it is.  */

static void
compareseq (int xoff, int xlim, int yoff, int ylim, int minimal)
{
  int * const xv = xvec; /* Help the compiler.  */
  int * const yv = yvec;

  /* Slide down the bottom initial diagonal. */
  while (xoff < xlim && yoff < ylim && xv[xoff] == yv[yoff])
    ++xoff, ++yoff;
  /* Slide up the top initial diagonal. */
  while (xlim > xoff && ylim > yoff && xv[xlim - 1] == yv[ylim - 1])
    --xlim, --ylim;

  /* Handle simple cases. */
  if (xoff == xlim)
    while (yoff < ylim)
      files[1].changed_flag[files[1].realindexes[yoff++]] = 1;
  else if (yoff == ylim)
    while (xoff < xlim)
      files[0].changed_flag[files[0].realindexes[xoff++]] = 1;
  else
    {
      int c;
      struct partition part;

      /* Find a point of correspondence in the middle of the files.  */

      c = diag (xoff, xlim, yoff, ylim, minimal, &part);

      if (c == 1)
	{
	  /* This should be impossible, because it implies that
	     one of the two subsequences is empty,
	     and that case was handled above without calling `diag'.
	     Let's verify that this is true.  */
	  abort ();
#if 0
	  /* The two subsequences differ by a single insert or delete;
	     record it and we are done.  */
	  if (part.xmid - part.ymid < xoff - yoff)
	    files[1].changed_flag[files[1].realindexes[part.ymid - 1]] = 1;
	  else
	    files[0].changed_flag[files[0].realindexes[part.xmid]] = 1;
#endif
	}
      else
	{
	  /* Use the partitions to split this problem into subproblems.  */
	  compareseq (xoff, part.xmid, yoff, part.ymid, part.lo_minimal);
	  compareseq (part.xmid, xlim, part.ymid, ylim, part.hi_minimal);
	}
    }
}

/* Discard lines from one file that have no matches in the other file.

   A line which is discarded will not be considered by the actual
   comparison algorithm; it will be as if that line were not in the file.
   The file's `realindexes' table maps virtual line numbers
   (which don't count the discarded lines) into real line numbers;
   this is how the actual comparison algorithm produces results
   that are comprehensible when the discarded lines are counted.

   When we discard a line, we also mark it as a deletion or insertion
   so that it will be printed in the output.  */

static void
discard_confusing_lines (struct file_data filevec[])
{
  unsigned int f, i;
  char *discarded[2];
  int *equiv_count[2];
  int *p;

  /* Allocate our results.  */
  p = (int *) xmalloc ((filevec[0].buffered_lines + filevec[1].buffered_lines)
		       * (2 * sizeof (int)));
  for (f = 0; f < 2; f++)
    {
      filevec[f].undiscarded = p;  p += filevec[f].buffered_lines;
      filevec[f].realindexes = p;  p += filevec[f].buffered_lines;
    }

  /* Set up equiv_count[F][I] as the number of lines in file F
     that fall in equivalence class I.  */

  p = (int *) xmalloc (filevec[0].equiv_max * (2 * sizeof (int)));
  equiv_count[0] = p;
  equiv_count[1] = p + filevec[0].equiv_max;
  bzero (p, filevec[0].equiv_max * (2 * sizeof (int)));

  for (i = 0; i < (unsigned int)filevec[0].buffered_lines; ++i)
    ++equiv_count[0][filevec[0].equivs[i]];
  for (i = 0; i < (unsigned int)filevec[1].buffered_lines; ++i)
    ++equiv_count[1][filevec[1].equivs[i]];

  /* Set up tables of which lines are going to be discarded.  */

  discarded[0] = xmalloc (sizeof (char)
			  * (filevec[0].buffered_lines
			     + filevec[1].buffered_lines));
  discarded[1] = discarded[0] + filevec[0].buffered_lines;
  bzero (discarded[0], sizeof (char) * (filevec[0].buffered_lines
					+ filevec[1].buffered_lines));

  /* Mark to be discarded each line that matches no line of the other file.
     If a line matches many lines, mark it as provisionally discardable.  */

  for (f = 0; f < 2; f++)
    {
      unsigned int end = filevec[f].buffered_lines;
      char *discards = discarded[f];
      int *counts = equiv_count[1 - f];
      int *equivs = filevec[f].equivs;
      unsigned int many = 5;
      unsigned int tem = end / 64;

      /* Multiply MANY by approximate square root of number of lines.
	 That is the threshold for provisionally discardable lines.  */
      while ((tem = tem >> 2) > 0)
	many *= 2;

      for (i = 0; i < end; i++)
	{
	  int nmatch;
	  if (equivs[i] == 0)
	    continue;
	  nmatch = counts[equivs[i]];
	  if (nmatch == 0)
	    discards[i] = 1;
	  else if (nmatch > (int)many)
	    discards[i] = 2;
	}
    }

  /* Don't really discard the provisional lines except when they occur
     in a run of discardables, with nonprovisionals at the beginning
     and end.  */

  for (f = 0; f < 2; f++)
    {
      unsigned int end = filevec[f].buffered_lines;
      register char *discards = discarded[f];

      for (i = 0; i < end; i++)
	{
	  /* Cancel provisional discards not in middle of run of discards.  */
	  if (discards[i] == 2)
	    discards[i] = 0;
	  else if (discards[i] != 0)
	    {
	      /* We have found a nonprovisional discard.  */
	      register int j;
	      unsigned int length;
	      unsigned int provisional = 0;

	      /* Find end of this run of discardable lines.
		 Count how many are provisionally discardable.  */
	      for (j = (int)i; (unsigned int)j < end; j++)
		{
		  if (discards[j] == 0)
		    break;
		  if (discards[j] == 2)
		    ++provisional;
		}

	      /* Cancel provisional discards at end, and shrink the run.  */
	      while (j > (int)i && discards[j - 1] == 2)
		discards[--j] = 0, --provisional;

	      /* Now we have the length of a run of discardable lines
		 whose first and last are not provisional.  */
	      length = j - i;

	      /* If 1/4 of the lines in the run are provisional,
		 cancel discarding of all provisional lines in the run.  */
	      if (provisional * 4 > length)
		{
		  while (j > (int)i)
		    if (discards[--j] == 2)
		      discards[j] = 0;
		}
	      else
		{
		  register unsigned int consec;
		  unsigned int minimum = 1;
		  unsigned int tem = length / 4;

		  /* MINIMUM is approximate square root of LENGTH/4.
		     A subrun of two or more provisionals can stand
		     when LENGTH is at least 16.
		     A subrun of 4 or more can stand when LENGTH >= 64.  */
		  while ((tem = tem >> 2) > 0)
		    minimum *= 2;
		  minimum++;

		  /* Cancel any subrun of MINIMUM or more provisionals
		     within the larger run.  */
		  for (j = 0, consec = 0; (unsigned int)j < length; j++)
		    if (discards[i + j] != 2)
		      consec = 0;
		    else if (minimum == ++consec)
		      /* Back up to start of subrun, to cancel it all.  */
		      j -= consec;
		    else if (minimum < consec)
		      discards[i + j] = 0;

		  /* Scan from beginning of run
		     until we find 3 or more nonprovisionals in a row
		     or until the first nonprovisional at least 8 lines in.
		     Until that point, cancel any provisionals.  */
		  for (j = 0, consec = 0; (unsigned int)j < length; j++)
		    {
		      if (j >= 8 && discards[i + j] == 1)
			break;
		      if (discards[i + j] == 2)
			consec = 0, discards[i + j] = 0;
		      else if (discards[i + j] == 0)
			consec = 0;
		      else
			consec++;
		      if (consec == 3)
			break;
		    }

		  /* I advances to the last line of the run.  */
		  i += length - 1;

		  /* Same thing, from end.  */
		  for (j = 0, consec = 0; (unsigned int)j < length; j++)
		    {
		      if (j >= 8 && discards[i - j] == 1)
			break;
		      if (discards[i - j] == 2)
			consec = 0, discards[i - j] = 0;
		      else if (discards[i - j] == 0)
			consec = 0;
		      else
			consec++;
		      if (consec == 3)
			break;
		    }
		}
	    }
	}
    }

  /* Actually discard the lines. */
  for (f = 0; f < 2; f++)
    {
      char *discards = discarded[f];
      unsigned int end = filevec[f].buffered_lines;
      unsigned int j = 0;
      for (i = 0; i < end; ++i)
	if (no_discards || discards[i] == 0)
	  {
	    filevec[f].undiscarded[j] = filevec[f].equivs[i];
	    filevec[f].realindexes[j++] = i;
	  }
	else
	  filevec[f].changed_flag[i] = 1;
      filevec[f].nondiscarded_lines = j;
    }

  free (discarded[0]);
  free (equiv_count[0]);
}

/* Adjust inserts/deletes of identical lines to join changes
   as much as possible.

   We do something when a run of changed lines include a
   line at one end and have an excluded, identical line at the other.
   We are free to choose which identical line is included.
   `compareseq' usually chooses the one at the beginning,
   but usually it is cleaner to consider the following identical line
   to be the "change".  */

DECL_TLS int inhibit;

static void
shift_boundaries (struct file_data filevec[])
{
  int f;

  if (inhibit)
    return;

  for (f = 0; f < 2; f++)
    {
      char *changed = filevec[f].changed_flag;
      char const *other_changed = filevec[1-f].changed_flag;
      int const *equivs = filevec[f].equivs;
      int i = 0;
      int j = 0;
      int i_end = filevec[f].buffered_lines;

      while (1)
	{
	  int runlength, start, corresponding;

	  /* Scan forwards to find beginning of another run of changes.
	     Also keep track of the corresponding point in the other file.  */

	  while (i < i_end && changed[i] == 0)
	    {
	      while (other_changed[j++])
		continue;
	      i++;
	    }

	  if (i == i_end)
	    break;

	  start = i;

	  /* Find the end of this run of changes.  */

	  while (changed[++i])
	    continue;
	  while (other_changed[j])
	    j++;

	  do
	    {
	      /* Record the length of this run of changes, so that
		 we can later determine whether the run has grown.  */
	      runlength = i - start;

	      /* Move the changed region back, so long as the
		 previous unchanged line matches the last changed one.
		 This merges with previous changed regions.  */

	      while (start && equivs[start - 1] == equivs[i - 1])
		{
		  changed[--start] = 1;
		  changed[--i] = 0;
		  while (changed[start - 1])
		    start--;
		  while (other_changed[--j])
		    continue;
		}

	      /* Set CORRESPONDING to the end of the changed run, at the last
		 point where it corresponds to a changed run in the other file.
		 CORRESPONDING == I_END means no such point has been found.  */
	      corresponding = other_changed[j - 1] ? i : i_end;

	      /* Move the changed region forward, so long as the
		 first changed line matches the following unchanged one.
		 This merges with following changed regions.
		 Do this second, so that if there are no merges,
		 the changed region is moved forward as far as possible.  */

	      while (i != i_end && equivs[start] == equivs[i])
		{
		  changed[start++] = 0;
		  changed[i++] = 1;
		  while (changed[i])
		    i++;
		  while (other_changed[++j])
		    corresponding = i;
		}
	    }
	  while (runlength != i - start);

	  /* If possible, move the fully-merged run of changes
	     back to a corresponding run in the other file.  */

	  while (corresponding < i)
	    {
	      changed[--start] = 1;
	      changed[--i] = 0;
	      while (other_changed[--j])
		continue;
	}
    }
}
}

/* Cons an additional entry onto the front of an edit script OLD.
   LINE0 and LINE1 are the first affected lines in the two files (origin 0).
   DELETED is the number of lines deleted here from file 0.
   INSERTED is the number of lines inserted here in file 1.

   If DELETED is 0 then LINE0 is the number of the line before
   which the insertion was done; vice versa for INSERTED and LINE1.  */

static struct change *
add_change (int line0, int line1, int deleted, int inserted, struct change *old)
{
  struct change *newob = (struct change *) xmalloc (sizeof (struct change));
  memset(newob, 0, sizeof(*newob));

  newob->line0 = line0;
  newob->line1 = line1;
  newob->inserted = inserted;
  newob->deleted = deleted;
  newob->link = old;
  newob->match0 = -1; /* WinMerge moved block code */
  newob->match1 = -1; /* WinMerge moved block code */
  return newob;
}

/* Scan the tables of which lines are inserted and deleted,
   producing an edit script in reverse order.  */

static struct change *
build_reverse_script (struct file_data const filevec[])
{
  struct change *script = NULL;
  char *changed0 = filevec[0].changed_flag;
  char *changed1 = filevec[1].changed_flag;
  int len0 = filevec[0].buffered_lines;
  int len1 = filevec[1].buffered_lines;

  /* Note that changedN[len0] does exist, and contains 0.  */

  int i0 = 0, i1 = 0;

  while (i0 < len0 || i1 < len1)
    {
      if (changed0[i0] || changed1[i1])
	{
	  int line0 = i0, line1 = i1;

	  /* Find # lines changed here in each file.  */
	  while (changed0[i0]) ++i0;
	  while (changed1[i1]) ++i1;

	  /* Record this change.  */
	  script = add_change (line0, line1, i0 - line0, i1 - line1, script);
	}

      /* We have reached lines in the two files that match each other.  */
      i0++, i1++;
    }

  return script;
}

/* Scan the tables of which lines are inserted and deleted,
   producing an edit script in forward order.  */

static struct change *
build_script (struct file_data const filevec[])
{
  struct change *script = NULL;
  char *changed0 = filevec[0].changed_flag;
  char *changed1 = filevec[1].changed_flag;
  int i0 = filevec[0].buffered_lines, i1 = filevec[1].buffered_lines;

  /* Note that changedN[-1] does exist, and contains 0.  */

  while (i0 >= 0 || i1 >= 0)
    {
      if (changed0[i0 - 1] || changed1[i1 - 1])
	{
	  int line0 = i0, line1 = i1;

	  /* Find # lines changed here in each file.  */
	  while (changed0[i0 - 1]) --i0;
	  while (changed1[i1 - 1]) --i1;

	  /* Record this change.  */
	  script = add_change (i0, i1, line0 - i0, line1 - i1, script);
	}

      /* We have reached lines in the two files that match each other.  */
      i0--, i1--;
    }

  return script;
}

/* If CHANGES, briefly report that two files differed.  */
static void
briefly_report (int changes, struct file_data const filevec[])
{
  if (changes)
    message (no_details_flag ? "Files %s and %s differ\n"
	     : "Binary files %s and %s differ\n",
	     filevec[0].name, filevec[1].name);
}

//  Report the differences of two files.  DEPTH is the current directory
// depth. 
// WinMerge: add bMoved_blocks_flag for detecting moved blocks and
// bin_file for getting info which file is binary file (can be NULL)
// Winmerge: assume S_ISREG() files, not pipes, directories or devices
struct change * diff_2_files (struct file_data filevec[], int depth, int * bin_status,
	int bMoved_blocks_flag, int * bin_file)
{
	int diags;
	int i;
	struct change *script=NULL;
	int changes;
	
	
	//  If we have detected that either file is binary,
	// compare the two files as binary.  This can happen
	// only when the first chunk is read.
	// Also, --brief without any --ignore-* options means
	// we can speed things up by treating the files as binary.  
	if (read_files (filevec, no_details_flag & ~ignore_some_changes, bin_file))
	{
		//  We can now safely assume to have a pair of Binary files.

		// Are both files Open and Regular (no Pipes, Directories, Devices (e.g. NUL))
		if (filevec[0].desc < 0 || filevec[1].desc < 0 ||
			!(S_ISREG (filevec[0].stat.st_mode)) || !(S_ISREG (filevec[1].stat.st_mode))   )
			changes = 1;
		else
		//  Files with different lengths must be different.  
		if (filevec[0].stat.st_size != filevec[1].stat.st_size)
			changes = 1;
		else
		//  Identical descriptor implies identical files
		if (filevec[0].desc == filevec[1].desc)
			changes = 0;
		//  Scan both files, a buffer at a time, looking for a difference.  
		else
		{
			//  Same-sized buffers for both files were allocated in read_files().  
			size_t buffer_size = filevec[0].bufsize;
			
			for (;;)
			{
				//  Read a buffer's worth from both files.  
				for (i = 0; i < 2; i++)
					while (filevec[i].buffered_chars < buffer_size)
					  {
						int r = _read (filevec[i].desc,
									   filevec[i].buffer	+ filevec[i].buffered_chars,
									   (int)(buffer_size - filevec[i].buffered_chars));
						if (r == 0)
							break;
						if (r < 0)
							pfatal_with_name (filevec[i].name);
						filevec[i].buffered_chars += r;
					  }
						
				//  If the buffers have different number of chars, the files differ.  
				if (filevec[0].buffered_chars != filevec[1].buffered_chars)
				{
					changes = 1;
					break;
				}

				//  If we reach end-of-file, the files are the same.  
				if (filevec[0].buffered_chars==0) // therefore: filevec[1].buffered_chars==0
				{
					changes = 0;
					break;
				}	

				//	If buffers have different contents, the files are different.
				if (memcmp (filevec[0].buffer,
							filevec[1].buffer,
							filevec[0].buffered_chars) != 0)
				{
					changes = 1;
					break;
				}

				//	Files appear identical so far...
				//	Prepare to loop again for the next pair of buffers.
				filevec[0].buffered_chars = filevec[1].buffered_chars = 0;
			}
		}
		
		briefly_report (changes, filevec);

		if (bin_status != NULL)
			*bin_status = (changes != 0 ? -1 : 1);
	}
	else
	{
		//  Allocate vectors for the results of comparison:
		// a flag for each line of each file, saying whether that line
		// is an insertion or deletion.
		// Allocate an extra element, always zero, at each end of each vector.  
		
		size_t s = filevec[0].buffered_lines + filevec[1].buffered_lines + 4;
		filevec[0].changed_flag = (char *)xmalloc (s);
		bzero (filevec[0].changed_flag, s);
		filevec[0].changed_flag++;
		filevec[1].changed_flag = filevec[0].changed_flag
			+ filevec[0].buffered_lines + 2;
		
		//  Some lines are obviously insertions or deletions
		// because they don't match anything.  Detect them now, and
		// avoid even thinking about them in the main comparison algorithm.  
		
		discard_confusing_lines (filevec);
		
		//  Now do the main comparison algorithm, considering just the
		// undiscarded lines.  
		
		xvec = filevec[0].undiscarded;
		yvec = filevec[1].undiscarded;
		diags = filevec[0].nondiscarded_lines + filevec[1].nondiscarded_lines + 3;
		fdiag = (int *) xmalloc (diags * (2 * sizeof (int)));
		bdiag = fdiag + diags;
		fdiag += filevec[1].nondiscarded_lines + 1;
		bdiag += filevec[1].nondiscarded_lines + 1;
		
      /* Set TOO_EXPENSIVE to be approximate square root of input size,
	     bounded below by 4096.  4096 seems to be good for circa-2016 CPUs 
	  */
        too_expensive = 1;
        for (i = filevec[0].nondiscarded_lines + filevec[1].nondiscarded_lines;
	         i != 0; i >>= 2)
		  too_expensive <<= 1;
        too_expensive = max (4096, too_expensive);

		files[0] = filevec[0];
		files[1] = filevec[1];
		
		compareseq (0, filevec[0].nondiscarded_lines,
		  0, filevec[1].nondiscarded_lines, no_discards);
		
		free (fdiag - (filevec[1].nondiscarded_lines + 1));
		
		//  Modify the results slightly to make them prettier
		// in cases where that can validly be done.  
		
		shift_boundaries (filevec);
		
		//  Get the results of comparison in the form of a chain
		// of `struct change's -- an edit script.  
		
#if 0
		if (output_style == OUTPUT_ED)
			script = build_reverse_script (filevec);
		else
#endif
			script = build_script (filevec);
		
		//  Set CHANGES if we had any diffs.
		// If some changes are ignored, we must scan the script to decide.  
		if (ignore_blank_lines_flag)
		{
			struct change *next = script;
			changes = 0;
			
			while (next)
			{
				struct change *thisob, *end;
				int first0, last0, first1, last1, deletes, inserts;
				
				//  Find a set of changes that belong together.  
				thisob = next;
				end = find_change (next);
				
				//  Disconnect them from the rest of the changes, making them
				// a hunk, and remember the rest for next iteration.  
				next = end->link;
				end->link = NULL;
				
				//  Determine whether thisob hunk is really a difference.  
				analyze_hunk (thisob, &first0, &last0, &first1, &last1,
					&deletes, &inserts, files);
				
				//  Reconnect the script so it will all be freed properly.  
				end->link = next;
				
				if (deletes || inserts)
					changes = 1;

			}
		}
		else
		{
			changes = (script != NULL);
		}

		/* WinMerge moved block support */
		if (bMoved_blocks_flag)
		{
			moved_block_analysis(&script, filevec);
		}
		
		if (no_details_flag)
			briefly_report (changes, filevec);
		else
		{
			if (changes==0 && ignore_blank_lines_flag)
			{
				// determined that there were no nontrivial changes after considering flags
			}
			else if (changes == 0)
			{
				// determined that there were no nontrivial changes after considering flags
			}
			else if (changes || ! no_diff_means_no_output)
			{
				//  Record info for starting up output,
				// to be used if and when we have some output to print.  
				setup_output (files[0].name, files[1].name, depth);
				
				/*switch (output_style)
				{
				case OUTPUT_CONTEXT:
					print_context_script (script, 0);
					break;
					
				case OUTPUT_UNIFIED:
					print_context_script (script, 1);
					break;
					
				case OUTPUT_ED:
					print_ed_script (script);
					break;
					
				case OUTPUT_FORWARD_ED:
					pr_forward_ed_script (script);
					break;
					
				case OUTPUT_RCS:
					print_rcs_script (script);
					break;
					
				case OUTPUT_NORMAL:
					print_normal_script (script);
					break;
					
				case OUTPUT_IFDEF:
					print_ifdef_script (script);
					break;
					
				case OUTPUT_SDIFF:
					print_sdiff_script (script);
				}
				
				finish_output ();*/
			}
		}
		
		//free (filevec[0].undiscarded);
		
		//free (filevec[0].changed_flag - 1);
		
		//for (i = 1; i >= 0; --i)
		//	free (filevec[i].equivs);
		
		//for (i = 0; i < 2; ++i)
		//	free (filevec[i].linbuf + filevec[i].linbuf_base);
		
		
		/*cleanup the script
		for (e = script; e; e = p)
		{
			p = e->link;
			free (e);
		}*/
		
		if (! ROBUST_OUTPUT_STYLE (output_style))
			for (i = 0; i < 2; ++i)
				if (filevec[i].missing_newline)
				{
					error ("No newline at end of file %s", filevec[i].name, "");
					changes = 2;
				}
    }
	
	//if (filevec[0].buffer != filevec[1].buffer)
	//	free (filevec[0].buffer);
	//free (filevec[1].buffer);
	
	return script;
}

void cleanup_file_buffers(struct file_data fd[])
{
	int i;
	free (fd[0].undiscarded);
	
	if (fd[0].changed_flag != NULL)
		free (fd[0].changed_flag - 1);
	
	for (i = 1; i >= 0; --i)
		free (fd[i].equivs);
	
	for (i = 0; i < 2; ++i)
		free ((void *)(fd[i].linbuf + fd[i].linbuf_base));

	if (fd[0].buffer != fd[1].buffer)
		free (fd[0].buffer);
	free (fd[1].buffer);
}
</file>

<file path="Winmerge-Src/Src/diffutils/src/context.c">
/* Context-format output routines for GNU DIFF.
   Copyright (C) 1988, 89, 91, 92, 93 Free Software Foundation, Inc.

This file is part of GNU DIFF.

GNU DIFF is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GNU DIFF is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU DIFF; see the file COPYING.  If not, write to
the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */

#include "diff.h"

static struct change *find_hunk (struct change *);
static void find_function (struct file_data const *, int, char const HUGE **, size_t *);
static void mark_ignorable (struct change *);
static void pr_context_hunk (struct change *);
static void pr_unidiff_hunk (struct change *);
static void print_context_label (char const *, struct file_data *, char const *);
static void print_context_number_range (struct file_data const *, int, int);
static void print_unidiff_number_range (struct file_data const *, int, int);

/* Last place find_function started searching from.  */
static DECL_TLS int find_function_last_search;

/* The value find_function returned when it started searching there.  */
static DECL_TLS int find_function_last_match;

/* Print a label for a context diff, with a file name and date or a label.  */

static void
print_context_label(char const *mark, struct file_data *inf, char const *label)
{
  if (label)
    fprintf (outfile, "%s %s\n", mark, label);
  else
	{
    /* See Posix.2 section 4.17.6.1.4 for this format.  */
	char ctimeBuffer[26];
	ctime_s(ctimeBuffer, sizeof(ctimeBuffer), &inf->stat.st_mtime);
    fprintf (outfile, "%s %s\t%s", mark, inf->name, ctimeBuffer);
	}
}

/* Print a header for a context diff, with the file names and dates.  */

void
print_context_header(struct file_data inf[], int unidiff_flag)
{
  if (unidiff_flag)
    {
      print_context_label ("---", &inf[0], file_label[0]);
      print_context_label ("+++", &inf[1], file_label[1]);
    }
  else
    {
      print_context_label ("***", &inf[0], file_label[0]);
      print_context_label ("---", &inf[1], file_label[1]);
    }
}

/* Print an edit script in context format.  */

void
print_context_script (struct change *script, int unidiff_flag)
{
  if (ignore_blank_lines_flag)
    mark_ignorable (script);
  else
    {
      struct change *e;
      for (e = script; e != NULL; e = e->link)
	e->ignore = 0;
    }

  find_function_last_search = - files[0].prefix_lines;
  find_function_last_match = find_function_last_search - 1;

  if (unidiff_flag)
    print_script (script, find_hunk, pr_unidiff_hunk);
  else
    print_script (script, find_hunk, pr_context_hunk);
}

/* Print a pair of line numbers with a comma, translated for file FILE.
   If the second number is not greater, use the first in place of it.

   Args A and B are internal line numbers.
   We print the translated (real) line numbers.  */

static void
print_context_number_range (struct file_data const *file, int a, int b)
{
  int trans_a, trans_b;
  translate_range (file, a, b, &trans_a, &trans_b);

  /* Note: we can have B < A in the case of a range of no lines.
     In this case, we should print the line number before the range,
     which is B.  */
  if (trans_b > trans_a)
    fprintf (outfile, "%d,%d", trans_a, trans_b);
  else
    fprintf (outfile, "%d", trans_b);
}

/* Print a portion of an edit script in context format.
   HUNK is the beginning of the portion to be printed.
   The end is marked by a `link' that has been nulled out.

   Prints out lines from both files, and precedes each
   line with the appropriate flag-character.  */

static void
pr_context_hunk (struct change *hunk)
{
  int first0, last0, first1, last1, show_from, show_to, i;
  struct change *next;
  char const *prefix;
  char const HUGE *function;
  size_t function_length=0;
  FILE *out;

  /* Determine range of line numbers involved in each file.  */

  analyze_hunk (hunk, &first0, &last0, &first1, &last1, &show_from, &show_to, files);

  if (!show_from && !show_to)
    return;

  /* Include a context's width before and after.  */

  i = - files[0].prefix_lines;
  first0 = max (first0 - context, i);
  first1 = max (first1 - context, i);
  last0 = min (last0 + context, files[0].valid_lines - 1);
  last1 = min (last1 + context, files[1].valid_lines - 1);

  /* If desired, find the preceding function definition line in file 0.  */
  function = NULL;

  begin_output ();
  out = outfile;

  /* If we looked for and found a function this is part of,
     include its name in the header of the diff section.  */
  fprintf (out, "***************");

  if (function != NULL)
    {
      fprintf (out, " ");
      fwrite (function, 1, min (function_length - 1, 40), out);
    }

  fprintf (out, "\n*** ");
  print_context_number_range (&files[0], first0, last0);
  fprintf (out, " ****\n");

  if (show_from)
    {
      next = hunk;

      for (i = first0; i <= last0; i++)
	{
	  /* Skip past changes that apply (in file 0)
	     only to lines before line I.  */

	  while (next && next->line0 + next->deleted <= i)
	    next = next->link;

	  /* Compute the marking for line I.  */

	  prefix = " ";
	  if (next && next->line0 <= i)
	    /* The change NEXT covers this line.
	       If lines were inserted here in file 1, this is "changed".
	       Otherwise it is "deleted".  */
	    prefix = (next->inserted > 0 ? "!" : "-");

	  print_1_line (prefix, &files[0].linbuf[i]);
	}
    }

  fprintf (out, "--- ");
  print_context_number_range (&files[1], first1, last1);
  fprintf (out, " ----\n");

  if (show_to)
    {
      next = hunk;

      for (i = first1; i <= last1; i++)
	{
	  /* Skip past changes that apply (in file 1)
	     only to lines before line I.  */

	  while (next && next->line1 + next->inserted <= i)
	    next = next->link;

	  /* Compute the marking for line I.  */

	  prefix = " ";
	  if (next && next->line1 <= i)
	    /* The change NEXT covers this line.
	       If lines were deleted here in file 0, this is "changed".
	       Otherwise it is "inserted".  */
	    prefix = (next->deleted > 0 ? "!" : "+");

	  print_1_line (prefix, &files[1].linbuf[i]);
	}
    }
}

/* Print a pair of line numbers with a comma, translated for file FILE.
   If the second number is smaller, use the first in place of it.
   If the numbers are equal, print just one number.

   Args A and B are internal line numbers.
   We print the translated (real) line numbers.  */

static void
print_unidiff_number_range (struct file_data const *file, int a, int b)
{
  int trans_a, trans_b;
  translate_range (file, a, b, &trans_a, &trans_b);

  /* Note: we can have B < A in the case of a range of no lines.
     In this case, we should print the line number before the range,
     which is B.  */
  if (trans_b <= trans_a)
    fprintf (outfile, trans_b == trans_a ? "%d" : "%d,0", trans_b);
  else
    fprintf (outfile, "%d,%d", trans_a, trans_b - trans_a + 1);
}

/* Print a portion of an edit script in unidiff format.
   HUNK is the beginning of the portion to be printed.
   The end is marked by a `link' that has been nulled out.

   Prints out lines from both files, and precedes each
   line with the appropriate flag-character.  */

static void
pr_unidiff_hunk (struct change *hunk)
{
  int first0, last0, first1, last1, show_from, show_to, i, j, k;
  struct change *next;
  char const HUGE *function;
  size_t function_length=0;
  FILE *out;

  /* Determine range of line numbers involved in each file.  */

  analyze_hunk (hunk, &first0, &last0, &first1, &last1, &show_from, &show_to, files);

  if (!show_from && !show_to)
    return;

  /* Include a context's width before and after.  */

  i = - files[0].prefix_lines;
  first0 = max (first0 - context, i);
  first1 = max (first1 - context, i);
  last0 = min (last0 + context, files[0].valid_lines - 1);
  last1 = min (last1 + context, files[1].valid_lines - 1);

  /* If desired, find the preceding function definition line in file 0.  */
  function = NULL;

  begin_output ();
  out = outfile;

  fprintf (out, "@@ -");
  print_unidiff_number_range (&files[0], first0, last0);
  fprintf (out, " +");
  print_unidiff_number_range (&files[1], first1, last1);
  fprintf (out, " @@");

  /* If we looked for and found a function this is part of,
     include its name in the header of the diff section.  */

  if (function != NULL)
    {
      putc (' ', out);
      fwrite (function, 1, min (function_length - 1, 40), out);
    }
  putc ('\n', out);

  next = hunk;
  i = first0;
  j = first1;

  while (i <= last0 || j <= last1)
    {

      /* If the line isn't a difference, output the context from file 0. */

      if (!next || i < next->line0)
	{
	  putc (tab_align_flag ? '\t' : ' ', out);
	  print_1_line (0, &files[0].linbuf[i++]);
	  j++;
	}
      else
	{
	  /* For each difference, first output the deleted part. */

	  k = next->deleted;
	  while (k--)
	    {
	      putc ('-', out);
	      if (tab_align_flag)
		putc ('\t', out);
	      print_1_line (0, &files[0].linbuf[i++]);
	    }

	  /* Then output the inserted part. */

	  k = next->inserted;
	  while (k--)
	    {
	      putc ('+', out);
	      if (tab_align_flag)
		putc ('\t', out);
	      print_1_line (0, &files[1].linbuf[j++]);
	    }

	  /* We're done with this hunk, so on to the next! */

	  next = next->link;
	}
    }
}

/* Scan a (forward-ordered) edit script for the first place that more than
   2*CONTEXT unchanged lines appear, and return a pointer
   to the `struct change' for the last change before those lines.  */

static struct change *
find_hunk (struct change *start)
{
  struct change *prev;
  int top0, top1;
  int thresh;

  do
    {
      /* Compute number of first line in each file beyond this changed.  */
      top0 = start->line0 + start->deleted;
      top1 = start->line1 + start->inserted;
      prev = start;
      start = start->link;
      /* Threshold distance is 2*CONTEXT between two non-ignorable changes,
	 but only CONTEXT if one is ignorable.  */
      thresh = ((prev->ignore || (start && start->ignore))
		? context
		: 2 * context + 1);
      /* It is not supposed to matter which file we check in the end-test.
	 If it would matter, crash.  */
      if (start && start->line0 - top0 != start->line1 - top1)
	abort ();
    } while (start
	     /* Keep going if less than THRESH lines
		elapse before the affected line.  */
	     && start->line0 < top0 + thresh);

  return prev;
}

/* Set the `ignore' flag properly in each change in SCRIPT.
   It should be 1 if all the lines inserted or deleted in that change
   are ignorable lines.  */

static void
mark_ignorable (struct change *script)
{
  while (script)
    {
      struct change *next = script->link;
      int first0, last0, first1, last1, deletes, inserts;

      /* Turn this change into a hunk: detach it from the others.  */
      script->link = NULL;

      /* Determine whether this change is ignorable.  */
      analyze_hunk (script, &first0, &last0, &first1, &last1, &deletes, &inserts, files);
      /* Reconnect the chain as before.  */
      script->link = next;

      /* If the change is ignorable, mark it.  */
      script->ignore = (char)(!deletes && !inserts);

      /* Advance to the following change.  */
      script = next;
    }
}

</file>

<file path="Winmerge-Src/Src/diffutils/src/Diff.cpp">
/////////////////////////////////////////////////////////////////////////////
//    WinMerge:  an interactive diff/merge utility
//    Copyright (C) 1997-2000  Thingamahoochie Software
//    Author: Dean Grimm

/* GNU DIFF main routine.
   Copyright (C) 1988, 1989, 1992, 1993 Free Software Foundation, Inc.

This file is part of GNU DIFF.

GNU DIFF is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GNU DIFF is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU DIFF; see the file COPYING.  If not, write to
the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* GNU DIFF was written by Mike Haertel, David Hayes,
   Richard Stallman, Len Tower, and Paul Eggert.  */

#include "pch.h"
#define GDIFF_MAIN
#include "diff.h" 
#include "io.h"
#include "diffwrapper.h"


/* Nonzero for -r: if comparing two directories,
   compare their common subdirectories recursively.  */

DECL_TLS int recursive;

</file>

<file path="Winmerge-Src/Src/diffutils/src/diff.h">
/* Shared definitions for GNU DIFF
   Copyright (C) 1988, 89, 91, 92, 93 Free Software Foundation, Inc.

This file is part of GNU DIFF.

GNU DIFF is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GNU DIFF is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU DIFF; see the file COPYING.  If not, write to
the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */

#pragma once

#include "system.h"
#include <ctype.h>
#include <stdio.h>

#ifdef NOMINMAX
#undef min
#undef max
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifndef PR_FILE_NAME
#if defined(__MSDOS__) || defined(__NT__) || defined(WIN32)
#define PR_FILE_NAME "pr"
#else
#define PR_FILE_NAME "/bin/pr"
#endif
#endif

#ifdef _MSC_VER
#define DECL_TLS __declspec(thread)
#else
#define DECL_TLS __thread
#endif

#define TAB_WIDTH 8

/* Variables for command line options */

#ifndef GDIFF_MAIN
#define EXTERN extern DECL_TLS 
#else
#define EXTERN DECL_TLS
#endif

enum output_style {
	
  // NOTE: these values are stored in the user's Registry - don't change their value !!
  //   (see enum DiffOutputType in Src/CompareOptions.h)
  /* Default output style.  */
  OUTPUT_NORMAL = 0,
  /* Output the differences with lines of context before and after (-c).  */
  OUTPUT_CONTEXT = 1,
  /* Output the differences in a unified context diff format (-u). */
  OUTPUT_UNIFIED = 2,
  /* Output the differences as commands suitable for `ed' (-e).  */
#if 0
  OUTPUT_ED = 3,
  /* Output the diff as a forward ed script (-f).  */
  OUTPUT_FORWARD_ED = 4,
  /* Like -f, but output a count of changed lines in each "command" (-n). */
  OUTPUT_RCS = 5,
  /* Output merged #ifdef'd file (-D).  */
  OUTPUT_IFDEF = 6,
  /* Output sdiff style (-y).  */
  OUTPUT_SDIFF = 7,
#endif
  /* Output html style.  */
  OUTPUT_HTML = 8
};

/* True for output styles that are robust,
   i.e. can handle a file that ends in a non-newline.  */
#define ROBUST_OUTPUT_STYLE(S) ((S)>=0) // ((S) != OUTPUT_ED && (S) != OUTPUT_FORWARD_ED)

EXTERN int output_style;

/* Nonzero if output cannot be generated for identical files.  */
EXTERN int no_diff_means_no_output;

/* Number of lines of context to show in each set of diffs.
   This is zero when context is not to be shown.  */
EXTERN int      context;

/* Consider all files as text files (-a).
   Don't interpret codes over 0177 as implying a "binary file".  */
EXTERN int	always_text_flag;

/* Number of lines to keep in identical prefix and suffix.  */
EXTERN int      horizon_lines;

/* Ignore changes in horizontal white space (-b).  */
EXTERN int      ignore_space_change_flag;

/* Ignore end of line differences (at least between UNIX & DOS */
EXTERN int      ignore_eol_diff;

/* Ignore all horizontal white space (-w).  */
EXTERN int      ignore_all_space_flag;

/* Ignore changes that affect only blank lines (-B).  */
EXTERN int      ignore_blank_lines_flag;

/* WinMerge moved block code */
EXTERN int moved_blocks_flag;

/* 1 if lines may match even if their lengths are different.
   This depends on various options.  */
EXTERN int      length_varies;

/* 1 if files may match even if their contents are not byte-for-byte identical.
   This depends on various options.  */
EXTERN int      ignore_some_changes;

/* Ignore differences in case of letters (-i).  */
EXTERN int      ignore_case_flag;

/* Ignore differences in case of numbers.  */
EXTERN int      ignore_numbers_flag;

/* File labels for `-c' output headers (-L).  */
EXTERN char *file_label[2];

/* Say only whether files differ, not how (-q).  */
EXTERN int 	no_details_flag;

/* Report files compared that match (-s).
   Normally nothing is output when that happens.  */
EXTERN int      print_file_same_flag;

/* character that ends a line.  Currently this is always `\n'.  */
EXTERN char     line_end_char;

/* Output the differences with exactly 8 columns added to each line
   so that any tabs in the text line up properly (-T).  */
EXTERN int	tab_align_flag;

/* Expand tabs in the output so the text lines up properly
   despite the characters added to the front of each line (-t).  */
EXTERN int	tab_expand_flag;

/* In directory comparison, specify file to start with (-S).
   All file names less than this name are ignored.  */
EXTERN char	*dir_start_file;

/* If a file is new (appears in only one dir)
   include its entire contents (-N).
   Then `patch' would create the file with appropriate contents.  */
EXTERN int	entire_new_file_flag;

/* If a file is new (appears in only the second dir)
   include its entire contents (-P).
   Then `patch' would create the file with appropriate contents.  */
EXTERN int	unidirectional_new_file_flag;

/* Pipe each file's output through pr (-l).  */
EXTERN int	paginate_flag;

enum line_class {
  /* Lines taken from just the first file.  */
  OLD,
  /* Lines taken from just the second file.  */
  NEW,
  /* Lines common to both files.  */
  UNCHANGED,
  /* A hunk containing both old and new lines (line groups only).  */
  CHANGED
};

/* Line group formats for old, new, unchanged, and changed groups.  */
EXTERN char *group_format[CHANGED + 1];

/* Line formats for old, new, and unchanged lines.  */
EXTERN char *line_format[UNCHANGED + 1];

/* If using OUTPUT_SDIFF print extra information to help the sdiff filter. */
EXTERN int sdiff_help_sdiff;

/* Tell OUTPUT_SDIFF to show only the left version of common lines. */
EXTERN int sdiff_left_only;

/* Tell OUTPUT_SDIFF to not show common lines. */
EXTERN int sdiff_skip_common_lines;

/* The half line width and column 2 offset for OUTPUT_SDIFF.  */
EXTERN unsigned sdiff_half_width;
EXTERN unsigned sdiff_column2_offset;

/* String containing all the command options diff received,
   with spaces between and at the beginning but none at the end.
   If there were no options given, this string is empty.  */
EXTERN char *	switch_string;

/* Nonzero means use heuristics for better speed.  */
EXTERN int	heuristic;

/* Name of program the user invoked (for error messages).  */
EXTERN char *	program;

/* The result of comparison is an "edit script": a chain of `struct change'.
   Each `struct change' represents one place where some lines are deleted
   and some are inserted.

   LINE0 and LINE1 are the first affected lines in the two files (origin 0).
   DELETED is the number of lines deleted here from file 0.
   INSERTED is the number of lines inserted here in file 1.

   If DELETED is 0 then LINE0 is the number of the line before
   which the insertion was done; vice versa for INSERTED and LINE1.  */

struct change
{
  struct change *link;		/* Previous or next edit command  */
  int inserted;			/* # lines of file 1 changed here.  */
  int deleted;			/* # lines of file 0 changed here.  */
  int line0;			/* Line number of 1st deleted line.  */
  int line1;			/* Line number of 1st inserted line.  */
  char ignore;			/* Flag used in context.c */
  char trivial;                 /* Flag if change is trivial (ignored blanks or filtered regexps) */
  int match0;                   /* side0 matching line for line 1 */ /* WinMerge moved block code */
  int match1;                   /* side1 matching line for line 0 */ /* WinMerge moved block code */
};

/* Structures that describe the input files.  */

/* Data on one input file being compared.  */

struct file_data {
    int             desc;	/* File descriptor  */
    char const      *name;	/* File name  */
#ifdef _WIN32
    struct _stat64  stat;	/* File status from fstat()  */
#else
    struct stat     stat;	/* File status from fstat()  */
#endif
    int             dir_p;	/* nonzero if file is a directory  */

    /* Buffer in which text of file is read.  */
    char HUGE *	    buffer;
    /* Allocated size of buffer.  */
    FSIZE	    bufsize;
    /* Number of valid characters now in the buffer. */
    FSIZE	    buffered_chars;

    /* Array of pointers to lines in the file.  */
    char const HUGE **linbuf;

    /* linbuf_base <= buffered_lines <= valid_lines <= alloc_lines.
       linebuf[linbuf_base ... buffered_lines - 1] are possibly differing.
       linebuf[linbuf_base ... valid_lines - 1] contain valid data.
       linebuf[linbuf_base ... alloc_lines - 1] are allocated.  */
    int linbuf_base, buffered_lines, valid_lines, alloc_lines;

    /* Pointer to end of prefix of this file to ignore when hashing. */
    char const HUGE *prefix_end;

    /* Count of lines in the prefix.
       There are this many lines in the file before linbuf[0].  */
    int prefix_lines;

    /* Pointer to start of suffix of this file to ignore when hashing. */
    char const HUGE *suffix_begin;

    /* Vector, indexed by line number, containing an equivalence code for
       each line.  It is this vector that is actually compared with that
       of another file to generate differences. */
    int		   *equivs;

    /* Vector, like the previous one except that
       the elements for discarded lines have been squeezed out.  */
    int		   *undiscarded;

    /* Vector mapping virtual line numbers (not counting discarded lines)
       to real ones (counting those lines).  Both are origin-0.  */
    int		   *realindexes;

    /* Total number of nondiscarded lines. */
    int		    nondiscarded_lines;

    /* Vector, indexed by real origin-0 line number,
       containing 1 for a line that is an insertion or a deletion.
       The results of comparison are stored here.  */
    char	   *changed_flag;

    /* 1 if file ends in a line with no final newline. */
    int		    missing_newline;

    /* 1 more than the maximum equivalence value used for this or its
       sibling file. */
    int equiv_max;

    /* text stats for WinMerge */
    int count_crlfs, count_crs, count_lfs, count_zeros;
};

/* Describe the two files currently being compared.  */

EXTERN struct file_data files[2];

/* Stdio stream to output diffs to.  */

EXTERN FILE *outfile;

/* Declare various functions.  */

/* analyze.c */
/* WinMerge: add last two params */
struct change * diff_2_files (struct file_data[], int, int *, int, int*);
void moved_block_analysis(struct change ** pscript, struct file_data fd[]);

/* context.c */
void print_context_header (struct file_data[], int);
void print_context_script (struct change *, int);

/* diff.c */
int excluded_filename (char const *);

/* dir.c */
//int diff_dirs (CDiffContext*);

/* ed.c */
void print_ed_script (struct change *);
void pr_forward_ed_script (struct change *);

/* ifdef.c */
void print_ifdef_script (struct change *);

/* io.c */
/* WinMerge: add last pointer param */
int read_files (struct file_data[], int, int *);
int sip (struct file_data *, int);
void slurp (struct file_data *);

/* normal.c */
void print_normal_script (struct change *);

/* rcs.c */
void print_rcs_script (struct change *);

/* side.c */
void print_sdiff_script (struct change *);

/* util.c */
void *xmalloc (size_t);
void *xrealloc (void *, size_t);
char *concat (char const *, char const *, char const *);
char *dir_file_pathname (char const *, char const *);
int change_letter (int, int);
int line_cmp (char const HUGE *, size_t, char const HUGE *, size_t);
int translate_line_number (struct file_data const *, int);
struct change *find_change (struct change *);
struct change *find_reverse_change (struct change *);
void analyze_hunk (struct change *, int *, int *, int *, int *, int *, int *, const struct file_data fd[]);
void begin_output (void);
void debug_script (struct change *);
void error (char const *, char const *, char const *);
void fatal (char const *);
void finish_output (void);
void message (char const *, char const *, char const *);
void message5 (char const *, char const *, char const *, char const *, char const *);
void output_1_line (char const HUGE *, char const HUGE *, char const *, char const *);
void perror_with_name (char const *);
void pfatal_with_name (char const *);
void print_1_line (char const *, char const HUGE * const *);
void print_message_queue (void);
void print_number_range (int, struct file_data *, int, int);
void print_script (struct change *, struct change * (*) (struct change *), void (*) (struct change *));
void setup_output (char const *, char const *, int);
void translate_range (struct file_data const *, int, int, int *, int *);
void cleanup_file_buffers(struct file_data fd[]);

/* version.c */
extern char const version_string[];

#ifdef _WIN32
/* mystat.cpp */
int myfstat(int fd, struct _stat64 *buf);
int mywstat(const wchar_t *filename, struct _stat64 *buf);
#else
#define myfstat fstat
#endif

#ifdef __cplusplus
#undef HUGE
}
#endif

</file>

<file path="Winmerge-Src/Src/diffutils/src/ed.c">
/* Output routines for ed-script format.
   Copyright (C) 1988, 89, 91, 92, 93 Free Software Foundation, Inc.

This file is part of GNU DIFF.

GNU DIFF is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GNU DIFF is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU DIFF; see the file COPYING.  If not, write to
the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */

#include "diff.h"

static void print_ed_hunk (struct change *);
static void print_rcs_hunk (struct change *);
static void pr_forward_ed_hunk (struct change *);

/* Print our script as ed commands.  */

void
print_ed_script (struct change *script)
{
  print_script (script, find_reverse_change, print_ed_hunk);
}

/* Print a hunk of an ed diff */

static void
print_ed_hunk (struct change *hunk)
{
  int f0, l0, f1, l1;
  int deletes, inserts;

#if 0
  hunk = flip_script (hunk);
#endif
#ifdef DEBUG
  debug_script (hunk);
#endif

  /* Determine range of line numbers involved in each file.  */
  analyze_hunk (hunk, &f0, &l0, &f1, &l1, &deletes, &inserts, files);
  if (!deletes && !inserts)
    return;

  begin_output ();

  /* Print out the line number header for this hunk */
  print_number_range (',', &files[0], f0, l0);
  fprintf (outfile, "%c\n", change_letter (inserts, deletes));

  /* Print new/changed lines from second file, if needed */
  if (inserts)
    {
      int i;
      int inserting = 1;
      for (i = f1; i <= l1; i++)
	{
	  /* Resume the insert, if we stopped.  */
	  if (! inserting)
	    fprintf (outfile, "%da\n",
		     i - f1 + translate_line_number (&files[0], f0) - 1);
	  inserting = 1;

	  /* If the file's line is just a dot, it would confuse `ed'.
	     So output it with a double dot, and set the flag LEADING_DOT
	     so that we will output another ed-command later
	     to change the double dot into a single dot.  */

	  if (files[1].linbuf[i][0] == '.'
	      && files[1].linbuf[i][1] == '\n')
	    {
	      fprintf (outfile, "..\n");
	      fprintf (outfile, ".\n");
	      /* Now change that double dot to the desired single dot.  */
	      fprintf (outfile, "%ds/^\\.\\././\n",
		       i - f1 + translate_line_number (&files[0], f0));
	      inserting = 0;
	    }
	  else
	    /* Line is not `.', so output it unmodified.  */
	    print_1_line ("", &files[1].linbuf[i]);
	}

      /* End insert mode, if we are still in it.  */
      if (inserting)
	fprintf (outfile, ".\n");
    }
}

/* Print change script in the style of ed commands,
   but print the changes in the order they appear in the input files,
   which means that the commands are not truly useful with ed.  */

void
pr_forward_ed_script (struct change *script)
{
  print_script (script, find_change, pr_forward_ed_hunk);
}

static void
pr_forward_ed_hunk (struct change *hunk)
{
  int i;
  int f0, l0, f1, l1;
  int deletes, inserts;

  /* Determine range of line numbers involved in each file.  */
  analyze_hunk (hunk, &f0, &l0, &f1, &l1, &deletes, &inserts, files);
  if (!deletes && !inserts)
    return;

  begin_output ();

  fprintf (outfile, "%c", change_letter (inserts, deletes));
  print_number_range (' ', files, f0, l0);
  fprintf (outfile, "\n");

  /* If deletion only, print just the number range.  */

  if (!inserts)
    return;

  /* For insertion (with or without deletion), print the number range
     and the lines from file 2.  */

  for (i = f1; i <= l1; i++)
    print_1_line ("", &files[1].linbuf[i]);

  fprintf (outfile, ".\n");
}

/* Print in a format somewhat like ed commands
   except that each insert command states the number of lines it inserts.
   This format is used for RCS.  */

void
print_rcs_script (struct change *script)
{
  print_script (script, find_change, print_rcs_hunk);
}

/* Print a hunk of an RCS diff */

static void
print_rcs_hunk (struct change *hunk)
{
  int i;
  int f0, l0, f1, l1;
  int deletes, inserts;
  int tf0, tl0, tf1, tl1;

  /* Determine range of line numbers involved in each file.  */
  analyze_hunk (hunk, &f0, &l0, &f1, &l1, &deletes, &inserts, files);
  if (!deletes && !inserts)
    return;

  begin_output ();

  translate_range (&files[0], f0, l0, &tf0, &tl0);

  if (deletes)
    {
      fprintf (outfile, "d");
      /* For deletion, print just the starting line number from file 0
	 and the number of lines deleted.  */
      fprintf (outfile, "%d %d\n",
	       tf0,
	       (tl0 >= tf0 ? tl0 - tf0 + 1 : 1));	     
    }

  if (inserts)
    {
      fprintf (outfile, "a");

      /* Take last-line-number from file 0 and # lines from file 1.  */
      translate_range (&files[1], f1, l1, &tf1, &tl1);
      fprintf (outfile, "%d %d\n",
	       tl0,
	       (tl1 >= tf1 ? tl1 - tf1 + 1 : 1));	     

      /* Print the inserted lines.  */
      for (i = f1; i <= l1; i++)
	print_1_line ("", &files[1].linbuf[i]);
    }
}
</file>

<file path="Winmerge-Src/Src/diffutils/src/ifdef.c">
/* #ifdef-format output routines for GNU DIFF.
   Copyright (C) 1989, 91, 92, 93 Free Software Foundation, Inc.

This file is part of GNU DIFF.

GNU DIFF is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY.  No author or distributor
accepts responsibility to anyone for the consequences of using it
or for whether it serves any particular purpose or works at all,
unless he says so in writing.  Refer to the GNU General Public
License for full details.

Everyone is granted permission to copy, modify and redistribute
GNU DIFF, but only under the conditions described in the
GNU General Public License.   A copy of this license is
supposed to have been given to you along with GNU DIFF so you
can know your rights and responsibilities.  It should be in a
file named COPYING.  Among other things, the copyright notice
and this notice must be preserved on all copies.  */


#include "diff.h"
#include <assert.h>

struct group
{
  struct file_data const *file;
  int from, upto; /* start and limit lines for this group of lines */
};

static char *format_group (FILE *, char *, int, struct group const[]);
static char *scan_char_literal (char *, int *);
static char *scan_printf_spec (char *);
static int groups_letter_value (struct group const[], int);
static void format_ifdef (char *, int, int, int, int);
static void print_ifdef_hunk (struct change *);
static void print_ifdef_lines (FILE *, char *, struct group const *);

static DECL_TLS int next_line;

/* Print the edit-script SCRIPT as a merged #ifdef file.  */

void
print_ifdef_script (struct change *script)
{
  next_line = - files[0].prefix_lines;
  print_script (script, find_change, print_ifdef_hunk);
  if (next_line < files[0].valid_lines)
    {
      begin_output ();
      format_ifdef (group_format[UNCHANGED], next_line, files[0].valid_lines,
		    next_line - files[0].valid_lines + files[1].valid_lines,
		    files[1].valid_lines);
    }
}

/* Print a hunk of an ifdef diff.
   This is a contiguous portion of a complete edit script,
   describing changes in consecutive lines.  */

static void
print_ifdef_hunk (struct change *hunk)
{
  int first0, last0, first1, last1, deletes, inserts;
  char *format;

  /* Determine range of line numbers involved in each file.  */
  analyze_hunk (hunk, &first0, &last0, &first1, &last1, &deletes, &inserts, files);
  if (inserts)
    format = deletes ? group_format[CHANGED] : group_format[NEW];
  else if (deletes)
    format = group_format[OLD];
  else
    return;

  begin_output ();

  /* Print lines up to this change.  */
  if (next_line < first0)
    format_ifdef (group_format[UNCHANGED], next_line, first0,
		  next_line - first0 + first1, first1);

  /* Print this change.  */
  next_line = last0 + 1;
  format_ifdef (format, first0, next_line, first1, last1 + 1);
}

/* Print a set of lines according to FORMAT.
   Lines BEG0 up to END0 are from the first file;
   lines BEG1 up to END1 are from the second file.  */

static void
format_ifdef (char *format, int beg0, int end0, int beg1, int end1)
{
  struct group groups[2];

  groups[0].file = &files[0];
  groups[0].from = beg0;
  groups[0].upto = end0;
  groups[1].file = &files[1];
  groups[1].from = beg1;
  groups[1].upto = end1;
  format_group (outfile, format, '\0', groups);
}

/* Print to file OUT a set of lines according to FORMAT.
   The format ends at the first free instance of ENDCHAR.
   Yield the address of the terminating character.
   GROUPS specifies which lines to print.
   If OUT is zero, do not actually print anything; just scan the format.  */

static char *
format_group (register FILE *out, char *format, int endchar, struct group const groups[])
{
  register char c;
  register char *f = format;

  while ((c = *f) != endchar && c != 0)
    {
      f++;
      if (c == '%')
	{
	  char *spec = f;
	  switch ((c = *f++))
	    {
	    case '%':
	      break;

	    case '(':
	      /* Print if-then-else format e.g. `%(n=1?thenpart:elsepart)'.  */
	      {
		int i, value[2];
		FILE *thenout, *elseout;

		for (i = 0; i < 2; i++)
		  {
		    unsigned char f0 = f[0];
		    if (isdigit (f0))
		      {
			value[i] = atoi (f);
			while (isdigit ((unsigned char) *++f))
			  continue;
		      }
		    else
		      {
			value[i] = groups_letter_value (groups, f0);
			if (value[i] < 0)
			  goto bad_format;
			f++;
		      }
		    if (*f++ != "=?"[i])
		      goto bad_format;
		  }
		if (value[0] == value[1])
		  thenout = out, elseout = 0;
		else
		  thenout = 0, elseout = out;
		f = format_group (thenout, f, ':', groups);
		if (*f)
		  {
		    f = format_group (elseout, f + 1, ')', groups);
		    if (*f)
		      f++;
		  }
	      }
	      continue;

	    case '<':
	      /* Print lines deleted from first file.  */
	      print_ifdef_lines (out, line_format[OLD], &groups[0]);
	      continue;

	    case '=':
	      /* Print common lines.  */
	      print_ifdef_lines (out, line_format[UNCHANGED], &groups[0]);
	      continue;

	    case '>':
	      /* Print lines inserted from second file.  */
	      print_ifdef_lines (out, line_format[NEW], &groups[1]);
	      continue;

	    default:
	      {
		int value;
		char *speclim;

		f = scan_printf_spec (spec);
		if (!f)
		  goto bad_format;
		speclim = f;
		c = *f++;
		switch (c)
		  {
		    case '\'':
		      f = scan_char_literal (f, &value);
		      if (!f)
			goto bad_format;
		      break;

		    default:
		      value = groups_letter_value (groups, c);
		      if (value < 0)
			goto bad_format;
		      break;
		  }
		if (out)
		  {
		    /* Temporarily replace e.g. "%3dnx" with "%3d\0x".  */
		    *speclim = 0;
		    fprintf (out, spec - 1, value);
		    /* Undo the temporary replacement.  */
		    *speclim = c;
		  }
	      }
	      continue;

	    bad_format:
	      c = '%';
	      f = spec;
	      break;
	    }
	}
      if (out)
	putc (c, out);
    }
  return f;
}

/* For the line group pair G, return the number corresponding to LETTER.
   Return -1 if LETTER is not a group format letter.  */
static int
groups_letter_value (struct group const g[], int letter)
{
  if (isupper (letter))
    {
      g++;
      letter = tolower (letter);
    }
  switch (letter)
    {
      case 'e': return translate_line_number (g->file, g->from) - 1;
      case 'f': return translate_line_number (g->file, g->from);
      case 'l': return translate_line_number (g->file, g->upto) - 1;
      case 'm': return translate_line_number (g->file, g->upto);
      case 'n': return g->upto - g->from;
      default: return -1;
    }
}

/* Print to file OUT, using FORMAT to print the line group GROUP.
   But do nothing if OUT is zero.  */
static void
print_ifdef_lines (register FILE *out, char *format, struct group const *group)
{
  struct file_data const *file = group->file;
  char const HUGE * const *linbuf = file->linbuf;
  int from = group->from, upto = group->upto;

  if (!out)
    return;

  /* If possible, use a single fwrite; it's faster.  */
  if (!tab_expand_flag && format[0] == '%')
    {
      if (format[1] == 'l' && format[2] == '\n' && !format[3])
	{
	  fwrite (linbuf[from], sizeof (char),
		  linbuf[upto] + (linbuf[upto][-1] != '\n') -  linbuf[from],
		  out);
	  return;
	}
      if (format[1] == 'L' && !format[2])
	{
	  fwrite (linbuf[from], sizeof (char),
		  linbuf[upto] -  linbuf[from], out);
	  return;
	}
    }

  for (;  from < upto;  from++)
    {
      register char c;
      register char *f = format;

      while ((c = *f++) != 0)
	{
	  if (c == '%')
	    {
	      char *spec = f;
	      switch ((c = *f++))
		{
		case '%':
		  break;

		case 'l':
		  output_1_line (linbuf[from],
				 linbuf[from + 1]
				   - (linbuf[from + 1][-1] == '\n'), 0, 0);
		  continue;

		case 'L':
		  output_1_line (linbuf[from], linbuf[from + 1], 0, 0);
		  continue;

		default:
		  {
		    int value;
		    char *speclim;

		    f = scan_printf_spec (spec);
		    if (!f)
		      goto bad_format;
		    speclim = f;
		    c = *f++;
		    switch (c)
		      {
			case '\'':
			  f = scan_char_literal (f, &value);
			  if (!f)
			    goto bad_format;
			  break;

		        case 'n':
			  value = translate_line_number (file, from);
			  break;
			
			default:
			  goto bad_format;
		      }
		    /* Temporarily replace e.g. "%3dnx" with "%3d\0x".  */
		    *speclim = 0;
		    fprintf (out, spec - 1, value);
		    /* Undo the temporary replacement.  */
		    *speclim = c;
		  }
		  continue;

		bad_format:
		  c = '%';
		  f = spec;
		  break;
		}
	    }
	  putc (c, out);
	}
    }
}

/* Scan the character literal represented in the string LIT; LIT points just
   after the initial apostrophe.  Put the literal's value into *INTPTR.
   Yield the address of the first character after the closing apostrophe,
   or zero if the literal is ill-formed.  */
static char *
scan_char_literal (char *lit, int *intptr)
{
  register char *p = lit;
  int value, digits;
  char c = *p++;

  switch (c)
    {
      case 0:
      case '\'':
	return NULL;

      case '\\':
	value = 0;
	while ((c = *p++) != '\'')
	  {
	    unsigned digit = c - '0';
	    if (8 <= digit)
	      return NULL;
	    value = 8 * value + digit;
	  }
	assert((p - lit - 2) < INT_MAX);
	digits = (int)(p - lit - 2);
	if (! (1 <= digits && digits <= 3))
	  return NULL;
	break;

      default:
	value = c;
	if (*p++ != '\'')
	  return NULL;
	break;
    }
  *intptr = value;
  return p;
}

/* Scan optional printf-style SPEC of the form `-*[0-9]*(.[0-9]*)?[cdoxX]'.
   Return the address of the character following SPEC, or NULL if failure.  */
static char *
scan_printf_spec (register char *spec)
{
  register unsigned char c;

  while ((c = *spec++) == '-')
    continue;
  while (isdigit (c))
    c = *spec++;
  if (c == '.')
    while (isdigit (c = *spec++))
      continue;
  switch (c)
    {
      case 'c': case 'd': case 'o': case 'x': case 'X':
	return spec;

      default:
	return NULL;
    }
}
</file>

<file path="Winmerge-Src/Src/diffutils/src/io.c">
/* File I/O for GNU DIFF.
   Copyright (C) 1988, 1989, 1992, 1993 Free Software Foundation, Inc.

This file is part of GNU DIFF.

GNU DIFF is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GNU DIFF is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU DIFF; see the file COPYING.  If not, write to
the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */

#include "diff.h"
#include <io.h>
#include <assert.h>

/* Rotate a value n bits to the left. */
#define UINT_BIT (sizeof (unsigned) * CHAR_BIT)
#define ROL(v, n) ((v) << (n) | (v) >> (UINT_BIT - (n)))

/* Given a hash value and a new character, return a new hash value. */
#define HASH(h, c) ((c) + ROL (h, 7))

/* Guess remaining number of lines from number N of lines so far,
   size S so far, and total size T.  */
#define GUESS_LINES(n,s,t) (((t) - (s)) / ((n) < 10 ? 32 : (s) / ((n)-1)) + 5)

/* Type used for fast prefix comparison in find_identical_ends.  */
typedef unsigned word;

/** @brief Known Unicode encodings. */
enum UNICODESET
{
  NONE = 0,  /**< No unicode. */
  UCS2LE,    /**< UCS-2 / UTF-16 little endian. */
  UCS2BE,    /**< UCS-2 / UTF-16 big endian. */
  UTF8,      /**< UTF-8. */
  UCS4LE,    /**< UTF-32 little endian */
  UCS4BE,    /**< UTF-32 big-endian */
};

/* Lines are put into equivalence classes (of lines that match in line_cmp).
   Each equivalence class is represented by one of these structures,
   but only while the classes are being computed.
   Afterward, each class is represented by a number.  */
struct equivclass
{
  int next;	/* Next item in this bucket. */
  unsigned hash;	/* Hash of lines in this class.  */
  char const HUGE *line;	/* A line that fits this class. */
  size_t length;	/* The length of that line.  */
};

/* Hash-table: array of buckets, each being a chain of equivalence classes.  */
static DECL_TLS int *buckets;
  
/* Number of buckets in the hash table array. */
static DECL_TLS int nbuckets;

/* Array in which the equivalence classes are allocated.
   The bucket-chains go through the elements in this array.
   The number of an equivalence class is its index in this array.  */
static DECL_TLS struct equivclass HUGE *equivs;

/* Index of first free element in the array `equivs'.  */
static DECL_TLS int equivs_index;

/* Number of elements allocated in the array `equivs'.  */
static DECL_TLS int equivs_alloc;

static void find_and_hash_each_line (struct file_data *);
static void find_identical_ends (struct file_data[]);
static char *prepare_text_end (struct file_data *, short);
static enum UNICODESET get_unicode_signature(struct file_data *, int *pBomsize);

/* Check for binary files and compare them for exact identity.  */

/* Return 1 if BUF contains a non text character.
   SIZE is the number of characters in BUF.  */

#define binary_file_p(buf, size) (size != 0 && memchr (buf, '\0', size) != 0)

/** @brief Get unicode signature from file_data. */
static enum UNICODESET get_unicode_signature(struct file_data *current, int *pBomsize)
{
  // initialize to a pattern that differs everywhere from all possible unicode signatures
  unsigned long sig = 0x3F3F3F3F;
  // copy at most 4 bytes from buffer
  memcpy(&sig, current->buffer, min(current->buffered_chars, 4));
  // check for the two possible 4 bytes signatures
  int tmp;
  int *bomsize = pBomsize ? pBomsize : &tmp;
  
  if (sig == 0x0000FEFF)
    {
      *bomsize = 4;
      return UCS4LE;
    }
  if (sig == 0xFFFE0000)
    {
      *bomsize = 4;
      return UCS4BE;
    }
  // check for the only possible 3 bytes signature
  sig &= 0xFFFFFF;
  if (sig == 0xBFBBEF)
    {
      *bomsize = 3;
      return UTF8;
    }
  // check for the two possible 2 bytes signatures
  sig &= 0xFFFF;
  if (sig == 0xFEFF)
    {
      *bomsize = 2;
      return UCS2LE;
    }
  if (sig == 0xFFFE)
    {
      *bomsize = 2;
      return UCS2BE;
    }
  // none of the above checks has passed, so probably no unicode
  *bomsize = 0;
  return NONE;
}

/* Get ready to read the current file.
   Return nonzero if SKIP_TEST is zero,
   and if it appears to be a binary file.  */

int
sip (struct file_data *current, int skip_test)
{
  int isbinary = 0;
  /* If we have a nonexistent file (or NUL: device) at this stage, treat it as empty.  */
  if (current->desc < 0 || !(S_ISREG (current->stat.st_mode)))
    {
      /* Leave room for a sentinel.  */
      current->buffer = xmalloc (sizeof (word));
      current->bufsize = sizeof (word);
      current->buffered_chars = 0;
    }
  else
    {
      current->bufsize = current->buffered_chars
        = STAT_BLOCKSIZE (current->stat);
#ifdef __MSDOS__
      if ((current->buffer = (char HUGE *) farmalloc (current->bufsize)) == NULL)
         fatal ("far memory exhausted");
#else
      current->buffer = xmalloc (current->bufsize);
#endif /*__MSDOS__*/

      if (skip_test)
        current->buffered_chars = 0;
      else
        {
          /* Check first part of file to see if it's a binary file.  */
          current->buffered_chars = _read (current->desc,
            current->buffer,
            (unsigned int)current->buffered_chars);
          if (current->buffered_chars == -1)
            pfatal_with_name (current->name);
          if (!get_unicode_signature(current, NULL))
            isbinary = binary_file_p(current->buffer, current->buffered_chars);
        }
    }
  
  return isbinary;
}

/* Slurp the rest of the current file completely into memory.  */

void
slurp (struct file_data *current)
{
  size_t cc;

  if (current->desc < 0)
    /* The file is nonexistent.  */
    ;
  else if (always_text_flag || current->buffered_chars != 0)
    {
      enum UNICODESET sig = get_unicode_signature(current, NULL);
      size_t alloc_extra
        = (1 << sig) & ((1 << UCS2LE) | (1 << UCS2BE) | (1 << UCS4LE) | (1 << UCS4BE))
          // some flavor of non octet encoded unicode?
          ? ~0U	// yes, allocate extra room for transcoding
          : 0U;	// no, allocate no extra room for transcoding

      for (;;)
        {
          if (current->buffered_chars == current->bufsize)
            {
              if (S_ISREG (current->stat.st_mode))
                {
              /* Get the size out of the stat block.
                 Allocate 50% extra room for a necessary transcoding to UTF-8.
                 Allocate enough room for appended newline and sentinel.
                 Allocate at least one block, to prevent overrunning the buffer
                 when comparing growing binary files. */
                  current->bufsize = max (current->bufsize,
                    (size_t)current->stat.st_size + (alloc_extra & (size_t)current->stat.st_size / 2) + sizeof (word) + 1);
                }
              else
                {
#ifdef __MSDOS__
                  current->bufsize += 4096;
#else
                  current->bufsize = current->bufsize * 2;
#endif /*__MSDOS__*/
                }
#ifdef __MSDOS__
              current->buffer = (char HUGE *) farrealloc (current->buffer, current->bufsize);
#else
              current->buffer = xrealloc (current->buffer, current->bufsize);
#endif /*__MSDOS__*/
            }
          unsigned int bytes_to_read = min((unsigned int)(current->bufsize - current->buffered_chars), INT_MAX);
          if (bytes_to_read == 0)
            break;
          cc = _read (current->desc,
                      current->buffer + current->buffered_chars,
                      bytes_to_read);
          if (cc == 0)
            break;
          if (cc == -1)
            pfatal_with_name (current->name);
          current->buffered_chars += cc;
        }
#ifndef __MSDOS__
      /* Allocate 50% extra room for a necessary transcoding to UTF-8.
         Allocate enough room for appended newline and sentinel. 
		 But don't reallocate if the buffer is already big enough */
	  FSIZE tmp_bufsize = current->buffered_chars + (alloc_extra & current->buffered_chars / 2) + sizeof (word) + 1;
	  if (tmp_bufsize > current->bufsize) 
	    { 
		  current->buffer = xrealloc (current->buffer, tmp_bufsize);
		  current->bufsize = tmp_bufsize;
	    }
#endif /*!__MSDOS__*/
    }
}

static int
ISWSPACE (char ch)
{
  return ch==' ' || ch=='\t';
}

/* Split the file into lines, simultaneously computing the equivalence class for
   each line. */
static void
find_and_hash_each_line (struct file_data *current)
{
  unsigned h;
  unsigned char const HUGE *p = (unsigned char const HUGE *) current->prefix_end;
  unsigned char c;
  int i, *bucket;
  size_t length;

  /* Cache often-used quantities in local variables to help the compiler.  */
  char const HUGE **linbuf = current->linbuf;
  int alloc_lines = current->alloc_lines;
  int line = 0;
  int linbuf_base = current->linbuf_base;
  int *cureqs = (int *) xmalloc (alloc_lines * sizeof (int));
  struct equivclass HUGE *eqs = equivs;
  int eqs_index = equivs_index;
  int eqs_alloc = equivs_alloc;
  char const HUGE *suffix_begin = current->suffix_begin;
  char const HUGE *bufend = current->buffer + current->buffered_chars;
  char const HUGE *incomplete_tail
    = current->missing_newline && ROBUST_OUTPUT_STYLE (output_style)
      ? bufend : (char const HUGE *) NULL;
  int varies = length_varies;

  /* prepare_text_end put a zero word at the end of the buffer, 
  so we're not in danger of overrunning the end of the file */

  while ((char const HUGE *) p < suffix_begin)
    {
      char const HUGE *ip = (char const HUGE *) p;

      /* Compute the equivalence class (hash) for this line.  */

      h = 0;


      /* loops advance pointer to eol (end of line)
         respecting UNIX (\r), MS-DOS/Windows (\r\n), and MAC (\r) eols */

      /* Hash this line until we find a newline. */
      if (ignore_case_flag)
        {
          if (ignore_all_space_flag)
            while ((c = *p++) != '\n' && (c != '\r' || *p == '\n'))
              {
                if (ignore_numbers_flag && isdigit(c))
                    continue;
                if (! ISWSPACE (c))
                  h = HASH (h, isupper (c) ? tolower (c) : c);
              }
          else if (ignore_space_change_flag)
            /* Note that \r must be hashed (if !ignore_eol_diff) */
            while ((c = *p++) != '\n' && (c != '\r' || *p == '\n'))
              {
                if (ISWSPACE (c))
                  {
                    /* skip whitespace after whitespace */
                    while (ISWSPACE (c = *p++))
                      ;
                    if (c == '\n')
                      {
                        goto hashing_done; /* never hash trailing \n */
                      }
                    else if (c != '\r')
                      {
                  /* runs of whitespace not ending line hashed as one space */
                        h = HASH (h, ' ');
                      }
                  }

                /* c is now the first non-space.  */

                if (ignore_numbers_flag && isdigit(c))
                    continue;

                /* c can be a \r (CR) if !ignore_eol_diff */
                h = HASH (h, isupper (c) ? tolower (c) : c);
                if (c == '\r' && *p != '\n')
                  goto hashing_done;
              }
          else
            while ((c = *p++) != '\n' && (c != '\r' || *p == '\n'))
              {
                if (ignore_numbers_flag && isdigit(c))
                    continue;

                h = HASH (h, isupper (c) ? tolower (c) : c);
              }
        }
      else
        {
          if (ignore_all_space_flag)
            while ((c = *p++) != '\n' && (c != '\r' || *p == '\n'))
              {
                if (ignore_numbers_flag && isdigit(c))
                    continue;

                if (! ISWSPACE (c))
                  h = HASH (h, c);
              }
          else if (ignore_space_change_flag)
            /* Note that \r must be hashed (if !ignore_eol_diff) */
            while ((c = *p++) != '\n' && (c != '\r' || *p == '\n'))
              {
                if (ISWSPACE (c))
                  {
                    /* skip whitespace after whitespace */
                    while (ISWSPACE (c = *p++))
                      ;
                    if (c == '\n')
                      {
                        goto hashing_done; /* never hash trailing \n */
                      }
                    else if (c != '\r')
                      {
                  /* runs of whitespace not ending line hashed as one space */
                        h = HASH (h, ' ');
                      }
                  }
                /* c is now the first non-space.  */
                if (ignore_numbers_flag && isdigit(c))
                    continue;

                /* c can be a \r (CR) if !ignore_eol_diff */
                h = HASH (h, c);
                if (c == '\r' && *p != '\n')
                  goto hashing_done;
              }
          else
            while ((c = *p++) != '\n' && (c != '\r' || *p == '\n'))
              {
                if (ignore_numbers_flag && isdigit(c))
                    continue;

                h = HASH (h, c);
              }
        }
hashing_done:;

      bucket = &buckets[h % nbuckets];
      length = (char const HUGE *) p - ip - ((char const HUGE *) p == incomplete_tail);
      for (i = *bucket;  ;  i = eqs[i].next)
        if (!i)
          {
            /* Create a new equivalence class in this bucket. */
            i = eqs_index++;
            if (i == eqs_alloc)
#ifdef __MSDOS__
              if ((eqs = (struct equivclass HUGE *) farrealloc (eqs, (long) (eqs_alloc*=2) * sizeof(*eqs))) == NULL)
                fatal ("far memory exhausted");
#else
              eqs = (struct equivclass *)
                xrealloc (eqs, (eqs_alloc*=2) * sizeof(*eqs));
#endif /*__MSDOS__*/
            eqs[i].next = *bucket;
            eqs[i].hash = h;
            eqs[i].line = ip;
            eqs[i].length = length;
            *bucket = i;
            break;
          }
        /* "line_cmp" changed to "lines_differ" by diffutils 2.8.1 */
        else if (eqs[i].hash == h
           && (eqs[i].length == length || varies)
           && ! line_cmp (eqs[i].line, eqs[i].length, ip, length))
          /* Reuse existing equivalence class.  */
            break;

      /* Maybe increase the size of the line table. */
      if (line == alloc_lines)
        {
          /* Double (alloc_lines - linbuf_base) by adding to alloc_lines.  */
          alloc_lines = 2 * alloc_lines - linbuf_base;
          cureqs = (int *) xrealloc (cureqs, alloc_lines * sizeof (*cureqs));
          linbuf = (char const HUGE **) xrealloc ((void *)(linbuf + linbuf_base),
                     (alloc_lines - linbuf_base)
                     * sizeof (*linbuf))
             - linbuf_base;
        }
      linbuf[line] = ip;
      cureqs[line] = i;
      ++line;
    }

  current->buffered_lines = line;

  for (i = 0;  ;  i++)
    {
      /* Record the line start for lines in the suffix that we care about.
         Record one more line start than lines,
         so that we can compute the length of any buffered line.  */
      if (line == alloc_lines)
        {
          /* Double (alloc_lines - linbuf_base) by adding to alloc_lines.  */
          alloc_lines = 2 * alloc_lines - linbuf_base;
          linbuf = (char const HUGE **) xrealloc ((void *)(linbuf + linbuf_base),
                     (alloc_lines - linbuf_base)
                     * sizeof (*linbuf))
             - linbuf_base;
        }
      linbuf[line] = (char const HUGE *) p;
    
     if ((char const HUGE *) p == bufend)
        {
          linbuf[line]  -=  (char const HUGE *) p == incomplete_tail;
          break;
        }

      if (context <= i && no_diff_means_no_output)
        break;

      line++;

      while (p[0] != '\n' && (p[0] != '\r' || p[1] == '\n'))
         p++;
      p++;
    }

  /* Done with cache in local variables.  */
  current->linbuf = linbuf;
  current->valid_lines = line;
  current->alloc_lines = alloc_lines;
  current->equivs = cureqs;
  equivs = eqs;
  equivs_alloc = eqs_alloc;
  equivs_index = eqs_index;
}

/* Convert any non octet encoded unicode text to UTF-8.
   Prepare the end of the text. Make sure it's initialized.
   Make sure text ends in a newline,
   but remember that we had to add one unless -B is in effect.
   Return effective start of text to be compared. */

# pragma warning(push)          // Saves the current warning state.
# pragma warning(disable:4244)  // Temporarily disables warning 4244: "conversion from 'int' to 'char', possible loss of data"
static char *
prepare_text_end (struct file_data *current, short side)
{
  FSIZE buffered_chars = current->buffered_chars;
  char *const p = current->buffer;
  char *r = p; // receives the return value
  char *q0, *t;
  int bomsize = 0;
  enum UNICODESET sig = get_unicode_signature(current, &bomsize);
  char *const u0 = p + bomsize;

  if (sig == UCS4LE)
    {
      FSIZE buffered_words = buffered_chars / 2;
      unsigned long *q1 = (unsigned long *)p + buffered_words / 2;
      buffered_chars += buffered_words;
      r = p + buffered_chars;
      while (--q1 >= (unsigned long *)u0) // exclude the BOM
        {
          unsigned long u = *q1;
          if (u >= 0x80000000)
            {
              *--r = '?';
            }
          else if (u >= 0x4000000)
            {
              *--r = 0x80 + (u & 0x3F);
              *--r = 0x80 + ((u >> 6) & 0x3F);
              *--r = 0x80 + ((u >> 12) & 0x3F);
              *--r = 0x80 + ((u >> 18) & 0x3F);
              *--r = 0x80 + ((u >> 24) & 0x3F);
              *--r = 0xFC + (u >> 30);
            }
            else if (u >= 0x200000)
            {
              *--r = 0x80 + (u & 0x3F);
              *--r = 0x80 + ((u >> 6) & 0x3F);
              *--r = 0x80 + ((u >> 12) & 0x3F);
              *--r = 0x80 + ((u >> 18) & 0x3F);
              *--r = 0xF8 + (u >> 24);
            }
            else if (u >= 0x10000)
            {
              *--r = 0x80 + (u & 0x3F);
              *--r = 0x80 + ((u >> 6) & 0x3F);
              *--r = 0x80 + ((u >> 12) & 0x3F);
              *--r = 0xF0 + (char)(u >> 18);
            }
            else if (u >= 0x800)
            {
              *--r = 0x80 + (u & 0x3F);
              *--r = 0x80 + ((u >> 6) & 0x3F);
              *--r = 0xE0 + (char)(u >> 12);
            }
            else if (u >= 0x80 || u == 0) // map NUL to 2 byte sequence so as to prevent it from confusing diff algorithm
            {
              *--r = 0x80 + (u & 0x3F);
              *--r = 0xC0 + (char)(u >> 6);
            }
            else
            {
              *--r = (char)u;
            }
        }
    }
  else if (sig == UCS4BE)
    {
      FSIZE buffered_words = buffered_chars / 2;
      unsigned long *q = (unsigned long *)p + buffered_words / 2;
      buffered_chars += buffered_words;
      r = p + buffered_chars;
      while (--q >= (unsigned long *)u0) // exclude the BOM
        {
          unsigned long u =
          ((*q & 0x000000FF) << 24) |
          ((*q & 0x0000FF00) << 8) |
          ((*q & 0x00FF0000) >> 8) |
          ((*q & 0xFF000000) >> 24); // fix byte order
          if (u >= 0x80000000)
            {
              *--r = '?';
            }
          else if (u >= 0x4000000)
            {
              *--r = 0x80 + (u & 0x3F);
              *--r = 0x80 + ((u >> 6) & 0x3F);
              *--r = 0x80 + ((u >> 12) & 0x3F);
              *--r = 0x80 + ((u >> 18) & 0x3F);
              *--r = 0x80 + ((u >> 24) & 0x3F);
              *--r = 0xFC + (u >> 30);
            }
          else if (u >= 0x200000)
            {
              *--r = 0x80 + (u & 0x3F);
              *--r = 0x80 + ((u >> 6) & 0x3F);
              *--r = 0x80 + ((u >> 12) & 0x3F);
              *--r = 0x80 + ((u >> 18) & 0x3F);
              *--r = 0xF8 + (u >> 24);
            }
          else if (u >= 0x10000)
            {
              *--r = 0x80 + (u & 0x3F);
              *--r = 0x80 + ((u >> 6) & 0x3F);
              *--r = 0x80 + ((u >> 12) & 0x3F);
              *--r = 0xF0 + (char)(u >> 18);
            }
          else if (u >= 0x800)
            {
              *--r = 0x80 + (u & 0x3F);
              *--r = 0x80 + ((u >> 6) & 0x3F);
              *--r = 0xE0 + (char)(u >> 12);
            }
          else if (u >= 0x80 || u == 0) // map NUL to 2 byte sequence so as to prevent it from confusing diff algorithm
            {
              *--r = 0x80 + (u & 0x3F);
              *--r = 0xC0 + (char)(u >> 6);
            }
          else
            {
              *--r = (char)u;
            }
        }
    }
  else if (sig == UCS2LE)
    {
      FSIZE buffered_words = buffered_chars / 2;
      unsigned short *q = (unsigned short *)p + buffered_words;
      buffered_chars += buffered_words;
      r = p + buffered_chars;
      while (--q >= (unsigned short *)u0) // exclude the BOM
        {
          unsigned short u = *q;
          if (u >= 0x800)
            {
              *--r = 0x80 + (u & 0x3F);
              *--r = 0x80 + ((u >> 6) & 0x3F);
              *--r = 0xE0 + (u >> 12);
            }
          else if (u >= 0x80 || u == 0) // map NUL to 2 byte sequence so as to prevent it from confusing diff algorithm
            {
              *--r = 0x80 + (u & 0x3F);
              *--r = 0xC0 + (u >> 6);
            }
          else
            {
              *--r = (char)u;
            }
        }
    }
  else if (sig == UCS2BE)
    {
      FSIZE buffered_words = buffered_chars / 2;
      unsigned short *q = (unsigned short *)p + buffered_words;
      buffered_chars += buffered_words;
      r = p + buffered_chars;
      while (--q >= (unsigned short *)u0) // exclude the BOM
        {
          unsigned short u = (*q << 8) | (*q >> 8); // fix byte order
          if (u >= 0x800)
            {
              *--r = 0x80 + (u & 0x3F);
              *--r = 0x80 + ((u >> 6) & 0x3F);
              *--r = 0xE0 + (u >> 12);
            }
          else if (u >= 0x80 || u == 0) // map NUL to 2 byte sequence so as to prevent it from confusing diff algorithm
            {
              *--r = 0x80 + (u & 0x3F);
              *--r = 0xC0 + (u >> 6);
            }
          else
            {
              *--r = (char)u;
            }
        }
    }
  else if (sig == UTF8)
    {
      r = u0; // skip the BOM
    }

  if (buffered_chars - bomsize == 0 || p[buffered_chars - 1] == '\n' || p[buffered_chars - 1] == '\r')
    current->missing_newline = 0;
  else
    {
      p[buffered_chars++] = '\n';
      current->missing_newline = 1;
      --current->count_lfs; // compensate for extra newline
    }

	current->buffered_chars = buffered_chars;

	/* Count line endings and map them to '\n' if ignore_eol_diff is set. */
	t = q0 = p + buffered_chars;
	while (q0 > r)
	{
		switch (*--t = *--q0)
		{
		case '\r':
			++current->count_crs;
			if (ignore_eol_diff)
				*t = '\n';
			break;
		case '\n':
			if (q0 > r && q0[-1] == '\r')
			{
				++current->count_crlfs;
				--current->count_crs; // compensate for bogus increment
				if (ignore_eol_diff)
					++t;
			}
			else
			{
				++current->count_lfs;
			}
			break;
		case '\0':
			++current->count_zeros;
			break;
		}
	}

  /* Don't use uninitialized storage when planting or using sentinels.  */
  bzero (p + buffered_chars, sizeof (word));
  return t;
}
# pragma warning(pop)           // Restores the warning state.

/* Given a vector of two file_data objects, find the identical
   prefixes and suffixes of each object. */

static void
find_identical_ends (struct file_data filevec[])
{
  word HUGE *w0, HUGE *w1;
  char HUGE *p0, HUGE *p1, HUGE *buffer0, HUGE *buffer1;
  char const HUGE *end0, HUGE *beg0;
  char const HUGE **linbuf0, HUGE **linbuf1;
  int i, lines;
  FSIZE n0, n1;
  FSIZE tem;
  FSIZE alloc_lines0, alloc_lines1;
  int buffered_prefix, prefix_count, prefix_mask;
  int ttt;

  if (filevec[0].desc != filevec[1].desc)
    {
      slurp (&filevec[0]);
      buffer0 = prepare_text_end (&filevec[0], 0);
      slurp (&filevec[1]);
      buffer1 = prepare_text_end (&filevec[1], 1);
    }
  else
    {
      slurp (&filevec[0]);
      buffer0 = prepare_text_end (&filevec[0], -1);
      filevec[1].buffer = filevec[0].buffer;
      filevec[1].bufsize = filevec[0].bufsize;
      filevec[1].buffered_chars = filevec[0].buffered_chars;
      buffer1 = buffer0;
    }

  /* Find identical prefix.  */

  p0 = buffer0;
  p1 = buffer1;

  n0 = filevec[0].buffered_chars - (buffer0 - filevec[0].buffer);
  n1 = filevec[1].buffered_chars - (buffer1 - filevec[1].buffer);

  if (p0 == p1)
    /* The buffers are the same; sentinels won't work.  */
    p0 = p1 += n1;
  else
    {
      /* Insert end sentinels, in this case characters that are guaranteed
         to make the equality test false, and thus terminate the loop.  */

      if (n0 < n1)
        p0[n0] = (char)(~p1[n0]);
      else
        p1[n1] = (char)(~p0[n1]);

      /* Loop until first mismatch, or to the sentinel characters.  */

      /* Compare a word at a time for speed.  */
      w0 = (word *) p0;
      w1 = (word *) p1;
      while (*w0++ == *w1++)
        ;
      --w0, --w1;

      /* Do the last few bytes of comparison a byte at a time.  */
      p0 = (char *) w0;
      p1 = (char *) w1;
      while (*p0++ == *p1++)
        ;
      --p0, --p1;

      /* Don't mistakenly count missing newline as part of prefix. */
      if (ROBUST_OUTPUT_STYLE (output_style)
        && (buffer0 + n0 - filevec[0].missing_newline < p0)
        !=
        (buffer1 + n1 - filevec[1].missing_newline < p1))
        --p0, --p1;
    }

  /* Now P0 and P1 point at the first nonmatching characters.  */

  /* Skip back to last line-beginning in the prefix,
     and then discard up to HORIZON_LINES lines from the prefix.  */
  i = horizon_lines;
  /* This loop can be done in one line, but isn't not easy to read, so unrolled into simple statements */
  while (p0 != buffer0)
    {
      /* we know p0[-1] == p1[-1], but maybe p0[0] != p1[0] */
      int linestart=0;
      if (p0[-1] == '\n')
        linestart=1;
      /* only count \r if not followed by a \n on either side */
      if (p0[-1] == '\r' && p0[0] != '\n' && p1[0] != '\n')
        linestart=1;
      if (linestart && !(i--))
        break;
    --p0, --p1;
    }

  /* Record the prefix.  */
  filevec[0].prefix_end = p0;
  filevec[1].prefix_end = p1;

  /* Find identical suffix.  */

  /* P0 and P1 point beyond the last chars not yet compared.  */
  p0 = buffer0 + n0;
  p1 = buffer1 + n1;

  if (! ROBUST_OUTPUT_STYLE (output_style)
      || filevec[0].missing_newline == filevec[1].missing_newline)
    {
      end0 = p0;  /* Addr of last char in file 0.  */

      /* Get value of P0 at which we should stop scanning backward:
         this is when either P0 or P1 points just past the last char
         of the identical prefix.  */
      beg0 = filevec[0].prefix_end + (n0 < n1 ? 0 : n0 - n1);

      /* Scan back until chars don't match or we reach that point.  */
      while (p0 != beg0)
        if (*--p0 != *--p1)
          {
            /* Point at the first char of the matching suffix.  */
            ++p0, ++p1;
            beg0 = p0;
            break;
          }

      /* Are we at a line-beginning in both files?  If not, add the rest of
         this line to the main body.  Discard up to HORIZON_LINES lines from
         the identical suffix.  Also, discard one extra line,
         because shift_boundaries may need it.  */
      i = horizon_lines + !((buffer0 == p0 || p0[-1] == '\n' || (p0[-1] == '\r' && p0[0] != '\n'))
          &&
          (buffer1 == p1 || p1[-1] == '\n' || (p1[-1] == '\r' && p1[0] != '\n')));
      while (i-- && p0 != end0)
        while (*p0++ != '\n' && (p0[-1] != '\r' || p0[0] == '\n'))
          ;

      p1 += p0 - (char HUGE *)beg0;
    }

  /* Record the suffix.  */
  filevec[0].suffix_begin = p0;
  filevec[1].suffix_begin = p1;

  /* Calculate number of lines of prefix to save.

     prefix_count == 0 means save the whole prefix;
     we need this with for options like -D that output the whole file.
     We also need it for options like -F that output some preceding line;
     at least we will need to find the last few lines,
     but since we don't know how many, it's easiest to find them all.

     Otherwise, prefix_count != 0.  Save just prefix_count lines at start
     of the line buffer; they'll be moved to the proper location later.
     Handle 1 more line than the context says (because we count 1 too many),
     rounded up to the next power of 2 to speed index computation.  */

  if (no_diff_means_no_output)
    {
      for (prefix_count = 1;  prefix_count < context + 1;  prefix_count *= 2)
        ;
      prefix_mask = prefix_count - 1;
	  assert((p0 - (char HUGE *)filevec[0].prefix_end) < INT_MAX);
      ttt = (int)(p0 - (char HUGE *)filevec[0].prefix_end);
      alloc_lines0
        = prefix_count
        + GUESS_LINES (0, 0, ttt)
        + context;
    }
  else
    {
      prefix_count = 0;
      prefix_mask = ~0;
      alloc_lines0 = GUESS_LINES (0, 0, n0);
    }

  lines = 0;
  linbuf0 = (char const HUGE **) xmalloc (alloc_lines0 * sizeof (*linbuf0));

  /* If the prefix is needed, find the prefix lines.  */
  if (! (no_diff_means_no_output
   && filevec[0].prefix_end == p0
   && filevec[1].prefix_end == p1))
    {
      p0 = buffer0;
      end0 = filevec[0].prefix_end;
      while (p0 != end0)
        {
          int l = lines++ & prefix_mask;
          if ((FSIZE)l == alloc_lines0)
            linbuf0 = (char const HUGE **) xrealloc ((void *)linbuf0, (alloc_lines0 *= 2)
               * sizeof(*linbuf0));
          linbuf0[l] = p0;
          /* Perry/WinMerge (2004-01-05) altered original diffutils loop "while (*p0++ != '\n') ;" for other EOLs */
          while (1)
            {
              char ch = *p0++;
              /* stop at any eol, \n or \r or \r\n */
              if (ch == '\n') break;
              if (ch == '\r' && (p0==end0 || *p0!='\n')) break;
            }
        }
    }
  buffered_prefix = prefix_count && context < lines ? context : lines;

  /* Allocate line buffer 1.  */
  tem = prefix_count ? filevec[1].suffix_begin - buffer1 : n1;
  ttt = (int)(filevec[1].prefix_end - buffer1);
  alloc_lines1
    = (buffered_prefix
       + GUESS_LINES (lines, ttt, tem)
       + context);
  linbuf1 = (char const HUGE **) xmalloc (alloc_lines1 * sizeof (*linbuf1));

  if (buffered_prefix != lines)
    {
      /* Rotate prefix lines to proper location.  */
      for (i = 0;  i < buffered_prefix;  i++)
        linbuf1[i] = linbuf0[(lines - context + i) & prefix_mask];
      for (i = 0;  i < buffered_prefix;  i++)
        linbuf0[i] = linbuf1[i];
    }

  /* Initialize line buffer 1 from line buffer 0.  */
  for (i = 0; i < buffered_prefix; i++)
    linbuf1[i] = linbuf0[i] - buffer0 + buffer1;

  /* Record the line buffer, adjusted so that
     linbuf*[0] points at the first differing line.  */
  filevec[0].linbuf = linbuf0 + buffered_prefix;
  filevec[1].linbuf = linbuf1 + buffered_prefix;
  filevec[0].linbuf_base = filevec[1].linbuf_base = - buffered_prefix;
  assert((alloc_lines0 - buffered_prefix) < INT_MAX);
  assert((alloc_lines1 - buffered_prefix) < INT_MAX);
  filevec[0].alloc_lines = (int)(alloc_lines0 - buffered_prefix);
  filevec[1].alloc_lines = (int)(alloc_lines1 - buffered_prefix);
  filevec[0].prefix_lines = filevec[1].prefix_lines = lines;
}

/* Largest primes less than some power of two, for nbuckets.  Values range
   from useful to preposterous.  If one of these numbers isn't prime
   after all, don't blame it on me, blame it on primes (6) . . . */
static int const primes[] =
{
  509,
  1021,
  2039,
  4093,
  8191,
  16381,
  32749,
#if 32767 < INT_MAX
  65521,
  131071,
  262139,
  524287,
  1048573,
  2097143,
  4194301,
  8388593,
  16777213,
  33554393,
  67108859,     /* Preposterously large . . . */
  134217689,
  268435399,
  536870909,
  1073741789,
  2147483647,
#endif
  0
};

static int isnulldev(const char* filename)
{
    return (_stricmp(filename, "NUL") == 0 || _stricmp(filename, "\\\\.\\NUL") == 0);
}

/* Given a vector of two file_data objects, read the file associated
   with each one, and build the table of equivalence classes.
   Return 1 if either file appears to be a binary file.
   If PRETEND_BINARY is nonzero, pretend they are binary regardless.  */
/* WinMerge: Add int * bin_file param for getting actual binary file
   If bin_file is given, then check both files for binary files,
   otherwise check second file only if first wasn't binary */
int
read_files (struct file_data filevec[], int pretend_binary, int *bin_file)
{
  int i;
  int skip_test = always_text_flag | pretend_binary;
  int appears_binary = 0;

  if (bin_file != NULL)
    *bin_file = 0;
  appears_binary = pretend_binary | sip (&filevec[0], skip_test);
  if (bin_file!=NULL && appears_binary)
    {
      *bin_file = 1;
    }

  if (filevec[0].desc != filevec[1].desc)
    {
      if (bin_file!=NULL)
        {
          appears_binary = pretend_binary | sip (&filevec[1], skip_test);
          if (appears_binary)
            *bin_file |= 0x2; // set second bit for second file
        }
      else
        appears_binary |= sip (&filevec[1], skip_test | appears_binary);
    }
	
	// Are both files Open and Regular (no Pipes, Directories, Devices (except NUL))
	if (filevec[0].desc < 0 || filevec[1].desc < 0 ||
        (!(S_ISREG (filevec[0].stat.st_mode)) && !isnulldev(filevec[0].name)) ||
		(!(S_ISREG (filevec[1].stat.st_mode)) && !isnulldev(filevec[1].name)))
      {
		assert(!S_ISCHR(filevec[0].stat.st_mode));
		assert(!S_ISCHR(filevec[1].stat.st_mode));
		return appears_binary;
      }

  if (appears_binary)
	{
		// Because of the way 3-way binary comparison works, both buffers need
		// to be exactly the same size.  It also makes sense if the buffers are
		// large enough to hold a large chunk of the file with each read(); 
		// within reason of course.  Note: if the buffers are too big, the 
		// multi-processor performance is degraded.
		
		// Note that one or both buffers already have some amount of data.

		const FSIZE tmax_reasonable = (1 << 19) -1;		// 2**19 bytes, about 524KB

		FSIZE tmax_bufsize = max ((size_t)filevec[0].stat.st_size, 
								  (size_t)filevec[1].stat.st_size);
		tmax_bufsize = min (tmax_bufsize, tmax_reasonable);
		
		FSIZE tmin_bufsize = max(filevec[0].buffered_chars, filevec[1].buffered_chars);
		tmax_bufsize = max (tmax_bufsize, tmin_bufsize);

		if (tmax_bufsize > filevec[0].bufsize)
		  {
			filevec[0].buffer = xrealloc (filevec[0].buffer, tmax_bufsize);
			filevec[0].bufsize = tmax_bufsize;
		  }
		if (filevec[0].desc != filevec[1].desc && tmax_bufsize > filevec[1].bufsize)
		  {
			filevec[1].buffer = xrealloc (filevec[1].buffer, tmax_bufsize);
			filevec[1].bufsize = tmax_bufsize;
		  }
	}
	  
  if (filevec[0].desc == filevec[1].desc)
	{
		// The files may be exactly the same file.  Give them the same buffer, etc.
		assert( filevec[1].buffer == NULL );

		filevec[1].buffer = filevec[0].buffer;
		filevec[1].bufsize = filevec[0].bufsize;
		filevec[1].buffered_chars = filevec[0].buffered_chars;
	}
	
  // Binary comparisons *must not* go past here;  line-break sentinel markers may 
  // be put into the buffers.  Since read_files() only gets called for filevec[0], 
  // this causes a false mis-compare of all binary files (because filevec[1] would 
  // never get these non-necessary changes).
  if (appears_binary)
		return 1;
		
  find_identical_ends (filevec);

  /* Don't slurp rest of file when comparing file to itself. */
  if (filevec[0].desc == filevec[1].desc)
    {
	  filevec[1].count_crs = filevec[0].count_crs;
	  filevec[1].count_lfs = filevec[0].count_lfs;
	  filevec[1].count_crlfs = filevec[0].count_crlfs;
	  filevec[1].count_zeros = filevec[0].count_zeros;
      return 0;
    }

  equivs_alloc = filevec[0].alloc_lines + filevec[1].alloc_lines + 1;
#ifdef __MSDOS__
  if ((equivs = (struct equivclass HUGE *) farmalloc ((long) equivs_alloc * sizeof(struct equivclass))) == NULL)
    fatal ("far memory exhausted");
#else
  equivs = (struct equivclass *) xmalloc (equivs_alloc * sizeof (struct equivclass));
#endif /*__MSDOS__*/
  /* Equivalence class 0 is permanently safe for lines that were not
     hashed.  Real equivalence classes start at 1. */
  equivs_index = 1;

  for (i = 0;  primes[i] < equivs_alloc / 3;  i++)
    if (! primes[i])
      abort ();
  nbuckets = primes[i];

  buckets = (int *) xmalloc (nbuckets * sizeof (*buckets));
  bzero (buckets, nbuckets * sizeof (*buckets));

  for (i = 0; i < 2; ++i)
    find_and_hash_each_line (&filevec[i]);

  filevec[0].equiv_max = filevec[1].equiv_max = equivs_index;

  free (equivs);
  free (buckets);

  return 0;
}
</file>

<file path="Winmerge-Src/Src/diffutils/src/mystat.cpp">
// my own _fstat() and _wstat() implementation for the bug https://connect.microsoft.com/VisualStudio/feedback/details/1600505/stat-not-working-on-windows-xp-using-v14-xp-platform-toolset-vs2015
#include "pch.h"
#include <sys/stat.h>
#include <io.h>
#include <cerrno>
#include <windows.h>

inline time_t filetime_to_time_t(const FILETIME& ft)
{
	if (ft.dwHighDateTime == 0 && ft.dwLowDateTime == 0)
		return 0;
	else
		return ((static_cast<time_t>(ft.dwHighDateTime) << 32) + ft.dwLowDateTime) / 10000000ULL - 11644473600ULL;
}

template<typename FileInfo>
inline void set_statbuf(const FileInfo& hfi, struct _stat64& buf)
{
	buf.st_size = (static_cast<__int64>(hfi.nFileSizeHigh) << 32) | hfi.nFileSizeLow;
	buf.st_atime = filetime_to_time_t(hfi.ftLastAccessTime);
	buf.st_mtime = filetime_to_time_t(hfi.ftLastWriteTime);
	buf.st_ctime = filetime_to_time_t(hfi.ftCreationTime);
	buf.st_mode = 
		((hfi.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? _S_IFDIR : _S_IFREG) |
		((hfi.dwFileAttributes & FILE_ATTRIBUTE_READONLY ) ? 
			 (_S_IREAD              | ( _S_IREAD              >> 3) | ( _S_IREAD              >> 6)) : 
			((_S_IREAD | _S_IWRITE) | ((_S_IREAD | _S_IWRITE) >> 3) | ((_S_IREAD | _S_IWRITE) >> 6)));
}

extern "C" int myfstat(int fd, struct _stat64 *buf)
{
	if (buf == nullptr)
	{
		errno = EINVAL;
		return -1;
	}
	HANDLE hFile = reinterpret_cast<HANDLE>(_get_osfhandle(fd));
	if (hFile == INVALID_HANDLE_VALUE)
	{
		errno = EBADF;
		return -1;
	}
	memset(buf, 0, sizeof(*buf));
	switch (GetFileType(hFile) & ~FILE_TYPE_REMOTE)
	{
	case FILE_TYPE_CHAR:
		buf->st_mode = _S_IFCHR;
		return 0;
	case FILE_TYPE_PIPE:
		buf->st_mode = _S_IFIFO;
		DWORD nBufferSize;
		if (PeekNamedPipe(hFile, nullptr, 0, nullptr, &nBufferSize, nullptr))
			buf->st_size = nBufferSize;
		return 0;
	case FILE_TYPE_DISK:
		BY_HANDLE_FILE_INFORMATION hfi;
		if (!GetFileInformationByHandle(hFile, &hfi))
		{
			errno = EBADF;
			return -1;
		}
		set_statbuf(hfi, *buf);
		return 0;
	default:
		errno = EBADF;
		return -1;
	}
}

extern "C" int mywstat(const wchar_t *filename, struct _stat64 *buf)
{
	if (buf == nullptr)
	{
		errno = EINVAL;
		return -1;
	}
	if (wcspbrk(filename, L"*?") != nullptr)
	{
		errno = ENOENT;
		return -1;
	}
	WIN32_FIND_DATAW ffd;
	HANDLE hFindFile = FindFirstFileW(filename, &ffd);
	if (hFindFile == INVALID_HANDLE_VALUE)
	{
		errno = ENOENT;
		return -1;
	}
	FindClose(hFindFile);
	memset(buf, 0, sizeof(*buf));
	set_statbuf(ffd, *buf);
	return 0;
}
</file>

<file path="Winmerge-Src/Src/diffutils/src/normal.c">
/* Normal-format output routines for GNU DIFF.
   Copyright (C) 1988, 1989, 1993 Free Software Foundation, Inc.

This file is part of GNU DIFF.

GNU DIFF is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GNU DIFF is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU DIFF; see the file COPYING.  If not, write to
the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */


#include "diff.h"

static void print_normal_hunk (struct change *);

/* Print the edit-script SCRIPT as a normal diff.
   INF points to an array of descriptions of the two files.  */

void
print_normal_script (struct change *script)
{
  print_script (script, find_change, print_normal_hunk);
}

/* Print a hunk of a normal diff.
   This is a contiguous portion of a complete edit script,
   describing changes in consecutive lines.  */

static void
print_normal_hunk (struct change *hunk)
{
  int first0, last0, first1, last1, deletes, inserts;
  register int i;
  //int trans_a, trans_b;
  //int trans_c, trans_d;

  /* Determine range of line numbers involved in each file.  */
  analyze_hunk (hunk, &first0, &last0, &first1, &last1, &deletes, &inserts, files);
  if (!deletes && !inserts)
    return;

  begin_output ();

  /* Print out the line number header for this hunk */
  print_number_range (',', &files[0], first0, last0);
  fprintf (outfile, "%c", change_letter (inserts, deletes));
  print_number_range (',', &files[1], first1, last1);
  fprintf (outfile, "\n");

  //translate_range (&files[0], first0, last0, &trans_a, &trans_b);
  //translate_range (&files[1], first1, last1, &trans_c, &trans_d);
  //printf("left=%d,%d   right=%d,%d\n", trans_a, trans_b, trans_c, trans_d);

  /* Print the lines that the first file has. */ 
  if (deletes)
    for (i = first0; i <= last0; i++)
      print_1_line ("<", &files[0].linbuf[i]);

  if (inserts && deletes)
    fprintf (outfile, "---\n");

  // Print the lines that the second file has.  
  if (inserts)
    for (i = first1; i <= last1; i++)
      print_1_line (">", &files[1].linbuf[i]);
}
</file>

<file path="Winmerge-Src/Src/diffutils/src/side.c">
/* sdiff-format output routines for GNU DIFF.
   Copyright (C) 1991, 1992, 1993 Free Software Foundation, Inc.

This file is part of GNU DIFF.

GNU DIFF is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY.  No author or distributor
accepts responsibility to anyone for the consequences of using it
or for whether it serves any particular purpose or works at all,
unless he says so in writing.  Refer to the GNU General Public
License for full details.

Everyone is granted permission to copy, modify and redistribute
GNU DIFF, but only under the conditions described in the
GNU General Public License.   A copy of this license is
supposed to have been given to you along with GNU DIFF so you
can know your rights and responsibilities.  It should be in a
file named COPYING.  Among other things, the copyright notice
and this notice must be preserved on all copies.  */


#include "diff.h"

static unsigned print_half_line (char const * const *, unsigned, unsigned);
static unsigned tab_from_to (unsigned, unsigned);
static void print_1sdiff_line (char const * const *, int, char const * const *);
static void print_sdiff_common_lines (int, int);
static void print_sdiff_hunk (struct change *);

/* Next line number to be printed in the two input files.  */
static DECL_TLS int next0, next1;

/* Print the edit-script SCRIPT as a sdiff style output.  */

void
print_sdiff_script (struct change *script)
{
  begin_output ();

  next0 = next1 = - files[0].prefix_lines;
  print_script (script, find_change, print_sdiff_hunk);

  print_sdiff_common_lines (files[0].valid_lines, files[1].valid_lines);
}

/* Tab from column FROM to column TO, where FROM <= TO.  Yield TO.  */

static unsigned
tab_from_to (unsigned from, unsigned to)
{
  FILE *out = outfile;
  unsigned tab;

  if (! tab_expand_flag)
    for (tab = from + TAB_WIDTH - from % TAB_WIDTH;  tab <= to;  tab += TAB_WIDTH)
      {
	putc ('\t', out);
	from = tab;
      }
  while (from++ < to)
    putc (' ', out);
  return to;
}

/*
 * Print the text for half an sdiff line.  This means truncate to width
 * observing tabs, and trim a trailing newline.  Returns the last column
 * written (not the number of chars).
 */
static unsigned
print_half_line (char const * const *line, unsigned indent, unsigned out_bound)
{
  FILE *out = outfile;
  register unsigned in_position = 0, out_position = 0;
  register char const
	HUGE *text_pointer = line[0],
	HUGE *text_limit = line[1];

  while (text_pointer < text_limit)
    {
      register unsigned char c = *text_pointer++;

      switch (c)
	{
	case '\t':
	  {
	    unsigned spaces = TAB_WIDTH - in_position % TAB_WIDTH;
	    if (in_position == out_position)
	      {
		unsigned tabstop = out_position + spaces;
		if (tab_expand_flag)
		  {
		    if (out_bound < tabstop)
		      tabstop = out_bound;
		    for (;  out_position < tabstop;  out_position++)
		      putc (' ', out);
		  }
		else
		  if (tabstop < out_bound)
		    {
		      out_position = tabstop;
		      putc (c, out);
		    }
	      }
	    in_position += spaces;
	  }
	  break;

	case '\r':
	  {
	    putc (c, out);
	    tab_from_to (0, indent);
	    in_position = out_position = 0;
	  }
	  break;

	case '\b':
	  if (in_position != 0 && --in_position < out_bound)
	    if (out_position <= in_position)
	      /* Add spaces to make up for suppressed tab past out_bound.  */
	      for (;  out_position < in_position;  out_position++)
		putc (' ', out);
	    else
	      {
		out_position = in_position;
		putc (c, out);
	      }
	  break;

	case '\f':
	case '\v':
	control_char:
	  if (in_position < out_bound)
	    putc (c, out);
	  break;

	default:
	  if (! isprint (c))
	    goto control_char;
	  /* falls through */
	case ' ':
	  if (in_position++ < out_bound)
	    {
	      out_position = in_position;
	      putc (c, out);
	    }
	  break;

	case '\n':
	  return out_position;
	}
    }

  return out_position;
}

/*
 * Print side by side lines with a separator in the middle.
 * 0 parameters are taken to indicate white space text.
 * Blank lines that can easily be caught are reduced to a single newline.
 */

static void
print_1sdiff_line (char const HUGE * const *left, int sep, char const HUGE * const *right)
{
  FILE *out = outfile;
  unsigned hw = sdiff_half_width, c2o = sdiff_column2_offset;
  unsigned col = 0;
  int put_newline = 0;
  
  if (left)
    {
      if (left[1][-1] == '\n')
	put_newline = 1;
      col = print_half_line (left, 0, hw);
    }

  if (sep != ' ')
    {
      col = tab_from_to (col, (hw + c2o - 1) / 2) + 1;
      if (sep == '|' && put_newline != (right[1][-1] == '\n'))
	sep = put_newline ? '/' : '\\';
      putc (sep, out);
    }

  if (right)
    {
      if (right[1][-1] == '\n')
	put_newline = 1;
      if (**right != '\n')
	{
	  col = tab_from_to (col, c2o);
	  print_half_line (right, col, hw);
	}
    }

  if (put_newline)
    putc ('\n', out);
}

/* Print lines common to both files in side-by-side format.  */
static void
print_sdiff_common_lines (int limit0, int limit1)
{
  int i0 = next0, i1 = next1;

  if (! sdiff_skip_common_lines  &&  (i0 != limit0 || i1 != limit1))
    {
      if (sdiff_help_sdiff)
	fprintf (outfile, "i%d,%d\n", limit0 - i0, limit1 - i1);

      if (! sdiff_left_only)
	{
	  while (i0 != limit0 && i1 != limit1)
	    print_1sdiff_line (&files[0].linbuf[i0++], ' ', &files[1].linbuf[i1++]);
	  while (i1 != limit1)
	    print_1sdiff_line (0, ')', &files[1].linbuf[i1++]);
	}
      while (i0 != limit0)
	print_1sdiff_line (&files[0].linbuf[i0++], '(', 0);
    }

  next0 = limit0;
  next1 = limit1;
}

/* Print a hunk of an sdiff diff.
   This is a contiguous portion of a complete edit script,
   describing changes in consecutive lines.  */

static void
print_sdiff_hunk (struct change *hunk)
{
  int first0, last0, first1, last1, deletes, inserts;
  register int i, j;

  /* Determine range of line numbers involved in each file.  */
  analyze_hunk (hunk, &first0, &last0, &first1, &last1, &deletes, &inserts, files);
  if (!deletes && !inserts)
    return;

  /* Print out lines up to this change.  */
  print_sdiff_common_lines (first0, first1);

  if (sdiff_help_sdiff)
    fprintf (outfile, "c%d,%d\n", last0 - first0 + 1, last1 - first1 + 1);

  /* Print ``xxx  |  xxx '' lines */
  if (inserts && deletes)
    {
      for (i = first0, j = first1;  i <= last0 && j <= last1; ++i, ++j)
	print_1sdiff_line (&files[0].linbuf[i], '|', &files[1].linbuf[j]);
      deletes = i <= last0;
      inserts = j <= last1;
      next0 = first0 = i;
      next1 = first1 = j;
    }


  /* Print ``     >  xxx '' lines */
  if (inserts)
    {
      for (j = first1; j <= last1; ++j)
	print_1sdiff_line (0, '>', &files[1].linbuf[j]);
      next1 = j;
    }

  /* Print ``xxx  <     '' lines */
  if (deletes)
    {
      for (i = first0; i <= last0; ++i)
	print_1sdiff_line (&files[0].linbuf[i], '<', 0);
      next0 = i;
    }
}
</file>

<file path="Winmerge-Src/Src/diffutils/src/system.h">
/* System dependent declarations.
   Copyright (C) 1988, 1989, 1992, 1993 Free Software Foundation, Inc.

This file is part of GNU DIFF.

GNU DIFF is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GNU DIFF is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU DIFF; see the file COPYING.  If not, write to
the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */

#pragma once

/* We must define `volatile' and `const' first (the latter inside config.h),
   so that they're used consistently in all system includes.  */
#if !defined(__STDC__) && !defined(_MSC_VER)
#ifndef volatile
#define volatile
#endif
#endif
#include <config.h>

#include <sys/types.h>
#include <sys/stat.h>

#if STAT_MACROS_BROKEN
#undef S_ISBLK
#undef S_ISCHR
#undef S_ISDIR
#undef S_ISFIFO
#undef S_ISREG
#undef S_ISSOCK
#endif
#ifndef S_ISDIR
#define S_ISDIR(mode) (((mode) & S_IFMT) == S_IFDIR)
#endif
#ifndef S_ISREG
#define S_ISREG(mode) (((mode) & S_IFMT) == S_IFREG)
#endif
#if !defined(S_ISBLK) && defined(S_IFBLK)
#define S_ISBLK(mode) (((mode) & S_IFMT) == S_IFBLK)
#endif
#if !defined(S_ISCHR) && defined(S_IFCHR)
#define S_ISCHR(mode) (((mode) & S_IFMT) == S_IFCHR)
#endif
#if !defined(S_ISFIFO) && defined(S_IFFIFO)
#define S_ISFIFO(mode) (((mode) & S_IFMT) == S_IFFIFO)
#endif
#if !defined(S_ISSOCK) && defined(S_IFSOCK)
#define S_ISSOCK(mode) (((mode) & S_IFMT) == S_IFSOCK)
#endif

#ifndef S_IXOTH
#define S_IXOTH 1
#endif
#ifndef S_IXGRP
#define S_IXGRP (S_IXOTH << 3)
#endif
#ifndef S_IXUSR
#define S_IXUSR (S_IXGRP << 3)
#endif

#if HAVE_UNISTD_H
#include <unistd.h>
#endif

#ifndef SEEK_SET
#define SEEK_SET 0
#endif
#ifndef SEEK_CUR
#define SEEK_CUR 1
#endif

#ifndef STDIN_FILENO
#define STDIN_FILENO 0
#endif
#ifndef STDOUT_FILENO
#define STDOUT_FILENO 1
#endif
#ifndef STDERR_FILENO
#define STDERR_FILENO 2
#endif

#if HAVE_TIME_H
#include <time.h>
#else
#include <sys/time.h>
#endif

#if HAVE_FCNTL_H
#include <fcntl.h>
#else
#include <sys/file.h>
#endif

#if !HAVE_DUP2
#define dup2(f,t)	(close (t),  fcntl (f,F_DUPFD,t))
#endif

#ifndef O_RDONLY
#define O_RDONLY 0
#endif

#if HAVE_SYS_WAIT_H
#ifndef _POSIX_VERSION
/* Prevent the NeXT prototype using union wait from causing problems.  */
#define wait system_wait
#endif
#include <sys/wait.h>
#ifndef _POSIX_VERSION
#undef wait
#endif
#endif /* HAVE_SYS_WAIT_H */

#ifndef WEXITSTATUS
#define WEXITSTATUS(stat_val) ((unsigned)(stat_val) >> 8)
#undef WIFEXITED		/* Avoid 4.3BSD incompatibility with Posix.  */
#endif
#ifndef WIFEXITED
#define WIFEXITED(stat_val) (((stat_val) & 255) == 0)
#endif

#if HAVE_ST_BLKSIZE
#define STAT_BLOCKSIZE(s) (s).st_blksize
#else
#define STAT_BLOCKSIZE(s) (8 * 1024)
#endif

#if HAVE_VFORK_H
#include <vfork.h>
#endif

#if HAVE_STDLIB_H
#include <stdlib.h>
#else
void *malloc ();
void *realloc ();
#endif
//#ifndef getenv
//extern char *getenv ();
//#endif

#if HAVE_LIMITS_H
#include <limits.h>
#endif
#ifndef INT_MAX
#define INT_MAX 2147483647
#endif
#ifndef CHAR_BIT
#define CHAR_BIT 8
#endif

#if HAVE_STRING_H
#include <string.h>
#ifndef bzero
#define bzero(s,n) memset (s,0,n)
#endif
#else /* !HAVE_STRING_H */
#include <strings.h>
#ifndef strchr
#define strchr index
#endif
#ifndef strrchr
#define strrchr rindex
#endif
#ifndef memcpy
#define memcpy(d,s,n) bcopy (s,d,n)
#endif
#ifndef memcmp
#define memcmp(s1,s2,n) bcmp (s1,s2,n)
#endif
#endif /* !HAVE_STRING_H */
#if !HAVE_MEMCHR
char *memchr ();
#endif

#include <errno.h>
#if !STDC_HEADERS
extern int errno;
#endif

#ifndef min
#define min(a,b) ((a) <= (b) ? (a) : (b))
#define max(a,b) ((a) >= (b) ? (a) : (b))
#endif

#ifdef __MSDOS__
typedef int pid_t;
typedef long off_t;
#include <stdio.h>
#include <malloc.h>
FILE *popen(char *, char *);
int pclose(FILE *);
#define HUGE huge
#define FSIZE long
#else
#define HUGE
#define FSIZE size_t
#endif

#if defined(__NT__) || defined(WIN32)
#ifndef _PID_T_
typedef int pid_t;
#endif
#define popen	_popen
#define pclose	_pclose
#endif
</file>

<file path="Winmerge-Src/Src/diffutils/src/util.c">
/* Support routines for GNU DIFF.
   Copyright (C) 1988, 1989, 1992, 1993 Free Software Foundation, Inc.

This file is part of GNU DIFF.

GNU DIFF is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GNU DIFF is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU DIFF; see the file COPYING.  If not, write to
the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */

#include <windows.h>
#include "diff.h"

/* Queue up one-line messages to be printed at the end,
   when -l is specified.  Each message is recorded with a `struct msg'.  */

struct msg
{
  struct msg *next;
  char const *format;
  char const *arg1;
  char const *arg2;
  char const *arg3;
  char const *arg4;
};

/* Head of the chain of queues messages.  */

static struct msg *msg_chain;

/* Tail of the chain of queues messages.  */

static struct msg **msg_chain_end = &msg_chain;

/* Use when a system call returns non-zero status.
   TEXT should normally be the file name.  */

void
perror_with_name (char const *text)
{
  int e = errno;
  fprintf (stderr, "%s: ", program);
  errno = e;
  perror (text);
}

/* Use when a system call returns non-zero status and that is fatal.  */

void
pfatal_with_name (char const *text)
{
  int e = errno;
  print_message_queue ();
  fprintf (stderr, "%s: ", program);
  errno = e;
  perror (text);
  //exit (2);
  RaiseException(STATUS_ACCESS_VIOLATION, 0, 0, NULL);
}

/* Print an error message from the format-string FORMAT
   with args ARG1 and ARG2.  */

void
error (char const *format, char const *arg, char const *arg1)
{
  fprintf (stderr, "%s: ", program);
  fprintf (stderr, format, arg, arg1);
  fprintf (stderr, "\n");
}

/* Print an error message containing the string TEXT, then exit.  */

void
fatal (char const *m)
{
  print_message_queue ();
  error ("%s", m, 0);
  //exit (2);
  RaiseException(STATUS_ACCESS_VIOLATION, 0, 0, NULL);
}

/* Like printf, except if -l in effect then save the message and print later.
   This is used for things like "binary files differ" and "Only in ...".  */

void
message (char const *format, char const *arg1, char const *arg2)
{
  message5 (format, arg1, arg2, 0, 0);
}

void
message5 (char const *format, char const *arg1, char const *arg2, char const *arg3, char const *arg4)
{
  if (paginate_flag)
    {
      struct msg *new = (struct msg *) xmalloc (sizeof (struct msg));
      new->format = format;
      new->arg1 = concat (arg1, "", "");
      new->arg2 = concat (arg2, "", "");
      new->arg3 = arg3 ? concat (arg3, "", "") : 0;
      new->arg4 = arg4 ? concat (arg4, "", "") : 0;
      new->next = NULL;
      *msg_chain_end = new;
      msg_chain_end = &new->next;
    }
  else
    {
      if (sdiff_help_sdiff)
	putchar (' ');
      printf (format, arg1, arg2, arg3, arg4);
    }
}

/* Output all the messages that were saved up by calls to `message'.  */

void
print_message_queue ()
{
  struct msg *m;

  for (m = msg_chain; m; m = m->next)
    printf (m->format, m->arg1, m->arg2, m->arg3, m->arg4);
}

/* Call before outputting the results of comparing files NAME0 and NAME1
   to set up OUTFILE, the stdio stream for the output to go to.

   Usually, OUTFILE is just stdout.  But when -l was specified
   we fork off a `pr' and make OUTFILE a pipe to it.
   `pr' then outputs to our stdout.  */

static char const *current_name0;
static char const *current_name1;
static int current_depth;

void
setup_output (char const *name0, char const *name1, int depth)
{
  current_name0 = name0;
  current_name1 = name1;
  current_depth = depth;
  outfile = NULL;
}

static pid_t pr_pid;

void
begin_output ()
{
  char *name;

  if (outfile != NULL)
    return;

  char *mySwitch = (switch_string != NULL ? switch_string : "");

  /* Construct the header of this piece of diff.  */
  const size_t nameSiz = strlen(current_name0) + strlen(current_name1)
	  + strlen(mySwitch) + 7;
  name = xmalloc (nameSiz);
  /* Posix.2 section 4.17.6.1.1 specifies this format.  But there are some
     bugs in the first printing (IEEE Std 1003.2-1992 p 251 l 3304):
     it says that we must print only the last component of the pathnames,
     and it requires two spaces after "diff" if there are no options.
     These requirements are silly and do not match historical practice.  */
  sprintf_s (name, nameSiz, "diff%s %s %s", mySwitch, current_name0, current_name1);

  if (paginate_flag)
    {
#if defined(__MSDOS__) || defined(__NT__) || defined(WIN32)
      char command[120];

      sprintf_s(command, sizeof(command), "%s -f -h \"%s\"", PR_FILE_NAME, name);
      if ((outfile = popen(command, "w")) == NULL)
        pfatal_with_name ("popen");
#else
      int pipes[2];

      /* Fork a `pr' and make OUTFILE a pipe to it.  */
      if (pipe (pipes) < 0)
	pfatal_with_name ("pipe");

      fflush (stdout);

      pr_pid = vfork ();
      if (pr_pid < 0)
	pfatal_with_name ("vfork");

      if (pr_pid == 0)
	{
	  close (pipes[1]);
	  if (pipes[0] != STDIN_FILENO)
	    {
	      if (dup2 (pipes[0], STDIN_FILENO) < 0)
		pfatal_with_name ("dup2");
	      close (pipes[0]);
	    }

	  execl (PR_FILE_NAME, PR_FILE_NAME, "-f", "-h", name, 0);
	  pfatal_with_name (PR_FILE_NAME);
	}
      else
	{
	  close (pipes[0]);
	  outfile = fdopen (pipes[1], "w");
	}
#endif /*__MSDOS__||__NT__*/
    }
  else
    {

      /* If -l was not specified, output the diff straight to `stdout'.  */

      outfile = stdout;

      /* If handling multiple files (because scanning a directory),
	 print which files the following output is about.  */
      if (current_depth > 0)
	printf ("%s\n", name);
    }

  free (name);

  /* A special header is needed at the beginning of context output.  */
  switch (output_style)
    {
    case OUTPUT_CONTEXT:
      print_context_header (files, 0);
      break;

    case OUTPUT_UNIFIED:
      print_context_header (files, 1);
      break;

    default:
      break;
    }
}

/* Call after the end of output of diffs for one file.
   Close OUTFILE and get rid of the `pr' subfork.  */

void
finish_output ()
{
  if (outfile != NULL && outfile != stdout)
    {
#if defined(__MSDOS__) || defined(__NT__) || defined(WIN32)
      if (pclose (outfile))
	pfatal_with_name ("write error");
#else
      int wstatus;
      if (ferror (outfile))
	fatal ("write error");
      if (fclose (outfile) != 0)
	pfatal_with_name ("write error");
#if HAVE_WAITPID
      if (waitpid (pr_pid, &wstatus, 0) < 0)
	pfatal_with_name ("waitpid");
#else
      for (;;) {
	pid_t w = wait (&wstatus);
	if (w < 0)
	  pfatal_with_name ("wait");
	if (w == pr_pid)
	  break;
      }
#endif
      if (! WIFEXITED (wstatus) || WEXITSTATUS (wstatus) != 0)
	fatal ("subsidiary pr failed");
#endif /*__MSDOS__||__NT__*/
    }

  outfile = NULL;
}


static int
ISWSPACE (char ch)
{
	return ch==' ' || ch=='\t';
}

/* Compare two lines (typically one from each input file)
   according to the command line options.
   Return 1 if the lines differ, like `memcmp'.  */

int
line_cmp (char const *s1, size_t len1, char const *s2, size_t len2)
{
  register unsigned char const *t1, *t2;
  register unsigned char end_char = line_end_char;

  /* Check first for exact identity.
     If that is true, return 0 immediately.
     This detects the common case of exact identity
     faster than complete comparison would.  */

  if (len1 == len2 && memcmp (s1, s2, len1) == 0)
    return 0;

  /* Not exactly identical, but perhaps they match anyway
     when case or white space is ignored.  */
  /* c1 is the current character value for the line s1, it is set to 0
     when the line has been entirely scanned.
     c2 is the equivalent of c1 for the line s2 */

  if (ignore_case_flag | ignore_space_change_flag | ignore_all_space_flag | ignore_eol_diff | ignore_numbers_flag)
    {
      t1 = (unsigned char const *) s1;
      t2 = (unsigned char const *) s2;

      while (1)
	{
	  register unsigned char c1;
	  register unsigned char c2;
	  if (t1-(unsigned char *)s1<(int)len1)
	    c1 = *t1++;
	  else
	    c1 = 0;
	  if (t2-(unsigned char *)s2<(int)len2)
	    c2 = *t2++;
	  else
	    c2 = 0;

      /* Test for exact char equality first, since it's a common case.  */
      if (c1 != c2)
	{
	  /* Ignore horizontal white space if -b or -w is specified.  */

	  if (ignore_all_space_flag)
	    {
	      /* For -w, just skip past any white space.  */
	      while (ISWSPACE (c1))
		{
		  if (t1-(unsigned char *)s1<(int)len1)
		    {
		      c1 = *t1++;
		    }
		  else
		    {
		      c1 = 0;
		      break;
		    }
		}
	      while (ISWSPACE (c2))
		{
		  if (t2-(unsigned char *)s2<(int)len2)
		    {
		      c2 = *t2++;
		    }
		  else
		    {
		      c2 = 0;
		      break;
		    }
		}
	    }
	  else if (ignore_space_change_flag)
	    {
	      /* For -b, advance past any sequence of white space in line 1
		 and consider it just one Space, or nothing at all
		 if it is at the end of the line.  */
	      if (ISWSPACE (c1))
		{
		  /* Any whitespace sequence counts as one space */
		  c1 = ' ';
		  /* Skip to end of whitespace sequence */
		  while (t1-(unsigned char *)s1<(int)len1 && ISWSPACE(*t1))
		    ++t1;
		  /* if c1 is whitespace and c2 is end of line
		  we must advance c1 to next char, because c1
		  whitespace matches the nothing in c2 */
		  if (c2=='\r' || c2=='\n')
		    {
		      if (t1-(unsigned char *)s1<(int)len1)
			c1 = *t1++;
		      else
			c1 = 0;
		    }
		}

	      /* Likewise for line 2.  */
	      if (ISWSPACE (c2))
		{
		  /* Any whitespace sequence counts as one space */
		  c2 = ' ';
		  /* Skip to end of whitespace sequence */
		  while (t2-(unsigned char *)s2<(int)len2 && ISWSPACE(*t2))
		    ++t2;
		  /* if c2 is whitespace and c1 is end of line
		  we must advance c1 to next char, because c2
		  whitespace matches the nothing in c1 */
		  if (c1=='\r' || c1=='\n')
		    {
		      if (t2-(unsigned char *)s2<(int)len2)
			c2 = *t2++;
		      else
			c2 = 0;
		    }
		}

	      /*
	      Whitespace at end of line matches end of file
	      make them both say ' ' so they match, and the one
	      not at end will get advanced
	      */
	      if (c1 != c2)
	        {
		  if (c1==' ' && !c2)
		    c2 = ' ';
		  else if (c2==' ' && !c1)
		    c1 = ' ';
	        }

	      if (c1 != c2)
		{
		  /* backtracking necessary when matching "cat and" against "cat  and"
		     because the spaces got matched with equality, so now "a" and " "
		     are mismatches */

		  /* If we went too far when doing the simple test
		     for equality, go back to the first non-white-space
		     character in both sides and try again.  */
		  if (c2 == ' ' && c1 && c1 != '\n' && c1 != '\r'
		      && (unsigned char const *) s1 + 1 < t1
		      && isspace(t1[-2]))
		    {
		      --t1;
		      continue;
		    }
		  if (c1 == ' ' && c2 && c2 != '\n' && c2 != '\r'
		      && (unsigned char const *) s2 + 1 < t2
		      && isspace(t2[-2]))
		    {
		      --t2;
		      continue;
		    }
		}
	    }

		if (ignore_numbers_flag)
		{
			/* For ..., just skip past any numbers.  */
			while (isdigit(c1))
			{
				if (t1 - (unsigned char*)s1 < (int)len1)
				{
					c1 = *t1++;
				}
				else
				{
					c1 = 0;
					break;
				}
			}
			while (isdigit(c2))
			{
				if (t2 - (unsigned char*)s2 < (int)len2)
				{
					c2 = *t2++;
				}
				else
				{
					c2 = 0;
					break;
				}
			}
		}

	  /* Upcase all letters if -i is specified.  */

	  if (ignore_case_flag)
	    {
	      if (isupper (c1))
	        c1 = (unsigned char)tolower (c1);
	      if (isupper(c2))
	        c2 = (unsigned char)tolower (c2);
	    }

	  if (ignore_eol_diff)
	    {
	      if (c1 == '\r')
		c1 = 0;
	      else if (c2 == '\r')
		c2 = 0;
	    }

	  if (c1 != c2)
	    break;
	  }

	  /* If we got here, c1 == c2 */

	  if (!c1)
	    return 0;
	}
    }

  return 1;
}

/* Find the consecutive changes at the start of the script START.
   Return the last link before the first gap.  */

struct change *
find_change (struct change *start)
{
  return start;
}

struct change *
find_reverse_change (struct change *start)
{
  return start;
}

/* Divide SCRIPT into pieces by calling HUNKFUN and
   print each piece with PRINTFUN.
   Both functions take one arg, an edit script.

   HUNKFUN is called with the tail of the script
   and returns the last link that belongs together with the start
   of the tail.

   PRINTFUN takes a subscript which belongs together (with a null
   link at the end) and prints it.  */

void
print_script (struct change *script, 
				struct change *(*hunkfun) (struct change *), 
				void (*printfun) (struct change *) )
{
  struct change *next = script;

  while (next)
    {
      struct change *this, *end;

      /* Find a set of changes that belong together.  */
      this = next;
      end = (*hunkfun) (next);

      /* Disconnect them from the rest of the changes,
	 making them a hunk, and remember the rest for next iteration.  */
      next = end->link;
      end->link = NULL;
#ifdef DEBUG
      debug_script (this);
#endif

      /* Print this hunk.  */
      (*printfun) (this);

      /* Reconnect the script so it will all be freed properly.  */
      end->link = next;
    }
}

/* Print the text of a single line LINE,
   flagging it with the characters in LINE_FLAG (which say whether
   the line is inserted, deleted, changed, etc.).  */

void
print_1_line (char const *line_flag, char const * const *line)
{
  char const HUGE *text = line[0], HUGE *limit = line[1]; /* Help the compiler.  */
  FILE *out = outfile; /* Help the compiler some more.  */
  char const *flag_format = NULL;

  /* If -T was specified, use a Tab between the line-flag and the text.
     Otherwise use a Space (as Unix diff does).
     Print neither space nor tab if line-flags are empty.  */

  if (line_flag != NULL && *line_flag != 0)
    {
      flag_format = tab_align_flag ? "%s\t" : "%s ";
      fprintf (out, flag_format, line_flag);
    }

  output_1_line (text, limit, flag_format, line_flag);

  if ((line_flag == NULL || line_flag[0]) && limit[-1] != '\n' && limit[-1] != '\r'
      && line_end_char == '\n')
    fprintf (out, "\n\\ No newline at end of file\n");
}

/*
A version of fwrite which converts any embedded \r or \n or \r\n to \n
before passing it to fwrite. This is meant to be used with mixed eol mode input
being written to a text mode stream.
*/
static size_t
fwrite_textify( const void *buffer, size_t size, size_t count, FILE *stream )
{
	/*
	\r = carriage return
	\n = line feed
	We have to handle the carriage returns (\r) specially
	because some of them may be the first half of a \r\n pair
	We output \r\n for any solo \r or solo \n, but also for any \r\n pair
	so the tricky part is just avoiding outputing \r\n\r\n for the \r\n pair.
	*/

	size_t bytes=0;
	unsigned int i;
	const char * text = buffer;
	int cr = 0;
	char ch;
	i = 0;
	while (1)
	{
		// first handle any pending carriage returns
		// before even checking if we've finished file
		if (cr)
		{
			// currently handling a carriage return
			// we always finish the line for carriage returns
			bytes += fwrite("\n", 1, 1, stream);
			if (i==size*count)
			{
				// we're done
				return bytes;
			}
			// now check to see if we need to swallow the trailing line feed
			// of a carriage return/line feed pair (\r\n)
			if (text[i] == '\n')
				++i;
			// finished the pending carriage return
			cr = 0;
		}
		// check if we finished
		if (i==size*count)
			return bytes;
		ch = text[i];
		// first check if new character is a carriage return
		if (ch == '\r')
		{
			// activate our special mode flag, and go to next character
			cr = 1;
			++i;
			continue;
		}
		// (any bare \n characters are ok, stream will convert them)
		bytes += fwrite(&text[i], 1, 1, stream);
		++i;
	}
}


/* Output a line from TEXT up to LIMIT.  Without -t, output verbatim.
   With -t, expand white space characters to spaces, and if FLAG_FORMAT
   is nonzero, output it with argument LINE_FLAG after every
   internal carriage return, so that tab stops continue to line up.  */

void
output_1_line (char const *text, char const *limit, char const *flag_format, char const *line_flag)
{
  char * pos = NULL;
  if (!tab_expand_flag)
    fwrite_textify (text, sizeof (char), limit - text, outfile);
  else
    {
      register FILE *out = outfile;
      register unsigned char c;
      register char const HUGE *t = text;
      register unsigned column = 0;

      while (t < limit)
	switch ((c = *t++))
	  {
	  case '\t':
	    {
	      unsigned spaces = TAB_WIDTH - column % TAB_WIDTH;
	      column += spaces;
	      do
		putc (' ', out);
	      while (--spaces);
	    }
	    break;

	  case '\r':
	    putc (c, out);
	    if (flag_format && t < limit && *t != '\n')
	      fprintf (out, flag_format, line_flag);
	    column = 0;
	    break;

	  case '\b':
	    if (column == 0)
	      continue;
	    column--;
	    putc (c, out);
	    break;

	  default:
	    if (isprint (c))
	      column++;
	    putc (c, out);
	    break;
	  }
    }
}

int
change_letter (int inserts, int deletes)
{
  if (!inserts)
    return 'd';
  else if (!deletes)
    return 'a';
  else
    return 'c';
}

/* Translate an internal line number (an index into diff's table of lines)
   into an actual line number in the input file.
   The internal line number is LNUM.  FILE points to the data on the file.

   Internal line numbers count from 0 starting after the prefix.
   Actual line numbers count from 1 within the entire file.  */

int
translate_line_number (struct file_data const *file, int lnum)
{
  return lnum + file->prefix_lines + 1;
}

void
translate_range (struct file_data const *file, int a, int b, int *aptr, int *bptr)
{
  *aptr = translate_line_number (file, a - 1) + 1;
  *bptr = translate_line_number (file, b + 1) - 1;
}

/* Print a pair of line numbers with SEPCHAR, translated for file FILE.
   If the two numbers are identical, print just one number.

   Args A and B are internal line numbers.
   We print the translated (real) line numbers.  */

void
print_number_range (int sepchar, struct file_data *file, int a, int b)
{
  int trans_a, trans_b;
  translate_range (file, a, b, &trans_a, &trans_b);

  /* Note: we can have B < A in the case of a range of no lines.
     In this case, we should print the line number before the range,
     which is B.  */
  if (trans_b > trans_a)
    fprintf (outfile, "%d%c%d", trans_a, sepchar, trans_b);
  else
    fprintf (outfile, "%d", trans_b);
}

int iseolch (char ch)
{
  return ch=='\n' || ch=='\r';
}

int is_blank_line (char const *pch, char const *limit)
{
  while (pch < limit)
    {
      if ((*pch) == '\n' || (*pch) == '\r')
        break;
      if ((*pch) != ' ' && (*pch) != '\t')
        return 0;
      pch++;
    }
  return 1;
}

/* Look at a hunk of edit script and report the range of lines in each file
   that it applies to.  HUNK is the start of the hunk, which is a chain
   of `struct change'.  The first and last line numbers of file 0 are stored in
   *FIRST0 and *LAST0, and likewise for file 1 in *FIRST1 and *LAST1.
   Note that these are internal line numbers that count from 0.

   If no lines from file 0 are deleted, then FIRST0 is LAST0+1.

   Also set *DELETES nonzero if any lines of file 0 are deleted
   and set *INSERTS nonzero if any lines of file 1 are inserted.
   If only ignorable lines are inserted or deleted, both are
   set to 0.  */

void
analyze_hunk (struct change *hunk, 
    int *first0, int *last0, 
    int *first1, int *last1, 
    int *deletes, int *inserts, const struct file_data fd[])
{
  int l0, l1, show_from, show_to;
  int i;
  int trivial = ignore_blank_lines_flag;
  struct change *next;

  show_from = show_to = 0;

  *first0 = hunk->line0;
  *first1 = hunk->line1;

  next = hunk;
  do
    {
      l0 = next->line0 + next->deleted - 1;
      l1 = next->line1 + next->inserted - 1;
      show_from += next->deleted;
      show_to += next->inserted;

      for (i = next->line0; i <= l0 && trivial; i++)
        {
          if (!ignore_blank_lines_flag)
            {
              trivial = 0;
            }
          else if (ignore_all_space_flag | ignore_space_change_flag)
            {
              if (!is_blank_line(fd[0].linbuf[i], fd[0].linbuf[i + 1]))
                trivial = 0;
            }
          else if (!iseolch(fd[0].linbuf[i][0]) && fd[0].linbuf[i][0] != 0)
            {
              trivial = 0;
            }
        }
      for (i = next->line1; i <= l1 && trivial; i++)
        {
          if (!ignore_blank_lines_flag)
            {
              trivial = 0;
            }
          else if (ignore_all_space_flag | ignore_space_change_flag)
            {
              if (!is_blank_line(fd[1].linbuf[i], fd[1].linbuf[i + 1]))
                trivial = 0;
            }
          else if (!iseolch(fd[1].linbuf[i][0]) && fd[1].linbuf[i][0] != 0)
            {
              trivial = 0;
            }
        }
    }
  while ((next = next->link) != NULL);

  *last0 = l0;
  *last1 = l1;

  /* If all inserted or deleted lines are ignorable,
     tell the caller to ignore this hunk.  */
  if (trivial)
    show_from = show_to = 0;

  /* WinMerge editor needs to know if there were trivial changes though,
     so stash that off in the trivial field */
  if (trivial)
    hunk->trivial = 1;
  else
    hunk->trivial = 0;

  *deletes = show_from;
  *inserts = show_to;
}

/* malloc a block of memory, with fatal error message if we can't do it. */

VOID *
xmalloc (size_t size)
{
  register VOID *value;

  if (size == 0)
    size = 1;

  value = (VOID *) malloc (size);

  if (!value)
#ifdef __MSDOS__
    fatal ("real memory exhausted");
#else
    fatal ("virtual memory exhausted");
#endif
  return value;
}

/* realloc a block of memory, with fatal error message if we can't do it. */

VOID *
xrealloc (VOID *old, size_t size)
{
  register VOID *value;

  if (size == 0)
    size = 1;

  value = (VOID *) realloc (old, size);

  if (!value)
#ifdef __MSDOS__
    fatal ("real memory exhausted");
#else
    fatal ("virtual memory exhausted");
#endif
  return value;
}

/* Concatenate three strings, returning a newly malloc'd string.  */

char *
concat (char const *s1, char const *s2, char const *s3)
{
  size_t len = strlen (s1) + strlen (s2) + strlen (s3);
  char *new = xmalloc (len + 1);
  sprintf_s (new, len+1, "%s%s%s", s1, s2, s3);
  return new;
}

/* Yield the newly malloc'd pathname
   of the file in DIR whose filename is FILE.  */

char *
dir_file_pathname (char const *dir, char const *file)
{
#if defined(__MSDOS__) || defined(__NT__) || defined(WIN32)
  char sep = dir[strlen(dir) - 1];
  return concat (dir, "\\" + (*dir && ((sep == '/') || (sep == '\\'))), file);
#else
  return concat (dir, "/" + (*dir && dir[strlen (dir) - 1] == '/'), file);
#endif /*__MSDOS__||__NT__*/
}

void
debug_script (struct change *sp)
{
  fflush (stdout);
  for (; sp!=NULL; sp = sp->link)
    fprintf (stderr, "%3d %3d delete %d insert %d\n",
	     sp->line0, sp->line1, sp->deleted, sp->inserted);
  fflush (stderr);
}

#if !HAVE_MEMCHR
char *
memchr (s, c, n)
     char const *s;
     int c;
     size_t n;
{
  unsigned char const *p = (unsigned char const *) s, *lim = p + n;
  for (;  p < lim;  p++)
    if (*p == c)
      return (char *) p;
  return NULL;
}
#endif
</file>

<file path="Winmerge-Src/Src/FilterEngine/FileContentRef.cpp">
#include "pch.h"
#include "FileContentRef.h"
#include "UnicodeString.h"
#include "OptionsMgr.h"
#include "OptionsDef.h"
#include "UniFile.h"
#include "codepage_detect.h"
#include "paths.h"
#include "MergeApp.h"
#include <algorithm>
#include <functional>
#include <Poco/RegularExpression.h>
#include <Poco/FileStream.h>
#include <Poco/Exception.h>

static void GuessEncoding(UniMemFile& file, const String& path)
{
	file.ReadBom();
	if (!file.HasBom())
	{
		int iGuessEncodingType = GetOptionsMgr()->GetInt(OPT_CP_DETECT);
		int64_t fileSize = file.GetFileSize();
		FileTextEncoding encoding = codepage_detect::Guess(
			paths::FindExtension(path), file.GetBase(), static_cast<size_t>(
				fileSize < static_cast<int64_t>(codepage_detect::BufSize) ?
				fileSize : static_cast<int64_t>(codepage_detect::BufSize)),
			iGuessEncodingType);
		file.SetCodepage(encoding.m_codepage);
	}
}

bool FileContentRef::operator==(const FileContentRef& other) const
{
	try {
		Poco::FileInputStream fs1(ucr::toUTF8(path), std::ios::binary);
		Poco::FileInputStream fs2(ucr::toUTF8(other.path), std::ios::binary);

		if (!fs1.good() || !fs2.good()) return false;

		const size_t bufferSize = 4096;
		char buffer1[bufferSize];
		char buffer2[bufferSize];

		while (true) {
			fs1.read(buffer1, bufferSize);
			fs2.read(buffer2, bufferSize);

			std::streamsize count1 = fs1.gcount();
			std::streamsize count2 = fs2.gcount();

			if (count1 != count2) return false;
			if (count1 == 0) return true; // end of both

			if (std::memcmp(buffer1, buffer2, static_cast<size_t>(count1)) != 0)
				return false;
		}
	}
	catch (const Poco::Exception&)
	{
		return false;
	}
}

bool FileContentRef::Contains(const std::string& str) const
{
	UniMemFile file;
	if (!file.OpenReadOnly(path))
		return false;
	GuessEncoding(file, path);
	String searchStr = ucr::toTString(str);
	strutils::makelower(searchStr);
	std::boyer_moore_horspool_searcher<String::const_iterator> searcher(searchStr.begin(), searchStr.end());
	bool linesToRead = true;
	bool found = false;
	do
	{
		bool lossy;
		String line, eol;
		linesToRead = file.ReadString(line, eol, &lossy);
		strutils::makelower(line);
		using iterator = String::const_iterator;
		std::pair<iterator, iterator> result = searcher(line.begin(), line.end());
		if (result.first != result.second)
		{
			found = true;
			break;
		}
	} while (linesToRead);
	file.Close();
	return found;
}

bool FileContentRef::REContains(const Poco::RegularExpression& regexp) const
{
	UniMemFile file;
	if (!file.OpenReadOnly(path))
		return false;
	GuessEncoding(file, path);
	bool linesToRead = true;
	bool found = false;
	try
	{
		do
		{
			bool lossy;
			String line, eol;
			linesToRead = file.ReadString(line, eol, &lossy);
			Poco::RegularExpression::Match match;
			if (regexp.match(ucr::toUTF8(line), match) > 0)
			{
				found = true;
				break;
			}
		} while (linesToRead);
	}
	catch (const Poco::RegularExpressionException&)
	{
	}
	file.Close();
	return found;
}

std::string FileContentRef::Sublines(ptrdiff_t start, ptrdiff_t len) const
{
	UniMemFile file;
	if (!file.OpenReadOnly(path))
		return "";
	GuessEncoding(file, path);
	bool linesToRead = true;
	std::vector<String> lines;
	if (start >= 0 && len >= 0)
	{
		size_t count = 0;
		do
		{
			bool lossy;
			String line, eol;
			linesToRead = file.ReadString(line, eol, &lossy);
			if (count >= start && count < start + len && (!line.empty() || !eol.empty()))
				lines.push_back(line + eol);
			if (lines.size() >= static_cast<size_t>(len))
				break;
			++count;
		} while (linesToRead);
		file.Close();
		return ucr::toUTF8(strutils::join(lines.begin(), lines.end(), _T("")));
	}
	do
	{
		bool lossy;
		String line, eol;
		linesToRead = file.ReadString(line, eol, &lossy);
		if (!line.empty() || !eol.empty())
			lines.push_back(line + eol);
	} while (linesToRead);
	if (start < 0)
	{
		start = static_cast<ptrdiff_t>(lines.size()) + start;
		if (start < 0)
			start = 0;
	}
	if (start >= static_cast<ptrdiff_t>(lines.size()))
		return "";
	if (len < 0)
		len = static_cast<ptrdiff_t>(lines.size()) - start + len + 1;
	if (len < 0)
		return "";
	file.Close();
	return ucr::toUTF8(strutils::join(lines.begin() + start, lines.begin() + start + len, _T("")));
}

size_t FileContentRef::LineCount() const
{
	UniMemFile file;
	if (!file.OpenReadOnly(path))
		return static_cast<size_t>(-1);
	GuessEncoding(file, path);
	bool linesToRead = true;
	size_t count = 0;
	do
	{
		bool lossy;
		String line, eol;
		linesToRead = file.ReadString(line, eol, &lossy);
		if (!line.empty() || !eol.empty())
			++count;
	} while (linesToRead);
	file.Close();
	return count;
}

</file>

<file path="Winmerge-Src/Src/FilterEngine/FileContentRef.h">
#pragma once

#include "DiffFileInfo.h"
#include <string>

namespace Poco { class RegularExpression; }

struct FileContentRef
{
	String path;
	DiffFileInfo item;
	bool operator==(const FileContentRef& other) const;
	bool Contains(const std::string& str) const;
	bool REContains(const Poco::RegularExpression& regexp) const;
	std::string Sublines(ptrdiff_t start, ptrdiff_t len) const;
	size_t LineCount() const;
};
</file>

<file path="Winmerge-Src/Src/FilterEngine/FilterEngine.vcxitems">
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Label="Globals">
    <MSBuildAllProjects Condition="'$(MSBuildVersion)' == '' Or '$(MSBuildVersion)' &lt; '16.0'">$(MSBuildAllProjects);$(MSBuildThisFileFullPath)</MSBuildAllProjects>
    <HasSharedItems>true</HasSharedItems>
    <ItemsProjectGuid>{9c37e5d8-1dc0-4eac-aadb-5fc8be4fb1bc}</ItemsProjectGuid>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <ClCompile>
      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(MSBuildThisFileDirectory)</AdditionalIncludeDirectories>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ProjectCapability Include="SourceItemsFromImports" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="$(MSBuildThisFileDirectory)FileContentRef.cpp">
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)FilterExpression.cpp">
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)FilterExpressionNodes.cpp">
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)FilterLexer.cpp">
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)FilterParser.c">
      <ExcludedFromBuild>true</ExcludedFromBuild>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)FilterParser.cpp">
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <CustomBuild Include="$(MSBuildThisFileDirectory)FilterLexer.re">
      <ExcludedFromBuild>
      </ExcludedFromBuild>
      <FileType>Document</FileType>
      <Command>"$(SolutionDir)\Build\msys2\usr\bin\re2c.exe" "%(FullPath)" -o "%(RelativeDir)\FilterLexer.cpp"</Command>
      <Outputs>%(RelativeDir)\FilterLexer.cpp</Outputs>
    </CustomBuild>
  </ItemGroup>
  <ItemGroup>
    <CustomBuild Include="$(MSBuildThisFileDirectory)FilterParser.y">
      <ExcludedFromBuild>false</ExcludedFromBuild>
      <FileType>Document</FileType>
      <Command>"$(SolutionDir)\Build\msys2\usr\bin\lemon" "%(FullPath)" "-T$(SolutionDir)\Build\msys2\usr\share\lemon\lempar.c"</Command>
      <Outputs>%(RelativeDir)\FilterParser.c</Outputs>
    </CustomBuild>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="$(MSBuildThisFileDirectory)FileContentRef.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)FilterError.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)FilterExpression.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)FilterExpressionNodes.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)FilterLexer.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)FilterParser.h" />
  </ItemGroup>
</Project>
</file>

<file path="Winmerge-Src/Src/FilterEngine/FilterEngine.vcxitems.filters">
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Header Files">
      <UniqueIdentifier>{cbb36660-3f8a-46ba-855a-fa8f32b99d72}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files">
      <UniqueIdentifier>{7e65cd72-3165-42cc-b722-0dcf1593ffdd}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="$(MSBuildThisFileDirectory)FilterExpression.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)FilterExpressionNodes.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)FilterLexer.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)FilterParser.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)FilterParser.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)FileContentRef.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <CustomBuild Include="$(MSBuildThisFileDirectory)FilterLexer.re">
      <Filter>Source Files</Filter>
    </CustomBuild>
    <CustomBuild Include="$(MSBuildThisFileDirectory)FilterParser.y">
      <Filter>Source Files</Filter>
    </CustomBuild>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="$(MSBuildThisFileDirectory)FilterExpression.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="$(MSBuildThisFileDirectory)FilterExpressionNodes.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="$(MSBuildThisFileDirectory)FilterLexer.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="$(MSBuildThisFileDirectory)FilterParser.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="$(MSBuildThisFileDirectory)FilterError.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="$(MSBuildThisFileDirectory)FileContentRef.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
</file>

<file path="Winmerge-Src/Src/FilterEngine/FilterError.h">
/**
 * @file FilterError.h
 * @brief Defines error codes for the filter engine.
 */
#pragma once

enum FilterErrorCode
{
	FILTER_ERROR_NO_ERROR = 0,
	FILTER_ERROR_UNKNOWN_CHAR = 1, // LEXER_ERR_UNKNOWN_CHAR(-1)
	FILTER_ERROR_UNTERMINATED_STRING = 2, // LEXER_ERR_UNTERMINATED_STRING(-2)
	FILTER_ERROR_EMPTY_EXPRESSION = 3,
	FILTER_ERROR_SYNTAX_ERROR = 4,
	FILTER_ERROR_PARSE_FAILURE = 5,
	FILTER_ERROR_INVALID_LITERAL = 6,
	FILTER_ERROR_INVALID_ARGUMENT_COUNT = 7,
	FILTER_ERROR_INVALID_REGULAR_EXPRESSION = 8,
	FILTER_ERROR_UNDEFINED_IDENTIFIER = 9,
	FILTER_ERROR_FILTER_NAME_NOT_FOUND = 10,
	FILTER_ERROR_EVALUATION_FAILED = 11,
	FILTER_ERROR_DIVIDE_BY_ZERO = 12,
};
</file>

<file path="Winmerge-Src/Src/FilterEngine/FilterExpression.cpp">
/**
 * @file  FilterExpression.cpp
 *
 * @brief Filter engine implementation.
 */
#include "pch.h"
#include "FilterExpression.h"
#include "FilterExpressionNodes.h"
#include "FilterLexer.h"
#include "DiffContext.h"
#include "DiffItem.h"
#include <Poco/LocalDateTime.h>

extern void Parse(void* yyp, int yymajor, YYSTYPE yyminor, FilterExpression* pCtx);
extern void* ParseAlloc(void* (*mallocProc)(size_t));
extern void ParseFree(void* yyp, void (*freeProc)(void*));

void YYSTYPEDestructor(YYSTYPE& yystype)
{
	if (yystype.nodeList)
	{
		for (auto& node : *yystype.nodeList)
			delete node;
		delete yystype.nodeList;
	}
	delete yystype.node;
	yystype.node = nullptr;
	yystype.nodeList = nullptr;
}

FilterExpression::FilterExpression()
{
}

FilterExpression::FilterExpression(const FilterExpression& other)
	: optimize(other.optimize)
	, ctxt(other.ctxt)
	, now(other.now ? new Poco::Timestamp(*other.now) : nullptr)
	, today(other.today ? new Poco::Timestamp(*other.today) : nullptr)
	, expression(other.expression)
{
	Parse(expression);
}

FilterExpression::FilterExpression(const std::string& expression)
{
	Parse(expression);
}

FilterExpression::~FilterExpression()
{
	Clear();
}

void FilterExpression::Clear()
{
	now.reset();
	today.reset();
	rootNode.reset();
	errorCode = FILTER_ERROR_NO_ERROR;
	errorPosition = -1;
}

void FilterExpression::UpdateTimestamp()
{
	now.reset(new Poco::Timestamp());
	Poco::LocalDateTime ldt(*now);
	Poco::LocalDateTime midnight(ldt.year(), ldt.month(), ldt.day(), 0, 0, 0, 0, 0);
	today.reset(new Poco::Timestamp(midnight.utc().timestamp()));
}

static int getErrorPosition(const FilterExpression* pCtx, const FilterLexer& lexer)
{
	if (pCtx->errorCode == FILTER_ERROR_UNDEFINED_IDENTIFIER)
	{
		return static_cast<int>(lexer.yycursor - strlen(lexer.yylval.string) - pCtx->expression.c_str());
	}
	return static_cast<int>(lexer.yycursor - pCtx->expression.c_str());
}

bool FilterExpression::Parse()
{
	Clear();
	UpdateTimestamp();
	if (expression.empty())
	{
		errorCode = FILTER_ERROR_EMPTY_EXPRESSION;
		errorPosition = 0;
		return false;
	}
	FilterLexer lexer(expression);
	void* prs = ParseAlloc(malloc);
	int token;
	FilterErrorCode firstError = FILTER_ERROR_NO_ERROR;
	while ((token = lexer.yylex()) != 0)
	{
		if (token < 0)
		{
			firstError = static_cast<FilterErrorCode>(-token);
			errorPosition = getErrorPosition(this, lexer);
			break;
		}
		::Parse(prs, token, lexer.yylval, this);
		if (errorCode != 0)
		{
			firstError = errorCode;
			errorPosition = getErrorPosition(this, lexer);
			break;
		}
		lexer.yycursor = lexer.YYCURSOR;
	}
	::Parse(prs, 0, lexer.yylval, this);
	if (firstError == 0 && errorCode != 0)
	{
		firstError = errorCode;
		errorPosition = getErrorPosition(this, lexer);
	}
	::ParseFree(prs, free);
	if (firstError != 0)
		errorCode = firstError;
	return (errorCode == 0 && rootNode != nullptr);
}

bool FilterExpression::Parse(const std::string& expressionStr)
{
	expression = expressionStr;
	return Parse();
}

bool FilterExpression::Evaluate(const DIFFITEM& di)
{
	try
	{
		const auto result = rootNode->Evaluate(di);
		if (const auto boolVal = std::get_if<bool>(&result))
			return *boolVal;
		if (const auto arrayVal = std::get_if<std::shared_ptr<std::vector<ValueType2>>>(&result))
		{
			const auto& vec = *arrayVal->get();
			return std::any_of(vec.begin(), vec.end(), [](const ValueType2& item) {
				const auto boolVal = std::get_if<bool>(&item.value);
				return boolVal && *boolVal;
				});
		}
		return false;
	}
	catch (const Poco::RegularExpressionException& e)
	{
		errorCode = FILTER_ERROR_INVALID_REGULAR_EXPRESSION;
		errorPosition = -1;
		errorMessage = e.message();
		if (logger)
			logger("FilterExpression evaluation error: " + errorMessage);
		return false;
	}
	catch (const std::exception& e)
	{
		errorCode = FILTER_ERROR_EVALUATION_FAILED;
		errorPosition = -1;
		errorMessage = e.what();
		if (logger)
			logger("FilterExpression evaluation error: " + errorMessage);
		return false;
	}
}
</file>

<file path="Winmerge-Src/Src/FilterEngine/FilterExpression.h">
/**
 * @file  FilterExpression.h
 *
 * @brief Header file for the FilterExpression class, which provides functionality to parse and evaluate filter expressions.
 */
#pragma once

#include <string>
#include <memory>
#include "FilterError.h"

class CDiffContext;
class DIFFITEM;
struct ExprNode;
struct YYSTYPE;
namespace Poco { class Timestamp; }

struct FilterExpression
{
	FilterExpression();
	FilterExpression(const FilterExpression& other);
	FilterExpression(const std::string& expression);
	~FilterExpression();
	bool Parse(const std::string& expression);
	bool Parse();
	void SetDiffContext(const CDiffContext* pCtxt) { ctxt = pCtxt; }
	bool Evaluate(const DIFFITEM& di);
	void UpdateTimestamp();
	void Clear();
	static void SetLogger(std::function<void(const std::string&)> func) { logger = func; };
	bool optimize = true;
	const CDiffContext* ctxt = nullptr;
	std::unique_ptr<Poco::Timestamp> now;
	std::unique_ptr<Poco::Timestamp> today;
	std::unique_ptr<ExprNode> rootNode;
	std::string expression;
	FilterErrorCode errorCode = FILTER_ERROR_NO_ERROR;
	int errorPosition = -1;
	std::string errorMessage;
	inline static std::function<void(const std::string&)> logger;
};
</file>

<file path="Winmerge-Src/Src/FilterEngine/FilterExpressionNodes.h">
/**
 * @file  FilterExpressionNodes.h
 *
 * @brief Filter expression evaluation classes.
 */
#pragma once

#include "FilterParser.h"
#include <string>
#include <map>
#include <variant>
#include <vector>
#include <Poco/Timestamp.h>

namespace Poco { class RegularExpression; }
struct FilterExpression;
struct FileContentRef;
class DIFFITEM;
struct ValueType2;
using ValueType = std::variant<std::monostate, bool, int64_t, Poco::Timestamp, std::shared_ptr<Poco::RegularExpression>, std::string, std::shared_ptr<FileContentRef>, std::shared_ptr<std::vector<ValueType2>>>;
struct ValueType2 { ValueType value; };

struct ExprNode
{
	virtual ~ExprNode() { }
	virtual ExprNode* Optimize() { return this; }
	virtual ValueType Evaluate(const DIFFITEM& di) const = 0;
};

struct OrNode : public ExprNode
{
	OrNode(ExprNode* l, ExprNode* r) : left(l), right(r) { }
	virtual ~OrNode()
	{
		delete left;
		delete right;
	}
	ExprNode* Optimize() override;
	ValueType Evaluate(const DIFFITEM& di) const override;
	ExprNode* left;
	ExprNode* right;
};

struct AndNode : public ExprNode
{
	AndNode(ExprNode* l, ExprNode* r) : left(l), right(r) { }
	virtual ~AndNode()
	{
		delete left;
		delete right;
	}
	ExprNode* Optimize() override;
	ValueType Evaluate(const DIFFITEM& di) const override;
	ExprNode* left;
	ExprNode* right;
};

struct NotNode : public ExprNode
{
	NotNode(ExprNode* e) : expr(e) { }
	virtual ~NotNode()
	{
		delete expr;
	}
	ExprNode* Optimize() override;
	ValueType Evaluate(const DIFFITEM& di) const override;
	ExprNode* expr;
};

struct BinaryOpNode : public ExprNode
{
	BinaryOpNode(ExprNode* l, int o, ExprNode* r) : left(l), right(r), op(o) { }
	virtual ~BinaryOpNode()
	{
		delete left;
		delete right;
	}
	ExprNode* Optimize() override;
	ValueType Evaluate(const DIFFITEM& di) const override;
	int op;
	ExprNode* left;
	ExprNode* right;
};

struct NegateNode : public ExprNode
{
	NegateNode(ExprNode* r) : right(r) { }
	virtual ~NegateNode()
	{
		delete right;
	}
	ExprNode* Optimize() override;
	ValueType Evaluate(const DIFFITEM& di) const override;
	ExprNode* right;
};

struct FieldNode : public ExprNode
{
	FieldNode(const FilterExpression* ctxt, const std::string& v);
	ValueType Evaluate(const DIFFITEM& di) const override;
	const FilterExpression* ctxt;
	std::string field;
	std::function<ValueType(const FilterExpression* ctxt, const DIFFITEM& di)> func;
};

struct FunctionNode : public ExprNode
{
	FunctionNode(const FilterExpression* ctxt, const std::string& name, std::vector<ExprNode*>* args);
	virtual ~FunctionNode();
	ExprNode* Optimize() override;
	ValueType Evaluate(const DIFFITEM& di) const override;
	const FilterExpression* ctxt;
	std::string functionName;
	std::vector<ExprNode*>* args;
	std::function<ValueType(const FilterExpression* ctxt, const DIFFITEM& di, std::vector<ExprNode*>* args)> func;
};

struct BoolLiteral : public ExprNode
{
	BoolLiteral(bool v) : value(v) { }
	inline ValueType Evaluate(const DIFFITEM& di) const override { return value; }
	bool value;
};

struct IntLiteral : public ExprNode
{
	IntLiteral(int64_t v) : value(v) { }
	inline ValueType Evaluate(const DIFFITEM& di) const override { return value; }
	int64_t value;
};

struct StringLiteral : public ExprNode
{
	StringLiteral(const std::string& v) : value(v) { }
	inline ValueType Evaluate(const DIFFITEM& di) const override { return value; }
	std::string value;
};

struct SizeLiteral : public ExprNode
{
	SizeLiteral(const std::string& v);
	inline ValueType Evaluate(const DIFFITEM& di) const override { return value; }
	int64_t value;
};

struct DateTimeLiteral : public ExprNode
{
	DateTimeLiteral(const std::string& v);
	DateTimeLiteral(const Poco::Timestamp& v) : value(v) { }
	inline ValueType Evaluate(const DIFFITEM& di) const override { return value; }
	Poco::Timestamp value;
};

struct DurationLiteral : public ExprNode
{
	DurationLiteral(const std::string& v);
	inline ValueType Evaluate(const DIFFITEM& di) const override { return value; }
	int64_t value;
};

struct VersionLiteral : public ExprNode
{
	VersionLiteral(const std::string& v);
	inline ValueType Evaluate(const DIFFITEM& di) const override { return value; }
	int64_t value;
};

struct RegularExpressionLiteral : public ExprNode
{
	RegularExpressionLiteral(const std::string& v);
	inline ValueType Evaluate(const DIFFITEM& di) const override { return value; }
	std::shared_ptr<Poco::RegularExpression> value;
};

struct ArrayLiteral : public ExprNode
{
	ArrayLiteral(std::shared_ptr<std::vector<ValueType2>> v) : value(v) {}
	inline ValueType Evaluate(const DIFFITEM& di) const override { return value; }
	std::shared_ptr<std::vector<ValueType2>> value;
};
</file>

<file path="Winmerge-Src/Src/FilterEngine/FilterLexer.cpp">
/* Generated by re2c 3.1 on Sun Aug 24 15:01:07 2025 */
#line 1 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
/**
 * @file  FilterLexer.re
 *
 * @brief Lexer for the filter parser.
 */
#line 11 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"


#include "pch.h"
#include "FilterParser.h"
#include "FilterLexer.h"
#include <string>

int FilterLexer::yylex()
{
begin:
	
#line 21 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
{
	char yych;
	unsigned int yyaccept = 0;
	yych = *YYCURSOR;
	switch (yych) {
		case '\t':
		case '\n':
		case '\r':
		case ' ': goto yy3;
		case '!': goto yy5;
		case '"': goto yy6;
		case '%': goto yy7;
		case '(': goto yy8;
		case ')': goto yy9;
		case '*': goto yy10;
		case '+': goto yy11;
		case ',': goto yy12;
		case '-': goto yy13;
		case '/': goto yy14;
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9': goto yy15;
		case '<': goto yy17;
		case '=': goto yy19;
		case '>': goto yy21;
		case 'A':
		case 'a': goto yy23;
		case 'B':
		case 'E':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'P':
		case 'Q':
		case 'S':
		case 'U':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'b':
		case 'e':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'p':
		case 'q':
		case 's':
		case 'u':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy25;
		case 'C':
		case 'c': goto yy27;
		case 'D':
		case 'd': goto yy28;
		case 'F':
		case 'f': goto yy29;
		case 'L':
		case 'l': goto yy30;
		case 'M':
		case 'm': goto yy31;
		case 'N':
		case 'n': goto yy32;
		case 'O':
		case 'o': goto yy33;
		case 'R':
		case 'r': goto yy34;
		case 'T':
		case 't': goto yy35;
		case 'V':
		case 'v': goto yy36;
		default:
			if (YYLIMIT <= YYCURSOR) goto yy123;
			goto yy1;
	}
yy1:
	++YYCURSOR;
yy2:
#line 100 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ return LEXER_ERR_UNKNOWN_CHAR; }
#line 116 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy3:
	yych = *++YYCURSOR;
	switch (yych) {
		case '\t':
		case '\n':
		case '\r':
		case ' ': goto yy3;
		default: goto yy4;
	}
yy4:
#line 22 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ goto begin; }
#line 129 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy5:
	yych = *++YYCURSOR;
	switch (yych) {
		case '=': goto yy37;
		default: goto yy2;
	}
yy6:
	++YYCURSOR;
#line 76 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{
		int errorCode = 0;
		std::string str = UnescapeQuotes(YYCURSOR, errorCode);
		if (errorCode != 0)
			return errorCode;
		yylval.string = DupString(str.c_str());
		return TK_STRING_LITERAL;
	}
#line 147 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy7:
	++YYCURSOR;
#line 97 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ return TK_MOD; }
#line 152 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy8:
	++YYCURSOR;
#line 91 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ return TK_LPAREN; }
#line 157 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy9:
	++YYCURSOR;
#line 92 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ return TK_RPAREN; }
#line 162 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy10:
	++YYCURSOR;
#line 95 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ return TK_STAR; }
#line 167 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy11:
	++YYCURSOR;
#line 93 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ return TK_PLUS; }
#line 172 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy12:
	++YYCURSOR;
#line 99 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ return TK_COMMA; }
#line 177 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy13:
	++YYCURSOR;
#line 94 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ return TK_MINUS; }
#line 182 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy14:
	++YYCURSOR;
#line 96 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ return TK_SLASH; }
#line 187 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy15:
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case '.': goto yy38;
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9': goto yy15;
		case 'B':
		case 'b': goto yy40;
		case 'D':
		case 'd': goto yy41;
		case 'G':
		case 'K':
		case 'T':
		case 'g':
		case 'k':
		case 't': goto yy43;
		case 'H':
		case 'h': goto yy44;
		case 'M':
		case 'm': goto yy45;
		case 'S':
		case 's': goto yy46;
		case 'W':
		case 'w': goto yy47;
		default: goto yy16;
	}
yy16:
#line 64 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{
		yylval.integer = std::stoi(std::string((const char*)yycursor, YYCURSOR - yycursor));
		return TK_INTEGER_LITERAL;
	}
#line 229 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy17:
	yych = *++YYCURSOR;
	switch (yych) {
		case '=': goto yy48;
		default: goto yy18;
	}
yy18:
#line 87 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ return TK_LT; }
#line 239 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy19:
	yych = *++YYCURSOR;
	switch (yych) {
		case '=': goto yy49;
		default: goto yy20;
	}
yy20:
#line 85 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ return TK_EQ; }
#line 249 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy21:
	yych = *++YYCURSOR;
	switch (yych) {
		case '=': goto yy50;
		default: goto yy22;
	}
yy22:
#line 89 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ return TK_GT; }
#line 259 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy23:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'N':
		case 'n': goto yy51;
		default: goto yy26;
	}
yy24:
#line 68 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{
		const char* p = yycursor;
		while (*p == ' ' || *p == '\t' || *p == '\r' || *p == '\n')
			p++;
		std::string tmp = std::string(p, YYCURSOR - p);
		yylval.string = DupString(tmp.c_str());
		return TK_IDENTIFIER;
	}
#line 278 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy25:
	yych = *++YYCURSOR;
yy26:
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy25;
		default: goto yy24;
	}
yy27:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'O':
		case 'o': goto yy52;
		default: goto yy26;
	}
yy28:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case '"': goto yy53;
		default: goto yy26;
	}
yy29:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'A':
		case 'a': goto yy54;
		default: goto yy26;
	}
yy30:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'I':
		case 'i': goto yy55;
		default: goto yy26;
	}
yy31:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'A':
		case 'a': goto yy56;
		default: goto yy26;
	}
yy32:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'O':
		case 'o': goto yy57;
		default: goto yy26;
	}
yy33:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'R':
		case 'r': goto yy58;
		default: goto yy26;
	}
yy34:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'E':
		case 'e': goto yy60;
		default: goto yy26;
	}
yy35:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'R':
		case 'r': goto yy61;
		default: goto yy26;
	}
yy36:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case '"': goto yy62;
		default: goto yy26;
	}
yy37:
	++YYCURSOR;
#line 86 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ return TK_NE; }
#line 430 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy38:
	yych = *++YYCURSOR;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9': goto yy63;
		default: goto yy39;
	}
yy39:
	YYCURSOR = YYMARKER;
	if (yyaccept == 0) {
		goto yy16;
	} else {
		goto yy42;
	}
yy40:
	++YYCURSOR;
#line 32 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{
		const char* p = yycursor;
		while (*p == ' ' || *p == '\t' || *p == '\r' || *p == '\n')
			p++;
		std::string lit(p, YYCURSOR - p);
		yylval.string = DupString(lit.c_str());
		return TK_SIZE_LITERAL;
	}
#line 464 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy41:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case 'A':
		case 'a': goto yy64;
		default: goto yy42;
	}
yy42:
#line 40 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{
		const char* p = yycursor;
		while (*p == ' ' || *p == '\t' || *p == '\r' || *p == '\n')
			p++;
		std::string lit(p, YYCURSOR - p);
		yylval.string = DupString(lit.c_str());
		return TK_DURATION_LITERAL;
	}
#line 483 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy43:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'B':
		case 'b': goto yy40;
		default: goto yy39;
	}
yy44:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case 'O':
		case 'o': goto yy65;
		case 'R':
		case 'r': goto yy66;
		default: goto yy42;
	}
yy45:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case 'B':
		case 'b': goto yy40;
		case 'I':
		case 'i': goto yy67;
		case 'S':
		case 's': goto yy68;
		default: goto yy42;
	}
yy46:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case 'E':
		case 'e': goto yy69;
		default: goto yy42;
	}
yy47:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case 'E':
		case 'e': goto yy70;
		default: goto yy42;
	}
yy48:
	++YYCURSOR;
#line 88 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ return TK_LE; }
#line 533 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy49:
	++YYCURSOR;
#line 84 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ return TK_EQ; }
#line 538 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy50:
	++YYCURSOR;
#line 90 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ return TK_GE; }
#line 543 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy51:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'D':
		case 'd': goto yy71;
		default: goto yy26;
	}
yy52:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'N':
		case 'n': goto yy73;
		default: goto yy26;
	}
yy53:
	++YYCURSOR;
#line 48 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{
		int errorCode = 0;
		std::string str = UnescapeQuotes(YYCURSOR, errorCode);
		if (errorCode != 0)
			return errorCode;
		yylval.string = DupString(str.c_str());
		return TK_DATETIME_LITERAL;
	}
#line 571 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy54:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'L':
		case 'l': goto yy74;
		default: goto yy26;
	}
yy55:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'K':
		case 'k': goto yy75;
		default: goto yy26;
	}
yy56:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'T':
		case 't': goto yy76;
		default: goto yy26;
	}
yy57:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'T':
		case 't': goto yy77;
		default: goto yy26;
	}
yy58:
	yych = *++YYCURSOR;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy25;
		default: goto yy59;
	}
yy59:
#line 24 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ return TK_OR; }
#line 675 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy60:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'C':
		case 'c': goto yy79;
		default: goto yy26;
	}
yy61:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'U':
		case 'u': goto yy80;
		default: goto yy26;
	}
yy62:
	++YYCURSOR;
#line 56 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{
		int errorCode = 0;
		std::string str = UnescapeQuotes(YYCURSOR, errorCode);
		if (errorCode != 0)
			return errorCode;
		yylval.string = DupString(str.c_str());
		return TK_VERSION_LITERAL;
	}
#line 703 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy63:
	yych = *++YYCURSOR;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9': goto yy63;
		case 'B':
		case 'b': goto yy40;
		case 'D':
		case 'd': goto yy41;
		case 'G':
		case 'K':
		case 'T':
		case 'g':
		case 'k':
		case 't': goto yy43;
		case 'H':
		case 'h': goto yy44;
		case 'M':
		case 'm': goto yy45;
		case 'S':
		case 's': goto yy46;
		case 'W':
		case 'w': goto yy47;
		default: goto yy39;
	}
yy64:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'Y':
		case 'y': goto yy81;
		default: goto yy39;
	}
yy65:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'U':
		case 'u': goto yy82;
		default: goto yy39;
	}
yy66:
	++YYCURSOR;
	goto yy42;
yy67:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'L':
		case 'l': goto yy83;
		case 'N':
		case 'n': goto yy84;
		default: goto yy39;
	}
yy68:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case 'E':
		case 'e': goto yy85;
		default: goto yy42;
	}
yy69:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'C':
		case 'c': goto yy86;
		default: goto yy39;
	}
yy70:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'E':
		case 'e': goto yy87;
		default: goto yy39;
	}
yy71:
	yych = *++YYCURSOR;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy25;
		default: goto yy72;
	}
yy72:
#line 23 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ return TK_AND; }
#line 856 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy73:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'T':
		case 't': goto yy88;
		default: goto yy26;
	}
yy74:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'S':
		case 's': goto yy89;
		default: goto yy26;
	}
yy75:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'E':
		case 'e': goto yy90;
		default: goto yy26;
	}
yy76:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'C':
		case 'c': goto yy92;
		default: goto yy26;
	}
yy77:
	yych = *++YYCURSOR;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy25;
		default: goto yy78;
	}
yy78:
#line 25 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ return TK_NOT; }
#line 960 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy79:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'O':
		case 'o': goto yy93;
		default: goto yy26;
	}
yy80:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'E':
		case 'e': goto yy94;
		default: goto yy26;
	}
yy81:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'S':
		case 's': goto yy66;
		default: goto yy42;
	}
yy82:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'R':
		case 'r': goto yy81;
		default: goto yy39;
	}
yy83:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'L':
		case 'l': goto yy96;
		default: goto yy39;
	}
yy84:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case 'U':
		case 'u': goto yy97;
		default: goto yy42;
	}
yy85:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'C':
		case 'c': goto yy66;
		default: goto yy39;
	}
yy86:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case 'O':
		case 'o': goto yy98;
		default: goto yy42;
	}
yy87:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'K':
		case 'k': goto yy81;
		default: goto yy39;
	}
yy88:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'A':
		case 'a': goto yy99;
		default: goto yy26;
	}
yy89:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'E':
		case 'e': goto yy100;
		default: goto yy26;
	}
yy90:
	yych = *++YYCURSOR;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy25;
		default: goto yy91;
	}
yy91:
#line 30 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ return TK_LIKE; }
#line 1115 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy92:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'H':
		case 'h': goto yy102;
		default: goto yy26;
	}
yy93:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'N':
		case 'n': goto yy103;
		default: goto yy26;
	}
yy94:
	yych = *++YYCURSOR;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy25;
		default: goto yy95;
	}
yy95:
#line 26 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ yylval.boolean = true; return TK_TRUE_LITERAL; }
#line 1203 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy96:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'I':
		case 'i': goto yy104;
		default: goto yy39;
	}
yy97:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'T':
		case 't': goto yy105;
		default: goto yy39;
	}
yy98:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'N':
		case 'n': goto yy106;
		default: goto yy39;
	}
yy99:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'I':
		case 'i': goto yy107;
		default: goto yy26;
	}
yy100:
	yych = *++YYCURSOR;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy25;
		default: goto yy101;
	}
yy101:
#line 27 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ yylval.boolean = false; return TK_FALSE_LITERAL; }
#line 1304 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy102:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'E':
		case 'e': goto yy108;
		default: goto yy26;
	}
yy103:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'T':
		case 't': goto yy109;
		default: goto yy26;
	}
yy104:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'S':
		case 's': goto yy110;
		default: goto yy39;
	}
yy105:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'E':
		case 'e': goto yy81;
		default: goto yy39;
	}
yy106:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'D':
		case 'd': goto yy81;
		default: goto yy39;
	}
yy107:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'N':
		case 'n': goto yy111;
		default: goto yy26;
	}
yy108:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'S':
		case 's': goto yy112;
		default: goto yy26;
	}
yy109:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'A':
		case 'a': goto yy114;
		default: goto yy26;
	}
yy110:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'E':
		case 'e': goto yy115;
		default: goto yy39;
	}
yy111:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'S':
		case 's': goto yy116;
		default: goto yy26;
	}
yy112:
	yych = *++YYCURSOR;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy25;
		default: goto yy113;
	}
yy113:
#line 31 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ return TK_MATCHES; }
#line 1452 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy114:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'I':
		case 'i': goto yy118;
		default: goto yy26;
	}
yy115:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'C':
		case 'c': goto yy119;
		default: goto yy39;
	}
yy116:
	yych = *++YYCURSOR;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy25;
		default: goto yy117;
	}
yy117:
#line 28 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ return TK_CONTAINS; }
#line 1539 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy118:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'N':
		case 'n': goto yy120;
		default: goto yy26;
	}
yy119:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'O':
		case 'o': goto yy98;
		default: goto yy39;
	}
yy120:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'S':
		case 's': goto yy121;
		default: goto yy26;
	}
yy121:
	yych = *++YYCURSOR;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy25;
		default: goto yy122;
	}
yy122:
#line 29 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ return TK_RECONTAINS; }
#line 1634 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy123:
#line 98 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ return 0; }
#line 1638 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
}
#line 101 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"

}

std::string FilterLexer::UnescapeQuotes(char*& str, int& errorCode)
{
	errorCode = LEXER_ERR_UNTERMINATED_STRING;
	std::string result;
	while (*str != '\0')
	{
		if (*str == '"')
		{
			if (*(str + 1) == '"')
			{
				result += '"';
				str += 2;
			}
			else
			{
				str++;
				errorCode = 0;
				break;
			}
		}
		else
		{
			result += *str++;
		}
	}
	return result;
}

const char* FilterLexer::DupString(const char* str)
{
	char* newStr = _strdup(str);
	strings.push_back(newStr);
	return newStr;
}

void FilterLexer::FreeStrings()
{
	for (auto str : strings)
		free(str);
	strings.clear();
}

</file>

<file path="Winmerge-Src/Src/FilterEngine/FilterLexer.h">
/**
 * @file  FilterLexer.h
 *
 * @brief Header file for the FilterLexer class, which is responsible for tokenizing filter expressions.
 */
#pragma once

#include <string>
#include <variant>
#include <vector>

struct ExprNode;

struct YYSTYPE
{
	ExprNode* node;
	std::vector<ExprNode*> *nodeList;
	const char* string;
	int64_t integer;
	bool boolean;
};

extern void YYSTYPEDestructor(YYSTYPE& yystype);

struct FilterLexer
{
	enum ErrorCode {
		LEXER_ERR_UNKNOWN_CHAR = -1,
		LEXER_ERR_UNTERMINATED_STRING = -2,
	};

	FilterLexer(const std::string& input)
		: yycursor((char*)input.c_str())
		, YYCURSOR((char*)input.c_str())
		, YYLIMIT((char*)input.c_str() + input.length())
	{
	}

	~FilterLexer()
	{
		FreeStrings();
	}

	int yylex();

	std::string UnescapeQuotes(char*& str, int& errorCode);
	const char* DupString(const char* str);
	void FreeStrings();

	YYSTYPE yylval{};
	char* yycursor = nullptr;
	char* YYMARKER = nullptr;
	char* YYCURSOR = nullptr;
	char* YYLIMIT = nullptr;
	std::vector<char*> strings;
};
</file>

<file path="Winmerge-Src/Src/FilterEngine/FilterLexer.re">
/**
 * @file  FilterLexer.re
 *
 * @brief Lexer for the filter parser.
 */
/*!re2c
re2c:define:YYCTYPE = char;
re2c:yyfill:enable = 0;
re2c:flags:case-insensitive = 1;
re2c:eof = 0;
*/

#include "pch.h"
#include "FilterParser.h"
#include "FilterLexer.h"
#include <string>

int FilterLexer::yylex()
{
begin:
	/*!re2c
	[ \t\r\n]+        { goto begin; }
	"AND"             { return TK_AND; }
	"OR"              { return TK_OR; }
	"NOT"             { return TK_NOT; }
	"TRUE"            { yylval.boolean = true; return TK_TRUE_LITERAL; }
	"FALSE"           { yylval.boolean = false; return TK_FALSE_LITERAL; }
	"CONTAINS"        { return TK_CONTAINS; }
	"RECONTAINS"      { return TK_RECONTAINS; }
	"LIKE"            { return TK_LIKE; }
	"MATCHES"         { return TK_MATCHES; }
	([0-9]+([.][0-9]+)?)("B"|"KB"|"MB"|"GB"|"TB") {
		const char* p = yycursor;
		while (*p == ' ' || *p == '\t' || *p == '\r' || *p == '\n')
			p++;
		std::string lit(p, YYCURSOR - p);
		yylval.string = DupString(lit.c_str());
		return TK_SIZE_LITERAL;
	}
	([0-9]+([.][0-9]+)?)("weeks"|"week"|"w"|"days"|"day"|"d"|"hours"|"hour"|"hr"|"h"|"minutes"|"minute"|"min"|"m"|"seconds"|"second"|"sec"|"s"|"milliseconds"|"millisecond"|"msec"|"ms") {
		const char* p = yycursor;
		while (*p == ' ' || *p == '\t' || *p == '\r' || *p == '\n')
			p++;
		std::string lit(p, YYCURSOR - p);
		yylval.string = DupString(lit.c_str());
		return TK_DURATION_LITERAL;
	}
	"d\"" {
		int errorCode = 0;
		std::string str = UnescapeQuotes(YYCURSOR, errorCode);
		if (errorCode != 0)
			return errorCode;
		yylval.string = DupString(str.c_str());
		return TK_DATETIME_LITERAL;
	}
	"v\"" {
		int errorCode = 0;
		std::string str = UnescapeQuotes(YYCURSOR, errorCode);
		if (errorCode != 0)
			return errorCode;
		yylval.string = DupString(str.c_str());
		return TK_VERSION_LITERAL;
	}
	[0-9]+ {
		yylval.integer = std::stoi(std::string((const char*)yycursor, YYCURSOR - yycursor));
		return TK_INTEGER_LITERAL;
	}
	[a-zA-Z_][a-zA-Z0-9_]* {
		const char* p = yycursor;
		while (*p == ' ' || *p == '\t' || *p == '\r' || *p == '\n')
			p++;
		std::string tmp = std::string(p, YYCURSOR - p);
		yylval.string = DupString(tmp.c_str());
		return TK_IDENTIFIER;
	}
	"\"" {
		int errorCode = 0;
		std::string str = UnescapeQuotes(YYCURSOR, errorCode);
		if (errorCode != 0)
			return errorCode;
		yylval.string = DupString(str.c_str());
		return TK_STRING_LITERAL;
	}
	"=="              { return TK_EQ; }
	"="               { return TK_EQ; }
	"!="              { return TK_NE; }
	"<"               { return TK_LT; }
	"<="              { return TK_LE; }
	">"               { return TK_GT; }
	">="              { return TK_GE; }
	"("               { return TK_LPAREN; }
	")"               { return TK_RPAREN; }
	"+"               { return TK_PLUS; }
	"-"               { return TK_MINUS; }
	"*"               { return TK_STAR; }
	"/"               { return TK_SLASH; }
	"%"               { return TK_MOD; }
	$                 { return 0; }
	","               { return TK_COMMA; }
	.                 { return LEXER_ERR_UNKNOWN_CHAR; }
	*/
}

std::string FilterLexer::UnescapeQuotes(char*& str, int& errorCode)
{
	errorCode = LEXER_ERR_UNTERMINATED_STRING;
	std::string result;
	while (*str != '\0')
	{
		if (*str == '"')
		{
			if (*(str + 1) == '"')
			{
				result += '"';
				str += 2;
			}
			else
			{
				str++;
				errorCode = 0;
				break;
			}
		}
		else
		{
			result += *str++;
		}
	}
	return result;
}

const char* FilterLexer::DupString(const char* str)
{
	char* newStr = _strdup(str);
	strings.push_back(newStr);
	return newStr;
}

void FilterLexer::FreeStrings()
{
	for (auto str : strings)
		free(str);
	strings.clear();
}

</file>

<file path="Winmerge-Src/Src/FilterEngine/FilterParser.cpp">
#include "pch.h"
#include "FilterParser.c"
</file>

<file path="Winmerge-Src/Src/FilterEngine/FilterParser.h">
#define TK_AND                              1
#define TK_OR                               2
#define TK_NOT                              3
#define TK_TRUE_LITERAL                     4
#define TK_FALSE_LITERAL                    5
#define TK_INTEGER_LITERAL                  6
#define TK_STRING_LITERAL                   7
#define TK_SIZE_LITERAL                     8
#define TK_DATETIME_LITERAL                 9
#define TK_DURATION_LITERAL                10
#define TK_VERSION_LITERAL                 11
#define TK_IDENTIFIER                      12
#define TK_EQ                              13
#define TK_NE                              14
#define TK_LT                              15
#define TK_LE                              16
#define TK_GT                              17
#define TK_GE                              18
#define TK_CONTAINS                        19
#define TK_RECONTAINS                      20
#define TK_LIKE                            21
#define TK_MATCHES                         22
#define TK_LPAREN                          23
#define TK_RPAREN                          24
#define TK_PLUS                            25
#define TK_MINUS                           26
#define TK_STAR                            27
#define TK_SLASH                           28
#define TK_MOD                             29
#define TK_COMMA                           30
</file>

<file path="Winmerge-Src/Src/FilterEngine/FilterParser.out">
State 0:
          filter_expr ::= * or_expr
          or_expr ::= * or_expr OR and_expr
          or_expr ::= * and_expr
          and_expr ::= * and_expr AND not_expr
          and_expr ::= * not_expr
          not_expr ::= * NOT not_expr
          not_expr ::= * cmp_expr
          cmp_expr ::= * arithmetic EQ arithmetic
          cmp_expr ::= * arithmetic NE arithmetic
          cmp_expr ::= * arithmetic LT arithmetic
          cmp_expr ::= * arithmetic LE arithmetic
          cmp_expr ::= * arithmetic GT arithmetic
          cmp_expr ::= * arithmetic GE arithmetic
          cmp_expr ::= * arithmetic CONTAINS arithmetic
          cmp_expr ::= * arithmetic NOT CONTAINS arithmetic
          cmp_expr ::= * arithmetic RECONTAINS arithmetic
          cmp_expr ::= * arithmetic NOT RECONTAINS arithmetic
          cmp_expr ::= * arithmetic LIKE arithmetic
          cmp_expr ::= * arithmetic NOT LIKE arithmetic
          cmp_expr ::= * arithmetic MATCHES arithmetic
          cmp_expr ::= * arithmetic NOT MATCHES arithmetic
          cmp_expr ::= * arithmetic
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= * unary
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN

                           NOT shift        5      
                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                   filter_expr accept
                       or_expr shift        46     
                      and_expr shift        48     
                      not_expr shift        48       /* because not_expr==and_expr */
                      cmp_expr shift        48       /* because cmp_expr==not_expr */
                    arithmetic shift        27     
                         unary shift        27       /* because unary==arithmetic */
                          term shift        27       /* because term==unary */

State 1:
          or_expr ::= * or_expr OR and_expr
          or_expr ::= * and_expr
          and_expr ::= * and_expr AND not_expr
          and_expr ::= * not_expr
          not_expr ::= * NOT not_expr
          not_expr ::= * cmp_expr
          cmp_expr ::= * arithmetic EQ arithmetic
          cmp_expr ::= * arithmetic NE arithmetic
          cmp_expr ::= * arithmetic LT arithmetic
          cmp_expr ::= * arithmetic LE arithmetic
          cmp_expr ::= * arithmetic GT arithmetic
          cmp_expr ::= * arithmetic GE arithmetic
          cmp_expr ::= * arithmetic CONTAINS arithmetic
          cmp_expr ::= * arithmetic NOT CONTAINS arithmetic
          cmp_expr ::= * arithmetic RECONTAINS arithmetic
          cmp_expr ::= * arithmetic NOT RECONTAINS arithmetic
          cmp_expr ::= * arithmetic LIKE arithmetic
          cmp_expr ::= * arithmetic NOT LIKE arithmetic
          cmp_expr ::= * arithmetic MATCHES arithmetic
          cmp_expr ::= * arithmetic NOT MATCHES arithmetic
          cmp_expr ::= * arithmetic
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= * unary
          expr ::= * or_expr
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= IDENTIFIER LPAREN * RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= IDENTIFIER LPAREN * expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN
          expr_list ::= * expr
          expr_list ::= * expr_list COMMA expr

                           NOT shift        5      
                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                        RPAREN shift-reduce 32     term ::= IDENTIFIER LPAREN RPAREN
                         MINUS shift        26     
                       or_expr shift        49     
                      and_expr shift        48     
                      not_expr shift        48       /* because not_expr==and_expr */
                      cmp_expr shift        48       /* because cmp_expr==not_expr */
                    arithmetic shift        27     
                         unary shift        27       /* because unary==arithmetic */
                          expr shift-reduce 36     expr_list ::= expr
                          term shift        27       /* because term==unary */
                     expr_list shift        45     

State 2:
          or_expr ::= * or_expr OR and_expr
          or_expr ::= * and_expr
          and_expr ::= * and_expr AND not_expr
          and_expr ::= * not_expr
          not_expr ::= * NOT not_expr
          not_expr ::= * cmp_expr
          cmp_expr ::= * arithmetic EQ arithmetic
          cmp_expr ::= * arithmetic NE arithmetic
          cmp_expr ::= * arithmetic LT arithmetic
          cmp_expr ::= * arithmetic LE arithmetic
          cmp_expr ::= * arithmetic GT arithmetic
          cmp_expr ::= * arithmetic GE arithmetic
          cmp_expr ::= * arithmetic CONTAINS arithmetic
          cmp_expr ::= * arithmetic NOT CONTAINS arithmetic
          cmp_expr ::= * arithmetic RECONTAINS arithmetic
          cmp_expr ::= * arithmetic NOT RECONTAINS arithmetic
          cmp_expr ::= * arithmetic LIKE arithmetic
          cmp_expr ::= * arithmetic NOT LIKE arithmetic
          cmp_expr ::= * arithmetic MATCHES arithmetic
          cmp_expr ::= * arithmetic NOT MATCHES arithmetic
          cmp_expr ::= * arithmetic
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= * unary
          expr ::= * or_expr
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN
          term ::= LPAREN * expr RPAREN

                           NOT shift        5      
                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                       or_expr shift        49     
                      and_expr shift        48     
                      not_expr shift        48       /* because not_expr==and_expr */
                      cmp_expr shift        48       /* because cmp_expr==not_expr */
                    arithmetic shift        27     
                         unary shift        27       /* because unary==arithmetic */
                          expr shift        47     
                          term shift        27       /* because term==unary */

State 3:
          or_expr ::= * or_expr OR and_expr
          or_expr ::= * and_expr
          and_expr ::= * and_expr AND not_expr
          and_expr ::= * not_expr
          not_expr ::= * NOT not_expr
          not_expr ::= * cmp_expr
          cmp_expr ::= * arithmetic EQ arithmetic
          cmp_expr ::= * arithmetic NE arithmetic
          cmp_expr ::= * arithmetic LT arithmetic
          cmp_expr ::= * arithmetic LE arithmetic
          cmp_expr ::= * arithmetic GT arithmetic
          cmp_expr ::= * arithmetic GE arithmetic
          cmp_expr ::= * arithmetic CONTAINS arithmetic
          cmp_expr ::= * arithmetic NOT CONTAINS arithmetic
          cmp_expr ::= * arithmetic RECONTAINS arithmetic
          cmp_expr ::= * arithmetic NOT RECONTAINS arithmetic
          cmp_expr ::= * arithmetic LIKE arithmetic
          cmp_expr ::= * arithmetic NOT LIKE arithmetic
          cmp_expr ::= * arithmetic MATCHES arithmetic
          cmp_expr ::= * arithmetic NOT MATCHES arithmetic
          cmp_expr ::= * arithmetic
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= * unary
          expr ::= * or_expr
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN
          expr_list ::= expr_list COMMA * expr

                           NOT shift        5      
                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                       or_expr shift        49     
                      and_expr shift        48     
                      not_expr shift        48       /* because not_expr==and_expr */
                      cmp_expr shift        48       /* because cmp_expr==not_expr */
                    arithmetic shift        27     
                         unary shift        27       /* because unary==arithmetic */
                          expr shift-reduce 37     expr_list ::= expr_list COMMA expr
                          term shift        27       /* because term==unary */

State 4:
          or_expr ::= or_expr OR * and_expr
          and_expr ::= * and_expr AND not_expr
          and_expr ::= * not_expr
          not_expr ::= * NOT not_expr
          not_expr ::= * cmp_expr
          cmp_expr ::= * arithmetic EQ arithmetic
          cmp_expr ::= * arithmetic NE arithmetic
          cmp_expr ::= * arithmetic LT arithmetic
          cmp_expr ::= * arithmetic LE arithmetic
          cmp_expr ::= * arithmetic GT arithmetic
          cmp_expr ::= * arithmetic GE arithmetic
          cmp_expr ::= * arithmetic CONTAINS arithmetic
          cmp_expr ::= * arithmetic NOT CONTAINS arithmetic
          cmp_expr ::= * arithmetic RECONTAINS arithmetic
          cmp_expr ::= * arithmetic NOT RECONTAINS arithmetic
          cmp_expr ::= * arithmetic LIKE arithmetic
          cmp_expr ::= * arithmetic NOT LIKE arithmetic
          cmp_expr ::= * arithmetic MATCHES arithmetic
          cmp_expr ::= * arithmetic NOT MATCHES arithmetic
          cmp_expr ::= * arithmetic
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= * unary
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN

                           NOT shift        5      
                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                      and_expr shift        51     
                      not_expr shift        51       /* because not_expr==and_expr */
                      cmp_expr shift        51       /* because cmp_expr==not_expr */
                    arithmetic shift        27     
                         unary shift        27       /* because unary==arithmetic */
                          term shift        27       /* because term==unary */

State 5:
          not_expr ::= * NOT not_expr
          not_expr ::= NOT * not_expr
          not_expr ::= * cmp_expr
          cmp_expr ::= * arithmetic EQ arithmetic
          cmp_expr ::= * arithmetic NE arithmetic
          cmp_expr ::= * arithmetic LT arithmetic
          cmp_expr ::= * arithmetic LE arithmetic
          cmp_expr ::= * arithmetic GT arithmetic
          cmp_expr ::= * arithmetic GE arithmetic
          cmp_expr ::= * arithmetic CONTAINS arithmetic
          cmp_expr ::= * arithmetic NOT CONTAINS arithmetic
          cmp_expr ::= * arithmetic RECONTAINS arithmetic
          cmp_expr ::= * arithmetic NOT RECONTAINS arithmetic
          cmp_expr ::= * arithmetic LIKE arithmetic
          cmp_expr ::= * arithmetic NOT LIKE arithmetic
          cmp_expr ::= * arithmetic MATCHES arithmetic
          cmp_expr ::= * arithmetic NOT MATCHES arithmetic
          cmp_expr ::= * arithmetic
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= * unary
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN

                           NOT shift        5      
                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                      not_expr shift-reduce 3      not_expr ::= NOT not_expr
                      cmp_expr shift-reduce 3      not_expr ::= NOT not_expr  /* because cmp_expr==not_expr */
                    arithmetic shift        27     
                         unary shift        27       /* because unary==arithmetic */
                          term shift        27       /* because term==unary */

State 6:
          and_expr ::= and_expr AND * not_expr
          not_expr ::= * NOT not_expr
          not_expr ::= * cmp_expr
          cmp_expr ::= * arithmetic EQ arithmetic
          cmp_expr ::= * arithmetic NE arithmetic
          cmp_expr ::= * arithmetic LT arithmetic
          cmp_expr ::= * arithmetic LE arithmetic
          cmp_expr ::= * arithmetic GT arithmetic
          cmp_expr ::= * arithmetic GE arithmetic
          cmp_expr ::= * arithmetic CONTAINS arithmetic
          cmp_expr ::= * arithmetic NOT CONTAINS arithmetic
          cmp_expr ::= * arithmetic RECONTAINS arithmetic
          cmp_expr ::= * arithmetic NOT RECONTAINS arithmetic
          cmp_expr ::= * arithmetic LIKE arithmetic
          cmp_expr ::= * arithmetic NOT LIKE arithmetic
          cmp_expr ::= * arithmetic MATCHES arithmetic
          cmp_expr ::= * arithmetic NOT MATCHES arithmetic
          cmp_expr ::= * arithmetic
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= * unary
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN

                           NOT shift        5      
                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                      not_expr shift-reduce 2      and_expr ::= and_expr AND not_expr
                      cmp_expr shift-reduce 2      and_expr ::= and_expr AND not_expr  /* because cmp_expr==not_expr */
                    arithmetic shift        27     
                         unary shift        27       /* because unary==arithmetic */
                          term shift        27       /* because term==unary */

State 7:
          cmp_expr ::= arithmetic MATCHES * arithmetic
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= * unary
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN

                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                    arithmetic shift        28     
                         unary shift        28       /* because unary==arithmetic */
                          term shift        28       /* because term==unary */

State 8:
          cmp_expr ::= arithmetic LIKE * arithmetic
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= * unary
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN

                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                    arithmetic shift        29     
                         unary shift        29       /* because unary==arithmetic */
                          term shift        29       /* because term==unary */

State 9:
          cmp_expr ::= arithmetic RECONTAINS * arithmetic
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= * unary
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN

                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                    arithmetic shift        30     
                         unary shift        30       /* because unary==arithmetic */
                          term shift        30       /* because term==unary */

State 10:
          cmp_expr ::= arithmetic NOT MATCHES * arithmetic
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= * unary
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN

                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                    arithmetic shift        31     
                         unary shift        31       /* because unary==arithmetic */
                          term shift        31       /* because term==unary */

State 11:
          cmp_expr ::= arithmetic NOT LIKE * arithmetic
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= * unary
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN

                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                    arithmetic shift        32     
                         unary shift        32       /* because unary==arithmetic */
                          term shift        32       /* because term==unary */

State 12:
          cmp_expr ::= arithmetic NOT RECONTAINS * arithmetic
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= * unary
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN

                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                    arithmetic shift        33     
                         unary shift        33       /* because unary==arithmetic */
                          term shift        33       /* because term==unary */

State 13:
          cmp_expr ::= arithmetic NOT CONTAINS * arithmetic
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= * unary
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN

                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                    arithmetic shift        34     
                         unary shift        34       /* because unary==arithmetic */
                          term shift        34       /* because term==unary */

State 14:
          cmp_expr ::= arithmetic CONTAINS * arithmetic
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= * unary
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN

                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                    arithmetic shift        35     
                         unary shift        35       /* because unary==arithmetic */
                          term shift        35       /* because term==unary */

State 15:
          cmp_expr ::= arithmetic GE * arithmetic
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= * unary
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN

                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                    arithmetic shift        36     
                         unary shift        36       /* because unary==arithmetic */
                          term shift        36       /* because term==unary */

State 16:
          cmp_expr ::= arithmetic GT * arithmetic
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= * unary
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN

                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                    arithmetic shift        37     
                         unary shift        37       /* because unary==arithmetic */
                          term shift        37       /* because term==unary */

State 17:
          cmp_expr ::= arithmetic LE * arithmetic
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= * unary
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN

                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                    arithmetic shift        38     
                         unary shift        38       /* because unary==arithmetic */
                          term shift        38       /* because term==unary */

State 18:
          cmp_expr ::= arithmetic LT * arithmetic
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= * unary
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN

                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                    arithmetic shift        39     
                         unary shift        39       /* because unary==arithmetic */
                          term shift        39       /* because term==unary */

State 19:
          cmp_expr ::= arithmetic NE * arithmetic
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= * unary
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN

                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                    arithmetic shift        40     
                         unary shift        40       /* because unary==arithmetic */
                          term shift        40       /* because term==unary */

State 20:
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= arithmetic MOD * arithmetic
          arithmetic ::= * unary
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN

                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                    arithmetic shift-reduce 22     arithmetic ::= arithmetic MOD arithmetic
                         unary shift-reduce 22     arithmetic ::= arithmetic MOD arithmetic  /* because unary==arithmetic */
                          term shift-reduce 22     arithmetic ::= arithmetic MOD arithmetic  /* because term==unary */

State 21:
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= arithmetic SLASH * arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= * unary
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN

                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                    arithmetic shift-reduce 21     arithmetic ::= arithmetic SLASH arithmetic
                         unary shift-reduce 21     arithmetic ::= arithmetic SLASH arithmetic  /* because unary==arithmetic */
                          term shift-reduce 21     arithmetic ::= arithmetic SLASH arithmetic  /* because term==unary */

State 22:
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= arithmetic STAR * arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= * unary
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN

                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                    arithmetic shift-reduce 20     arithmetic ::= arithmetic STAR arithmetic
                         unary shift-reduce 20     arithmetic ::= arithmetic STAR arithmetic  /* because unary==arithmetic */
                          term shift-reduce 20     arithmetic ::= arithmetic STAR arithmetic  /* because term==unary */

State 23:
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= arithmetic MINUS * arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= * unary
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN

                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                    arithmetic shift        43     
                         unary shift        43       /* because unary==arithmetic */
                          term shift        43       /* because term==unary */

State 24:
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= arithmetic PLUS * arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= * unary
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN

                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                    arithmetic shift        44     
                         unary shift        44       /* because unary==arithmetic */
                          term shift        44       /* because term==unary */

State 25:
          cmp_expr ::= arithmetic EQ * arithmetic
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= * unary
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN

                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                    arithmetic shift        41     
                         unary shift        41       /* because unary==arithmetic */
                          term shift        41       /* because term==unary */

State 26:
          unary ::= * MINUS unary
          unary ::= MINUS * unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN

                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                         unary shift-reduce 23     unary ::= MINUS unary
                          term shift-reduce 23     unary ::= MINUS unary  /* because term==unary */

State 27:
          cmp_expr ::= arithmetic * EQ arithmetic
          cmp_expr ::= arithmetic * NE arithmetic
          cmp_expr ::= arithmetic * LT arithmetic
          cmp_expr ::= arithmetic * LE arithmetic
          cmp_expr ::= arithmetic * GT arithmetic
          cmp_expr ::= arithmetic * GE arithmetic
          cmp_expr ::= arithmetic * CONTAINS arithmetic
          cmp_expr ::= arithmetic * NOT CONTAINS arithmetic
          cmp_expr ::= arithmetic * RECONTAINS arithmetic
          cmp_expr ::= arithmetic * NOT RECONTAINS arithmetic
          cmp_expr ::= arithmetic * LIKE arithmetic
          cmp_expr ::= arithmetic * NOT LIKE arithmetic
          cmp_expr ::= arithmetic * MATCHES arithmetic
          cmp_expr ::= arithmetic * NOT MATCHES arithmetic
     (41) cmp_expr ::= arithmetic *
          arithmetic ::= arithmetic * PLUS arithmetic
          arithmetic ::= arithmetic * MINUS arithmetic
          arithmetic ::= arithmetic * STAR arithmetic
          arithmetic ::= arithmetic * SLASH arithmetic
          arithmetic ::= arithmetic * MOD arithmetic

                           NOT shift        42     
                            EQ shift        25     
                            NE shift        19     
                            LT shift        18     
                            LE shift        17     
                            GT shift        16     
                            GE shift        15     
                      CONTAINS shift        14     
                    RECONTAINS shift        9      
                          LIKE shift        8      
                       MATCHES shift        7      
                          PLUS shift        24     
                         MINUS shift        23     
                          STAR shift        22     
                         SLASH shift        21     
                           MOD shift        20     
                     {default} reduce       41     cmp_expr ::= arithmetic

State 28:
     (16) cmp_expr ::= arithmetic MATCHES arithmetic *
          arithmetic ::= arithmetic * PLUS arithmetic
          arithmetic ::= arithmetic * MINUS arithmetic
          arithmetic ::= arithmetic * STAR arithmetic
          arithmetic ::= arithmetic * SLASH arithmetic
          arithmetic ::= arithmetic * MOD arithmetic

                          PLUS shift        24     
                         MINUS shift        23     
                          STAR shift        22     
                         SLASH shift        21     
                           MOD shift        20     
                     {default} reduce       16     cmp_expr ::= arithmetic MATCHES arithmetic

State 29:
     (14) cmp_expr ::= arithmetic LIKE arithmetic *
          arithmetic ::= arithmetic * PLUS arithmetic
          arithmetic ::= arithmetic * MINUS arithmetic
          arithmetic ::= arithmetic * STAR arithmetic
          arithmetic ::= arithmetic * SLASH arithmetic
          arithmetic ::= arithmetic * MOD arithmetic

                          PLUS shift        24     
                         MINUS shift        23     
                          STAR shift        22     
                         SLASH shift        21     
                           MOD shift        20     
                     {default} reduce       14     cmp_expr ::= arithmetic LIKE arithmetic

State 30:
     (12) cmp_expr ::= arithmetic RECONTAINS arithmetic *
          arithmetic ::= arithmetic * PLUS arithmetic
          arithmetic ::= arithmetic * MINUS arithmetic
          arithmetic ::= arithmetic * STAR arithmetic
          arithmetic ::= arithmetic * SLASH arithmetic
          arithmetic ::= arithmetic * MOD arithmetic

                          PLUS shift        24     
                         MINUS shift        23     
                          STAR shift        22     
                         SLASH shift        21     
                           MOD shift        20     
                     {default} reduce       12     cmp_expr ::= arithmetic RECONTAINS arithmetic

State 31:
     (17) cmp_expr ::= arithmetic NOT MATCHES arithmetic *
          arithmetic ::= arithmetic * PLUS arithmetic
          arithmetic ::= arithmetic * MINUS arithmetic
          arithmetic ::= arithmetic * STAR arithmetic
          arithmetic ::= arithmetic * SLASH arithmetic
          arithmetic ::= arithmetic * MOD arithmetic

                          PLUS shift        24     
                         MINUS shift        23     
                          STAR shift        22     
                         SLASH shift        21     
                           MOD shift        20     
                     {default} reduce       17     cmp_expr ::= arithmetic NOT MATCHES arithmetic

State 32:
     (15) cmp_expr ::= arithmetic NOT LIKE arithmetic *
          arithmetic ::= arithmetic * PLUS arithmetic
          arithmetic ::= arithmetic * MINUS arithmetic
          arithmetic ::= arithmetic * STAR arithmetic
          arithmetic ::= arithmetic * SLASH arithmetic
          arithmetic ::= arithmetic * MOD arithmetic

                          PLUS shift        24     
                         MINUS shift        23     
                          STAR shift        22     
                         SLASH shift        21     
                           MOD shift        20     
                     {default} reduce       15     cmp_expr ::= arithmetic NOT LIKE arithmetic

State 33:
     (13) cmp_expr ::= arithmetic NOT RECONTAINS arithmetic *
          arithmetic ::= arithmetic * PLUS arithmetic
          arithmetic ::= arithmetic * MINUS arithmetic
          arithmetic ::= arithmetic * STAR arithmetic
          arithmetic ::= arithmetic * SLASH arithmetic
          arithmetic ::= arithmetic * MOD arithmetic

                          PLUS shift        24     
                         MINUS shift        23     
                          STAR shift        22     
                         SLASH shift        21     
                           MOD shift        20     
                     {default} reduce       13     cmp_expr ::= arithmetic NOT RECONTAINS arithmetic

State 34:
     (11) cmp_expr ::= arithmetic NOT CONTAINS arithmetic *
          arithmetic ::= arithmetic * PLUS arithmetic
          arithmetic ::= arithmetic * MINUS arithmetic
          arithmetic ::= arithmetic * STAR arithmetic
          arithmetic ::= arithmetic * SLASH arithmetic
          arithmetic ::= arithmetic * MOD arithmetic

                          PLUS shift        24     
                         MINUS shift        23     
                          STAR shift        22     
                         SLASH shift        21     
                           MOD shift        20     
                     {default} reduce       11     cmp_expr ::= arithmetic NOT CONTAINS arithmetic

State 35:
     (10) cmp_expr ::= arithmetic CONTAINS arithmetic *
          arithmetic ::= arithmetic * PLUS arithmetic
          arithmetic ::= arithmetic * MINUS arithmetic
          arithmetic ::= arithmetic * STAR arithmetic
          arithmetic ::= arithmetic * SLASH arithmetic
          arithmetic ::= arithmetic * MOD arithmetic

                          PLUS shift        24     
                         MINUS shift        23     
                          STAR shift        22     
                         SLASH shift        21     
                           MOD shift        20     
                     {default} reduce       10     cmp_expr ::= arithmetic CONTAINS arithmetic

State 36:
      (9) cmp_expr ::= arithmetic GE arithmetic *
          arithmetic ::= arithmetic * PLUS arithmetic
          arithmetic ::= arithmetic * MINUS arithmetic
          arithmetic ::= arithmetic * STAR arithmetic
          arithmetic ::= arithmetic * SLASH arithmetic
          arithmetic ::= arithmetic * MOD arithmetic

                          PLUS shift        24     
                         MINUS shift        23     
                          STAR shift        22     
                         SLASH shift        21     
                           MOD shift        20     
                     {default} reduce       9      cmp_expr ::= arithmetic GE arithmetic

State 37:
      (8) cmp_expr ::= arithmetic GT arithmetic *
          arithmetic ::= arithmetic * PLUS arithmetic
          arithmetic ::= arithmetic * MINUS arithmetic
          arithmetic ::= arithmetic * STAR arithmetic
          arithmetic ::= arithmetic * SLASH arithmetic
          arithmetic ::= arithmetic * MOD arithmetic

                          PLUS shift        24     
                         MINUS shift        23     
                          STAR shift        22     
                         SLASH shift        21     
                           MOD shift        20     
                     {default} reduce       8      cmp_expr ::= arithmetic GT arithmetic

State 38:
      (7) cmp_expr ::= arithmetic LE arithmetic *
          arithmetic ::= arithmetic * PLUS arithmetic
          arithmetic ::= arithmetic * MINUS arithmetic
          arithmetic ::= arithmetic * STAR arithmetic
          arithmetic ::= arithmetic * SLASH arithmetic
          arithmetic ::= arithmetic * MOD arithmetic

                          PLUS shift        24     
                         MINUS shift        23     
                          STAR shift        22     
                         SLASH shift        21     
                           MOD shift        20     
                     {default} reduce       7      cmp_expr ::= arithmetic LE arithmetic

State 39:
      (6) cmp_expr ::= arithmetic LT arithmetic *
          arithmetic ::= arithmetic * PLUS arithmetic
          arithmetic ::= arithmetic * MINUS arithmetic
          arithmetic ::= arithmetic * STAR arithmetic
          arithmetic ::= arithmetic * SLASH arithmetic
          arithmetic ::= arithmetic * MOD arithmetic

                          PLUS shift        24     
                         MINUS shift        23     
                          STAR shift        22     
                         SLASH shift        21     
                           MOD shift        20     
                     {default} reduce       6      cmp_expr ::= arithmetic LT arithmetic

State 40:
      (5) cmp_expr ::= arithmetic NE arithmetic *
          arithmetic ::= arithmetic * PLUS arithmetic
          arithmetic ::= arithmetic * MINUS arithmetic
          arithmetic ::= arithmetic * STAR arithmetic
          arithmetic ::= arithmetic * SLASH arithmetic
          arithmetic ::= arithmetic * MOD arithmetic

                          PLUS shift        24     
                         MINUS shift        23     
                          STAR shift        22     
                         SLASH shift        21     
                           MOD shift        20     
                     {default} reduce       5      cmp_expr ::= arithmetic NE arithmetic

State 41:
      (4) cmp_expr ::= arithmetic EQ arithmetic *
          arithmetic ::= arithmetic * PLUS arithmetic
          arithmetic ::= arithmetic * MINUS arithmetic
          arithmetic ::= arithmetic * STAR arithmetic
          arithmetic ::= arithmetic * SLASH arithmetic
          arithmetic ::= arithmetic * MOD arithmetic

                          PLUS shift        24     
                         MINUS shift        23     
                          STAR shift        22     
                         SLASH shift        21     
                           MOD shift        20     
                     {default} reduce       4      cmp_expr ::= arithmetic EQ arithmetic

State 42:
          cmp_expr ::= arithmetic NOT * CONTAINS arithmetic
          cmp_expr ::= arithmetic NOT * RECONTAINS arithmetic
          cmp_expr ::= arithmetic NOT * LIKE arithmetic
          cmp_expr ::= arithmetic NOT * MATCHES arithmetic

                      CONTAINS shift        13     
                    RECONTAINS shift        12     
                          LIKE shift        11     
                       MATCHES shift        10     

State 43:
          arithmetic ::= arithmetic * PLUS arithmetic
          arithmetic ::= arithmetic * MINUS arithmetic
     (19) arithmetic ::= arithmetic MINUS arithmetic *
          arithmetic ::= arithmetic * STAR arithmetic
          arithmetic ::= arithmetic * SLASH arithmetic
          arithmetic ::= arithmetic * MOD arithmetic

                          STAR shift        22     
                         SLASH shift        21     
                           MOD shift        20     
                     {default} reduce       19     arithmetic ::= arithmetic MINUS arithmetic

State 44:
          arithmetic ::= arithmetic * PLUS arithmetic
     (18) arithmetic ::= arithmetic PLUS arithmetic *
          arithmetic ::= arithmetic * MINUS arithmetic
          arithmetic ::= arithmetic * STAR arithmetic
          arithmetic ::= arithmetic * SLASH arithmetic
          arithmetic ::= arithmetic * MOD arithmetic

                          STAR shift        22     
                         SLASH shift        21     
                           MOD shift        20     
                     {default} reduce       18     arithmetic ::= arithmetic PLUS arithmetic

State 45:
          term ::= IDENTIFIER LPAREN expr_list * RPAREN
          expr_list ::= expr_list * COMMA expr

                        RPAREN shift-reduce 33     term ::= IDENTIFIER LPAREN expr_list RPAREN
                         COMMA shift        3      

State 46:
      (0) filter_expr ::= or_expr *
          or_expr ::= or_expr * OR and_expr

                             $ reduce       0      filter_expr ::= or_expr
                            OR shift        4      

State 47:
          term ::= LPAREN expr * RPAREN

                        RPAREN shift-reduce 35     term ::= LPAREN expr RPAREN

State 48:
     (38) or_expr ::= and_expr *
          and_expr ::= and_expr * AND not_expr

                           AND shift        6      
                     {default} reduce       38     or_expr ::= and_expr

State 49:
          or_expr ::= or_expr * OR and_expr
     (43) expr ::= or_expr *

                            OR shift        4      
                     {default} reduce       43     expr ::= or_expr

State 50:
          term ::= IDENTIFIER * LPAREN RPAREN
          term ::= IDENTIFIER * LPAREN expr_list RPAREN
     (34) term ::= IDENTIFIER *

                        LPAREN shift        1      
                     {default} reduce       34     term ::= IDENTIFIER

State 51:
      (1) or_expr ::= or_expr OR and_expr *
          and_expr ::= and_expr * AND not_expr

                           AND shift        6      
                     {default} reduce       1      or_expr ::= or_expr OR and_expr

----------------------------------------------------
Symbols:
The first-set of non-terminals is shown after the name.

    0: $:
    1: AND (precedence=2)
    2: OR (precedence=1)
    3: NOT (precedence=4)
    4: TRUE_LITERAL
    5: FALSE_LITERAL
    6: INTEGER_LITERAL
    7: STRING_LITERAL
    8: SIZE_LITERAL
    9: DATETIME_LITERAL
   10: DURATION_LITERAL
   11: VERSION_LITERAL
   12: IDENTIFIER
   13: EQ (precedence=3)
   14: NE (precedence=3)
   15: LT (precedence=3)
   16: LE (precedence=3)
   17: GT (precedence=3)
   18: GE (precedence=3)
   19: CONTAINS (precedence=3)
   20: RECONTAINS (precedence=3)
   21: LIKE (precedence=3)
   22: MATCHES (precedence=3)
   23: LPAREN
   24: RPAREN
   25: PLUS (precedence=5)
   26: MINUS (precedence=5)
   27: STAR (precedence=6)
   28: SLASH (precedence=6)
   29: MOD (precedence=6)
   30: COMMA
   31: filter_expr: NOT TRUE_LITERAL FALSE_LITERAL INTEGER_LITERAL STRING_LITERAL SIZE_LITERAL DATETIME_LITERAL DURATION_LITERAL VERSION_LITERAL IDENTIFIER LPAREN MINUS
   32: or_expr: NOT TRUE_LITERAL FALSE_LITERAL INTEGER_LITERAL STRING_LITERAL SIZE_LITERAL DATETIME_LITERAL DURATION_LITERAL VERSION_LITERAL IDENTIFIER LPAREN MINUS
   33: and_expr: NOT TRUE_LITERAL FALSE_LITERAL INTEGER_LITERAL STRING_LITERAL SIZE_LITERAL DATETIME_LITERAL DURATION_LITERAL VERSION_LITERAL IDENTIFIER LPAREN MINUS
   34: not_expr: NOT TRUE_LITERAL FALSE_LITERAL INTEGER_LITERAL STRING_LITERAL SIZE_LITERAL DATETIME_LITERAL DURATION_LITERAL VERSION_LITERAL IDENTIFIER LPAREN MINUS
   35: cmp_expr: TRUE_LITERAL FALSE_LITERAL INTEGER_LITERAL STRING_LITERAL SIZE_LITERAL DATETIME_LITERAL DURATION_LITERAL VERSION_LITERAL IDENTIFIER LPAREN MINUS
   36: arithmetic: TRUE_LITERAL FALSE_LITERAL INTEGER_LITERAL STRING_LITERAL SIZE_LITERAL DATETIME_LITERAL DURATION_LITERAL VERSION_LITERAL IDENTIFIER LPAREN MINUS
   37: unary: TRUE_LITERAL FALSE_LITERAL INTEGER_LITERAL STRING_LITERAL SIZE_LITERAL DATETIME_LITERAL DURATION_LITERAL VERSION_LITERAL IDENTIFIER LPAREN MINUS
   38: expr: NOT TRUE_LITERAL FALSE_LITERAL INTEGER_LITERAL STRING_LITERAL SIZE_LITERAL DATETIME_LITERAL DURATION_LITERAL VERSION_LITERAL IDENTIFIER LPAREN MINUS
   39: term: TRUE_LITERAL FALSE_LITERAL INTEGER_LITERAL STRING_LITERAL SIZE_LITERAL DATETIME_LITERAL DURATION_LITERAL VERSION_LITERAL IDENTIFIER LPAREN
   40: expr_list: NOT TRUE_LITERAL FALSE_LITERAL INTEGER_LITERAL STRING_LITERAL SIZE_LITERAL DATETIME_LITERAL DURATION_LITERAL VERSION_LITERAL IDENTIFIER LPAREN MINUS
----------------------------------------------------
Syntax-only Symbols:
The following symbols never carry semantic content.

$ AND OR NOT TRUE_LITERAL FALSE_LITERAL EQ NE LT LE GT GE CONTAINS
RECONTAINS LIKE MATCHES LPAREN RPAREN PLUS MINUS STAR SLASH MOD COMMA
filter_expr
----------------------------------------------------
Rules:
   0: filter_expr ::= or_expr.
   1: or_expr ::= or_expr OR and_expr. [OR precedence=1]
   2: and_expr ::= and_expr AND not_expr. [AND precedence=2]
   3: not_expr ::= NOT not_expr. [NOT precedence=4]
   4: cmp_expr ::= arithmetic EQ arithmetic. [EQ precedence=3]
   5: cmp_expr ::= arithmetic NE arithmetic. [NE precedence=3]
   6: cmp_expr ::= arithmetic LT arithmetic. [LT precedence=3]
   7: cmp_expr ::= arithmetic LE arithmetic. [LE precedence=3]
   8: cmp_expr ::= arithmetic GT arithmetic. [GT precedence=3]
   9: cmp_expr ::= arithmetic GE arithmetic. [GE precedence=3]
  10: cmp_expr ::= arithmetic CONTAINS arithmetic. [CONTAINS precedence=3]
  11: cmp_expr ::= arithmetic NOT CONTAINS arithmetic. [NOT precedence=4]
  12: cmp_expr ::= arithmetic RECONTAINS arithmetic. [RECONTAINS precedence=3]
  13: cmp_expr ::= arithmetic NOT RECONTAINS arithmetic. [NOT precedence=4]
  14: cmp_expr ::= arithmetic LIKE arithmetic. [LIKE precedence=3]
  15: cmp_expr ::= arithmetic NOT LIKE arithmetic. [NOT precedence=4]
  16: cmp_expr ::= arithmetic MATCHES arithmetic. [MATCHES precedence=3]
  17: cmp_expr ::= arithmetic NOT MATCHES arithmetic. [NOT precedence=4]
  18: arithmetic ::= arithmetic PLUS arithmetic. [PLUS precedence=5]
  19: arithmetic ::= arithmetic MINUS arithmetic. [MINUS precedence=5]
  20: arithmetic ::= arithmetic STAR arithmetic. [STAR precedence=6]
  21: arithmetic ::= arithmetic SLASH arithmetic. [SLASH precedence=6]
  22: arithmetic ::= arithmetic MOD arithmetic. [MOD precedence=6]
  23: unary ::= MINUS unary. [MINUS precedence=5]
  24: term ::= TRUE_LITERAL.
  25: term ::= FALSE_LITERAL.
  26: term ::= INTEGER_LITERAL.
  27: term ::= STRING_LITERAL.
  28: term ::= SIZE_LITERAL.
  29: term ::= DATETIME_LITERAL.
  30: term ::= DURATION_LITERAL.
  31: term ::= VERSION_LITERAL.
  32: term ::= IDENTIFIER LPAREN RPAREN.
  33: term ::= IDENTIFIER LPAREN expr_list RPAREN.
  34: term ::= IDENTIFIER.
  35: term ::= LPAREN expr RPAREN.
  36: expr_list ::= expr.
  37: expr_list ::= expr_list COMMA expr.
  38: or_expr ::= and_expr.
  39: and_expr ::= not_expr.
  40: not_expr ::= cmp_expr.
  41: cmp_expr ::= arithmetic.
  42: arithmetic ::= unary.
  43: expr ::= or_expr.
  44: unary ::= term.
</file>

<file path="Winmerge-Src/Src/FilterEngine/FilterParser.y">
/**
 * @file  FilterParser.y
 *
 * @brief Parser for filter expressions.
 */
%token AND OR NOT TRUE_LITERAL FALSE_LITERAL INTEGER_LITERAL STRING_LITERAL SIZE_LITERAL DATETIME_LITERAL DURATION_LITERAL VERSION_LITERAL IDENTIFIER EQ NE LT LE GT GE CONTAINS RECONTAINS LIKE MATCHES LPAREN RPAREN PLUS MINUS STAR SLASH MOD COMMA.

%left OR.
%left AND.
%left EQ NE LT LE GT GE CONTAINS RECONTAINS LIKE MATCHES.
%right NOT.
%left PLUS MINUS.
%left STAR SLASH MOD.

%token_type {YYSTYPE}
%token_prefix TK_
%extra_argument { FilterExpression* pCtx }

%include {
#include "FilterLexer.h"
#include "FilterExpressionNodes.h"
#include "FilterExpression.h"
#include <Poco/Exception.h>
}

%syntax_error {
	pCtx->errorCode = FILTER_ERROR_SYNTAX_ERROR;
}
%parse_failure {
	pCtx->errorCode = FILTER_ERROR_PARSE_FAILURE;
}
%default_destructor {
	YYSTYPEDestructor($$);
}

filter_expr ::= or_expr(A). {
	if (pCtx->errorCode == 0 && pCtx->optimize)
	{
		try
		{
			pCtx->rootNode.reset(A.node->Optimize());
		}
		catch (Poco::RegularExpressionException& e)
		{
			pCtx->errorCode = FILTER_ERROR_INVALID_REGULAR_EXPRESSION;
			pCtx->rootNode.reset(A.node);
			pCtx->errorMessage = e.message();
		}
		catch (const std::invalid_argument& e)
		{
			pCtx->errorCode = FILTER_ERROR_DIVIDE_BY_ZERO;
			pCtx->rootNode.reset(A.node);
			pCtx->errorMessage = e.what();
		}
		catch (const std::exception&)
		{
			pCtx->rootNode.reset(A.node);
		}
	}
	else
	{
		pCtx->rootNode.reset(A.node);
	}
}

or_expr(A) ::= or_expr(B) OR and_expr(C).             { A = { new OrNode(B.node, C.node) }; }
or_expr(A) ::= and_expr(A).

and_expr(A) ::= and_expr(B) AND not_expr(C).          { A = { new AndNode(B.node, C.node) }; }
and_expr(A) ::= not_expr(A).

not_expr(A) ::= NOT not_expr(B).                      { A = { new NotNode(B.node) }; }
not_expr(A) ::= cmp_expr(A).

cmp_expr(A) ::= arithmetic(B) EQ arithmetic(C).       { A = { new BinaryOpNode(B.node, TK_EQ, C.node) }; }
cmp_expr(A) ::= arithmetic(B) NE arithmetic(C).       { A = { new BinaryOpNode(B.node, TK_NE, C.node) }; }
cmp_expr(A) ::= arithmetic(B) LT arithmetic(C).       { A = { new BinaryOpNode(B.node, TK_LT,  C.node) }; }
cmp_expr(A) ::= arithmetic(B) LE arithmetic(C).       { A = { new BinaryOpNode(B.node, TK_LE, C.node) }; }
cmp_expr(A) ::= arithmetic(B) GT arithmetic(C).       { A = { new BinaryOpNode(B.node, TK_GT,  C.node) }; }
cmp_expr(A) ::= arithmetic(B) GE arithmetic(C).       { A = { new BinaryOpNode(B.node, TK_GE, C.node) }; }
cmp_expr(A) ::= arithmetic(B) CONTAINS arithmetic(C). { A = { new BinaryOpNode(B.node, TK_CONTAINS, C.node) }; }
cmp_expr(A) ::= arithmetic(B) NOT CONTAINS arithmetic(C). { A = { new NotNode(new BinaryOpNode(B.node, TK_CONTAINS, C.node)) }; }
cmp_expr(A) ::= arithmetic(B) RECONTAINS arithmetic(C). { A = { new BinaryOpNode(B.node, TK_RECONTAINS, C.node) }; }
cmp_expr(A) ::= arithmetic(B) NOT RECONTAINS arithmetic(C). { A = { new NotNode(new BinaryOpNode(B.node, TK_RECONTAINS, C.node)) }; }
cmp_expr(A) ::= arithmetic(B) LIKE arithmetic(C).     { A = { new BinaryOpNode(B.node, TK_LIKE, C.node) }; }
cmp_expr(A) ::= arithmetic(B) NOT LIKE arithmetic(C).     { A = { new NotNode(new BinaryOpNode(B.node, TK_LIKE, C.node)) }; }
cmp_expr(A) ::= arithmetic(B) MATCHES  arithmetic(C). { A = { new BinaryOpNode(B.node, TK_MATCHES, C.node) }; }
cmp_expr(A) ::= arithmetic(B) NOT MATCHES  arithmetic(C). { A = { new NotNode(new BinaryOpNode(B.node, TK_MATCHES, C.node)) }; }
cmp_expr(A) ::= arithmetic(A).

arithmetic(A) ::= arithmetic(B) PLUS arithmetic(C).   { A = { new BinaryOpNode(B.node, TK_PLUS, C.node) }; }
arithmetic(A) ::= arithmetic(B) MINUS arithmetic(C).  { A = { new BinaryOpNode(B.node, TK_MINUS, C.node) }; }
arithmetic(A) ::= arithmetic(B) STAR arithmetic(C).   { A = { new BinaryOpNode(B.node, TK_STAR, C.node) }; }
arithmetic(A) ::= arithmetic(B) SLASH arithmetic(C).  { A = { new BinaryOpNode(B.node, TK_SLASH, C.node) }; }
arithmetic(A) ::= arithmetic(B) MOD arithmetic(C).    { A = { new BinaryOpNode(B.node, TK_MOD, C.node) }; }
arithmetic(A) ::= unary(A).

expr(A) ::= or_expr(A).

unary(A) ::= MINUS unary(B).       { A = { new NegateNode(B.node) }; }
unary(A) ::= term(A).

term(A) ::= TRUE_LITERAL.          { A = { new BoolLiteral(true) }; }
term(A) ::= FALSE_LITERAL.         { A = { new BoolLiteral(false) }; }
term(A) ::= INTEGER_LITERAL(B).    { A = { new IntLiteral(B.integer) }; }
term(A) ::= STRING_LITERAL(B).     { A = { new StringLiteral(B.string) }; }
term(A) ::= SIZE_LITERAL(B).       { A = { new SizeLiteral(B.string) }; }
term(A) ::= DATETIME_LITERAL(B).{
  try
  {
    A = {};
    A.node = new DateTimeLiteral(B.string);
  }
  catch (const std::exception&)
  {
    pCtx->errorCode = FILTER_ERROR_INVALID_LITERAL;
  }
}
term(A) ::= DURATION_LITERAL(B).   { A = { new DurationLiteral(B.string) }; }
term(A) ::= VERSION_LITERAL(B).    { A = { new VersionLiteral(B.string) }; }
term(A) ::= IDENTIFIER(B) LPAREN RPAREN. {
  try
  {
    A = {};
    A.node = new FunctionNode(pCtx, B.string, {});
  }
  catch (const std::invalid_argument& e)
  {
    pCtx->errorCode = FILTER_ERROR_INVALID_ARGUMENT_COUNT;
	pCtx->errorMessage = e.what();
  }
  catch (const std::runtime_error& e)
  {
    pCtx->errorCode = FILTER_ERROR_UNDEFINED_IDENTIFIER;
	pCtx->errorMessage = e.what();
  }
}
term(A) ::= IDENTIFIER(B) LPAREN expr_list(C) RPAREN. {
  try
  {
    A = {};
    A.node = new FunctionNode(pCtx, B.string, C.nodeList);
  }
  catch (const std::invalid_argument& e)
  {
    pCtx->errorCode = FILTER_ERROR_INVALID_ARGUMENT_COUNT;
	pCtx->errorMessage = e.what();
    YYSTYPEDestructor(C);
  }
  catch (const std::runtime_error& e)
  {
    pCtx->errorCode = FILTER_ERROR_UNDEFINED_IDENTIFIER;
	pCtx->errorMessage = e.what();
    YYSTYPEDestructor(C);
  }
}
term(A) ::= IDENTIFIER(B). {
  try
  {
    A = {};
    A.node = new FieldNode(pCtx, B.string);
  }
  catch (const std::exception&)
  {
    pCtx->errorCode = FILTER_ERROR_UNDEFINED_IDENTIFIER;
  }
}
term(A) ::= LPAREN expr(B) RPAREN. { A = B; }

expr_list(A) ::= expr(B). {
  A = {};
  A.nodeList = new std::vector<ExprNode*>{ B.node };
}
expr_list(A) ::= expr_list(B) COMMA expr(C). {
  A = {};
  B.nodeList->push_back(C.node);
  A.nodeList = B.nodeList;
}

</file>

<file path="Winmerge-Src/Src/Common/AccentColor.cpp">
// Copyright (c) 2024 Takashi Sawanaka
// SPDX-License-Identifier: BSL-1.0
/**
 * @file  AccentColor.cpp
 *
 * @brief Implementation of the CAccentColor class
 */

#include "StdAfx.h"
#include "AccentColor.h"
#include "RegKey.h"

CAccentColor::CAccentColor()
	: m_accentColor(CLR_NONE)
	, m_accentColorInactive(CLR_NONE)
	, m_colorPrevalence(false)
{
	Reload();
}

CAccentColor& CAccentColor::Get()
{
	static CAccentColor s_accentColor;
	return s_accentColor;
}

void CAccentColor::Reload()
{
	CRegKeyEx reg;
	if (ERROR_SUCCESS != reg.Open(HKEY_CURRENT_USER, _T("SOFTWARE\\Microsoft\\Windows\\DWM")))
		return;
	m_accentColor = reg.ReadDword(_T("AccentColor"), CLR_NONE);
	if (m_accentColor != CLR_NONE)
		m_accentColor &= 0xffffff;
	m_accentColorInactive = reg.ReadDword(_T("AccentColorInactive"), CLR_NONE);
	if (m_accentColorInactive != CLR_NONE)
		m_accentColorInactive &= 0xffffff;
	m_colorPrevalence = reg.ReadDword(_T("ColorPrevalence"), false);
}
</file>

<file path="Winmerge-Src/Src/Common/AccentColor.h">
// Copyright (c) 2024 Takashi Sawanaka
// SPDX-License-Identifier: BSL-1.0
/**
 * @file  AccentColor.h
 *
 * @brief Declaration file for CAccentColor class
 */

#pragma once

class CAccentColor
{
public:
	CAccentColor();
	COLORREF GetAccentColor() const { return m_accentColor; };
	COLORREF GetAccentColorInactive() const { return m_accentColorInactive; }
	bool GetColorPrevalence() const { return m_colorPrevalence; }
	void Reload();
	static CAccentColor& Get();
private:
	COLORREF m_accentColor;
	COLORREF m_accentColorInactive;
	bool m_colorPrevalence;
};
</file>

<file path="Winmerge-Src/Src/Common/BCMenu.cpp">
//*************************************************************************
// BCMenu.cpp : implementation file
// Version : 3.036
// Date : June 2005
// Author : Brent Corkum
// Email :  corkum@rocscience.com
// Latest Version : http://www.rocscience.com/~corkum/BCMenu.html
// 
// Bug Fixes and portions of code supplied by:
//
// Ben Ashley,Girish Bharadwaj,Jean-Edouard Lachand-Robert,
// Robert Edward Caldecott,Kenny Goers,Leonardo Zide,
// Stefan Kuhr,Reiner Jung,Martin Vladic,Kim Yoo Chul,
// Oz Solomonovich,Tongzhe Cui,Stephane Clog,Warren Stevens,
// Damir Valiulin,David Kinder,Marc Loiry
//
// You are free to use/modify this code but leave this header intact.
// This class is public domain so you are free to use it any of
// your applications (Freeware,Shareware,Commercial). All I ask is
// that you let me know so that if you have a real winner I can
// brag to my buddies that some of my code is in your app. I also
// wouldn't mind if you sent me a copy of your application since I
// like to play with new stuff.
//*************************************************************************

#include "stdafx.h"        // Standard windows header file
#include "BCMenu.h"        // BCMenu class declaration
#include "MergeDarkMode.h" // Dark mode
#include <afxpriv.h>       //SK: makes A2W and other spiffy AFX macros work
#include <../src/mfc/afximpl.h>
#include <cmath>

#pragma comment(lib, "uxtheme.lib")

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

#define BCMENU_GAP 1

bool BCMenu::hicolor_bitmaps=false;

CImageList BCMenu::m_AllImages;
bool BCMenu::m_bHasNotLoadedImages = false;
std::vector<BCMenu::ImageData> BCMenu::m_AllImagesID;
int BCMenu::m_iconX = 16;
int BCMenu::m_iconY = 15;
MARGINS BCMenu::m_marginCheck = { 0 };
MARGINS BCMenu::m_marginSeparator = { 0 };
SIZE BCMenu::m_sizeCheck = { 0 };
SIZE BCMenu::m_sizeSeparator = { 0 };
int BCMenu::m_textBorder = 0;
int BCMenu::m_checkBgWidth = 0;
int BCMenu::m_gutterWidth = 0;
int BCMenu::m_arrowWidth = 0;
COLORREF BCMenu::m_menuTextColor = GetSysColor(COLOR_MENUTEXT);
COLORREF BCMenu::m_menuBgColor = GetSysColor(COLOR_MENU);
HTHEME BCMenu::m_hTheme = nullptr;
bool BCMenu::m_bEnableOwnerDraw = true;

static class GdiplusToken
{
public:
	GdiplusToken() = default;

	~GdiplusToken()
	{
		if (m_token != 0)
			Gdiplus::GdiplusShutdown(m_token);
	}

	void InitGdiplus()
	{
		if (m_token == 0)
		{
			Gdiplus::GdiplusStartupInput gdiplusStartupInput;
			Gdiplus::GdiplusStartup(&m_token, &gdiplusStartupInput, nullptr);
		}
	}

private:
	ULONG_PTR m_token = 0;
} m_gdiplusToken;

// The Representation of a 32 bit color table entry
#pragma pack(push)
#pragma pack(1)
typedef struct ssBGR {
	unsigned char b;
	unsigned char g;
	unsigned char r;
	unsigned char pad;
} sBGR;

typedef sBGR *pBGR;
#pragma pack(pop)


// Returns the DI (Device Independent) bits of the Bitmap
// Here I use 32 bit since it's easy to address in memory and no
// padding of the horizontal lines is required.
static pBGR MyGetDibBits(HDC hdcSrc, HBITMAP hBmpSrc, int nx, int ny)
{
	BITMAPINFO bi;
	int nRes;
	pBGR buf;

	bi.bmiHeader.biSize = sizeof(bi.bmiHeader);
	bi.bmiHeader.biWidth = nx;
	bi.bmiHeader.biHeight = ny;
	bi.bmiHeader.biPlanes = 1;
	bi.bmiHeader.biBitCount = 32;
	bi.bmiHeader.biCompression = BI_RGB;
	bi.bmiHeader.biSizeImage = nx * 4 * ny;
	bi.bmiHeader.biClrUsed = 0;
	bi.bmiHeader.biClrImportant = 0;
	
	buf = (pBGR) malloc(static_cast<size_t>(nx) * 4 * ny);
	nRes = GetDIBits(hdcSrc, hBmpSrc, 0, ny, buf, &bi, DIB_RGB_COLORS);
	if (nRes == 0) {
		free(buf);
		buf = nullptr;
	}
	return buf;
}

static void MySetDibBits(HDC hdcDst, HBITMAP hBmpDst, pBGR pdstBGR, int nx, int ny)
{
	BITMAPINFO bi;

	// Set the new Bitmap
	bi.bmiHeader.biSize = sizeof(bi.bmiHeader);
	bi.bmiHeader.biWidth = nx;
	bi.bmiHeader.biHeight = ny;
	bi.bmiHeader.biPlanes = 1;
	bi.bmiHeader.biBitCount = 32;
	bi.bmiHeader.biCompression = BI_RGB;
	bi.bmiHeader.biSizeImage = nx * 4 * ny;
	bi.bmiHeader.biClrUsed = 0;
	bi.bmiHeader.biClrImportant = 0;
	SetDIBits(hdcDst, hBmpDst, 0, ny, pdstBGR, &bi, DIB_RGB_COLORS);
}

CString BCMenuData::GetString(void)//returns the menu text
//depending on the MFC-Version we are using
{
	CString strText;
	if (m_szMenuText)
    {
		strText = m_szMenuText;
    }
	return strText;
}

CTypedPtrArray<CPtrArray, HMENU> BCMenu::m_AllSubMenus;  // Stores list of all sub-menus

IMPLEMENT_DYNAMIC( BCMenu, CMenu )

/*
===============================================================================
BCMenu::BCMenu()
BCMenu::~BCMenu()
-----------------

Constructor and Destructor.

===============================================================================
*/

BCMenu::BCMenu()
{
	// set the color used for the transparent background in all bitmaps
	m_bitmapBackground=RGB(192,192,192); //gray
	m_bitmapBackgroundFlag=false;
	m_loadmenu=false;
	if (m_hTheme==nullptr && IsThemeActive())
	{
		m_hTheme = OpenThemeData(nullptr, _T("MENU"));
		if (m_hTheme != nullptr)
		{
			const int dpi = CClientDC(CWnd::GetDesktopWindow()).GetDeviceCaps(LOGPIXELSX);
			auto resizeMargins = [dpi](MARGINS& margins)
			{
				margins.cxLeftWidth = MulDiv(margins.cxLeftWidth, dpi, 96);
				margins.cxRightWidth = MulDiv(margins.cxRightWidth, dpi, 96);
				margins.cyTopHeight = MulDiv(margins.cyTopHeight, dpi, 96);
				margins.cyBottomHeight = MulDiv(margins.cyBottomHeight, dpi, 96);
			};
			MARGINS marginCheckBg, marginArrow;	
			GetThemePartSize(m_hTheme, nullptr, MENU_POPUPCHECK, 0, nullptr, TS_TRUE, &m_sizeCheck);
			GetThemeMargins(m_hTheme, nullptr, MENU_POPUPCHECK, 0, TMT_CONTENTMARGINS, nullptr, &m_marginCheck);
			GetThemePartSize(m_hTheme, nullptr, MENU_POPUPSEPARATOR, 0, nullptr, TS_TRUE, &m_sizeSeparator); 
			GetThemeMargins(m_hTheme, nullptr, MENU_POPUPSEPARATOR, 0, TMT_SIZINGMARGINS, nullptr, &m_marginSeparator);
			GetThemeMargins(m_hTheme, nullptr, MENU_POPUPCHECKBACKGROUND, 0, TMT_CONTENTMARGINS, nullptr, &marginCheckBg);
			GetThemeMargins(m_hTheme, nullptr, MENU_POPUPSUBMENU, 0, TMT_CONTENTMARGINS, nullptr, &marginArrow);
			GetThemeInt(m_hTheme, MENU_POPUPBACKGROUND, 0, TMT_BORDERSIZE, &m_textBorder);
			GetThemeColor(m_hTheme, MENU_POPUPITEM, MPI_NORMAL, TMT_TEXTCOLOR, &m_menuTextColor);
			GetThemeColor(m_hTheme, MENU_POPUPBACKGROUND, 0, TMT_FILLCOLOR, &m_menuBgColor);
			for (auto* pmargins : { &m_marginCheck, &m_marginSeparator, &marginCheckBg, &marginArrow })
				resizeMargins(*pmargins);
			m_textBorder = MulDiv(m_textBorder, dpi, 96);
			m_checkBgWidth = m_marginCheck.cxLeftWidth + m_sizeCheck.cx + m_marginCheck.cxRightWidth;
			m_gutterWidth = marginCheckBg.cxLeftWidth + m_checkBgWidth + marginCheckBg.cxRightWidth;
			m_arrowWidth = marginArrow.cxRightWidth;
		}
	}
}


BCMenu::~BCMenu()
{
	BCMenu::DestroyMenu();
}

BCMenuData::~BCMenuData()
{
	delete[] m_szMenuText; //Need not check for nullptr because ANSI X3J16 allows "delete nullptr"
}


void BCMenuData::SetWideString(const wchar_t *szWideString)
{
	delete[] m_szMenuText;//Need not check for nullptr because ANSI X3J16 allows "delete nullptr"
	
	if (szWideString)
    {
		const size_t MenuSiz = wcslen(szWideString) + 1;
		m_szMenuText = new wchar_t[MenuSiz];
		wcscpy_s(m_szMenuText, MenuSiz, szWideString);
    }
	else
		m_szMenuText=nullptr;//set to nullptr so we need not bother about dangling non-nullptr Ptrs
}

void BCMenu::DisableOwnerDraw()
{
	m_bEnableOwnerDraw = false;
	RecreateRadioDotBitmap();
}

void BCMenu::RecreateRadioDotBitmap()
{
	CBitmap* pBitmap = CreateRadioDotBitmap();
	if (afxData.hbmMenuDot)
		DeleteObject(afxData.hbmMenuDot);
	afxData.hbmMenuDot = reinterpret_cast<HBITMAP>(pBitmap->Detach());
	delete pBitmap;
}

bool BCMenu::IsMenu(HMENU submenu)
{
	INT_PTR m;
	INT_PTR numSubMenus = m_AllSubMenus.GetUpperBound();
	for(m=0;m<=numSubMenus;++m){
		if(submenu==m_AllSubMenus[m] || 
		  static_cast<UINT>(reinterpret_cast<uintptr_t>(submenu)) == static_cast<UINT>(reinterpret_cast<uintptr_t>(m_AllSubMenus[m])))
			return true;
	}
	return false;
}

BOOL BCMenu::DestroyMenu()
{
	// Destroy Sub menus:
	INT_PTR m,n;
	INT_PTR numAllSubMenus = m_AllSubMenus.GetUpperBound();
	for(n = numAllSubMenus; n>= 0; n--){
		if(m_AllSubMenus[n]==this->m_hMenu)m_AllSubMenus.RemoveAt(n);
	}
	INT_PTR numSubMenus = m_SubMenus.GetUpperBound();
	for(m = numSubMenus; m >= 0; m--){
		numAllSubMenus = m_AllSubMenus.GetUpperBound();
		for(n = numAllSubMenus; n>= 0; n--){
			if(m_AllSubMenus[n]==m_SubMenus[m])m_AllSubMenus.RemoveAt(n);
		}
		CMenu *ptr=FromHandle(m_SubMenus[m]);
		if(ptr != nullptr){
			bool flag = !!ptr->IsKindOf(RUNTIME_CLASS( BCMenu ));
			if(flag)delete(static_cast<BCMenu *>(ptr));
		}
	}
	m_SubMenus.RemoveAll();
	// Destroy menu data
	INT_PTR numItems = m_MenuList.GetUpperBound();
	for(m = 0; m <= numItems; m++)delete(m_MenuList[m]);
	m_MenuList.RemoveAll();
	// Call base-class implementation last:
	return CMenu::DestroyMenu();
};

/*
==========================================================================
void BCMenu::DrawItem(LPDRAWITEMSTRUCT)
---------------------------------------

  Called by the framework when a particular item needs to be drawn.  We
  override this to draw the menu item in a custom-fashion, including icons
  and the 3D rectangle bar.
  ==========================================================================
*/

void BCMenu::DrawItem (LPDRAWITEMSTRUCT lpDIS)
{
	ASSERT(lpDIS != nullptr);
	LoadImages();
	CDC* pDC = CDC::FromHandle(lpDIS->hDC);
	if((pDC->GetDeviceCaps(RASTERCAPS) & RC_PALETTE) != 0)DrawItem_Win9xNT2000(lpDIS);
	else{
		if (m_hTheme == nullptr || !IsThemeActive())
			DrawItem_Win9xNT2000(lpDIS);
		else
			DrawItem_Theme(lpDIS);
	}
}

void BCMenu::DrawItem_Win9xNT2000 (LPDRAWITEMSTRUCT lpDIS)
{
	ASSERT(lpDIS != nullptr);
	CDC* pDC = CDC::FromHandle(lpDIS->hDC);
	CRect rect;
	UINT state0 = reinterpret_cast<BCMenuData*>(lpDIS->itemData)->nFlags;
	COLORREF clrBack=GetSysColor(COLOR_MENU);
	CBrush brBackground(clrBack);

	if((state0 & MF_SEPARATOR) != 0){
		rect.CopyRect(&lpDIS->rcItem);
		pDC->FillRect (rect,&brBackground);
		rect.top += (rect.Height()>>1);
		pDC->DrawEdge(&rect,EDGE_ETCHED,BF_TOP);
	}
	else{
		CRect rect2;
		bool standardflag = false;
		bool selectedflag = false;
		bool disableflag = false;
		COLORREF crText = GetSysColor(COLOR_MENUTEXT);
		int dy;
		INT_PTR xoffset=-1;
		
		// set some colors
		CPen penBack(PS_SOLID,0,clrBack);
		CBrush brSelect(GetSysColor(COLOR_HIGHLIGHT));
		
		// draw the colored rectangle portion
		
		rect.CopyRect(&lpDIS->rcItem);
		rect2=rect;
		
		// draw the up/down/focused/disabled state
		
		UINT state = lpDIS->itemState;
		CString strText;
		
		if(lpDIS->itemData != NULL){
			BCMenuData *mdata = reinterpret_cast<BCMenuData *>(lpDIS->itemData);
			strText = mdata->GetString();

			xoffset=mdata->global_offset;
			
			if((state&ODS_CHECKED)!=0 && xoffset<0){
			}
			else if(xoffset != -1){
				standardflag=true;
				if((state&ODS_SELECTED)!=0 && (state&ODS_GRAYED)==0)
					selectedflag=true;
				else 
				if((state&ODS_GRAYED)!=0) 
					disableflag=true;
			}
		}
		else{
			strText.Empty();
		}
		
		if((state&ODS_SELECTED)!=0){ // draw the down edges
			
			CPen *pOldPen = pDC->SelectObject (&penBack);
			
			// You need only Text highlight and thats what you get
			
			if(standardflag||selectedflag||disableflag||(state&ODS_CHECKED)!=0)
				rect2.SetRect(rect.left+m_iconX+4+BCMENU_GAP,rect.top,rect.right,rect.bottom);
			pDC->FillRect (rect2,&brSelect);
			
			pDC->SelectObject (pOldPen);
			crText = GetSysColor(COLOR_HIGHLIGHTTEXT);
		}
		else {
			CPen *pOldPen = pDC->SelectObject (&penBack);
			pDC->FillRect (rect,&brBackground);
			pDC->SelectObject (pOldPen);
			
			// draw the up edges	
			pDC->Draw3dRect (rect,clrBack,clrBack);
		}
		
		// draw the text if there is any
		//We have to paint the text only if the image is nonexistant
		
		dy = (rect.Height()-4-m_iconY)/2;
		dy = dy<0 ? 0 : dy;
		
		if(standardflag||selectedflag||disableflag){
			rect2.SetRect(rect.left+1,rect.top+1+dy,rect.left+m_iconX+3,
				rect.top+m_iconY+3+dy);
			pDC->Draw3dRect (rect2,clrBack,clrBack);
			if(disableflag){
				if(!selectedflag){
					CBitmap bitmapstandard;
					GetBitmapFromImageList(pDC,(int)xoffset,bitmapstandard);
					rect2.SetRect(rect.left,rect.top+dy,rect.left+m_iconX+4,
                        rect.top+m_iconY+4+dy);
					pDC->Draw3dRect (rect2,clrBack,clrBack);
					if(hicolor_bitmaps)
						DitherBlt3(pDC,rect.left+2,rect.top+2+dy,m_iconX,m_iconY,
						bitmapstandard,clrBack);
					else
						DitherBlt2(pDC,rect.left+2,rect.top+2+dy,m_iconX,m_iconY,
						bitmapstandard,0,0,clrBack);
				}
			}
			else if(selectedflag){
				pDC->FillRect (rect2,&brBackground);
				rect2.SetRect(rect.left,rect.top+dy,rect.left+m_iconX+4,
					rect.top+m_iconY+4+dy);
				if(state&ODS_CHECKED)
					pDC->Draw3dRect(rect2,GetSysColor(COLOR_3DSHADOW),
					GetSysColor(COLOR_3DHILIGHT));
				else
					pDC->Draw3dRect(rect2,GetSysColor(COLOR_3DHILIGHT),
					GetSysColor(COLOR_3DSHADOW));
				CPoint ptImage(rect.left+2,rect.top+2+dy);
				if(xoffset >= 0) m_AllImages.Draw(pDC,(int)xoffset,ptImage,ILD_TRANSPARENT);
			}
			else{
				if(state&ODS_CHECKED){
					CBrush cbTemp = LightenColor(clrBack, 0.6);
					pDC->FillRect(rect2,&cbTemp);
					rect2.SetRect(rect.left,rect.top+dy,rect.left+m_iconX+4,
                        rect.top+m_iconY+4+dy);
					pDC->Draw3dRect(rect2,GetSysColor(COLOR_3DSHADOW),
					GetSysColor(COLOR_3DHILIGHT));
				}
				else{
					pDC->FillRect (rect2,&brBackground);
					rect2.SetRect(rect.left,rect.top+dy,rect.left+m_iconX+4,
                        rect.top+m_iconY+4+dy);
					pDC->Draw3dRect (rect2,clrBack,clrBack);
				}
				CPoint ptImage(rect.left+2,rect.top+2+dy);
				if(xoffset >= 0) m_AllImages.Draw(pDC,(int)xoffset,ptImage,ILD_TRANSPARENT);
			}
		}
		if(xoffset<0 && (state&ODS_CHECKED)!=0){
			rect2.SetRect(rect.left+1,rect.top+2+dy,rect.left+m_iconX+1,
				rect.top+m_iconY+2+dy);
			CMenuItemInfo info;
			info.fMask = MIIM_CHECKMARKS;
			::GetMenuItemInfo((HMENU)lpDIS->hwndItem,lpDIS->itemID,
				MF_BYCOMMAND, &info);
			if((state&ODS_CHECKED)!=0 || info.hbmpUnchecked!=nullptr) {
				Draw3DCheckmark(pDC, rect2, (state&ODS_SELECTED)!=0,
					(state&ODS_CHECKED)!=0 ? info.hbmpChecked : info.hbmpUnchecked);
			}
		}
		
		//This is needed always so that we can have the space for check marks
		
		rect.left = rect.left + m_iconX + 8 + BCMENU_GAP; 
		
		if(!strText.IsEmpty()){
			
			CRect rectt(rect.left,rect.top-1,rect.right,rect.bottom-1);
			
			//   Find tabs
			
			CString leftStr,rightStr;
			leftStr.Empty();rightStr.Empty();
			int tablocr=strText.ReverseFind(_T('\t'));
			if(tablocr!=-1){
				rightStr=strText.Mid(tablocr+1);
				leftStr=strText.Left(strText.Find(_T('\t')));
				rectt.right-=m_iconX;
			}
			else leftStr=strText;
			
			int iOldMode = pDC->GetBkMode();
			pDC->SetBkMode( TRANSPARENT);
			
			// Draw the text in the correct colour:
			
			UINT nFormat  = DT_LEFT|DT_SINGLELINE|DT_VCENTER;
			UINT nFormatr = DT_RIGHT|DT_SINGLELINE|DT_VCENTER;
			if((lpDIS->itemState & ODS_GRAYED)==0){
				pDC->SetTextColor(crText);
				pDC->DrawText (leftStr,rectt,nFormat);
				if(tablocr!=-1) pDC->DrawText (rightStr,rectt,nFormatr);
			}
			else{
				
				// Draw the disabled text
				if((state & ODS_SELECTED)==0){
					RECT offset = *rectt;
					offset.left+=1;
					offset.right+=1;
					offset.top+=1;
					offset.bottom+=1;
					pDC->SetTextColor(GetSysColor(COLOR_BTNHILIGHT));
					pDC->DrawText(leftStr,&offset, nFormat);
					if(tablocr!=-1) pDC->DrawText (rightStr,&offset,nFormatr);
					pDC->SetTextColor(GetSysColor(COLOR_GRAYTEXT));
					pDC->DrawText(leftStr,rectt, nFormat);
					if(tablocr!=-1) pDC->DrawText (rightStr,rectt,nFormatr);
				}
				else{
					// And the standard Grey text:
					pDC->SetTextColor(clrBack);
					pDC->DrawText(leftStr,rectt, nFormat);
					if(tablocr!=-1) pDC->DrawText (rightStr,rectt,nFormatr);
				}
			}
			pDC->SetBkMode( iOldMode );
		}
	}
}

inline COLORREF BCMenu::LightenColor(COLORREF col,double factor)
{
	if(factor>0.0&&factor<=1.0){
		BYTE red,green,blue,lightred,lightgreen,lightblue;
		red = GetRValue(col);
		green = GetGValue(col);
		blue = GetBValue(col);
		lightred = (BYTE)((factor*(255-red)) + red);
		lightgreen = (BYTE)((factor*(255-green)) + green);
		lightblue = (BYTE)((factor*(255-blue)) + blue);
		col = RGB(lightred,lightgreen,lightblue);
	}
	return col;
}

void BCMenu::DrawItem_Theme(LPDRAWITEMSTRUCT lpDIS)
{
	ASSERT(lpDIS != nullptr);
	CDC* pDC = CDC::FromHandle(lpDIS->hDC);
	HDC hDC = lpDIS->hDC;
	CRect rect(&lpDIS->rcItem);
	UINT state = lpDIS->itemState;
	CRect rectGutter(rect.left, rect.top, rect.left + m_gutterWidth, rect.bottom);

	const int stateId =
		(state & ODS_GRAYED)!=0 ?
			((state & ODS_SELECTED)!=0 ? MPI_DISABLEDHOT : MPI_DISABLED)
		:
			((state & ODS_SELECTED)!=0 ? MPI_HOT : MPI_NORMAL);

	DrawThemeBackground(m_hTheme, hDC, MENU_POPUPBACKGROUND, 0, &rect, nullptr);
	DrawThemeBackground(m_hTheme, hDC, MENU_POPUPGUTTER, 0, &rectGutter, nullptr);
	DrawThemeBackground(m_hTheme, hDC, MENU_POPUPITEM, stateId, &rect, nullptr);
	
	BCMenuData *mdata = reinterpret_cast<BCMenuData*>(lpDIS->itemData);
	if(mdata == nullptr)
		return;

	if ((mdata->nFlags & MF_SEPARATOR)!=0){
		CRect rectSeparator(rectGutter.right + m_marginSeparator.cxLeftWidth,
			rect.top + m_marginSeparator.cyTopHeight,
		    rect.right - m_marginSeparator.cxRightWidth,
			rect.top + m_marginSeparator.cyTopHeight + m_sizeSeparator.cy);
		DrawThemeBackground(m_hTheme, hDC, MENU_POPUPSEPARATOR, 0, &rectSeparator, nullptr);
		return;
	}

	INT_PTR xoffset = mdata->global_offset;
	CString	strText = mdata->GetString();

	int cxSMIcon = GetSystemMetrics(SM_CXSMICON);
	int cySMIcon = GetSystemMetrics(SM_CYSMICON);

	if(xoffset >= 0){
		CImage bitmapstandard;
		GetBitmapFromImageList(pDC,(int)xoffset,bitmapstandard);
		if((state & ODS_GRAYED)!=0)
			GetDisabledBitmap(bitmapstandard);
		m_gdiplusToken.InitGdiplus();
		Gdiplus::Bitmap bm(bitmapstandard.GetWidth(), bitmapstandard.GetHeight(), 
			bitmapstandard.GetPitch(), PixelFormat32bppARGB, (BYTE *)bitmapstandard.GetBits());
		Gdiplus::Graphics dcDst(pDC->m_hDC);
		dcDst.SetInterpolationMode(Gdiplus::InterpolationModeHighQualityBicubic);
		Gdiplus::Rect rcDst(
			static_cast<int>(rect.left + (rectGutter.right - cxSMIcon) / 2.0 + 0.5),
			static_cast<int>(rect.top  + (rect.Height() - cySMIcon) / 2.0 + 0.5),
			cxSMIcon, cySMIcon);
		dcDst.DrawImage(&bm, rcDst, 0, 0, m_iconX, m_iconY, Gdiplus::UnitPixel);
	}
	if(xoffset < 0 && (state&ODS_CHECKED)!=0){
		CMenuItemInfo info;
		info.fMask = MIIM_CHECKMARKS;
		::GetMenuItemInfo((HMENU)lpDIS->hwndItem,lpDIS->itemID,
			MF_BYCOMMAND, &info);
		if((state&ODS_CHECKED)!=0 || (info.hbmpUnchecked != nullptr)) {
			int stateIdCheck = 0;
			if (info.hbmpChecked == nullptr)
				stateIdCheck = (state & ODS_GRAYED)!=0 ? MC_CHECKMARKDISABLED : MC_CHECKMARKNORMAL;
			else
				stateIdCheck = (state & ODS_GRAYED)!=0 ? MC_BULLETDISABLED : MC_BULLETNORMAL;
			int stateIdCheckBk = (state & ODS_GRAYED)!=0 ? MCB_DISABLED : MCB_NORMAL;
			CRect rectCheck(
				rect.left + m_marginCheck.cxLeftWidth,
				rect.top + m_marginCheck.cyTopHeight,
				rect.left + m_marginCheck.cxLeftWidth + m_sizeCheck.cx,
				rect.top + m_marginCheck.cyTopHeight + m_sizeCheck.cy);
			CRect rectCheckBg(rect.left,rect.top,rect.left+m_checkBgWidth,rect.bottom);
			DrawThemeBackground(m_hTheme, hDC, MENU_POPUPCHECKBACKGROUND, stateIdCheckBk, &rectCheckBg, nullptr);
			DrawThemeBackground(m_hTheme, hDC, MENU_POPUPCHECK, stateIdCheck, &rectCheck, nullptr);
		}
	}
	
	if(!strText.IsEmpty()){
		
		CRect rectt(rectGutter.right + m_textBorder, rect.top, rect.right, rect.bottom);
		
		//   Find tabs
		
		CString leftStr,rightStr;
		leftStr.Empty();rightStr.Empty();
		int tablocr=strText.ReverseFind(_T('\t'));
		if(tablocr!=-1){
			rightStr=strText.Mid(tablocr+1);
			leftStr=strText.Left(strText.Find(_T('\t')));
			rectt.right-=cxSMIcon;
		}
		else leftStr=strText;
		
		// Draw the text in the correct colour:
		DWORD nFormat  = DT_LEFT|DT_SINGLELINE|DT_VCENTER;
		DWORD nFormatr = DT_RIGHT|DT_SINGLELINE|DT_VCENTER;
		DrawThemeText(m_hTheme, hDC, MENU_POPUPITEM, stateId, leftStr, leftStr.GetLength(), nFormat, 0, &rectt);
		if(tablocr!=-1) DrawThemeText(m_hTheme, hDC, MENU_POPUPITEM, stateId, rightStr, rightStr.GetLength(), nFormatr, 0, &rectt);
	}
}

bool BCMenu::GetBitmapFromImageList(CDC* pDC,int nIndex,CImage &bmp)
{
	CDC dc;
	dc.CreateCompatibleDC(pDC);
	bmp.Create(m_iconX, -m_iconY, 32, CImage::createAlphaChannel);
	memset(bmp.GetBits(), 0xff, static_cast<size_t>(abs(bmp.GetPitch())) * m_iconY);
	HGDIOBJ pOldBmp = dc.SelectObject(bmp.operator HBITMAP());
	POINT pt = {0};
	SIZE  sz = {m_iconX, m_iconY};

	IMAGELISTDRAWPARAMS drawing;

	drawing.cbSize = IMAGELISTDRAWPARAMS_V3_SIZE;
	drawing.himl = m_AllImages.m_hImageList;
	drawing.i = nIndex;
	drawing.hdcDst = dc.m_hDC;
	drawing.x = pt.x;
	drawing.y = pt.y;
	drawing.cx = sz.cx;
	drawing.cy = sz.cy;
	drawing.xBitmap = pt.x;
	drawing.yBitmap = pt.y;
	drawing.rgbBk = CLR_NONE;
	drawing.rgbFg = CLR_DEFAULT;
	drawing.fStyle = ILD_NORMAL;
	drawing.dwRop = SRCCOPY;

	ImageList_DrawIndirect(&drawing);

	int pitch = bmp.GetPitch();
	BYTE *p = (BYTE *)bmp.GetBits();
	for (int y = 0; y < m_iconY; ++y)
	{
		for (int x = 0; x < m_iconX; ++x)
		{
			if (p[x * 4 + y * pitch + 3] == 0xff)
				p[x * 4 + y * pitch + 3] = 0;
			else
				p[x * 4 + y * pitch + 3] = 0xff;
		}
	}

	dc.SelectObject( pOldBmp );
	return true;
}

bool BCMenu::GetBitmapFromImageList(CDC* pDC,int nIndex,CBitmap &bmp)
{
	CDC dc;
	dc.CreateCompatibleDC(pDC);
	bmp.CreateCompatibleBitmap(pDC,m_iconX,m_iconY);
	CBitmap* pOldBmp = dc.SelectObject(&bmp);
	POINT pt = {0};
	SIZE  sz = {m_iconX, m_iconY};

	IMAGELISTDRAWPARAMS drawing;

	drawing.cbSize = IMAGELISTDRAWPARAMS_V3_SIZE;
	drawing.himl = m_AllImages.m_hImageList;
	drawing.i = nIndex;
	drawing.hdcDst = dc.m_hDC;
	drawing.x = pt.x;
	drawing.y = pt.y;
	drawing.cx = sz.cx;
	drawing.cy = sz.cy;
	drawing.xBitmap = pt.x;
	drawing.yBitmap = pt.y;
	drawing.rgbBk = GetSysColor(COLOR_3DFACE);
	drawing.rgbFg = CLR_DEFAULT;
	drawing.fStyle = ILD_NORMAL;
	drawing.dwRop = SRCCOPY;

	ImageList_DrawIndirect(&drawing);

	dc.SelectObject( pOldBmp );
	return true;
}

/*
==========================================================================
void BCMenu::MeasureItem(LPMEASUREITEMSTRUCT)
---------------------------------------------

  Called by the framework when it wants to know what the width and height
  of our item will be.  To accomplish this we provide the width of the
  icon plus the width of the menu text, and then the height of the icon.
  
	==========================================================================
*/

void BCMenu::MeasureItem( LPMEASUREITEMSTRUCT lpMIS )
{
	UINT state = reinterpret_cast<BCMenuData*>(lpMIS->itemData)->nFlags;
	if((state & MF_SEPARATOR)!=0){
		lpMIS->itemWidth = 0;
		if (m_hTheme != nullptr)
			lpMIS->itemHeight = m_marginSeparator.cyTopHeight + m_sizeSeparator.cy + m_marginSeparator.cyBottomHeight;
		else
			lpMIS->itemHeight = 3;
	}
	else{
		CFont fontMenu;
		NONCLIENTMETRICS nm = { sizeof NONCLIENTMETRICS };
		VERIFY(::SystemParametersInfo(SPI_GETNONCLIENTMETRICS,
			nm.cbSize,&nm,0)); 
		fontMenu.CreateFontIndirect (&nm.lfMenuFont);
		
		// Obtain the width of the text:
		CClientDC dc(AfxGetMainWnd() ? AfxGetMainWnd() : CWnd::GetDesktopWindow());     // Get device context
		CFont* pFont=nullptr;    // Select menu font in...
		
		pFont = dc.SelectObject (&fontMenu);// Select menu font in...
        
		//Get pointer to text SK
		const wchar_t *lpstrText = reinterpret_cast<BCMenuData*>(lpMIS->itemData)->GetWideString();//SK: we use const to prevent misuse
		    
		SIZE size;
		size.cx=size.cy=0;
		
		VERIFY(::GetTextExtentPoint32W(dc.m_hDC,lpstrText,
			lstrlenW(lpstrText),&size)); //SK should also work on 95
		CSize t = CSize(size);
		dc.SelectObject (pFont);  // Select old font in
		
		// Set width and height:
		
		int temp = GetSystemMetrics(SM_CYMENU);
		const int BCMENU_PAD=4;
		lpMIS->itemHeight = temp>m_iconY+BCMENU_PAD ? temp : m_iconY+BCMENU_PAD;
		if (m_hTheme == nullptr)
		{
			lpMIS->itemWidth = m_iconX + BCMENU_PAD + 8 + t.cx;
		}
		else
		{
			lpMIS->itemWidth = m_gutterWidth+m_textBorder+t.cx+m_arrowWidth;
			unsigned menuHeight = static_cast<unsigned>(
				m_sizeCheck.cy + m_marginCheck.cyTopHeight + m_marginCheck.cyBottomHeight);
			if (menuHeight > lpMIS->itemHeight)
				lpMIS->itemHeight = menuHeight;
		}
	}
}

bool BCMenu::AppendODMenu(const wchar_t *lpstrText,UINT nFlags,UINT_PTR nID,
                           int nIconNormal)
{
	// Add the MF_OWNERDRAW flag if not specified:
	if(nID == 0){
		if((nFlags&MF_BYPOSITION)!=0)
			nFlags=MF_SEPARATOR|MakeOwnerDrawFlag()|MF_BYPOSITION;
		else 
			nFlags=MF_SEPARATOR|MakeOwnerDrawFlag();
	}
	else 
	if((nFlags & MF_OWNERDRAW)==0)
		nFlags |= MakeOwnerDrawFlag();
	
	if((nFlags & MF_POPUP)!=0){
		m_AllSubMenus.Add((HMENU)nID);
		m_SubMenus.Add((HMENU)nID);
	}
	
	BCMenuData *mdata = new BCMenuData;
	m_MenuList.Add(mdata);
	mdata->SetWideString(lpstrText);    //SK: modified for dynamic allocation
	
	if(nIconNormal>=0){
		mdata->global_offset = AddToGlobalImageList(nIconNormal,static_cast<int>(nID));
	}
	else mdata->global_offset = GlobalImageListOffset(static_cast<int>(nID));

	mdata->nFlags = nFlags;
	mdata->nID = nID;
	bool returnflag=!!CMenu::AppendMenu(nFlags, nID, MakeItemData(mdata));
	if(m_loadmenu)RemoveTopLevelOwnerDraw();
	return returnflag;
}

bool BCMenu::InsertODMenu(UINT nPosition,wchar_t *lpstrText,UINT nFlags,UINT_PTR nID,
                           int nIconNormal)
{
	if((nFlags & MF_BYPOSITION) == 0){
		UINT iPosition =0;
		BCMenu* pMenu = FindMenuOption(nPosition,iPosition);
		if(pMenu != nullptr){
			return pMenu->InsertODMenu(iPosition,lpstrText,nFlags|MF_BYPOSITION,nID,nIconNormal);
		}
		else return false;
	}
	
	if(nID==0)
		nFlags=MF_SEPARATOR|MakeOwnerDrawFlag()|MF_BYPOSITION;
	else 
	if((nFlags & MF_OWNERDRAW)==0)
		nFlags |= MakeOwnerDrawFlag();

	int menustart=0;

	if((nFlags & MF_POPUP)!=0){
		if(m_loadmenu){
			menustart=GetMenuStart();
			if(nPosition<(UINT)menustart)menustart=0;
		}
		m_AllSubMenus.Add((HMENU)nID);
		m_SubMenus.Add((HMENU)nID);
	}

	//Stephane Clog suggested adding this, believe it or not it's in the help 
	if(nPosition==(UINT)-1)nPosition=GetMenuItemCount();
	
	BCMenuData *mdata = new BCMenuData;
	m_MenuList.InsertAt(nPosition-menustart,mdata);
	mdata->SetWideString(lpstrText);    //SK: modified for dynamic allocation
	
	if(nIconNormal>=0){
		mdata->global_offset = AddToGlobalImageList(nIconNormal, static_cast<int>(nID));
	}
	else mdata->global_offset = GlobalImageListOffset(static_cast<int>(nID));
	mdata->nFlags = nFlags;
	mdata->nID = nID;
	bool returnflag=!!CMenu::InsertMenu(nPosition,nFlags,nID,MakeItemData(mdata));
	if(m_loadmenu)RemoveTopLevelOwnerDraw();
	return returnflag;
}

bool BCMenu::ModifyODMenu(const wchar_t *lpstrText,UINT_PTR nID,int nIconNormal)
{
	UINT nLoc;
	BCMenuData *mdata;
	CArray<BCMenu*,BCMenu*>bcsubs;
	CArray<UINT,UINT&>bclocs;
	
	// Find the old BCMenuData structure:
	BCMenu *psubmenu = FindMenuOption(static_cast<int>(nID),nLoc);
	do{
		if(psubmenu!=nullptr && nLoc!=-1)mdata = psubmenu->m_MenuList[nLoc];
		else{
			// Create a new BCMenuData structure:
			mdata = new BCMenuData;
			m_MenuList.Add(mdata);
		}
		
		ASSERT(mdata != nullptr);
		if(lpstrText != nullptr)
			mdata->SetWideString(lpstrText);  //SK: modified for dynamic allocation
		if(nIconNormal>=0){
			mdata->global_offset = AddToGlobalImageList(nIconNormal, static_cast<int>(nID));
		}
		else mdata->global_offset = GlobalImageListOffset(static_cast<int>(nID));
		mdata->nFlags &= ~(MF_BYPOSITION);
		mdata->nFlags |= MakeOwnerDrawFlag();
		mdata->nID = nID;
		bcsubs.Add(psubmenu);
		bclocs.Add(nLoc);
		if(psubmenu!=nullptr && nLoc!=-1)
			psubmenu = FindAnotherMenuOption(static_cast<int>(nID),nLoc,bcsubs,bclocs);
		else 
			psubmenu=nullptr;
	}while(psubmenu != nullptr);
	return !!CMenu::ModifyMenu(static_cast<UINT>(nID),mdata->nFlags, static_cast<UINT>(nID),MakeItemData(mdata));
}

BCMenuData *BCMenu::NewODMenu(UINT pos,UINT nFlags,UINT_PTR nID,CString string)
{
	BCMenuData *mdata;
	
	mdata = new BCMenuData;
	mdata->SetWideString((LPCTSTR)string);//SK: modified for dynamic allocation
	mdata->nFlags = nFlags;
	mdata->nID = nID;
	
//	if((nFlags & MF_POPUP)!=0)m_AllSubMenus.Add((HMENU)nID);
		
	if ((nFlags&MF_OWNERDRAW)!=0){
		ModifyMenu(pos,nFlags,nID,MakeItemData(mdata));
	}
	else
	if ((nFlags&MF_SEPARATOR)!=0){
		ModifyMenu(pos,nFlags,nID);
	}
	else{
		ModifyMenu(pos,nFlags,nID,mdata->GetString());
	}
	
	return mdata;
};

bool BCMenu::LoadToolbar(UINT nToolBar, CToolBar* pBar)
{
	bool returnflag=false;
	CToolBar barIns;
	CToolBar& bar = pBar ? *pBar : barIns;
	
	if (!pBar)
	{
		CWnd* pWnd = AfxGetMainWnd();
		if (pWnd == nullptr)pWnd = CWnd::GetDesktopWindow();
		bar.Create(pWnd);
	}
	if(pBar || bar.LoadToolBar(nToolBar)){
		returnflag=true;
		for(int i=0;i<bar.GetCount();++i){
			UINT nID = bar.GetItemID(i); 
			if(nID!=0 && GetMenuState(nID, MF_BYCOMMAND)!=0xFFFFFFFF){
				int xoffset=bar.CommandToIndex(nID);
				if(xoffset>=0){
					UINT nStyle;
					int xset;
					bar.GetButtonInfo(xoffset,nID,nStyle,xset);
					if(xset>0)xoffset=xset;
				}
				ModifyODMenu(nullptr, nID, MAKELONG(nToolBar, 0x4000 + xoffset));
			}
		}
	}
	return returnflag;
}

// O.S.
BCMenuData *BCMenu::FindMenuItem(UINT_PTR nID)
{
	BCMenuData *pData = nullptr;
	int i;
	
	for(i = 0; i <= m_MenuList.GetUpperBound(); i++){
		if (m_MenuList[i]->nID == nID){
			pData = m_MenuList[i];
			break;
		}
	}
	if (pData == nullptr){
		UINT loc;
		BCMenu *pMenu = FindMenuOption(static_cast<int>(nID), loc);
		ASSERT (pMenu != this);
		if (loc != -1){
			return pMenu->FindMenuItem(nID);
		}
	}
	return pData;
}


BCMenu *BCMenu::FindAnotherMenuOption(int nId,UINT& nLoc,CArray<BCMenu*,BCMenu*>&bcsubs,
									  CArray<UINT,UINT&>&bclocs)
{
	BCMenu *psubmenu,*pgoodmenu;
	bool foundflag;
	int nummenu = GetMenuItemCount();
	
	for(int i=0;i<nummenu;++i){
#ifdef _CPPRTTI 
		psubmenu=dynamic_cast<BCMenu *>(GetSubMenu(i));
#else
		psubmenu=static_cast<BCMenu *>(GetSubMenu((int)i));
#endif
		if(psubmenu != nullptr){
			pgoodmenu=psubmenu->FindAnotherMenuOption(nId,nLoc,bcsubs,bclocs);
			if(pgoodmenu != nullptr)
				return pgoodmenu;
		}
		else if(nId==(int)GetMenuItemID(i)){
			INT_PTR numsubs=bcsubs.GetSize();
			foundflag=true;
			for(INT_PTR j=0;j<numsubs;++j){
				if(bcsubs[j]==this && bclocs[j]==static_cast<UINT>(i)){
					foundflag=false;
					break;
				}
			}
			if(foundflag){
				nLoc=static_cast<UINT>(i);
				return this;
			}
		}
	}
	nLoc = static_cast<UINT>(-1);
	return nullptr;
}

BCMenu *BCMenu::FindMenuOption(int nId,UINT& nLoc)
{
	BCMenu *psubmenu,*pgoodmenu;
	int nummenu = GetMenuItemCount();
	
	for(int i=0;i<nummenu;++i){
#ifdef _CPPRTTI 
		psubmenu=dynamic_cast<BCMenu *>(GetSubMenu(i));
#else
		psubmenu=static_cast<BCMenu *>(GetSubMenu(i));
#endif
		if(psubmenu != nullptr){
			pgoodmenu=psubmenu->FindMenuOption(nId,nLoc);
			if(pgoodmenu != nullptr)
				return pgoodmenu;
		}
		else if(nId==(int)GetMenuItemID(i)){
			nLoc=i;
			return this;
		}
	}
	nLoc = static_cast<UINT>(-1);
	return nullptr;
}

BCMenuData *BCMenu::FindMenuOption(wchar_t *lpstrText)
{
	BCMenu *psubmenu;
	BCMenuData *pmenulist;
	int nummenu = GetMenuItemCount();
	
	for(int i=0;i<nummenu;++i){
#ifdef _CPPRTTI 
		psubmenu=dynamic_cast<BCMenu *>(GetSubMenu(i));
#else
		psubmenu=static_cast<BCMenu *>(GetSubMenu(i));
#endif
		if(psubmenu != nullptr){
			pmenulist=psubmenu->FindMenuOption(lpstrText);
			if(pmenulist != nullptr)
				return pmenulist;
		}
		else{
			for(int j=0;j<=m_MenuList.GetUpperBound();++j){     
				const wchar_t *szWide;//SK: we use const to prevent misuse of this Ptr
				szWide = m_MenuList[j]->GetWideString ();
				if(szWide != nullptr && wcscmp(lpstrText,szWide)==0)//SK: modified for dynamic allocation
					return m_MenuList[j];
			}
		}
	}
	return nullptr;
}

BOOL BCMenu::LoadMenu(LPCTSTR lpszResourceName)
{
	ASSERT_VALID(this);
	ASSERT(lpszResourceName != nullptr);
	
	// Find the Menu Resource:
	HINSTANCE hInst = AfxFindResourceHandle(lpszResourceName,RT_MENU);
	HRSRC hRsrc = ::FindResource(hInst,lpszResourceName,RT_MENU);
	if (hRsrc == nullptr){
		hInst = nullptr;
		hRsrc = ::FindResource(hInst,lpszResourceName,RT_MENU);
	}
	if(hRsrc == nullptr)
		return FALSE;
	
	// Load the Menu Resource:
	
	HGLOBAL hGlobal = LoadResource(hInst, hRsrc);
	if(hGlobal == nullptr)
		return FALSE;

	// first destroy the menu if we're trying to loadmenu again
	DestroyMenu();

	// Attempt to create us as a menu...
	if(!CMenu::CreateMenu())
		return FALSE;
	
	// Get Item template Header, and calculate offset of MENUITEMTEMPLATES
	
	MENUITEMTEMPLATEHEADER *pTpHdr=
		(MENUITEMTEMPLATEHEADER*)LockResource(hGlobal);
	BYTE* pTp=(BYTE*)pTpHdr + 
		(sizeof(MENUITEMTEMPLATEHEADER) + pTpHdr->offset);
	
	
	// Variables needed during processing of Menu Item Templates:
	
	WORD    dwFlags = 0;              // Flags of the Menu Item
	WORD    dwID  = 0;              // ID of the Menu Item
	CTypedPtrArray<CPtrArray, BCMenu*>  stack;    // Popup menu stack
	CArray<bool,bool>  stackEnd;    // Popup menu stack
	stack.Add(this);                  // Add it to this...
	stackEnd.Add(false);
	
	do{
		// Obtain Flags and (if necessary), the ID...
		memcpy(&dwFlags, pTp, sizeof(WORD));pTp+=sizeof(WORD);// Obtain Flags
		if((dwFlags & MF_POPUP)==0){
			memcpy(&dwID, pTp, sizeof(WORD)); // Obtain ID
			pTp+=sizeof(WORD);
		}
		else dwID = 0;
		
		UINT uFlags = (UINT)dwFlags; // Remove MF_END from the flags that will
		if((uFlags & MF_END) != 0) // be passed to the Append(OD)Menu functions.
			uFlags -= MF_END;
		
		// Obtain Caption (and length)
		
		const size_t CaptionSiz = wcslen((wchar_t *)pTp)+1;
		wchar_t *szCaption=new wchar_t[CaptionSiz];
		wcscpy_s(szCaption, CaptionSiz, reinterpret_cast<wchar_t *>(pTp));
		pTp=&pTp[(wcslen((wchar_t *)pTp)+1)*sizeof(wchar_t)];//modified SK
		
		// Handle popup menus first....
		
		//WideCharToMultiByte
		if((dwFlags & MF_POPUP)!=0){
			if((dwFlags & MF_END)!=0)
				stackEnd.SetAt(stack.GetUpperBound(),true);
			BCMenu* pSubMenu = new BCMenu;
			pSubMenu->CreatePopupMenu();
			
			// Append it to the top of the stack:
			
			stack[stack.GetUpperBound()]->AppendODMenu(szCaption,uFlags,
				(UINT_PTR)pSubMenu->m_hMenu, -1);
			stack.Add(pSubMenu);
			stackEnd.Add(false);
		}
		else {
			stack[stack.GetUpperBound()]->AppendODMenu(szCaption, uFlags,
				dwID, -1);
			if((dwFlags & MF_END)!=0)
				stackEnd.SetAt(stack.GetUpperBound(),true);
			INT_PTR j = stack.GetUpperBound();
			while(j>=0 && stackEnd.GetAt(j)){
				stack.RemoveAt(j);
				stackEnd.RemoveAt(j);
				--j;
			}
		}
		
		delete[] szCaption;
	}while(stack.GetUpperBound() != -1);
	
	int nummenu = GetMenuItemCount();
	for(int i=0;i<nummenu;++i){
		CString str=m_MenuList[i]->GetString();
		if(GetSubMenu(i)){
			m_MenuList[i]->nFlags=MF_POPUP|MF_BYPOSITION;
			ModifyMenu(i,MF_POPUP|MF_BYPOSITION,
				(UINT_PTR)GetSubMenu(i)->m_hMenu,str);
		}
		else{
			m_MenuList[i]->nFlags=MF_STRING|MF_BYPOSITION;
			ModifyMenu(i,MF_STRING|MF_BYPOSITION,m_MenuList[i]->nID,str);
		}
	}

	m_loadmenu=true;
	
	return TRUE;
}

int BCMenu::GetMenuStart(void)
{
	if(!m_loadmenu)return 0;

	CString name,str;
	int menuloc=-1,listloc=-1,menustart=0,i=0;
	INT_PTR nummenulist=m_MenuList.GetSize();
	int nummenu=GetMenuItemCount();

	while(i<nummenu&&menuloc==-1){
		GetMenuString (i, name, MF_BYPOSITION);
		if(name.GetLength()>0){
			for(int j=0;j<nummenulist;++j){
				str=m_MenuList[j]->GetString();
				if(name==str){
					menuloc=i;
					listloc=j;
					break;
				}
			}
		}
		++i;
	}
	if(menuloc>=0&&listloc>=0&&menuloc>=listloc)menustart=menuloc-listloc;
	return menustart;
}

void BCMenu::RemoveTopLevelOwnerDraw(void)
{
	CString str;
	INT_PTR nummenulist=m_MenuList.GetSize();
	int nummenu = GetMenuItemCount();

	int menustart=GetMenuStart();
	for(int i=menustart,j=0;i<nummenu;++i,++j){
		if(j<nummenulist){
			str=m_MenuList[j]->GetString();
			if(GetSubMenu(i)){
				m_MenuList[j]->nFlags=MF_POPUP|MF_BYPOSITION;
				ModifyMenu(i,MF_POPUP|MF_BYPOSITION,
					(UINT_PTR)GetSubMenu(i)->m_hMenu,str);
			}
		}
	}

}

//--------------------------------------------------------------------------
//[18.06.99 rj]
bool BCMenu::GetMenuText(UINT id, CString& string, UINT nFlags/*= MF_BYPOSITION*/)
{
	bool returnflag=false;
	
	if((MF_BYPOSITION&nFlags) != 0){
		INT_PTR numMenuItems = m_MenuList.GetUpperBound();
		if(static_cast<INT_PTR>(id)<=numMenuItems){
			string=m_MenuList[id]->GetString();
			returnflag=true;
		}
	}
	else{
		UINT uiLoc;
		BCMenu* pMenu = FindMenuOption(id,uiLoc);
		if(pMenu != nullptr) 
			returnflag = pMenu->GetMenuText(uiLoc,string);
	}
	return returnflag;
}


void BCMenu::DrawRadioDot(CDC *pDC,int x,int y,COLORREF color)
{
	CRect rcDot(x,y,x+6,y+6);
	CBrush brush(color);
	CPen pen(PS_SOLID,0,color);
	CBrush *pOldBrush=pDC->SelectObject(&brush);
	CPen *pOldPen=pDC->SelectObject(&pen);
	pDC->Ellipse(&rcDot);
	pDC->SelectObject(pOldBrush);
	pDC->SelectObject(pOldPen);
}

void BCMenu::DrawCheckMark(CDC* pDC,int x,int y,COLORREF color,bool narrowflag /*= false*/)
{
	int dp=0;
	CPen penBack(PS_SOLID,0,color);
	CPen *pOldPen = pDC->SelectObject (&penBack);
	if(narrowflag)dp=1;

	pDC->MoveTo(x,y+2);
	pDC->LineTo(x,y+5-dp);
	
	pDC->MoveTo(x+1,y+3);
	pDC->LineTo(x+1,y+6-dp);
	
	pDC->MoveTo(x+2,y+4);
	pDC->LineTo(x+2,y+7-dp);
	
	pDC->MoveTo(x+3,y+3);
	pDC->LineTo(x+3,y+6-dp);
	
	pDC->MoveTo(x+4,y+2);
	pDC->LineTo(x+4,y+5-dp);
	
	pDC->MoveTo(x+5,y+1);
	pDC->LineTo(x+5,y+4-dp);
	
	pDC->MoveTo(x+6,y);
	pDC->LineTo(x+6,y+3-dp);
	
	pDC->SelectObject (pOldPen);
}

BCMenuData *BCMenu::FindMenuList(UINT_PTR nID)
{
	for(int i=0;i<=m_MenuList.GetUpperBound();++i){
		if(m_MenuList[i]->nID==nID && !m_MenuList[i]->syncflag){
			m_MenuList[i]->syncflag=1;
			return m_MenuList[i];
		}
	}
	return nullptr;
}

void BCMenu::InitializeMenuList(int value)
{
	for(int i=0;i<=m_MenuList.GetUpperBound();++i)
		m_MenuList[i]->syncflag=value;
}

void BCMenu::DeleteMenuList(void)
{
	for(int i=0;i<=m_MenuList.GetUpperBound();++i){
		if(m_MenuList[i]->syncflag==0){
			delete m_MenuList[i];
		}
	}
}

void BCMenu::SetMenuItemBitmap(intptr_t xoffset, int pos, unsigned state)
{
	if (m_AllImagesID[xoffset].state == state && m_AllImagesID[xoffset].pBitmap)
	{
		SetMenuItemBitmaps(static_cast<UINT>(pos), MF_BYPOSITION, m_AllImagesID[xoffset].pBitmap.get(), nullptr);
		return;
	}

	const int cxSMIcon = GetSystemMetrics(SM_CXSMICON);
	const int cySMIcon = GetSystemMetrics(SM_CYSMICON);

	LoadImages();

	BYTE* pBits;
	BITMAPINFO bmi{ sizeof(BITMAPINFOHEADER), cxSMIcon, -cySMIcon, 1, 32, BI_RGB };
	CBitmap *pBitmap = new CBitmap();
	HBITMAP hBitmap = CreateDIBSection(nullptr, &bmi, DIB_RGB_COLORS, (void**)&pBits, nullptr, 0);
	pBitmap->Attach(hBitmap);
	CDC dcMem;
	dcMem.CreateCompatibleDC(nullptr);
	CBitmap* pOldBitmap = dcMem.SelectObject(pBitmap);
	CImage bitmapstandard;
	GetBitmapFromImageList(nullptr, (int)xoffset, bitmapstandard);
	if ((state & ODS_GRAYED) != 0)
		GetDisabledBitmap(bitmapstandard);
	m_gdiplusToken.InitGdiplus();
	Gdiplus::Bitmap bm(bitmapstandard.GetWidth(), bitmapstandard.GetHeight(),
		bitmapstandard.GetPitch(), PixelFormat32bppARGB, (BYTE*)bitmapstandard.GetBits());
	Gdiplus::Graphics dcDst(dcMem.m_hDC);
	dcDst.SetInterpolationMode(Gdiplus::InterpolationModeHighQualityBicubic);
	Gdiplus::Rect rcDst(0, 0, cxSMIcon, cySMIcon);
	dcDst.DrawImage(&bm, rcDst, 0, 0, m_iconX, m_iconY, Gdiplus::UnitPixel);
	dcMem.SelectObject(pOldBitmap);
	SetMenuItemBitmaps(static_cast<UINT>(pos), MF_BYPOSITION, pBitmap, nullptr);
	m_AllImagesID[xoffset].pBitmap.reset(pBitmap);
	m_AllImagesID[xoffset].state = state;
}

void BCMenu::SynchronizeMenu(void)
{
	CTypedPtrArray<CPtrArray, BCMenuData*> temp;
	CString string;
	UINT_PTR submenu,nID=0;
	
	InitializeMenuList(0);
	for(int j=0;j<GetMenuItemCount();++j){
		BCMenuData *mdata=nullptr;
		UINT state=GetMenuState(j,MF_BYPOSITION);
		if((state&MF_POPUP)!=0){
			submenu=(UINT_PTR)GetSubMenu(j)->m_hMenu;
			mdata=FindMenuList(submenu);
			GetMenuString(j,string,MF_BYPOSITION);
			if(mdata == nullptr)mdata=NewODMenu(j,
				(state&0xFF)|MF_BYPOSITION|MF_POPUP|MakeOwnerDrawFlag(),submenu,string);
			else if(string.GetLength()>0)
				mdata->SetWideString(string);  //SK: modified for dynamic allocation
		}
		else 
		if((state&MF_SEPARATOR)!=0){
			mdata=FindMenuList(0);
			if(mdata == nullptr)mdata=NewODMenu(j,
				state|MF_BYPOSITION|MF_SEPARATOR|MakeOwnerDrawFlag(),0,_T(""));//SK: modified for Unicode correctness
			else ModifyMenu(j,mdata->nFlags,nID,MakeItemData(mdata));
		}
		else{
			nID=GetMenuItemID(j);
			mdata=FindMenuList(nID);
			GetMenuString(j,string,MF_BYPOSITION);
			if(mdata == nullptr)
				mdata=NewODMenu(j,state|MF_BYPOSITION|MakeOwnerDrawFlag(),nID,string);
			else{
				mdata->nFlags=state|MF_BYPOSITION|MakeOwnerDrawFlag();
				if(string.GetLength()>0)
					mdata->SetWideString(string);//SK: modified for dynamic allocation
				
				ModifyMenu(j,mdata->nFlags,nID,MakeItemData(mdata));
			}
			if(!m_bEnableOwnerDraw && mdata->global_offset >= 0)
				SetMenuItemBitmap(mdata->global_offset,j,state);
		}
		if(mdata != nullptr)temp.Add(mdata);
	}
	DeleteMenuList();
	m_MenuList.RemoveAll();
	m_MenuList.Append(temp);
	temp.RemoveAll(); 
}

void BCMenu::UpdateMenu(CMenu *pmenu)
{
#ifdef _CPPRTTI 
	BCMenu *psubmenu = dynamic_cast<BCMenu *>(pmenu);
#else
	BCMenu *psubmenu = static_cast<BCMenu *>(pmenu);
#endif
	if(psubmenu != nullptr)psubmenu->SynchronizeMenu();
}

LRESULT BCMenu::FindKeyboardShortcut(UINT nChar, UINT nFlags,
                                     CMenu *pMenu)
{
#ifdef _CPPRTTI 
	BCMenu *pBCMenu = dynamic_cast<BCMenu *>(pMenu);
#else
	BCMenu *pBCMenu = static_cast<BCMenu *>(pMenu);
#endif
	if(pBCMenu!=nullptr && (nFlags&MF_POPUP)!=0){
		CString key(_T('&'),2);//SK: modified for Unicode correctness
		key.SetAt(1,(TCHAR)nChar);
		key.MakeLower();
		CString menutext;
		int menusize = pBCMenu->GetMenuItemCount();
		if(menusize!=(pBCMenu->m_MenuList.GetUpperBound()+1))
			pBCMenu->SynchronizeMenu();
		for(int i=0;i<menusize;++i){
			if(pBCMenu->GetMenuText(i,menutext)){
				menutext.MakeLower();
				if(menutext.Find(key)>=0)return MAKELRESULT(i,2);
			}
		}
	}
	return 0;
}

void BCMenu::GetTransparentBitmap(CBitmap &bmp)
{
	CDC ddc;
	COLORREF col,newcol;
	BITMAP BitMap;

	bmp.GetBitmap(&BitMap);
	ddc.CreateCompatibleDC(nullptr);
	CBitmap * pddcOldBmp = ddc.SelectObject(&bmp);

	// use this to get the background color, takes into account color shifting
	CDC ddc2;
	CBitmap bmp2;
	ddc2.CreateCompatibleDC(nullptr);
	bmp2.CreateCompatibleBitmap(&ddc,BitMap.bmWidth,BitMap.bmHeight);
	col=RGB(255,0,255); // Original was RGB(192,192,192)
	CBitmap * pddcOldBmp2 = ddc2.SelectObject(&bmp2);
	CRect rect(0,0,BitMap.bmWidth,BitMap.bmHeight);
	CBrush cbTemp = col;
	ddc2.FillRect(rect, &cbTemp);
	ddc2.SelectObject(pddcOldBmp2);
	newcol=GetSysColor(COLOR_3DFACE);

	pBGR pdstBGR = MyGetDibBits(ddc2.m_hDC,(HBITMAP)bmp.m_hObject,BitMap.bmWidth,BitMap.bmHeight);
	sBGR bgcolBGR = *pdstBGR;
	sBGR newcolBGR = {GetBValue(newcol),GetGValue(newcol), GetRValue(newcol),0};
	pBGR pcurBGR = pdstBGR;

	for(int i=0;i<BitMap.bmWidth;++i){
		for(int j=0;j<BitMap.bmHeight;++j){
			if(*(DWORD *)pcurBGR == *(DWORD *)&bgcolBGR)
				*pcurBGR = newcolBGR;
			pcurBGR++;
		}
	}

	MySetDibBits(ddc2.m_hDC, (HBITMAP)bmp.m_hObject,pdstBGR,BitMap.bmWidth,BitMap.bmHeight);
	free(pdstBGR);

	ddc.SelectObject(pddcOldBmp);
}

void BCMenu::GetDisabledBitmap(CBitmap &bmp,COLORREF background)
{
	CDC ddc;
	COLORREF discol;
	BITMAP BitMap;

	bmp.GetBitmap(&BitMap);
	ddc.CreateCompatibleDC(nullptr);
	CBitmap * pddcOldBmp = ddc.SelectObject(&bmp);

	// use this to get the background color, takes into account color shifting
	CDC ddc2;
	CBitmap bmp2;
	ddc2.CreateCompatibleDC(nullptr);
	bmp2.CreateCompatibleBitmap(&ddc,BitMap.bmWidth,BitMap.bmHeight);
	CBitmap * pddcOldBmp2 = ddc2.SelectObject(&bmp2);
	CRect rect(0,0,BitMap.bmWidth,BitMap.bmHeight);
	CBrush cbTemp = GetSysColor(COLOR_3DFACE);
	ddc2.FillRect(rect, &cbTemp);
	ddc2.SelectObject(pddcOldBmp2);
	discol=GetSysColor(COLOR_BTNSHADOW);

	pBGR pdstBGR = MyGetDibBits(ddc2.m_hDC,(HBITMAP)bmp.m_hObject,BitMap.bmWidth,BitMap.bmHeight);
	sBGR bgcolBGR = *pdstBGR;
	sBGR backgroundBGR = {GetBValue(background),GetGValue(background),GetRValue(background),0};
	pBGR pcurBGR = pdstBGR;

	for(int i=0;i<BitMap.bmWidth;++i){
		for(int j=0;j<BitMap.bmHeight;++j){
			if(*(DWORD *)pcurBGR != *(DWORD *)&bgcolBGR){
				int avgcol = ((DWORD)pcurBGR->r+(DWORD)pcurBGR->g+(DWORD)pcurBGR->b)/3;
				double factor = avgcol/255.0;
				COLORREF newcol = LightenColor(discol,factor);
				sBGR newcolBGR = {GetBValue(newcol),GetGValue(newcol),GetRValue(newcol),0};
				*pcurBGR = newcolBGR;
			}
			else{
				if(background)
					*pcurBGR = backgroundBGR;
			}
			pcurBGR++;
		}
	}

	MySetDibBits(ddc2.m_hDC,(HBITMAP)bmp.m_hObject,pdstBGR,BitMap.bmWidth,BitMap.bmHeight);
	free(pdstBGR);

	ddc.SelectObject(pddcOldBmp);
}

void BCMenu::GetDisabledBitmap(CImage &bmp)
{
	COLORREF discol=GetSysColor(COLOR_BTNSHADOW);
	pBGR pcurBGR = static_cast<pBGR>(bmp.GetBits());

	for(int i=0;i<bmp.GetWidth();++i){
		for(int j=0;j<bmp.GetHeight();++j){
			int avgcol = ((DWORD)pcurBGR->r+(DWORD)pcurBGR->g+(DWORD)pcurBGR->b)/3;
			double factor = avgcol/255.0;
			COLORREF newcol = LightenColor(discol,factor);
			sBGR newcolBGR = {GetBValue(newcol),GetGValue(newcol),GetRValue(newcol),pcurBGR->pad};
			*pcurBGR = newcolBGR;
			pcurBGR++;
		}
	}
}

bool BCMenu::AddBitmapToImageList(CImageList *bmplist,UINT nResourceID)
{
	bool bReturn=false;

	HBITMAP hbmp=LoadSysColorBitmap(nResourceID);
	if(hbmp!=nullptr){
		CBitmap bmp;
		bmp.Attach(hbmp);
		if(bmplist->Add(&bmp,GetBitmapBackground())>=0)bReturn=true;
	}
	else{ // a hicolor bitmap
		CBitmap mybmp;
		VERIFY(mybmp.LoadBitmap(nResourceID));
		if (!mybmp.m_hObject)
			mybmp.CreateBitmap(16, 15, 1, 32, nullptr);
		hicolor_bitmaps=true;
		GetTransparentBitmap(mybmp);
		if(bmplist->Add(&mybmp,GetBitmapBackground())>=0)bReturn=true;
	}
	return bReturn;
}

bool BCMenu::ReplaceBitmapInImageList(CImageList* bmplist, int xoffset, UINT nResourceID)
{
	bool result = AddBitmapToImageList(bmplist, nResourceID);
	const int cnt = bmplist->GetImageCount();
	if (xoffset < cnt - 1)
	{
		bmplist->Copy(xoffset, cnt - 1);
		bmplist->Remove(cnt - 1);
	}
	return result;
}

bool BCMenu::Draw3DCheckmark(CDC *dc, const CRect& rc,
                             bool bSelected, HBITMAP hbmCheck)
{
	CRect rcDest = rc;
	COLORREF col=GetSysColor(COLOR_MENU);
	if(!bSelected)col = LightenColor(col,0.6);
	CBrush cbTemp = col;
	dc->FillRect(rcDest, &cbTemp);
	dc->DrawEdge(&rcDest, BDR_SUNKENOUTER, BF_RECT);
	if (hbmCheck == nullptr)
		DrawCheckMark(dc,rc.left+4,rc.top+4,GetSysColor(COLOR_MENUTEXT));
	else 
		DrawRadioDot(dc,rc.left+5,rc.top+4,GetSysColor(COLOR_MENUTEXT));
	return true;
}

void BCMenu::DitherBlt2(CDC *drawdc, int nXDest, int nYDest, int nWidth, 
                        int nHeight, CBitmap &bmp, int nXSrc, int nYSrc,
						COLORREF bgcolor)
{
	// create a monochrome memory DC
	CDC ddc;
	ddc.CreateCompatibleDC(nullptr);
	CBitmap bwbmp;
	bwbmp.CreateCompatibleBitmap(&ddc, nWidth, nHeight);
	CBitmap * pddcOldBmp = ddc.SelectObject(&bwbmp);
	
	CDC dc;
	dc.CreateCompatibleDC(nullptr);
	CBitmap * pdcOldBmp = dc.SelectObject(&bmp);
	
	// build a mask
	ddc.PatBlt(0, 0, nWidth, nHeight, WHITENESS);
	dc.SetBkColor(GetSysColor(COLOR_BTNFACE));
	ddc.BitBlt(0, 0, nWidth, nHeight, &dc, nXSrc,nYSrc, SRCCOPY);
	dc.SetBkColor(GetSysColor(COLOR_BTNHILIGHT));
	ddc.BitBlt(0, 0, nWidth, nHeight, &dc, nXSrc,nYSrc, SRCPAINT);
	
	// Copy the image from the toolbar into the memory DC
	// and draw it (grayed) back into the toolbar.
	dc.FillSolidRect(0,0, nWidth, nHeight, bgcolor);
	//SK: Looks better on the old shell
	dc.SetBkColor(RGB(0, 0, 0));
	dc.SetTextColor(RGB(255, 255, 255));
	CBrush brHilight(GetSysColor(COLOR_BTNHILIGHT));
	CBrush brShadow(GetSysColor(COLOR_BTNSHADOW));
	CBrush * pOldBrush = dc.SelectObject(&brHilight);
	dc.BitBlt(0,0, nWidth, nHeight, &ddc, 0, 0, 0x00E20746L);
	drawdc->BitBlt(nXDest+1,nYDest+1,nWidth, nHeight, &dc,0,0,SRCCOPY);
	dc.BitBlt(1,1, nWidth, nHeight, &ddc, 0, 0, 0x00E20746L);
	dc.SelectObject(&brShadow);
	dc.BitBlt(0,0, nWidth, nHeight, &ddc, 0, 0, 0x00E20746L);
	drawdc->BitBlt(nXDest,nYDest,nWidth, nHeight, &dc,0,0,SRCCOPY);
	// reset DCs
	ddc.SelectObject(pddcOldBmp);
	dc.SelectObject(pOldBrush);
	dc.SelectObject(pdcOldBmp);
}

void BCMenu::DitherBlt3(CDC *drawdc, int nXDest, int nYDest, int nWidth, 
                        int nHeight, CBitmap &bmp,COLORREF bgcolor)
{
	GetDisabledBitmap(bmp,bgcolor);
	CDC dc;
	dc.CreateCompatibleDC(nullptr);
	CBitmap * pdcOldBmp = dc.SelectObject(&bmp);
	drawdc->BitBlt(nXDest,nYDest,nWidth, nHeight, &dc,0,0,SRCCOPY);
	// reset DCs
	dc.SelectObject(pdcOldBmp);
}

WORD BCMenu::NumBitmapColors(LPBITMAPINFOHEADER lpBitmap)
{
	WORD returnval = 0;

	if ( lpBitmap->biClrUsed != 0){
		returnval=(WORD)lpBitmap->biClrUsed;
	}
	else{
		switch (lpBitmap->biBitCount){
			case 1:
				returnval=2;
				break;
			case 4:
				returnval=16;
				break;
			case 8:
				returnval=256;
				break;
			default:
				returnval=0;
				break;
		}
	}
	return returnval;
}

HBITMAP BCMenu::LoadSysColorBitmap(int nResourceId)
{
	HINSTANCE hInst = 
		AfxFindResourceHandle(MAKEINTRESOURCE(nResourceId),RT_BITMAP);
	HRSRC hRsrc = 
		::FindResource(hInst,MAKEINTRESOURCE(nResourceId),RT_BITMAP);
	if (hRsrc == nullptr){
		hInst = nullptr;
		hRsrc = ::FindResource(hInst,MAKEINTRESOURCE(nResourceId),RT_BITMAP);
	}
	if (hRsrc == nullptr)
		return nullptr;

	// determine how many colors in the bitmap
	HGLOBAL hglb;
	if ((hglb = LoadResource(hInst, hRsrc)) == nullptr)
		return nullptr;
	LPBITMAPINFOHEADER lpBitmap = (LPBITMAPINFOHEADER)LockResource(hglb);
	if (lpBitmap == nullptr)
		return nullptr;
	WORD numcol = NumBitmapColors(lpBitmap);
	::FreeResource(hglb);

	if(numcol!=16)
		return nullptr;

	return ::AfxLoadSysColorBitmap(hInst, hRsrc, FALSE);
}

bool BCMenu::RemoveMenu(UINT uiId,UINT nFlags)
{
	if(MF_BYPOSITION&nFlags){
		UINT uint = GetMenuState(uiId,MF_BYPOSITION);
		if((uint&MF_SEPARATOR)!=0 && (uint&MF_POPUP)==0){
			delete m_MenuList.GetAt(uiId);
			m_MenuList.RemoveAt(uiId);
		}
		else{
			BCMenu* pSubMenu = static_cast<BCMenu*>(GetSubMenu(uiId));
			if(pSubMenu == nullptr){
				UINT uiCommandId = GetMenuItemID(uiId);
				for(int i=0;i<m_MenuList.GetSize(); i++){
					if(m_MenuList[i]->nID==uiCommandId){
						delete m_MenuList.GetAt(i);
						m_MenuList.RemoveAt(i);
						break;
					}
				}
			}
			else{
				INT_PTR numSubMenus = m_SubMenus.GetUpperBound();
				for(INT_PTR m = numSubMenus; m >= 0; m--){
					if(m_SubMenus[m]==pSubMenu->m_hMenu){
						INT_PTR numAllSubMenus = m_AllSubMenus.GetUpperBound();
						for(INT_PTR n = numAllSubMenus; n>= 0; n--){
							if(m_AllSubMenus[n]==m_SubMenus[m])m_AllSubMenus.RemoveAt(n);
						}
						m_SubMenus.RemoveAt(m);
					}
				}
				int num = pSubMenu->GetMenuItemCount();
				int i=0;
				for(i=num-1;i>=0;--i)pSubMenu->RemoveMenu(i,MF_BYPOSITION);
				for(i=(int)m_MenuList.GetUpperBound();i>=0;i--){
					if(m_MenuList[i]->nID==(UINT_PTR)pSubMenu->m_hMenu){
						delete m_MenuList.GetAt(i);
						m_MenuList.RemoveAt(i);
						break;
					}
				}
				delete pSubMenu; 
			}
		}
	}
	else{
		UINT iPosition =0;
		BCMenu* pMenu = FindMenuOption(uiId,iPosition);
		// bug fix RIA 14th September 2000 
		// failed to return correct value on call to remove menu as the item was 
		// removed twice. The second time its not found 
		// so a value of 0 was being returned 
		if(pMenu != nullptr) 
			return pMenu->RemoveMenu(iPosition,MF_BYPOSITION); // added return 
	}
	return !!CMenu::RemoveMenu(uiId,nFlags);
}

bool BCMenu::DeleteMenu(UINT uiId,UINT nFlags)
{
	if((MF_BYPOSITION&nFlags)!=0){
		UINT uint = GetMenuState(uiId,MF_BYPOSITION);
		if((uint&MF_SEPARATOR)!=0 && (uint&MF_POPUP)==0){
			// make sure it's a separator
			INT_PTR menulistsize=m_MenuList.GetSize();	
			if(uiId<(UINT)menulistsize){
				CString str=m_MenuList[uiId]->GetString();
				if(str.IsEmpty()){
					delete m_MenuList.GetAt(uiId);
					m_MenuList.RemoveAt(uiId);
				}
			}
		}
		else{
			BCMenu* pSubMenu = static_cast<BCMenu*>(GetSubMenu(uiId));
			if(pSubMenu == nullptr){
				UINT uiCommandId = GetMenuItemID(uiId);
				for(int i=0;i<m_MenuList.GetSize(); i++){
					if(m_MenuList[i]->nID==uiCommandId){
						delete m_MenuList.GetAt(i);
						m_MenuList.RemoveAt(i);
						break;
					}
				}
			}
			else{
				INT_PTR numSubMenus = m_SubMenus.GetUpperBound();
				for(INT_PTR m = numSubMenus; m >= 0; m--){
					if(m_SubMenus[m]==pSubMenu->m_hMenu){
						INT_PTR numAllSubMenus = m_AllSubMenus.GetUpperBound();
						for(INT_PTR n = numAllSubMenus; n>= 0; n--){
							if(m_AllSubMenus[n]==m_SubMenus[m])m_AllSubMenus.RemoveAt(n);
						}
						m_SubMenus.RemoveAt(m);
					}
				}
				int num = pSubMenu->GetMenuItemCount();
				for(int i=num-1;i>=0;--i)pSubMenu->DeleteMenu(i,MF_BYPOSITION);
				for(INT_PTR i=m_MenuList.GetUpperBound();i>=0;i--){
					if(m_MenuList[i]->nID==(UINT_PTR)pSubMenu->m_hMenu){
						delete m_MenuList.GetAt(i);
						m_MenuList.RemoveAt(i);
						break;
					}
				}
				delete pSubMenu;
			}
		}
	}
	else{
		UINT iPosition =0;
		BCMenu* pMenu = FindMenuOption(uiId,iPosition);
		if(pMenu != nullptr)
			return pMenu->DeleteMenu(iPosition,MF_BYPOSITION);
	}

	return !!CMenu::DeleteMenu(uiId,nFlags);
}

// Larry Antram
bool BCMenu::SetMenuText(UINT id, CString string, UINT nFlags/*= MF_BYPOSITION*/ )
{
	bool returnflag=false;
	
	if((MF_BYPOSITION&nFlags) != 0)
	{
		INT_PTR numMenuItems = m_MenuList.GetUpperBound();
		if(static_cast<INT_PTR>(id)<=numMenuItems){
			m_MenuList[id]->SetWideString((LPCTSTR)string);
			returnflag=true;
		}
	}
	else{
		UINT uiLoc;
		BCMenu* pMenu = FindMenuOption(id,uiLoc);
		if(pMenu != nullptr) 
			returnflag = pMenu->SetMenuText(uiLoc,string);
	}
	return returnflag;
}

int BCMenu::GlobalImageListOffset(int nID)
{
	INT_PTR numcurrent=m_AllImagesID.size();
	int existsloc = -1;
	for(INT_PTR i=0;i<numcurrent;++i){
		if(m_AllImagesID[i].id==nID){
			existsloc=static_cast<int>(i);
			break;
		}
	}
	return existsloc;
}

CBitmap* BCMenu::CreateRadioDotBitmap()
{
	COLORREF textColor = m_menuTextColor;
	COLORREF bkColor = m_menuBgColor;
	if (DarkMode::isEnabled())
	{
		HTHEME hTheme = OpenThemeData(nullptr, _T("DarkMode_ImmersiveStart::Menu"));
		if (hTheme)
		{
			GetThemeColor(hTheme, MENU_POPUPITEM, MPI_NORMAL, TMT_TEXTCOLOR, &textColor);
			GetThemeColor(hTheme, MENU_POPUPBACKGROUND, 0, TMT_FILLCOLOR, &bkColor);
			CloseThemeData(hTheme);
		}
	}
	const BYTE textR = GetRValue(textColor);
	const BYTE textG = GetGValue(textColor);
	const BYTE textB = GetBValue(textColor);
	const BYTE bkR = GetRValue(bkColor);
	const BYTE bkG = GetGValue(bkColor);
	const BYTE bkB = GetBValue(bkColor);
	const int cxSMIcon = GetSystemMetrics(SM_CXSMICON);
	const int cySMIcon = GetSystemMetrics(SM_CYSMICON);
	BYTE* pBits;
	BITMAPINFO bmi{ sizeof(BITMAPINFOHEADER), cxSMIcon, -cySMIcon, 1, 32, BI_RGB };
	CBitmap *pBitmap = new CBitmap();
	HBITMAP hBitmap = CreateDIBSection(nullptr, &bmi, DIB_RGB_COLORS, (void**)&pBits, nullptr, 0);
	pBitmap->Attach(hBitmap);
	CDC dcMem;
	dcMem.CreateCompatibleDC(nullptr);
	CBitmap* pOldBitmap = dcMem.SelectObject(pBitmap);
	CRect rcDot(cxSMIcon/2-cxSMIcon/5,cySMIcon/2-cxSMIcon/5,cxSMIcon/2+cxSMIcon/5,cySMIcon/2+cySMIcon/5);
	DWORD* p = reinterpret_cast<DWORD*>(pBits);
	const int cx = (rcDot.left + rcDot.right ) / 2;
	const int cy = (rcDot.top  + rcDot.bottom) / 2;
	const double r = std::sqrt((cxSMIcon / 5) * (cxSMIcon / 5));
	for (int y = rcDot.top; y < rcDot.bottom; ++y)
	{
		for (int x = rcDot.left; x < rcDot.right; ++x)
		{
			const double d = std::sqrt((x - cx) * (x - cx) + (y - cy) * (y - cy));
			if (d <= r)
			{
				const BYTE alpha =(r - d >= 1.0) ? 255 : static_cast<BYTE>(255.0 * (r - d));
				const BYTE outR = static_cast<BYTE>((textR * alpha + bkR * (255 - alpha)) / 255);
				const BYTE outG = static_cast<BYTE>((textG * alpha + bkG * (255 - alpha)) / 255);
				const BYTE outB = static_cast<BYTE>((textB * alpha + bkB * (255 - alpha)) / 255);
				p[x + y * cxSMIcon] = (0xFF << 24) | (outR << 16) | (outG << 8) | outB;
			}
			else
			{
				p[x + y * cxSMIcon] = (0xFF << 24) | (bkR << 16) | (bkG << 8) | bkB;
			}
		}
	}
	dcMem.SelectObject(pOldBitmap);
	return pBitmap;
}

void BCMenu::LoadImages()
{
	if (!m_bHasNotLoadedImages)
		return;
	HIMAGELIST hImageList = m_AllImages.m_hImageList;
	if(hImageList == nullptr)
		m_AllImages.Create(m_iconX,m_iconY,ILC_COLORDDB|ILC_MASK,1,1);
	std::map<int, std::unique_ptr<CImageList>> mapImageList;
	for (size_t i = 0; i < m_AllImagesID.size(); ++i)
	{
		const int resourceId = m_AllImagesID[i].resourceId;
		if (resourceId != -1)
		{
			if (m_AllImagesID[i].bitmapIndex >= 0)
			{
				if (mapImageList.find(resourceId) == mapImageList.end())
				{
					mapImageList.emplace(resourceId, new CImageList);
					mapImageList[resourceId]->Create(m_iconX, m_iconY, ILC_COLORDDB | ILC_MASK, 1, 1);
					AddBitmapToImageList(mapImageList[resourceId].get(), resourceId);
				}
				HICON hIcon = mapImageList[resourceId]->ExtractIcon(m_AllImagesID[i].bitmapIndex);
				if (static_cast<int>(i) < m_AllImages.GetImageCount())
					m_AllImages.Replace(static_cast<int>(i), hIcon);
				else
					m_AllImages.Add(hIcon);
				DestroyIcon(hIcon);
			}
			else
			{
				ReplaceBitmapInImageList(&m_AllImages, static_cast<int>(i), resourceId);
			}
			m_AllImagesID[i].resourceId = -1;
			m_AllImagesID[i].bitmapIndex = -1;
		}
	}
	m_bHasNotLoadedImages = false;
}

INT_PTR BCMenu::AddToGlobalImageList(int nIconNormal,int nID)
{
	INT_PTR loc = -1;
	INT_PTR numcurrent=m_AllImagesID.size();
	int existsloc = GlobalImageListOffset(nID);
	if(existsloc>=0){
		m_AllImagesID[existsloc].resourceId = (nIconNormal & 0x40000000) ? (nIconNormal & 0xffff) : nIconNormal;
		m_AllImagesID[existsloc].bitmapIndex = (nIconNormal & 0x40000000) ? ((nIconNormal & 0x3fff0000) >> 16) : -1;
		m_AllImagesID[existsloc].pBitmap.reset();
		m_AllImagesID[existsloc].state = 0;
		loc = existsloc;
	}
	else{
		m_AllImagesID.push_back({ nID, 
			(nIconNormal & 0x40000000) ? (nIconNormal & 0xffff) : nIconNormal, 
			(nIconNormal & 0x40000000) ? ((nIconNormal & 0x3fff0000) >> 16) : -1 });
		loc=numcurrent;
	}
	m_bHasNotLoadedImages = true;
	return loc;
}
</file>

<file path="Winmerge-Src/Src/Common/BCMenu.h">
//*************************************************************************
// BCMenu.h : header file
// Version : 3.036
// Date : June 2005
// Author : Brent Corkum
// Email :  corkum@rocscience.com
// Latest Version : http://www.rocscience.com/~corkum/BCMenu.html
// 
// Bug Fixes and portions of code supplied by:
//
// Ben Ashley,Girish Bharadwaj,Jean-Edouard Lachand-Robert,
// Robert Edward Caldecott,Kenny Goers,Leonardo Zide,
// Stefan Kuhr,Reiner Jung,Martin Vladic,Kim Yoo Chul,
// Oz Solomonovich,Tongzhe Cui,Stephane Clog,Warren Stevens,
// Damir Valiulin,David Kinder,Marc Loiry
//
// You are free to use/modify this code but leave this header intact.
// This class is public domain so you are free to use it any of
// your applications (Freeware,Shareware,Commercial). All I ask is
// that you let me know so that if you have a real winner I can
// brag to my buddies that some of my code is in your app. I also
// wouldn't mind if you sent me a copy of your application since I
// like to play with new stuff.
//*************************************************************************

#pragma once

#include <afxtempl.h>

// BCMenuData class. Fill this class structure to define a single menu item:
class BCMenuData
{
	wchar_t *m_szMenuText;
public:
	BCMenuData () {pContext=nullptr;
	nFlags=0;nID=0;syncflag=0;m_szMenuText=nullptr;global_offset=-1;};
	void SetWideString(const wchar_t *szWideString);
	const wchar_t *GetWideString(void) const {return m_szMenuText;};
	~BCMenuData ();
	CString GetString(void);//returns the menu text
	INT_PTR global_offset;
	UINT nFlags,syncflag;
	UINT_PTR nID;
	void *pContext; // used to attach user data
};

struct CMenuItemInfo : public MENUITEMINFO 
{
	CMenuItemInfo() : MENUITEMINFO{ sizeof(MENUITEMINFO) }
	{
	}
};

class BCMenu : public CMenu
{
	DECLARE_DYNAMIC( BCMenu )
public:
	BCMenu(); 
	virtual ~BCMenu();

	static void DisableOwnerDraw();
	static void RecreateRadioDotBitmap();

	// Functions for loading and applying bitmaps to menus (see example application)
	virtual BOOL LoadMenu(LPCTSTR lpszResourceName);
	virtual BOOL LoadMenu(int nResource)
	{
		return BCMenu::LoadMenu(MAKEINTRESOURCE(nResource));
	}

	bool LoadToolbar(UINT nToolBar, CToolBar* pBar = nullptr);
	bool AddBitmapToImageList(CImageList *list,UINT nResourceID);
	bool ReplaceBitmapInImageList(CImageList *list,int xoffset,UINT nResourceID);
	static HBITMAP LoadSysColorBitmap(int nResourceId);
	
	bool AppendMenu(UINT nFlags, UINT_PTR nIDNewItem = 0, const wchar_t* lpszNewItem = nullptr, int nIconNormal = -1)
	{
		return AppendODMenu(lpszNewItem, nFlags, nIDNewItem, nIconNormal);
	}
	bool AppendODMenu(const wchar_t *lpstrText,UINT nFlags = MF_OWNERDRAW,UINT_PTR nID = 0,int nIconNormal = -1);  
	
	// functions for inserting a menu option, use the InsertMenu call (see above define)
	bool InsertMenu(UINT nPosition, UINT nFlags, UINT_PTR nIDNewItem = 0, wchar_t* lpszNewItem = nullptr, int nIconNormal= -1)
	{
		return InsertODMenu(nPosition, lpszNewItem, nFlags, nIDNewItem, nIconNormal);
	}
	bool InsertODMenu(UINT nPosition,wchar_t *lpstrText,UINT nFlags = MF_OWNERDRAW,UINT_PTR nID = 0,int nIconNormal = -1);  

	// functions for modifying a menu option, use the ModifyODMenu call (see above define)
	bool ModifyODMenu(const wchar_t *lpstrText,UINT_PTR nID=0,int nIconNormal=-1);

	// for deleting and removing menu options
	bool	RemoveMenu(UINT uiId,UINT nFlags);
	bool	DeleteMenu(UINT uiId,UINT nFlags);
	
	// Destoying
	virtual BOOL DestroyMenu();

	// function for retrieving and setting a menu options text (use this function
	// because it is ownerdrawn)
	bool GetMenuText(UINT id,CString &string,UINT nFlags = MF_BYPOSITION);
	bool SetMenuText(UINT id,CString string, UINT nFlags = MF_BYPOSITION);

	// Drawing: 
	virtual void DrawItem( LPDRAWITEMSTRUCT);  // Draw an item
	virtual void MeasureItem( LPMEASUREITEMSTRUCT );  // Measure an item

	// Static functions used for handling menu's in the mainframe
	static void UpdateMenu(CMenu *pmenu);
	static bool IsMenu(CMenu *submenu)
	{
		return IsMenu(submenu->m_hMenu);
	}
	static bool IsMenu(HMENU submenu);
	static LRESULT FindKeyboardShortcut(UINT nChar,UINT nFlags,CMenu *pMenu);

	// Customizing:
	// Set icon size
	static void SetIconSize (int width, int height)
	{
		m_iconX = width;
		m_iconY = height;
	}

	// set the color in the bitmaps that is the background transparent color
	void SetBitmapBackground(COLORREF color)
	{
		m_bitmapBackground=color;
		m_bitmapBackgroundFlag=true;
	}
	void UnSetBitmapBackground(void)
	{
		m_bitmapBackgroundFlag=false;
	}

	COLORREF GetBitmapBackground() const { return m_bitmapBackgroundFlag ? m_bitmapBackground : GetSysColor(COLOR_3DFACE); }
	// obsolete functions for setting how menu images are dithered for disabled menu options
	static inline COLORREF LightenColor(COLORREF col,double factor);

public:
	// Miscellaneous Protected Member functions
protected:
	BCMenuData *FindMenuItem(UINT_PTR nID);
	BCMenu *FindMenuOption(int nId,UINT& nLoc);
	BCMenu *FindAnotherMenuOption(int nId,UINT& nLoc,CArray<BCMenu*,BCMenu*>&bcsubs,
								  CArray<UINT,UINT&>&bclocs);
	BCMenuData *FindMenuOption(wchar_t *lpstrText);
	void DrawCheckMark(CDC* pDC,int x,int y,COLORREF color,bool narrowflag=false);
	void DrawRadioDot(CDC *pDC,int x,int y,COLORREF color);
	BCMenuData *NewODMenu(UINT pos,UINT nFlags,UINT_PTR nID,CString string);
	void SetMenuItemBitmap(intptr_t xoffset, int pos, unsigned state);
	void SynchronizeMenu(void);
	void InitializeMenuList(int value);
	void DeleteMenuList(void);
	BCMenuData *FindMenuList(UINT_PTR nID);
	void DrawItem_Win9xNT2000 (LPDRAWITEMSTRUCT lpDIS);
	bool Draw3DCheckmark(CDC *dc, const CRect& rc,bool bSelected,HBITMAP hbmCheck);
	void DrawItem_Theme (LPDRAWITEMSTRUCT lpDIS);
	void DitherBlt2(CDC *drawdc, int nXDest, int nYDest, int nWidth, 
		int nHeight, CBitmap &bmp, int nXSrc, int nYSrc,COLORREF bgcolor);
	void DitherBlt3(CDC *drawdc, int nXDest, int nYDest, int nWidth, 
		int nHeight, CBitmap &bmp,COLORREF bgcolor);
	bool GetBitmapFromImageList(CDC* pDC,int nIndex,CBitmap &bmp);
	bool GetBitmapFromImageList(CDC* pDC,int nIndex,CImage &bmp);
	static WORD NumBitmapColors(LPBITMAPINFOHEADER lpBitmap);
	void RemoveTopLevelOwnerDraw(void);
	int GetMenuStart(void);
	void GetTransparentBitmap(CBitmap &bmp);
	void GetDisabledBitmap(CBitmap &bmp,COLORREF background=0);
	void GetDisabledBitmap(CImage &bmp);
	INT_PTR AddToGlobalImageList(int nIconNormal,int nID);
	int GlobalImageListOffset(int nID);
	void LoadImages();
	inline unsigned MakeOwnerDrawFlag() const { return BCMenu::m_bEnableOwnerDraw ? MF_OWNERDRAW : MF_STRING; }
	inline const tchar_t *MakeItemData(const BCMenuData* mdata) const { return m_bEnableOwnerDraw ? reinterpret_cast<const tchar_t *>(mdata) : mdata->GetWideString(); }
	static CBitmap* CreateRadioDotBitmap();
	
// Member Variables
protected:
	CTypedPtrArray<CPtrArray, BCMenuData*> m_MenuList;  // Stores list of menu items 
	// When loading an owner-drawn menu using a Resource, BCMenu must keep track of
	// the popup menu's that it creates. Warning, this list *MUST* be destroyed
	// last item first :)
	CTypedPtrArray<CPtrArray, HMENU>  m_SubMenus;  // Stores list of sub-menus 
	// Stores a list of all BCMenu's ever created 
	static CTypedPtrArray<CPtrArray, HMENU>  m_AllSubMenus;
	// Global ImageList
	static CImageList m_AllImages;
	struct ImageData { int id; int resourceId; int bitmapIndex; std::unique_ptr<CBitmap> pBitmap; unsigned state; };
	static std::vector<ImageData> m_AllImagesID;
	static bool m_bHasNotLoadedImages;
	// icon size
	static int m_iconX;
	static int m_iconY;
	COLORREF m_bitmapBackground;
	bool m_bitmapBackgroundFlag;
	static bool hicolor_bitmaps;
	bool m_loadmenu;
	static MARGINS m_marginCheck;
	static MARGINS m_marginSeparator;
	static SIZE m_sizeCheck;
	static SIZE m_sizeSeparator;
	static int m_textBorder;
	static int m_checkBgWidth;
	static int m_gutterWidth;
	static int m_arrowWidth;
	static COLORREF m_menuTextColor;
	static COLORREF m_menuBgColor;
	static HTHEME m_hTheme;
	static bool m_bEnableOwnerDraw;
}; 

</file>

<file path="Winmerge-Src/Src/Common/Bitmap.cpp">
/** 
 * @file  Bitmap.cpp
 *
 * @brief Implementation file for Bitmap helper functions.
 *
 */

#include "StdAfx.h"
#include "Bitmap.h"
#include <cmath>
#include <memory>

#ifdef _DEBUG
#define new DEBUG_NEW
#endif


/**
 * @brief Save an area as a bitmap
 * @param pDC [in] The source device context
 * @param rect [in] The rect to be copied
 * @return The bitmap object
 */
CBitmap *CopyRectToBitmap(CDC *pDC, const CRect & rect)
{
	CRect rc = rect;
	CDC dcMem;
	dcMem.CreateCompatibleDC(pDC);
	CBitmap *pBitmap = new CBitmap;
	pBitmap->CreateCompatibleBitmap(pDC, rc.Width(), rc.Height());
	CBitmap *pOldBitmap = dcMem.SelectObject(pBitmap);
	dcMem.BitBlt(0, 0, rc.Width(), rc.Height(), pDC, rc.left, rc.top, SRCCOPY);
	dcMem.SelectObject(pOldBitmap);
	return pBitmap;
}

/**
 * @brief Draw a bitmap image
 * @param pDC [in] The destination device context to draw to
 * @param x [in] The x-coordinate of the upper-left corner of the bitmap
 * @param y [in] The y-coordinate of the upper-left corner of the bitmap
 * @param pBitmap [in] the bitmap to draw
 */
void DrawBitmap(CDC *pDC, int x, int y, CBitmap *pBitmap)
{
	CDC dcMem;
	dcMem.CreateCompatibleDC(pDC);
	BITMAP bm;
	pBitmap->GetBitmap(&bm);
	CBitmap *pOldBitmap = dcMem.SelectObject(pBitmap);
	pDC->BitBlt(x, y, bm.bmWidth, bm.bmHeight, &dcMem, 0, 0, SRCCOPY);
	dcMem.SelectObject(pOldBitmap);
}

/**
 * @brief Duplicate a bitmap and make it dark
 * @param pDC [in] Device context
 * @param pBitmap [in] the bitmap to darken
 * @param radius [in] 
 * @param lighten [in] make bitmap lighten if ligthen is true
 * @return The bitmap object
 */
CBitmap *GetDarkenedBitmap(CDC *pDC, CBitmap *pBitmap, int radius, bool lighten)
{
	CDC dcMem;
	dcMem.CreateCompatibleDC(pDC);
	BITMAP bm;
	pBitmap->GetObject(sizeof(bm), &bm);
	CBitmap *pBitmapDarkened = new CBitmap();
	pBitmapDarkened->CreateCompatibleBitmap(pDC, bm.bmWidth, bm.bmHeight);
	CBitmap *pOldBitmap = dcMem.SelectObject(pBitmapDarkened);
	DrawBitmap(&dcMem, 0, 0, pBitmap);

	BITMAPINFO bi;
	bi.bmiHeader.biSize = sizeof(bi.bmiHeader);
	bi.bmiHeader.biWidth = bm.bmWidth;
	bi.bmiHeader.biHeight = -bm.bmHeight;
	bi.bmiHeader.biPlanes = 1;
	bi.bmiHeader.biBitCount = 32;
	bi.bmiHeader.biCompression = 0;
	bi.bmiHeader.biSizeImage = bm.bmWidth * 4 * bm.bmHeight;
	bi.bmiHeader.biXPelsPerMeter = 0;
	bi.bmiHeader.biYPelsPerMeter = 0;
	bi.bmiHeader.biClrUsed = 0;
	bi.bmiHeader.biClrImportant = 0;

	auto pbuf = std::make_unique<BYTE[]>(bi.bmiHeader.biSizeImage);
	GetDIBits(dcMem.m_hDC, (HBITMAP)*pBitmapDarkened, 0, bm.bmHeight, pbuf.get(), &bi, DIB_RGB_COLORS);

	radius = std::clamp(radius, 0, static_cast<int>((std::min)(bm.bmWidth / 3, bm.bmHeight / 3)));

	if (!lighten)
	{
		auto darkenInner = [&pbuf, &bm](int left, int top, int right, int bottom)
			{
				for (int x = left; x < right; x++)
				{
					double b = 0.85 + (0.10 * sin(acos((double)x / bm.bmWidth*2.0 - 1.0)));
					for (int y = top; y < bottom; y++)
					{
						{
							int i = x * 4 + y * bm.bmWidth * 4;
							pbuf[i] = (BYTE)(pbuf[i] * 0.95);
							pbuf[i + 1] = (BYTE)(pbuf[i + 1] * b);
							pbuf[i + 2] = (BYTE)(pbuf[i + 2] * b);
						}
					}
				}

			};
		auto darkenCorner = [&pbuf, &bm](int left, int top, int right, int bottom, int cx, int cy, int radius)
			{
				auto sqr = [](double x) { return x * x; };
				for (int x = left; x < right; x++)
				{
					const double b = 0.85 + (0.10 * sin(acos((double)x / bm.bmWidth*2.0 - 1.0)));
					for (int y = top; y < bottom; y++)
					{
						int i = x * 4 + y * bm.bmWidth * 4;
						const double dist = std::sqrt(sqr(x - cx) + sqr(y - cy)) - static_cast<double>(radius);
						if (dist < 0)
						{
							pbuf[i] = (BYTE)(pbuf[i] * 0.95);
							pbuf[i + 1] = (BYTE)(pbuf[i + 1] * b);
							pbuf[i + 2] = (BYTE)(pbuf[i + 2] * b);
						}
						else if (dist <= 1.0)
						{
							pbuf[i] = (BYTE)(pbuf[i] * (0.95 + 0.05 * dist));
							pbuf[i + 1] = (BYTE)(pbuf[i + 1] * (0.9 + 0.1 * dist));
							pbuf[i + 2] = (BYTE)(pbuf[i + 2] * (0.9 + 0.1 * dist));
						}
					}
				}
			};
		auto darkenTopBottomEdge = [&pbuf, &bm](int y, int left, int right)
			{
				for (int x = left; x < right; x++)
				{
					int i = x * 4 + y * bm.bmWidth * 4;
					pbuf[i] = (BYTE)(pbuf[i] * 0.95);
					pbuf[i + 1] = (BYTE)(pbuf[i + 1] * 0.9);
					pbuf[i + 2] = (BYTE)(pbuf[i + 2] * 0.9);
				}
			};
		auto darkenLeftRightEdge = [&pbuf, &bm](int x, int top, int bottom)
			{
				for (int y = top; y < bottom; y++)
				{
					int i = x * 4 + y * bm.bmWidth * 4;
					pbuf[i] = (BYTE)(pbuf[i] * 0.95);
					pbuf[i + 1] = (BYTE)(pbuf[i + 1] * 0.85);
					pbuf[i + 2] = (BYTE)(pbuf[i + 2] * 0.85);
				}
			};
		darkenInner(radius, 1, bm.bmWidth - radius, radius);
		darkenInner(radius, bm.bmHeight - radius, bm.bmWidth - radius, bm.bmHeight - 1);
		darkenInner(1, radius, bm.bmWidth - 1, bm.bmHeight - radius);
		darkenCorner(0, 0, radius, radius, radius, radius, radius);
		darkenCorner(bm.bmWidth - radius, 0, bm.bmWidth, radius, bm.bmWidth - radius - 1, radius, radius);
		darkenCorner(0, bm.bmHeight - radius, radius, bm.bmHeight, radius, bm.bmHeight - radius - 1, radius);
		darkenCorner(bm.bmWidth - radius, bm.bmHeight - radius, bm.bmWidth, bm.bmHeight, bm.bmWidth - radius - 1, bm.bmHeight - radius - 1, radius);
		darkenTopBottomEdge(0, radius, bm.bmWidth - radius);
		darkenTopBottomEdge(bm.bmHeight - 1, radius, bm.bmWidth - radius);
		darkenLeftRightEdge(0, radius, bm.bmHeight - radius);
		darkenLeftRightEdge(bm.bmWidth - 1, radius, bm.bmHeight - radius);
	}
	else
	{
		auto lightenInner = [&pbuf, &bm](int left, int top, int right, int bottom)
			{
				for (int x = left; x < right; x++)
				{
					int b = static_cast<int>(12.0 + (20.0 * sin(acos((double)x / bm.bmWidth*2.0 - 1.0))));
					for (int y = top; y < bottom; y++)
					{
						int i = x * 4 + y * bm.bmWidth * 4;
						pbuf[i] = (BYTE)((std::min)(pbuf[i] + 40, 255));
						pbuf[i + 1] = (BYTE)((std::min)(pbuf[i + 1] + b, 255));
						pbuf[i + 2] = (BYTE)((std::min)(pbuf[i + 2] + b, 255));
					}
				}
			};
		auto lightenCorner = [&pbuf, &bm](int left, int top, int right, int bottom, int cx, int cy, int radius)
			{
				auto sqr = [](double x) { return x * x; };
				for (int x = left; x < right; x++)
				{
					int b = static_cast<int>(12.0 + (20.0 * sin(acos((double)x / bm.bmWidth*2.0 - 1.0))));
					for (int y = top; y < bottom; y++)
					{
						int i = x * 4 + y * bm.bmWidth * 4;
						const double dist = std::sqrt(sqr(x - cx) + sqr(y - cy)) - static_cast<double>(radius);
						if (dist < 0)
						{
							pbuf[i] = (BYTE)((std::min)(pbuf[i] + 40, 255));
							pbuf[i + 1] = (BYTE)((std::min)(pbuf[i + 1] + b, 255));
							pbuf[i + 2] = (BYTE)((std::min)(pbuf[i + 2] + b, 255));
						}
						else if (dist <= 1.0)
						{
							pbuf[i] = (BYTE)((std::min)(pbuf[i] + (BYTE)(40 * (1.0 - dist)), 255));
							pbuf[i + 1] = (BYTE)((std::min)(pbuf[i + 1] + (BYTE)(32 * (1.0 - dist)), 255));
							pbuf[i + 2] = (BYTE)((std::min)(pbuf[i + 2] + (BYTE)(32 * (1.0 - dist)), 255));
						}
					}
				}
			};
		auto lightenTopBottomEdge = [&pbuf, &bm](int y, int left, int right)
			{
				for (int x = left; x < right; x++)
				{
					int i = x * 4 + y * bm.bmWidth * 4;
					pbuf[i] = (BYTE)((std::min)(pbuf[i] + 40, 255));
					pbuf[i + 1] = (BYTE)((std::min)(pbuf[i + 1] + 32, 255));
					pbuf[i + 2] = (BYTE)((std::min)(pbuf[i + 2] + 32, 255));
				}
			};
		auto lightenLeftRightEdge = [&pbuf, &bm](int x, int top, int bottom)
			{
				for (int y = top; y < bottom; y++)
				{
					int i = x * 4 + y * bm.bmWidth * 4;
					pbuf[i] = (BYTE)((std::min)(pbuf[i] + 40, 255));
					pbuf[i + 1] = (BYTE)((std::min)(pbuf[i + 1] + 32, 255));
					pbuf[i + 2] = (BYTE)((std::min)(pbuf[i + 2] + 32, 255));
				}
			};
		lightenInner(radius, 1, bm.bmWidth - radius, radius);
		lightenInner(radius, bm.bmHeight - radius, bm.bmWidth - radius, bm.bmHeight - 1);
		lightenInner(1, radius, bm.bmWidth - 1, bm.bmHeight - radius);
		lightenCorner(0, 0, radius, radius, radius, radius, radius);
		lightenCorner(bm.bmWidth - radius, 0, bm.bmWidth, radius, bm.bmWidth - radius - 1, radius, radius);
		lightenCorner(0, bm.bmHeight - radius, radius, bm.bmHeight, radius, bm.bmHeight - radius - 1, radius);
		lightenCorner(bm.bmWidth - radius, bm.bmHeight - radius, bm.bmWidth, bm.bmHeight, bm.bmWidth - radius - 1, bm.bmHeight - radius - 1, radius);
		lightenTopBottomEdge(0, radius, bm.bmWidth - radius);
		lightenTopBottomEdge(bm.bmHeight - 1, radius, bm.bmWidth - radius);
		lightenLeftRightEdge(0, radius, bm.bmHeight - radius);
		lightenLeftRightEdge(bm.bmWidth - 1, radius, bm.bmHeight - radius);
	}

	SetDIBits(dcMem.m_hDC, (HBITMAP)*pBitmapDarkened, 0, bm.bmHeight, pbuf.get(), &bi, DIB_RGB_COLORS);
	dcMem.SelectObject(pOldBitmap);
	return pBitmapDarkened;
}

bool LoadImageFromResource(ATL::CImage& image, const tchar_t *pName, const tchar_t *pType)
{
	HRSRC hrsrc = FindResource(nullptr, pName, pType);
	if (hrsrc == nullptr)
		return false;
	DWORD dwResourceSize = SizeofResource(nullptr, hrsrc);
	HGLOBAL hglbImage = LoadResource(nullptr, hrsrc);
	if (hglbImage == nullptr)
		return false;
	LPVOID pvSourceResourceData = LockResource(hglbImage);
	if (pvSourceResourceData == nullptr)
		return false;
	IStream * pStream = SHCreateMemStream(reinterpret_cast<const BYTE *>(pvSourceResourceData), dwResourceSize);
	if (!pStream)
		return false;
	HRESULT hr = image.Load(pStream);
	pStream->Release();
	if (FAILED(hr))
		return false;
	return true;
}
</file>

<file path="Winmerge-Src/Src/Common/Bitmap.h">
/** 
 * @file  Bitmap.h
 *
 * @brief Declaration file for Bitmap helper functions.
 *
 */
#pragma once

#include "utils/ctchar.h"

class CBitmap;
class CDC;
class CRect;
namespace ATL { class CImage; }

CBitmap *CopyRectToBitmap(CDC *pDC, const CRect & rect);
void DrawBitmap(CDC *pDC, int x, int y, CBitmap *pBitmap);
CBitmap *GetDarkenedBitmap(CDC *pDC, CBitmap *pBitmap, int radius, bool lighten = false);
bool LoadImageFromResource(ATL::CImage& image, const tchar_t *pName, const tchar_t *pType);
</file>

<file path="Winmerge-Src/Src/Common/cio.cpp">
#include "pch.h"
#include "cio.h"
#include "TFile.h"
#include <cerrno>

namespace cio
{
#ifdef _WIN32

int tsopen_s(int* fd, const String& filepath, int oflag, int shflag, int pmode)
{
	return _wsopen_s(fd, TFile(filepath).wpath().c_str(), oflag, shflag, pmode);
}

int tfopen_s(FILE** fp, const String& filepath, const String::value_type* mode)
{
	return _wfopen_s(fp, TFile(filepath).wpath().c_str(), mode);
}

ssize_t read(int fd, void* buf, size_t size)
{
	ssize_t pos = 0;
	while (pos < size)
	{
		unsigned rsize = (size - pos < 0x40000000) ? static_cast<unsigned>(size - pos) : 0x40000000;
		int res32 = _read(fd, reinterpret_cast<char *>(buf) + pos, rsize);
		if (res32 == -1)
			return -1;
		pos += res32;
		if (res32 < rsize)
			break;
	}
	return pos;
}

ssize_t write(int fd, const void* buf, size_t size)
{
	ssize_t pos = 0;
	while (pos < size)
	{
		unsigned wsize = (size - pos < 0x40000000) ? static_cast<unsigned>(size - pos) : 0x40000000;
		int res32 = _write(fd, reinterpret_cast<const char *>(buf) + pos, wsize);
		if (res32 == -1)
			return -1;
		pos += res32;
	}
	return pos;
}

#else

int tsopen_s(int* fd, const String& filepath, int oflag, int shflag, int pmode)
{
	*fd = open(filepath.c_str(), oflag, pmode);
	return errno;
}

int fopen_s(FILE** fp, const String& filepath, const String::value_type* mode)
{
	*fp = fopen(filepath.c_str(), mode);
	return errno;
}

#endif
}
</file>

<file path="Winmerge-Src/Src/Common/cio.h">
#pragma once

#include <cstdio>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#ifdef _WIN32
#include <io.h>
extern "C" int myfstat(int fd, struct _stat64 *buf);
#else
#include <unistd.h>
#endif
#include "UnicodeString.h"

namespace cio
{
	int tsopen_s(int* fd, const String& filepath, int oflag, int shflag, int pmode);
	int tfopen_s(FILE** fp, const String& filepath, const String::value_type* mode);
#ifdef _WIN32
	typedef intptr_t ssize_t;
	typedef struct _stat64 stat;
	constexpr auto read_i = _read;
	constexpr auto write_i = _write;
	ssize_t read(int fd, void* buf, size_t size);
	ssize_t write(int fd, const void* buf, size_t size);
	constexpr auto close = ::_close;
	constexpr auto fstat = ::myfstat;
	constexpr auto pipe = ::_pipe;
#else
#define O_BINARY (0)
#define _SH_DENYNO (0)
#define _S_IREAD  (S_IRUSR | S_IRGRP | S_IROTH)
#define _S_IWRITE (S_IWUSR | S_IWGRP | S_IWOTH)
	typedef struct stat stat;
	inline int read_i(int fd, void* buf, unsigned size) { return (int)::read(fd, buf, size); }
	inline int write_i(int fd, const void* buf, unsigned size) { return (int)::write(fd, buf, size); }
	constexpr auto read = ::read;
	constexpr auto write = ::write;
	constexpr auto close = ::close;
	constexpr auto fstat = ::fstat;
	constexpr auto pipe = ::pipe;
#endif
}
</file>

<file path="Winmerge-Src/Src/Common/ClipBoard.cpp">
/**
 * @file  ClipBoard.cpp
 *
 * @brief ClipBoard helper functions implementations.
 */

#include "pch.h"
#include "ClipBoard.h"
#include <ShlObj.h>

inline CLIPFORMAT GetClipTcharTextFormat() { return (sizeof(tchar_t) == 1 ? CF_TEXT : CF_UNICODETEXT); }

/**
 * @brief Copies string to clipboard.
 * @param [in] text Text to copy to clipboard.
 * @param [in] currentWindowHandle Handle to current window.
 * @return `true` if text copying succeeds, `false` otherwise.
 */
template<>
bool PutToClipboard<HWND>(const String & text, HWND currentWindowHandle)
{
	if (text.empty())
		return false;

	bool bOK = false;
	if (OpenClipboard(currentWindowHandle))
	{
		EmptyClipboard();
		const size_t dataSiz = text.length() + 1;
		HGLOBAL hData = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, dataSiz * sizeof(tchar_t));
		if (hData != nullptr)
		{
			if (tchar_t* pszData = static_cast<tchar_t*>(::GlobalLock(hData)))
			{
				tc::tcslcpy(pszData, dataSiz, text.c_str());
				GlobalUnlock(hData);
			}
			CLIPFORMAT fmt = GetClipTcharTextFormat();
			bOK = SetClipboardData(fmt, hData) != nullptr;
		}
		CloseClipboard();
	}
	return bOK;
}

/**
 * @brief Retrieves the string from clipboard.
 * @param [out] text Text copied from clipboard.
 * @param [in] currentWindowHandle Handle to current window.
 * @return `true` if retrieving the clipboard text succeeds, `false` otherwise.
 */
bool GetFromClipboard(String & text)
{
	bool bSuccess = false;
	if (OpenClipboard(nullptr))
	{
		CLIPFORMAT fmt = GetClipTcharTextFormat();
		HGLOBAL hData = GetClipboardData(fmt);
		if (hData != nullptr)
		{
			tchar_t* pszData = (tchar_t*) GlobalLock(hData);
			if (pszData != nullptr)
			{
				text = pszData;
				GlobalUnlock(hData);
				bSuccess = true;
			}
		}
		CloseClipboard();
	}
	return bSuccess;
}

template<>
void PutFilesToClipboardInternal<HWND>(const String& strPaths, const String& strPathsSepSpc, HWND currentWindowHandle)
{
	// CF_HDROP
	HGLOBAL hDrop = GlobalAlloc(GHND, sizeof(DROPFILES) + sizeof(tchar_t) * strPaths.length());
	if (hDrop == nullptr)
		return;
	if (tchar_t* pDrop = static_cast<tchar_t*>(GlobalLock(hDrop)))
	{
		DROPFILES df = { 0 };
		df.pFiles = sizeof(DROPFILES);
		df.fWide = (sizeof(tchar_t) > 1);
		memcpy(pDrop, &df, sizeof(DROPFILES));
		memcpy((BYTE*)pDrop + sizeof(DROPFILES), (const tchar_t*)strPaths.c_str(), sizeof(tchar_t) * strPaths.length());
		GlobalUnlock(hDrop);
	}

	// CF_DROPEFFECT
	HGLOBAL hDropEffect = GlobalAlloc(GHND, sizeof(DWORD));
	if (hDropEffect == nullptr)
	{
		GlobalFree(hDrop);
		return;
	}
	if (DWORD* p = static_cast<DWORD*>(GlobalLock(hDropEffect)))
	{
		*p = DROPEFFECT_COPY;
		GlobalUnlock(hDropEffect);
	}

	// CF_UNICODETEXT
	HGLOBAL hPathnames = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, sizeof(tchar_t) * (strPathsSepSpc.length() + 1));
	if (hPathnames == nullptr)
	{
		GlobalFree(hDrop);
		GlobalFree(hDropEffect);
		return;
	}
	if (void* pPathnames = GlobalLock(hPathnames))
	{
		memcpy((BYTE*)pPathnames, (const tchar_t*)strPathsSepSpc.c_str(), sizeof(tchar_t) * strPathsSepSpc.length());
		((tchar_t*)pPathnames)[strPathsSepSpc.length()] = 0;
		GlobalUnlock(hPathnames);
	}

	UINT CF_DROPEFFECT = RegisterClipboardFormat(CFSTR_PREFERREDDROPEFFECT);
	if (::OpenClipboard(currentWindowHandle))
	{
		EmptyClipboard();
		SetClipboardData(CF_HDROP, hDrop);
		SetClipboardData(CF_DROPEFFECT, hDropEffect);
		SetClipboardData(GetClipTcharTextFormat(), hPathnames);
		CloseClipboard();
	}
}

</file>

<file path="Winmerge-Src/Src/Common/ClipBoard.h">
/**
 * @file  ClipBoard.h
 *
 * @brief ClipBoard helper functions definitions.
 */
#pragma once

#include "UnicodeString.h"

template<typename WindowHandle>
bool PutToClipboard(const String & text, WindowHandle currentWindowHandle);
bool GetFromClipboard(String & text);
template<typename WindowHandle>
void PutFilesToClipboardInternal(const String& strPaths, const String& strPathsSepSpc, WindowHandle currentWindowHandle);

template<class Container, typename WindowHandle>
void PutFilesToClipboard(const Container& list, WindowHandle currentWindowHandle)
{
	constexpr size_t MaxPathFull = 32767;
	String strPaths, strPathsSepSpc;
	strPaths.reserve(list.size() * MaxPathFull);
	strPathsSepSpc.reserve(list.size() * MaxPathFull);

	for (Container::const_iterator it = list.begin(); it != list.end(); ++it)
	{
		String path = *it;

		strPaths += path;
		strPaths += _T('\0');

		strPathsSepSpc += _T("\"");
		strPathsSepSpc += path;
		strPathsSepSpc += _T("\" ");
	}

	strPaths += _T('\0');
	strPathsSepSpc = strutils::trim_ws_end(strPathsSepSpc);

	PutFilesToClipboardInternal(strPaths, strPathsSepSpc, currentWindowHandle);
}
</file>

<file path="Winmerge-Src/Src/Common/CMoveConstraint.cpp">
/*!
  \file    CMoveConstraint.cpp
  \author  Perry Rapp, Creator, 1998-2004
  \date    Created: 1998
  \date    Edited:  2006-09-23 (Kimmo Varis)

  \brief   Implementation of CMoveConstraint

*/
/* The MIT License
Copyright (c) 2001 Perry Rapp
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/


#include "StdAfx.h"
#include "CMoveConstraint.h"
#include "Win_VersionHelper.h"
#include <afxtempl.h>       // MFC template collection classes
#include <afxext.h> // needed for CFormView

#ifdef _DEBUG
#define new DEBUG_NEW
#endif




namespace prdlg {

// from windowsx.h
#define GetWindowStyle(hwnd) ((DWORD)::GetWindowLong(hwnd, GWL_STYLE))
#define MapWindowRect(hwndFrom, hwndTo, lprc) \
                    MapWindowPoints((hwndFrom), (hwndTo), (POINT *)(lprc), 2)

// from wdj
static RECT getGripRect(HWND hwnd)
{
	RECT rc;
	GetClientRect(hwnd, &rc);
	rc.left = rc.right - GetSystemMetrics(SM_CXVSCROLL);
	rc.top = rc.bottom - GetSystemMetrics(SM_CYHSCROLL);
	return rc;
}

CMoveConstraint::EGRIP CMoveConstraint::c_defGrip = SG_NORMAL;

CMoveConstraint::Constraint::Constraint()
{
	Init();
}
CMoveConstraint::Constraint::Constraint(double fLeftX, double fExpandX, double fAboveY, double fExpandY, HWND hwndChild, CWnd * pWnd)
{
	Init();
	m_fLeftX = fLeftX;
	m_fExpandX = fExpandX;
	m_fAboveY = fAboveY;
	m_fExpandY = fExpandY;
	m_hwndChild = hwndChild;
	m_pWnd = pWnd;
}
void 
CMoveConstraint::Constraint::Init()
{
	m_fLeftX = 0;
	m_fExpandX = 0;
	m_fAboveY = 0;
	m_fExpandY = 0;
	m_hwndChild = nullptr;
	m_pWnd = nullptr;
	// m_rectChildOriginal
	m_hwndParent = nullptr;
}

CMoveConstraint::CMoveConstraint()
: m_hTheme(nullptr)
, m_bSubclassed(false)
, m_oldWndProc(nullptr)
, m_sRegistryValueName(_T("UnnamedWindow"))
, m_sRegistrySubkey(_T("LastWindowPos"))
{
	ClearMostData();
}

bool
CMoveConstraint::InitializeCurrentSize(HWND hwndDlg)
{
	ASSERT(!m_hwndDlg);
	if (!IsWindow(hwndDlg))
		return false;
	m_hwndDlg = hwndDlg;

	GrabCurrentDimensionsAsOriginal(hwndDlg);
	return true;
}

void
CMoveConstraint::GrabCurrentDimensionsAsOriginal(HWND hwndDlg)
{
	// figure original size for resizing code
	GetClientRect(hwndDlg, m_rectDlgOriginal);
	CRect rect;
	GetWindowRect(hwndDlg, &rect);

	// (min/max code)
	// remember original width & heighth in case a disallow function called
	// by default, set minimum size to original size
	m_nOrigX = m_nMinX = rect.Width();
	m_nOrigY = m_nMinY = rect.Height();

	m_bOriginalFetched = true;
}

void
CMoveConstraint::InitializeSpecificSize(HWND /*hwndDlg*/, int nWidth, int nHeight)
{
	// figure original size for resizing code
	m_rectDlgOriginal.left = 0;
	m_rectDlgOriginal.right = nWidth;
	m_rectDlgOriginal.top = 0;
	m_rectDlgOriginal.bottom = nHeight;

	// (min/max code)
	// remember original width & heighth in case a disallow function called
	// by default, set minimum size to original size
	m_nOrigX = m_nMinX = nWidth;
	m_nOrigY = m_nMinY = nHeight;
}

bool
CMoveConstraint::InitializeOriginalSize(HWND hwndDlg)
{
	ASSERT(hwndDlg != nullptr && m_hwndDlg == nullptr);
	m_hwndDlg = hwndDlg;

	return m_nOrigX != 0; // if 0, we didn't get WM_SIZE so we don't know the original size
}

bool
CMoveConstraint::InitializeOriginalSize(CWnd * pParent)
{
	ASSERT(pParent != nullptr);
	return InitializeOriginalSize(pParent->m_hWnd);
}


void
CMoveConstraint::InitializeSpecificSize(CWnd * pDlg, int nWidth, int nHeight)
{
	ASSERT(pDlg != nullptr);
	InitializeSpecificSize(pDlg->m_hWnd, nWidth, nHeight);
}

bool
CMoveConstraint::InitializeCurrentSize(CWnd * pDlg)
{
	ASSERT(pDlg != nullptr);
	return InitializeCurrentSize(pDlg->m_hWnd);
}

void
CMoveConstraint::UpdateSizes()
{
	Resize(m_hwndDlg, SIZE_RESTORED);
}

void
CMoveConstraint::AllowHeightShrink()
{
	m_nMinY = 0;
}
void
CMoveConstraint::AllowWidthShrink()
{
	m_nMinX = 0;
}
void
CMoveConstraint::DisallowHeightGrowth()
{
	m_nMaxY = m_nOrigY;
}
void
CMoveConstraint::DisallowWidthGrowth()
{
	m_nMaxX = m_nOrigX;
}

void
CMoveConstraint::SetMaxSizePixels(int nWidth, int nHeight)
{
	if (nWidth != -1)
		m_nMaxX = nWidth;
	if (nHeight != -1)
		m_nMaxY = nHeight;
}

void
CMoveConstraint::SetMinSizePixels(int nWidth, int nHeight)
{
	if (nWidth != -1)
		m_nMinX = nWidth;
	if (nHeight != -1)
		m_nMinY = nHeight;
}

void
CMoveConstraint::SetMinSizePercent(double fWidth, double fHeight)
{
	if (fWidth >= 0)
		m_nMinX = (int)(fWidth * m_nOrigX);
	if (fHeight >= 0)
		m_nMinY = (int)(fHeight * m_nOrigY);
}

void
CMoveConstraint::SetScrollScale(CFormView * pFormView, double fShrinkWidth, double fShrinkHeight)
{
	m_fShrinkHeight = fShrinkHeight;
	m_fShrinkWidth = fShrinkWidth;
	m_pFormView = pFormView;
	CSize size = pFormView->GetTotalSize();
	m_nOrigScrollX = size.cx;
	m_nOrigScrollY = size.cy;
}

CMoveConstraint::~CMoveConstraint()
{
	ClearMostData();
}


void
CMoveConstraint::ClearMostData()
{
	// clears everything but m_bSubclassed
	// this is called from constructor, OnDestroy, and destructor
	// so it can't assume any numerical variables have sane values
	m_hwndDlg=nullptr;
	// m_rectDlgOriginal
	m_nOrigX=0;
	m_nOrigY=0;
	m_nGrip=c_defGrip;
	m_bOriginalFetched=false;
	m_nMinX=0;
	m_nMinY=0;
	m_nMaxX=0;
	m_nMaxY=0;
	m_nDelayed=0;
	// this specifically does NOT touch m_bSubclassed, as a subclass may still be in use
	m_pFormView=nullptr;
	m_nOrigScrollX=0;
	m_nOrigScrollY=0;
	m_fShrinkWidth=0;
	m_fShrinkHeight=0;
	m_bPropertyPage=false;
	m_bPropertySheet=false;
	m_ConstraintList.clear();
	m_bPersistent=false;
	m_bConstrainNonChildren = false;
}

void
CMoveConstraint::
InitializeChildConstraintData(HWND hwndDlg, Constraint & constraint)
{
	HWND hwndChild = constraint.m_hwndChild;
	ASSERT(IsWindow(hwndChild));
	constraint.m_hwndParent = GetParent(hwndChild);
	if (!m_bConstrainNonChildren && constraint.m_hwndParent != hwndDlg)
	{
		// this is all predicated on the children being real Windows children
		// because of the use of client coordinates in ::SetWindowPos down in Resize() below
		// altho the truth is, the scaling is linear, so it will work with any windows
		// but if you want to do that, you have to call 
		//  m_constraint.ConstrainNonWindows();
		// to suppress this debug ASSERT
		ASSERT(false); // this is not a child of the dialog
	}
	GetWindowRect(hwndChild, constraint.m_rectChildOriginal);
	CWnd * wndParent = CWnd::FromHandle(constraint.m_hwndParent);
	wndParent->ScreenToClient(constraint.m_rectChildOriginal);
}

bool
CMoveConstraint::
Constrain(HWND hwndChild, double fLeftX, double fExpandX, double fAboveY, double fExpandY)
{
	return DoConstrain(0, hwndChild, fLeftX, fExpandX, fAboveY, fExpandY);
}

bool
CMoveConstraint::
DoConstrain(CWnd * pWnd, HWND hwndChild, double fLeftX, double fExpandX, double fAboveY, double fExpandY)
{
	Constraint constraint(fLeftX, fExpandX, fAboveY, fExpandY, hwndChild, pWnd);

	if (m_hwndDlg && IsWindow(m_hwndDlg) && hwndChild != nullptr && IsWindow(hwndChild))
	{
		InitializeChildConstraintData(m_hwndDlg, constraint);
	}
	else
	{
		if (pWnd == nullptr) // only CWnds can be deferred
			return false;
		m_nDelayed++;
	}

	m_ConstraintList.push_back(constraint);
	return true;
}


void
CMoveConstraint::
Constrain(CWnd * pWnd, double fLeftX, double fExpandX, double fAboveY, double fExpandY)
{
	ASSERT(pWnd != nullptr);
	DoConstrain(pWnd, pWnd->m_hWnd, fLeftX, fExpandX, fAboveY, fExpandY);
}

bool
CMoveConstraint::
ConstrainItem(int nId, double fLeftX, double fExpandX, double fAboveY, double fExpandY)
{
	if (m_hwndDlg == nullptr || !IsWindow(m_hwndDlg))
		return false;
	HWND hwnd = GetDlgItem(m_hwndDlg, nId);
	return DoConstrain(0, hwnd, fLeftX, fExpandX, fAboveY, fExpandY);
}

/**
 * This is the window proc callback that works with the CSubclass module.
 */
LRESULT CALLBACK
CMoveConstraint::ConstraintWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	void * data = GetProp(hwnd, _T("CMoveConstraintData"));
	if (!data)
		return DefWindowProc(hwnd, msg, wParam, lParam);
	CMoveConstraint * constraint = reinterpret_cast<CMoveConstraint *>(data);

	LRESULT lresult;
	if (constraint->WindowProc(hwnd, msg, wParam, lParam, &lresult))
		return lresult;

	return CallWindowProc(constraint->m_oldWndProc, hwnd, msg, wParam, lParam);
}
bool
CMoveConstraint::SubclassWnd()
{
	void * data = reinterpret_cast<void *>(this);
	// this will return false if this window/wndproc combination has already
	// been established (subclassed)
	m_oldWndProc = reinterpret_cast<WNDPROC>(GetWindowLongPtr(m_hwndDlg, GWLP_WNDPROC));
	if (SetWindowLongPtr(m_hwndDlg, GWLP_WNDPROC, (__int3264)(LONG_PTR)(CMoveConstraint::ConstraintWndProc)) != 0)
	{
		if (SetProp(m_hwndDlg, _T("CMoveConstraintData"), data))
		{
			m_bSubclassed = true;
		}
		else
		{
			SetWindowLongPtr(m_hwndDlg, GWLP_WNDPROC, (__int3264)(LONG_PTR)(m_oldWndProc));
			m_oldWndProc = nullptr;
		}
	}
	return m_bSubclassed;
}
bool
CMoveConstraint::UnSubclassWnd()
{
	if (!m_bSubclassed)
		return false;
	SetWindowLongPtr(m_hwndDlg, GWLP_WNDPROC, (__int3264)(LONG_PTR)(m_oldWndProc));
	RemoveProp(m_hwndDlg, _T("CMoveConstraintData"));
	m_oldWndProc = nullptr;
	m_bSubclassed = false;
	return true;
}

/**
 * Check if we have any pending constraints not yet added to constraint list
 * because they were set before the dialog was created (so initial sizes 
 * could not yet be captured).
 */
void
CMoveConstraint::CheckDeferredChildren()
{
	if (m_nDelayed == 0)
		return;
	for (auto& constraint : m_ConstraintList)
	{
		if (constraint.m_hwndChild  != nullptr)
			continue;
		ASSERT(constraint.m_pWnd != nullptr);
		if (constraint.m_pWnd->m_hWnd != nullptr)
		{
			constraint.m_hwndChild = constraint.m_pWnd->m_hWnd;
			InitializeChildConstraintData(m_hwndDlg, constraint);
			m_nDelayed--;
		}
	}
}

/**
 * Custom handling for WM_SIZE
 * Apply all resize constraints from the constraint list.
 */
void
CMoveConstraint::Resize(HWND hWnd, UINT nType)
{
// optional - could use BeginDeferWindowPos, DeferWindowPos, EndDeferWindowPos
// 2000/10/07 - haven't tried them
// but I don't think they'd matter because I use SWP_NOREDRAW in the loop

	if (nType == SIZE_MINIMIZED) return;

	if (m_hwndDlg == nullptr && hWnd != nullptr && !m_bOriginalFetched)
	{
		// if early subclass or wndproc
		// grab early dimensions, in case we want them later (eg, property sheet)
		GrabCurrentDimensionsAsOriginal(hWnd);
		return;
	}

	if (m_hwndDlg == nullptr || !IsWindow(m_hwndDlg))
		return;

	CRect rectParentCurrent;
	GetClientRect(m_hwndDlg, rectParentCurrent);

	// compute delta from original size (all fractions based on this)
	int nDeltaWidth = (rectParentCurrent.right - m_rectDlgOriginal.right);
	int nDeltaHeight = (rectParentCurrent.bottom - m_rectDlgOriginal.bottom);

	for (auto& constraint : m_ConstraintList)
	{
		if (constraint.m_hwndChild == nullptr)
			continue;

		CRect rectChildCurrent;
		// get the screen & client coordinates of the child
		::GetWindowRect(constraint.m_hwndChild, &rectChildCurrent);
		CWnd * wndParent = CWnd::FromHandle(constraint.m_hwndParent);
		wndParent->ScreenToClient(&rectChildCurrent);

		int nDelta;

		nDelta = nDeltaWidth;
		rectChildCurrent.left = (int)(nDelta * constraint.m_fLeftX) + constraint.m_rectChildOriginal.left;
		rectChildCurrent.right = (int)(nDelta * (constraint.m_fLeftX + constraint.m_fExpandX)) + constraint.m_rectChildOriginal.right;

		nDelta = nDeltaHeight;
		rectChildCurrent.top = (int)(nDelta * constraint.m_fAboveY) + constraint.m_rectChildOriginal.top;
		rectChildCurrent.bottom = (int)(nDelta * (constraint.m_fAboveY + constraint.m_fExpandY)) + constraint.m_rectChildOriginal.bottom;

		SetWindowPos(constraint.m_hwndChild, nullptr, rectChildCurrent.left, rectChildCurrent.top
			, rectChildCurrent.Width(), rectChildCurrent.Height(), SWP_NOZORDER+SWP_NOREDRAW);
	}

	if (m_pFormView != nullptr)
	{
		// ignore growth
		//if (nDeltaWidth > 0)
		//	nDeltaWidth = 0;
		//if (nDeltaHeight > 0)
		//	nDeltaHeight = 0;
		CSize size;
		size.cx = (int)(m_nOrigScrollX + nDeltaWidth * m_fShrinkWidth);
		size.cy = (int)(m_nOrigScrollY + nDeltaHeight * m_fShrinkHeight);
		m_pFormView->SetScrollSizes(MM_TEXT, size);
	}

	InvalidateRect(m_hwndDlg, nullptr, TRUE);
	UpdateWindow(m_hwndDlg);
}

/**
 * Custom handling for WM_GETMINMAXINFO.
 * Enforce any resizing limitations.
 */
void
CMoveConstraint::OnGetMinMaxInfo(MINMAXINFO* lpMMI)
{
	// views don't get WM_GETMINMAXINFO, but dialogs & frames do
	if (m_hwndDlg == nullptr)
		return;
	if (m_nMinX)
		lpMMI->ptMinTrackSize.x = m_nMinX;
	if (m_nMinY)
		lpMMI->ptMinTrackSize.y = m_nMinY;
	if (m_nMaxX)
		lpMMI->ptMaxTrackSize.x = m_nMaxX;
	if (m_nMaxY)
		lpMMI->ptMaxTrackSize.y = m_nMaxY;
}

bool
CMoveConstraint::PaintGrip()
{
	if (m_nGrip == SG_NONE) return false;
	if (m_hwndDlg == nullptr) return false;
	HWND hw = (m_nGrip == SG_PARENTSTATE) ? GetParent(m_hwndDlg) : m_hwndDlg;
	return !IsZoomed(hw) && !IsIconic(hw);
}

/**
 * Custom handling for WM_NCHITTEST
 * We paint the sizing grip if the mouse is in the lower right hand corner.
 */
bool
CMoveConstraint::OnNcHitTest(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT * plresult)
{
	// views don't get WM_NCHITTEST, but dialogs & frames do
	if (m_hwndDlg == nullptr)
		return false;
	if (m_nMinY == m_nMaxY)
	{
		LRESULT nRet = CallWindowProc(m_oldWndProc, m_hwndDlg, msg, wParam, lParam);
		switch(nRet)
		{
		case HTBOTTOMLEFT:
		case HTTOPLEFT:
			*plresult = HTLEFT;
			return true;
		case HTBOTTOMRIGHT:
		case HTTOPRIGHT:
			*plresult = HTRIGHT;
			return true;
		case HTBOTTOM:
		case HTTOP:
			*plresult = HTBORDER;
			return true;
		}
		return false;
	}
	if (m_nMinX == m_nMaxX)
	{
		LRESULT nRet = CallWindowProc(m_oldWndProc, m_hwndDlg, msg, wParam, lParam);
		switch(nRet)
		{
		case HTBOTTOMLEFT:
		case HTBOTTOMRIGHT:
			*plresult = HTBOTTOM;
			return true;
		case HTTOPLEFT:
		case HTTOPRIGHT:
			*plresult = HTTOP;
			return true;
		case HTLEFT:
		case HTRIGHT:
			*plresult = HTBORDER;
			return true;
		}
		return false;
	}
	if (!PaintGrip())
		return false;

	// check for size grip
	int x = (int)(short)LOWORD(lParam);
	int y = (int)(short)HIWORD(lParam);
	int cx,cy;
	RECT rc = getGripRect(m_hwndDlg);
	MapWindowRect(m_hwndDlg, HWND_DESKTOP, &rc);
	RECT rc2;
	GetWindowRect(m_hwndDlg, &rc2);
	cx = x-rc.left;
	cy = y-rc.top;
	if (0 < cx && 0 < cy && (rc.right - rc.left < cy+cy))
	{
		*plresult = HTBOTTOMRIGHT;
		return true;
	}
	return false;
}

void
CMoveConstraint::OnDestroy()
{
	if (m_bPersistent)
		Persist(true, true);
	UnSubclassWnd();
	// the one variable that CANNOT safely be cleared now is m_bSubclassed
	// because the subclass is almost certainly not yet removed
	// (the subclass calls us to let us do destroy processing, before 
	//  removing itself)
	ClearMostData();
}

/**
 * Custom handling of the TTN_NEEDTEXT notification message
 */
bool
CMoveConstraint::OnTtnNeedText(TOOLTIPTEXT * pTTT, LRESULT * plresult)
{
	UINT_PTR id = pTTT->hdr.idFrom;
	UINT uflags = pTTT->uFlags;
	if (uflags & TTF_IDISHWND)
		id = GetDlgCtrlID((HWND)id);
	tip ti;
	if (m_tips.Lookup(id, ti))
	{
		if (ti.m_nResourceId)
		{
			pTTT->lpszText = MAKEINTRESOURCE(ti.m_nResourceId);
			pTTT->hinst = AfxGetResourceHandle();
		}
		else
		{
			pTTT->lpszText = (tchar_t*)(const tchar_t*)ti.m_sText;
		}
		*plresult = true; // return `true` from original window proc
		return true; // stop processing this message
	}
	return false;
}

/**
 * Main window proc of this subclassing library
 * Set plresult to set the return value of the real window proc which called us.
 * Return true to prevent any further handling of this message.
 */
bool
CMoveConstraint::WindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam, LRESULT * plresult)
{
	if (m_bPropertyPage)
	{
		// pass PSN_SETACTIVE to parent (property sheet)
		if (m_hwndDlg && (WM_NOTIFY == msg) && (PSN_SETACTIVE == (((NMHDR *)lParam)->code)))
		{
			HWND hwndParent = GetParent(m_hwndDlg);
			NMHDR nmhdr = { hwndParent, 0, PSN_SETACTIVE };
			SendMessage(hwndParent, WM_NOTIFY, 0, (LPARAM)&nmhdr);
		}
	}
	if (m_bPropertySheet)
	{
		if ((WM_NOTIFY == msg) && (PSN_SETACTIVE == (((NMHDR *)lParam)->code)))
		{
			CheckDeferredChildren();
		}
	}
	if (WM_GETMINMAXINFO == msg) {
		OnGetMinMaxInfo(reinterpret_cast<LPMINMAXINFO>(lParam));
	} else if (WM_SIZE == msg) { // 2000/03/10 - tried WM_EXITSIZEMOVE - no help for property page problem
		Resize(hWnd, (UINT)wParam /* x & y in lParam */);
	} else if (WM_PAINT == msg && PaintGrip()) {
		CPaintDC dc(CWnd::FromHandle(hWnd));
		RECT rc = getGripRect(hWnd);
		if (IsVista_OrGreater() && m_hTheme == nullptr && IsThemeActive()) {
			m_hTheme = OpenThemeData(hWnd, WC_SCROLLBAR);
		}
		if (m_hTheme != nullptr) {
			DrawThemeBackground(m_hTheme, dc.GetSafeHdc(), SBP_SIZEBOX, 0, &rc, nullptr);
		} else {
			dc.DrawFrameControl(&rc, DFC_SCROLL, DFCS_SCROLLSIZEGRIP);
		}
	} else if (WM_THEMECHANGED == msg) {
		if (m_hTheme != nullptr) {
			CloseThemeData(m_hTheme);
			m_hTheme = nullptr;
		}
		if (m_hTheme == nullptr && IsThemeActive()) {
			m_hTheme = OpenThemeData(hWnd, WC_SCROLLBAR);
		}
	} else if (WM_NCHITTEST == msg && !IsIconic(hWnd) && !IsZoomed(hWnd)) {
		if (OnNcHitTest(msg, wParam, lParam, plresult))
			return true;
	} else if (WM_DESTROY == msg) {
		if (m_hTheme != nullptr) {
			CloseThemeData(m_hTheme);
			m_hTheme = nullptr;
		}
		OnDestroy();
	} else if (msg==WM_NOTIFY && TTN_NEEDTEXT==((NMHDR*)lParam)->code) {
		if (OnTtnNeedText((TOOLTIPTEXT*)lParam, plresult))
			return true;
	}

	return false;
}

/**
 * Save size (& optionally position) in registry
 */
void
CMoveConstraint::LoadPosition(const tchar_t* szKeyName, const tchar_t* szValueName, bool position)
{
	m_sRegistrySubkey = szKeyName;
	LoadPosition(szValueName, position);
}

/**
 * Save size (& optionally position) in registry
 */
void
CMoveConstraint::LoadPosition(const tchar_t* szValueName, bool position)
{
	m_sRegistryValueName = szValueName;
	m_bPersistent=true;
	Persist(false, position);
}

void
CMoveConstraint::Persist(bool saving, bool position)
{
	const tchar_t* szSection = m_sRegistrySubkey;
	if (saving)
	{
		CString str;
		RECT rc;
		GetWindowRect(m_hwndDlg, &rc);
		str.Format(_T("%d,%d,%d,%d"), rc.left, rc.top, rc.right, rc.bottom);
		AfxGetApp()->WriteProfileString(szSection, m_sRegistryValueName, str);
	}
	else
	{
		RECT wprc;
		CString str = AfxGetApp()->GetProfileString(szSection, m_sRegistryValueName);
		GetWindowRect(m_hwndDlg, &wprc);
		if (m_pFormView != nullptr)
			CWnd::FromHandle(m_hwndDlg)->GetParent()->ScreenToClient(&wprc);
		CRect rc;
		int ct=_stscanf_s(str, _T("%d,%d,%d,%d"), &rc.left, &rc.top, &rc.right, &rc.bottom);
		if (ct==4)
		{
			if (position)
			{
				wprc.left = rc.left;
				wprc.top = rc.top;
			}
			int width = rc.Width();
			int height = rc.Height();
			if (m_nMinX && m_nMinX > width)  width = m_nMinX;
			if (m_nMaxX && m_nMaxX < width)  width = m_nMaxX;
			if (m_nMinY && m_nMinY > height) height = m_nMinY;
			if (m_nMaxY && m_nMaxY < height) height = m_nMaxY;
			wprc.right = wprc.left + width;
			wprc.bottom = wprc.top + height;
			SetWindowPos(m_hwndDlg, nullptr, 
				wprc.left, wprc.top, wprc.right - wprc.left, wprc.bottom - wprc.top,
				SWP_NOZORDER | SWP_NOACTIVATE);
		}
	}
}


void
CMoveConstraint::SetTip(int id, const tchar_t* szTip)
{
	tip ti;
	ti.m_sText = szTip;
	m_tips[id] = ti;
}

void
CMoveConstraint::SetTip(int id, int nResourceId)
{
	tip ti;
	ti.m_nResourceId = nResourceId;
	m_tips[id] = ti;
}


} // namespace

</file>

<file path="Winmerge-Src/Src/Common/CMoveConstraint.h">
/*!
  \file    CMoveConstraint.h
  \author  Perry Rapp, Creator, 1998-2004
  \date    Created: 1998
  \date    Edited:  2006-09-23 (Kimmo Varis)

  \brief   Declaration of CMoveConstraint

*/
/* The MIT License
Copyright (c) 2001 Perry Rapp
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
#pragma once

#include <afxtempl.h>

class CFormView;

namespace prdlg {

/*!
  \class CMoveConstraint
  \brief Code to resize controls on a dialog (formview, propertypage)

  HOW TO USE

  (a) add a member variable

	prdlg::CMoveConstraint m_constraint; 

  (b) add (1) Initialize & (2,3,4...) Constrain calls
      (to OnInitDialog for dialogs)
      (to InitialUpdate for views)
      (to OnCreate or OnCreateClient for frames)

  (c) optionally call any Allow or Disallow functions to adjust sizing potential (as in b)

  (d) call SetIsPropertyPage or Sheet if appropriate
       call SetScrollScale (for formview)

  Choose to (e1) Subclass or (e2) call WindowProc

  (e1) call Subclass - can call after Initialize calls
       unless original size is needed, eg FormViews,
		 in which case call Initialize from OnNcCreate

  (e2) override dialog's WindowProc and forward to constraint
    add code to WindowProc (copy following block) before the call to the parent WindowProc
	   use ClassWizard, or add to AFX_VIRTUAL block:
	   virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);

	LRESULT lresult;
	if (m_constraint.WindowProc(m_hWnd, message, wParam, lParam, &lresult))
		return lresult;


   For frames & views, the GetMinMaxInfo is sent to the frame
   so the frame must have a constraint to control min & max

  EXAMPLE USE (in InitDialog)

  m_constraint.InitializeCurrentSize(this);
  m_constraint.ConstrainItem(IDC_EDIT, 0, 1, 0, 1); // fills up all x & y delta
  m_constraint.ConstrainItem(IDC_LABEL, 0, 0, 1, 0); // no expansion, but below 100% of height growth
  m_constraint.SubclassWnd(); // install subclassing

 */

class CMoveConstraint
{
public:
	enum EGRIP { SG_NONE, SG_NORMAL, SG_PARENTSTATE };
private:
	static EGRIP c_defGrip; // class-wide default sizing grip setting

public:
	static void SetDefGrip(EGRIP nDefGrip) { c_defGrip = nDefGrip; }

public:

	// add a MoveConstraint member to dialog or view
	CMoveConstraint();
	~CMoveConstraint();

	bool IsInitalized() { return m_hwndDlg!=nullptr; }

	// THIS IS THE USUAL ONE
	// call from InitDialog (dialogs) or InitialUpdate (views) or OnCreate (frames)
	// if you want the current size of the dialog
	// to be used for scaling the controls
	// fails if IsWindow fails
	bool InitializeCurrentSize(HWND hwndParent);
	bool InitializeCurrentSize(CWnd * pParent);

	// if you want to set, a priori, the size of the dialog to be assumed
	// the controls are scaled for in the template
	// for use when parent is maximized, and we need to know the design size (in pixels)
	// this size is what the initial controls are sized to fit
	void InitializeSpecificSize(HWND hwndParent, int nWidth, int nHeight);
	void InitializeSpecificSize(CWnd * pParent, int nWidth, int nHeight);

	// for FORMVIEWS, who lose their dialog size early
	// fails if no WM_SIZE came thru
	bool InitializeOriginalSize(CWnd * pParent);
	bool InitializeOriginalSize(HWND hwndParent);

	// force an update of controls (laying them out to current size)
	void UpdateSizes();

	// default is no height shrink, no width shrink
	// but allowed height growth & allowed width growth
	void AllowHeightShrink();
	void AllowWidthShrink();
	void DisallowHeightGrowth();
	void DisallowWidthGrowth();
	// if you know exactly how big you want to allow it (in pixels)
	// use -1 to not set an argument
	void SetMaxSizePixels(int nWidth, int nHeight);
	void SetMinSizePixels(int nWidth, int nHeight);
	void SetMinSizePercent(double fWidth, double fHeight);

	// for FORMVIEW, how much to reduce scrollbars when form shrinks
	void SetScrollScale(CFormView * pFormView, double fShrinkWidth, double fShrinkHeight);

	// call for each constrained child window (three equivalent versions for convenience)
	// fails if IsWindow fails (except with CWnd it is just deferred)
	bool Constrain(HWND hwndChild, double fLeftX, double fExpandX, double fAboveY, double fExpandY);
	void Constrain(CWnd * pWnd, double fLeftX, double fExpandX, double fAboveY, double fExpandY);
	bool ConstrainItem(int nId, double fLeftX, double fExpandX, double fAboveY, double fExpandY);

	void SetIsPropertyPage() { m_bPropertyPage = true; SetSizeGrip(SG_NONE); }
	void SetIsPropertySheet() { m_bPropertySheet = true; }
	void SetIsView() { SetSizeGrip(SG_PARENTSTATE); }

	// If you plan to constrain windows that are not your children
	// (eg, grandchildren), call this
	void ConstrainNonChildren() { m_bConstrainNonChildren = true; }

	// embedded windows, such as property pages or formviews, should set the size grip to none
	void SetSizeGrip(EGRIP nGrip) { m_nGrip = nGrip; }
	// either Subclass or call a WindowProc
	bool SubclassWnd();
	bool UnSubclassWnd();

	// call after all constraints established
	// always loads size, may also set position
	void LoadPosition(const tchar_t* szKeyName, const tchar_t* szValueName, bool position);
	void LoadPosition(const tchar_t* szValueName, bool position);
	void Persist(bool saving, bool position);

	// for use when children hadn't been created yet at initialization time
	// so their constraints had to be buffered to be initialized later
	// (this is used by property pages & property sheets automatically, at PSN_SETACTIVE)
	void CheckDeferredChildren();
	int GetDeferredCount() { return m_nDelayed; }

	// see usage section above
	bool WindowProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam, LRESULT * plresult);

// ToolTips
	void SetTip(int id, const tchar_t* szTip);
	void SetTip(int id, int nResourceId);

// Implementation methods
protected:
	struct Constraint;
	void GrabCurrentDimensionsAsOriginal(HWND hwndParent);
	bool DoConstrain(CWnd * pWnd, HWND hwndChild, double fLeftX, double fExpandX, double fAboveY, double fExpandY);
	void InitializeChildConstraintData(HWND hwndParent, Constraint & constraint);
	// handle WM_SIZE
	void Resize(HWND hWnd, UINT nType);
	// handle WM_GETMINMAXINFO
	void OnGetMinMaxInfo(MINMAXINFO* lpMMI );
	// handle WM_NCHITTEST
	bool OnNcHitTest(UINT message, WPARAM wParam, LPARAM lParam, LRESULT * plresult);
	// handle WM_NOTIFY/TTN_NEEDTEXT combination
	bool OnTtnNeedText(TOOLTIPTEXT * pTTT, LRESULT * plresult);
	bool PaintGrip();
	void ClearMostData();
	// handle WM_DESTROY
	void OnDestroy();


	static LRESULT CALLBACK ConstraintWndProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam );
	

// Implementation types
protected:
	struct tip { CString m_sText; int m_nResourceId; tip() : m_nResourceId(0) { } };

	struct Constraint
	{
		double m_fLeftX;
		double m_fExpandX;
		double m_fAboveY;
		double m_fExpandY;
		HWND m_hwndChild;
		CWnd * m_pWnd;
		CRect m_rectChildOriginal;
		HWND m_hwndParent; // normally is the dialog
		Constraint();
		Constraint(double fLeftX, double fExpandX, double fAboveY, double fExpandY, HWND hwndChild, CWnd * pWnd);
		void Init();
	};

	typedef std::list<Constraint> ConstraintList;


// Implementation data
private:
	HWND m_hwndDlg; // parent of controls - could be FormView or PropertyPage or whatever as well
	CRect m_rectDlgOriginal;
	int m_nOrigX;
	int m_nOrigY;
	EGRIP m_nGrip;
	HTHEME m_hTheme;
	bool m_bOriginalFetched;
	int m_nMinX;
	int m_nMinY;
	int m_nMaxX;
	int m_nMaxY;
	int m_nDelayed; // CWnds without HWND
	bool m_bSubclassed;
	WNDPROC m_oldWndProc;
// formview stuff
	CFormView * m_pFormView;
	// formview original scrollbars
	int m_nOrigScrollX;
	int m_nOrigScrollY;
	// formview - how much scrollbars shrink
	double m_fShrinkWidth;
	double m_fShrinkHeight;
	// special handling for PSN_SETACTIVE
	bool m_bPropertyPage;
	bool m_bPropertySheet;
// constraints
	ConstraintList m_ConstraintList;
	bool m_bConstrainNonChildren;
	bool m_bPersistent; // whether to save position to registry
	CString m_sRegistrySubkey; // defaults to _T("LastWindowPos")
	CString m_sRegistryValueName; // should be name of window
// tooltips
	CMap<UINT_PTR, UINT_PTR, tip, tip&> m_tips;
};

} // namespace
</file>

<file path="Winmerge-Src/Src/Common/ColorButton.cpp">
/** 
 * @file  ColorButton.cpp
 *
 * @brief Implementation file for CColorButton
 *
 */

#include "stdafx.h"
#include "ColorButton.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/** 
 * @brief Default constructor setting color to black.
 */
CColorButton::CColorButton()
: m_clrFill(RGB(0, 0, 0))
{
}

/** 
 * @brief Constructor setting initial color
 * @param [in] clfFill Initial color to set.
 */
CColorButton::CColorButton(COLORREF clrFill)
: m_clrFill(clrFill)
{
}

/** 
 * @brief Draws color button
 */
void CColorButton::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct) 
{
	::FillRect(lpDrawItemStruct->hDC, &lpDrawItemStruct->rcItem, CBrush(m_clrFill));
}

/** 
 * @brief Sets new button color
 * @param [in] crlFill New color
 * @param [in] bInvalidate If `true` button is invalidated (causing redraw)
 */
void CColorButton::SetColor(COLORREF clrFill, bool bInvalidate /* = true*/)
{
	m_clrFill = clrFill;
	if (bInvalidate && m_hWnd != nullptr)
		Invalidate();
}
</file>

<file path="Winmerge-Src/Src/Common/ColorButton.h">
/** 
 * @file  ColorButton.h
 *
 * @brief Declaration file for CColorButton class
 */
#pragma once

/** 
 * @brief Button showing currently selected color.
 * This class creates a button that shows currently selected color in its
 * client area. When the button is selected it opens color selection
 * dialog for selecting new color.
 */
class CColorButton : public CButton
{
private:
	COLORREF m_clrFill;

public:
	CColorButton();
	explicit CColorButton(COLORREF clrFill);

	void SetColor(COLORREF clrFill, bool bInvalidate = true);
	COLORREF GetColor() const { return m_clrFill; };
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
};
</file>

<file path="Winmerge-Src/Src/Common/coretools.cpp">
/**
 * @file  coretools.cpp
 *
 * @brief Common routines
 *
 */

#include "pch.h"
#include "coretools.h"

static bool iseolch(char ch)
{
	return ch == '\n' || ch == '\r';
}

size_t linelen(const char *string, size_t maxlen)
{
	const char *q = string + maxlen;
	do
	{
		maxlen = q - string;
	} while (maxlen && iseolch(*--q));
	return maxlen;
}
</file>

<file path="Winmerge-Src/Src/Common/coretools.h">
/**
 * @file  coretools.h
 *
 * @brief Declaration file for Coretools.cpp
 */
#pragma once

size_t linelen(const char *string, size_t maxlen);
</file>

<file path="Winmerge-Src/Src/Common/DebugNew.h">
#ifdef _DEBUG
void* operator new(size_t size, const char *file, int line);
void* operator new[](size_t size, const char *file, int line);
#define DEBUG_NEW new(__FILE__, __LINE__)
#define new DEBUG_NEW
void operator delete(void* p, const char *file, int line);
void operator delete[](void* p, const char *file, int line);
#endif
</file>

<file path="Winmerge-Src/Src/Common/ExConverter.cpp">
/** 
 * @file  ExConverter.cpp
 *
 * @brief Codepage converter using external libraries.
 */

#include "pch.h"
#include "ExConverter.h"
#include <windows.h>
#include <mlang.h>
#include <memory>
#include <list>
#define POCO_NO_UNWINDOWS 1
#include <Poco/Mutex.h>
#include "unicoder.h"

#if !defined(__IMultiLanguage2_INTERFACE_DEFINED__) && !defined(__GNUC__)
#error "IMultiLanguage2 is not defined in mlang.h. Please install latest Platform SDK."
#endif

#if defined(__GNUC__)
const IID IID_IMultiLanguage2 = {0xDCCFC164, 0x2B38, 0x11d2, {0xB7, 0xEC, 0x00, 0xC0, 0x4F, 0x8F, 0x5D, 0x9A}};
#endif 

extern "C" typedef HRESULT (__stdcall *DllGetClassObjectFunc)(const CLSID &, const IID &, void **); 

class CExconverterMLang: public IExconverter {
private:
	IMultiLanguage2 *m_pmlang;
	HMODULE m_hLibMLang;
	DWORD m_mlangcookie;
#ifdef USEUNIVERSALCHARDET
	HMODULE m_hLibCharGuess;
	int (*m_pfnCharGuessInit)(void);
	int (*m_pfnCharGuessDone)(void);
	const char* (*m_pfnGuessChardet)(const char *str);
#endif

public:
	CExconverterMLang()
	: m_pmlang(nullptr)
	, m_hLibMLang(nullptr)
	, m_mlangcookie(0)
	{
	}

	virtual ~CExconverterMLang() override
	{
		if (m_pmlang != nullptr)
			m_pmlang->Release();
		if (m_hLibMLang != nullptr)
			FreeLibrary(m_hLibMLang);
	}

	bool initialize()
	{
		DllGetClassObjectFunc pfnDllGetClassObject = nullptr;
		IClassFactory *pClassFactory = nullptr;

		m_hLibMLang = LoadLibrary(_T("mlang.dll"));
		if (m_hLibMLang != nullptr)
		{
			pfnDllGetClassObject = (DllGetClassObjectFunc)GetProcAddress(m_hLibMLang, "DllGetClassObject");
			if (pfnDllGetClassObject != nullptr)
			{
				HRESULT hr = pfnDllGetClassObject(CLSID_CMultiLanguage, IID_IClassFactory, (void**)&pClassFactory);
				if (pClassFactory != nullptr)
				{
					hr = pClassFactory->CreateInstance(nullptr, IID_IMultiLanguage2, (void**)&m_pmlang);
					if (SUCCEEDED(hr))
					{
						pClassFactory->Release();
						return true;
					}
				}
			}
		}
		if (pClassFactory != nullptr)
			pClassFactory->Release();
		if (m_hLibMLang != nullptr)
		{
			FreeLibrary(m_hLibMLang);
			m_hLibMLang = nullptr;
		}
		return false;
	}

	bool convert(int srcCodepage, int dstCodepage, const unsigned char * src, size_t * srcbytes, unsigned char * dest, size_t * destbytes)
	{
		bool bsucceeded;
#ifdef POCO_ARCH_BIG_ENDIAN
		if (srcCodepage == ucr::CP_UCS2BE)
#else
		if (srcCodepage == ucr::CP_UCS2LE)
#endif
		{
			size_t srcwchars = *srcbytes / sizeof(wchar_t);
			bsucceeded = convertFromUnicode(dstCodepage, (const wchar_t *)src, &srcwchars, (char *)dest, destbytes);
			*srcbytes = srcwchars * sizeof(wchar_t);
		}
		else
		{
			size_t wsize = *srcbytes * 2 + 6;
			auto pbuf = std::make_unique<wchar_t[]>(wsize);
			bsucceeded = convertToUnicode(srcCodepage, (const char *)src, srcbytes, pbuf.get(), &wsize);
			if (!bsucceeded)
			{
				*destbytes = 0;
				return false;
			}
			bsucceeded = convertFromUnicode(dstCodepage, pbuf.get(), &wsize, (char *)dest, destbytes);
		}
		return bsucceeded;
	}

	bool convertFromUnicode(int dstCodepage, const wchar_t * src, size_t * srcchars, char * dest, size_t *destbytes)
	{
		UINT uisrcchars = static_cast<UINT>(*srcchars), uidestbytes = static_cast<UINT>(*destbytes);
		HRESULT hr = m_pmlang->ConvertStringFromUnicode(&m_mlangcookie, dstCodepage, (wchar_t *)src, &uisrcchars, (char *)dest, &uidestbytes);
		*srcchars = uisrcchars;
		*destbytes = uidestbytes;
		return SUCCEEDED(hr) ? true : false;
	}

	bool convertToUnicode(int srcCodepage, const char * src, size_t * srcbytes, wchar_t * dest, size_t *destchars)
	{
		UINT uisrcbytes = static_cast<UINT>(*srcbytes), uidestchars = static_cast<UINT>(*destchars);
		HRESULT hr = m_pmlang->ConvertStringToUnicode(&m_mlangcookie, srcCodepage, (char *)src, &uisrcbytes, dest, &uidestchars);
		*srcbytes = uisrcbytes;
		*destchars = uidestchars;
		if (SUCCEEDED(hr))
			return true;
		if (srcCodepage != ucr::CP_UCS2BE)
			return false;
#ifdef POCO_ARCH_BIG_ENDIAN
		return false;
#else
		// Workaround for the problem that Wine does not support UCS2-BE(1201) as the source code page for IMultiLanguage::ConvertStringToUnicode()
		if (uisrcbytes > 0)
		{
			for (size_t i = 0; i < uisrcbytes - 1; i += 2)
				dest[i >> 1] = (src[i] << 8) + src[i + 1];
			if ((uisrcbytes % 2) == 1)
				memcpy(reinterpret_cast<unsigned char*>(dest) + uisrcbytes - 1, src + uisrcbytes - 1, 1);
		}
		*srcbytes = uisrcbytes;
		*destchars = uisrcbytes;
		return true;
#endif
	}

	void clearCookie()
	{
		m_mlangcookie = 0;
	}

	int detectInputCodepage(int autodetectType, int defcodepage, const char *data, size_t size)
	{
		int codepage;
		IMLangConvertCharset *pcc;
		UINT dstsize;
		UINT srcsize;
		HRESULT hr;

		hr = m_pmlang->CreateConvertCharset(autodetectType, ucr::CP_UCS2LE, MLCONVCHARF_AUTODETECT, &pcc);
		if (FAILED(hr))
			return defcodepage;
		srcsize = static_cast<UINT>(size);
		dstsize = static_cast<UINT>(size * sizeof(wchar_t));
		auto pdst = std::make_unique<unsigned char[]>(size * sizeof(wchar_t));
		SetLastError(0);
		hr = pcc->DoConversion((unsigned char *)data, &srcsize, pdst.get(), &dstsize);
		pcc->GetSourceCodePage((unsigned *)&codepage);
		if (FAILED(hr) || GetLastError() == ERROR_NO_UNICODE_TRANSLATION || codepage == autodetectType)
		{
			int codepagestotry[3] = {0};
			if (codepage == autodetectType)
			{
				if (size < 2 || (data[0] != 0 && data[1] != 0))
				{
					codepagestotry[0] = defcodepage;
					codepagestotry[1] = ucr::CP_UTF_8;
				}
			}
			else
			{
				if (size < 2 || (data[0] != 0 && data[1] != 0))
					codepagestotry[0] = ucr::CP_UTF_8;
			}
			codepage = defcodepage;
			size_t i;
			for (i = 0; i < sizeof(codepagestotry)/sizeof(codepagestotry[0]) - 1; i++)
			{
				if (codepagestotry[i] == 0) break;
				pcc->Initialize(codepagestotry[i], ucr::CP_UCS2LE, 0);
				srcsize = static_cast<UINT>(size);
				dstsize = static_cast<UINT>(size * sizeof(wchar_t));
				SetLastError(0);
				hr = pcc->DoConversion((unsigned char *)data, &srcsize, pdst.get(), &dstsize);
				if (FAILED(hr) || GetLastError() == ERROR_NO_UNICODE_TRANSLATION)
					continue;
				codepage = codepagestotry[i];
				break;
			}
			if (codepagestotry[i] == 0 && (size % 2) == 0)
			{
				// UCS-2
				int lezerocount = 0;
				int lecrorlf = 0;
				int bezerocount = 0;
				int becrorlf = 0;
				for (i = 0; i < size; i += 2)
				{
					if (data[i] == 0)
					{
						bezerocount++;
						if (data[i + 1] == 0x0a || data[i + 1] == 0x0d)
							becrorlf++;
					}
					else if (data[i + 1] == 0)
					{
						lezerocount++;
						if (data[i] == 0x0a || data[i] == 0x0d)
							lecrorlf++;
					}
				}
				if (lezerocount > 0 || bezerocount > 0)
				{
					if ((lecrorlf == 0 && size < 512 || (lecrorlf > 0 && (size / lecrorlf > 1024))) && lezerocount > bezerocount)
						codepage = ucr::CP_UCS2LE;
					else if ((becrorlf == 0 && size < 512 || (becrorlf > 0 && (size / becrorlf > 1024))) && lezerocount < bezerocount)
						codepage = ucr::CP_UCS2BE;
				}
			}
		}
		if (codepage == 20127 || codepage == 65000)
			return defcodepage;
		return codepage;
	}

	std::vector<CodePageInfo> enumCodePages()
	{
		std::vector<CodePageInfo> cpinfo;
		IEnumCodePage *pEnumCodePage = nullptr;
		ULONG ccpInfo;
		HRESULT hr = m_pmlang->EnumCodePages(MIMECONTF_SAVABLE_BROWSER | MIMECONTF_VALID | MIMECONTF_VALID_NLS, 0, &pEnumCodePage);
		if (FAILED(hr))
			return cpinfo;
		auto pcpInfo = std::make_unique<MIMECPINFO[]>(256);
		if (FAILED(pEnumCodePage->Next(256, pcpInfo.get(), &ccpInfo)))
			return cpinfo;

		cpinfo.resize(ccpInfo);
		for (int i = 0; i < (int)ccpInfo; i++)
		{
			cpinfo[i].codepage = pcpInfo[i].uiCodePage;
			cpinfo[i].desc = ucr::toTString(pcpInfo[i].wszDescription);
		}

		return cpinfo;
	}

	bool getCodepageFromCharsetName(const String& sCharsetName, int& codepage)
	{
		MIMECSETINFO charsetInfo;
		BSTR bstrCharsetName = SysAllocString(ucr::toUTF16(sCharsetName).c_str());
		HRESULT hr = m_pmlang->GetCharsetInfo(bstrCharsetName, &charsetInfo);
		SysFreeString(bstrCharsetName);
		if (FAILED(hr))
			return false;
		codepage = charsetInfo.uiInternetEncoding;
		return true;
	}

	bool getCodepageDescription(int codepage, String& sDescription)
	{
		wchar_t szDescription[256];
		HRESULT hr = m_pmlang->GetCodePageDescription(codepage, GetSystemDefaultLangID(), szDescription, sizeof(szDescription)/sizeof(wchar_t));
		if (FAILED(hr))
			return false;

		sDescription = ucr::toTString(szDescription);
		return true;
	}

	bool isValidCodepage(int codepage)
	{
		String sDesc;
		return getCodepageDescription(codepage, sDesc);
	}

	bool getCodePageInfo(int codepage, CodePageInfo *pCodePageInfo)
	{
		MIMECPINFO mcpi = {0};
		HRESULT hr = m_pmlang->GetCodePageInfo(codepage, GetSystemDefaultLangID(), &mcpi);
		if (FAILED(hr))
			return false;
		pCodePageInfo->proportionalFont = ucr::toTString(mcpi.wszProportionalFont);
		pCodePageInfo->fixedWidthFont = ucr::toTString(mcpi.wszFixedWidthFont);
		pCodePageInfo->bGDICharset = mcpi.bGDICharset;
		return true;
	}

};

#ifdef _MSC_VER
__declspec(thread) static IExconverter *m_pexconv = nullptr;
#else
static __thread IExconverter *m_pexconv = nullptr;
#endif
static std::list<std::unique_ptr<IExconverter> > m_exconv_list;
static Poco::FastMutex m_mutex;

IExconverter *Exconverter::getInstance()
{
	if (m_pexconv != nullptr)
	{
		m_pexconv->clearCookie();
		return m_pexconv;
	}
	CExconverterMLang *pexconv = new CExconverterMLang();
	if (!pexconv->initialize())
	{
		delete pexconv;
		return nullptr;
	}
	m_pexconv = pexconv;
	Poco::FastMutex::ScopedLock lock(m_mutex);
	m_exconv_list.emplace_back(m_pexconv);
	return m_pexconv;
}

</file>

<file path="Winmerge-Src/Src/Common/ExConverter.h">
#pragma once

#include "UnicodeString.h"
#include <vector>

struct CodePageInfo
{
	int codepage = 0;
	String desc;
	String proportionalFont;
	String fixedWidthFont;
	char bGDICharset = 0;
};

struct IExconverter
{
	virtual ~IExconverter() {}
	virtual bool initialize() = 0;
	virtual bool convert(int srcCodepage, int dstCodepage, const unsigned char * src, size_t * srcbytes, unsigned char * dest, size_t * destbytes) = 0;
	virtual bool convertFromUnicode(int dstCodepage, const wchar_t * src, size_t * srcchars, char * dest, size_t *destbytes) = 0;
	virtual bool convertToUnicode(int srcCodepage, const char * src, size_t * srcbytes, wchar_t * dest, size_t *destchars) = 0;
	virtual void clearCookie() = 0;
	virtual int detectInputCodepage(int autodetectType, int defcodepage, const char *data, size_t size) = 0;
	virtual std::vector<CodePageInfo> enumCodePages() = 0;
	virtual bool getCodepageFromCharsetName(const String& sCharsetName, int& codepage) = 0;
	virtual bool getCodepageDescription(int codepage, String& sCharsetName) = 0;
	virtual bool isValidCodepage(int codepage) = 0;
	virtual bool getCodePageInfo(int codePage, CodePageInfo *pCodePageInfo) = 0;
};

struct Exconverter
{
	static IExconverter *getInstance();
};
</file>

<file path="Winmerge-Src/Src/Common/IatHook.h">
/* This file is a modified version of IatHook.h from the win32-darkmode project
 * (https://github.com/ysc3839/win32-darkmode)
 * Original file: https://github.com/ysc3839/win32-darkmode/blob/master/win32-darkmode/IatHook.h
 */
// This file contains code from
// https://github.com/stevemk14ebr/PolyHook_2_0/blob/master/sources/IatHook.cpp
// which is licensed under the MIT License.
// See PolyHook_2_0-LICENSE for more information.

#pragma once

#if (NTDDI_VERSION <= NTDDI_WINXP)

typedef struct _IMAGE_DELAYLOAD_DESCRIPTOR {
	union {
		DWORD AllAttributes;
		struct {
			DWORD RvaBased : 1;
			DWORD ReservedAttributes : 31;
		} DUMMYSTRUCTNAME;
	} Attributes;
	DWORD DllNameRVA;
	DWORD ModuleHandleRVA;
	DWORD ImportAddressTableRVA;
	DWORD ImportNameTableRVA;
	DWORD BoundImportAddressTableRVA;
	DWORD UnloadInformationTableRVA;
	DWORD TimeDateStamp;
} IMAGE_DELAYLOAD_DESCRIPTOR, *PIMAGE_DELAYLOAD_DESCRIPTOR;

#endif

template <typename T, typename T1, typename T2>
constexpr T RVA2VA(T1 base, T2 rva)
{
	return reinterpret_cast<T>(reinterpret_cast<ULONG_PTR>(base) + rva);
}

template <typename T>
constexpr T DataDirectoryFromModuleBase(void *moduleBase, size_t entryID)
{
	auto dosHdr = reinterpret_cast<PIMAGE_DOS_HEADER>(moduleBase);
	auto ntHdr = RVA2VA<PIMAGE_NT_HEADERS>(moduleBase, dosHdr->e_lfanew);
	auto dataDir = ntHdr->OptionalHeader.DataDirectory;
	return RVA2VA<T>(moduleBase, dataDir[entryID].VirtualAddress);
}

PIMAGE_THUNK_DATA FindAddressByName(void *moduleBase, PIMAGE_THUNK_DATA impName, PIMAGE_THUNK_DATA impAddr, const char *funcName)
{
	for (; impName->u1.Ordinal; ++impName, ++impAddr)
	{
		if (IMAGE_SNAP_BY_ORDINAL(impName->u1.Ordinal))
			continue;

		auto import = RVA2VA<PIMAGE_IMPORT_BY_NAME>(moduleBase, impName->u1.AddressOfData);
		if (strcmp(reinterpret_cast<char *>(import->Name), funcName) != 0)
			continue;
		return impAddr;
	}
	return nullptr;
}

PIMAGE_THUNK_DATA FindAddressByOrdinal(void *moduleBase, PIMAGE_THUNK_DATA impName, PIMAGE_THUNK_DATA impAddr, uint16_t ordinal)
{
	for (; impName->u1.Ordinal; ++impName, ++impAddr)
	{
		if (IMAGE_SNAP_BY_ORDINAL(impName->u1.Ordinal) && IMAGE_ORDINAL(impName->u1.Ordinal) == ordinal)
			return impAddr;
	}
	return nullptr;
}

PIMAGE_THUNK_DATA FindIatThunkInModule(void *moduleBase, const char *dllName, const char *funcName)
{
	auto imports = DataDirectoryFromModuleBase<PIMAGE_IMPORT_DESCRIPTOR>(moduleBase, IMAGE_DIRECTORY_ENTRY_IMPORT);
	for (; imports->Name; ++imports)
	{
		if (_stricmp(RVA2VA<LPCSTR>(moduleBase, imports->Name), dllName) != 0)
			continue;

		auto origThunk = RVA2VA<PIMAGE_THUNK_DATA>(moduleBase, imports->OriginalFirstThunk);
		auto thunk = RVA2VA<PIMAGE_THUNK_DATA>(moduleBase, imports->FirstThunk);
		return FindAddressByName(moduleBase, origThunk, thunk, funcName);
	}
	return nullptr;
}

PIMAGE_THUNK_DATA FindDelayLoadThunkInModule(void *moduleBase, const char *dllName, const char *funcName)
{
	auto imports = DataDirectoryFromModuleBase<PIMAGE_DELAYLOAD_DESCRIPTOR>(moduleBase, IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT);
	for (; imports->DllNameRVA; ++imports)
	{
		if (_stricmp(RVA2VA<LPCSTR>(moduleBase, imports->DllNameRVA), dllName) != 0)
			continue;

		auto impName = RVA2VA<PIMAGE_THUNK_DATA>(moduleBase, imports->ImportNameTableRVA);
		auto impAddr = RVA2VA<PIMAGE_THUNK_DATA>(moduleBase, imports->ImportAddressTableRVA);
		return FindAddressByName(moduleBase, impName, impAddr, funcName);
	}
	return nullptr;
}

PIMAGE_THUNK_DATA FindDelayLoadThunkInModule(void *moduleBase, const char *dllName, uint16_t ordinal)
{
	auto imports = DataDirectoryFromModuleBase<PIMAGE_DELAYLOAD_DESCRIPTOR>(moduleBase, IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT);
	for (; imports->DllNameRVA; ++imports)
	{
		if (_stricmp(RVA2VA<LPCSTR>(moduleBase, imports->DllNameRVA), dllName) != 0)
			continue;

		auto impName = RVA2VA<PIMAGE_THUNK_DATA>(moduleBase, imports->ImportNameTableRVA);
		auto impAddr = RVA2VA<PIMAGE_THUNK_DATA>(moduleBase, imports->ImportAddressTableRVA);
		return FindAddressByOrdinal(moduleBase, impName, impAddr, ordinal);
	}
	return nullptr;
}
</file>

<file path="Winmerge-Src/Src/Common/IMDITab.h">
#pragma once

#include <afxstr.h>

struct IMDITab
{
	virtual CString GetTooltipString() const = 0;
};

</file>

<file path="Winmerge-Src/Src/Common/IniOptionsMgr.cpp">
/**
 * @file IniOptionsMgr.cpp
 *
 * @brief Implementation of Ini file Options management class.
 *
 */

#include "pch.h"
#include "IniOptionsMgr.h"
#include <windows.h>
#include <process.h>
#include "OptionsMgr.h"

LPCWSTR lpAppName = TEXT("WinMerge");
LPCWSTR lpDefaultSection = TEXT("Defaults");

struct AsyncWriterThreadParams
{
	AsyncWriterThreadParams(const String& name, const varprop::VariantValue& value) : name(name), value(value) {}
	String name;
	varprop::VariantValue value;
};

class CIniOptionsMgr::IOHandler
{
public:
	IOHandler(const String& path) :
		  m_hThread(nullptr)
		, m_hEvent(nullptr)
		, m_dwThreadId(0)
		, m_dwQueueCount(0)
		, m_path(path)
	{
		m_hEvent = CreateEvent(nullptr, TRUE, FALSE, nullptr);
		if (m_hEvent)
		{
			m_hThread = reinterpret_cast<HANDLE>(
				_beginthreadex(nullptr, 0, AsyncWriterThreadProc, this, 0,
					reinterpret_cast<unsigned*>(&m_dwThreadId)));
			WaitForSingleObject(m_hEvent, INFINITE);
			CloseHandle(m_hEvent);
			m_hEvent = nullptr;
		}
	}

	~IOHandler()
	{
		for (;;)
		{
			::PostThreadMessage(m_dwThreadId, WM_QUIT, 0, 0);
			if (WaitForSingleObject(m_hThread, 1) != WAIT_TIMEOUT)
				break;
		}
	}

	std::map<String, String> Load(const String& iniFilePath) const
	{
		std::map<String, String> iniFileKeyValues = ReadIniFile(iniFilePath, lpAppName);

		// after reading the "WinMerge" section try to read the "Defaults" section; overwrite existing entries in "iniFileKeyValues" with the ones from the "Defaults" section
		std::map<String, String> iniFileKeyDefaultValues = ReadIniFile(iniFilePath, lpDefaultSection);
		for (auto& [key, strValue] : iniFileKeyDefaultValues)
			iniFileKeyValues.insert_or_assign(key, strValue);
		return iniFileKeyValues;
	}

	const String& GetPath() const { return m_path; }

	void WriteAsync(const String& name, const varprop::VariantValue& value)
	{
		auto* pParam = new AsyncWriterThreadParams(name, value);
		InterlockedIncrement(&m_dwQueueCount);
		if (!::PostThreadMessage(m_dwThreadId, WM_USER, (WPARAM)pParam, 0))
		{
			delete pParam;
			InterlockedDecrement(&m_dwQueueCount);
		}
	}

	void WriteKeyValue(const String& key, const String& value, const String& filename)
	{
		// https://learn.microsoft.com/en-us/answers/questions/578134/error-in-writeprivateprofilestring-function-when-j
		WritePrivateProfileString(_T("WinMerge"), key.c_str(),
			nullptr, filename.c_str());
		WritePrivateProfileString(_T("WinMerge"), key.c_str(),
			EscapeValue(value).c_str(), filename.c_str());
	}

	int WaitForQueueFlush()
	{
		int retVal = COption::OPT_OK;

		while (InterlockedCompareExchange(&m_dwQueueCount, 0, 0) != 0)
			Sleep(0);

		return retVal;
	}

	int SaveValueToFile(const String& name, const varprop::VariantValue& value)
	{
		BOOL retValReg = TRUE;
		int valType = value.GetType();
		int retVal = COption::OPT_OK;

		if (valType == varprop::VT_STRING)
		{
			String strVal = EscapeValue(value.GetString());
			LPCWSTR text = strVal.c_str();
			// https://learn.microsoft.com/en-us/answers/questions/578134/error-in-writeprivateprofilestring-function-when-j
			WritePrivateProfileString(lpAppName, name.c_str(), nullptr, m_path.c_str());
			retValReg = WritePrivateProfileString(lpAppName, name.c_str(), text, m_path.c_str());
		}
		else if (valType == varprop::VT_INT)
		{
			DWORD dwordVal = value.GetInt();
			String strVal = strutils::to_str(dwordVal);
			LPCWSTR text = strVal.c_str();
			retValReg = WritePrivateProfileString(lpAppName, name.c_str(), text, m_path.c_str());
		}
		else if (valType == varprop::VT_BOOL)
		{
			DWORD dwordVal = value.GetBool() ? 1 : 0;
			String strVal = strutils::to_str(dwordVal);
			LPCWSTR text = strVal.c_str();
			retValReg = WritePrivateProfileString(lpAppName, name.c_str(), text, m_path.c_str());
		}
		else if (valType == varprop::VT_NULL)
		{
			auto [strPath, strValueName] = SplitName(name);
			if (!strValueName.empty())
				retValReg = WritePrivateProfileString(lpAppName, name.c_str(), nullptr, m_path.c_str());
			else
			{
				auto iniFileMap = Load(m_path);
				for (auto& [key, value2] : iniFileMap)
				{
					if (key.find(strPath) == 0 && key.length() > strPath.length() && key[strPath.length()] == '/')
						retValReg = WritePrivateProfileString(lpAppName, key.c_str(), nullptr, m_path.c_str());
				}
			}
		}
		else
		{
			retVal = COption::OPT_UNKNOWN_TYPE;
		}
			
		if (!retValReg)
		{
			retVal = COption::OPT_ERR;
		}
		return retVal;
	}

	static unsigned __stdcall AsyncWriterThreadProc(void *pvThis)
	{
		CIniOptionsMgr::IOHandler *pThis = reinterpret_cast<CIniOptionsMgr::IOHandler *>(pvThis);
		MSG msg;
		BOOL bRet;
		// create message queue
		PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE);
		SetEvent(pThis->m_hEvent);
		while ((bRet = GetMessage(&msg, 0, 0, 0)) != 0)
		{
			auto* pParam = reinterpret_cast<AsyncWriterThreadParams *>(msg.wParam);
			if (msg.message == WM_USER && pParam)
			{
				pThis->SaveValueToFile(pParam->name, pParam->value);
				delete pParam;
				InterlockedDecrement(&pThis->m_dwQueueCount);
			}
		}
		return 0;
	}

private:
	String m_path;
	DWORD m_dwThreadId;
	DWORD m_dwQueueCount;
	HANDLE m_hThread;
	HANDLE m_hEvent;
};

CIniOptionsMgr::CIniOptionsMgr(const String& filePath)
	: m_serializing(true)
	, m_pIOHandler(std::make_unique<IOHandler>(filePath))
{
	m_iniFileKeyValues = m_pIOHandler->Load(filePath);
}

CIniOptionsMgr::~CIniOptionsMgr()
{
	m_pIOHandler.reset();
}

int CIniOptionsMgr::LoadValueFromBuf(const String& strName, const String& textValue, varprop::VariantValue& value)
{
	int retVal = COption::OPT_OK;
	int valType = value.GetType();
	if (valType == varprop::VT_STRING)
	{
		value.SetString(textValue);
		retVal = Set(strName, value);
	}
	else if (valType == varprop::VT_INT)
	{
		tchar_t* endptr = nullptr;
		DWORD val = static_cast<DWORD>(tc::tcstoll(textValue.c_str(), &endptr, 
			(textValue.length() >= 2 && textValue[1] == 'x') ? 16 : 10));
		value.SetInt(static_cast<int>(val));
		retVal = Set(strName, value);
	}
	else if (valType == varprop::VT_BOOL)
	{
		value.SetBool(textValue[0] == '1' ? true : false);
		retVal = Set(strName, value);
	}
	else
		retVal = COption::OPT_WRONG_TYPE;

	return retVal;
}

int CIniOptionsMgr::InitOption(const String& name, const varprop::VariantValue& defaultValue)
{
	// Check type & bail if null
	int valType = defaultValue.GetType();
	if (valType == varprop::VT_NULL)
		return COption::OPT_ERR;

	// If we're not loading & saving options, bail
	if (!m_serializing)
		return AddOption(name, defaultValue);

	// Actually save value into our in-memory options table
	int retVal = AddOption(name, defaultValue);

	// Update registry if successfully saved to in-memory table
	if (retVal == COption::OPT_OK)
	{
		// check if value exist
		bool found = m_iniFileKeyValues.find(name) != m_iniFileKeyValues.end();
		if (found)
		{
			String textValue = m_iniFileKeyValues[name];
			varprop::VariantValue value(defaultValue);
			retVal = LoadValueFromBuf(name, textValue, value);
		}
	}

	return retVal;
}

int CIniOptionsMgr::InitOption(const String& name, const String& defaultValue)
{
	varprop::VariantValue defValue;
	defValue.SetString(defaultValue);
	return InitOption(name, defValue);
}

int CIniOptionsMgr::InitOption(const String& name, const tchar_t* defaultValue)
{
	return InitOption(name, String(defaultValue));
}

int CIniOptionsMgr::InitOption(const String& name, int defaultValue, bool serializable)
{
	varprop::VariantValue defValue;
	int retVal = COption::OPT_OK;

	defValue.SetInt(defaultValue);
	if (serializable)
		retVal = InitOption(name, defValue);
	else
		AddOption(name, defValue);
	return retVal;
}

int CIniOptionsMgr::InitOption(const String& name, bool defaultValue)
{
	varprop::VariantValue defValue;
	defValue.SetBool(defaultValue);
	return InitOption(name, defValue);
}

int CIniOptionsMgr::SaveOption(const String& name)
{
	if (!m_serializing) return COption::OPT_OK;

	varprop::VariantValue value;
	int retVal = COption::OPT_OK;

	value = Get(name);
	int valType = value.GetType();
	if (valType == varprop::VT_NULL)
		retVal = COption::OPT_NOTFOUND;

	if (retVal == COption::OPT_OK)
		m_pIOHandler->WriteAsync(name, value);

	return retVal;
}

/**
 * @brief Set new value for option and save option to file
 */
int CIniOptionsMgr::SaveOption(const String& name, const varprop::VariantValue& value)
{
	int retVal = Set(name, value);
	if (retVal == COption::OPT_OK)
		retVal = SaveOption(name);
	return retVal;
}

/**
 * @brief Set new string value for option and save option to file
 */
int CIniOptionsMgr::SaveOption(const String& name, const String& value)
{
	varprop::VariantValue val;
	val.SetString(value);
	int retVal = Set(name, val);
	if (retVal == COption::OPT_OK)
		retVal = SaveOption(name);
	return retVal;
}

/**
 * @brief Set new string value for option and save option to file
 */
int CIniOptionsMgr::SaveOption(const String& name, const tchar_t* value)
{
	return SaveOption(name, String(value));
}

int CIniOptionsMgr::SaveOption(const String& name, int value)
{
	varprop::VariantValue val;
	val.SetInt(value);
	int retVal = Set(name, val);
	if (retVal == COption::OPT_OK)
		retVal = SaveOption(name);
	return retVal;
}

int CIniOptionsMgr::SaveOption(const String& name, bool value)
{
	varprop::VariantValue val;
	val.SetBool(value);
	int retVal = Set(name, val);
	if (retVal == COption::OPT_OK)
		retVal = SaveOption(name);
	return retVal;
}

int CIniOptionsMgr::RemoveOption(const String& name)
{
	int retVal = COption::OPT_OK;
	auto [strPath, strValueName] = SplitName(name);

	if (!strValueName.empty())
	{
		retVal = COptionsMgr::RemoveOption(name);
	}
	else
	{
		for (auto it = m_optionsMap.begin(); it != m_optionsMap.end(); )
		{
			const String& key = it->first;
			if (key.find(strPath) == 0 && key.length() > strPath.length() && key[strPath.length()] == '/')
			{
				m_iniFileKeyValues.erase(key);
				it = m_optionsMap.erase(it);
			}
			else
				++it;
		}
		retVal = COption::OPT_OK;
	}

	m_pIOHandler->WriteAsync(name, varprop::VariantValue());

	return retVal;
}

int CIniOptionsMgr::FlushOptions()
{
	return m_pIOHandler->WaitForQueueFlush();
}

int CIniOptionsMgr::ExportOptions(const String& filename, const bool bHexColor /*= false*/) const
{
	for (auto& [key, value] : m_iniFileKeyValues)
	{
		if (m_optionsMap.find(key) == m_optionsMap.end())
			m_pIOHandler->WriteKeyValue(key, value, filename);
	}
	return COptionsMgr::ExportOptions(filename, bHexColor);
}

int CIniOptionsMgr::ImportOptions(const String& filename)
{
	int retVal = COptionsMgr::ImportOptions(filename);
	auto iniFileMap = m_pIOHandler->Load(filename);
	for (auto& [key, value] : iniFileMap)
	{
		if (m_optionsMap.find(key) == m_optionsMap.end())
			m_pIOHandler->WriteKeyValue(key, value, m_pIOHandler->GetPath());
	}
	return retVal;
}

</file>

<file path="Winmerge-Src/Src/Common/IniOptionsMgr.h">
/**
 * @file IniOptionsMgr.h
 *
 * @brief Implementation of Ini file Options management class.
 *
 */
#pragma once

#include "OptionsMgr.h"

class COptionsMgr;

/**
 * @brief Ini-based implementation of OptionsMgr interface (q.v.).
 */
class CIniOptionsMgr : public COptionsMgr
{
public:
	explicit CIniOptionsMgr(const String& filePath);
	virtual ~CIniOptionsMgr();
	CIniOptionsMgr(const CIniOptionsMgr&) = delete;
	CIniOptionsMgr& operator=(const CIniOptionsMgr&) = delete;

	virtual int InitOption(const String& name, const varprop::VariantValue& defaultValue) override;
	virtual int InitOption(const String& name, const String& defaultValue) override;
	virtual int InitOption(const String& name, const tchar_t* defaultValue) override;
	virtual int InitOption(const String& name, int defaultValue, bool serializable = true) override;
	virtual int InitOption(const String& name, bool defaultValue) override;

	virtual int SaveOption(const String& name) override;
	virtual int SaveOption(const String& name, const varprop::VariantValue& value) override;
	virtual int SaveOption(const String& name, const String& value) override;
	virtual int SaveOption(const String& name, const tchar_t* value) override;
	virtual int SaveOption(const String& name, int value) override;
	virtual int SaveOption(const String& name, bool value) override;

	virtual int RemoveOption(const String& name) override;

	virtual int FlushOptions() override;

	virtual int ExportOptions(const String& filename, const bool bHexColor=false) const override;
	virtual int ImportOptions(const String& filename) override;

	virtual void SetSerializing(bool serializing = true) override { m_serializing = serializing; }

protected:
	int LoadValueFromBuf(const String& strName, const String& textValue, varprop::VariantValue& value);

private:
	bool m_serializing;
	std::map<String, String> m_iniFileKeyValues;
	class IOHandler;
	std::unique_ptr<IOHandler> m_pIOHandler;
};
</file>

<file path="Winmerge-Src/Src/Common/LanguageSelect.cpp">
/**
 * @file  LanguageSelect.cpp
 *
 * @brief Implements the Language Selection dialog class (which contains the language data)
 */

#include "StdAfx.h"
#include "LanguageSelect.h"
#include "BCMenu.h"
#include "Environment.h"
#include "paths.h"
#include "unicoder.h"
#include "cio.h"

// Escaped character constants in range 0x80-0xFF are interpreted in current codepage
// Using C locale gets us direct mapping to Unicode codepoints
#pragma setlocale("C")

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/** @brief Relative path to WinMerge executable for lang files. */
static const tchar_t szRelativePath[] = _T("Languages");

static wchar_t *EatPrefix(wchar_t *text, const wchar_t *prefix);
static void unslash(std::wstring &s);
static HANDLE NTAPI FindFile(HANDLE h, const tchar_t* path, WIN32_FIND_DATA *fd);

/**
 * @brief A class holding information about language file.
 */
class LangFileInfo
{
public:
	LANGID id; /**< Language ID. */

	static LANGID LangId(const char *lang, const char *sublang);
	
	/**
	 * A constructor taking a language id as parameter.
	 * @param [in] id Language ID to use.
	 */
	explicit LangFileInfo(LANGID id): id(id) { };
	
	explicit LangFileInfo(const tchar_t* path);
	String GetString(LCTYPE type) const;

private:
	struct rg
	{
		LANGID id;
		const char *lang;
	};
	static const struct rg rg[];
};

/**
 * @brief An array holding language IDs and names.
 */
const struct LangFileInfo::rg LangFileInfo::rg[] =
{
	{
		LANG_AFRIKAANS,		"AFRIKAANS\0"
	},
	{
		LANG_ALBANIAN,		"ALBANIAN\0"
	},
	{
		LANG_ARABIC,		"ARABIC\0"						"SAUDI_ARABIA\0"
															"IRAQ\0"
															"EGYPT\0"
															"LIBYA\0"
															"ALGERIA\0"
															"MOROCCO\0"
															"TUNISIA\0"
															"OMAN\0"
															"YEMEN\0"
															"SYRIA\0"
															"JORDAN\0"
															"LEBANON\0"
															"KUWAIT\0"
															"UAE\0"
															"BAHRAIN\0"
															"QATAR\0"
	},
	{
		LANG_ARMENIAN,		"ARMENIAN\0"
	},
	{
		LANG_ASSAMESE,		"ASSAMESE\0"
	},
	{
		LANG_AZERI,			"AZERI\0"						"LATIN\0"
															"CYRILLIC\0"
	},
	{
		LANG_BASQUE,		"BASQUE\0"
	},
	{
		LANG_BELARUSIAN,	"BELARUSIAN\0"
	},
	{
		LANG_BENGALI,		"BENGALI\0"
	},
	{
		LANG_BULGARIAN,		"BULGARIAN\0"
	},
	{
		LANG_CATALAN,		"CATALAN\0"
	},
	{
		LANG_CHINESE,		"CHINESE\0"						"TRADITIONAL\0"
															"SIMPLIFIED\0"
															"HONGKONG\0"
															"SINGAPORE\0"
															"MACAU\0"
	},
	{
		LANG_CORSICAN,		"CORSICAN\0"
	},
	{
		LANG_CROATIAN,		"CROATIAN\0"
	},
	{
		LANG_CZECH,			"CZECH\0"
	},
	{
		LANG_DANISH,		"DANISH\0"
	},
	{
		LANG_DIVEHI,		"DIVEHI\0"
	},
	{
		MAKELANGID(LANG_DUTCH, SUBLANG_DUTCH),				"DUTCH\0"
															"BELGIAN\0"
	},
	{
		LANG_ENGLISH,		"ENGLISH\0"						"US\0"
															"UK\0"
															"AUS\0"
															"CAN\0"
															"NZ\0"
															"EIRE\0"
															"SOUTH_AFRICA\0"
															"JAMAICA\0"
															"CARIBBEAN\0"
															"BELIZE\0"
															"TRINIDAD\0"
															"ZIMBABWE\0"
															"PHILIPPINES\0"
	},
	{
		LANG_ESTONIAN,		"ESTONIAN\0"
	},
	{
		LANG_FAEROESE,		"FAEROESE\0"
	},
	{
		LANG_FARSI,			"FARSI\0"
	},
	{
		LANG_FINNISH,		"FINNISH\0"
	},
	{
		MAKELANGID(LANG_FRENCH, SUBLANG_FRENCH),			"FRENCH\0"
															"BELGIAN\0"
															"CANADIAN\0"
															"SWISS\0"
															"LUXEMBOURG\0"
															"MONACO\0"
	},
	{
		LANG_GALICIAN,		"GALICIAN\0"
	},
	{
		LANG_GEORGIAN,		"GEORGIAN\0"
	},
	{
		MAKELANGID(LANG_GERMAN, SUBLANG_GERMAN),			"GERMAN\0"
															"SWISS\0"
															"AUSTRIAN\0"
															"LUXEMBOURG\0"
															"LIECHTENSTEIN"
	},
	{
		LANG_GREEK,			"GREEK\0"
	},
	{
		LANG_GUJARATI,		"GUJARATI\0"
	},
	{
		LANG_HEBREW,		"HEBREW\0"						"ISRAEL\0"
	},
	{
		LANG_HINDI,			"HINDI\0"
	},
	{
		LANG_HUNGARIAN,		"HUNGARIAN\0"
	},
	{
		LANG_ICELANDIC,		"ICELANDIC\0"
	},
	{
		LANG_INDONESIAN,	"INDONESIAN\0"
	},
	{
		MAKELANGID(LANG_ITALIAN, SUBLANG_ITALIAN),			"ITALIAN\0"
															"SWISS\0"
	},
	{
		LANG_JAPANESE,		"JAPANESE\0"
	},
	{
		LANG_KANNADA,		"KANNADA\0"
	},
	{
		MAKELANGID(LANG_KASHMIRI, SUBLANG_DEFAULT),			"KASHMIRI\0"
															"SASIA\0"
	},
	{
		LANG_KAZAK,			"KAZAK\0"
	},
	{
		LANG_KONKANI,		"KONKANI\0"
	},
	{
		MAKELANGID(LANG_KOREAN, SUBLANG_KOREAN),			"KOREAN\0"
	},
	{
		LANG_KYRGYZ,		"KYRGYZ\0"
	},
	{
		LANG_LATVIAN,		"LATVIAN\0"
	},
	{
		MAKELANGID(LANG_LITHUANIAN, SUBLANG_LITHUANIAN),	"LITHUANIAN\0"
	},
	{
		LANG_MACEDONIAN,	"MACEDONIAN\0"
	},
	{
		LANG_MALAY,			"MALAY\0"						"MALAYSIA\0"
															"BRUNEI_DARUSSALAM\0"
	},
	{
		LANG_MALAYALAM,		"MALAYALAM\0"
	},
	{
		LANG_MANIPURI,		"MANIPURI\0"
	},
	{
		LANG_MARATHI,		"MARATHI\0"
	},
	{
		LANG_MONGOLIAN,		"MONGOLIAN\0"
	},
	{
		MAKELANGID(LANG_NEPALI, SUBLANG_DEFAULT),			"NEPALI\0"
															"INDIA\0"
	},
	{
		LANG_NORWEGIAN,		"NORWEGIAN\0"					"BOKMAL\0"
															"NYNORSK\0"
	},
	{
		LANG_ORIYA,			"ORIYA\0"
	},
	{
		LANG_POLISH,		"POLISH\0"
	},
	{
		MAKELANGID(LANG_PORTUGUESE, SUBLANG_PORTUGUESE),	"PORTUGUESE\0"
															"BRAZILIAN\0"
	},
	{
		LANG_PUNJABI,		"PUNJABI\0"
	},
	{
		LANG_ROMANIAN,		"ROMANIAN\0"
	},
	{
		LANG_RUSSIAN,		"RUSSIAN\0"
	},
	{
		LANG_SANSKRIT,		"SANSKRIT\0"
	},
	{
		MAKELANGID(LANG_SERBIAN, SUBLANG_DEFAULT),			"SERBIAN\0"
															"LATIN\0"
															"CYRILLIC\0"
	},
	{
		LANG_SINDHI,		"SINDHI\0"
	},
	{
		LANG_SINHALESE,		"SINHALESE\0"
	},
	{
		LANG_SLOVAK,		"SLOVAK\0"
	},
	{
		LANG_SLOVENIAN,		"SLOVENIAN\0"
	},
	{
		MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH),			"SPANISH\0"
															"MEXICAN\0"
															"MODERN\0"
															"GUATEMALA\0"
															"COSTA_RICA\0"
															"PANAMA\0"
															"DOMINICAN_REPUBLIC\0"
															"VENEZUELA\0"
															"COLOMBIA\0"
															"PERU\0"
															"ARGENTINA\0"
															"ECUADOR\0"
															"CHILE\0"
															"URUGUAY\0"
															"PARAGUAY\0"
															"BOLIVIA\0"
															"EL_SALVADOR\0"
															"HONDURAS\0"
															"NICARAGUA\0"
															"PUERTO_RICO\0"
	},
	{
		LANG_SWAHILI,		"SWAHILI\0"
	},
	{
		MAKELANGID(LANG_SWEDISH, SUBLANG_SWEDISH),			"SWEDISH\0"
															"FINLAND\0"
	},
	{
		LANG_SYRIAC,		"SYRIAC\0"
	},
	{
		LANG_TAMIL,			"TAMIL\0"						"INDIA\0"
															"SRI_LANKA\0"
	},
	{
		LANG_TATAR,			"TATAR\0"
	},
	{
		LANG_TELUGU,		"TELUGU\0"
	},
	{
		LANG_THAI,			"THAI\0"
	},
	{
		LANG_TURKISH,		"TURKISH\0"
	},
	{
		LANG_UKRAINIAN,		"UKRAINIAN\0"
	},
	{
		LANG_URDU,			"URDU\0"						"PAKISTAN\0"
															"INDIA\0"
	},
	{
		LANG_UZBEK,			"UZBEK\0"						"LATIN\0"
															"CYRILLIC\0"
	},
	{
		LANG_VIETNAMESE,	"VIETNAMESE\0"
	},
};

/**
 * @brief Get a language ID for given language + sublanguage.
 * @param [in] lang Language name.
 * @param [in] sublang Sub language name.
 * @return Language ID.
 */
LANGID LangFileInfo::LangId(const char *lang, const char *sublang)
{
	// binary search the array for passed in lang
	size_t lower = 0;
	size_t upper = std::size(rg);
	while (lower < upper)
	{
		size_t match = (upper + lower) >> 1;
		int cmp = strcmp(rg[match].lang, lang);
		if (cmp >= 0)
			upper = match;
		if (cmp <= 0)
			lower = match + 1;
	}
	if (lower <= upper)
		return 0;
	LANGID baseid = rg[upper].id;
	// figure out sublang
	if ((baseid & ~0x3ff) && *sublang == '\0')
		return baseid;
	LANGID id = PRIMARYLANGID(baseid);
	if (0 == strcmp(sublang, "DEFAULT"))
		return MAKELANGID(id, SUBLANG_DEFAULT);
	const char *sub = rg[upper].lang;
	do
	{
		do
		{
			id += MAKELANGID(0, 1);
		} while (id == baseid);
		sub += strlen(sub) + 1;
		if (0 == strcmp(sublang, sub))
			return id;
	} while (*sub);
	return 0;
}

/**
 * @brief A constructor taking a path to language file as parameter.
 * @param [in] path Full path to the language file.
 */
LangFileInfo::LangFileInfo(const tchar_t* path)
: id(0)
{
	FILE *f;
	if (cio::tfopen_s(&f, path, _T("r,ccs=utf-8")) == 0 && f)
	{
		wchar_t buf[1024 + 1];
		while (fgetws(buf, static_cast<int>(std::size(buf)) - 1, f) != nullptr)
		{
			int i = 0;
			wcscat_s(buf, L"1");
			swscanf_s(buf, L"msgid \" LANG_ENGLISH , SUBLANG_ENGLISH_US \" %d", &i);
			if (i)
			{
				if (fgetws(buf, static_cast<int>(std::size(buf)), f) != nullptr)
				{
					wchar_t *lang = wcsstr(buf, L"LANG_");
					wchar_t *sublang = wcsstr(buf, L"SUBLANG_");
					wchar_t *langNext = nullptr;
					wchar_t *sublangNext = nullptr;
					if (lang && sublang)
					{
						wcstok_s(lang, L",\" \t\r\n", &langNext);
						wcstok_s(sublang, L",\" \t\r\n", &sublangNext);
						lang += std::size("LANG");
						sublang += std::size("SUBLANG");
						if (0 != wcscmp(sublang, L"DEFAULT"))
						{
							sublang = EatPrefix(sublang, lang);
							if (sublang && *sublang)
								sublang = EatPrefix(sublang, L"_");
						}
						if (sublang)
							id = LangId(ucr::toUTF8(lang).c_str(), ucr::toUTF8(sublang).c_str());
					}
				}
				break;
			}
		}
		fclose(f);
	}
}

String LangFileInfo::GetString(LCTYPE type) const
{
	String s;
	if (int cch = GetLocaleInfo(id, type, 0, 0))
	{
		s.resize(cch - 1);
		GetLocaleInfo(id, type, &*s.begin(), cch);
	}
	return s;
}

static HANDLE NTAPI FindFile(HANDLE h, const tchar_t* path, WIN32_FIND_DATA *fd)
{
	if (h == INVALID_HANDLE_VALUE)
	{
		h = FindFirstFile(path, fd);
	}
	else if (fd->dwFileAttributes == INVALID_FILE_ATTRIBUTES || !FindNextFile(h, fd))
	{
		FindClose(h);
		h = INVALID_HANDLE_VALUE;
	}
	return h;
}

/////////////////////////////////////////////////////////////////////////////
// CLanguageSelect dialog

/** @brief Default English language. */
const WORD wSourceLangId = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);

CLanguageSelect::CLanguageSelect()
: m_wCurLanguage(wSourceLangId)
{
	SetThreadLocale(MAKELCID(m_wCurLanguage, SORT_DEFAULT));
}

/**
 * @brief Remove prefix from the string.
 * @param [in] text String from which to jump over prefix.
 * @param [in] prefix Prefix string to jump over.
 * @return String without the prefix.
 * @note Function returns pointer to original string,
 *  it does not allocate a new string.
 */
static wchar_t *EatPrefix(wchar_t *text, const wchar_t *prefix)
{
	if (size_t len = wcslen(prefix))
		if (_memicmp(text, prefix, len * sizeof(wchar_t)) == 0)
			return text + len;
	return 0;
}

/**
 * @brief Convert C style \\nnn, \\r, \\n, \\t etc into their indicated characters.
 * @param [in,out] s String to convert.
 */
static void unslash(std::wstring &s)
{
	wchar_t *p = &*s.begin();
	wchar_t *q = p;
	wchar_t c = {};
	do
	{
		wchar_t *r = q + 1;
		switch (c = *q)
		{
		case '\\':
			switch (c = *r++)
			{
			case 'a':
				c = '\a';
				break;
			case 'b':
				c = '\b';
				break;
			case 'f':
				c = '\f';
				break;
			case 'n':
				c = '\n';
				break;
			case 'r':
				c = '\r';
				break;
			case 't':
				c = '\t';
				break;
			case 'v':
				c = '\v';
				break;
			case 'x':
				*p = (wchar_t)wcstol(r, &q, 16);
				break;
			default:
				*p = (wchar_t)wcstol(r - 1, &q, 8);
				break;
			}
			if (q >= r)
				break;
			[[fallthrough]];
		default:
			*p = c;
			q = r;
		}
		++p;
	} while (c != '\0');
	s.resize(p - 1 - &*s.begin());
}

/**
 * @brief Load language.file
 * @param [in] wLangId 
 * @return `true` on success, `false` otherwise.
 */
bool CLanguageSelect::LoadLanguageFile(LANGID wLangId, bool bShowError /*= false*/)
{
	String strPath = GetFileName(wLangId);
	if (strPath.empty())
		return false;

	wchar_t buf[1024];
	std::wstring *ps = nullptr;
	std::wstring msgctxt;
	std::wstring msgid;
	FILE *f;
	if (cio::tfopen_s(&f, strPath, _T("r,ccs=UTF-8")) != 0)
	{
		if (bShowError)
		{
			String str = _T("Failed to load ") + strPath;
			AfxMessageBox(str.c_str(), MB_ICONSTOP);
		}
		return false;
	}
	ps = nullptr;
	std::wstring format;
	std::wstring msgstr;
	std::wstring directive;
	auto addToMap = [&]() {
		ps = nullptr;
		if (!msgctxt.empty())
			unslash(msgctxt);
		if (!msgid.empty())
			unslash(msgid);
		if (msgstr.empty())
			msgstr = msgid;
		unslash(msgstr);
		if (!msgid.empty())
		{
			if (msgctxt.empty())
				m_map_msgid_to_msgstr.insert_or_assign(msgid, msgstr);
			else
				m_map_msgid_to_msgstr.insert_or_assign(L"\x01\"" + msgctxt + L"\"" + msgid, msgstr);
		}
		msgctxt.erase();
		msgid.erase();
		msgstr.erase();
	};
	while (fgetws(buf, static_cast<int>(std::size(buf)), f) != nullptr)
	{
		if (wchar_t *p1 = EatPrefix(buf, L"#,"))
		{
			format = p1;
			format.erase(0, format.find_first_not_of(L" \t\r\n"));
			format.erase(format.find_last_not_of(L" \t\r\n") + 1);
		}
		else if (wchar_t *p2 = EatPrefix(buf, L"#."))
		{
			directive = p2;
			directive.erase(0, directive.find_first_not_of(L" \t\r\n"));
			directive.erase(directive.find_last_not_of(L" \t\r\n") + 1);
		}
		else if (EatPrefix(buf, L"msgctxt "))
		{
			ps = &msgctxt;
		}
		else if (EatPrefix(buf, L"msgid "))
		{
			ps = &msgid;
		}
		else if (EatPrefix(buf, L"msgstr "))
		{
			ps = &msgstr;
		}
		if (ps != nullptr)
		{
			wchar_t *p = wcschr(buf, '"');
			wchar_t *q = wcsrchr(buf, '"');
			if (std::wstring::size_type n = q - p)
			{
				ps->append(p + 1, n - 1);
			}
			else
			{
				addToMap();
			}
		}
	}
	if (ps != nullptr)
		addToMap();
	fclose(f);
	return true;
}

/**
 * @brief Set UI language.
 * @param [in] wLangId 
 * @return `true` on success, `false` otherwise.
 */
bool CLanguageSelect::SetLanguage(LANGID wLangId, bool bShowError /*= false*/)
{
	if (wLangId == 0)
		return false;
	if (m_wCurLanguage == wLangId)
		return true;
	m_map_msgid_to_msgstr.clear();
	if (wLangId != wSourceLangId)
	{
		if (!LoadLanguageFile(wLangId, bShowError))
			wLangId = wSourceLangId;
	}
	m_wCurLanguage = wLangId;
	SetThreadLocale(MAKELCID(m_wCurLanguage, SORT_DEFAULT));
#ifdef _WIN64
	SetThreadUILanguage(wLangId);
#endif
	return true;
}

/**
 * @brief Get a language file for the specified language ID.
 * This function gets a language file name for the given language ID. Language
 * files are currently named as [languagename].po.
 * @param [in] wLangId Language ID.
 * @return Language filename, or empty string if no file for language found.
 */
String CLanguageSelect::GetFileName(LANGID wLangId) const
{
	String filename;
	String path = paths::ConcatPath(env::GetProgPath(), szRelativePath);
	String pattern = paths::ConcatPath(path, _T("*.po"));
	WIN32_FIND_DATA ff;
	HANDLE h = INVALID_HANDLE_VALUE;
	while ((h = FindFile(h, pattern.c_str(), &ff)) != INVALID_HANDLE_VALUE)
	{
		filename = paths::ConcatPath(path, ff.cFileName);
		LangFileInfo lfi(filename.c_str());
		if (lfi.id == wLangId)
			ff.dwFileAttributes = INVALID_FILE_ATTRIBUTES; // terminate loop
		else
			filename.erase();
	}
	return filename;
}

/////////////////////////////////////////////////////////////////////////////
// CLanguageSelect commands

bool CLanguageSelect::TranslateString(const std::wstring& msgid, std::wstring &s) const
{
	if (m_map_msgid_to_msgstr.find(msgid) != m_map_msgid_to_msgstr.end())
	{
		s = m_map_msgid_to_msgstr.at(msgid);
		return true;
	}
	if (msgid.length() > 2 && msgid[0] == '\x01' && msgid[1] == '"')
	{
		size_t pos = msgid.find('"', 2);
		if (pos != std::wstring::npos)
		{
			s = msgid.substr(pos + 1);
			return true;
		}
	}
	s = msgid;
	return false;
}

bool CLanguageSelect::TranslateString(const std::string& msgid, String& s) const
{
	bool result = TranslateString(std::wstring(msgid.begin(), msgid.end()), s);
	return result;
}

void CLanguageSelect::SetIndicators(CStatusBar &sb, const UINT *rgid, int n) const
{
	HGDIOBJ hf = (HGDIOBJ)sb.SendMessage(WM_GETFONT);
	CClientDC dc(nullptr);
	if (hf != nullptr)
		hf = dc.SelectObject(hf);
	if (n)
		sb.SetIndicators(0, n);
	else
		n = sb.m_nCount;
	int cx = ::GetSystemMetrics(SM_CXSCREEN) / 4;	// default to 1/4 the screen width
	UINT style = SBPS_STRETCH | SBPS_NOBORDERS;		// first pane is stretchy
	for (int i = 0 ; i < n ; ++i)
	{
		UINT id = rgid ? rgid[i] : sb.GetItemID(i);
		if (id >= ID_INDICATOR_EXT)
		{
			String text = LoadString(id);
			int cx1 = dc.GetTextExtent(text.c_str(), static_cast<int>(text.length())).cx;
			sb.SetPaneInfo(i, id, style | SBPS_DISABLED, cx1);
			sb.SetPaneText(i, text.c_str(), FALSE);
		}
		else if (rgid)
		{
			sb.SetPaneInfo(i, 0, style, cx);
		}
		style = 0;
	}
	if (hf != nullptr)
		dc.SelectObject(hf);
	// Send WM_SIZE to get pane rectangles right
	RECT rect;
	sb.GetClientRect(&rect);
	sb.SendMessage(WM_SIZE, 0, MAKELPARAM(rect.right, rect.bottom));
}

void CLanguageSelect::TranslateMenu(HMENU h) const
{
	BCMenu* pBCMenu = dynamic_cast<BCMenu*>(CMenu::FromHandle(h));
	int i = ::GetMenuItemCount(h);
	while (i > 0)
	{
		--i;
		MENUITEMINFO mii = {0};
#if(WINVER >= 0x0500)
		mii.cbSize = sizeof mii - sizeof HBITMAP;
#else
		mii.cbSize = sizeof mii;
#endif
		mii.fMask = MIIM_STATE|MIIM_ID|MIIM_SUBMENU|MIIM_DATA;
		::GetMenuItemInfo(h, i, TRUE, &mii);
		if (mii.hSubMenu)
		{
			TranslateMenu(mii.hSubMenu);
			mii.wID = static_cast<UINT>(reinterpret_cast<uintptr_t>(mii.hSubMenu));
		}
		BCMenuData *pItemData = reinterpret_cast<BCMenuData *>(mii.dwItemData);
		if (pItemData)
		{
			if (LPCWSTR text = pItemData->GetWideString())
			{
				std::wstring s;
				if (TranslateString(text, s))
					pItemData->SetWideString(s.c_str());
			}
		}
		wchar_t text[80];
		if (::GetMenuStringW(h, i, text, static_cast<int>(std::size(text)), MF_BYPOSITION))
		{
			std::wstring s;
			if (TranslateString(text, s))
			{
				if (pBCMenu && !pItemData)
					pBCMenu->SetMenuText(i, s.c_str(), MF_BYPOSITION);
				::ModifyMenuW(h, i, mii.fState | MF_BYPOSITION, mii.wID, s.c_str());
			}
		}
	}
}

void CLanguageSelect::TranslateDialog(HWND h) const
{
	UINT gw = GW_CHILD;
	do
	{
		wchar_t text[512];
		::GetWindowTextW(h, text, static_cast<int>(std::size(text)));
		std::wstring s;
		if (TranslateString(text, s))
			::SetWindowTextW(h, s.c_str());
		h = ::GetWindow(h, gw);
		gw = GW_HWNDNEXT;
	} while (h != nullptr);
}

void CLanguageSelect::RetranslateDialog(HWND h, const tchar_t *name) const
{
	typedef struct
	{
		WORD dlgVer;
		WORD signature;
		DWORD helpID;
		DWORD exStyle;
		DWORD style;
		WORD cDlgItems;
		short x;
		short y;
		short cx;
		short cy;
	} DLGTEMPLATEEX;

	typedef struct
	{
		DWORD helpID;
		DWORD exStyle;
		DWORD style;
		short x;
		short y;
		short cx;
		short cy;
		DWORD id;
	} DLGITEMTEMPLATEEX;

	auto loadDialogResource = [](HMODULE hModule, const tchar_t *name) -> DLGTEMPLATEEX *
	{
		if (HRSRC hFindRes = FindResource(hModule, name, RT_DIALOG))
		{
			if (HGLOBAL hLoadRes = LoadResource(hModule, hFindRes))
			{
				if (LPVOID q = LockResource(hLoadRes))
				{
					return reinterpret_cast<DLGTEMPLATEEX *>(q);
				}
			}
		}
		return nullptr;
	};

	auto skip = [](const WORD* &pw)
	{
		if (*pw == static_cast<WORD>(-1)) pw += 2; else { while (*pw++); };
	};

	auto findFirstDlgItem = [&skip](const DLGTEMPLATEEX *pTemplate) -> const DLGITEMTEMPLATEEX *
	{
		const WORD *pw = reinterpret_cast<const WORD *>(pTemplate) + 13;

		skip(pw); // Skip menu name string or ordinal
		skip(pw); // Skip class name string or ordinal
		while (*pw++);          // Skip caption string
		if (pTemplate->style & DS_SETFONT)
		{
			pw += 3;
			while (*pw++);
		}
		return reinterpret_cast<const DLGITEMTEMPLATEEX *>(
			reinterpret_cast<WORD*>((reinterpret_cast<DWORD_PTR>(pw) + 3) & ~DWORD_PTR(3))); // DWORD align
	};

	auto findNextDlgItem = [&skip](const DLGITEMTEMPLATEEX *pItem) -> const DLGITEMTEMPLATEEX * {
		const WORD *pw = reinterpret_cast<const WORD *>(pItem);
		pw += sizeof(DLGITEMTEMPLATEEX) / sizeof(WORD);

		skip(pw); // Skip class name string or ordinal
		skip(pw);  // Skip text string or ordinal

		WORD cbExtra = *reinterpret_cast<const WORD*>(pw);      // Skip extra data
		pw += 1 + cbExtra / sizeof(WORD);
		return reinterpret_cast<const DLGITEMTEMPLATEEX *>(
			reinterpret_cast<WORD*>((reinterpret_cast<DWORD_PTR>(pw) + 3) & ~DWORD_PTR(3))); // DWORD align
	};

	DLGTEMPLATEEX *pTemplate = nullptr;
	if ((pTemplate = loadDialogResource(AfxGetInstanceHandle(), name)) != nullptr)
	{
		HWND hWndChlid = ::GetWindow(h, GW_CHILD);
		const DLGITEMTEMPLATEEX *pItem = findFirstDlgItem(pTemplate);
		for (int nDlgItems = 0; nDlgItems < pTemplate->cDlgItems; ++nDlgItems)
		{
			const WORD *pw = reinterpret_cast<const WORD *>(pItem);
			pw += sizeof(DLGITEMTEMPLATEEX) / sizeof(WORD);
			skip(pw); // Skip class name string or ordinal

			if (*pw == static_cast<WORD>(-1))     // Skip text string or ordinal
				pw += 2;
			else
			{
				const wchar_t *p = reinterpret_cast<const wchar_t*>(pw);
				::SetWindowTextW(hWndChlid, p);
				while (*pw++);
			}

			hWndChlid = ::GetWindow(hWndChlid, GW_HWNDNEXT);
			pItem = findNextDlgItem(pItem);
		}
	}
	TranslateDialog(h);
}

String CLanguageSelect::LoadString(UINT id) const
{
	String s;
	if (id)
	{
		wchar_t text[1024];
		AfxLoadString(id, text, static_cast<unsigned>(std::size(text)));
		if (!TranslateString(text, s))
			s = text;
	}
	return s;
}

std::wstring CLanguageSelect::LoadDialogCaption(const tchar_t* lpDialogTemplateID) const
{
	std::wstring s;
	if (HINSTANCE hInst = AfxFindResourceHandle(lpDialogTemplateID, RT_DIALOG))
	{
		if (HRSRC hRsrc = FindResource(hInst, lpDialogTemplateID, RT_DIALOG))
		{
			if (LPCWSTR text = (LPCWSTR)LoadResource(hInst, hRsrc))
			{
				// Skip DLGTEMPLATE or DLGTEMPLATEEX
				text += text[1] == 0xFFFF ? 13 : 9;
				// Skip menu name string or ordinal
				if (*text == (const WCHAR)-1)
					text += 2; // WCHARs
				else
					while (*text++);
				// Skip class name string or ordinal
				if (*text == (const WCHAR)-1)
					text += 2; // WCHARs
				else
					while (*text++);
				// Caption string is ahead
				if (!TranslateString(text, s))
					s = text;
			}
		}
	}
	return s;
}

/**
 * @brief Load languages available on disk, and display in list, and select current
 */
std::vector<std::pair<LANGID, String> > CLanguageSelect::GetAvailableLanguages() const
{
	std::vector<std::pair<LANGID, String> > list;
	String path = paths::ConcatPath(env::GetProgPath(), szRelativePath);
	String pattern = paths::ConcatPath(path, _T("*.po"));
	WIN32_FIND_DATA ff;
	HANDLE h = INVALID_HANDLE_VALUE;
	do
	{
		LangFileInfo lfi(wSourceLangId);
		if (h != INVALID_HANDLE_VALUE)
			lfi = LangFileInfo(paths::ConcatPath(path, ff.cFileName).c_str());
		String str;
		str += lfi.GetString(LOCALE_SLANGUAGE);
		str += _T(" - ");
		str += lfi.GetString(LOCALE_SNATIVELANGNAME | LOCALE_USE_CP_ACP);
		str += _T(" (");
		str += lfi.GetString(LOCALE_SNATIVECTRYNAME | LOCALE_USE_CP_ACP);
		str += _T(")");
		str += _T(" - ");
		str += lfi.GetString(LOCALE_SENGLANGUAGE);
		str += _T(" (");
		str += lfi.GetString(LOCALE_SENGCOUNTRY);
		str += _T(")");
		list.emplace_back(lfi.id, str);
	} while ((h = FindFile(h, pattern.c_str(), &ff)) != INVALID_HANDLE_VALUE);
	return list;
}

/**
 * @brief Find DLL entry in lang_map for language for specified locale
 */
static WORD GetLangFromLocale(LCID lcid)
{
	tchar_t buff[8] = {0};
	WORD langID = 0;
	if (GetLocaleInfo(lcid, LOCALE_IDEFAULTLANGUAGE, buff, static_cast<int>(std::size(buff))))
		_stscanf_s(buff, _T("%4hx"), &langID);
	return langID;
}

void CLanguageSelect::InitializeLanguage(WORD langID)
{
	ASSERT(LangFileInfo::LangId("GERMAN", "") == MAKELANGID(LANG_GERMAN, SUBLANG_GERMAN));
	ASSERT(LangFileInfo::LangId("GERMAN", "DEFAULT") == MAKELANGID(LANG_GERMAN, SUBLANG_DEFAULT));
	ASSERT(LangFileInfo::LangId("GERMAN", "SWISS") == MAKELANGID(LANG_GERMAN, SUBLANG_GERMAN_SWISS));
	ASSERT(LangFileInfo::LangId("PORTUGUESE", "") == MAKELANGID(LANG_PORTUGUESE, SUBLANG_PORTUGUESE));
	ASSERT(LangFileInfo::LangId("NORWEGIAN", "BOKMAL") == MAKELANGID(LANG_NORWEGIAN, SUBLANG_NORWEGIAN_BOKMAL));
	ASSERT(LangFileInfo::LangId("NORWEGIAN", "NYNORSK") == MAKELANGID(LANG_NORWEGIAN, SUBLANG_NORWEGIAN_NYNORSK));

	//TRACE(_T("%hs\n"), LangFileInfo::FileName(MAKELANGID(LANG_NORWEGIAN, SUBLANG_NORWEGIAN_BOKMAL)).c_str());
	//TRACE(_T("%hs\n"), LangFileInfo::FileName(MAKELANGID(LANG_PORTUGUESE, SUBLANG_PORTUGUESE)).c_str());
	//TRACE(_T("%hs\n"), LangFileInfo::FileName(MAKELANGID(LANG_GERMAN, SUBLANG_DEFAULT)).c_str());

	if (langID)
	{
		// User has set a language override
		SetLanguage(langID);
		return;
	}
	// User has not specified a language
	// so look in thread locale, user locale, and then system locale for
	// a language that WinMerge supports
	WORD Lang1 = GetLangFromLocale(GetThreadLocale());
	if (SetLanguage(Lang1))
		return;
	WORD Lang2 = GetLangFromLocale(LOCALE_USER_DEFAULT);
	if (Lang2 != Lang1 && SetLanguage(Lang2))
		return;
	WORD Lang3 = GetLangFromLocale(LOCALE_SYSTEM_DEFAULT);
	if (Lang3 != Lang2 && Lang3 != Lang1 && SetLanguage(Lang3))
		return;
}
</file>

<file path="Winmerge-Src/Src/Common/LanguageSelect.h">
/** 
 * @file  LanguageSelect.h
 *
 * @brief Declaration file for CLanguageSelect dialog.
 */
#pragma once

#include <vector>
#include <string>
#include <map>
#include "UnicodeString.h"

/////////////////////////////////////////////////////////////////////////////
// CLanguageSelect class

class CStatusBar;

/**
 * @brief Class for selecting GUI language.
 *
 * Language select dialog shows list of installed GUI languages and
 * allows user to select one for use.
 */
class CLanguageSelect
{
// Construction
public:
	CLanguageSelect();   // standard constructor
	WORD GetLangId() const { return m_wCurLanguage; }
	String GetFileName(LANGID) const;
	void InitializeLanguage(WORD langID);

	bool TranslateString(const std::wstring&, std::wstring&) const;
	bool TranslateString(const std::string&, String&) const;
	void SetIndicators(CStatusBar &, const UINT *, int) const;
	void TranslateMenu(HMENU) const;
	void TranslateDialog(HWND) const;
	void RetranslateDialog(HWND, const tchar_t *name) const;
	String LoadString(UINT) const;
	std::wstring LoadDialogCaption(const tchar_t* lpDialogTemplateID) const;
	std::vector<std::pair<LANGID, String> > GetAvailableLanguages() const;
	bool SetLanguage(LANGID, bool bShowError = false);

// Implementation data
private:
	LANGID m_wCurLanguage;
	std::map<std::wstring, std::wstring> m_map_msgid_to_msgstr;
// Implementation methods
private:
	bool LoadLanguageFile(LANGID, bool bShowError = false);
};
</file>

<file path="Winmerge-Src/Src/Common/lwdisp.c">
/* File:	lwdisp.c - light weight dispatch API
 * Author:	Jochen Tucht 2003/01/09
 *			Copyright (C) 2003 herbert dahm datensysteme GmbH
 *
 * Purpose:	- Create windows scripting objects (scriptlets)
 *			- Invoke methods and access properties
 *			- Implement callback interfaces to be invoked by scriptlets
 *
 * Remarks:	requires Win32
 *			link with oleaut32, shlwapi 4.71
 *
 *			Features not supported by this API include:
 *			- type libraries
 *			- named arguments
 *
 * License:	THIS FILE CONTAINS FREE SOURCE CODE. IT IS PROVIDED *AS IS*, WITHOUT
 *			WARRANTY OF ANY KIND. YOU MAY USE IT AT YOUR OWN RISK, AS LONG AS
 *			YOU KEEP IT IN A SEPARATE FILE AND PRESERVE THIS COMMENT.
 *			CHANGES MUST BE RECORDED IN THE MODIFICATION HISTORY BELOW SO THERE
 *			IS EVIDENCE THAT THE FILE DIFFERS FROM EARLIER RELEASES. THE LEVEL
 *			OF DETAIL IS UP TO YOU. YOU MAY SET THE BY: ENTRY TO "NOBODY@ALL"
 *			IF YOU DON'T WANT TO EXPOSE YOUR NAME. SUBSEQUENT CHANGES MAY BE
 *			REFLECTED BY A SINGLE RECORD CARRYING THE DATE OF THE LATEST CHANGE.
 *

DATE:		BY:					DESCRIPTION:
==========	==================	================================================
2003/01/14	J.Tucht				provide a way to subclass the default LWDispVtbl
2003/03/16	J.Tucht				ensure BSTR arguments are writeable
2003/05/31	J.Tucht				registration of SCT and OCX no longer required
2003/08/05	J.Tucht				change some names for use with MFC
2003/08/31	J.Tucht				avoid wnsprintfW to get away with shlwapi < 5.0
2003/10/05	J.Tucht				allow calls from other threads through HWND
2003/11/04	J.Tucht				more explicit error messages, SEH
2003/11/06	NOBODY@ALL			incredible number of changes for unknown reasons
2003/11/18	Laoran				CreateDispatchBySource : avoid crash if loading dll fails
2003/11/18	Laoran				CreateDispatchBySource, cosmetic : move dll load&object creation after the CLSID search (= less indentations)
2004/01/08  Perry               Updated function comment preceding ReportError
2008/01/22  Kimmo               Changed map argument name to disp_map to not confuse VC6
*/

//#define _WIN32_IE		0x0300
//#define _WIN32_WINNT	0x0400	

#define NONAMELESSUNION		// avoid warning C4201
#define CINTERFACE			// tell gcc this is "C"

struct IShellView;			// avoid MSC warning C4115
struct _RPC_ASYNC_STATE;	// avoid MSC warning C4115

#pragma warning (push)			// prevent "warning C4091: 'typedef ': ignored on left of 'tagGPFIDL_FLAGS' when no variable is declared"
#pragma warning (disable:4091)	// VC bug when using XP enabled toolsets.
#include <shlobj.h>
#pragma warning (pop)
#include <shlwapi.h>
#include <tchar.h>
#include <stdarg.h>
#include <strsafe.h>
#include "lwdisp.h"

/**
* @brief Display or return error message string (from
number)
*
* @param style: if 0, return sysalloc'd string, else
msgbox
*
* Calls FormatMessage to get description of system string.
* If not found, makes a string containing raw number.
* If msgbox (style!=0), then function returns 0.
* If not msgbox (style==0), caller must LocalFree string.
*/
static LPTSTR NTAPI ReportError(HRESULT sc, UINT style)
{
	LPTCH pc = NULL;
	FormatMessage
	(
		FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
		NULL, sc,
		MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),
		(LPTCH)&pc, 0, NULL
	);
	if (pc == NULL)
	{
		FormatMessage
		(
			FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING |
			FORMAT_MESSAGE_ARGUMENT_ARRAY,
			_T("Error 0x%1!lX!"), 0,
			MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),
			(LPTCH)&pc, 0, (va_list *)&sc
		);
	}
	if (style)
	{
		MessageBox(0, pc, 0, style);
		LocalFree(pc);
		pc = NULL;
	}
	return pc;
}

/**
 * @brief build a formatted message string 
 */
static LPTSTR FormatMessageFromString(LPCTSTR format, ...)
{
	LPTCH pc = NULL;
	va_list list;
	va_start(list, format);
	FormatMessage
	(
		FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
		format, 0,
		MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),
		(LPTCH)&pc, 0, &list
	);
	va_end(list);
	return pc;
}

static void mycpyt2w(LPCTSTR tsz, wchar_t * wdest, size_t limit)
{
#ifdef _UNICODE
	StringCchCopyW(wdest, limit, tsz);
#else
	MultiByteToWideChar(CP_ACP, 0, tsz, -1, wdest, (int)limit);
	// always terminate the string
	wdest[limit-1] = 0;
#endif
}

#ifdef _WIN64
LPDISPATCH CreatDispatchBy32BitProxy(LPCTSTR source, LPCWSTR progid)
{
	CLSID clsid;
	VARIANT v[2], ret;
	void *pv = NULL;
	SCODE sc;
	wchar_t wpath[512];

	sc = CLSIDFromProgID(L"WinMerge32BitPluginProxy.Loader", &clsid);
	if (SUCCEEDED(sc))
		sc = CoCreateInstance(&clsid, 0, CLSCTX_LOCAL_SERVER|CLSCTX_ACTIVATE_32_BIT_SERVER, &IID_IDispatch, &pv);
	if (FAILED(sc))
	{
		LPTSTR errorText = ReportError(sc, 0);
		LPTSTR tmp;
		tmp = FormatMessageFromString(_T("Failed to load 32bit plugin(%1):%2\n")
			_T("WinMerge32BitPluginProxy.exe may not be registered.\n")
			_T("Try running the following in an elevated command prompt.\n\n")
			_T("\"{WinMerge installation path}\\WinMerge32BitPluginProxy.exe\" /RegServer"), source, errorText);
		LocalFree(errorText);
		errorText = tmp;
		MessageBox(NULL, errorText, NULL, MB_ICONSTOP|MB_TASKMODAL);
		LocalFree(errorText);
		return NULL;
	}
	VariantInit(&v[0]);
	VariantInit(&v[1]);
	VariantInit(&ret);
	V_VT(&v[1]) = VT_BSTR;
	mycpyt2w(source, wpath, DIMOF(wpath));
	V_BSTR(&v[1]) = SysAllocString(wpath);
	V_VT(&v[0]) = VT_BSTR;
	V_BSTR(&v[0]) = SysAllocString(progid);
	sc = invokeW(pv, &ret, L"Load", opFxn[2], v);
	if (SUCCEEDED(sc))
		pv = V_DISPATCH(&ret);
	VariantClear(&v[0]);
	VariantClear(&v[1]);
	return pv;
}
#endif

LPDISPATCH CreateDispatchBySourceAndCLSID(LPCTSTR source, CLSID *pObjectCLSID)
{
	LPDISPATCH pv = NULL;
	HMODULE hLibrary = LoadLibrary(source);
	if (hLibrary)
	{
		HRESULT (NTAPI*DllGetClassObject)(REFCLSID,REFIID,IClassFactory**)
			= (HRESULT(NTAPI*)(REFCLSID, REFIID, IClassFactory**))GetProcAddress(hLibrary, "DllGetClassObject");
		if (DllGetClassObject)
		{
			SCODE sc;
			IClassFactory *piClassFactory;
			if (SUCCEEDED(sc = DllGetClassObject(pObjectCLSID, &IID_IClassFactory, &piClassFactory)))
			{
				sc = piClassFactory->lpVtbl->CreateInstance(piClassFactory, 0, &IID_IDispatch, &pv);
				piClassFactory->lpVtbl->Release(piClassFactory);
			}
		}
		if (pv == NULL)
			FreeLibrary(hLibrary);
	}
	return pv;
}


/**
 * 
 * @Note We can use this code with unregistered COM DLL
 * For VC++ DLL, we need a custom CComTypeInfoHolder as the default one search the registry
 * For VB DLL, instance can not be shared across thread, one must be created for each thread
 *
 * Don't catch unknown errors in this function, because we want to catch
 * both C++ and C errors, and this is a C file.
 */
LPDISPATCH NTAPI CreateDispatchBySource(LPCTSTR source, LPCWSTR progid)
{
	void *pv = NULL;
	SCODE sc;
	WCHAR wc[320];
	if (source == NULL)
	{
		CLSID clsid;
		if (SUCCEEDED(sc=CLSIDFromProgID(progid, &clsid)))
		{
			sc=CoCreateInstance(&clsid, 0, CLSCTX_ALL, &IID_IDispatch, &pv);
		}
	}
	else if (PathMatchSpec(source, _T("*.ocx")) || PathMatchSpec(source, _T("*.dll")))
	{
		CLSID objectGUID = {0};
		BOOL bGUIDFound = FALSE;

		// search in the interface of the dll for the CLSID of progid
		ITypeLib *piTypeLib;
		mycpyt2w(source, wc, DIMOF(wc));
		if (SUCCEEDED(sc=LoadTypeLib(wc, &piTypeLib)))
		{
			UINT count = piTypeLib->lpVtbl->GetTypeInfoCount(piTypeLib);
			while (SUCCEEDED(sc) && !bGUIDFound && count--)
			{
				ITypeInfo *piTypeInfo;
				if (SUCCEEDED(sc=piTypeLib->lpVtbl->GetTypeInfo(piTypeLib, count, &piTypeInfo)))
				{
					TYPEATTR *pTypeAttr;
					if (SUCCEEDED(sc=piTypeInfo->lpVtbl->GetTypeAttr(piTypeInfo, &pTypeAttr)))
					{
						BSTR bstrName = 0;
						if (SUCCEEDED(sc=piTypeInfo->lpVtbl->GetDocumentation(piTypeInfo, MEMBERID_NIL, &bstrName, 0, 0, 0)))
						{
							if (pTypeAttr->typekind == TKIND_COCLASS && StrCmpIW(bstrName, progid) == 0)
							{
								memcpy(&objectGUID, &pTypeAttr->guid, sizeof(CLSID));
								bGUIDFound = TRUE;
							}
							SysFreeString(bstrName);
						}
						piTypeInfo->lpVtbl->ReleaseTypeAttr(piTypeInfo, pTypeAttr);
					}
					piTypeInfo->lpVtbl->Release(piTypeInfo);
				}
			}
			piTypeLib->lpVtbl->Release(piTypeLib);
		}
	
		if (bGUIDFound)
		{
			// we have found the CLSID, so this is really a COM dll for WinMerge
			// now try to load the dll and to create an instance of the object
#ifdef _WIN64
			{
			HMODULE hLibrary = LoadLibrary(source);
			if (hLibrary == NULL)
			{
				// assume 32bit DLL if failed to load DLL
				pv = CreatDispatchBy32BitProxy(source, progid);
			}
			else
			{
				pv = CreateDispatchBySourceAndCLSID(source, &objectGUID);
				FreeLibrary(hLibrary);
			}
			}
#else
			pv = CreateDispatchBySourceAndCLSID(source, &objectGUID);
#endif
		}
		// don't display an error message if no interface (normal dll)
		if (PathMatchSpec(source, _T("*.dll")) && sc == TYPE_E_CANTLOADLIBRARY)
			sc = 0;
		// don't display an error message if the format is too old
		if (sc == TYPE_E_UNSUPFORMAT)
			sc = 0;
	}
	else 
	{
		BIND_OPTS bind_opts;
		// initialize to official defaults:
		bind_opts.cbStruct = sizeof bind_opts;
		bind_opts.grfFlags = 0;
		bind_opts.grfMode = STGM_READWRITE;
		bind_opts.dwTickCountDeadline = 0;
		// prepend appropriate moniker:
		if (PathMatchSpec(source, _T("*.sct")) 
			|| PathMatchSpec(source, _T("*.wsc")))
			mycpyt2w(_T("script:"), wc, DIMOF(wc));
		else
			mycpyt2w(_T(""), wc, DIMOF(wc));
		size_t len = wcslen(wc);
		mycpyt2w(source, wc + len, DIMOF(wc) - len);

		// I observed that CoGetObject() may internally provoke an access
		// violation and succeed anyway. No idea how to avoid this.
		sc=CoGetObject(wc, &bind_opts, &IID_IDispatch, &pv);
		if (sc == E_NOINTERFACE)
		{
			// give it a second try after opening within associated application:
			SHELLEXECUTEINFO sein;
			sein.cbSize = sizeof sein;
			sein.hwnd = NULL;
			// SEE_MASK_FLAG_DDEWAIT: wait until application is ready to listen
			sein.fMask = SEE_MASK_FLAG_DDEWAIT;
			sein.lpVerb = _T("open");
			sein.lpFile = source;
			sein.lpParameters = NULL;
			sein.lpDirectory = _T(".");
			sein.nShow = SW_SHOWNORMAL;
			if (ShellExecuteEx(&sein))
			{
				sc=CoGetObject(wc, &bind_opts, &IID_IDispatch, &pv);
			}
		}
		// no error if the interface does not exist
		if (sc == MK_E_INTERMEDIATEINTERFACENOTSUPPORTED || sc == E_UNEXPECTED)
			sc = 0;
	}
	if (FAILED(sc))
	{
		// get the error description
		LPTSTR errorText = ReportError(sc, 0);
		if (source)
		{
			// append the source name
			LPTSTR tmp;
			tmp = FormatMessageFromString(_T("%1\n%2"), errorText, source);
			LocalFree(errorText);
			errorText = tmp;
		}
		// report error
		MessageBox(0, errorText, 0, MB_ICONSTOP|MB_TASKMODAL);
		LocalFree(errorText);
		// no valid dispatch
		pv = NULL;
	}
	return (LPDISPATCH)pv;
}

static BOOL NeedsConversion(LPDISPATCH pi, DISPID id, VARIANT *argv, int cArgs)
{
	BOOL bParamByRef = FALSE;
	BOOL bNeedToConv = FALSE;
	int i;

	for (i = 0; i < cArgs; i++)
	{
		if (V_ISBYREF(&argv[i]))
		{
			bParamByRef = TRUE;
			break;
		}
	}
	if (bParamByRef)
	{
		ITypeInfo* pTypeInfo;
		HRESULT hr;

		hr = pi->lpVtbl->GetTypeInfo(pi, 0, 0, &pTypeInfo);
		if (SUCCEEDED(hr))
		{
			FUNCDESC* pFuncDesc = NULL;
			ITypeInfo2* pTypeInfo2 = NULL;
			pTypeInfo->lpVtbl->QueryInterface(pTypeInfo, &IID_ITypeInfo2, &pTypeInfo2);
			if (pTypeInfo2 != NULL)
			{
				UINT nIndex;
				hr = pTypeInfo2->lpVtbl->GetFuncIndexOfMemId(pTypeInfo2, id, INVOKE_FUNC, &nIndex);
				if (SUCCEEDED(hr))
				{
					hr = pTypeInfo->lpVtbl->GetFuncDesc(pTypeInfo, nIndex, &pFuncDesc);
					if (SUCCEEDED(hr))
					{
						if (pFuncDesc->oVft == 0)
							bNeedToConv = TRUE;
						pTypeInfo->lpVtbl->ReleaseFuncDesc(pTypeInfo, pFuncDesc);
					}
				}
				pTypeInfo2->lpVtbl->Release(pTypeInfo2);
			}
			pTypeInfo->lpVtbl->Release(pTypeInfo);
		}
	}
	return bNeedToConv;
}

static void MoveVariantValue(VARIANT* dst, VARIANT* src)
{
	if ((V_VT(dst) & ~VT_BYREF) == VT_BSTR && V_VT(src) == VT_BSTR)
	{
		SysFreeString(*V_BSTRREF(dst));
		*V_BSTRREF(dst) = V_BSTR(src);
		V_VT(src) = VT_EMPTY;
		return;
	}
	VARIANT varTemp;
	VariantInit(&varTemp);
	VariantChangeType(&varTemp, src, 0, (unsigned short)(V_VT(dst) & ~VT_BYREF));
	switch (V_VT(dst) & ~VT_BYREF) {
	case VT_BOOL:
		*V_BOOLREF(dst) = V_BOOL(&varTemp);
		break;
	case VT_I1:
		*V_I2REF(dst) = V_I1(&varTemp);
		break;
	case VT_I2:
		*V_I2REF(dst) = V_I2(&varTemp);
		break;
	case VT_I4:
		*V_I4REF(dst) = V_I4(&varTemp);
		break;
	case VT_R4:
		*V_R4REF(dst) = V_R4(&varTemp);
		break;
	case VT_R8:
		*V_R8REF(dst) = V_R8(&varTemp);
		break;
	case VT_BSTR:
		SysFreeString(*V_BSTRREF(dst));
		*V_BSTRREF(dst) = V_BSTR(&varTemp);
		V_VT(&varTemp) = VT_EMPTY;
		break;
	}
	VariantClear(&varTemp);
}

STDAPI invokeV(LPDISPATCH pi, VARIANT *ret, DISPID id, LPCCH op, VARIANT *argv)
{
	HRESULT sc = E_FAIL;
	DISPID idNamed = DISPID_PROPERTYPUT;
	WORD wFlags = HIBYTE((UINT_PTR)op);
	DISPPARAMS dispparams;
	UINT nArgErr = (UINT)-1;
	EXCEPINFO excepInfo = {0};
	dispparams.cArgs = LOBYTE((UINT_PTR)op);
	dispparams.cNamedArgs = 0;
	dispparams.rgvarg = argv;
	if (wFlags & (DISPATCH_PROPERTYPUT|DISPATCH_PROPERTYPUTREF))
	{
		dispparams.cNamedArgs = 1;
		dispparams.rgdispidNamedArgs = &idNamed;
	}
	if (pi != NULL)
	{
		VARIANT varParams[12] = { 0 };
		VARIANT varData[12] = { 0 };
		BOOL bNeedToConv = NeedsConversion(pi, id, argv, dispparams.cArgs);
		int i;
		if (bNeedToConv)
		{
			for (i = 0; i < (int)dispparams.cArgs; i++)
			{
				VariantInit(&varData[i]);
				VariantCopyInd(&varData[i], &argv[i]);
				V_VARIANTREF(&varParams[i]) = &varData[i];
				V_VT(&varParams[i]) = VT_VARIANT | VT_BYREF;
			}
			dispparams.rgvarg = varParams;
		}
		else
		{
			dispparams.rgvarg = argv;
		}

		sc = pi->lpVtbl->Invoke(pi, id, &IID_NULL, 0, wFlags, &dispparams,
			ret, &excepInfo, &nArgErr);
		if (FAILED(sc))
		{
			if (excepInfo.pfnDeferredFillIn)
			{
				excepInfo.pfnDeferredFillIn(&excepInfo);
			}
			if (excepInfo.bstrDescription)
			{
				MessageBoxW(0, excepInfo.bstrDescription, excepInfo.bstrSource, MB_ICONSTOP|MB_TASKMODAL);
			}
			else
			{
				ReportError(excepInfo.scode == 0 ? sc : excepInfo.scode, MB_ICONSTOP|MB_TASKMODAL);
			}
			SysFreeString(excepInfo.bstrDescription);
			SysFreeString(excepInfo.bstrSource);
			SysFreeString(excepInfo.bstrHelpFile);
		}
		else
		{
			if (bNeedToConv)
			{
				if (V_VT(ret) == (VT_ARRAY | VT_VARIANT))
				{
					long ubound = 0;
					SafeArrayGetUBound(V_ARRAY(ret), 1, &ubound);
					VARIANT* p = NULL;
					int j = ubound;
					SafeArrayAccessData(V_ARRAY(ret), (void**)(&p));
					for (i = 0; i < (int)dispparams.cArgs; i++)
					{
						if (V_ISBYREF(&argv[i]) && j > 0)
							MoveVariantValue(&argv[i], &p[j--]);
						VariantClear(&varParams[i]);
						VariantClear(&varData[i]);
					}
					VARIANT_BOOL bResult = V_BOOL(&p[0]);
					VariantClear(ret);
					V_BOOL(ret) = bResult;
					V_VT(ret) = VT_BOOL;
				}
				else
				{
					for (i = 0; i < (int)dispparams.cArgs; i++)
					{
						if (V_ISBYREF(&argv[i]))
							MoveVariantValue(&argv[i], &varData[i]);
						VariantClear(&varParams[i]);
					}
				}
			}
		}
	}
	while (dispparams.cArgs--)
	{
		VariantClear(dispparams.rgvarg++);
	}
	return sc;
}

HRESULT invokeA(LPDISPATCH pi, VARIANT *ret, DISPID id, LPCCH op, VARIANT *argv)
{
	return invokeV(pi, ret, id, op, argv);
}
HRESULT invokeW(LPDISPATCH pi, VARIANT *ret, LPCOLESTR silent, LPCCH op, VARIANT *argv)
{
	DISPID id = DISPID_UNKNOWN;
	LPOLESTR  name = (LPOLESTR )((UINT_PTR)silent & ~1);
	if (pi != NULL)
	{
		HRESULT sc = pi->lpVtbl->GetIDsOfNames(pi, &IID_NULL, &name, 1, 0, &id);
		if (FAILED(sc))
		{
			if (!((UINT_PTR)silent & 1))
			{
				ReportError(sc, MB_ICONSTOP);
			}
			pi = NULL;
		}
	}
	return invokeV(pi, ret, id, op, argv);
}

STDAPI ValidateArgs(VARIANT *argv, UINT argc, LPCCH pvt)
{
	VARTYPE vt;
	while ((vt = (BYTE)*pvt++) != 0)
	{
		if (argc == 0)
			return DISP_E_BADPARAMCOUNT;
		if (vt == VT_VARIANT)
		{
			VARIANT *ref = argv;
			while (V_VT(ref) == VT_VARIANT + VT_BYREF)
			{
				ref = V_VARIANTREF(ref);
			}
			vt = V_VT(ref);
		}
		if (vt != VT_VARIANT)
		{
			if (V_VT(argv) != vt)
			{
				HRESULT sc = VariantChangeType(argv, argv, 0, vt);
				if (FAILED(sc))
					return sc;
			}
			else if (vt == VT_BSTR)
			{
				// Const strings passed in from Compiled VB may reside in r/o
				// memory. Since B2A() expects BSTR arguments to be writeable,
				// the following code copies short strings to writeable memory.
				// Long strings are assumed to be writeable anyway since they
				// are normally a result of some non-const expression.
				// This is a tradeoff between efficiency and safety.
				// A const string longer than 260 OLECHARs (520 bytes) will
				// provoke an access violation in B2A().
				char buffer[520];
				buffer[0] = '\0';
				UINT length =  SysStringByteLen V_BSTR(argv);
				if (length <= sizeof buffer)
				{
					CopyMemory(buffer, V_BSTR(argv), length);
					SysFreeString V_BSTR(argv);
					V_BSTR(argv) = SysAllocStringByteLen(buffer, length);
				}
			}
		}
		--argc;
		++argv;
	}
	return argc ? DISP_E_BADPARAMCOUNT : S_OK;
}

/** 
 * @brief BSTR to PCH (ANSI) conversion
 * It needs BSTR to be wide (always the case in Windows) 
 *
 * @note THIS METHOD IS BUGGY : IT IS NOT CORRECT TO PUT A CHAR STRING IN A WCHAR BUFFER
 * IN FACT IN PLACE TRANSFORMATION OF WCHAR TO CHAR IS NOT CORRECT
 * the content of bcVal is changed
 */
/*
PCH NTAPI B2A(BSTR bcVal)
{
	static const char empty[] = {0};
	PCH pcVal = (PCH)empty;
	if (bcVal)
	{
		pcVal = ((PCH)bcVal) + 1;
		if (*(PCH)bcVal)
		{
			int cch = lstrlenW(bcVal) + 1;
			WideCharToMultiByte(CP_ACP, 0, bcVal, cch, pcVal, cch, 0, 0);
			// this is buggy : we need to set *bcVal = 0 (so we use pcVal = ((PCH)bcVal) + 2)
			*(PCH)bcVal = 0;
		}
	}
	return pcVal;
}
*/

// FIX B2A BEFORE UNCOMMENTING THIS ONE
/*
LPCTSTR NTAPI B2T(BSTR bcVal)
{
#ifdef _UNICODE
	return bcVal;
#else
	return B2A(bcVal);
#endif
}
*/

STDAPI LWDefProc(PVOID UNUSED_ARG(target), HRESULT UNUSED_ARG(sc),
	VARIANT *UNUSED_ARG(ret), VARIANT *UNUSED_ARG(argv), UINT UNUSED_ARG(argc),
	EXCEPINFO *UNUSED_ARG(e))
{
	return DISP_E_MEMBERNOTFOUND;
}

struct LWDispMap
{
	LWDispFxn pfnProc;
	int count;
	struct LWDispRef ref[1];
};

static STDMETHODIMP QueryInterface(struct LWDispatch *This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void **ppvObject)
{
	if (IsEqualIID(riid, &IID_IUnknown) || IsEqualIID(riid, &IID_IDispatch))
	{
		This -> lpVtbl -> AddRef(This);
		*ppvObject = This;
		return S_OK;
	}
	return E_NOINTERFACE;
}
        
static ULONG STDMETHODCALLTYPE AddRef(struct LWDispatch *This)
{
	return ++This->refc;
}        

static ULONG STDMETHODCALLTYPE Release(struct LWDispatch *This)
{
	ULONG Release = --This->refc;
	if (Release == 0)
	{
		free(This);
	}
	return Release;
}

static STDMETHODIMP GetTypeInfoCount(struct LWDispatch *UNUSED_ARG(This),
					/* [out] */ UINT *UNUSED_ARG(pctinfo))
{
	return E_NOTIMPL;
}

static STDMETHODIMP GetTypeInfo(struct LWDispatch *UNUSED_ARG(This),
					/* [in] */ UINT UNUSED_ARG(iTInfo),
					/* [in] */ LCID UNUSED_ARG(lcid),
					/* [out] */ ITypeInfo **UNUSED_ARG(ppTInfo))
{
	return E_NOTIMPL;
}

static STDMETHODIMP GetIDsOfNames(struct LWDispatch *This,
					/* [in] */ REFIID UNUSED_ARG(riid),
					/* [size_is][in] */ LPOLESTR *rgszNames,
					/* [in] */ UINT UNUSED_ARG(cNames),
					/* [in] */ LCID UNUSED_ARG(lcid),
					/* [size_is][out] */ DISPID *rgDispId)
{
	DISPID dispIdMember = 0;
	for ( ; dispIdMember < This->map->count ; ++dispIdMember)
	{
		if (StrCmpIW(This->map->ref[dispIdMember].pwcName, rgszNames[0]) == 0)
		{
			*rgDispId = dispIdMember;
			return S_OK;
		}
	}
	return DISP_E_MEMBERNOTFOUND;
}

static STDMETHODIMP Invoke(struct LWDispatch *This,
					/* [in] */ DISPID dispIdMember,
					/* [in] */ REFIID UNUSED_ARG(riid),
					/* [in] */ LCID UNUSED_ARG(lcid),
					/* [in] */ WORD wFlags,
					/* [out][in] */ DISPPARAMS *pDispParams,
					/* [out] */ VARIANT *pVarResult,
					/* [out] */ EXCEPINFO *pExcepInfo,
					/* [out] */ UINT *UNUSED_ARG(puArgErr))
{
	// provide a dummy result variable if pVarResult == 0
	VARIANT varEmpty;
	HRESULT sc = dispIdMember < 0 ? dispIdMember : (HRESULT)wFlags;
	if (pDispParams->cNamedArgs >
		((wFlags & (DISPATCH_PROPERTYPUT|DISPATCH_PROPERTYPUTREF)) ? 1U : 0U))
		return DISP_E_NONAMEDARGS;
	VariantInit(&varEmpty);
	sc =
	(
		dispIdMember < 0 ? This->map->pfnProc :
		dispIdMember < This->map->count ? This->map->ref[dispIdMember].pfnProc :
		LWDefProc
	)
	(
		This->target, sc,
		pVarResult ? pVarResult : &varEmpty,
		pDispParams->rgvarg, pDispParams->cArgs,
		pExcepInfo
	);
	VariantClear(&varEmpty);
	return sc;
}

static const struct LWDispVtbl vtbl =
{
	QueryInterface,
	AddRef,
	Release,
	GetTypeInfoCount,
	GetTypeInfo,
	GetIDsOfNames,
	Invoke
};

const struct LWDispVtbl *NTAPI LWDispSubclass(struct LWDispVtbl *lpVtbl)
{
	*lpVtbl = vtbl;
	return &vtbl;
}

IDispatch *NTAPI LWDispatch(void *target, const void *disp_map,
	const struct LWDispVtbl *lpVtbl, struct LWDispatch *This)
{
	if (lpVtbl == NULL)
		lpVtbl = &vtbl;
	if (This == NULL)
		This = (struct LWDispatch *)malloc(sizeof(*This));
	if (This)
	{
		This->lpVtbl = lpVtbl;
		This->target = target;
		This->map = (const struct LWDispMap *)disp_map;
		This->refc = 0;
	}
	return (IDispatch *)This;
}

VARIANT NTAPI LWArg(LPDISPATCH pdispVal)
{
	VARIANT v;
	VariantInit(&v);
	if (pdispVal) (V_VAR(&v,DISPATCH) = pdispVal) -> lpVtbl -> AddRef(pdispVal);
	return v;
}

VARIANT NTAPI LWArgW(LPCWSTR wcVal)
{
	VARIANT v;
	VariantInit(&v);
	V_VAR(&v,BSTR) = SysAllocString(wcVal);
	return v;
}

VARIANT NTAPI LWArgA(LPCSTR cVal)
{
	UINT len = lstrlenA(cVal);
	VARIANT v;
	VariantInit(&v);
	V_VAR(&v,BSTR) = SysAllocStringLen(NULL, len);
	MultiByteToWideChar(CP_ACP, 0, cVal, -1, V_BSTR(&v), len);
	return v;
}

VARIANT NTAPI LWArgV(UINT vt, ...)
{
	VARIANT v;
	va_list list;
	VariantInit(&v);
	va_start(list, vt);
	V_VT(&v) = (VARTYPE)(vt & 0xF0FF);
	CopyMemory(&V_NONE(&v), va_arg(list, void *), (vt & 0x0F00) >> 8);
	va_end(list);
	return v;
}
</file>

<file path="Winmerge-Src/Src/Common/lwdisp.h">
/* File:	lwdisp.h - light weight dispatch API
 * Author:	Jochen Tucht 2003/01/09
 *			Copyright (C) 2003 herbert dahm datensysteme GmbH
 *
 * Declaration file for lwdisp.c
 *
 * Purpose:	- Create windows scripting objects (scriptlets)
 *			- Invoke methods and access properties
 *			- Implement callback interfaces to be invoked by scriptlets
 *
 * License:	THIS FILE CONTAINS FREE SOURCE CODE. IT IS PROVIDED *AS IS*, WITHOUT
 *			WARRANTY OF ANY KIND. YOU MAY USE IT AT YOUR OWN RISK, AS LONG AS
 *			YOU KEEP IT IN A SEPARATE FILE AND PRESERVE THIS COMMENT.
 *			CHANGES MUST BE RECORDED IN THE MODIFICATION HISTORY BELOW SO THERE
 *			IS EVIDENCE THAT THE FILE DIFFERS FROM EARLIER RELEASES. THE LEVEL
 *			OF DETAIL IS UP TO YOU. YOU MAY SET THE BY: ENTRY TO "NOBODY@ALL"
 *			IF YOU DON'T WANT TO EXPOSE YOUR NAME. SUBSEQUENT CHANGES MAY BE
 *			REFLECTED BY A SINGLE RECORD CARRYING THE DATE OF THE LATEST CHANGE.
 *

DATE:		BY:					DESCRIPTION:
==========	==================	================================================
2003/11/28	Laoran 				      header and RCS ID
*/
#pragma once

#ifdef __cplusplus
extern "C"{
#endif 

#ifdef _MSC_VER
#define UNUSED_ARG(ARG) ARG
#elif defined(__GNUC__)
#define UNUSED_ARG(ARG) ARG
#else
#define UNUSED_ARG(ARG)
#endif

// macros for use with ValidateArgs()

// parameter types: by value VTs
#define VTS_I2              "\x02"      // a 'short'
#define VTS_I4              "\x03"      // a 'long'
#define VTS_R4              "\x04"      // a 'float'
#define VTS_R8              "\x05"      // a 'double'
#define VTS_CY              "\x06"      // a 'CY' or 'CY*'
#define VTS_DATE            "\x07"      // a 'DATE'
#define VTS_WBSTR           "\x08"      // an 'LPCOLESTR'
#define VTS_DISPATCH        "\x09"      // an 'IDispatch*'
#define VTS_SCODE           "\x0A"      // an 'SCODE'
#define VTS_BOOL            "\x0B"      // a 'BOOL'
#define VTS_VARIANT         "\x0C"      // a 'const VARIANT&' or 'VARIANT*'
#define VTS_UNKNOWN         "\x0D"      // an 'IUnknown*'
#if defined(_UNICODE) || defined(OLE2ANSI)
	#define VTS_BSTR            VTS_WBSTR// an 'LPCOLESTR'
	#define VT_BSTRT            VT_BSTR
#else
	#define VTS_BSTR            "\x0E"  // an 'LPCSTR'
	#define VT_BSTRA            14
	#define VT_BSTRT            VT_BSTRA
#endif
#ifndef VTS_UI1
#define VTS_UI1             "\x0F"      // a 'BYTE'
#endif

// parameter types: by reference VTs
#define VTS_PI2             "\x42"      // a 'short*'
#define VTS_PI4             "\x43"      // a 'long*'
#define VTS_PR4             "\x44"      // a 'float*'
#define VTS_PR8             "\x45"      // a 'double*'
#define VTS_PCY             "\x46"      // a 'CY*'
#define VTS_PDATE           "\x47"      // a 'DATE*'
#define VTS_PBSTR           "\x48"      // a 'BSTR*'
#define VTS_PDISPATCH       "\x49"      // an 'IDispatch**'
#define VTS_PSCODE          "\x4A"      // an 'SCODE*'
#define VTS_PBOOL           "\x4B"      // a 'VARIANT_BOOL*'
#define VTS_PVARIANT        "\x4C"      // a 'VARIANT*'
#define VTS_PUNKNOWN        "\x4D"      // an 'IUnknown**'

// special VT_ and VTS_ values
#define VTS_NONE            NULL        // used for members with 0 params

// macros for use with wsprintfA(), wsprintfW()

#ifdef _UNICODE
#define WVA_TSTR L"%s"
#define AVA_TSTR "%S"
#define TVA_BSTR L"%s"
#else
#define WVA_TSTR L"%S"
#define AVA_TSTR "%s"
#define TVA_BSTR "%S"
#endif

// misc. macros

#define DIMOF(a) (sizeof(a)/sizeof(*a))


/**
 * @param source : if 0, create an object of the class registered as *progid*
 * @param progid : if 0, create an object from file *source*
 * If both source and progid defined, ask *source* to create an object of class *progid*
 */
LPDISPATCH NTAPI CreateDispatchBySource(LPCTSTR source, LPCWSTR progid);

/**
 * @brief invoke helper (__stdcall)
 *
 * @note Free all variants passed to it (except ByRef ones) 
 */
STDAPI invokeV(LPDISPATCH, VARIANT *, DISPID, LPCCH, VARIANT *);
/**
 * @brief invoke helper (by ordinal)
 *
 * @note Free all variants passed to it (except ByRef ones) 
 */
STDAPIV invokeA(LPDISPATCH, VARIANT *, DISPID, LPCCH, VARIANT *);
/**
 * @brief invoke helper (by function name)
 *
 * @note Free all variants passed to it (except ByRef ones) 
 */
STDAPIV invokeW(LPDISPATCH, VARIANT *, LPCOLESTR, LPCCH, VARIANT *);

// macros for use with invoke*()
#define opFxn &((PCH)(DISPATCH_METHOD<<8))
#define opPut &((PCH)(DISPATCH_PROPERTYPUT<<8))
#define opGet &((PCH)(DISPATCH_PROPERTYGET<<8))
#define opSet &((PCH)(DISPATCH_PROPERTYPUTREF<<8))

// ::invokeW(piDispatch, LODD(Foo), ...) will fail silently if the interface
// lacks the requested method or property
#define LODD(NAME) ((BSTR)((PCH)L###NAME+1))

// convert given arguments to requested types
STDAPI ValidateArgs(VARIANT *argv, UINT argc, LPCCH pvt);

// in place conversion of BSTR to LPCCH
// IN PLACE TRANSFORMATION OF WCHAR TO CHAR IS NOT CORRECT
/*
PCH NTAPI B2A(BSTR);
LPCTSTR NTAPI B2T(BSTR);
*/

// callback interface related declarations

typedef HRESULT(NTAPI*LWDispFxn)
		(PVOID, HRESULT, VARIANT *, VARIANT *, UINT, EXCEPINFO *);

STDAPI	LWDefProc
		(PVOID, HRESULT, VARIANT *, VARIANT *, UINT, EXCEPINFO *);

struct LWDispRef
{
	LPCWSTR pwcName;
	LWDispFxn pfnProc;
};

struct LWDispatch;

struct LWDispVtbl
{
	HRESULT(STDMETHODCALLTYPE*QueryInterface)( 
		struct LWDispatch *This,
		/* [in] */ REFIID riid,
		/* [iid_is][out] */ void **ppvObject);
	ULONG(STDMETHODCALLTYPE*AddRef)(struct LWDispatch *This);
	ULONG(STDMETHODCALLTYPE*Release)(struct LWDispatch *This);
	HRESULT(STDMETHODCALLTYPE*GetTypeInfoCount)( 
		struct LWDispatch *This,
		/* [out] */ UINT *pctinfo);
	HRESULT(STDMETHODCALLTYPE*GetTypeInfo)( 
		struct LWDispatch *This,
		/* [in] */ UINT iTInfo,
		/* [in] */ LCID lcid,
		/* [out] */ ITypeInfo **ppTInfo);
	HRESULT(STDMETHODCALLTYPE*GetIDsOfNames)( 
		struct LWDispatch *This,
		/* [in] */ REFIID riid,
		/* [size_is][in] */ LPOLESTR *rgszNames,
		/* [in] */ UINT cNames,
		/* [in] */ LCID lcid,
		/* [size_is][out] */ DISPID *rgDispId);
	HRESULT(STDMETHODCALLTYPE*Invoke)( 
		struct LWDispatch *This,
		/* [in] */ DISPID dispIdMember,
		/* [in] */ REFIID riid,
		/* [in] */ LCID lcid,
		/* [in] */ WORD wFlags,
		/* [out][in] */ DISPPARAMS *pDispParams,
		/* [out] */ VARIANT *pVarResult,
		/* [out] */ EXCEPINFO *pExcepInfo,
		/* [out] */ UINT *puArgErr);
};

struct LWDispatch
{
	const struct LWDispVtbl *lpVtbl;
	void *target;
	const struct LWDispMap *map;
	ULONG refc;
};

const struct LWDispVtbl *NTAPI LWDispSubclass(struct LWDispVtbl *);

IDispatch *NTAPI LWDispatch(void *target, const void *disp_map,
							const struct LWDispVtbl *, struct LWDispatch *);

// functions to build VARIANT arguments from various data types

// LWArg for objects
VARIANT NTAPI LWArg(LPDISPATCH);

// LWArg for wide and ansi character strings
VARIANT NTAPI LWArgW(LPCWSTR);
VARIANT NTAPI LWArgA(LPCSTR);

#ifdef _UNICODE
#define LWArgT LWArgW
#else
#define LWArgT LWArgA
#endif
// Generic LWArg for everything that does not involve dynamic allocation or
// reference counting. Use LWVT macro to compute the UINT argument.

VARIANT NTAPI LWArgV(UINT, ...);
#define LWVT(t) (sizeof(V_##t((VARIANT*)0)) << 8 | VT_##t)

// assign variant type and data in one statement
#define V_VAR(r,t) V_VT(r)=VT_##t,V_##t(r)

#ifdef __cplusplus
}
#endif 

#ifdef __cplusplus

// LWDispMap implementation macros for C++

#define	DISPMAP_FXN(NAME) \
	HRESULT *_##NAME, NAME(HRESULT, VARIANT *, VARIANT *, UINT, EXCEPINFO *); \
	static HRESULT NTAPI NAME##_(PVOID p, HRESULT sc, VARIANT *ret, VARIANT *argv, UINT argc, EXCEPINFO *e) \
	{ return ((P*)p)->NAME(sc, ret, argv, argc, e); }

#define	DISPMAP_REF(NAME) {L###NAME,NAME##_}

#define DISPMAP(T) \
	enum {COUNT = (sizeof(P) - sizeof(T)) / sizeof(HRESULT*)}; \
	static const struct\
	{ \
		LWDispFxn pfnProc; \
		int count; \
		struct LWDispRef ref[COUNT]; \
	} map =

// VARIANT derivative to hold a result value

struct LWRet: public VARIANT
{
	LWRet() {VariantInit(this);}
~	LWRet() {VariantClear(this);}
};

#else

// Sorry, no extra support for plain old C...

#endif
</file>

<file path="Winmerge-Src/Src/Common/MDITabBar.cpp">
/**
 * @file  MDITabBar.cpp
 *
 * @brief Implementation of the MDITabBar class
 */

#include "StdAfx.h"
#include "MDITabBar.h"
#include "IMDITab.h"
#include "cecolor.h"
#include "RoundedRectWithShadow.h"
#include "MergeDarkMode.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

constexpr int RR_RADIUS = 3;
constexpr int RR_PADDING = 3;
constexpr int RR_SHADOWWIDTH = 3;

/////////////////////////////////////////////////////////////////////////////
// CMDITabBar

IMPLEMENT_DYNAMIC(CMyTabCtrl, CTabCtrl)

BEGIN_MESSAGE_MAP(CMyTabCtrl, CTabCtrl)
	//{{AFX_MSG_MAP(CMyTabCtrl)
	ON_WM_MBUTTONDOWN()
	ON_WM_CONTEXTMENU()
	ON_WM_PAINT()
	ON_WM_ERASEBKGND()
	ON_NOTIFY_REFLECT_EX(TCN_SELCHANGE, OnSelchange)
	ON_WM_DRAWITEM_REFLECT()
	ON_WM_MOUSEMOVE()
	ON_WM_MOUSELEAVE()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEWHEEL()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

IMPLEMENT_DYNAMIC(CMDITabBar, CControlBar)

BEGIN_MESSAGE_MAP(CMDITabBar, CControlBar)
	//{{AFX_MSG_MAP(CMDITabBar)
	ON_WM_SIZE()
	ON_WM_NCHITTEST()
	ON_WM_ERASEBKGND()
	ON_WM_PAINT()
	ON_WM_NCMOUSEMOVE()
	ON_WM_NCMOUSELEAVE()
	ON_WM_NCLBUTTONDBLCLK()
	ON_WM_NCLBUTTONDOWN()
	ON_WM_NCLBUTTONUP()
	ON_WM_NCRBUTTONDOWN()
	ON_WM_NCRBUTTONUP()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

static int determineIconSize()
{
	return GetSystemMetrics(SM_CXSMICON);
}

BOOL CMyTabCtrl::Create(CMDIFrameWnd* pMainFrame, CWnd* pParent)
{
	if (!CTabCtrl::Create(WS_CHILD | WS_VISIBLE | TCS_OWNERDRAWFIXED, CRect(0, 0, 0, 0), pParent, 0))
		return FALSE;

	m_pMainFrame = pMainFrame;
	m_tooltips.Create(m_pMainFrame, TTS_NOPREFIX);
	m_tooltips.AddTool(this, _T(""));
	if (HWND hSelf = GetSafeHwnd())
		DarkMode::setTabCtrlUpDownSubclass(hSelf);

	if (HWND hTip = m_tooltips.GetSafeHwnd())
		DarkMode::setDarkTooltips(hTip);

	return TRUE;
}

/**
 * @brief Called before messages are translated.
 * Passes a mouse message to the ToolTip control for processing.
 * @param [in] pMsg Points to an MSG structure that contains the message to be chcecked
 */
BOOL CMyTabCtrl::PreTranslateMessage(MSG* pMsg)
{
	if (pMsg->message == WM_MOUSEMOVE)
		m_tooltips.RelayEvent(pMsg);

	// Call the parent method.
	return __super::PreTranslateMessage(pMsg);
}

void CMyTabCtrl::SetActive(bool bActive)
{
	CTitleBarHelper::ReloadAccentColor();
	m_bActive = bActive;
}

/**
 * @brief Activate the specific tab by index.
 * @param nTabIndex [in] Tab index to activate
 */
void CMyTabCtrl::ActivateTab(int nTabIndex)
{
	if (nTabIndex < 0 || nTabIndex >= GetItemCount())
		return;

	SetCurSel(nTabIndex);

	// Notify tab selection changed
	NMHDR nmhdr = {0};
	nmhdr.hwndFrom = GetSafeHwnd();
	nmhdr.idFrom = GetDlgCtrlID();
	nmhdr.code = TCN_SELCHANGE;
	GetParent()->SendMessage(WM_NOTIFY, nmhdr.idFrom, reinterpret_cast<LPARAM>(&nmhdr));
}

static inline COLORREF getTextColor()
{
	return GetSysColor(COLOR_WINDOWTEXT);
}

COLORREF CMyTabCtrl::GetBackColor() const
{
	const COLORREF clr = GetSysColor(COLOR_3DFACE);
	if (!m_bOnTitleBar)
		return clr;
	return CTitleBarHelper::GetBackColor(m_bActive);
}

static inline bool IsHighContrastEnabled()

{
	HIGHCONTRAST hc = { sizeof(HIGHCONTRAST) };
	SystemParametersInfo(SPI_GETHIGHCONTRAST, sizeof(hc), &hc, 0);
	return (hc.dwFlags & HCF_HIGHCONTRASTON) != 0;
}

void CMyTabCtrl::OnPaint() 
{
	CPaintDC dc(this);
	dc.SelectObject(GetFont());

	DRAWITEMSTRUCT dis;
	dis.hDC = dc.GetSafeHdc();

	CRect rcClient;
	GetClientRect(&rcClient);

	const int nCount = GetItemCount();
	if (nCount == 0)
	{
		const COLORREF winTitleTextColor = m_bOnTitleBar ?
			CTitleBarHelper::GetTextColor(m_bActive) : getTextColor();
		dc.SetTextColor(winTitleTextColor);
		TCHAR szBuf[256];
		AfxGetMainWnd()->GetWindowText(szBuf, sizeof(szBuf) / sizeof(szBuf[0]));
		dc.DrawText(szBuf, -1, &rcClient, DT_LEFT | DT_VCENTER | DT_SINGLELINE);
	}

	int nCurSel = GetCurSel();
	for (int i = nCount - 1; i >= 0; --i)
	{
		GetItemRect(i, &dis.rcItem);
		dis.itemID = i;
		dis.rcItem.top = rcClient.top;
		dis.rcItem.bottom = rcClient.bottom;
		dis.itemState = (i != nCurSel) ? 0 : ODS_SELECTED;
		DrawItem(&dis);
	}
}

BOOL CMyTabCtrl::OnEraseBkgnd(CDC* pDC)
{
	CRect rClient;
	GetClientRect(rClient);
	pDC->FillSolidRect(rClient, GetBackColor());
	return TRUE;
}

/** 
 * @brief Called when tab selection is changed.
 */
BOOL CMyTabCtrl::OnSelchange(NMHDR* pNMHDR, LRESULT* pResult)
{
	TC_ITEM tci;
	tci.mask = TCIF_PARAM;
	GetItem(GetCurSel(), &tci);
	m_bInSelchange = true;
	m_pMainFrame->MDIActivate(FromHandle((HWND)tci.lParam));
	m_bInSelchange = false;

	return TRUE;
}

/**
 * @brief Show context menu and handle user selection.
 */
void CMyTabCtrl::OnContextMenu(CWnd *pWnd, CPoint point)
{
	CPoint ptClient = point;
	ScreenToClient(&ptClient);
	int index = GetItemIndexFromPoint(ptClient);
	if (index < 0)
		return;

	TCITEM tci;
	tci.mask = TCIF_PARAM;
	GetItem(index, &tci);
	CWnd* pMDIChild = FromHandle((HWND)tci.lParam);
	m_pMainFrame->MDIActivate(pMDIChild);
	CMenu* pPopup = pMDIChild->GetSystemMenu(FALSE);
	if (pPopup == nullptr) return;
	MENUITEMINFO mii = { sizeof MENUITEMINFO };
	if (!pPopup->GetMenuItemInfo(ID_CLOSE_OTHER_TABS, &mii, FALSE))
	{
		pPopup->AppendMenu(MF_SEPARATOR, 0, _T(""));
		pPopup->AppendMenu(MF_STRING, ID_TABBAR_AUTO_MAXWIDTH, _T(""));
		pPopup->AppendMenu(MF_SEPARATOR, 0, _T(""));
		pPopup->AppendMenu(MF_STRING, ID_CLOSE_OTHER_TABS, _T(""));
		pPopup->AppendMenu(MF_STRING, ID_CLOSE_RIGHT_TABS, _T(""));
		pPopup->AppendMenu(MF_STRING, ID_CLOSE_LEFT_TABS, _T(""));
	}
	pPopup->ModifyMenu(ID_TABBAR_AUTO_MAXWIDTH, MF_BYCOMMAND, ID_TABBAR_AUTO_MAXWIDTH, _("Enable &Auto Max Width").c_str());
	pPopup->ModifyMenu(ID_CLOSE_OTHER_TABS, MF_BYCOMMAND, ID_CLOSE_OTHER_TABS, _("Close &Other Tabs").c_str());
	pPopup->ModifyMenu(ID_CLOSE_RIGHT_TABS, MF_BYCOMMAND, ID_CLOSE_RIGHT_TABS, _("Close R&ight Tabs").c_str());
	pPopup->ModifyMenu(ID_CLOSE_LEFT_TABS, MF_BYCOMMAND, ID_CLOSE_LEFT_TABS, _("Close &Left Tabs").c_str());

	pPopup->CheckMenuItem(ID_TABBAR_AUTO_MAXWIDTH, m_bAutoMaxWidth ? MF_CHECKED : MF_UNCHECKED);
	// invoke context menu
	int command = pPopup->TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON | TPM_RETURNCMD, point.x, point.y,
		this);
	switch (command)
	{
	case ID_CLOSE_OTHER_TABS:
	case ID_CLOSE_RIGHT_TABS:
	case ID_CLOSE_LEFT_TABS: {
		int curcel = GetCurSel();
		int n = GetItemCount();
		TCITEM tci1;
		tci1.mask = TCIF_PARAM;
		for (int i = n - 1; i >= 0; --i)
		{
			if ((command == ID_CLOSE_OTHER_TABS && i == curcel) ||
				(command == ID_CLOSE_RIGHT_TABS && i <= curcel) ||
				(command == ID_CLOSE_LEFT_TABS  && i >= curcel))
				continue;
			GetItem(i, &tci1);
			CWnd* pMDIChild1 = FromHandle((HWND)tci1.lParam);
			pMDIChild1->SendMessage(WM_SYSCOMMAND, SC_CLOSE);
		}
		break;
	}
	case ID_TABBAR_AUTO_MAXWIDTH:
		m_bAutoMaxWidth = !m_bAutoMaxWidth;
		UpdateTabs();
		break;
	default:
		pMDIChild->SendMessage(WM_SYSCOMMAND, command);
	}
}

/**
 * @brief synchronize the tabs with all mdi client windows.
 */
void CMyTabCtrl::UpdateTabs()
{
	Invalidate();

	HWND hWndMDIActive = m_pMainFrame->MDIGetActive()->GetSafeHwnd();

	CMap<HWND, HWND, int, int> MDIFrameList;
	if (hWndMDIActive != nullptr) {
		for (CWnd *pFrame = m_pMainFrame->MDIGetActive()->GetParent()->GetTopWindow(); pFrame; pFrame = pFrame->GetNextWindow())
			MDIFrameList[pFrame->m_hWnd] = -1;
	}

	// Associate MDIFrameList with the index of the tab
	TC_ITEM tci;
	int item;
	for (item = GetItemCount() - 1; item >= 0 ; item--)
	{
		int dummy;
		tci.mask = TCIF_PARAM;
		GetItem(item, &tci);
		if (MDIFrameList.Lookup((HWND)tci.lParam, dummy))
		{
			MDIFrameList[(HWND)tci.lParam] = item;
			if (!m_bInSelchange && hWndMDIActive == (HWND)tci.lParam)
				SetCurSel(item);
		}
	}

	int nMaxTitleLength;
	if (m_bAutoMaxWidth)
		nMaxTitleLength = static_cast<int>(MDITABBAR_MAXTITLELENGTH - (MDIFrameList.GetCount() - 1) * 6);
	else
		nMaxTitleLength = MDITABBAR_MAXTITLELENGTH;
	if (nMaxTitleLength < MDITABBAR_MINTITLELENGTH)
		nMaxTitleLength = MDITABBAR_MINTITLELENGTH;

	// Update or insert tabs
	for (POSITION pos = MDIFrameList.GetStartPosition(); pos != nullptr; )
	{
		HWND hFrameWnd;
//~		int item;
		MDIFrameList.GetNextAssoc(pos, hFrameWnd, item);

		CString strTitle;
		CDocument *pDoc = ((CFrameWnd *)FromHandle(hFrameWnd))->GetActiveDocument();
		if (pDoc != nullptr)
			strTitle = pDoc->GetTitle();
		else
			FromHandle(hFrameWnd)->GetWindowText(strTitle);

		if (strTitle.GetLength() > nMaxTitleLength)
			strTitle = strTitle.Left(nMaxTitleLength - 3) + _T("...");

		// Escape the '&' to prevent it from being removed and underlining the next character in the string.
		strTitle.Replace(_T("&"), _T("&&"));

		if (item == -1)
		{
			tci.mask = TCIF_PARAM | TCIF_TEXT;
			tci.pszText = strTitle.LockBuffer();
			tci.lParam = (LPARAM)hFrameWnd;
			InsertItem(GetItemCount(), &tci);
			if (GetItemCount() == 1)
				m_pMainFrame->RecalcLayout();
			if (!m_bInSelchange && hWndMDIActive == (HWND)tci.lParam)
				SetCurSel(item);
		}
		else
		{
			TCHAR szText[256];
			szText[0] = '\0';
			tci.pszText = szText;
			tci.cchTextMax = static_cast<int>(std::size(szText));
			tci.mask = TCIF_TEXT;
			GetItem(item, &tci);
			if (tci.pszText && strTitle.Compare(tci.pszText) != 0)
			{
				tci.pszText = strTitle.LockBuffer();
				SetItem(item, &tci);
			}
		}
	}

	// Delete tabs
	for (item = GetItemCount() - 1; item >= 0 ; item--)
	{
		int dummy;
		tci.mask = TCIF_PARAM;
		GetItem(item, &tci);
		if (!MDIFrameList.Lookup((HWND)tci.lParam, dummy))
		{
			DeleteItem(item);
			if (GetItemCount() == 0)
				m_pMainFrame->RecalcLayout();
		}
	}

	m_nTooltipTabItemIndex = -1;
}

/**
 * @brief Called when middle mouse button is pressed.
 * This function closes the tab when the middle mouse button is pressed.
 */
void CMyTabCtrl::OnMButtonDown(UINT nFlags, CPoint point)
{
	int index = GetItemIndexFromPoint(point);
	if (index < 0)
		return;

	TCITEM tci;
	tci.mask = TCIF_PARAM;
	GetItem(index, &tci);
	CWnd* pMDIChild = FromHandle((HWND)tci.lParam);
	pMDIChild->SendMessage(WM_SYSCOMMAND, SC_CLOSE);
}

void CMyTabCtrl::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct)
{
	TCHAR            szBuf[256];
	TCITEM           item;
	LPDRAWITEMSTRUCT lpDraw = (LPDRAWITEMSTRUCT)lpDrawItemStruct;

	item.mask       = TCIF_TEXT | TCIF_PARAM;
	item.pszText    = szBuf;
	item.cchTextMax = sizeof(szBuf) / sizeof(TCHAR);
	GetItem(lpDraw->itemID, &item);

	const int lpx = ::GetDeviceCaps(lpDraw->hDC, LOGPIXELSX);
	auto pointToPixel = [lpx](int point) { return MulDiv(point, lpx, 72); };
	const int r = pointToPixel(RR_RADIUS);
	const int pd = pointToPixel(RR_PADDING);
	const int sw = pointToPixel(RR_SHADOWWIDTH);

	CRect rc = lpDraw->rcItem;
	if (lpDraw->itemState & ODS_SELECTED)
	{
		const COLORREF clrShadow = CEColor::GetIntermediateColor(GetSysColor(COLOR_3DSHADOW), GetBackColor(), 0.5f);
		if (IsHighContrastEnabled())
		{
			DrawRoundedRectWithShadow(lpDraw->hDC, rc.left + sw, rc.top + sw - 1, rc.Width() - sw * 2, rc.Height() - rc.top - sw * 2 + 2, r, sw,
				GetSysColor(COLOR_HIGHLIGHT), clrShadow, GetBackColor());
			SetTextColor(lpDraw->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
		}
		else
		{
			DrawRoundedRectWithShadow(lpDraw->hDC, rc.left + sw, rc.top + sw - 1, rc.Width() - sw * 2, rc.Height() - sw * 2 + 2, r, sw,
				GetSysColor(COLOR_3DHIGHLIGHT), clrShadow, GetBackColor());
			SetTextColor(lpDraw->hDC, getTextColor());
		}
	}
	else
	{
		const COLORREF txtclr = m_bOnTitleBar ?
			CTitleBarHelper::GetTextColor(m_bActive) : GetSysColor(COLOR_BTNTEXT);
		SetTextColor(lpDraw->hDC, txtclr);
	}
	CSize iconsize(determineIconSize(), determineIconSize());
	rc.left += sw + pd + iconsize.cx;
	SetBkMode(lpDraw->hDC, TRANSPARENT);
	HWND hwndFrame = reinterpret_cast<HWND>(item.lParam);
	if (::IsWindow(hwndFrame))
	{
		HICON hIcon = (HICON)::SendMessage(hwndFrame, WM_GETICON, ICON_SMALL2, 0);
		if (hIcon == nullptr)
			hIcon = (HICON)GetClassLongPtr(hwndFrame, GCLP_HICONSM);
		if (hIcon != nullptr)
			DrawIconEx(lpDraw->hDC, rc.left - iconsize.cx, rc.top + (rc.Height() - iconsize.cy) / 2, hIcon, iconsize.cx, iconsize.cy, 0, nullptr, DI_NORMAL);
	}
	rc.left += pd;
	rc.right -= pd;
	DrawText(lpDraw->hDC, szBuf, -1, &rc, DT_LEFT | DT_VCENTER | DT_SINGLELINE);

	int nItem = GetItemIndexFromPoint(m_rcCurrentCloseButtom.CenterPoint());
	if (static_cast<UINT>(nItem) == lpDraw->itemID)
	{
		CPoint pt;
		GetCursorPos(&pt);
		ScreenToClient(&pt);
		CRect rc1 = GetCloseButtonRect(nItem);
		DrawFrameControl(lpDraw->hDC, &rc1, DFC_CAPTION, 
			DFCS_CAPTIONCLOSE | DFCS_FLAT | (rc1.PtInRect(pt) ? DFCS_HOT : 0) |
			((m_bCloseButtonDown && rc1.PtInRect(pt)) ? DFCS_PUSHED : 0));
	}
}

void CMyTabCtrl::OnMouseMove(UINT nFlags, CPoint point)
{
	int nTabItemIndex = GetItemIndexFromPoint(point);
	CRect rc = GetCloseButtonRect(nTabItemIndex);
	if (rc != m_rcCurrentCloseButtom)
	{
		InvalidateRect(&rc);
		InvalidateRect(&m_rcCurrentCloseButtom);
	}
	m_rcCurrentCloseButtom = rc;
	if (!m_bMouseTracking)
	{
		TRACKMOUSEEVENT tme = { sizeof TRACKMOUSEEVENT };
		tme.dwFlags = TME_LEAVE;
		tme.hwndTrack = m_hWnd;
		TrackMouseEvent(&tme);
		m_bMouseTracking = true;
	}
	if (m_nDraggingTabItemIndex >= 0 && nTabItemIndex >= 0 && m_nDraggingTabItemIndex != nTabItemIndex)
	{
		CRect rectDraggingTab, rectDest;
		GetItemRect(m_nDraggingTabItemIndex, &rectDraggingTab);
		GetItemRect(nTabItemIndex, &rectDest);
		rectDest.right = rectDest.left + rectDraggingTab.Width();
		if (rectDest.PtInRect(point))
		{
			SwapTabs(m_nDraggingTabItemIndex, nTabItemIndex);
			m_nDraggingTabItemIndex = nTabItemIndex;
			m_rcCurrentCloseButtom = GetCloseButtonRect(nTabItemIndex);
			Invalidate();
		}
	}

	if (nTabItemIndex != m_nTooltipTabItemIndex)
		UpdateToolTips(nTabItemIndex);
}

void CMyTabCtrl::OnMouseLeave()
{
	TRACKMOUSEEVENT tme = { sizeof(TRACKMOUSEEVENT) };
	tme.dwFlags = TME_LEAVE | TME_CANCEL;
	tme.hwndTrack = m_hWnd;
	TrackMouseEvent(&tme);
	m_bMouseTracking = false;
	InvalidateRect(&m_rcCurrentCloseButtom);
	m_rcCurrentCloseButtom = CRect();
	m_bCloseButtonDown = false;
}

void CMyTabCtrl::OnLButtonDown(UINT nFlags, CPoint point)
{
	m_bCloseButtonDown = !!m_rcCurrentCloseButtom.PtInRect(point);
	InvalidateRect(m_rcCurrentCloseButtom);
	if (!m_bCloseButtonDown)
	{
		if (DragDetect(point))
		{
			m_nDraggingTabItemIndex = GetItemIndexFromPoint(point);
			SetCapture();
		}
		CWnd::OnLButtonDown(nFlags, point);
	}
}

void CMyTabCtrl::OnLButtonUp(UINT nFlags, CPoint point)
{
	if (m_nDraggingTabItemIndex >= 0)
	{
		m_nDraggingTabItemIndex = -1;
		ReleaseCapture();
	}
	else
	{
		if (m_bCloseButtonDown && m_rcCurrentCloseButtom.PtInRect(point))
			OnMButtonDown(nFlags, point);
		InvalidateRect(m_rcCurrentCloseButtom);
		m_bCloseButtonDown = false;
	}
	CWnd::OnLButtonUp(nFlags, point);
}

BOOL CMyTabCtrl::OnMouseWheel(UINT nFlags, short zDelta, CPoint point)
{
	// Rotating the mouse wheel while dragging: No action performed
	if (m_nDraggingTabItemIndex >= 0)
		return TRUE;

	// "Scroll forward" is wheel rotation towards the user
	const bool bIsScrollForward = zDelta < 0;

	const int nLastTabIndex = GetItemCount() - 1;

	// SHIFT + MOUSEWHEEL (UP/DOWN): Switches to the previous/next tab WITHOUT wraparound
	if (nFlags & MK_SHIFT)
	{
		int nSwitchToTabIndex = GetCurSel() + (bIsScrollForward ? 1 : -1);
		if (nSwitchToTabIndex < 0 || nSwitchToTabIndex > nLastTabIndex)
			return TRUE;

		ActivateTab(nSwitchToTabIndex);
	}

	// Otherwise, scroll the tab bar
	else
	{
		CRect rectTabCtrl, rectLastTab;
		GetClientRect(&rectTabCtrl);
		GetItemRect(nLastTabIndex, &rectLastTab);

		// Get index of the first visible tab
		CPoint pt(rectTabCtrl.left + 10, rectTabCtrl.Height() / 2);
		int nFirstVisibleTabIndex = GetItemIndexFromPoint(pt);

		if (nFirstVisibleTabIndex < 1 && rectLastTab.right < rectTabCtrl.right)  // No overflow
			return TRUE;

		// Get the width of the up/down control
		// This area may hide parts of the last tab and needs to be excluded
		CWnd* pUpDownCtrl = FindWindowEx(GetSafeHwnd(), nullptr, L"msctls_updown32", nullptr);
		if (!pUpDownCtrl)	// No up/down control also means no overflow
			return TRUE;

		CRect rectUpDownCtrl;
		pUpDownCtrl->GetWindowRect(&rectUpDownCtrl);

		// Scroll forward as long as the last tab is hidden; scroll backward till the first tab
		int nScrollTabIndex = nFirstVisibleTabIndex;
		if ((rectTabCtrl.right - rectLastTab.right) < rectUpDownCtrl.Width() || !bIsScrollForward)
		{
			nScrollTabIndex += (bIsScrollForward ? 1 : -1);
			if (nScrollTabIndex < 0 || nScrollTabIndex > nLastTabIndex)
				return TRUE;

			// Scroll tabs
			SendMessage(WM_HSCROLL, MAKEWPARAM(SB_THUMBPOSITION, nScrollTabIndex), 0);
		}
	}

	return TRUE;
}

CRect CMyTabCtrl::GetCloseButtonRect(int nItem)
{
	CClientDC dc(this);
	const int lpx = dc.GetDeviceCaps(LOGPIXELSX);
	auto pointToPixel = [lpx](int point) { return MulDiv(point, lpx, 72); };
	const int pd = pointToPixel(RR_PADDING);
	const int sw = pointToPixel(RR_SHADOWWIDTH);
	CRect rc, rcClient;
	CSize size(determineIconSize(), determineIconSize());
	GetClientRect(&rcClient);
	GetItemRect(nItem, &rc);
	rc.left = rc.right - size.cx - sw - pd;
	rc.right = rc.left + size.cx;
	int y = (rcClient.top + rcClient.bottom) / 2;
	rc.top = y - size.cy / 2 + 1;
	rc.bottom = rc.top + size.cy;
	return rc;
}

int CMyTabCtrl::GetItemIndexFromPoint(CPoint point) const
{
	TCHITTESTINFO hit;
	hit.pt = point;
	return HitTest(&hit);
}

void CMyTabCtrl::SwapTabs(int nIndexA, int nIndexB)
{
	TC_ITEM tciA = {0}, tciB = {0};
	TCHAR szTextA[256], szTextB[256];
	int nCurSel = GetCurSel();

	tciA.cchTextMax = sizeof(szTextA)/sizeof(szTextA[0]);
	tciB.cchTextMax = sizeof(szTextB)/sizeof(szTextB[0]);
	tciA.pszText = szTextA;
	tciB.pszText = szTextB;
	tciA.mask = tciB.mask = TCIF_PARAM | TCIF_TEXT;

	GetItem(nIndexA, &tciA);
	GetItem(nIndexB, &tciB);

	std::swap(tciA, tciB);

	SetItem(nIndexB, &tciB);
	SetItem(nIndexA, &tciA);

	if (nCurSel == nIndexA)
		SetCurSel(nIndexB);
	if (nCurSel == nIndexB)
		SetCurSel(nIndexA);
}

/**
 * @brief Get the maximum length of the title.
 */
int CMyTabCtrl::GetMaxTitleLength() const
{
	int nMaxTitleLength = m_bAutoMaxWidth ? static_cast<int>(MDITABBAR_MAXTITLELENGTH - (GetItemCount() - 1) * 6) : MDITABBAR_MAXTITLELENGTH;
	if (nMaxTitleLength < MDITABBAR_MINTITLELENGTH)
		nMaxTitleLength = MDITABBAR_MINTITLELENGTH;

	return nMaxTitleLength;
}

/**
 * @brief Update tooltip text.
 * @param [in] nTabItemIndex Index of the tab displaying tooltip.
 */
void CMyTabCtrl::UpdateToolTips(int nTabItemIndex)
{
	TC_ITEM tci;
	tci.mask = TCIF_PARAM;
	GetItem(nTabItemIndex, &tci);

	if (!m_pMainFrame)
		return;
	CMDIChildWnd* pActiveWnd = m_pMainFrame->MDIGetActive();
	if (!pActiveWnd)
		return;
	CWnd* pParentWnd = pActiveWnd->GetParent();
	if (!pParentWnd)
		return;

	for (CWnd* pFrame = pParentWnd->GetTopWindow(); pFrame; pFrame = pFrame->GetNextWindow())
	{
		if (reinterpret_cast<HWND>(tci.lParam) == pFrame->m_hWnd)
		{
			HWND hFrameWnd = pFrame->m_hWnd;
			CString strTitle, strTooltip;
			CFrameWnd* pFrameWnd = (CFrameWnd*)FromHandle(hFrameWnd);
			CDocument* pDoc = pFrameWnd->GetActiveDocument();
			IMDITab* pITabBar = nullptr;
			if (pDoc != nullptr)
			{
				strTitle = pDoc->GetTitle();
				pITabBar = dynamic_cast<IMDITab*>(pDoc);
			}
			else
			{
				pFrameWnd->GetWindowText(strTitle);
				pITabBar = dynamic_cast<IMDITab*>(pFrameWnd);
			}
			strTooltip = pITabBar ? pITabBar->GetTooltipString() : _T("");

			if (strTooltip == strTitle && strTitle.GetLength() <= GetMaxTitleLength())
				strTooltip.Empty();

			constexpr size_t MAX_TIP_TEXT_LENGTH = 1024;
			if (strTooltip.GetLength() > MAX_TIP_TEXT_LENGTH)
				strTooltip.Truncate(MAX_TIP_TEXT_LENGTH);

			m_tooltips.UpdateTipText(strTooltip, this);
			CRect rc;
			GetClientRect(&rc);
			m_tooltips.SetMaxTipWidth(rc.Width() * 60 / 100);
			m_nTooltipTabItemIndex = nTabItemIndex;
			return;
		}
	}
}

BOOL CMDITabBar::Update(bool bOnTitleBar, bool bMaximized)
{
	m_bOnTitleBar = bOnTitleBar;
	m_titleBar.SetMaximized(bMaximized);
	m_tabCtrl.SetOnTitleBar(bOnTitleBar);
	return true;
}

void CMDITabBar::UpdateActive(bool bActive)
{
	if (m_tabCtrl.GetActive() != bActive)
	{
		m_tabCtrl.SetActive(bActive);
		Invalidate();
	}
}

/** 
 * @brief Create tab bar.
 * @param pParentWnd [in] main frame window pointer
 */
BOOL CMDITabBar::Create(CMDIFrameWnd* pMainFrame)
{
	m_dwStyle = CBRS_TOP;

	m_titleBar.Init(this);

	CWnd::Create(nullptr, nullptr, WS_CHILD | WS_VISIBLE, CRect(0, 0, 0, 0), pMainFrame, AFX_IDW_CONTROLBAR_LAST - 1);

	if (!m_tabCtrl.Create(pMainFrame, this))
		return FALSE;

	CClientDC dc(this);
	const int lpx = dc.GetDeviceCaps(LOGPIXELSX);
	auto pointToPixel = [lpx](int point) { return MulDiv(point, lpx, 72); };
	const int pd = pointToPixel(RR_PADDING);
	const int sw = pointToPixel(RR_SHADOWWIDTH);
	m_tabCtrl.SetPadding(CSize(sw + pd * 2 + determineIconSize() / 2, sw + pd));

	NONCLIENTMETRICS ncm = { sizeof NONCLIENTMETRICS };
	SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof NONCLIENTMETRICS, &ncm, 0);
	m_font.CreateFontIndirect(&ncm.lfMenuFont);
	m_tabCtrl.SetFont(&m_font);

	return TRUE;
}

/**
 * @brief Get tab item index from point
 */
int CMDITabBar::GetItemIndexFromPoint(CPoint point, bool bRelatively) const
{
	if (bRelatively)
	{
		CRect rcTabCtrl;
		m_tabCtrl.GetClientRect(&rcTabCtrl);

		m_tabCtrl.ScreenToClient(&point);
		point.y = rcTabCtrl.Height() / 2;
	}

	TCHITTESTINFO hit;
	hit.pt = point;
	return m_tabCtrl.HitTest(&hit);
}

/**
 * @brief Forward mouse events to the tab control if needed.
 */
bool CMDITabBar::ForwardMouseEventToTabCtrlIfNeeded(CPoint& point, UINT message)
{
	if (!(m_bOnTitleBar && m_titleBar.GetMaximized()))
		return false;

	int nItemHitTest = GetItemIndexFromPoint(point, true);
	if (nItemHitTest == -1)
		return false;

	CRect rcHitItem;
	m_tabCtrl.GetItemRect(nItemHitTest, &rcHitItem);
	m_tabCtrl.ScreenToClient(&point);

	if (point.y <= rcHitItem.top)
		point.y = rcHitItem.top + 1;
	else if (point.y >= rcHitItem.bottom)
		point.y = rcHitItem.bottom - 1;

	switch (message)
	{
	case WM_LBUTTONDOWN:
	case WM_LBUTTONUP:
		m_tabCtrl.SendMessage(message, MK_LBUTTON, MAKELPARAM(point.x, point.y));
		break;
	case WM_CONTEXTMENU:
		m_tabCtrl.SendMessage(WM_CONTEXTMENU, (WPARAM)m_tabCtrl.m_hWnd, MAKELPARAM(point.x, point.y));
		break;
	default:
		break;
	}

	return true;
}

/** 
 * @brief This method calculates the horizontal size of a control bar.
 */
CSize CMDITabBar::CalcFixedLayout(BOOL bStretch, BOOL bHorz)
{
	if (!m_bOnTitleBar && m_tabCtrl.GetItemCount() == 0)
		return CSize(SHRT_MAX, 0);
	
	TEXTMETRIC tm;
	CClientDC dc(this);
	CFont *pOldFont = dc.SelectObject(&m_font);
	dc.GetTextMetrics(&tm);
	dc.SelectObject(pOldFont);

	const int lpx = dc.GetDeviceCaps(LOGPIXELSX);
	auto pointToPixel = [lpx](int point) { return MulDiv(point, lpx, 72); };
	const int pd = pointToPixel(RR_PADDING);
	const int sw = pointToPixel(RR_SHADOWWIDTH);
	int my = m_bOnTitleBar ? (m_titleBar.GetTopMargin() + 2) : 0;
	CSize size(SHRT_MAX, my + tm.tmHeight + (sw + pd) * 2);
	return size;
}

LRESULT CMDITabBar::OnNcHitTest(CPoint point)
{
	if (!m_bOnTitleBar)
		return __super::OnNcHitTest(point);
	return m_titleBar.OnNcHitTest(point);
}

void CMDITabBar::OnNcMouseMove(UINT nHitTest, CPoint point)
{
	m_titleBar.OnNcMouseMove(nHitTest, point);
}

void CMDITabBar::OnNcMouseLeave()
{
	m_titleBar.OnNcMouseLeave();
}

void CMDITabBar::OnNcLButtonDblClk(UINT nHitTest, CPoint point)
{
	m_titleBar.OnNcLButtonDblClk(nHitTest, point);
}

void CMDITabBar::OnNcLButtonDown(UINT nHitTest, CPoint point)
{
	if (ForwardMouseEventToTabCtrlIfNeeded(point, WM_LBUTTONDOWN))
		return;
	m_titleBar.OnNcLButtonDown(nHitTest, point);
}

void CMDITabBar::OnNcLButtonUp(UINT nHitTest, CPoint point)
{
	if (ForwardMouseEventToTabCtrlIfNeeded(point, WM_LBUTTONUP))
		return;
	m_titleBar.OnNcLButtonUp(nHitTest, point);
}

void CMDITabBar::OnNcRButtonDown(UINT nHitTest, CPoint point)
{
	m_titleBar.OnNcRButtonDown(nHitTest, point);
}

void CMDITabBar::OnNcRButtonUp(UINT nHitTest, CPoint point)
{
	if (ForwardMouseEventToTabCtrlIfNeeded(point, WM_CONTEXTMENU))
		return;
	m_titleBar.OnNcRButtonUp(nHitTest, point);
}

void CMDITabBar::OnSize(UINT nType, int cx, int cy)
{
	__super::OnSize(nType, cx, cy);
	m_titleBar.SetSize(cx, cy);
	if (m_tabCtrl.m_hWnd)
	{
		const int leftMargin = m_bOnTitleBar ? m_titleBar.GetLeftMargin() : 0;
		const int rightMargin = m_bOnTitleBar ? m_titleBar.GetRightMargin() : 0;
		const int topMargin = ((m_titleBar.GetMaximized() && m_bOnTitleBar) ? m_titleBar.GetTopMargin() : 0) + (m_bOnTitleBar ? 1 : 0);
		const int bottomMargin = m_bOnTitleBar ? 1 : 0;
		CSize size{ 0, cy - topMargin - bottomMargin };
		m_tabCtrl.MoveWindow(leftMargin, topMargin, cx - leftMargin - rightMargin, cy - topMargin - bottomMargin, true);
		m_tabCtrl.SetItemSize(size);
	}
}

BOOL CMDITabBar::OnEraseBkgnd(CDC* pDC)
{
	CRect rClient;
	GetClientRect(rClient);
	pDC->FillSolidRect(rClient, m_tabCtrl.GetBackColor());
	return TRUE;
}

void CMDITabBar::OnPaint()
{
	if (!m_bOnTitleBar)
		return __super::OnPaint();
	CPaintDC dc(this);
	m_titleBar.DrawIcon(AfxGetMainWnd(), dc, m_tabCtrl.GetActive());
	m_titleBar.DrawButtons(dc, CTitleBarHelper::GetTextColor(m_tabCtrl.GetActive()), m_tabCtrl.GetBackColor());
}
</file>

<file path="Winmerge-Src/Src/Common/MDITabBar.h">
/** 
 * @file  MDITabBar.h
 *
 * @brief Declaration file for MDITabBar
 *
 */
#pragma once

#include "TitleBarHelper.h"

class CMyTabCtrl : public CTabCtrl
{
	enum { MDITABBAR_MINTITLELENGTH = 8, MDITABBAR_MAXTITLELENGTH = 64 };

	DECLARE_DYNAMIC(CMyTabCtrl)
public:
	CMyTabCtrl()
		: m_bMouseTracking(false)
		, m_bAutoMaxWidth(true)
		, m_pMainFrame(nullptr)
		, m_bCloseButtonDown(false)
		, m_nDraggingTabItemIndex(-1)
		, m_bInSelchange(false)
		, m_nTooltipTabItemIndex(-1)
		, m_bOnTitleBar(false)
		, m_bActive(false)
	{}

protected:
	bool m_bInSelchange;
	bool  m_bAutoMaxWidth;
	bool m_bMouseTracking;
	bool m_bCloseButtonDown;
	bool m_bOnTitleBar;
	bool m_bActive;
	CRect m_rcCurrentCloseButtom;
	int   m_nDraggingTabItemIndex;
	int   m_nTooltipTabItemIndex;	/**< Index of the tab displaying tooltip */
	CMDIFrameWnd *m_pMainFrame;
	CToolTipCtrl m_tooltips;		/**< Tooltip for the tab */

public:
	BOOL Create(CMDIFrameWnd* pMainFrame, CWnd* pParent);
	bool GetAutoMaxWidth() const { return m_bAutoMaxWidth; }
	void SetAutoMaxWidth(bool bAutoMaxWidth) { m_bAutoMaxWidth = bAutoMaxWidth; }
	void UpdateTabs();
	void SetOnTitleBar(bool onTitleBar) { m_bOnTitleBar = onTitleBar; }
	bool GetActive() const { return m_bActive; }
	void SetActive(bool bActive);
	void ActivateTab(int nTabIndex);
	COLORREF GetBackColor() const;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMyTabCtrl)
	//}}AFX_VIRTUAL
// Implementation
public:
	virtual ~CMyTabCtrl() {}

// Generated message map functions
protected:
	virtual BOOL PreTranslateMessage(MSG* pMsg);

	//{{AFX_MSG(CMyTabCtrl)
	afx_msg void OnPaint();
	afx_msg BOOL OnEraseBkgnd(CDC *pDC);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnMButtonDown(UINT nFlags, CPoint point);
	afx_msg BOOL OnSelchange(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnMouseLeave();
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg BOOL OnMouseWheel(UINT nFlags, short zDelta, CPoint point);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

	CRect GetCloseButtonRect(int nItem);
	int GetItemIndexFromPoint(CPoint pt) const;
	void SwapTabs(int nIndexA, int nIndexB);
	int GetMaxTitleLength() const;
	void UpdateToolTips(int index);
};

/**
 * @brief Class for Tab bar.
 */
class CMDITabBar : public CControlBar
{
	DECLARE_DYNAMIC(CMDITabBar)

private:

	bool m_bOnTitleBar;
	CMyTabCtrl m_tabCtrl;
	CFont m_font;
	CTitleBarHelper m_titleBar;

public:
	CMDITabBar()
		: m_bOnTitleBar(true)
	{}
	virtual ~CMDITabBar() {}
	BOOL Update(bool bOnTitleBar, bool bMaxmized);
	void UpdateActive(bool bActive);
	BOOL Create(CMDIFrameWnd* pParentWnd);
	void UpdateTabs() { m_tabCtrl.UpdateTabs(); }
	bool GetAutoMaxWidth() const { return m_tabCtrl.GetAutoMaxWidth(); }
	void SetAutoMaxWidth(bool bAutoMaxWidth) { m_tabCtrl.SetAutoMaxWidth(bAutoMaxWidth); }
	int GetItemCount() const { return m_tabCtrl.GetItemCount(); }
	int GetItemIndexFromPoint(CPoint point, bool bRelatively) const;
	bool ForwardMouseEventToTabCtrlIfNeeded(CPoint& point, UINT message);

	virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler) {}
	virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz);

protected:

	//{{AFX_MSG(CMDITabBar)
	afx_msg LRESULT OnNcHitTest(CPoint point);
	afx_msg void OnNcMouseMove(UINT nHitTest, CPoint point);
	afx_msg void OnNcMouseLeave();
	afx_msg void OnNcLButtonDblClk(UINT nHitTest, CPoint point);
	afx_msg void OnNcLButtonDown(UINT nHitTest, CPoint point);
	afx_msg void OnNcLButtonUp(UINT nHitTest, CPoint point);
	afx_msg void OnNcRButtonDown(UINT nHitTest, CPoint point);
	afx_msg void OnNcRButtonUp(UINT nHitTest, CPoint point);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnPaint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
};
</file>

<file path="Winmerge-Src/Src/Common/memdc.h">
#pragma once

//////////////////////////////////////////////////
// CMemDC - memory DC
//
// Author: Keith Rule
// Email:  keithr@europa.com
// Copyright 1996-2002, Keith Rule
//
// You may freely use or modify this code provided this
// Copyright is included in all derived versions.
//
// History - 10/3/97 Fixed scrolling bug.
//                   Added print support. - KR
//
//           11/3/99 Fixed most common complaint. Added
//                   background color fill. - KR
//
//           11/3/99 Added support for mapping modes other than
//                   MM_TEXT as suggested by Lee Sang Hun. - KR
//
//           02/11/02 Added support for CScrollView as supplied
//                    by Gary Kirkham. - KR
//
// This class implements a memory Device Context which allows
// flicker free drawing.

class CMyMemDC : public CDC {
private:	
	CBitmap		m_bitmap;		// Offscreen bitmap
	CBitmap*	m_oldBitmap;	// bitmap originally found in CMemDC
	CDC*		m_pDC;			// Saves CDC passed in constructor
	CRect		m_rect;			// Rectangle of drawing area.
	bool		m_bMemDC;		// `true` if CDC really is a Memory DC.
public:
	
	explicit CMyMemDC(CDC* pDC, const CRect* pRect = nullptr) : CDC()
	{
		ASSERT(pDC != nullptr); 

		// Some initialization
		m_pDC = pDC;
		m_oldBitmap = nullptr;
		m_bMemDC = !pDC->IsPrinting();

		// Get the rectangle to draw
		if (pRect == nullptr) {
			pDC->GetClipBox(&m_rect);
		} else {
			m_rect = *pRect;
		}

		if (m_bMemDC) {
			// Create a Memory DC
			CreateCompatibleDC(pDC);
			pDC->LPtoDP(&m_rect);

			m_bitmap.CreateCompatibleBitmap(pDC, m_rect.Width(), m_rect.Height());
			m_oldBitmap = SelectObject(&m_bitmap);

			SetMapMode(pDC->GetMapMode());

			SetWindowExt(pDC->GetWindowExt());
			SetViewportExt(pDC->GetViewportExt());

			pDC->DPtoLP(&m_rect);
			SetWindowOrg(m_rect.left, m_rect.top);
		} else {
			// Make a copy of the relevant parts of the current DC for printing
			m_bPrinting = pDC->m_bPrinting;
			m_hDC       = pDC->m_hDC;
			m_hAttribDC = pDC->m_hAttribDC;
		}

		// Fill background 
		FillSolidRect(m_rect, pDC->GetBkColor());
	}
	
	~CMyMemDC()	
	{		
		if (m_bMemDC) {
			// Copy the offscreen bitmap onto the screen.
			m_pDC->BitBlt(m_rect.left, m_rect.top, m_rect.Width(), m_rect.Height(),
				this, m_rect.left, m_rect.top, SRCCOPY);			
			
			//Swap back the original bitmap.
			SelectObject(m_oldBitmap);		
		} else {
			// All we need to do is replace the DC with an illegal value,
			// this keeps us from accidently deleting the handles associated with
			// the CDC that was passed to the constructor.			
			m_hDC = m_hAttribDC = nullptr;
		}	
	}
	
	// Allow usage as a pointer	
	CMyMemDC* operator->() 
	{
		return this;
	}	

	// Allow usage as a pointer	
	operator CMyMemDC*() 
	{
		return this;
	}
};
</file>

<file path="Winmerge-Src/Src/Common/MessageBoxDialog.h">
/*
 *	Extended MFC message boxes -- Version 1.1a
 *	Copyright (c) 2004 Michael P. Mehl. All rights reserved.
 *
 *	The contents of this file are subject to the Mozilla Public License
 *	Version 1.1a (the "License"); you may not use this file except in
 *	compliance with the License. You may obtain a copy of the License at 
 *	http://www.mozilla.org/MPL/.
 *
 *	Software distributed under the License is distributed on an "AS IS" basis,
 *	WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 *	for the specific language governing rights and limitations under the
 *	License. 
 *
 *	The Original Code is Copyright (c) 2004 Michael P. Mehl. All rights
 *	reserved. The Initial Developer of the Original Code is Michael P. Mehl
 *	<michael.mehl@web.de>.
 *
 *	Alternatively, the contents of this file may be used under the terms of
 *	the GNU Lesser General Public License Version 2.1 (the "LGPL License"),
 *	in which case the provisions of LGPL License are applicable instead of
 *	those above. If you wish to allow use of your version of this file only
 *	under the terms of the LGPL License and not to allow others to use your
 *	version of this file under the MPL, indicate your decision by deleting
 *	the provisions above and replace them with the notice and other provisions
 *	required by the LGPL License. If you do not delete the provisions above,
 *	a recipient may use your version of this file under either the MPL or
 *	the LGPL License.
 */

#pragma once

#include "resource.h"
#include "UnicodeString.h"
#include <vector>

//////////////////////////////////////////////////////////////////////////////
// Message box style definitions (mostly taken from WinUser.h).

#ifndef MB_CANCELTRYCONTINUE
#define MB_CANCELTRYCONTINUE		0x00000006L	// Standard for Win 5.x.
#endif

#define MB_CONTINUEABORT			0x00000007L	// Additional style.
#define MB_SKIPSKIPALLCANCEL		0x00000008L	// Additional style.
#define MB_IGNOREIGNOREALLCANCEL	0x00000009L	// Additional style.

#define MB_DONT_DISPLAY_AGAIN		0x01000000L	// Additional style.
#define MB_DONT_ASK_AGAIN			0x02000000L	// Additional style.
#define MB_YES_TO_ALL				0x04000000L	// Additional style.
#define MB_NO_TO_ALL				0x08000000L	// Additional style.

#define MB_DEFAULT_CHECKED			0x10000000L // Additional style.
#define MB_RIGHT_ALIGN				0x20000000L	// Additional style.
#define MB_NO_SOUND					0x40000000L	// Additional style.

#define MB_MODELESS					0x80000000L	// Additional style.

#define MB_DEFBUTTON5				0x00000400L	// Additional style.
#define MB_DEFBUTTON6				0x00000500L	// Additional style.

//////////////////////////////////////////////////////////////////////////////
// Dialog element IDs.

#ifndef IDTRYAGAIN
#define IDTRYAGAIN					10			// Standard for Win 5.x.
#endif

#ifndef IDCONTINUE
#define IDCONTINUE					11			// Standard for Win 5.x.
#endif

#define IDYESTOALL					14			// Additional element.
#define IDNOTOALL					15			// Additional element.
#define IDSKIP						16			// Additional element.
#define IDSKIPALL					17			// Additional element.
#define IDIGNOREALL					18			// Additional element.
#define IDCHECKBOX					19			// Additional element.

//////////////////////////////////////////////////////////////////////////////
// Name of the registry section for storing the message box results.

#define REGISTRY_SECTION_MESSAGEBOX	_T("MessageBoxes")

//////////////////////////////////////////////////////////////////////////////
// Class definition.

class CMessageBoxDialog : public CDialog
{

	DECLARE_DYNAMIC(CMessageBoxDialog)

public:

	//////////////////////////////////////////////////////////////////////////
	// Constructors and destructors of the class.

	// Constructor of the class for direct providing of the message strings.
	CMessageBoxDialog ( CWnd* pParent, CString strMessage, 
		CString strTitle = _T(""), UINT nStyle = MB_OK, UINT nHelp = 0, const CString& strRegistryKey = _T("") );

	// Constructor of the class for loading the strings from the resources.
	CMessageBoxDialog ( CWnd* pParent, UINT nMessageID, UINT nTitleID = 0,
		UINT nStyle = MB_OK, UINT nHelp = 0, const CString& strRegistryKey = _T("") );

	// Default destructor of the class.
	virtual ~CMessageBoxDialog ( );

	enum { IDD = IDD_MESSAGE_BOX };

public:

	//////////////////////////////////////////////////////////////////////////
	// Methods for setting and retrieving dialog options.

	// Method for setting the style of the message box.
	void SetStyle ( UINT nStyle );

	// Method for retrieving the style of the message box.
	UINT GetStyle ( );

	// Methods for setting the message to be displayed in the message box.
	void SetMessage ( LPCTSTR strMessage );
	void SetMessage ( UINT nMessageID );

	// Method for retrieving the message to be displayed in the message box.
	const String &GetMessage ( );

	// Methods for setting the title to be displayed in the message box.
	void SetTitle ( LPCTSTR strTitle );
	void SetTitle ( UINT nTitleID );

	// Method for retrieving the title to be displayed in the message box.
	const String &GetTitle ( );

	// Methods for setting the icon to be displayed in the message box.
	void SetMessageIcon ( HICON hIcon );
	void SetMessageIcon ( UINT nIconID );

	// Method for retrieving the icon to be displayed in the message box.
	HICON GetMessageIcon ( );

	// Method for setting a timeout.
	void SetTimeout ( UINT nSeconds, bool bDisabled = false );

	// Method for retrieving the seconds for the timeout.
	UINT GetTimeoutSeconds ( );

	// Method for retrieving whether a timeout is disabled.
	bool GetTimeoutDisabled ( );

	// Method for retrieving the former result of the message box from the registry.
	int GetFormerResult();
	// Method for storing the former result of the message box to the registry.
	int SetFormerResult(int nResult);

public:

	//////////////////////////////////////////////////////////////////////////
	// Methods for handling the stored states.

	// Method for resetting the message boxes stored in the registry.
	static void ResetMessageBoxes ( );
	static CString GenerateRegistryKey (UINT nMessageID, UINT nHelpID);

public:

	//////////////////////////////////////////////////////////////////////////
	// Methods for handling common window functions.

	// Method for displaying the dialog.
	virtual INT_PTR DoModal ( );

	// Method for closing the dialog.
	void EndDialog ( int nResult );

	// Method for initializing the dialog.
	virtual BOOL OnInitDialog ( );

	// Method for handling command messages.
	virtual BOOL OnCmdMsg ( UINT nID, int nCode, void* pExtra,
		AFX_CMDHANDLERINFO* pHandlerInfo );

	// Method for handling messages before dispatching them.
	virtual BOOL PreTranslateMessage ( MSG* pMsg );

	// Method for handling a timer event.
	afx_msg void OnTimer ( UINT_PTR nIDEvent );
	afx_msg BOOL OnEraseBkgnd( CDC* pDC );
	afx_msg HBRUSH OnCtlColor( CDC* pDC, CWnd* pWnd, UINT nCtlColor );

protected:

	//////////////////////////////////////////////////////////////////////////
	// Other methods for handling common window functions.

	// Method for handling window messages.
	virtual BOOL OnWndMsg ( UINT message, WPARAM wParam, LPARAM lParam,
		LRESULT* pResult );

	DECLARE_MESSAGE_MAP()

private:

	//////////////////////////////////////////////////////////////////////////
	// Private member variables of this dialog.

	String		m_strMessage;		// Message to be displayed.
	String		m_strTitle;			// Title to be used.
	UINT		m_nStyle;			// Style of the message box.
	UINT		m_nHelp;			// Help context of the message box.

	HICON		m_hIcon;			// Icon to be displayed in the dialog.

	UINT		m_nTimeoutSeconds;	// Seconds for a timeout.
	bool		m_bTimeoutDisabled;	// Flag whether the timeout is disabled.
	UINT_PTR	m_nTimeoutTimer;	// Timer for the timeout.

	CString		m_strRegistryKey;	// Entry for storing the result in the
									// registry, if the MB_DONT_DISPLAY_AGAIN
									// or MB_DONT_ASK_AGAIN flag is given.
	CFont       m_font;
	CFont       m_fontMainInstruction;
	COLORREF    m_clrMainInstructionFont;

private:

	//////////////////////////////////////////////////////////////////////////
	// Control handling types and variables.

	typedef struct tagMSGBOXBTN
	{
		UINT	nID;				// ID of a dialog button.
		UINT	nTitle;				// ID of the title string resource.
	} MSGBOXBTN;

    std::vector<MSGBOXBTN> m_aButtons;
									// List of all buttons in the dialog.

	int			m_nDefaultButton;	// ID of the default button.
	int			m_nEscapeButton;	// ID of the escape button.

	CStatic		m_stcIcon;			// Static control for the icon.
	CStatic		m_stcMessage;		// Static control for the message.
	CToolTipCtrl	m_tooltips;

private:

	//////////////////////////////////////////////////////////////////////////
	// Size handling variables.

	CSize		m_sDialogUnit;		// Variable for the size of a dialog unit.
	CSize		m_sIcon;			// Variable for the size of the icon.
	CSize		m_sMessage;			// Variable for the size of the message.
	CSize		m_sCheckbox;		// Variable for the size of the checkbox.
	CSize		m_sButton;			// Variable for the size of a button.

private:

	//////////////////////////////////////////////////////////////////////////
	// Helper methods.
	
	// Method for generating the registry key.
	CString	GenerateRegistryKey ( );

	// Method for adding a button to the list of buttons.
	void AddButton ( UINT nID, UINT nTitle, bool bIsDefault = false,
		bool bIsEscape = false );

	// Methods for converting a dialog units to a pixel values.
	int XDialogUnitToPixel ( int x );
	int YDialogUnitToPixel ( int y );

	// Method for parsing the given style.
	void ParseStyle ( );

	// Method for creating the icon control.
	void CreateIconControl ( );

	// Method for creating the message control.
	void CreateMessageControl ( );

	// Method for creating the checkbox control.
	void CreateCheckboxControl ( );

	// Method for creating the button controls.
	void CreateButtonControls ( );

	// Method for defining the layout of the dialog.
	void DefineLayout ( );

};
</file>

<file path="Winmerge-Src/Src/Common/multiformatText.cpp">
/////////////////////////////////////////////////////////////////////////////
//    WinMerge:  an interactive diff/merge utility
//    Copyright (C) 1997-2000  Thingamahoochie Software
//    Author: Dean Grimm
//    SPDX-License-Identifier: GPL-2.0-or-later
/////////////////////////////////////////////////////////////////////////////
/**
 * @file multiformatText.cpp
 *
 * @brief Implementation of class storageForPlugins
 *
 * @date  Created: 2003-11-24
 */ 

#include "pch.h"
#define NOMINMAX
#include "multiformatText.h"
#include <algorithm>
#include <cstring>
#include <cassert>
#include <memory>
#include <Poco/SharedMemory.h>
#include <Poco/FileStream.h>
#include <Poco/ByteOrder.h>
#include <Poco/Buffer.h>
#include <Poco/Exception.h>
#include "unicoder.h"
#include "ExConverter.h"
#include "paths.h"
#include "UniFile.h"
#include "codepage_detect.h"
#include "Environment.h"
#include "TFile.h"
#include "Logger.h"

using Poco::SharedMemory;
using Poco::FileOutputStream;
using Poco::ByteOrder;
using Poco::Exception;
using Poco::Buffer;

////////////////////////////////////////////////////////////////////////////////

static void *GetVariantArrayData(VARIANT& array, unsigned& size)
{
	char * parrayData;
	SafeArrayAccessData(array.parray, (void**)&parrayData);
	LONG ubound, lbound;
	SafeArrayGetLBound(array.parray, 1, &lbound);
	SafeArrayGetUBound(array.parray, 1, &ubound);
	size = ubound - lbound;
	return parrayData;
}

void storageForPlugins::Initialize()
{
	SysFreeString(m_bstr);
	m_bstr = nullptr;
	VariantClear(&m_array);
	m_tempFilenameDst.clear();
}

void storageForPlugins::SetDataFileAnsi(const String& filename, bool bOverwrite /*= false*/) 
{
	FileTextEncoding encoding;
	encoding.SetUnicoding(ucr::NONE);
	encoding.SetCodepage(ucr::getDefaultCodepage());
	SetDataFileEncoding(filename, encoding, bOverwrite); 
}
void storageForPlugins::SetDataFileEncoding(const String& filename, const FileTextEncoding& encoding, bool bOverwrite /*= false*/)
{
	m_filename = filename;
	m_nChangedValid = 0;
	m_nChanged = 0;
	if (encoding.m_unicoding != ucr::NONE && encoding.m_unicoding != ucr::UTF8)
		m_bOriginalIsUnicode = m_bCurrentIsUnicode = true;
	else
		m_bOriginalIsUnicode = m_bCurrentIsUnicode = false;
	m_bCurrentIsFile = true;
	m_bOverwriteSourceFile = bOverwrite;
	m_codepage = encoding.m_codepage;
	m_nBomSize = encoding.m_bom ? ucr::getBomSize(encoding.m_unicoding) : 0;
	Initialize();
}
void storageForPlugins::SetDataFileUnknown(const String& filename, bool bOverwrite /*= false*/) 
{
	FileTextEncoding encoding = codepage_detect::Guess(filename, 1);
	SetDataFileEncoding(filename, encoding, bOverwrite);
}

const tchar_t *storageForPlugins::GetDestFileName()
{
	if (m_tempFilenameDst.empty())
	{
		m_tempFilenameDst = env::GetTemporaryFileName(env::GetTemporaryPath(), _T ("_WM"));
		if (!m_tempFileExtensionDst.empty())
		{
			String tempFilenameDstNew = m_tempFilenameDst + m_tempFileExtensionDst;
			try
			{
				TFile(m_tempFilenameDst).renameTo(tempFilenameDstNew);
				m_tempFilenameDst = std::move(tempFilenameDstNew);
			}
			catch (Exception& e)
			{
				RootLogger::Error(e.displayText());
			}
		}
	}
	return m_tempFilenameDst.c_str();
}


void storageForPlugins::ValidateNewFile()
{
	// changed data are : file, nChanged
	// nChanged passed as pointer so already upToDate
	// now update file
	if (m_nChangedValid == m_nChanged)
	{
		// plugin succeeded, but nothing changed, just delete the new file
		try
		{
			TFile(m_tempFilenameDst).remove();
		}
		catch (Exception& e)
		{
			RootLogger::Error(e.displayText());
		}
		// we may reuse the temp filename
		// tempFilenameDst.Empty();
	}
	else
	{
		m_nChangedValid = m_nChanged;
		if (m_bOverwriteSourceFile)
		{
			try
			{
				TFile(m_filename).remove();
				TFile(m_tempFilenameDst).renameTo(m_filename);
			}
			catch (Exception& e)
			{
				RootLogger::Error(e.displayText());
			}
		}
		else
		{
			// do not delete the original file name
			m_filename = m_tempFilenameDst;
			// for next transformation, we may overwrite/delete the source file
			m_bOverwriteSourceFile = true;
		}
		m_tempFilenameDst.erase();
	}
}
void storageForPlugins::ValidateNewBuffer()
{
	// changed data are : buffer, nChanged
	// passed as pointers so already upToDate
	m_nChangedValid = m_nChanged;
}

////////////////////////////////////////////////////////////////////////////////

void storageForPlugins::ValidateInternal(bool bNewIsFile, bool bNewIsUnicode)
{
	assert (m_bCurrentIsFile != bNewIsFile || m_bCurrentIsUnicode != bNewIsUnicode);

	// if we create a file, we remove the remaining previous file 
	if (bNewIsFile)
	{
		if (m_bOverwriteSourceFile)
		{
			try
			{
				TFile(m_filename).remove();
				TFile(m_tempFilenameDst).renameTo(m_filename);
			}
			catch (...)
			{
			}
		}
		else
		{
			// do not delete the original file name
			m_filename = m_tempFilenameDst;
			// for next transformation, we may overwrite/delete the source file
			m_bOverwriteSourceFile = true;
		}
		m_tempFilenameDst.erase();
	}

	// old memory structures are freed
	if (!m_bCurrentIsFile)
		// except if the old data have been in situ replaced by new ones
		if (bNewIsFile || m_bCurrentIsUnicode != bNewIsUnicode)
		{
			if (m_bCurrentIsUnicode)
			{
				SysFreeString(m_bstr);
				m_bstr = nullptr;
			}
			else
				VariantClear(&m_array);
		}

	m_bCurrentIsUnicode = bNewIsUnicode;
	m_bCurrentIsFile = bNewIsFile;
	if (bNewIsUnicode)
	{
		m_codepage = ucr::CP_UCS2LE;
		m_nBomSize = 2;	
	}
	else
	{
		m_codepage = ucr::getDefaultCodepage();
		m_nBomSize = 0;
	}
}

const tchar_t *storageForPlugins::GetDataFileUnicode()
{
	if (m_bCurrentIsFile && m_bCurrentIsUnicode)
		return m_filename.c_str();

	unsigned nchars;
	char * pchar = nullptr;

	try
	{
		{
			std::unique_ptr<SharedMemory> pshmIn;
			// Get source data
			if (m_bCurrentIsFile)
			{
				// Init filedata struct and open file as memory mapped (in file)
				TFile fileIn(m_filename);
				try
				{
					pshmIn.reset(new SharedMemory(fileIn, SharedMemory::AM_READ));
					pchar = pshmIn->begin() + m_nBomSize;
					nchars = static_cast<unsigned>(pshmIn->end() - pchar);
				}
				catch (...)
				{
					if (!fileIn.isDevice() && fileIn.getSize() > 0)
						return nullptr;
					pchar = "";
					nchars = 0;
				}			
			}
			else
			{
				if (m_bCurrentIsUnicode)
				{
					pchar = (char *)m_bstr;
					nchars = SysStringLen(m_bstr) * sizeof(wchar_t);
				}
				else
				{
					pchar = (char *)GetVariantArrayData(m_array, nchars);
				}
			}

			// Compute the dest size (in bytes)
			int textForeseenSize = nchars * sizeof(wchar_t) + 6; // from unicoder.cpp maketstring
			int textRealSize = textForeseenSize;

			// Init filedata struct and open file as memory mapped (out file)
			GetDestFileName();

			TFile fileOut(m_tempFilenameDst);
			fileOut.setSize(textForeseenSize + 2);
			int bom_bytes = 0;
			{
				SharedMemory shmOut(fileOut, SharedMemory::AM_WRITE);
				bom_bytes = ucr::writeBom(shmOut.begin(), ucr::UCS2LE);
				// to UCS-2 conversion, from unicoder.cpp maketstring
				bool lossy;
				textRealSize = ucr::CrossConvert(pchar, nchars, (char *)shmOut.begin()+bom_bytes, textForeseenSize-1, m_codepage, ucr::CP_UCS2LE, &lossy);
			}
			// size may have changed
			fileOut.setSize(textRealSize + bom_bytes);

			// Release pointers to source data
			if (!m_bCurrentIsFile && !m_bCurrentIsUnicode)
				SafeArrayUnaccessData(m_array.parray);

			if ((textRealSize == 0) && (textForeseenSize > 0))
			{
				// conversion error
				try { TFile(m_tempFilenameDst).remove(); } catch (...) {}
				return nullptr;
			}
		}
		ValidateInternal(true, true);
		return m_filename.c_str();
	}
	catch (...)
	{
		return nullptr;
	}
}


BSTR * storageForPlugins::GetDataBufferUnicode()
{
	if (!m_bCurrentIsFile && m_bCurrentIsUnicode)
		return &m_bstr;

	unsigned nchars;
	char * pchar;

	try
	{
		{
			std::unique_ptr<SharedMemory> pshmIn;
			// Get source data
			if (m_bCurrentIsFile) 
			{
				// Init filedata struct and open file as memory mapped (in file)
				TFile fileIn(m_filename);
				try
				{
					pshmIn.reset(new SharedMemory(fileIn, SharedMemory::AM_READ));

					pchar = pshmIn->begin() + m_nBomSize;
					nchars = static_cast<unsigned>(pshmIn->end() - pchar);
				}
				catch (...)
				{
					if (!fileIn.isDevice() && fileIn.getSize() > 0)
						return nullptr;
					pchar = "";
					nchars = 0;
				}			
			}
			else
			{
				pchar = (char *)GetVariantArrayData(m_array, nchars);
			}

			// Compute the dest size (in bytes)
			int textForeseenSize = nchars * sizeof(wchar_t) + 6; // from unicoder.cpp maketstring
			int textRealSize = textForeseenSize;

			// allocate the memory
			auto tempBSTR = std::make_unique<wchar_t[]>(textForeseenSize);

			// fill in the data
			wchar_t * pbstrBuffer = tempBSTR.get();
			bool bAllocSuccess = (pbstrBuffer != nullptr);
			if (bAllocSuccess)
			{
				// to UCS-2 conversion, from unicoder.cpp maketstring
				bool lossy;
				textRealSize = ucr::CrossConvert(pchar, nchars, (char *)pbstrBuffer, textForeseenSize-1, m_codepage, ucr::CP_UCS2LE, &lossy);
				SysFreeString(m_bstr);
				m_bstr = SysAllocStringLen(tempBSTR.get(), textRealSize / sizeof(wchar_t));
				if (m_bstr == nullptr)
					bAllocSuccess = false;
			}

			// Release pointers to source data
			if (!m_bCurrentIsFile && !m_bCurrentIsUnicode)
				SafeArrayUnaccessData(m_array.parray);

			if (!bAllocSuccess)
				return nullptr;
		}
		ValidateInternal(false, true);
		return &m_bstr;
	}
	catch (...)
	{
		return nullptr;
	}
}

const tchar_t *storageForPlugins::GetDataFileAnsi()
{
	if (m_bCurrentIsFile && !m_bCurrentIsUnicode)
		return m_filename.c_str();

	unsigned nchars;
	char * pchar = nullptr;

	try
	{
		{
			std::unique_ptr<SharedMemory> pshmIn;
			// Get source data
			if (m_bCurrentIsFile)
			{
				// Init filedata struct and open file as memory mapped (in file)
				TFile fileIn(m_filename);
				try
				{
					pshmIn.reset(new SharedMemory(fileIn, SharedMemory::AM_READ));

					pchar = pshmIn->begin()+m_nBomSize; // pass the BOM
					nchars = static_cast<unsigned>(pshmIn->end() - pchar);
				}
				catch (...)
				{
					if (!fileIn.isDevice() && fileIn.getSize() > 0)
						return nullptr;
					pchar = "";
					nchars = 0;
				}
			}
			else 
			{
				if (m_bCurrentIsUnicode)
				{
					pchar  = (char *)m_bstr;
					nchars = SysStringLen(m_bstr) * sizeof(wchar_t);
				}
				else
				{
					pchar = (char *)GetVariantArrayData(m_array, nchars);
				}
			}

			// Compute the dest size (in bytes)
			int textForeseenSize = nchars; 
			if (m_bCurrentIsUnicode)
				textForeseenSize = nchars * 3; // from unicoder.cpp convertToBuffer
			int textRealSize = textForeseenSize;

			// Init filedata struct and open file as memory mapped (out file)
			GetDestFileName();
			TFile fileOut(m_tempFilenameDst);
			fileOut.setSize(textForeseenSize);
			if (textForeseenSize > 0)
			{
				SharedMemory shmOut(fileOut, SharedMemory::AM_WRITE);

				if (m_bCurrentIsUnicode)
				{
					// UCS-2 to Ansi conversion, from unicoder.cpp convertToBuffer
					bool lossy;
					textRealSize = ucr::CrossConvert(pchar, nchars, (char *)shmOut.begin(), textForeseenSize, m_codepage, ucr::getDefaultCodepage(), &lossy);
				}
				else
				{
					std::memcpy(shmOut.begin(), pchar, nchars);
				}
			}
			// size may have changed
			fileOut.setSize(textRealSize);

			// Release pointers to source data
			if (!m_bCurrentIsFile && !m_bCurrentIsUnicode)
				SafeArrayUnaccessData(m_array.parray);

			if ((textRealSize == 0) && (textForeseenSize > 0))
			{
				// conversion error
				try { TFile(m_tempFilenameDst).remove(); } catch (...) {}
				return nullptr;
			}
		}
		ValidateInternal(true, false);
		return m_filename.c_str();
	}
	catch (...)
	{
		return nullptr;
	}
}


VARIANT * storageForPlugins::GetDataBufferAnsi()
{
	if (!m_bCurrentIsFile && !m_bCurrentIsUnicode)
		return &m_array;

	unsigned nchars;
	char * pchar;

	try
	{
		{
			std::unique_ptr<SharedMemory> pshmIn;
			// Get source data
			if (m_bCurrentIsFile) 
			{
				// Init filedata struct and open file as memory mapped (in file)
				TFile fileIn(m_filename);
				pshmIn.reset(new SharedMemory(fileIn, SharedMemory::AM_READ));

				pchar = pshmIn->begin() + m_nBomSize;
				nchars = static_cast<unsigned>(pshmIn->end() - pchar);
			}
			else
			{
				pchar  = (char *)m_bstr;
				nchars = SysStringLen(m_bstr) * sizeof(wchar_t);
			}

			// Compute the dest size (in bytes)
			int textForeseenSize = nchars; 
			if (m_bCurrentIsUnicode)
				textForeseenSize = nchars * 3; // from unicoder.cpp convertToBuffer
			int textRealSize = textForeseenSize;

			// allocate the memory
			SAFEARRAYBOUND rgsabound = {static_cast<ULONG>(textForeseenSize), 0};
			m_array.vt = VT_UI1 | VT_ARRAY;
			m_array.parray = SafeArrayCreate(VT_UI1, 1, &rgsabound);
			char * parrayData;
			SafeArrayAccessData(m_array.parray, (void**)&parrayData);

			// fill in the data
			if (m_bCurrentIsUnicode)
			{
				// to Ansi conversion, from unicoder.cpp convertToBuffer
				bool lossy;
				textRealSize = ucr::CrossConvert(pchar, nchars, (char *)parrayData, textForeseenSize, m_codepage, ucr::getDefaultCodepage(), &lossy);
			}
			else
			{
				std::memcpy(parrayData, pchar, nchars);
			}
			// size may have changed
			SafeArrayUnaccessData(m_array.parray);
			SAFEARRAYBOUND rgsaboundnew = {static_cast<ULONG>(textRealSize), 0};
			SafeArrayRedim(m_array.parray, &rgsaboundnew);
		}
		ValidateInternal(false, false);
		return &m_array;
	}
	catch (...)
	{
		return nullptr;
	}
}

template<typename T, bool flipbytes>
inline const T *findNextLine(const T *pstart, const T *pend)
{
	for (const T *p = pstart; p < pend; ++p)
	{
		int ch = flipbytes ? ByteOrder::flipBytes(*p) : *p;
		if (ch == '\n')
			return p + 1;
		else if (ch == '\r')
		{
			if (p + 1 < pend && *(p + 1) == (flipbytes ? ByteOrder::flipBytes('\n') : '\n'))
				return p + 2;
			else
				return p + 1;
		}
	}
	return pend;
}

static const char *findNextLine(ucr::UNICODESET unicoding, const char *pstart, const char *pend)
{
	switch (unicoding)
	{
	case ucr::UCS2LE:
		return (const char *)findNextLine<unsigned short, false>((const unsigned short *)pstart, (const unsigned short *)pend);
	case ucr::UCS2BE:
		return (const char *)findNextLine<unsigned short, true>((const unsigned short *)pstart, (const unsigned short *)pend);
	default:
		return findNextLine<char, false>(pstart, pend);
	}
}

bool AnyCodepageToUTF8(int codepage, const String& filepath, const String& filepathDst, int & nFileChanged, bool bWriteBOM)
{
	UniMemFile ufile;
	if (!ufile.OpenReadOnly(filepath))
		return true;
	ufile.ReadBom();
	ucr::UNICODESET unicoding = ufile.GetUnicoding();
	// Finished with examing file contents
	ufile.Close();

	TFile fileIn(filepath);
	try
	{
		// Init filedataIn struct and open file as memory mapped (input)
		SharedMemory shmIn(fileIn, SharedMemory::AM_READ);

		IExconverter *pexconv = Exconverter::getInstance();

		char * pszBuf = shmIn.begin();
		size_t nBufSize = shmIn.end() - shmIn.begin();
		size_t nSizeOldBOM = 0;
		switch (unicoding)
		{
		case ucr::UTF8:
			nSizeOldBOM = 3;
			break;
		case ucr::UCS2LE:
		case ucr::UCS2BE:
			nSizeOldBOM = 2;
			break;
		}

		const size_t minbufsize = 128 * 1024;

		// create the destination file
		FileOutputStream fout(ucr::toUTF8(filepathDst), std::ios::out|std::ios::binary|std::ios::trunc);
		Buffer<char> obuf(minbufsize);
		int64_t pos = nSizeOldBOM;

		// write BOM
		if (bWriteBOM)
		{
			char bom[4];
			fout.write(bom, ucr::writeBom(bom, ucr::UTF8));
		}

		// write data
		for (;;)
		{
			size_t srcbytes = findNextLine(unicoding, pszBuf + pos + minbufsize, pszBuf + nBufSize) - (pszBuf + pos);
			if (srcbytes == 0)
				break;
			if (srcbytes * 3 > obuf.size())
				obuf.resize(srcbytes * 3 * 2, false);
			size_t destbytes = obuf.size();
			if (pexconv != nullptr)
			{
				size_t srcbytes2 = srcbytes;
				if (!pexconv->convert(codepage, ucr::CP_UTF_8, (const unsigned char *)pszBuf+pos, &srcbytes2, (unsigned char *)obuf.begin(), &destbytes))
					throw "failed to convert file contents to utf-8";
			}
			else
			{
				bool lossy = false;
				destbytes = ucr::CrossConvert((const char *)pszBuf+pos, static_cast<unsigned>(srcbytes), obuf.begin(), static_cast<unsigned>(destbytes), codepage, ucr::CP_UTF_8, &lossy);
			}
			fout.write(obuf.begin(), destbytes);
			pos += srcbytes;
		}

		nFileChanged ++;
		return true;
	}
	catch (...)
	{
		if (fileIn.getSize() == 0)
			return true;
		return false;
	}
}

</file>

<file path="Winmerge-Src/Src/Common/multiformatText.h">
/** 
 * @file  multiformatText.h
 *
 * @brief Declaration file for class storageForPlugins
 *
 * @date  Created: 2003-11-24
 */
#pragma once

#include "UnicodeString.h"
#include "unicoder.h"
#include "FileTextEncoding.h"
#include <windows.h>
#include <oleauto.h>

/**
 * @brief Storage for data to be processed by plugins. May return data
 * as file or buffer, as ansi or unicode. 
 * First you must load some file into the object. "data" is the content of this
 * file. May be text text (then you may convert ansi<->unicode), or anything.
 * Final save : for text, the format ansi/unicode is the same as the original file.
 *
 * @todo : export final save as UTF-8 for unicode optimization (avoid save+reload the file)
 */
class storageForPlugins
{
public:
	storageForPlugins()
	: m_bstr(nullptr)
	, m_bOriginalIsUnicode(false)
	, m_bCurrentIsUnicode(false)
	, m_bCurrentIsFile(false)
	, m_bOverwriteSourceFile(false)
	, m_nChangedValid(0)
	, m_bError(false)
	, m_codepage(0)
	, m_nBomSize(0)
	, m_nChanged(0)
	{
		VariantInit(&m_array);
	}

	~storageForPlugins()
	{
		if (!m_tempFilenameDst.empty()) // "!m_tempFilenameDst" means "never"
			::DeleteFile(m_tempFilenameDst.c_str());
		if (m_bstr != nullptr)
			SysFreeString(m_bstr);
		VariantClear(&m_array);
	}

	/// Get data as unicode buffer (BSTR)
	BSTR * GetDataBufferUnicode();
	/// Get data as ansi buffer (safearray of unsigned char)
	VARIANT * GetDataBufferAnsi();
	/// Get data as file (saved as UCS-2 with BOM)
	const tchar_t *GetDataFileUnicode();
	/// Get data as file (saved as Ansi)
	const tchar_t *GetDataFileAnsi();
	/// Get a temporary filename, to be used to save the transformed data 
	const tchar_t *GetDestFileName();
	/// validation for data retrieved by GetDataFileAnsi/GetDataFileUnicode
	void ValidateNewFile();
	/// validation for data retrieved by GetDataBufferAnsi/GetDataBufferUnicode
	void ValidateNewBuffer();

	/// Initial load
	void SetDataFileUnknown(const String& filename, bool bOverwrite = false);
	/// Set codepage to use for ANSI<->UNICODE conversions
	void SetCodepage(int code) { m_codepage = code; };
	/// Initial load
	void SetDataFileAnsi(const String& filename, bool bOverwrite = false);
	/// Initial load
	void SetDataFileEncoding(const String& filename, const FileTextEncoding& encoding, bool bOverwrite = false);
	/// Final save, same format as the original file
	bool SaveAsFile(String & filename)
	{
		const tchar_t *newFilename;
		if (m_bOriginalIsUnicode)
			newFilename = GetDataFileUnicode();
		else
			newFilename = GetDataFileAnsi();
		if (newFilename == nullptr)
		{
			GetLastValidFile(filename);
			return false;
		}
		filename = newFilename;
		return true;
	}
	/// Get the last valid file after an error
	/// Warning : the format may be different from the original one
	void GetLastValidFile(String & filename)
	{
		if (!m_tempFilenameDst.empty())
			::DeleteFile(m_tempFilenameDst.c_str());
		m_tempFilenameDst.erase();
		filename = this->m_filename;
	}

	/// return number of transformation until now
	int & GetNChanged() { return m_nChanged; };
	/// return number of valid transformation until now
	int & GetNChangedValid() { return m_nChangedValid; }
	/// return format of original data
	bool GetOriginalMode() const { return m_bOriginalIsUnicode; }
	const String GetDestFileExtension() const { return m_tempFileExtensionDst; }
	void SetDestFileExtension(const String& ext) { if (!ext.empty() && ext.back() != '/') m_tempFileExtensionDst = ext; }

private:
	void Initialize();
	void ValidateInternal(bool bNewIsFile, bool bNewIsUnicode);

// Implementation data
private:
	// original data mode ANSI/UNICODE
	bool m_bOriginalIsUnicode;

	// current format of data : BUFFER/FILE, ANSI/UNICODE
	bool m_bCurrentIsUnicode;
	bool m_bCurrentIsFile;
	// can we overwrite the current file (different from original file when nChangedValid>=1)
	bool m_bOverwriteSourceFile;	
	// number of valid transformation since load
	int m_nChangedValid;
	// data storage when mode is BUFFER UNICODE
	BSTR m_bstr;
	// data storage when mode is BUFFER ANSI
	VARIANT m_array;
	// data storage when mode is FILE
	String m_filename;
	// error during conversion ?
	bool m_bError;
	// codepage for ANSI mode
	int m_codepage;
	// BOM size
	int m_nBomSize;

	// temporary number of transformations, transformed by caller
	int m_nChanged;
	// temporary destination filename
	String m_tempFilenameDst;
	// temporary destination file extension
	String m_tempFileExtensionDst;
};


// other conversion functions

/// Convert file to UTF-8 (for diffutils)
bool AnyCodepageToUTF8(int codepage, const String& filepath, const String& filepathDst, int & nFileChanged, bool bWriteBOM);
</file>

<file path="Winmerge-Src/Src/Common/OptionsMgr.cpp">
/** 
 * @file OptionsMgr.cpp
 *
 * @brief Implementation of Options management classes
 *
 */


/* The MIT License
Copyright (c) 2004-2009 Kimmo Varis
Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files
(the "Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:
The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

#include "pch.h"
#include "OptionsMgr.h"
#include "UniFile.h"
#include <algorithm>
#include <cassert>
#include <windows.h>

constexpr int MAX_PATH_FULL = 32767;

static bool GetAsInt(const String& str, int & val);

varprop::VariantValue COptionsMgr::m_emptyValue;

/**
 * @brief Default constructor.
 */
COption::COption() = default;

/**
 * @brief Copy constructor.
 * @param [in] option Object to copy.
 */
COption::COption(const COption& option)
: m_strName(option.m_strName)
, m_value(option.m_value)
, m_valueDef(option.m_valueDef)
{
}

/**
 * @brief Assignment operator override.
 * @param [in] option Object to copy.
 * @return Copy of given object.
 */
COption& COption::operator=(const COption& option)
{
	if (this != &option)
	{
		m_strName = option.m_strName;
		m_value = option.m_value;
		m_valueDef = option.m_valueDef;
	}
	return *this;
}

/**
 * @brief Set name, value and default value for option
 * @param [in] name Name of option with full path ("Settings/AutomaticRescan")
 * @param [in] defaultValue Default value for option. This value
 * is restored for otion when Reset() is run.
 * @sa COption::Reset()
 */
int COption::Init(const String& name, const varprop::VariantValue& defaultValue)
{
	int retVal = COption::OPT_OK;

	m_strName = name;
	if (m_strName.empty())
		return OPT_ERR;

	// Dont' check type here since we are initing it!
	varprop::VT_TYPE inType = defaultValue.GetType();

	switch (inType)
	{
	case varprop::VT_NULL:
		retVal = OPT_UNKNOWN_TYPE;
		break;
	case varprop::VT_BOOL:
		m_value.SetBool(defaultValue.GetBool());
		m_valueDef.SetBool(defaultValue.GetBool());
		break;
	case varprop::VT_INT:
		m_value.SetInt(defaultValue.GetInt());
		m_valueDef.SetInt(defaultValue.GetInt());
		break;
	case varprop::VT_FLOAT:
		m_value.SetFloat(defaultValue.GetFloat());
		m_valueDef.SetFloat(defaultValue.GetFloat());
		break;
	case varprop::VT_STRING:
		m_value.SetString(defaultValue.GetString());
		m_valueDef.SetString(defaultValue.GetString());
		break;
	case varprop::VT_TIME:
		m_value.SetTime(defaultValue.GetTime());
		m_valueDef.SetTime(defaultValue.GetTime());
		break;
	default:
		retVal = OPT_UNKNOWN_TYPE;
	}
	return retVal;
}

/**
 * @brief Convert string to integer.
 * @param [in] str String to convert.
 * @param [out] val Converted integer.
 * @return true if conversion succeeded, false otherwise.
 */
static bool GetAsInt(const String& str, int & val)
{
	if (str.empty())
		return false;
	const size_t len = str.length();

	val = 0;
	for (int i = 0; i < (int)len; ++i)
	{
		int ch = (int)str[i];
		if (ch < '0' || ch > '9')
			return false;
		val *= 10;
		val += ch - '0';
	}
	return true;
}

/**
 * @brief Convert integer value to desired type.
 * @param [in, out] value Value to convert.
 * @param [in] nType Type to convert to.
 * @return true if conversion succeeded, false otherwise.
 * @note Only supports converting to boolean at the moment.
 * @todo Add other conversions (string?).
  */
bool COption::ConvertInteger(varprop::VariantValue & value, varprop::VT_TYPE nType)
{
	int ivalue = value.GetInt();

	switch(nType)
	{
	case varprop::VT_BOOL:
		// Convert integer to boolean
		{
			if (ivalue > 0)
			{
				value.SetBool(true);
				return true;
			}
			else
			{
				value.SetBool(false);
				return true;
			}
		}
	}
	return false;
}

/**
 * @brief Convert string value to desired type.
 * @param [in, out] value Value to convert.
 * @param [in] nType Type to convert to.
 * @return true if conversion succeeded, false otherwise.
 * @note Only supports converting to integer and boolean at the moment.
 * @todo Add other conversions (float?).
  */
bool COption::ConvertString(varprop::VariantValue & value, varprop::VT_TYPE nType)
{
	String svalue = value.GetString();
	switch(nType)
	{
	case varprop::VT_INT:
		// Convert string to integer
		{
			int val=0;
			if (!GetAsInt(svalue, val))
				return false;
			value.SetInt(val);
			return true;
		}
	case varprop::VT_BOOL:
		// Convert string to boolean
		{
			svalue = strutils::makelower(svalue);
			if (svalue == _T("1") || svalue == _T("yes")
				|| svalue == _T("true"))
			{
				value.SetBool(true);
				return true;
			}
			if (svalue == _T("0") || svalue == _T("no")
				|| svalue == _T("false"))
			{
				value.SetBool(false);
				return true;
			}
			return false;
		}
	}
	return false;
}

/**
 * @brief Convert value to desired type.
 * @param [in, out] value Value to convert.
 * @param [in] nType Type to convert to.
 * @return true if conversion succeeded, false otherwise.
 * @note Currently converts only strings and integers.
 * @todo Add other conversions.
 */
bool COption::ConvertType(varprop::VariantValue & value, varprop::VT_TYPE nType)
{
	if (value.GetType() == varprop::VT_STRING)
		return ConvertString(value, nType);
	if (value.GetType() == varprop::VT_INT)
		return ConvertInteger(value, nType);
	return false;
}

/**
 * @brief Set option value.
 * 
 * Set new value for option. If automatic conversion is not allowed,
 * type of value must match to type set when option was initialised.
 * @param [in] value New value to set.
 * @param [in] allowConversion Is automatic type conversion allowed?
 * @sa COption::Init()
 */
int COption::Set(const varprop::VariantValue& value, bool allowConversion)
{
	int retVal = COption::OPT_OK;

	// Check that type matches
	varprop::VT_TYPE inType = value.GetType();
	if (value.GetType() != m_value.GetType())
	{
		if (allowConversion)
		{
			varprop::VariantValue val(value);
			if (ConvertType(val, m_value.GetType()))
				return Set(val);
		}
		return COption::OPT_WRONG_TYPE;
	}

	switch (inType)
	{
	case varprop::VT_NULL:
		retVal = OPT_UNKNOWN_TYPE;
		break;
	case varprop::VT_BOOL:
		m_value.SetBool(value.GetBool());
		break;
	case varprop::VT_INT:
		m_value.SetInt(value.GetInt());
		break;
	case varprop::VT_FLOAT:
		m_value.SetFloat(value.GetFloat());
		break;
	case varprop::VT_STRING:
		m_value.SetString(value.GetString());
		break;
	case varprop::VT_TIME:
		m_value.SetTime(value.GetTime());
		break;
	default:
		retVal = OPT_UNKNOWN_TYPE;
	}
	return retVal;
}

/**
 * @brief Change default value for option.
 *
 * Set new value for option default value.  If automatic conversion is not
 * allowed, type of value must match to type set when option was initialised.
 * @param [in] defaultValue New default value.
 * @sa COption::Init()
 */
int COption::SetDefault(const varprop::VariantValue& defaultValue)
{
	int retVal = COption::OPT_OK;

	// Check that type matches
	varprop::VT_TYPE inType = defaultValue.GetType();
	if (inType != m_valueDef.GetType())
	{
		return COption::OPT_WRONG_TYPE;
	}

	switch (inType)
	{
	case varprop::VT_NULL:
		retVal = OPT_UNKNOWN_TYPE;
		break;
	case varprop::VT_BOOL:
		m_valueDef.SetBool(defaultValue.GetBool());
		break;
	case varprop::VT_INT:
		m_valueDef.SetInt(defaultValue.GetInt());
		break;
	case varprop::VT_FLOAT:
		m_valueDef.SetFloat(defaultValue.GetFloat());
		break;
	case varprop::VT_STRING:
		m_valueDef.SetString(defaultValue.GetString());
		break;
	case varprop::VT_TIME:
		m_valueDef.SetTime(defaultValue.GetTime());
		break;
	default:
		retVal = OPT_UNKNOWN_TYPE;
	}
	return retVal;
}

/**
 * @brief Reset option's value to default value.
 */
void COption::Reset()
{
	switch (m_value.GetType())
	{
	case varprop::VT_BOOL:
		m_value.SetBool(m_valueDef.GetBool());
		break;
	case varprop::VT_INT:
		m_value.SetInt(m_valueDef.GetInt());
		break;
	case varprop::VT_FLOAT:
		m_value.SetFloat(m_valueDef.GetFloat());
		break;
	case varprop::VT_STRING:
		m_value.SetString(m_valueDef.GetString());
		break;
	case varprop::VT_TIME:
		m_value.SetTime(m_valueDef.GetTime());
		break;
	case varprop::VT_NULL:
		// Do nothing for VT_NULL
		break;
	default:
		// Do nothing for unknown types
		break;
	}
}

/**
 * @brief Add new option to list.
 * @param [in] name Option's name.
 * @param [in] defaultValue Option's initial and default value.
 */
int COptionsMgr::AddOption(const String& name, const varprop::VariantValue& defaultValue)
{
	COption tmpOption;
	int retVal = tmpOption.Init(name, defaultValue);
	if (retVal == COption::OPT_OK)
		m_optionsMap.insert_or_assign(name, tmpOption);

	return retVal;
}

int COptionsMgr::InitOption(const String& name, int defaultValue, int minValue, int maxValue, bool serializable)
{
	int retVal = InitOption(name, defaultValue, serializable);
	if (retVal == COption::OPT_OK)
	{
		int ival = GetInt(name);
		if (ival < minValue || ival > maxValue)
			Reset(name);
	}
	return retVal;
}

/**
 * @brief Get option value from list by name.
 * @param [in] name Name of the option to get.
 * @return Option's value as variant type.
 */
const varprop::VariantValue& COptionsMgr::Get(const String& name) const
{
	OptionsMap::const_iterator found = m_optionsMap.find(name);
	if (found != m_optionsMap.end())
	{
		return found->second.Get();
	}
	return m_emptyValue;
}

/**
 * @brief Return string option value.
 * @param [in] name Option's name.
 */
const String& COptionsMgr::GetString(const String& name) const
{
	return Get(name).GetString();
}

/**
 * @brief Return integer option value.
 * @param [in] name Option's name.
 */
int COptionsMgr::GetInt(const String& name) const
{
	return Get(name).GetInt();
}

/**
 * @brief Return boolean option value
 * @param [in] name Option's name.
 */
bool COptionsMgr::GetBool(const String& name) const
{
	return Get(name).GetBool();
}

/**
 * @brief Set new value for option.
 * @param [in] name Option's name.
 * @param [in] value Option's new value.
 */
int COptionsMgr::Set(const String& name, const varprop::VariantValue& value)
{
	int retVal = COption::OPT_OK;

	OptionsMap::const_iterator found = m_optionsMap.find(name);
	if (found != m_optionsMap.end())
	{
		// Allow automatic conversion so we don't bother callsites about this!
		COption tmpOption = found->second;
		retVal = tmpOption.Set(value, true);
		if (retVal == COption::OPT_OK)
			m_optionsMap.insert_or_assign(name, tmpOption);
	}
	else
	{
		retVal = COption::OPT_NOTFOUND;
	}
	return retVal;
}

/**
 * @brief Set new value for boolean option.
 * @param [in] name Option's name.
 * @param [in] value Option's new value.
 */
int COptionsMgr::Set(const String& name, bool value)
{
	varprop::VariantValue valx;
	valx.SetBool(value);
	return Set(name, valx);
}

/**
 * @brief Set new value for integer option.
 * @param [in] name Option's name.
 * @param [in] value Option's new value.
 */
int COptionsMgr::Set(const String& name, int value)
{
	varprop::VariantValue valx;
	valx.SetInt(value);
	return Set(name, valx);
}

/**
 * @brief Set new value for string option.
 * @param [in] name Option's name.
 * @param [in] value Option's new value.
 */
int COptionsMgr::Set(const String& name, const String& value)
{
	varprop::VariantValue valx;
	valx.SetString(value);
	return Set(name, valx);
}

/**
 * @brief Set new value for string option.
 * @param [in] name Option's name.
 * @param [in] value Option's new value.
 */
int COptionsMgr::Set(const String& name, const tchar_t *value)
{
	return Set(name, String(value));
}

/**
 * @brief Type-convert and forward to SaveOption(String, int)
 * @param [in] name Option's name.
 * @param [in] value Option's new value.
 */
int COptionsMgr::SaveOption(const String& name, unsigned value)
{
	int xvalue = value;
	return SaveOption(name, xvalue);
}

/**
 * @brief Remove option from options list.
 * @param [in] name Name of the option to remove.
 */
int COptionsMgr::RemoveOption(const String& name)
{
	int retVal = COption::OPT_OK;

	OptionsMap::const_iterator found = m_optionsMap.find(name);
	if (found != m_optionsMap.end())
	{
		size_t nr_removed = m_optionsMap.erase(name);
		if (nr_removed == 0)
			retVal = COption::OPT_NOTFOUND;
	}
	else
		retVal = COption::OPT_NOTFOUND;

	return retVal;
}

/**
 * @brief Reset option value to default.
 * @param [in] name Name of the option to reset.
 */
int COptionsMgr::Reset(const String& name)
{
	int retVal = COption::OPT_OK;

	OptionsMap::const_iterator found = m_optionsMap.find(name);
	if (found != m_optionsMap.end())
	{
		COption tmpOption = found->second;
		tmpOption.Reset();
		m_optionsMap.insert_or_assign(name, tmpOption);
	}
	else
	{
		retVal = COption::OPT_NOTFOUND;
	}
	return retVal;
}

/**
 * @brief Return default string value.
 * @param [in] name Option's name.
 * @param [out] value Option's default value.
 */
int COptionsMgr::GetDefault(const String& name, String & value) const
{
	int retVal = COption::OPT_OK;

	OptionsMap::const_iterator found = m_optionsMap.find(name);
	if (found != m_optionsMap.end())
	{
		varprop::VariantValue val = found->second.GetDefault();
		if (val.IsString())
			value = val.GetString();
		else
			retVal = COption::OPT_WRONG_TYPE;
	}
	else
	{
		retVal = COption::OPT_NOTFOUND;
	}
	return retVal;
}

/**
 * @brief Return default number value
 * @param [in] name Option's name.
 * @param [out] value Option's default value.
 */
int COptionsMgr::GetDefault(const String& name, unsigned & value) const
{
	int retVal = COption::OPT_OK;

	OptionsMap::const_iterator found = m_optionsMap.find(name);
	if (found != m_optionsMap.end())
	{
		varprop::VariantValue val = found->second.GetDefault();
		if (val.IsInt())
			value = val.GetInt();
		else
			retVal = COption::OPT_WRONG_TYPE;
	}
	else
	{
		retVal = COption::OPT_NOTFOUND;
	}
	return retVal;
}

/**
 * @brief Return default boolean value
 * @param [in] name Option's name.
 * @param [out] value Option's default value.
 */
int COptionsMgr::GetDefault(const String& name, bool & value) const
{
	int retVal = COption::OPT_OK;

	OptionsMap::const_iterator found = m_optionsMap.find(name);
	if (found != m_optionsMap.end())
	{
		varprop::VariantValue val = found->second.GetDefault();
		if (val.IsBool())
			value = val.GetBool();
		else
			retVal = COption::OPT_WRONG_TYPE;
	}
	else
	{
		retVal = COption::OPT_NOTFOUND;
	}
	return retVal;
}

String COptionsMgr::ExpandShortName(const String& shortname) const
{
	int nmatched = 0;
	String matchedkey;
	for (const auto& it : m_optionsMap)
	{
		if (it.first.find(shortname) != String::npos)
		{
			matchedkey = it.first;
			++nmatched;
		}
	}
	return (nmatched == 1) ? matchedkey : _T("");
}

/**
 * @brief Export options to file.
 *
 * This function enumerates through our options storage and saves
 * every option name and value to file.
 *
 * @param [in] filename Filename where optios are written.
 * @return
 * - COption::OPT_OK when succeeds
 * - COption::OPT_ERR when writing to the file fails
 */
int COptionsMgr::ExportOptions(const String& filename, const bool bHexColor /*= false*/) const
{
	int retVal = COption::OPT_OK;
	OptionsMap::const_iterator optIter = m_optionsMap.begin();
	while (optIter != m_optionsMap.end() && retVal == COption::OPT_OK)
	{
		const String name(optIter->first);
		String strVal, strType;
		varprop::VariantValue value = optIter->second.Get();
		if (value.GetType() == varprop::VT_BOOL)
		{
			strType = _T("bool");
			if (value.GetBool())
				strVal = _T("1");
			else
				strVal = _T("0");
		}
		else if (value.GetType() == varprop::VT_INT)
		{
			strType = _T("int");
			if ( bHexColor && (strutils::makelower(name).find(String(_T("color"))) != std::string::npos) )
				strVal = strutils::format(_T("0x%06x"), value.GetInt());
			else
				strVal = strutils::to_str(value.GetInt());
		}
		else if (value.GetType() == varprop::VT_STRING)
		{
			strType = _T("string");
			strVal = EscapeValue(value.GetString());
		}

		// https://learn.microsoft.com/en-us/answers/questions/578134/error-in-writeprivateprofilestring-function-when-j
		bool bRet = !!WritePrivateProfileString(_T("WinMerge"), name.c_str(),
				nullptr, filename.c_str());
		if (!bRet)
			retVal = COption::OPT_ERR;
		bRet = !!WritePrivateProfileString(_T("WinMerge"), name.c_str(),
				strVal.c_str(), filename.c_str());
		if (!bRet)
			retVal = COption::OPT_ERR;
		bRet = !!WritePrivateProfileString(_T("WinMerge.TypeInfo"), name.c_str(),
				strType.c_str(), filename.c_str());
		if (!bRet)
			retVal = COption::OPT_ERR;
		++optIter;
	}
	return retVal;
}

/**
 * @brief Import options from file.
 *
 * This function reads options values and names from given file and
 * updates values to our options storage. If valuename does not exist
 * already in options storage its is not created.
 *
 * @param [in] filename Filename where optios are written.
 * @return
 * - COption::OPT_OK when succeeds
 * - COption::OPT_NOTFOUND if file wasn't found or didn't contain values
 */
int COptionsMgr::ImportOptions(const String& filename)
{
	int retVal = COption::OPT_OK;
	auto oleTranslateColor = [](unsigned color) -> unsigned { return ((color & 0xffffff00) == 0x80000000) ? GetSysColor(color & 0x000000ff) : color; };

	// Query keys - returns NUL separated strings
	auto iniFileKeyValues = ReadIniFile(filename, _T("WinMerge"));
	if (iniFileKeyValues.empty())
		return COption::OPT_NOTFOUND;

	for (auto& [key, strValue] : iniFileKeyValues)
	{
		varprop::VariantValue value = Get(key);

		if (value.GetType() == varprop::VT_BOOL)
		{
			value.SetBool(tc::ttoi(strValue.c_str()) != 0);
		}
		else if (value.GetType() == varprop::VT_INT)
		{
			tchar_t* endptr = nullptr;
			unsigned uval = static_cast<unsigned>(tc::tcstoll(strValue.c_str(), &endptr,
				(strValue.length() >= 2 && strValue[1] == 'x') ? 16 : 10));
			int intVal = static_cast<int>(uval);
			if (strutils::makelower(key).find(String(_T("color"))) != std::string::npos)
				intVal = static_cast<int>(oleTranslateColor(static_cast<unsigned>(intVal)));
			value.SetInt(intVal);
		}
		else if (value.GetType() == varprop::VT_STRING)
		{
			value.SetString(strValue);
		}

		if (value.GetType() != varprop::VT_NULL)
			SaveOption(key, value);
	}
	FlushOptions();
	return retVal;
}

String COptionsMgr::EscapeValue(const String& text)
{
	String text2;
	for (size_t i = 0; i < text.length(); ++i)
	{
		tchar_t ch = text[i];
		if (ch == '\0' || ch == '\x1b' || ch == '\r' || ch == '\n')
		{
			text2 += '\x1b';
			text2 += ch + '@';
		}
		else
			text2 += ch;
	}
	return text2;
}

String COptionsMgr::UnescapeValue(const String& text)
{
	if (text.find('\x1b') == String::npos)
		return text;
	String text2;
	for (size_t i = 0; i < text.length(); ++i)
	{
		if (text[i] == '\x1b' && i < text.length() - 1)
		{
			++i;
			text2 += text[i] - '@';
		}
		else
			text2 += text[i];
	}
	return text2;
}

/**
 * @brief Split option name to path (in registry) and
 * valuename (in registry).
 *
 * Option names are given as "full path", e.g. "Settings/AutomaticRescan".
 * This function splits that to path "Settings/" and valuename
 * "AutomaticRescan".
 * @param [in] strName Option name
 * @param [out] srPath Path (key) in registry
 * @param [out] strValue Value in registry
 */
std::pair<String, String> COptionsMgr::SplitName(const String& strName)
{
	String strValue, strPath;
	size_t pos = strName.rfind('/');
	if (pos != String::npos)
	{
		size_t len = strName.length();
		strValue = strName.substr(pos + 1, len - pos - 1); //Right(len - pos - 1);
		strPath = strName.substr(0, pos);  //Left(pos);
	}
	else
	{
		strValue = strName;
		strPath.erase();
	}
	return { strPath, strValue };
}

std::map<String, String> COptionsMgr::ReadIniFile(const String& filename, const String& section)
{
	std::map<String, String> iniFileKeyValues;
	UniMemFile file;
	if (!file.OpenReadOnly(filename))
		return {};
	file.ReadBom();
	String line, eol;
	bool lossy = false;
	bool inTargetSection = false;
	while (file.ReadString(line, eol, &lossy))
	{
		auto itBegin = std::find_if(line.begin(), line.end(), [](int ch) {
			return !tc::istspace(static_cast<wint_t>(ch)); });

		// Skip empty lines or lines starting with a comment
		if (itBegin == line.end() || *itBegin == ';')
			continue;

		if (*itBegin == '[' && line.back() == ']')
		{
			// section
			String currentSection = line.substr(itBegin - line.begin() + 1, line.end() - itBegin - 2);
			inTargetSection = (currentSection == section);
			continue;
		}

		if (!inTargetSection)
			continue;
		
		std::size_t equalsPos = line.find('=');
		if (equalsPos == String::npos)
			continue;
		
		iniFileKeyValues.insert_or_assign(
			/* key */line.substr(itBegin - line.begin(), equalsPos - (itBegin - line.begin())),
			/* value */ UnescapeValue(line.substr(equalsPos + 1)));
	}
	file.Close();
	return iniFileKeyValues;
}

</file>

<file path="Winmerge-Src/Src/Common/OptionsMgr.h">
/** 
 * @file OptionsMgr.h
 *
 * @brief Interface for Options management classes
 *
 */

/* The MIT License
Copyright (c) 2004-2009 Kimmo Varis
Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files
(the "Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:
The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

#pragma once

#include <map>
#include <vector>
#include "UnicodeString.h"
#include "varprop.h"

/**
 * @brief Class to store option name, value and default value.
 */
class COption
{
public:
	/**
	* @brief Return values for functions.
	*/
	enum
	{
		OPT_OK				= 0, /**< All good. */
		OPT_ERR				= 1, /**< General error. */
		OPT_WRONG_TYPE		= 2, /**< Option type was wrong. */
		OPT_UNKNOWN_TYPE	= 3, /**< Given option type is not known. */
		OPT_NOTFOUND		= 4, /**< Option name not found. */
	};

	COption();
	COption(const COption& option);

	COption& operator=(const COption& option);

	int Init(const String& name, const varprop::VariantValue& defaultVal);
	const varprop::VariantValue& Get() const;
	const varprop::VariantValue& GetDefault() const;
	int Set(const varprop::VariantValue& value, bool allowConversion = false);
	int SetDefault(const varprop::VariantValue& defaultValue); 
	void Reset();

protected:
	bool ConvertInteger(varprop::VariantValue & value, varprop::VT_TYPE nType);
	bool ConvertString(varprop::VariantValue & value, varprop::VT_TYPE nType);
	bool ConvertType(varprop::VariantValue & value, varprop::VT_TYPE nType);

private:
	String m_strName; /**< Option's name. */
	varprop::VariantValue m_value; /**< Option's current value. */
	varprop::VariantValue m_valueDef; /**< Option's default value. */
};

/**
 * @brief Return option value.
 * @return Value as Variant type.
 */
inline const varprop::VariantValue& COption::Get() const
{
	return m_value;
}

/**
 * @brief Return option default value.
 * @return Default value as varian type.
 */
inline const varprop::VariantValue& COption::GetDefault() const
{
	return m_valueDef;
}

typedef std::map<String, COption> OptionsMap;

/**
 * @brief Class to store list of options.
 * This class holds a list of all options (known to application). Options
 * are accessed by their name.
 *
 * Option must be first initialized before it can be read/set. Initialization
 * is done with InitOption() method.
 */
class COptionsMgr
{
public:
	virtual ~COptionsMgr() {}
	int AddOption(const String& name, const varprop::VariantValue& defaultValue);
	const varprop::VariantValue& Get(const String& name) const;
	const String& GetString(const String& name) const;
	int GetInt(const String& name) const;
	bool GetBool(const String& name) const;
	int Set(const String& name, const varprop::VariantValue& value);
	int Set(const String& name, const String& value);
	int Set(const String& name, const tchar_t *value);
	int Set(const String& name, bool value);
	int Set(const String& name, int value);
	int Reset(const String& name);
	int GetDefault(const String& name, String & value) const;
	int GetDefault(const String& name, unsigned & value) const;
	int GetDefault(const String& name, bool & value) const;
	template <typename T> T GetDefault(const String& name) const { T v; GetDefault(name, v); return v; }
	template <template<typename T, typename = std::allocator<T>> class Container = std::vector>
	Container<String> GetNameList() const
	{
		Container<String> nameList;
		for (const auto& e : m_optionsMap)
			nameList.push_back(e.first);
		return nameList;
	}
	String ExpandShortName(const String & shortname) const;

	virtual int InitOption(const String& name, const varprop::VariantValue& defaultValue) = 0;
	virtual int InitOption(const String& name, const String& defaultValue) = 0;
	virtual int InitOption(const String& name, const tchar_t *defaultValue) = 0;
	virtual int InitOption(const String& name, int defaultValue, bool serializable = true) = 0;
	virtual int InitOption(const String& name, int defaultValue, int minValue, int maxValue, bool serializable = true);
	virtual int InitOption(const String& name, bool defaultValue) = 0;

	virtual int SaveOption(const String& name) = 0;
	virtual int SaveOption(const String& name, const varprop::VariantValue& value) = 0;
	virtual int SaveOption(const String& name, const String& value) = 0;
	virtual int SaveOption(const String& name, const tchar_t *value) = 0;
	virtual int SaveOption(const String& name, int value) = 0;
	virtual int SaveOption(const String& name, bool value) = 0;
	virtual int SaveOption(const String& name, unsigned value);

	virtual int RemoveOption(const String& name);

	virtual int FlushOptions() = 0;

	virtual int ExportOptions(const String& filename, const bool bHexColor=false) const;
	virtual int ImportOptions(const String& filename);
	
	virtual void SetSerializing(bool serializing=true) = 0;

protected:
	static String EscapeValue(const String& text);
	static String UnescapeValue(const String& text);
	static std::pair<String, String> SplitName(const String& strName);
	static std::map<String, String> ReadIniFile(const String& filename, const String& section);

	OptionsMap m_optionsMap; /**< Map where options are stored. */

private:
	static varprop::VariantValue m_emptyValue;
};
</file>

<file path="Winmerge-Src/Src/Common/PidlContainer.cpp">
/////////////////////////////////////////////////////////////////////////////
//	  WinMerge:  an interactive diff/merge utility
//	  Copyright (C) 1997-2000  Thingamahoochie Software
//	  Author: Dean Grimm
//	  SPDX-License-Identifier: GPL-2.0-or-later
/////////////////////////////////////////////////////////////////////////////
/** 
 * @file  PidlContainer.cpp
 *
 * @brief Main implementation file for CPidlContainer
 */

#include "pch.h"
#include "PidlContainer.h"
#pragma warning (push)			// prevent "warning C4091: 'typedef ': ignored on left of 'tagGPFIDL_FLAGS' when no variable is declared"
#pragma warning (disable:4091)	// VC bug when using XP enabled toolsets.
#include <shlobj.h>
#pragma warning (pop)
#include <comdef.h>

CPidlContainer::~CPidlContainer()
{
	IMallocPtr m_pMalloc;
	if (FAILED(SHGetMalloc(&m_pMalloc)))
	{
		// can't do anything but return
		return;
	}
	// free memory allocated for pidls
	for (PidlContainer::iterator iter = m_container.begin(); iter != m_container.end(); ++iter)
	{
		m_pMalloc->Free(*iter);
	}
}

LPCITEMIDLIST* CPidlContainer::GetList() const
{
	if (m_container.empty())
		return nullptr;
	return const_cast<LPCITEMIDLIST*>(&m_container[0]);
}
</file>

<file path="Winmerge-Src/Src/Common/PidlContainer.h">
/////////////////////////////////////////////////////////////////////////////
//	  WinMerge:  an interactive diff/merge utility
//	  Copyright (C) 1997  Dean P. Grimm
//	  SPDX-License-Identifier: GPL-2.0-or-later
/////////////////////////////////////////////////////////////////////////////
/**
 *	@file PidlContainer.h
 *
 *	@brief Declaration of class CPidlContainer
 */ 
#pragma once

#include <ShTypes.h>
#include <vector>

/**
 * @brief Container for LPITEMIDLIST items
 *
 * When showing shell context menu we need to collect pidls for items.
 * This class simplifies this task.
 * Items are stored in vector. Memory allocated for pidls are freed in destructor.
 * You can add items and then query container size and pointer to 
 * LPCITEMIDLIST needed by IContextMenu::GetUIObjectOf
 */
class CPidlContainer
{
public:
	/**
	 * @brief Destructor
	 *
	 * Frees memory allocated for pidls using IMalloc interface
	 */
	~CPidlContainer();

	/**
	 * @brief Adds item to container
	 *
	 * @param[in]	pidl	item to add
	 */
	void Add(LPITEMIDLIST pidl) { m_container.push_back(pidl); } 

	/**
	 * @brief Returns pointer to array of LPCITEMIDLIST items
	 *
	 * @return Pointer to array of LPCITEMIDLIST items.
	 *		   May be invalidated by Add()
	 */
	LPCITEMIDLIST* GetList() const;

	/**
	 * @brief Returns number of items in container
	 *
	 * @return Number of items in container
	 */
	size_t Size() const { return m_container.size(); }

private:
	typedef std::vector<LPITEMIDLIST> PidlContainer;
	PidlContainer m_container; /**< stores items */
};
</file>

<file path="Winmerge-Src/Src/Common/PreferencesDlg.cpp">
/** 
 * @file PreferencesDlg.cpp
 *
 * @brief Implementation file for CPreferencesDlg
 *
 * @note This code originates from AbstractSpoon / TodoList
 * (http://www.abstractspoon.com/) but is modified to use in
 * WinMerge.
 */

#include "StdAfx.h"
#include "PreferencesDlg.h"
#include "resource.h"
#include "UnicodeString.h"
#include "OptionsDef.h"
#include "OptionsMgr.h"
#include "SyntaxColors.h"
#include "Merge.h"
#include "paths.h"
#include "FileOrFolderSelect.h"
#include "OptionsSyntaxColors.h"
#include "LineFiltersList.h"
#include "SubstitutionFiltersList.h"
#include "Constants.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CPreferencesDlg dialog

const tchar_t PATHDELIM = '>';

CPreferencesDlg::CPreferencesDlg(COptionsMgr *regOptions, SyntaxColors *colors,
		UINT nMenuID /*= 0*/, CWnd* pParent /*= nullptr*/)   // standard constructor
: CTrDialog(IDD_PREFERENCES, pParent)
, m_pOptionsMgr(regOptions)
, m_pSyntaxColorsOrg(colors)
, m_pSyntaxColors(new SyntaxColors(colors))
, m_pageGeneral(regOptions)
, m_pageCompare(regOptions)
, m_pageMessageBoxes(regOptions)
, m_pageColorSchemes(regOptions)
, m_pageMergeColors(regOptions)
, m_pageTextColors(regOptions, m_pSyntaxColors.get())
, m_pageSyntaxColors(regOptions, m_pSyntaxColors.get())
, m_pageMarkerColors(regOptions, m_pSyntaxColors.get())
, m_pageDirColors(regOptions)
, m_pageSysColors(regOptions)
, m_pageArchive(regOptions)
, m_pageCodepage(regOptions)
, m_pageEditor(regOptions)
, m_pageEditorCompareMerge(regOptions)
, m_pageEditorSyntax(regOptions)
, m_pageProject(regOptions)
, m_pageSystem(regOptions)
, m_pageBackups(regOptions)
, m_pageShell(regOptions)
, m_pageCompareFolder(regOptions)
, m_pageCompareTable(regOptions)
, m_pageCompareBinary(regOptions)
, m_pageCompareImage(regOptions)
, m_pageCompareWebPage(regOptions)
{
	UNREFERENCED_PARAMETER(nMenuID);
}

CPreferencesDlg::~CPreferencesDlg()
{
}

void CPreferencesDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPreferencesDlg)
	DDX_Control(pDX, IDC_TREEOPT_PAGES, m_tcPages);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CPreferencesDlg, CTrDialog)
	//{{AFX_MSG_MAP(CPreferencesDlg)
	ON_WM_SIZE()
	ON_COMMAND(ID_HELP, OnHelpButton)
	ON_BN_CLICKED(IDC_TREEOPT_HELP, OnHelpButton)
	ON_NOTIFY(TVN_SELCHANGED, IDC_TREEOPT_PAGES, OnSelchangedPages)
	ON_BN_CLICKED(IDC_TREEOPT_IMPORT, OnImportButton)
	ON_BN_CLICKED(IDC_TREEOPT_EXPORT, OnExportButton)
	ON_MESSAGE(WM_APP + IDC_COLOR_SCHEMES, OnColorSchemeChanged)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPreferencesDlg message handlers

BOOL CPreferencesDlg::OnInitDialog() 
{
	CTrDialog::OnInitDialog();

	m_tcPages.SetIndent(0);

	// Second parameter is 'path', page's parent page(s) and caption.
	// '>' is used as path separator.
	// For example "General" creates top-level "General" page
	// and "General>Colors" creates "Colors" sub-page for "General"
	AddPage(&m_pageGeneral, IDS_OPTIONSPG_GENERAL);
	AddPage(&m_pageCompare, IDS_OPTIONSPG_COMPARE, IDS_OPTIONSPG_GENCOMPARE);
	AddPage(&m_pageCompareFolder, IDS_OPTIONSPG_COMPARE, IDS_OPTIONSPG_FOLDERCOMPARE);
	AddPage(&m_pageCompareTable, IDS_OPTIONSPG_COMPARE, IDS_OPTIONSPG_TABLECOMPARE);
	AddPage(&m_pageCompareBinary, IDS_OPTIONSPG_COMPARE, IDS_OPTIONSPG_BINARYCOMPARE);
	AddPage(&m_pageCompareImage, IDS_OPTIONSPG_COMPARE, IDS_OPTIONSPG_IMAGECOMPARE);
	AddPage(&m_pageCompareWebPage, IDS_OPTIONSPG_COMPARE, IDS_OPTIONSPG_WEBPAGECOMPARE);
	AddPage(&m_pageMessageBoxes, IDS_OPTIONSPG_MESSAGEBOXES);
	AddPage(&m_pageEditor, IDS_OPTIONSPG_EDITOR, IDS_OPTIONSPG_GENEDITOR);
	AddPage(&m_pageEditorCompareMerge, IDS_OPTIONSPG_EDITOR, IDS_OPTIONSPG_EDITOR_COMPAREMERGE);
	AddPage(&m_pageEditorSyntax, IDS_OPTIONSPG_EDITOR, IDS_OPTIONSPG_EDITOR_SYNTAX);
	AddPage(&m_pageColorSchemes, IDS_OPTIONSPG_COLORS, IDS_OPTIONSPG_COLOR_SCHEMES);
	AddPage(&m_pageMergeColors, IDS_OPTIONSPG_COLORS, IDS_OPTIONSPG_MERGECOLORS);
	AddPage(&m_pageSyntaxColors, IDS_OPTIONSPG_COLORS, IDS_OPTIONSPG_SYNTAXCOLORS);
	AddPage(&m_pageTextColors, IDS_OPTIONSPG_COLORS, IDS_OPTIONSPG_TEXTCOLORS);
	AddPage(&m_pageMarkerColors, IDS_OPTIONSPG_COLORS, IDS_OPTIONSPG_MARKERCOLORS);
	AddPage(&m_pageDirColors, IDS_OPTIONSPG_COLORS, IDS_OPTIONSPG_DIRCOLORS);
	AddPage(&m_pageSysColors, IDS_OPTIONSPG_COLORS, IDS_OPTIONSPG_SYSCOLORS);
	AddPage(&m_pageArchive, IDS_OPTIONSPG_ARCHIVE);
	AddPage(&m_pageProject, IDS_OPTIONSPG_PROJECT);
	AddPage(&m_pageSystem, IDS_OPTIONSPG_SYSTEM);
	AddPage(&m_pageBackups, IDS_OPTIONSPG_BACKUPS);
	AddPage(&m_pageCodepage, IDS_OPTIONSPG_CODEPAGE);
	AddPage(&m_pageShell, IDS_OPTIONSPG_SHELL);

	ReadOptions();
	
	CRect rPPHost;
	GetDlgItem(IDC_TREEOPT_HOSTFRAME)->GetWindowRect(rPPHost);
	ScreenToClient(rPPHost);

	if (m_pphost.Create(rPPHost, this))
		SetActivePage(AfxGetApp()->GetProfileInt(_T("Settings"), _T("OptStartPage"), 0));
 
	// setup handler for resizing this dialog	
	m_constraint.InitializeCurrentSize(this);
	m_constraint.SubclassWnd(); // install subclassing
	m_constraint.LoadPosition(_T("ResizeableDialogs"), _T("OptionsDlg"), false); // persist size via registry
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CPreferencesDlg::OnOK()
{
	CDialog::OnOK();
	m_pphost.OnOK();

	SaveOptions();

	AfxGetApp()->WriteProfileInt(_T("Settings"), _T("OptStartPage"), m_pphost.GetActiveIndex());
}

void CPreferencesDlg::OnSize(UINT nType, int cx, int cy)
{
	CWnd::OnSize(nType, cx, cy);

	if (CWnd *pPPHostWnd = GetDlgItem(IDC_TREEOPT_HOSTFRAME))
	{
		CRect rPPHost;
		pPPHostWnd->GetWindowRect(rPPHost);
		ScreenToClient(rPPHost);
		m_pphost.MoveWindow(&rPPHost);
	}
}
	
void CPreferencesDlg::OnHelpButton() 
{
	theApp.ShowHelp(OptionsHelpLocation);
}

void CPreferencesDlg::AddPage(CPropertyPage* pPage, UINT nResourceID)
{
	String sPath = theApp.LoadString(nResourceID);
	AddPage(pPage, sPath.c_str());
}

void CPreferencesDlg::AddPage(CPropertyPage* pPage, UINT nTopHeading, UINT nSubHeading)
{
	String sPath = theApp.LoadString(nTopHeading);
	sPath += _T(">");
	sPath += theApp.LoadString(nSubHeading);
	AddPage(pPage, sPath.c_str());
}

void CPreferencesDlg::AddPage(CPropertyPage* pPage, const tchar_t* szPath)
{
	if (m_pphost.AddPage(pPage))
	{
		CString sPath(szPath);
		HTREEITEM htiParent = TVI_ROOT; // default
		int nFind = sPath.Find(PATHDELIM);

		while (nFind != -1)
		{
			CString sParent = sPath.Left(nFind);
			sPath = sPath.Mid(nFind + 1);

			// see if parent already exists
			HTREEITEM htiParentParent = htiParent;
			htiParent = m_tcPages.GetChildItem(htiParentParent);

			while (htiParent != nullptr)
			{
				if (sParent.CompareNoCase(m_tcPages.GetItemText(htiParent)) == 0)
					break;

				htiParent = m_tcPages.GetNextItem(htiParent, TVGN_NEXT);
			}

			if (htiParent == nullptr)
				htiParent = m_tcPages.InsertItem(sParent, htiParentParent);

			nFind = sPath.Find(PATHDELIM);
		}

		HTREEITEM hti = m_tcPages.InsertItem(sPath, htiParent); // whatever's left
		m_tcPages.EnsureVisible(hti);

		// map both ways
		m_tcPages.SetItemData(hti, static_cast<DWORD_PTR>(reinterpret_cast<uintptr_t>(pPage)));
		m_mapPP2HTI[(void*)pPage] = (void*)hti;
	}
}

void CPreferencesDlg::OnSelchangedPages(NMHDR* pNMHDR, LRESULT* pResult) 
{
	UNREFERENCED_PARAMETER(pNMHDR);
	HTREEITEM htiSel = m_tcPages.GetSelectedItem();

	while (m_tcPages.ItemHasChildren(htiSel))
		htiSel = m_tcPages.GetChildItem(htiSel);

	CPropertyPage* pPage = (CPropertyPage*)m_tcPages.GetItemData(htiSel);
	ASSERT (pPage != nullptr);

	if (pPage != nullptr)
	{
		m_pphost.SetActivePage(pPage, false);

		// update caption
		String sCaption = strutils::format_string1(_("Options (%1)"), (const tchar_t*)GetItemPath(htiSel));
		SetWindowText(sCaption.c_str());
	}

	m_tcPages.SetFocus();
	
	*pResult = 0;
}

void CPreferencesDlg::SetActivePage(int nPage)
{
	m_pphost.SetActivePage(nPage, false);

	// synchronize tree
	CPropertyPage* pPage = m_pphost.GetActivePage();
	HTREEITEM hti = nullptr;

	if (m_mapPP2HTI.Lookup(pPage, (void*&)hti) && hti != nullptr)
		m_tcPages.SelectItem(hti);
}

CString CPreferencesDlg::GetItemPath(HTREEITEM hti)
{
	CString sPath = m_tcPages.GetItemText(hti);

	hti = m_tcPages.GetParentItem(hti);
	while (hti != nullptr)
	{
		sPath = m_tcPages.GetItemText(hti) + _T(" > ") + sPath;
		hti = m_tcPages.GetParentItem(hti);
	}

	return sPath;
}

/**
 * @brief Read options from storage to UI controls.
 * @param [in] bUpdate If `true` UpdateData() is called
 */
void CPreferencesDlg::ReadOptions(bool bUpdate)
{
	m_pageGeneral.ReadOptions();
	m_pageColorSchemes.ReadOptions();
	m_pageMergeColors.ReadOptions();
	m_pageTextColors.ReadOptions();
	m_pageSyntaxColors.ReadOptions();
	m_pageMarkerColors.ReadOptions();
	m_pageDirColors.ReadOptions();
	m_pageSysColors.ReadOptions();
	m_pageSystem.ReadOptions();
	m_pageCompare.ReadOptions();
	m_pageCompareFolder.ReadOptions();
	m_pageCompareTable.ReadOptions();
	m_pageCompareBinary.ReadOptions();
	m_pageCompareImage.ReadOptions();
	m_pageCompareWebPage.ReadOptions();
	m_pageMessageBoxes.ReadOptions();
	m_pageEditor.ReadOptions();
	m_pageEditorCompareMerge.ReadOptions();
	m_pageEditorSyntax.ReadOptions();
	m_pageCodepage.ReadOptions();
	m_pageArchive.ReadOptions();
	m_pageProject.ReadOptions();
	m_pageBackups.ReadOptions();
	m_pageShell.ReadOptions();

	if (bUpdate)
	{
		SafeUpdatePage(&m_pageGeneral, false);
		SafeUpdatePage(&m_pageColorSchemes, false);
		SafeUpdatePage(&m_pageMergeColors, false);
		SafeUpdatePage(&m_pageTextColors, false);
		SafeUpdatePage(&m_pageSyntaxColors, false);
		SafeUpdatePage(&m_pageMarkerColors, false);
		SafeUpdatePage(&m_pageDirColors, false);
		SafeUpdatePage(&m_pageSysColors, false);
		SafeUpdatePage(&m_pageSystem, false);
		SafeUpdatePage(&m_pageCompare, false);
		SafeUpdatePage(&m_pageCompareFolder, false);
		SafeUpdatePage(&m_pageCompareTable, false);
		SafeUpdatePage(&m_pageCompareBinary, false);
		SafeUpdatePage(&m_pageCompareImage, false);
		SafeUpdatePage(&m_pageMessageBoxes, false);
		SafeUpdatePage(&m_pageEditor, false);
		SafeUpdatePage(&m_pageEditorCompareMerge, false);
		SafeUpdatePage(&m_pageEditorSyntax, false);
		SafeUpdatePage(&m_pageCodepage, false);
		SafeUpdatePage(&m_pageArchive, false);
		SafeUpdatePage(&m_pageProject, false);
		SafeUpdatePage(&m_pageBackups, false);
		SafeUpdatePage(&m_pageShell, false);
	}
}

/**
 * @brief Write options from UI to storage.
 */
void CPreferencesDlg::SaveOptions()
{
	m_pageGeneral.WriteOptions();
	m_pageSystem.WriteOptions();
	m_pageCompare.WriteOptions();
	m_pageCompareFolder.WriteOptions();
	m_pageCompareTable.WriteOptions();
	m_pageCompareBinary.WriteOptions();
	m_pageCompareImage.WriteOptions();
	m_pageCompareWebPage.WriteOptions();
	m_pageMessageBoxes.WriteOptions();
	m_pageEditor.WriteOptions();
	m_pageEditorCompareMerge.WriteOptions();
	m_pageEditorSyntax.WriteOptions();
	m_pageColorSchemes.WriteOptions();
	m_pageMergeColors.WriteOptions();
	m_pageTextColors.WriteOptions();
	m_pageSyntaxColors.WriteOptions();
	m_pageMarkerColors.WriteOptions();
	m_pageDirColors.WriteOptions();
	m_pageSysColors.WriteOptions();
	m_pageCodepage.WriteOptions();
	m_pageArchive.WriteOptions();
	m_pageProject.WriteOptions();
	m_pageBackups.WriteOptions();
	m_pageShell.WriteOptions();
	m_pSyntaxColorsOrg->Clone(m_pSyntaxColors.get());
}

/**
 * @brief Imports options from file.
 */
void CPreferencesDlg::OnImportButton()
{
	String s;
	if (SelectFile(GetSafeHwnd(), s, true, nullptr, _("Select file for import"), _("Options files (*.ini)|*.ini|All Files (*.*)|*.*||")))
	{
		if (m_pOptionsMgr->ImportOptions(s) == COption::OPT_OK)
		{
			Options::SyntaxColors::Load(m_pOptionsMgr, m_pSyntaxColors.get());
			theApp.m_pLineFilters->Initialize(GetOptionsMgr());
			theApp.m_pSubstitutionFiltersList->Initialize(GetOptionsMgr());

			ReadOptions(true);
			LangMessageBox(IDS_OPT_IMPORT_DONE, MB_ICONINFORMATION);
		}
		else
			LangMessageBox(IDS_OPT_IMPORT_ERR, MB_ICONWARNING);
	}
}

/**
 * @brief Exports options to file.
 */
void CPreferencesDlg::OnExportButton()
{
	String settingsFile;
	if (SelectFile(GetSafeHwnd(), settingsFile, false, nullptr, _("Select file for export"),
		_("Options files (*.ini)|*.ini|All Files (*.*)|*.*||")))
	{
		// Add settings file extension if it is missing
		// So we allow 'filename.otherext' but add extension for 'filename'
		if (paths::FindExtension(settingsFile).empty())
			settingsFile += _T(".ini");

		// Save all new settings before exporting
		m_pphost.UpdatePagesData();
		SaveOptions();

		if (m_pOptionsMgr->ExportOptions(settingsFile, true) == COption::OPT_OK)
			LangMessageBox(IDS_OPT_EXPORT_DONE, MB_ICONINFORMATION);
		else
			LangMessageBox(IDS_OPT_EXPORT_ERR, MB_ICONWARNING);
	}
}

LRESULT CPreferencesDlg::OnColorSchemeChanged(WPARAM wParams, LPARAM lParam)
{
	Options::SyntaxColors::Load(m_pOptionsMgr, m_pSyntaxColors.get());
	ReadOptions(true);
	EnableDlgItem(IDCANCEL, false);
	return 0;
}

/**
 * @brief Do a safe UpdateData call for propertypage.
 * This function does safe UpdateData call for given propertypage. As it is,
 * all propertypages may not have been yet initialized properly, so we must
 * have some care when calling updateData for them.
 * @param [in] pPage Propertypage to update.
 * @param bSaveAndValidate UpdateData direction parameter.
 */
void CPreferencesDlg::SafeUpdatePage(CPropertyPage* pPage, bool bSaveAndValidate)
{
	if (pPage->GetSafeHwnd() != nullptr)
		pPage->UpdateData(bSaveAndValidate);
}
</file>

<file path="Winmerge-Src/Src/Common/PreferencesDlg.h">
/** 
 * @file  PreferencesDlg.h
 *
 * @brief Declaration of CPreferencesDlg class
 *
 * @note This code originates from AbstractSpoon / TodoList
 * (http://www.abstractspoon.com/) but is modified to use in
 * WinMerge.
 */
#pragma once

#include "TrDialogs.h"
#include "PropGeneral.h"
#include "PropCompare.h"
#include "PropMessageBoxes.h"
#include "PropEditor.h"
#include "PropEditorCompareMerge.h"
#include "PropEditorSyntax.h"
#include "PropRegistry.h"
#include "PropColorSchemes.h"
#include "PropMergeColors.h"
#include "PropTextColors.h"
#include "PropSyntaxColors.h"
#include "PropMarkerColors.h"
#include "PropDirColors.h"
#include "PropSysColors.h"
#include "PropCodepage.h"
#include "PropArchive.h"
#include "PropProject.h"
#include "PropBackups.h"
#include "PropShell.h"
#include "PropCompareFolder.h"
#include "PropCompareTable.h"
#include "PropCompareBinary.h"
#include "PropCompareImage.h"
#include "PropCompareWebPage.h"

#include "PropertyPageHost.h"
#include "CMoveConstraint.h"

class COptionsMgr;
class SyntaxColors;

/////////////////////////////////////////////////////////////////////////////
// CPreferencesDlg dialog

class CPreferencesDlg : public CTrDialog
{
// Construction
public:
	//CPreferencesDlg(UINT nMenuID = 0, CWnd* pParent = nullptr);   // standard constructor
	CPreferencesDlg(COptionsMgr *optionsMgr, SyntaxColors *colors,
		UINT nMenuID = 0, CWnd* pParent = nullptr);   // standard constructor
	virtual ~CPreferencesDlg();

private:
	COptionsMgr *m_pOptionsMgr;
	std::unique_ptr<SyntaxColors> m_pSyntaxColors;
	SyntaxColors* m_pSyntaxColorsOrg;
	prdlg::CMoveConstraint m_constraint; /**< Resizes dialog controls when dialog resized */

protected:
// Dialog Data
	//{{AFX_DATA(CPreferencesDlg)
	CTreeCtrl m_tcPages;
	//}}AFX_DATA

	CPropertyPageHost m_pphost;
	
	PropGeneral m_pageGeneral;
	PropCompare m_pageCompare;
	PropMessageBoxes m_pageMessageBoxes;
	PropEditor m_pageEditor;
	PropEditorCompareMerge m_pageEditorCompareMerge;
	PropEditorSyntax m_pageEditorSyntax;
	PropRegistry m_pageSystem;
	PropCodepage m_pageCodepage;
	PropColorSchemes m_pageColorSchemes;
	PropMergeColors m_pageMergeColors;
	PropTextColors m_pageTextColors;
	PropSyntaxColors m_pageSyntaxColors;
	PropMarkerColors m_pageMarkerColors;
	PropDirColors m_pageDirColors;
	PropSysColors m_pageSysColors;
	PropArchive m_pageArchive;
	PropProject m_pageProject;
	PropBackups m_pageBackups;
	PropShell m_pageShell;
	PropCompareFolder m_pageCompareFolder;
	PropCompareTable m_pageCompareTable;
	PropCompareBinary m_pageCompareBinary;
	PropCompareImage m_pageCompareImage;
	PropCompareWebPage m_pageCompareWebPage;

	CMapPtrToPtr m_mapPP2HTI;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPreferencesDlg)
	public:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL
	virtual void OnOK();

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CPreferencesDlg)
	virtual BOOL OnInitDialog() override;
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnHelpButton();
	afx_msg void OnImportButton();
	afx_msg void OnExportButton();
	afx_msg LRESULT OnColorSchemeChanged(WPARAM wParam, LPARAM lParam);
	afx_msg void OnSelchangedPages(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	void AddPage(CPropertyPage* pPage, UINT nResourceID);
	void AddPage(CPropertyPage* pPage, const tchar_t* szPath);
	void AddPage(CPropertyPage* pPage, UINT nTopHeading, UINT nSubHeading);
	void SetActivePage(int nPage);
	CString GetItemPath(HTREEITEM hti);
	void ReadOptions(bool bUpdate = false);
	void SaveOptions();
	void SafeUpdatePage(CPropertyPage* pPage, bool bSaveAndValidate);
};
</file>

<file path="Winmerge-Src/Src/Common/PropertyPageHost.cpp">
/** 
 * @file PropertyPageHost.cpp
 *
 * @brief Implementation file for CPropertypageHost
 *
 * @note This code originates from AbstractSpoon / TodoList
 * (http://www.abstractspoon.com/) but is modified to use in
 * WinMerge.
 */

#include "StdAfx.h"
#include "PropertyPageHost.h"

#ifdef _WIN64
#	include <../src/mfc/occimpl.h>
#else // _WIN64
#	include <afxocc.h>
#endif // _WIN64

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CPropertyPageHost

CPropertyPageHost::CPropertyPageHost() : m_nSelIndex(-1)
{
}

CPropertyPageHost::~CPropertyPageHost()
{
}


BEGIN_MESSAGE_MAP(CPropertyPageHost, CWnd)
	//{{AFX_MSG_MAP(CPropertyPageHost)
	ON_WM_SIZE()
	ON_WM_ERASEBKGND()
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
	ON_MESSAGE(PSM_GETCURRENTPAGEHWND, OnGetCurrentPageHwnd)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CPropertyPageHost message handlers

BOOL CPropertyPageHost::Create(UINT nRefCtrlID, CWnd* pParent, UINT uCtrlID)
{
	ASSERT_VALID(pParent);

	if (pParent == nullptr || !::IsWindow(*pParent))
		return FALSE;

	CWnd* pRefCtrl = pParent->GetDlgItem(nRefCtrlID);

	ASSERT_VALID(pRefCtrl);

	if (pRefCtrl == nullptr || !::IsWindow(*pRefCtrl))
		return FALSE;

	CRect rHost;
	pRefCtrl->GetWindowRect(rHost);
	pParent->ScreenToClient(rHost);

	if (Create(rHost, pParent, uCtrlID))
	{
		// move us after nRefCtrlID in the z-order
		SetWindowPos(pRefCtrl, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
		return TRUE;
	}

	return FALSE;
}

BOOL CPropertyPageHost::Create(LPRECT lpRect, CWnd* pParent, UINT uCtrlID)
{
	ASSERT_VALID(pParent);

	if (pParent == nullptr || !::IsWindow(*pParent))
		return FALSE;

	if (!m_aPages.GetSize())
		return FALSE;

	if (!CWnd::Create(nullptr, nullptr, WS_CHILD | WS_VISIBLE, *lpRect, pParent, uCtrlID))
		return FALSE;

	// create the first page
	return SetActivePage(0);
}

int CPropertyPageHost::GetActiveIndex()
{
	return m_nSelIndex;
}

CPropertyPage* CPropertyPageHost::GetActivePage()
{
	if (m_nSelIndex < 0)
		return nullptr;

	CPropertyPage* pPage = m_aPages[m_nSelIndex].pPage;

	if (pPage == nullptr || pPage->GetSafeHwnd() == nullptr)
		return nullptr;

	return pPage;
}

LRESULT CPropertyPageHost::OnGetCurrentPageHwnd(WPARAM wParam, LPARAM lParam)
{
	CWnd* pActive = GetActivePage();

	return pActive ? (LRESULT)pActive->GetSafeHwnd() : NULL;
}

bool CPropertyPageHost::SetActivePage(int nIndex, bool bAndFocus /*= true*/)
{
	if (nIndex < 0 || nIndex >= m_aPages.GetSize())
		return false;

	CPropertyPage* pPage = m_aPages[nIndex].pPage;

	if (pPage == nullptr)
		return false;

	CWnd* pFocus = GetFocus();

	if (pPage->GetSafeHwnd() == nullptr && !pPage->Create(pPage->m_psp.pszTemplate, this))
		return false;

	// make sure we can into/out of the page
	pPage->ModifyStyleEx(0, WS_EX_CONTROLPARENT | DS_CONTROL);

	// make sure the page is a child and modify it if necessary
	pPage->ModifyStyle(WS_POPUPWINDOW | WS_OVERLAPPEDWINDOW, 0);

	if (!(pPage->GetStyle() & WS_CHILD))
	{
		pPage->ModifyStyle(0, WS_CHILD);
		pPage->SetParent(this);
		ASSERT (pPage->GetParent() == this);
	}


	CRect rClient;
	GetClientRect(rClient);

	pPage->SetParent(this);
	pPage->MoveWindow(rClient);

	if (m_nSelIndex != -1)
	{
		CPropertyPage* pPage1 = GetActivePage();
		ASSERT (pPage1 != nullptr);

		if (pPage1 != nullptr)
		{
			pPage1->ShowWindow(SW_HIDE);
			pPage1->OnKillActive();
		}
	}

	pPage->OnSetActive();
	pPage->ShowWindow(SW_SHOW);

	// move the focus to the first dlg ctrl
	if (bAndFocus)
	{
		CWnd* pCtrl = pPage->GetNextDlgTabItem(nullptr);

		if (pCtrl != nullptr)
			pCtrl->SetFocus();
	}
	else if (pFocus)
		pFocus->SetFocus();

	m_nSelIndex = nIndex;
	return true;
}

bool CPropertyPageHost::SetActivePage(CPropertyPage* pPage, bool bAndFocus /*= true*/)
{
	return SetActivePage(FindPage(pPage));
}

bool CPropertyPageHost::AddPage(CPropertyPage* pPage, const tchar_t* szTitle /*= nullptr*/, DWORD dwItemData /*= 0*/)
{
	if (pPage == nullptr || !pPage->IsKindOf(RUNTIME_CLASS(CPropertyPage)))
		return false;

	if (FindPage(pPage) == -1)
	{
		PAGEITEM pi(pPage, szTitle, dwItemData);
		int nPage = (int) m_aPages.Add(pi);

		if (szTitle != nullptr)
		{
			pPage->m_psp.pszTitle = m_aPages[nPage].sTitle; // the final string address
			pPage->m_psp.dwFlags |= PSP_USETITLE;
		}
	}

	return true;
}

int CPropertyPageHost::FindPage(CPropertyPage* pPage)
{
	int nPage = (int) m_aPages.GetSize();

	while (nPage--)
	{
		if (m_aPages[nPage].pPage == pPage)
			break;
	}

	return nPage;
}

BOOL CPropertyPageHost::PreTranslateMessage(MSG* pMsg) 
{
	CWnd* pActive = GetActivePage();

	if (pActive != nullptr)
	{
		if (pActive->PreTranslateMessage(pMsg))
			return TRUE;
		
		else if (pActive->IsDialogMessage(pMsg)) 
			return TRUE;
	}
	
	return FALSE;
}

// unfortunately there is a bug in MFC that can cause an infinite loop
// when the property page is hosting an OLE control so we fix
// it by providing a replacement to the buggy code
BOOL COccManager::IsDialogMessage(CWnd* pWndDlg, LPMSG lpMsg)
{
	UINT uMsg = lpMsg->message;

	if (((uMsg >= WM_KEYFIRST) && (uMsg <= WM_KEYLAST)) ||
		((uMsg >= WM_MOUSEFIRST) && (uMsg <= WM_MOUSELAST)))
	{
		CWnd* pWndCtrl = CWnd::GetFocus();

		// Walk up the parent chain, until we find an OLE control.
		while ((pWndCtrl != nullptr) && (pWndCtrl->m_pCtrlSite == nullptr) &&
			(pWndCtrl->GetParent() != pWndDlg))
		{
			pWndCtrl = pWndCtrl->GetParent();
		}

		// let the control attempt to translate the message
		if (pWndCtrl != nullptr && pWndCtrl->m_pCtrlSite != nullptr &&
			pWndCtrl->m_pCtrlSite->m_pActiveObject != nullptr &&
			pWndCtrl->m_pCtrlSite->m_pActiveObject->TranslateAccelerator(lpMsg) == S_OK)
		{
			return TRUE;
		}

		// handle CTRLINFO_EATS_RETURN and CTRLINFO_EATS_ESCAPE flags
		if ((uMsg == WM_KEYUP || uMsg == WM_KEYDOWN || uMsg == WM_CHAR) &&
			pWndCtrl != nullptr && pWndCtrl->m_pCtrlSite != nullptr &&
			((LOWORD(lpMsg->wParam) == VK_RETURN &&
			 (pWndCtrl->m_pCtrlSite->m_ctlInfo.dwFlags & CTRLINFO_EATS_RETURN)) ||
			(LOWORD(lpMsg->wParam) == VK_ESCAPE &&
			 (pWndCtrl->m_pCtrlSite->m_ctlInfo.dwFlags & CTRLINFO_EATS_ESCAPE))))
		{
			return FALSE;
		}
	}

	// else simple default
	// because this is where the MFC bug existed
	return ::IsDialogMessage(pWndDlg->GetSafeHwnd(), lpMsg);
}

void CPropertyPageHost::OnSize(UINT nType, int cx, int cy) 
{
	CWnd::OnSize(nType, cx, cy);
	
	// resize active page
	if (m_nSelIndex != -1)
	{
		CPropertyPage* pPage = GetActivePage();
		ASSERT (pPage != nullptr);

		if (pPage != nullptr)
			pPage->MoveWindow(0, 0, cx, cy, TRUE);
	}
}

BOOL CPropertyPageHost::OnEraseBkgnd(CDC* pDC) 
{
	return TRUE;
}

void CPropertyPageHost::OnOK()
{
	int nPage = (int) m_aPages.GetSize();

	while (nPage--)
	{
		CPropertyPage* pPage = m_aPages[nPage].pPage;

		if (pPage!= nullptr && pPage->GetSafeHwnd() != nullptr)
		{
			pPage->UpdateData();
			pPage->OnOK();
		}
	}
}

/**
 * @brief Update all PropertyPages.
 */
void CPropertyPageHost::UpdatePagesData()
{
	int nPage = (int) m_aPages.GetSize();

	while (nPage--)
	{
		CPropertyPage* pPage = m_aPages[nPage].pPage;

		if (pPage!= nullptr && pPage->GetSafeHwnd()!= nullptr)
		{
			pPage->UpdateData();
		}
	}
}

int CPropertyPageHost::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	// *************************************************************************
	// EXTREMELY IMPORTANT
	// set these styles because otherwise propsheet
	// goes into infinite loop when focus changes
	ModifyStyle(0, DS_CONTROL, 0);
	ModifyStyleEx(0, WS_EX_CONTROLPARENT);
	// *************************************************************************
	
	return 0;
}

CString CPropertyPageHost::GetPageTitle(int nIndex)
{
	if (nIndex < 0 || nIndex > m_aPages.GetSize())
		return _T("");

	return m_aPages[nIndex].sTitle;
}

DWORD CPropertyPageHost::GetPageItemData(int nIndex)
{
	if (nIndex < 0 || nIndex > m_aPages.GetSize())
		return 0;

	return m_aPages[nIndex].dwItemData;
}

CPropertyPage* CPropertyPageHost::GetPage(int nIndex)
{
	if (nIndex < 0 || nIndex > m_aPages.GetSize())
		return nullptr;

	return m_aPages[nIndex].pPage;
}

CPropertyPage* CPropertyPageHost::FindPage(DWORD dwItemData)
{
	int nPage = (int) m_aPages.GetSize();

	while (nPage--)
	{
		if (dwItemData && dwItemData == m_aPages[nPage].dwItemData)
			return m_aPages[nPage].pPage;
	}

	return nullptr;
}
</file>

<file path="Winmerge-Src/Src/Common/PropertyPageHost.h">
/** 
 * @file  PropertyPageHost.h
 *
 * @brief Declaration of CPropertyPageHost class
 *
 * @note This code originates from AbstractSpoon / TodoList
 * (http://www.abstractspoon.com/) but is modified to use in
 * WinMerge.
 */
#pragma once

#include <afxtempl.h>

/////////////////////////////////////////////////////////////////////////////
// CPropertyPageHost window

struct PAGEITEM
{
	PAGEITEM(CPropertyPage* _pPage = nullptr, const tchar_t* szTitle = nullptr, DWORD dwData = 0) : 
			pPage(_pPage), sTitle(szTitle), dwItemData(dwData) {}

	CPropertyPage* pPage;
	CString sTitle;
	DWORD dwItemData;
};

class CPropertyPageHost : public CWnd
{
// Construction
public:
	CPropertyPageHost();

	BOOL Create(LPRECT lpRect, CWnd* pParent, UINT uCtrlID = AFX_IDW_PANE_FIRST);
	BOOL Create(UINT nRefCtrlID, CWnd* pParent, UINT uCtrlID = AFX_IDW_PANE_FIRST);
	void OnOK();
	void UpdatePagesData();
	
	int GetActiveIndex();
	CPropertyPage* GetActivePage();
	bool AddPage(CPropertyPage* pPage, const tchar_t* szTitle = nullptr, DWORD dwItemData = 0);
	bool SetActivePage(int nIndex, bool bAndFocus = true);
	bool SetActivePage(CPropertyPage* pPage, bool bAndFocus = true);
	int GetPageCount() { return (int) m_aPages.GetSize(); }
	CString GetPageTitle(int nIndex);
	DWORD GetPageItemData(int nIndex);
	CPropertyPage* GetPage(int nIndex);
	CPropertyPage* FindPage(DWORD dwItemData);

protected:
	CArray<PAGEITEM, PAGEITEM&> m_aPages;
	int m_nSelIndex;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPropertyPageHost)
	public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CPropertyPageHost();

	// Generated message map functions
protected:
	//{{AFX_MSG(CPropertyPageHost)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	afx_msg LRESULT OnGetCurrentPageHwnd(WPARAM wParam, LPARAM lParam);
	DECLARE_MESSAGE_MAP()

protected:
	int FindPage(CPropertyPage* pPage);

};
</file>

<file path="Winmerge-Src/Src/Common/RegKey.cpp">
/** 
 * @file  RegKey.cpp
 *
 * @brief Implementation of CRegKeyEx C++ wrapper class for reading Windows registry
 */

#include "pch.h"
#define NOMINMAX
#include "RegKey.h"
#include <windows.h>
#include <cassert>
#include <strsafe.h>
#include "UnicodeString.h"

/**
 * @brief Default constructor.
 */
CRegKeyEx::CRegKeyEx()
: m_hKey(nullptr)
{
}

/**
 * @brief Default destructor.
 */
CRegKeyEx::~CRegKeyEx()
{
	Close();
}

/**
 * @brief Closes the key.
 */
void CRegKeyEx::Close()
{
	if (m_hKey != nullptr) 
	{
		RegCloseKey(m_hKey);
		m_hKey = nullptr;
	}
}

/**
 * @brief Opens or creates a key in given path.
 * @param [in] hKeyRoot Root key to open, HKLM, HKCU..
 * @param [in] pszPath Path to actual registry key to access.
 * @return ERROR_SUCCESS or error value.
 */
LONG CRegKeyEx::Open(HKEY hKeyRoot, const tchar_t* pszPath)
{
	return OpenWithAccess(hKeyRoot, pszPath, KEY_ALL_ACCESS);
}

/**
 * @brief Opens or creates a key in given path with access control.
 * @param [in] hKeyRoot Root key to open, HKLM, HKCU..
 * @param [in] pszPath Path to actual registry key to access.
 * @param [in] regsam Registry access parameter.
 * @return ERROR_SUCCESS or error value.
 */
LONG CRegKeyEx::OpenWithAccess(HKEY hKeyRoot, const tchar_t* pszPath, REGSAM regsam)
{
	DWORD dw;

	Close();
	m_sPath = pszPath;

	return RegCreateKeyEx(hKeyRoot, pszPath, 0L, nullptr,
		REG_OPTION_NON_VOLATILE, regsam, nullptr, 
		&m_hKey, &dw);
}

/**
 * @brief Opens key in given path.
 * @param [in] hKeyRoot Root key to open, HKLM, HKCU..
 * @param [in] pszPath Path to actual registry key to access.
 * @param [in] regsam Registry access parameter.
 * @return ERROR_SUCCESS or error value.
 */
LONG CRegKeyEx::OpenNoCreateWithAccess(HKEY hKeyRoot, const tchar_t* pszPath, REGSAM regsam)
{
	Close();

	m_sPath = pszPath;

	return RegOpenKeyEx (hKeyRoot, pszPath, 0L, regsam, &m_hKey);
}

/**
 * @brief Opens registry key from HKEY_LOCAL_MACHINE for reading.
 * @param [in] key Path to actual registry key to access.
 * @return true on success, false otherwise.
 */
bool CRegKeyEx::QueryRegMachine(const tchar_t* key)
{
	return OpenNoCreateWithAccess(HKEY_LOCAL_MACHINE, key, KEY_QUERY_VALUE) == ERROR_SUCCESS;
}

/**
 * @brief Opens registry key from HKEY_CURRENT_USER for reading.
 * @param [in] key Path to actual registry key to access.
 * @return true on success, false otherwise.
 */
bool CRegKeyEx::QueryRegUser(const tchar_t* key)
{
	return OpenNoCreateWithAccess(HKEY_CURRENT_USER, key, KEY_QUERY_VALUE) == ERROR_SUCCESS;
}

/**
 * @brief Write DWORD value to registry.
 * @param [in] pszKey Path to actual registry key to access.
 * @param [in] dwVal Value to write.
 * @return ERROR_SUCCESS on success, or error value.
 */
LONG CRegKeyEx::WriteDword(const tchar_t* pszKey, DWORD dwVal)
{
	assert(m_hKey != nullptr);
	assert(pszKey != nullptr);
	return RegSetValueEx(m_hKey, pszKey, 0L, REG_DWORD,
		(const LPBYTE) &dwVal, sizeof(DWORD));
}

/**
 * @brief Write `bool` value to registry.
 * @param [in] pszKey Path to actual registry key to access.
 * @param [in] bVal Value to write.
 * @return ERROR_SUCCESS on success, or error value.
 */
LONG CRegKeyEx::WriteBool(const tchar_t* pszKey, bool bVal)
{
	assert(m_hKey != nullptr);
	assert(pszKey != nullptr);
	DWORD dwVal = (DWORD)bVal; 
	return RegSetValueEx(m_hKey, pszKey, 0L, REG_DWORD,
		(const LPBYTE) &dwVal, sizeof(DWORD));
}

/**
 * @brief Write float value to registry.
 * @param [in] pszKey Path to actual registry key to access.
 * @param [in] fVal Value to write.
 * @return ERROR_SUCCESS on success, or error value.
 */
LONG CRegKeyEx::WriteFloat(const tchar_t* pszKey, float fVal)
{
	assert(m_hKey != nullptr);
	assert(pszKey != nullptr);
	String s = strutils::to_str(fVal);
	return RegSetValueEx(m_hKey, pszKey, 0L, REG_SZ,
		(const LPBYTE) s.c_str(), static_cast<DWORD>((s.length() + 1))*sizeof(tchar_t) );
}

/**
 * @brief Write string value to registry.
 * @param [in] pszKey Path to actual registry key to access.
 * @param [in] pszData Value to write.
 * @return ERROR_SUCCESS on success, or error value.
 */
LONG CRegKeyEx::WriteString(const tchar_t* pszKey, const tchar_t* pszData)
{
	assert(m_hKey != nullptr);
	assert(pszKey != nullptr);
	assert(pszData != nullptr);

	return RegSetValueEx(m_hKey, pszKey, 0L, REG_SZ,
		(const LPBYTE) pszData, static_cast<DWORD>(tc::tcslen(pszData)+ 1)*sizeof(tchar_t));
}

/**
 * @brief Read DWORD value from registry.
 * @param [in] pszKey Path to actual registry key to access.
 * @param [in] defval Default value to return if reading fails.
 * @return Read DWORD value.
 */
DWORD CRegKeyEx::ReadDword(const tchar_t* pszKey, DWORD defval)
{
	assert(m_hKey != nullptr);
	assert(pszKey != nullptr);

	DWORD dwType;
	DWORD dwSize = sizeof (DWORD);
	DWORD dwDest;

	LONG lRet = RegQueryValueEx (m_hKey, (tchar_t*) pszKey, nullptr, 
		&dwType, (LPBYTE) &dwDest, &dwSize);

	if (lRet == ERROR_SUCCESS)
		return dwDest;
	else
		return defval;
}

/**
 * @brief Read LONG value from registry.
 * @param [in] pszKey Path to actual registry key to access.
 * @param [in] defval Default value to return if reading fails.
 * @return Read LONG value.
 */
LONG CRegKeyEx::ReadLong(const tchar_t* pszKey, LONG defval)
{
	return (LONG)ReadDword(pszKey, (DWORD)defval);
}

/**
 * @brief Read UINT value from registry.
 * @param [in] pszKey Path to actual registry key to access.
 * @param [in] defval Default value to return if reading fails.
 * @return Read UINT value.
 */
UINT CRegKeyEx::ReadUint(const tchar_t* pszKey, UINT defval)
{
	return (UINT)ReadDword(pszKey, (DWORD)defval);
}

/**
 * @brief Read UINT value from registry.
 * @param [in] pszKey Path to actual registry key to access.
 * @param [in] defval Default value to return if reading fails.
 * @return Read UINT value.
 */
UINT CRegKeyEx::ReadInt(const tchar_t* pszKey, int defval)
{
	return (int)ReadDword(pszKey, (DWORD)defval);
}

/**
 * @brief Read short int value from registry.
 * @param [in] pszKey Path to actual registry key to access.
 * @param [in] defval Default value to return if reading fails.
 * @return Read short int value.
 */
short int CRegKeyEx::ReadShort(const tchar_t* pszKey, short int defval)
{
	return (short int)ReadDword(pszKey, (DWORD)defval);
}

/**
 * @brief Read BYTE value from registry.
 * @param [in] pszKey Path to actual registry key to access.
 * @param [in] defval Default value to return if reading fails.
 * @return Read BYTE value.
 */
BYTE CRegKeyEx::ReadByte(const tchar_t* pszKey, BYTE defval)
{
	return (BYTE)ReadDword(pszKey, (DWORD)defval);
}

/**
 * @brief Read float value from registry.
 * @param [in] pszKey Path to actual registry key to access.
 * @param [in] defval Default value to return if reading fails.
 * @return Read float value.
 */
float CRegKeyEx::ReadFloat(const tchar_t* pszKey, float defval)
{
	assert(m_hKey != nullptr);
	assert(pszKey != nullptr);

	DWORD dwType;
	DWORD dwSize = 100;
	tchar_t  string[100];

	LONG lReturn = RegQueryValueEx(m_hKey, (tchar_t*) pszKey, nullptr,
		&dwType, (LPBYTE) string, &dwSize);

	if (lReturn == ERROR_SUCCESS)
		return (float)tc::tcstod(string, nullptr);
	else
		return defval;
}

/**
 * @brief Read `bool` value from registry.
 * @param [in] pszKey Path to actual registry key to access.
 * @param [in] defval Default value to return if reading fails.
 * @return Read `bool` value.
 */
bool CRegKeyEx::ReadBool(const tchar_t* pszKey, bool defval)
{
	assert(m_hKey != nullptr);
	assert(pszKey != nullptr);

	DWORD dwType;
	DWORD dwSize = sizeof(DWORD);
	DWORD dwDest;

	LONG lRet = RegQueryValueEx(m_hKey, (tchar_t*) pszKey, nullptr, 
		&dwType, (LPBYTE) &dwDest, &dwSize);

	if (lRet == ERROR_SUCCESS)
		return (dwDest!=(DWORD)0);
	else
		return defval;
}

/**
 * @brief Read String value from registry.
 * @param [in] pszKey Path to actual registry key to access.
 * @param [in] defval Default value to return if reading fails.
 * @return Read String value.
 */
String CRegKeyEx::ReadString (const tchar_t* pszKey, const tchar_t* defval)
{
	assert(m_hKey != nullptr);
	assert(pszKey != nullptr);

	DWORD dwType;
	DWORD dwSize = 0;
	String retString;

	// Get size of the string
	LONG lReturn = RegQueryValueEx(m_hKey, (tchar_t*) pszKey, nullptr,
		&dwType, nullptr, &dwSize);

	if (lReturn == ERROR_SUCCESS)
	{
		retString.resize(dwSize/sizeof(tchar_t));
		lReturn = RegQueryValueEx(m_hKey, (tchar_t*) pszKey, nullptr,
			&dwType, (LPBYTE) retString.data(), &dwSize);
		retString.resize(dwSize/sizeof(tchar_t)-1);
	}
	if (lReturn == ERROR_SUCCESS)
		return retString;
	else
		return defval;
}

/**
 * @brief Read char table from registry.
 * @param [in] pszKey Path to actual registry key to access.
 * @param [in] pData Pointer to char table where value is written to.
 * @param [in] dwLen Size of pData table in bytes.
 * @param [in] defval Default value to return if reading fails.
 */
void CRegKeyEx::ReadChars (const tchar_t* pszKey, tchar_t* pData, DWORD dwLen, const tchar_t* defval)
{
	assert(m_hKey != nullptr);
	assert(pszKey != nullptr);

	DWORD dwType;
	DWORD len = dwLen;

	LONG ret = RegQueryValueEx (m_hKey, (tchar_t*) pszKey, nullptr,
		&dwType, (LPBYTE)pData, &len);
	if (ret != ERROR_SUCCESS)
		StringCchCopy(pData, dwLen, defval);
}
</file>

<file path="Winmerge-Src/Src/Common/RegKey.h">
/** 
 * @file  RegKey.h
 *
 * @brief Declaration of CRegKeyEx C++ wrapper class for reading Windows registry
 */
#pragma once

#include <windows.h>
#include "UnicodeString.h"

/**
 * @brief Class for reading/writing registry.
 */
class CRegKeyEx
{

// Construction
public:
	CRegKeyEx();
	~CRegKeyEx();

// Operations
public:
	void Close();
	LONG Open(HKEY hKeyRoot, const tchar_t* pszPath);
	LONG OpenWithAccess(HKEY hKeyRoot, const tchar_t* pszPath, REGSAM regsam);
	LONG OpenNoCreateWithAccess(HKEY hKeyRoot, const tchar_t* pszPath, REGSAM regsam);
	bool QueryRegMachine(const tchar_t* key);
	bool QueryRegUser(const tchar_t* key);

	LONG WriteDword (const tchar_t* pszKey, DWORD dwVal);
	LONG WriteString (const tchar_t* pszKey, const tchar_t* pszVal);
	LONG WriteBool (const tchar_t* pszKey, bool bVal);
	LONG WriteFloat (const tchar_t* pszKey, float fVal);

	DWORD ReadDword (const tchar_t* pszKey, DWORD defval);
	float ReadFloat (const tchar_t* pszKey, float defval);
	bool ReadBool(const tchar_t* pszKey, bool defval);
	LONG ReadLong (const tchar_t* pszKey, LONG defval);
	UINT ReadUint (const tchar_t* pszKey, UINT defval);
	UINT ReadInt (const tchar_t* pszKey, int defval);
	short int ReadShort (const tchar_t* pszKey, short int defval);
	BYTE ReadByte (const tchar_t* pszKey, BYTE defval);
	String ReadString (const tchar_t* pszKey, const tchar_t* defval);
	void ReadChars (const tchar_t* pszKey, tchar_t* pData, DWORD dwLength, const tchar_t* defval);

protected:
	HKEY m_hKey; /**< Open key (HKLM, HKCU, etc). */
	String m_sPath; /**< Path to actual key to open. */
};
</file>

<file path="Winmerge-Src/Src/Common/RegOptionsMgr.cpp">
/**
 * @file RegOptionsMgr.cpp
 *
 * @brief Implementation of Registry Options management class.
 *
 */

#include "pch.h"
#include "RegOptionsMgr.h"
#include <windows.h>
#include <process.h>
#include <Shlwapi.h>
#include "OptionsMgr.h"

struct AsyncWriterThreadParams
{
	AsyncWriterThreadParams(const String& name, const varprop::VariantValue& value) : name(name), value(value) {}
	String name;
	varprop::VariantValue value;
};

class CRegOptionsMgr::IOHandler
{
public:
	IOHandler(const String& path) :
		m_bCloseHandle(false)
		, m_hThread(nullptr)
		, m_hEvent(nullptr)
		, m_dwThreadId(0)
		, m_dwQueueCount(0)
	{
		InitializeCriticalSection(&m_cs);
		m_hEvent = CreateEvent(nullptr, TRUE, FALSE, nullptr);
		if (m_hEvent)
		{
			m_hThread = reinterpret_cast<HANDLE>(
				_beginthreadex(nullptr, 0, AsyncWriterThreadProc, this, 0,
					reinterpret_cast<unsigned*>(&m_dwThreadId)));
			WaitForSingleObject(m_hEvent, INFINITE);
			CloseHandle(m_hEvent);
			m_hEvent = nullptr;
		}
		SetRegRootKey(path);
	}

	~IOHandler()
	{
		for (;;)
		{
			PostThreadMessage(m_dwThreadId, WM_QUIT, 0, 0);
			if (WaitForSingleObject(m_hThread, 1) != WAIT_TIMEOUT)
				break;
		}
		DeleteCriticalSection(&m_cs);
	}

	void WriteAsync(const String& name, const varprop::VariantValue& value)
	{
		auto* pParam = new AsyncWriterThreadParams(name, value);
		InterlockedIncrement(&m_dwQueueCount);
		if (!::PostThreadMessage(m_dwThreadId, WM_USER, (WPARAM)pParam, 0))
		{
			delete pParam;
			InterlockedDecrement(&m_dwQueueCount);
		}
	}

	HKEY OpenKey(const String& strPath, bool bAlwaysCreate)
	{
		String strRegPath(m_registryRoot);
		strRegPath += strPath;
		HKEY hKey = nullptr;
		if (m_hKeys.find(strPath) == m_hKeys.end())
		{
			DWORD action = 0;
			LONG retValReg;
			if (bAlwaysCreate)
			{
				retValReg = RegCreateKeyEx(HKEY_CURRENT_USER, strRegPath.c_str(),
					0, nullptr, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, nullptr,
					&hKey, &action);
			}
			else
			{
				retValReg = RegOpenKeyEx(HKEY_CURRENT_USER, strRegPath.c_str(),
					0, KEY_ALL_ACCESS, &hKey);
			}
			if (retValReg != ERROR_SUCCESS)
				return nullptr;

			m_hKeys[strPath] = hKey;
		}
		else
		{
			hKey = m_hKeys[strPath];
		}
		return hKey;
	}

	void CloseKey(HKEY hKey, const String& strPath)
	{
		if (m_bCloseHandle)
		{
			if (hKey)
				RegCloseKey(hKey);
			m_hKeys.erase(strPath);
		}
	}

	void CloseKeys()
	{
		EnterCriticalSection(&m_cs);
		for (auto& pair : m_hKeys)
			RegCloseKey(pair.second);
		m_hKeys.clear();
		LeaveCriticalSection(&m_cs);
	}

	/**
	 * @brief Save value to registry.
	 *
	 * Saves one value to registry to key previously opened. Type of
	 * value is determined from given value parameter.
	 * @param [in] hKey Handle to open registry key
	 * @param [in] strValueName Name of value to write
	 * @param [in] value value to write to registry value
	 * @todo Handles only string and integer types
	 */
	int SaveValueToReg(HKEY hKey, const String& strValueName,
		const varprop::VariantValue& value)
	{
		LONG retValReg = 0;
		int valType = value.GetType();
		int retVal = COption::OPT_OK;

		if (valType == varprop::VT_STRING)
		{
			String strVal = value.GetString();
			if (strVal.length() > 0)
			{
				retValReg = RegSetValueEx(hKey, strValueName.c_str(), 0, REG_SZ,
						(LPBYTE)strVal.c_str(), (DWORD)(strVal.length() + 1) * sizeof(tchar_t));
			}
			else
			{
				tchar_t str[1] = {0};
				retValReg = RegSetValueEx(hKey, strValueName.c_str(), 0, REG_SZ,
						(LPBYTE)&str, 1 * sizeof(tchar_t));
			}
		}
		else if (valType == varprop::VT_INT)
		{
			DWORD dwordVal = value.GetInt();
			retValReg = RegSetValueEx(hKey, strValueName.c_str(), 0, REG_DWORD,
					(LPBYTE)&dwordVal, sizeof(DWORD));
		}
		else if (valType == varprop::VT_BOOL)
		{
			DWORD dwordVal = value.GetBool() ? 1 : 0;
			retValReg = RegSetValueEx(hKey, strValueName.c_str(), 0, REG_DWORD,
					(LPBYTE)&dwordVal, sizeof(DWORD));
		}
		else
		{
			retVal = COption::OPT_UNKNOWN_TYPE;
		}
			
		if (retValReg != ERROR_SUCCESS)
		{
			retVal = COption::OPT_ERR;
		}
		return retVal;
	}

	LONG Read(const String& name, std::vector<unsigned char>& dataBuf, DWORD& type)
	{
		// Figure out registry path, for saving value
		auto [strPath, strValueName] = SplitName(name);

		// Open key.
		EnterCriticalSection(&m_cs);
		HKEY hKey = OpenKey(strPath, false);

		// Check previous value
		// This just checks if the value exists, LoadValueFromReg() below actually
		// loads the value.
		if (dataBuf.size() < 256)
			dataBuf.resize(256);
		type = 0;
		DWORD size = static_cast<DWORD>(dataBuf.size());
		LONG retValReg;
		if (hKey)
		{
			dataBuf[0] = 0;
			retValReg = RegQueryValueEx(hKey, strValueName.c_str(),
				0, &type, dataBuf.data(), &size);
		}
		else
			retValReg = ERROR_FILE_NOT_FOUND;

		// Value didn't exist. Do nothing
		if (retValReg == ERROR_FILE_NOT_FOUND)
		{
		}
		// Value already exists so read it.
		else if (retValReg == ERROR_SUCCESS)
		{
		}
		else if (retValReg == ERROR_MORE_DATA)
		{
			dataBuf.resize(size);
			retValReg = RegQueryValueEx(hKey, strValueName.c_str(),
				0, &type, dataBuf.data(), &size);
		}

		CloseKey(hKey, strPath);
		LeaveCriticalSection(&m_cs);
		return retValReg;
	}

	int Remove(const String& name)
	{
		int retVal = COption::OPT_OK;
		auto [strPath, strValueName] = SplitName(name);

		while (InterlockedCompareExchange(&m_dwQueueCount, 0, 0) != 0)
			Sleep(0);

		EnterCriticalSection(&m_cs);
		HKEY hKey = OpenKey(strPath, true);
		if (strValueName.empty())
	#ifdef _WIN64
			RegDeleteTree(hKey, nullptr);
	#else
			SHDeleteKey(hKey, nullptr);
	#endif
		else
			RegDeleteValue(hKey, strValueName.c_str());
		CloseKey(hKey, strPath);
		LeaveCriticalSection(&m_cs);

		return retVal;
	}

	int WaitForQueueFlush()
	{
		int retVal = COption::OPT_OK;

		while (InterlockedCompareExchange(&m_dwQueueCount, 0, 0) != 0)
			Sleep(0);

		return retVal;
	}

	int ExportAllUnloadedValues(const String& filename, const OptionsMap& optionsMap) const
	{
		HKEY hKey = nullptr;
		if (RegOpenKeyEx(HKEY_CURRENT_USER, m_registryRoot.c_str(), 0, KEY_READ, &hKey) != ERROR_SUCCESS)
			return COption::OPT_ERR;
		int retVal = ExportAllUnloadedValues(hKey, _T(""), filename, optionsMap);
		RegCloseKey(hKey);
		return retVal;
	}

	int ExportAllUnloadedValues(HKEY hKey, const String& strPath, const String& filename, const OptionsMap& optionsMap) const
	{
		DWORD dwIndex = 0;
		tchar_t szValueName[MAX_PATH];
		std::vector<BYTE> data(MAX_PATH);
		for (;;)
		{
			DWORD dwType;
			DWORD cbValueName = MAX_PATH;
			DWORD cbData = static_cast<DWORD>(data.size());
			LSTATUS result = RegEnumValue(hKey, dwIndex, szValueName, &cbValueName, nullptr, &dwType, data.data(), &cbData);
			if (result == ERROR_MORE_DATA)
			{
				cbValueName = MAX_PATH;
				cbData *= 2;
				data.resize(cbData);
				result = RegEnumValue(hKey, dwIndex, szValueName, &cbValueName, nullptr, &dwType, data.data(), &cbData);
			}
			if (result == ERROR_SUCCESS)
			{
				String strName = strPath + _T("/") + szValueName;
				if (optionsMap.find(strName) == optionsMap.end())
				{
					varprop::VariantValue value;
					switch (dwType)
					{
					case REG_DWORD:
						WritePrivateProfileString(_T("WinMerge"), strName.c_str(),
							strutils::to_str(*(reinterpret_cast<int*>(data.data()))).c_str(), filename.c_str());
						WritePrivateProfileString(_T("WinMerge.TypeInfo"), strName.c_str(),
								_T("int"), filename.c_str());
						break;
					case REG_SZ:
						// https://learn.microsoft.com/en-us/answers/questions/578134/error-in-writeprivateprofilestring-function-when-j
						WritePrivateProfileString(_T("WinMerge"), strName.c_str(),
							nullptr, filename.c_str());
						WritePrivateProfileString(_T("WinMerge"), strName.c_str(),
							EscapeValue(reinterpret_cast<tchar_t*>(data.data())).c_str(), filename.c_str());
						WritePrivateProfileString(_T("WinMerge.TypeInfo"), strName.c_str(),
								_T("string"), filename.c_str());
						break;
					default:
						break;
					}
				}
				dwIndex++;
			}
			else if (result == ERROR_NO_MORE_ITEMS)
			{
				break;
			}
			else
			{
				return COption::OPT_ERR;
			}
		}

		dwIndex = 0;
		tchar_t szSubKey[MAX_PATH];
		DWORD cbSubKey = MAX_PATH;
		for (;;)
		{
			LSTATUS result = RegEnumKeyEx(hKey, dwIndex, szSubKey, &cbSubKey, nullptr, nullptr, nullptr, nullptr);
			if (result == ERROR_SUCCESS)
			{
				HKEY hSubKey = nullptr;
				if (RegOpenKeyEx(hKey, szSubKey, 0, KEY_READ, &hSubKey) == ERROR_SUCCESS)
				{
					int retVal = ExportAllUnloadedValues(hSubKey, strPath.empty() ? szSubKey : strPath + _T("\\") + szSubKey, filename, optionsMap);
					RegCloseKey(hSubKey);
					if (retVal != COption::OPT_OK)
						return retVal;
				}
				dwIndex++;
				cbSubKey = MAX_PATH;
			}
			else if (result == ERROR_NO_MORE_ITEMS)
			{
				break;
			}
			else
			{
				return COption::OPT_ERR;
			}
		}
		return COption::OPT_OK;
	}

	int ImportAllUnloadedValues(const String& filename, OptionsMap& optionsMap)
	{
		auto iniFileKeyValues = ReadIniFile(filename, _T("WinMerge"));
		auto iniFileKeyTypes = ReadIniFile(filename, _T("WinMerge.TypeInfo"));
		for (const auto& [key, strValue] : iniFileKeyValues)
		{
			if (optionsMap.find(key) == optionsMap.end() &&
				iniFileKeyTypes.find(key) != iniFileKeyTypes.end())
			{
				auto [strPath, strValueName] = SplitName(key);
				HKEY hKey = OpenKey(strPath, true);
				if (hKey)
				{
					varprop::VariantValue value;
					String strType = iniFileKeyTypes[key];
					if (tc::tcsicmp(strType.c_str(), _T("bool")) == 0)
						value.SetBool(tc::ttoi(strValue.c_str()) != 0);
					else if (tc::tcsicmp(strType.c_str(), _T("int")) == 0)
					{
						tchar_t* endptr = nullptr;
						unsigned uval = static_cast<unsigned>(tc::tcstoll(strValue.c_str(), &endptr,
							(strValue.length() >= 2 && strValue[1] == 'x') ? 16 : 10));
						value.SetInt(static_cast<int>(uval));
					}
					else if (tc::tcsicmp(strType.c_str(), _T("string")) == 0)
						value.SetString(strValue);
					SaveValueToReg(hKey, strValueName, value);
					CloseKey(hKey, strPath);
				}
			}
		}
		return COption::OPT_OK;
	}

	/**
	 * @brief Set registry root path for options.
	 *
	 * Sets path used as root path when loading/saving options. Paths
	 * given to other functions are relative to this path.
	 */
	int SetRegRootKey(const String& key)
	{
		String keyname(key);
		HKEY hKey = nullptr;
		DWORD action = 0;
		int retVal = COption::OPT_OK;

		size_t ind = keyname.find(_T("Software"));
		if (ind != 0)
			keyname.insert(0, _T("Software\\"));
		
		m_registryRoot = std::move(keyname);

		LONG retValReg =  RegCreateKeyEx(HKEY_CURRENT_USER, m_registryRoot.c_str(), 0, nullptr,
			REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, nullptr, &hKey, &action);

		if (retValReg == ERROR_SUCCESS)
		{
			if (action == REG_CREATED_NEW_KEY)
			{
				// TODO: At least log message..?
			}
			RegCloseKey(hKey);
		}
		else
		{
			retVal = COption::OPT_ERR;
		}

		return retVal;
	}

	static unsigned __stdcall AsyncWriterThreadProc(void *pvThis)
	{
		CRegOptionsMgr::IOHandler *pThis = reinterpret_cast<CRegOptionsMgr::IOHandler *>(pvThis);
		MSG msg;
		BOOL bRet;
		// create message queue
		PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE);
		SetEvent(pThis->m_hEvent);
		while ((bRet = GetMessage(&msg, 0, 0, 0)) != 0)
		{
			auto* pParam = reinterpret_cast<AsyncWriterThreadParams *>(msg.wParam);
			if (msg.message == WM_USER && pParam)
			{
				auto [strPath, strValueName] = COptionsMgr::SplitName(pParam->name);
				EnterCriticalSection(&pThis->m_cs);
				HKEY hKey = pThis->OpenKey(strPath, true);
				pThis->SaveValueToReg(hKey, strValueName, pParam->value);
				pThis->CloseKey(hKey, strPath);
				LeaveCriticalSection(&pThis->m_cs);
				delete pParam;
				InterlockedDecrement(&pThis->m_dwQueueCount);
			}
		}
		return 0;
	}

private:
	String m_registryRoot; /**< Registry path where to store options. */
	bool m_bCloseHandle;
	std::map<String, HKEY> m_hKeys;
	CRITICAL_SECTION m_cs;
	DWORD m_dwThreadId;
	DWORD m_dwQueueCount;
	HANDLE m_hThread;
	HANDLE m_hEvent;
};

CRegOptionsMgr::CRegOptionsMgr(const String& path)
	: m_serializing(true)
	, m_pIOHandler(std::make_unique<IOHandler>(path))
{
}

CRegOptionsMgr::~CRegOptionsMgr()
{
	m_pIOHandler.reset();
}

int CRegOptionsMgr::LoadValueFromBuf(const String& strName, unsigned type, const unsigned char* data, varprop::VariantValue& value)
{
	int retVal = COption::OPT_OK;
	int valType = value.GetType();
	if (type == REG_SZ && valType == varprop::VT_STRING )
	{
		value.SetString((tchar_t *)&data[0]);
		retVal = Set(strName, value);
	}
	else if (type == REG_DWORD)
	{
		if (valType == varprop::VT_INT)
		{
			DWORD dwordValue;
			CopyMemory(&dwordValue, &data[0], sizeof(DWORD));
			value.SetInt(dwordValue);
			retVal = Set(strName, value);
		}
		else if (valType == varprop::VT_BOOL)
		{
			DWORD dwordValue;
			CopyMemory(&dwordValue, &data[0], sizeof(DWORD));
			value.SetBool(dwordValue > 0 ? true : false);
			retVal = Set(strName, value);
		}
		else
			retVal = COption::OPT_WRONG_TYPE;
	}
	else
		retVal = COption::OPT_WRONG_TYPE;

	return retVal;
}

/**
 * @brief Init and add new option.
 *
 * Adds new option to list of options. Sets value to default value.
 * If option does not exist in registry, saves with default value.
 */
int CRegOptionsMgr::InitOption(const String& name, const varprop::VariantValue& defaultValue)
{
	// Check type & bail if null
	int valType = defaultValue.GetType();
	if (valType == varprop::VT_NULL)
		return COption::OPT_ERR;

	// If we're not loading & saving options, bail
	if (!m_serializing)
		return AddOption(name, defaultValue);

	// Actually save value into our in-memory options table
	int retVal = AddOption(name, defaultValue);
	if (retVal == COption::OPT_OK)
	{
		DWORD type = 0;
		std::vector<unsigned char> dataBuf(256);
		if (m_pIOHandler->Read(name, dataBuf, type) == ERROR_SUCCESS)
		{
			varprop::VariantValue value(defaultValue);
			retVal = LoadValueFromBuf(name, type, dataBuf.data(), value);
		}
	}

	return retVal;
}

/**
 * @brief Init and add new string option.
 *
 * Adds new option to list of options. Sets value to default value.
 * If option does not exist in registry, saves with default value.
 */
int CRegOptionsMgr::InitOption(const String& name, const String& defaultValue)
{
	varprop::VariantValue defValue;
	defValue.SetString(defaultValue);
	return InitOption(name, defValue);
}

int CRegOptionsMgr::InitOption(const String& name, const tchar_t *defaultValue)
{
	return InitOption(name, String(defaultValue));
}

/**
 * @brief Init and add new int option.
 *
 * Adds new option to list of options. Sets value to default value.
 * If option does not exist in registry, saves with default value.
 */
int CRegOptionsMgr::InitOption(const String& name, int defaultValue, bool serializable)
{
	varprop::VariantValue defValue;
	int retVal = COption::OPT_OK;

	defValue.SetInt(defaultValue);
	if (serializable)
		retVal = InitOption(name, defValue);
	else
		AddOption(name, defValue);
	return retVal;
}

/**
 * @brief Init and add new boolean option.
 *
 * Adds new option to list of options. Sets value to default value.
 * If option does not exist in registry, saves with default value.
 */
int CRegOptionsMgr::InitOption(const String& name, bool defaultValue)
{
	varprop::VariantValue defValue;
	defValue.SetBool(defaultValue);
	return InitOption(name, defValue);
}

/**
 * @brief Save option to registry
 * @note Currently handles only integer and string options!
 */
int CRegOptionsMgr::SaveOption(const String& name)
{
	if (!m_serializing) return COption::OPT_OK;

	varprop::VariantValue value;
	int retVal = COption::OPT_OK;

	value = Get(name);
	int valType = value.GetType();
	if (valType == varprop::VT_NULL)
		retVal = COption::OPT_NOTFOUND;

	if (retVal == COption::OPT_OK)
		m_pIOHandler->WriteAsync(name, value);

	return retVal;
}

/**
 * @brief Set new value for option and save option to registry
 */
int CRegOptionsMgr::SaveOption(const String& name, const varprop::VariantValue& value)
{
	int retVal = Set(name, value);
	if (retVal == COption::OPT_OK)
		retVal = SaveOption(name);
	return retVal;
}

/**
 * @brief Set new string value for option and save option to registry
 */
int CRegOptionsMgr::SaveOption(const String& name, const String& value)
{
	varprop::VariantValue val;
	val.SetString(value);
	int retVal = Set(name, val);
	if (retVal == COption::OPT_OK)
		retVal = SaveOption(name);
	return retVal;
}

/**
 * @brief Set new string value for option and save option to registry
 */
int CRegOptionsMgr::SaveOption(const String& name, const tchar_t *value)
{
	return SaveOption(name, String(value));
}

/**
 * @brief Set new integer value for option and save option to registry
 */
int CRegOptionsMgr::SaveOption(const String& name, int value)
{
	varprop::VariantValue val;
	val.SetInt(value);
	int retVal = Set(name, val);
	if (retVal == COption::OPT_OK)
		retVal = SaveOption(name);
	return retVal;
}

/**
 * @brief Set new boolean value for option and save option to registry
 */
int CRegOptionsMgr::SaveOption(const String& name, bool value)
{
	varprop::VariantValue val;
	val.SetBool(value);
	int retVal = Set(name, val);
	if (retVal == COption::OPT_OK)
		retVal = SaveOption(name);
	return retVal;
}

int CRegOptionsMgr::RemoveOption(const String& name)
{
	int retVal = COption::OPT_OK;
	auto [strPath, strValueName] = SplitName(name);

	if (!strValueName.empty())
	{
		retVal = COptionsMgr::RemoveOption(name);
	}
	else
	{
		for (auto it = m_optionsMap.begin(); it != m_optionsMap.end(); )
		{
			const String& key = it->first;
			if (key.find(strPath) == 0 && key.length() > strPath.length() && key[strPath.length()] == '/')
				it = m_optionsMap.erase(it);
			else
				++it;
		}
		retVal = COption::OPT_OK;
	}

	m_pIOHandler->Remove(name);

	return retVal;
}

int CRegOptionsMgr::FlushOptions()
{
	return m_pIOHandler->WaitForQueueFlush();
}

int CRegOptionsMgr::ExportOptions(const String& filename, const bool bHexColor /*= false*/) const
{
	int retVal = m_pIOHandler->ExportAllUnloadedValues(filename, m_optionsMap);
	if (retVal == COption::OPT_OK)
		retVal = COptionsMgr::ExportOptions(filename, bHexColor);
	return retVal;
}

int CRegOptionsMgr::ImportOptions(const String& filename)
{
	int retVal = m_pIOHandler->ImportAllUnloadedValues(filename, m_optionsMap);
	if (retVal == COption::OPT_OK)
		retVal = COptionsMgr::ImportOptions(filename);
	return retVal;
}

void CRegOptionsMgr::CloseKeys()
{
	m_pIOHandler->CloseKeys();
}

</file>

<file path="Winmerge-Src/Src/Common/RegOptionsMgr.h">
/**
 * @file RegOptionsMgr.h
 *
 * @brief Declaration for Registry options class.
 *
 */
#pragma once

#include "OptionsMgr.h"

class COptionsMgr;

/**
 * @brief Registry-based implementation of OptionsMgr interface (q.v.).
 */
class CRegOptionsMgr : public COptionsMgr
{
public:
	explicit CRegOptionsMgr(const String& path);
	virtual ~CRegOptionsMgr();
	CRegOptionsMgr(const CRegOptionsMgr&) = delete;
	CRegOptionsMgr& operator=(const CRegOptionsMgr&) = delete;

	void CloseKeys();

	virtual int InitOption(const String& name, const varprop::VariantValue& defaultValue) override;
	virtual int InitOption(const String& name, const String& defaultValue) override;
	virtual int InitOption(const String& name, const tchar_t* defaultValue) override;
	virtual int InitOption(const String& name, int defaultValue, bool serializable = true) override;
	virtual int InitOption(const String& name, bool defaultValue) override;

	virtual int SaveOption(const String& name) override;
	virtual int SaveOption(const String& name, const varprop::VariantValue& value) override;
	virtual int SaveOption(const String& name, const String& value) override;
	virtual int SaveOption(const String& name, const tchar_t* value) override;
	virtual int SaveOption(const String& name, int value) override;
	virtual int SaveOption(const String& name, bool value) override;

	virtual int RemoveOption(const String& name) override;

	virtual int FlushOptions() override;

	virtual int ExportOptions(const String& filename, const bool bHexColor=false) const override;
	virtual int ImportOptions(const String& filename) override;

	virtual void SetSerializing(bool serializing = true) override { m_serializing = serializing; }

protected:
	int LoadValueFromBuf(const String& strName, unsigned type, const unsigned char* data, varprop::VariantValue& value);

private:
	bool m_serializing;
	class IOHandler;
	std::unique_ptr<IOHandler> m_pIOHandler;
};
</file>

<file path="Winmerge-Src/Src/Common/RoundedRectWithShadow.cpp">
// Copyright (c) 2024 Takashi Sawanaka
// SPDX-License-Identifier: BSL-1.0
/** 
 * @file  RoundedRectWithShadow.cpp
 *
 * @brief Provides functions to draw rounded rectangles with shadows in a Win32 GDI context.
 *
 */
#include "StdAfx.h"
#include <cmath>
#include <algorithm>

struct RoundedRectWithShadow
{
	using dibcolor_t = unsigned int;

	RoundedRectWithShadow(int left, int top, int width, int height, int radius, int shadowWidth,
		COLORREF colorRoundedRect, COLORREF colorShadow, COLORREF colorBackground)
		: m_left(left)
		, m_top(top)
		, m_width(width)
		, m_height(height)
		, m_radius(radius)
		, m_shadowWidth(shadowWidth)
		, m_colorRoundedRect(COLORREFtoDIBColor_t(colorRoundedRect))
		, m_colorShadow(COLORREFtoDIBColor_t(colorShadow))
		, m_colorBackground(COLORREFtoDIBColor_t(colorBackground))
		, m_leftCircleCenterX(left + radius)
		, m_topCircleCenterY(top + radius)
		, m_rightCircleCenterX(left + width - radius)
		, m_bottomCircleCenterY(top + height - radius)
	{
	}

	static inline double sqr(double x) { return x * x; }

	static double distance(double x1, double y1, double x2, double y2)
	{
		return std::sqrt(sqr(x1 - x2) + sqr(y1 - y2));
	}

	static dibcolor_t COLORREFtoDIBColor_t(COLORREF color)
	{
		const BYTE r = GetRValue(color);
		const BYTE g = GetGValue(color);
		const BYTE b = GetBValue(color);
		return (r << 16) | (g << 8) | b;
	}

	static dibcolor_t interpolateColor(dibcolor_t color1, dibcolor_t color2, double t)
	{
		const unsigned char r1 = (color1 >> 16) & 0xff;
		const unsigned char g1 = (color1 >> 8) & 0xff;
		const unsigned char b1 = (color1) & 0xff;

		const unsigned char r2 = (color2 >> 16) & 0xff;
		const unsigned char g2 = (color2 >> 8) & 0xff;
		const unsigned char b2 = (color2) & 0xff;

		const unsigned char r = static_cast<unsigned char>(r1 + t * (r2 - r1));
		const unsigned char g = static_cast<unsigned char>(g1 + t * (g2 - g1));
		const unsigned char b = static_cast<unsigned char>(b1 + t * (b2 - b1));

		return (r << 16) | (g << 8) | b;
	}

	dibcolor_t getColor(int x, int y) const
	{
		if ((m_leftCircleCenterX <= x && x < m_rightCircleCenterX &&
			m_top <= y && y < m_top + m_height) ||
			(m_left <= x && x < m_left + m_width &&
				m_topCircleCenterY <= y && y < m_bottomCircleCenterY))
		{
			return m_colorRoundedRect;
		}

		double min_distance = (std::numeric_limits<double>::max)();
		if (y < m_top)
		{
			if (m_leftCircleCenterX <= x && x < m_rightCircleCenterX)
				min_distance = m_top - y;
		}
		else if (y > m_top + m_height)
		{
			if (m_leftCircleCenterX <= x && x < m_rightCircleCenterX)
				min_distance = y - (m_top + m_height) + 1;
		}
		else if (x < m_left)
		{
			if (m_topCircleCenterY <= y && y < m_bottomCircleCenterY)
				min_distance = m_left - x;
		}
		else if (x > m_left + m_width)
		{
			if (m_topCircleCenterY <= y && y < m_bottomCircleCenterY)
				min_distance = x - (m_left + m_width) + 1;
		}

		if (min_distance == (std::numeric_limits<double>::max)())
		{
			const double cx = (x < (m_left + m_left + m_width) / 2) ? m_leftCircleCenterX : m_rightCircleCenterX - 1;
			const double cy = (y < (m_top + m_top + m_height) / 2) ? m_topCircleCenterY : m_bottomCircleCenterY - 1;
			const double dist = distance(x, y, cx, cy);
			if (dist <= m_radius)
				return m_colorRoundedRect;
			min_distance = (std::min)(min_distance, dist - m_radius);
		}

		if (min_distance < 1.0)
			return interpolateColor(m_colorRoundedRect, m_shadowWidth == 0 ? m_colorBackground : m_colorShadow, min_distance);
		if (min_distance > m_shadowWidth)
			return m_colorBackground;
		const double t = std::sqrt(1.0 - sqr((min_distance - 1.0) / m_shadowWidth - 1.0));
		return interpolateColor(m_colorShadow, m_colorBackground, t);
	}

	void DrawPartialRoundedRectWithShadow(void* pBits, int pleft, int ptop, int pwidth, int pheight)
	{
		if (pleft < m_left - m_shadowWidth || pleft + pwidth > m_left + m_width + m_shadowWidth)
			return;
		if (ptop < m_top - m_shadowWidth || ptop + pheight > m_top + m_height + m_shadowWidth)
			return;
		const int left = m_left;
		const int top = m_top;
		const int shadowWidth = m_shadowWidth;
		const int pitch = m_width + m_shadowWidth * 2;
		if (m_left + m_radius <= pleft && pleft + pwidth <= m_left + m_width - m_radius)
		{
			for (int y = ptop; y < ptop + pheight; y++)
			{
				dibcolor_t color = getColor(pleft, y);
				for (int x = pleft; x < pleft + pwidth; x++)
					((dibcolor_t*)pBits)[(y - (top - shadowWidth)) * pitch + (x - (left - shadowWidth))] = color;
			}
		}
		else if (m_top + m_radius <= ptop && ptop + pheight <= m_top + m_height - m_radius)
		{
			for (int x = pleft; x < pleft + pwidth; x++)
			{
				dibcolor_t color = getColor(x, ptop);
				for (int y = ptop; y < ptop + pheight; y++)
					((dibcolor_t*)pBits)[(y - (top - shadowWidth)) * pitch + (x - (left - shadowWidth))] = color;
			}
		}
		else
		{
			for (int y = ptop; y < ptop + pheight; y++)
			{
				for (int x = pleft; x < pleft + pwidth; x++)
				{
					dibcolor_t color = getColor(x, y);
					((dibcolor_t*)pBits)[(y - (top - shadowWidth)) * pitch + (x - (left - shadowWidth))] = color;
				}
			}
		}
	}

	int m_left;
	int m_top;
	int m_width;
	int m_height;
	int m_radius;
	int m_shadowWidth;
	int m_leftCircleCenterX;
	int m_topCircleCenterY;
	int m_rightCircleCenterX;
	int m_bottomCircleCenterY;
	dibcolor_t m_colorRoundedRect;
	dibcolor_t m_colorShadow;
	dibcolor_t m_colorBackground;
};

void DrawRoundedRectWithShadow(HDC hdc, int left, int top, int width, int height, int radius, int shadowWidth,
	COLORREF roundedRectColor, COLORREF shadowColor, COLORREF backgroundColor)
{
	RoundedRectWithShadow rr(left, top, width, height, radius, shadowWidth, roundedRectColor, shadowColor, backgroundColor);

	HDC hdcMem = CreateCompatibleDC(hdc);
	if (!hdcMem)
		return;
	BITMAPINFO bmi{ sizeof(BITMAPINFOHEADER), width + shadowWidth * 2, -(height + shadowWidth * 2), 1, 32, BI_RGB };
	RoundedRectWithShadow::dibcolor_t* pBits;
	HBITMAP memBitmap = CreateDIBSection(hdcMem, &bmi, DIB_RGB_COLORS, (void**)&pBits, nullptr, 0);
	if (memBitmap)
	{
		HBITMAP oldBitmap = (HBITMAP)SelectObject(hdcMem, memBitmap);

		std::fill_n(pBits, (width + shadowWidth * 2) * (height + shadowWidth * 2), rr.COLORREFtoDIBColor_t(roundedRectColor));

		// Draw the shadow on the top side
		rr.DrawPartialRoundedRectWithShadow(pBits, left + radius, top - shadowWidth, width - 2 * radius, shadowWidth);
		// Draw the shadow on the bottom side
		rr.DrawPartialRoundedRectWithShadow(pBits, left + radius, top + height, width - 2 * radius, shadowWidth);
		// Draw the shadow on the left side
		rr.DrawPartialRoundedRectWithShadow(pBits, left - shadowWidth, top + radius, shadowWidth, height - 2 * radius);
		// Draw the shadow on the right side
		rr.DrawPartialRoundedRectWithShadow(pBits, left + width, top + radius, shadowWidth, height - 2 * radius);
		// Draw the top-left rounded corner and shadow
		rr.DrawPartialRoundedRectWithShadow(pBits, left - shadowWidth, top - shadowWidth, shadowWidth + radius, shadowWidth + radius);
		// Draw the top-right rounded corner and shadow
		rr.DrawPartialRoundedRectWithShadow(pBits, left + width - radius, top - shadowWidth, shadowWidth + radius, shadowWidth + radius);
		// Draw the bottom-left rounded corner and shadow
		rr.DrawPartialRoundedRectWithShadow(pBits, left - shadowWidth, top + height - radius, shadowWidth + radius, shadowWidth + radius);
		// Draw the bottom-right rounded corner and shadow
		rr.DrawPartialRoundedRectWithShadow(pBits, left + width - radius, top + height - radius, shadowWidth + radius, shadowWidth + radius);

		BitBlt(hdc, left - shadowWidth, top - shadowWidth, width + 2 * shadowWidth, height + 2 * shadowWidth, hdcMem, 0, 0, SRCCOPY);

		SelectObject(hdcMem, oldBitmap);
		DeleteObject(memBitmap);
	}

	DeleteDC(hdcMem);
}
</file>

<file path="Winmerge-Src/Src/Common/RoundedRectWithShadow.h">
/** 
 * @file  RoundedRectWithShadow.h
 *
 * @brief Provides functions to draw rounded rectangles with shadows in a Win32 GDI context.
 *
 */
#pragma once

void DrawRoundedRectWithShadow(HDC hdc, int left, int top, int width, int height, int radius, int shadowWidth, COLORREF roundedRectColor, COLORREF shadowColor, COLORREF backgroundColor);
inline void DrawRoundedRect(HDC hdc, int left, int top, int width, int height, int radius, COLORREF roundedRectColor, COLORREF backgroundColor)
{
	DrawRoundedRectWithShadow(hdc, left, top, width, height, radius, 0, roundedRectColor, backgroundColor, backgroundColor);
}

</file>

<file path="Winmerge-Src/Src/Common/scbarcf.cpp">
/////////////////////////////////////////////////////////////////////////
//
// CSizingControlBarCF          Version 2.44
// 
// Created: Dec 21, 1998        Last Modified: March 31, 2002
//
// See the official site at www.datamekanix.com for documentation and
// the latest news.
//
/////////////////////////////////////////////////////////////////////////
// Copyright (C) 1998-2002 by Cristi Posea. All rights reserved.
//
// This code is free for personal and commercial use, providing this 
// notice remains intact in the source files and all eventual changes are
// clearly marked with comments.
//
// You must obtain the author's consent before you can include this code
// in a software library.
//
// No warrantee of any kind, express or implied, is included with this
// software; use at your own risk, responsibility for damages (if any) to
// anyone resulting from the use of this software rests entirely with the
// user.
//
// Send bug reports, bug fixes, enhancements, requests, flames, etc. to
// cristi@datamekanix.com or post them at the message board at the site.
/////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "scbarcf.h"
#include "RoundedRectWithShadow.h"

/////////////////////////////////////////////////////////////////////////
// CSizingControlBarCF

IMPLEMENT_DYNAMIC(CSizingControlBarCF, baseCSizingControlBarCF);

int CALLBACK EnumFontFamProc(ENUMLOGFONT* lpelf,
                             NEWTEXTMETRIC* lpntm,
                             int FontType,
                             LPARAM lParam)
{
    UNUSED_ALWAYS(lpelf);
    UNUSED_ALWAYS(lpntm);
    UNUSED_ALWAYS(FontType);
    UNUSED_ALWAYS(lParam);

    return 0;
}
 
CSizingControlBarCF::CSizingControlBarCF()
{
    m_bActive = false;

    CDC dc;
    dc.CreateCompatibleDC(nullptr);

    m_sFontFace = (::EnumFontFamilies(dc.m_hDC,
        _T("Tahoma"), (FONTENUMPROC) EnumFontFamProc, 0) == 0) ?
        _T("Tahoma") : _T("Arial");
}

BEGIN_MESSAGE_MAP(CSizingControlBarCF, baseCSizingControlBarCF)
    //{{AFX_MSG_MAP(CSizingControlBarCF)
    //}}AFX_MSG_MAP
    ON_MESSAGE(WM_SETTEXT, OnSetText)
END_MESSAGE_MAP()

void CSizingControlBarCF::OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler)
{
    __super::OnUpdateCmdUI(pTarget, bDisableIfNoHndler);

    if (!HasGripper())
        return;

    bool bNeedPaint = false;

    CWnd* pFocus = GetFocus();
    bool bActiveOld = m_bActive;

    m_bActive = (pFocus && pFocus->GetSafeHwnd() && IsChild(pFocus));

    if (m_bActive != bActiveOld)
        bNeedPaint = true;

    if (bNeedPaint)
        SendMessage(WM_NCPAINT);
}

void CSizingControlBarCF::NcPaintGripper(CDC* pDC, const CRect& rcClient)
{
    if (!HasGripper())
        return;

    // compute the caption rectangle
    bool bHorz = IsHorzDocked();
    CRect rcGrip = rcClient;
    const int lpx = pDC->GetDeviceCaps(LOGPIXELSX);
    auto pointToPixel = [lpx](double point) { return static_cast<int>(point * lpx / 72); };
    CRect rcBtn(m_biHide.ptOrg, CSize(pointToPixel(m_biHide.dblBoxSize), pointToPixel(m_biHide.dblBoxSize)));
    if (bHorz)
    {   // right side gripper
        rcGrip.left -= pointToPixel(m_dblGripper + 0.75);
        rcGrip.right = rcGrip.left + pointToPixel(8.25);
		rcGrip.top = rcBtn.bottom + pointToPixel(2.25);
    }
    else
    {   // gripper at top
        rcGrip.top -= pointToPixel(m_dblGripper + 0.75);
        rcGrip.bottom = rcGrip.top + pointToPixel(8.25);
        rcGrip.right = rcBtn.left - pointToPixel(2.25);
    }
    rcGrip.InflateRect(bHorz ? pointToPixel(0.75) : 0, bHorz ? 0 : pointToPixel(0.75));

    // draw the caption background
    //CBrush br;
    const COLORREF clrCptn = m_bActive ?
        ::GetSysColor(COLOR_GRADIENTACTIVECAPTION) :
        ::GetSysColor(COLOR_GRADIENTINACTIVECAPTION);
    const COLORREF clrBack = ::GetSysColor(COLOR_3DFACE);
    const int radius = pointToPixel(2.25);
    DrawRoundedRect(pDC->m_hDC, rcGrip.left, rcGrip.top, rcGrip.Width(), rcGrip.Height(), radius, clrCptn, clrBack);

    // draw the caption text - first select a font
    CFont font;
    LOGFONT lf;
    bool bFont = !!font.CreatePointFont(85/*8.5 points*/, m_sFontFace);
    if (bFont)
    {
        // get the text color
        COLORREF clrCptnText = m_bActive ?
            ::GetSysColor(COLOR_CAPTIONTEXT) :
            ::GetSysColor(COLOR_INACTIVECAPTIONTEXT);

        int nOldBkMode = pDC->SetBkMode(TRANSPARENT);
        COLORREF clrOldText = pDC->SetTextColor(clrCptnText);

        if (bHorz)
        {
            // rotate text 90 degrees CCW if horizontally docked
            font.GetLogFont(&lf);
            font.DeleteObject();
            lf.lfEscapement = 900;
            font.CreateFontIndirect(&lf);
        }
        
        CFont* pOldFont = pDC->SelectObject(&font);
        CString sTitle;
        GetWindowText(sTitle);

        CPoint ptOrg = bHorz ?
            CPoint(rcGrip.left - pointToPixel(0.75), rcGrip.bottom - pointToPixel(2.25)) :
            CPoint(rcGrip.left + pointToPixel(2.25), rcGrip.top - pointToPixel(0.75));

        pDC->ExtTextOut(ptOrg.x, ptOrg.y,
            ETO_CLIPPED, rcGrip, sTitle, nullptr);

        pDC->SelectObject(pOldFont);
        pDC->SetBkMode(nOldBkMode);
        pDC->SetTextColor(clrOldText);
    }

    // draw the button
    m_biHide.Paint(pDC);
}

LRESULT CSizingControlBarCF::OnSetText(WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = __super::OnSetText(wParam, lParam);

    SendMessage(WM_NCPAINT);

    return lResult;
}
</file>

<file path="Winmerge-Src/Src/Common/scbarcf.h">
/////////////////////////////////////////////////////////////////////////
//
// CSizingControlBarCF          Version 2.44
// 
// Created: Dec 21, 1998        Last Modified: March 31, 2002
//
// See the official site at www.datamekanix.com for documentation and
// the latest news.
//
/////////////////////////////////////////////////////////////////////////
// Copyright (C) 1998-2002 by Cristi Posea. All rights reserved.
//
// This code is free for personal and commercial use, providing this 
// notice remains intact in the source files and all eventual changes are
// clearly marked with comments.
//
// You must obtain the author's consent before you can include this code
// in a software library.
//
// No warrantee of any kind, express or implied, is included with this
// software; use at your own risk, responsibility for damages (if any) to
// anyone resulting from the use of this software rests entirely with the
// user.
//
// Send bug reports, bug fixes, enhancements, requests, flames, etc. to
// cristi@datamekanix.com or post them at the message board at the site.
/////////////////////////////////////////////////////////////////////////
#pragma once
// scbarcf.h : header file
//

/////////////////////////////////////////////////////////////////////////
// CSizingControlBarCF

#ifndef baseCSizingControlBarCF
#define baseCSizingControlBarCF CSizingControlBarG
#endif

class CSizingControlBarCF : public baseCSizingControlBarCF
{
    DECLARE_DYNAMIC(CSizingControlBarCF)

// Construction
public:
    CSizingControlBarCF();

// Overridables
    virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler) override;

// Implementation
protected:
    // implementation helpers
    virtual void NcPaintGripper(CDC* pDC, const CRect& rcClient) override;

protected:
    bool    m_bActive; // a child has focus
    CString m_sFontFace;

// Generated message map functions
protected:
    //{{AFX_MSG(CSizingControlBarCF)
    //}}AFX_MSG
    afx_msg LRESULT OnSetText(WPARAM wParam, LPARAM lParam);

    DECLARE_MESSAGE_MAP()
};

</file>

<file path="Winmerge-Src/Src/Common/scbarg.cpp">
/////////////////////////////////////////////////////////////////////////
//
// CSizingControlBarG           Version 2.44
// 
// Created: Jan 24, 1998        Last Modified: March 31, 2002
//
// See the official site at www.datamekanix.com for documentation and
// the latest news.
//
/////////////////////////////////////////////////////////////////////////
// Copyright (C) 1998-2002 by Cristi Posea. All rights reserved.
//
// This code is free for personal and commercial use, providing this 
// notice remains intact in the source files and all eventual changes are
// clearly marked with comments.
//
// You must obtain the author's consent before you can include this code
// in a software library.
//
// No warrantee of any kind, express or implied, is included with this
// software; use at your own risk, responsibility for damages (if any) to
// anyone resulting from the use of this software rests entirely with the
// user.
//
// Send bug reports, bug fixes, enhancements, requests, flames, etc. to
// cristi@datamekanix.com or post them at the message board at the site.
/////////////////////////////////////////////////////////////////////////

// sizecbar.cpp : implementation file
//

#include "StdAfx.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////
// CSizingControlBarG

IMPLEMENT_DYNAMIC(CSizingControlBarG, baseCSizingControlBarG);

CSizingControlBarG::CSizingControlBarG()
{
}

CSizingControlBarG::~CSizingControlBarG()
{
}

BEGIN_MESSAGE_MAP(CSizingControlBarG, baseCSizingControlBarG)
    //{{AFX_MSG_MAP(CSizingControlBarG)
    ON_WM_NCLBUTTONUP()
    ON_WM_NCHITTEST()
    //}}AFX_MSG_MAP
    ON_MESSAGE(WM_SETTEXT, OnSetText)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////
// CSizingControlBarG message handlers

/////////////////////////////////////////////////////////////////////////
// Mouse Handling
//

void CSizingControlBarG::OnNcLButtonUp(UINT nHitTest, CPoint point)
{
    if (nHitTest == HTCLOSE)
        m_pDockSite->ShowControlBar(this, FALSE, FALSE); // hide

    __super::OnNcLButtonUp(nHitTest, point);
}

void CSizingControlBarG::NcCalcClient(LPRECT pRc, UINT nDockBarID)
{
    CRect rcBar(pRc); // save the bar rect
    // subtract edges
    __super::NcCalcClient(pRc, nDockBarID);

    if (!HasGripper())
        return;

    CRect rc(pRc); // the client rect as calculated by the base class

    bool bHorz = (nDockBarID == AFX_IDW_DOCKBAR_TOP) ||
                 (nDockBarID == AFX_IDW_DOCKBAR_BOTTOM);

    const int lpx = CClientDC(this).GetDeviceCaps(LOGPIXELSX);
    auto pointToPixel = [lpx](double point) { return static_cast<int>(point * lpx / 72); };

    if (bHorz)
        rc.DeflateRect(pointToPixel(m_dblGripper), 0, 0, 0);
    else
        rc.DeflateRect(0, pointToPixel(m_dblGripper), 0, 0);

    // set position for the "x" (hide bar) button
    CPoint ptOrgBtn;
    if (bHorz)
        ptOrgBtn = CPoint(rc.left - pointToPixel(9.75), rc.top);
    else
        ptOrgBtn = CPoint(rc.right - pointToPixel(9.0), rc.top - pointToPixel(9.75));

    m_biHide.Move(ptOrgBtn - rcBar.TopLeft());

    *pRc = rc;
}

void CSizingControlBarG::NcPaintGripper(CDC* pDC, const CRect& rcClient)
{
    if (!HasGripper())
        return;

    // paints a simple "two raised lines" gripper
    // override this if you want a more sophisticated gripper
    const int lpx = pDC->GetDeviceCaps(LOGPIXELSX);
    auto pointToPixel = [lpx](double point) { return static_cast<int>(point * lpx / 72); };
    CRect gripper = rcClient;
    CRect rcbtn(m_biHide.ptOrg, CSize(pointToPixel(m_biHide.dblBoxSize), pointToPixel(m_biHide.dblBoxSize)));
    bool bHorz = IsHorzDocked();

    gripper.DeflateRect(1, 1);
    if (bHorz)
    {   // gripper at left
        gripper.left -= pointToPixel(m_dblGripper);
        gripper.right = gripper.left + pointToPixel(2.25);
        gripper.top = rcbtn.bottom + pointToPixel(2.25);
    }
    else
    {   // gripper at top
        gripper.top -= pointToPixel(m_dblGripper);
        gripper.bottom = gripper.top + pointToPixel(2.25);
        gripper.right = rcbtn.left - pointToPixel(2.25);
    }

    pDC->Draw3dRect(gripper, ::GetSysColor(COLOR_BTNHIGHLIGHT),
        ::GetSysColor(COLOR_BTNSHADOW));

    gripper.OffsetRect(bHorz ? pointToPixel(2.25) : 0, bHorz ? 0 : pointToPixel(2.25));

    pDC->Draw3dRect(gripper, ::GetSysColor(COLOR_BTNHIGHLIGHT),
        ::GetSysColor(COLOR_BTNSHADOW));

    m_biHide.Paint(pDC);
}

LRESULT CSizingControlBarG::OnNcHitTest(CPoint point)
{
    CRect rcBar;
    GetWindowRect(rcBar);

    LRESULT nRet = __super::OnNcHitTest(point);
    if (nRet != HTCLIENT)
        return nRet;

    const int lpx = CClientDC(this).GetDeviceCaps(LOGPIXELSX);
    auto pointToPixel = [lpx](double point) { return static_cast<int>(point * lpx / 72); };
    CRect rc(m_biHide.ptOrg, CSize(pointToPixel(m_biHide.dblBoxSize), pointToPixel(m_biHide.dblBoxSize)));
    rc.OffsetRect(rcBar.TopLeft());
    if (rc.PtInRect(point))
        return HTCLOSE;

    return HTCLIENT;
}

/////////////////////////////////////////////////////////////////////////
// CSizingControlBarG implementation helpers

void CSizingControlBarG::OnUpdateCmdUI(CFrameWnd* pTarget,
                                      BOOL bDisableIfNoHndler)
{
    UNUSED_ALWAYS(bDisableIfNoHndler);
    UNUSED_ALWAYS(pTarget);

    if (!HasGripper())
        return;

    bool bNeedPaint = false;

    CPoint pt;
    ::GetCursorPos(&pt);
    bool bHit = (OnNcHitTest(pt) == HTCLOSE);
    bool bLButtonDown = (::GetKeyState(VK_LBUTTON) < 0);

    bool bWasPushed = m_biHide.bPushed;
    m_biHide.bPushed = bHit && bLButtonDown;

    bool bWasRaised = m_biHide.bRaised;
    m_biHide.bRaised = bHit && !bLButtonDown;

    bNeedPaint |= (m_biHide.bPushed ^ bWasPushed) ||
                  (m_biHide.bRaised ^ bWasRaised);

    if (bNeedPaint)
        SendMessage(WM_NCPAINT);
}

/////////////////////////////////////////////////////////////////////////
// CSCBButton

CSCBButton::CSCBButton()
{
    bRaised = false;
    bPushed = false;
}

void CSCBButton::Paint(CDC* pDC)
{
    const int lpx = pDC->GetDeviceCaps(LOGPIXELSX);
    auto pointToPixel = [lpx](double point) { return static_cast<int>(point * lpx / 72); };
    CRect rc(ptOrg, CSize(pointToPixel(dblBoxSize), pointToPixel(dblBoxSize)));

    if (bPushed)
        pDC->Draw3dRect(rc, ::GetSysColor(COLOR_BTNSHADOW),
            ::GetSysColor(COLOR_BTNHIGHLIGHT));
    else
        if (bRaised)
            pDC->Draw3dRect(rc, ::GetSysColor(COLOR_BTNHIGHLIGHT),
                ::GetSysColor(COLOR_BTNSHADOW));

    COLORREF clrOldTextColor = pDC->GetTextColor();
    pDC->SetTextColor(::GetSysColor(COLOR_BTNTEXT));
    int nPrevBkMode = pDC->SetBkMode(TRANSPARENT);
    CFont font;
    font.CreatePointFont(60/*6 points*/, _T("Marlett"));
    CFont* oldfont = pDC->SelectObject(&font);

    pDC->TextOut(ptOrg.x + pointToPixel(1.5), ptOrg.y + pointToPixel(1.5), CString(_T("r"))); // x-like

    pDC->SelectObject(oldfont);
    pDC->SetBkMode(nPrevBkMode);
    pDC->SetTextColor(clrOldTextColor);
}

bool CSizingControlBarG::HasGripper() const
{
#if defined(_SCB_MINIFRAME_CAPTION) || !defined(_SCB_REPLACE_MINIFRAME)
    // if the miniframe has a caption, don't display the gripper
    if (IsFloating())
        return false;
#endif //_SCB_MINIFRAME_CAPTION

    return true;
}
</file>

<file path="Winmerge-Src/Src/Common/scbarg.h">
/////////////////////////////////////////////////////////////////////////
//
// CSizingControlBarG           Version 2.44
//
// Created: Jan 24, 1998        Last Modified: March 31, 2002
//
// See the official site at www.datamekanix.com for documentation and
// the latest news.
//
/////////////////////////////////////////////////////////////////////////
// Copyright (C) 1998-2002 by Cristi Posea. All rights reserved.
//
// This code is free for personal and commercial use, providing this 
// notice remains intact in the source files and all eventual changes are
// clearly marked with comments.
//
// You must obtain the author's consent before you can include this code
// in a software library.
//
// No warrantee of any kind, express or implied, is included with this
// software; use at your own risk, responsibility for damages (if any) to
// anyone resulting from the use of this software rests entirely with the
// user.
//
// Send bug reports, bug fixes, enhancements, requests, flames, etc. to
// cristi@datamekanix.com or post them at the message board at the site.
/////////////////////////////////////////////////////////////////////////
#pragma once

/////////////////////////////////////////////////////////////////////////
// CSCBButton (button info) helper class

class CSCBButton
{
public:
    CSCBButton();

    void Move(CPoint ptTo) {ptOrg = ptTo; };
    void Paint(CDC* pDC);

    bool    bPushed;
    bool    bRaised;
    const double  dblBoxSize = 8.25;
    CPoint  ptOrg;
};

/////////////////////////////////////////////////////////////////////////
// CSizingControlBar control bar

#ifndef baseCSizingControlBarG
#define baseCSizingControlBarG CSizingControlBar
#endif

class CSizingControlBarG : public baseCSizingControlBarG
{
    DECLARE_DYNAMIC(CSizingControlBarG);

// Construction
public:
    CSizingControlBarG();

// Attributes
public:
    virtual bool HasGripper() const;

// Operations
public:

// Overridables
    virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler) override;

// Overrides
public:
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CSizingControlBarG)
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CSizingControlBarG();
    
protected:
    // implementation helpers
    virtual void NcPaintGripper(CDC* pDC, const CRect& rcClient) override;
    virtual void NcCalcClient(LPRECT pRc, UINT nDockBarID) override;

protected:
    const double m_dblGripper = 9.0;

    CSCBButton m_biHide;

// Generated message map functions
protected:
    //{{AFX_MSG(CSizingControlBarG)
    afx_msg LRESULT OnNcHitTest(CPoint point);
    afx_msg void OnNcLButtonUp(UINT nHitTest, CPoint point);
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
};
</file>

<file path="Winmerge-Src/Src/Common/Shell.cpp">
#include "pch.h"
#include "Shell.h"
#include "UnicodeString.h"
#include "paths.h"
#include <windows.h>

namespace shell
{

void Open(const tchar_t * szFile)
{
	ShellExecute(::GetDesktopWindow(), _T("open"), szFile, 0, 0, SW_SHOWNORMAL);
}

void Edit(const tchar_t * szFile)
{
	HINSTANCE rtn = ShellExecute(::GetDesktopWindow(), _T("edit"), szFile, 0, 0, SW_SHOWNORMAL);
	if (reinterpret_cast<uintptr_t>(rtn) == SE_ERR_NOASSOC)
		rtn = ShellExecute(::GetDesktopWindow(), _T("open"), szFile, 0, 0, SW_SHOWNORMAL);
	if (reinterpret_cast<uintptr_t>(rtn) == SE_ERR_NOASSOC)
		OpenWith(szFile);
}

void OpenWith(const tchar_t * szFile)
{
	tchar_t sysdir[MAX_PATH]{};
	if (!GetSystemDirectory(sysdir, MAX_PATH)) return;
	String arg = String(_T("shell32.dll,OpenAs_RunDLL ")) + szFile;
	ShellExecute(::GetDesktopWindow(), 0, _T("RUNDLL32.EXE"), arg.c_str(), sysdir, SW_SHOWNORMAL);
}

/**
 * @brief Open file, if it exists, else open url
 */
void OpenFileOrUrl(const tchar_t * szFile, const tchar_t * szUrl)
{
	if (paths::DoesPathExist(szFile) == paths::IS_EXISTING_FILE)
		ShellExecute(nullptr, _T("open"), _T("notepad.exe"), szFile, nullptr, SW_SHOWNORMAL);
	else
		Open(szUrl);
}

/**
 * @brief Open parent folder
 */
void OpenParentFolder(const tchar_t * szFile)
{
	String param = _T("/select,\"") + String(szFile) + _T("\"");
	ShellExecute(nullptr, _T("open"), _T("explorer.exe"), param.c_str(), nullptr, SW_SHOWNORMAL);
}

}
</file>

<file path="Winmerge-Src/Src/Common/Shell.h">
#pragma once

#include "UnicodeString.h"

namespace shell
{
	void Open(const tchar_t * szFile);
	void Edit(const tchar_t * szFile);
	void OpenWith(const tchar_t * szFile);
	void OpenFileOrUrl(const tchar_t * szFile, const tchar_t * szUrl);
	void OpenParentFolder(const tchar_t * szFile);
}
</file>

<file path="Winmerge-Src/Src/Common/ShellContextMenu.cpp">
/////////////////////////////////////////////////////////////////////////////
//	  WinMerge:  an interactive diff/merge utility
//	  Copyright (C) 1997-2000  Thingamahoochie Software
//	  Author: Dean Grimm
//	  SPDX-License-Identifier: GPL-2.0-or-later
/////////////////////////////////////////////////////////////////////////////
/** 
 * @file  ShellContextMenu.cpp
 *
 * @brief Main implementation file for CShellContextMenu
 */

#include "pch.h"
#include "ShellContextMenu.h"
#include "PidlContainer.h"
#include <Shlwapi.h>

CShellContextMenu::CShellContextMenu(UINT cmdFirst, UINT cmdLast)
: m_pPreferredMenu(nullptr)
, m_pShellContextMenu2(nullptr)
, m_pShellContextMenu3(nullptr)
, m_hShellContextMenu(nullptr)
, m_cmdFirst(cmdFirst)
, m_cmdLast(cmdLast)
{
}

CShellContextMenu::~CShellContextMenu()
{
	if (::IsMenu(m_hShellContextMenu))
	{
		::DestroyMenu(m_hShellContextMenu);
	}
}

void CShellContextMenu::Initialize()
{
	if (!::IsMenu(m_hShellContextMenu)) // first call or menu was destroyed by parent after it was added as submenu
	{
		m_hShellContextMenu = CreatePopupMenu();
	}
	m_files.clear();
}

void CShellContextMenu::AddItem(const std::wstring& fullpath)
{
	m_files.insert(m_files.end(), fullpath);
}

void CShellContextMenu::AddItem(const std::wstring& path,
								const std::wstring& filename)
{
	AddItem(path + L"\\" + filename);
}

HMENU CShellContextMenu::GetHMENU() const
{
	return ::IsMenu(m_hShellContextMenu) ? m_hShellContextMenu : nullptr;
}

bool CShellContextMenu::HandleMenuMessage(UINT message, WPARAM wParam, LPARAM lParam, LRESULT& retval)
{
	//HRESULT hr = E_FAIL;
	switch (message)
	{
	case WM_DRAWITEM:
	case WM_INITMENUPOPUP:
	case WM_MEASUREITEM:
		if (m_pShellContextMenu3 != nullptr)
		{
			if (FAILED(/*hr = */m_pShellContextMenu3->HandleMenuMsg(message, wParam, lParam/*, &retval*/)))
			{
				//TRACE(_T("HandleMenuMsg(%x) failed with error: %lx\n"), message, hr);
				//if (message == WM_DRAWITEM)
				//{
				//	  LPDRAWITEMSTRUCT lpDrawItem = (LPDRAWITEMSTRUCT) lParam;
				//	  (HMENU)hMenu = (HMENU)lpDrawItem->hwndItem;
				//	  TRACE(_T("  hMenu == 0x%p\n"), hMenu);
				//}
				//assert(false);
			}
		}
		else if (m_pShellContextMenu2 != nullptr)
		{
			if (FAILED(/*hr = */m_pShellContextMenu2->HandleMenuMsg(message, wParam, lParam)))
			{
				//TRACE(_T("HandleMenuMsg(%x) failed with error: %lx\n"), message, hr);
				//assert(false);
			}
		}
		// indicate that we've processed the message
		retval = (message == WM_INITMENUPOPUP) ? 0 : TRUE;
		return true;
	case WM_MENUCHAR:
		if (m_pShellContextMenu3 != nullptr)
		{
			retval = 0;
			if (FAILED(/*hr = */m_pShellContextMenu3->HandleMenuMsg2(message, wParam, lParam, &retval)))
			{
				//TRACE(_T("HandleMenuMsg2(%x) failed with error: %lx\n"), message, hr);
				//assert(false);
			}
			return true;
		}
	}
	return false;
}

static HRESULT _stdcall dfmCallback(IShellFolder* /*psf*/, HWND /*hwnd*/, IDataObject* /*pdtobj*/, UINT uMsg, WPARAM /*wParam*/, LPARAM /*lParam*/)
{
	switch (uMsg)
	{
	case DFM_MERGECONTEXTMENU:
		return S_OK;
	case DFM_INVOKECOMMAND:
	case DFM_INVOKECOMMANDEX:
	case DFM_GETDEFSTATICID: // Required for Windows 7 to pick a default
		return S_FALSE;
	}
	return E_NOTIMPL;
}

bool CShellContextMenu::QueryShellContextMenu()
{
	//HRESULT hr = E_FAIL;
	IShellFolderPtr pDesktop;
	if (FAILED(/*hr = */SHGetDesktopFolder(&pDesktop)))
		return false;

	CPidlContainer pidls;

	for (FilenamesContainer::const_iterator iter = m_files.begin(); iter != m_files.end(); ++iter)
	{
		const std::wstring& path = *iter;
		LPITEMIDLIST pidl;
		if (FAILED(/*hr = */pDesktop->ParseDisplayName(nullptr,				   // hwnd
												   nullptr,					   // pbc
												   const_cast<wchar_t *>(path.c_str()),	// pszDisplayName
												   nullptr,					   // pchEaten
												   &pidl,					   // ppidl
												   nullptr					   // pdwAttributes
												   )))
		{
			return false;
		}
		pidls.Add(pidl);
	} // for (FilenamesContainer::const_iterator iter = m_files.begin(); iter != m_files.end(); ++iter)
	
	if (0 == pidls.Size()) // no items to show menu for
	{
		return false;
	}

	// The following was created with reference to https://github.com/stefankueng/grepWin/blob/main/src/ShellContextMenu.cpp.
	HKEY ahkeys[16]{};
	int nKeys = 0;
	const std::wstring& path = m_files.front();
	nKeys += RegOpenKey(HKEY_CLASSES_ROOT, L"*", &ahkeys[nKeys]) == ERROR_SUCCESS ? 1 : 0;
	nKeys += RegOpenKey(HKEY_CLASSES_ROOT, L"AllFileSystemObjects", &ahkeys[nKeys]) == ERROR_SUCCESS ? 1 : 0;
	if (PathIsDirectory(path.c_str()))
	{
		nKeys += RegOpenKey(HKEY_CLASSES_ROOT, L"Folder", &ahkeys[nKeys]) == ERROR_SUCCESS ? 1 : 0;
		nKeys += RegOpenKey(HKEY_CLASSES_ROOT, L"Directory", &ahkeys[nKeys]) == ERROR_SUCCESS ? 1 : 0;
	}
	HKEY hkey;
	const wchar_t* ext = PathFindExtension(path.c_str());
	if (ext && *ext == '.' && RegOpenKey(HKEY_CLASSES_ROOT, ext, &hkey) == ERROR_SUCCESS)
	{
		wchar_t buf[MAX_PATH] = { 0 };
		DWORD dwSize = MAX_PATH;
		if (RegQueryValueEx(hkey, L"", nullptr, nullptr, reinterpret_cast<LPBYTE>(buf), &dwSize) == ERROR_SUCCESS)
			nKeys += RegOpenKey(HKEY_CLASSES_ROOT, buf, &ahkeys[nKeys]) == ERROR_SUCCESS ? 1 : 0;
		RegCloseKey(hkey);
	}

	IContextMenuPtr pCMenu1;
	HRESULT hr = CDefFolderMenu_Create2(nullptr, nullptr,
		static_cast<unsigned>(pidls.Size()),
		pidls.GetList(), pDesktop, dfmCallback, nKeys, ahkeys, &pCMenu1);

	for (int i = 0; i < nKeys; ++i)
		RegCloseKey(ahkeys[i]);

	if (FAILED(hr))
	{
		return false;
	}

	m_pPreferredMenu = pCMenu1;

	IContextMenu2Ptr pCMenu2(pCMenu1);
	if (pCMenu2 != nullptr)
	{
		m_pPreferredMenu = pCMenu2;
	}

	IContextMenu3Ptr pCMenu3(pCMenu1);
	if (pCMenu3 != nullptr)
	{
		m_pPreferredMenu = pCMenu3;
	}

	assert(::IsMenu(m_hShellContextMenu));
	if (FAILED(/*hr = */m_pPreferredMenu->QueryContextMenu(m_hShellContextMenu,
													   0,
													   m_cmdFirst,
													   m_cmdLast,
													   CMF_EXPLORE | CMF_CANRENAME)))
	{
		return false;
	}

	m_pShellContextMenu2 = std::move(pCMenu2);
	m_pShellContextMenu3 = std::move(pCMenu3);

	return true;
}

bool CShellContextMenu::InvokeCommand(UINT nCmd, HWND hWnd)
{
	if (nCmd >= m_cmdFirst && nCmd <= m_cmdLast)
	{
		CMINVOKECOMMANDINFO ici = {sizeof(CMINVOKECOMMANDINFO)};

		ici.hwnd = hWnd;
		nCmd -= m_cmdFirst; // adjust command id
		ici.lpVerb = MAKEINTRESOURCEA(nCmd);
		ici.nShow = SW_SHOWNORMAL;

		HRESULT hr = m_pPreferredMenu->InvokeCommand(&ici);
		assert(SUCCEEDED(hr));
		return SUCCEEDED(hr);
	}
	else 
	{
		return false;
	}
}

bool CShellContextMenu::RequeryShellContextMenu()
{
	assert(::IsMenu(m_hShellContextMenu));
	while (::GetMenuItemCount(m_hShellContextMenu) > 0)
	{
		::DeleteMenu(m_hShellContextMenu, 0, MF_BYPOSITION);
	}
	assert(::GetMenuItemCount(m_hShellContextMenu) == 0);

	return QueryShellContextMenu();
}

void CShellContextMenu::ReleaseShellContextMenu()
{
	m_pShellContextMenu2 = nullptr;
	m_pShellContextMenu3 = nullptr;
	m_pPreferredMenu = nullptr;
}
</file>

<file path="Winmerge-Src/Src/Common/ShellContextMenu.h">
/////////////////////////////////////////////////////////////////////////////
//	  WinMerge:  an interactive diff/merge utility
//	  Copyright (C) 1997  Dean P. Grimm
//	  SPDX-License-Identifier: GPL-2.0-or-later
/////////////////////////////////////////////////////////////////////////////
/**
 *	@file ShellContextMenu.h
 *
 *	@brief Declaration of class CShellContextMenu
 */ 
#pragma once

#pragma warning (push)			// prevent "warning C4091: 'typedef ': ignored on left of 'tagGPFIDL_FLAGS' when no variable is declared"
#pragma warning (disable:4091)	// VC bug when using XP enabled toolsets.
#include <shlobj.h>
#pragma warning (pop)
#include <comdef.h>
#include <list>

struct __declspec(uuid("000214e4-0000-0000-c000-000000000046")) IContextMenu;
struct __declspec(uuid("000214f4-0000-0000-c000-000000000046")) IContextMenu2;
struct __declspec(uuid("bcfce0a0-ec17-11d0-8d10-00a0c90f2719")) IContextMenu3;

_COM_SMARTPTR_TYPEDEF(IContextMenu, __uuidof(IContextMenu));
_COM_SMARTPTR_TYPEDEF(IContextMenu2, __uuidof(IContextMenu2));
_COM_SMARTPTR_TYPEDEF(IContextMenu3, __uuidof(IContextMenu3));

/**
 * @brief Explorer's context menu
 *
 * Allows to query shell context menu for a group of files
 *
 * Usage:
 * <ol>
 * <li>Initialize menu by calling Initialize().
 *	   This should be called each time user wants to show menu - i.e. user does not have to create 
 *	   new instance of CShellContextMenu each time, just needs to call Initialize().
 * <li>Add files using AddItem().</li>
 * <li>Call RequeryShellContextMenu().
 *	   If you have several CShellContextMenu objects for different groups of files and want to show context menu 
 *	   for these groups in turns you should call RequeryShellContextMenu() for appropriate object before menu is shown.
 *	   You can call RequeryShellContextMenu() in WM_INITMENUPOPUP message handler.
 *	   This is probably a "feature" of Windows Shell, but without it menus won't work correctly.</li>
 * <li>Show popup menu via TrackPopupMenu[Ex]() with TPM_RETURNCMD flag using handle that is returned by GetHMENU().
 *	   Handle WM_INITMENUPOPUP, WM_DRAWITEM, WM_MEASUREITEM and WM_MENUCHAR in window procedure of the menu owner 
 *	   and pass them to HandleMenuMessage().</li>
 * <li>Call InvokeCommand() with nCmd returned by TrackPopupMenu[Ex]().</li>
 * </ol>
 *
 * @note Current implementation can successfully query context menu from the shell only if all the files are in the same folder.
 *		 This is checked in QueryShellContextMenu() so caller can simply add items and check return value of RequeryShellContextMenu()
 */
class CShellContextMenu
{
public:
	/**
	 * @brief Constructor
	 *
	 * @param[in]	cmdFirst	minimum value for a menu item identifier
	 * @param[in]	cmdLast		maximum value for a menu item identifier
	 *
	 * @pre		cmdFirst < cmdLast <= 0xffff
	 * @pre		[cmdFirst, cmdLast] range should not intersect with available command IDs
	 */
	CShellContextMenu(UINT cmdFirst, UINT cmdLast);

	/**
	 * @brief Destructor
	 */
	~CShellContextMenu();

	/**
	 * @brief Initializes menu
	 *
	 * Should be called each time menu is going to be shown.
	 * Initializes m_hShellContextMenu and clears all previously added items.
	 */
	void Initialize();

	/**
	 * @brief	Adds a file to a group of files for which shell context menu is queried
	 *
	 * @param[in]	fullpath	Full path to file to set to item.
	 */
	void AddItem(const std::wstring& fullpath);

	/**
	 * @brief	Adds a file to a group of files for which shell context menu is queried
	 *
	 * @param[in]	path		path to file, including all but file name
	 * @param[in]	filename	file name without path
	 */
	void AddItem(const std::wstring& path,
				 const std::wstring& filename);

	/**
	 * @brief	Returns HMENU handle to context menu
	 *
	 * Menu is created by CShellContextMenu using CreatePopupMenu()
	 *
	 * @return	Handle to shell context menu.
	 *			Menu is created in constructor and does not normally change when requesting context menu via RequeryShellContextMenu()
	 *			It may though change if destroyed by someone. In this case it should be recreated in RequeryShellContextMenu()
	 *
	 * @retval	nullptr	If handle is destroyed by parent menu, but not yet recreated by RequeryShellContextMenu()
	 */
	HMENU GetHMENU() const;

	/**
	 * @brief	Clears current menu and queries context menu from the shell
	 *
	 * @retval	true	Context menu is queried successfully. User can track menu using handle returned by GetHMENU()
	 * @retval	false	Failed to query context menu
	 */
	bool RequeryShellContextMenu();

	/**
	 * @brief	Forwards certain messages to context menu so it works properly
	 *
	 * Handles WM_INITMENUPOPUP, WM_DRAWITEM, WM_MEASUREITEM and WM_MENUCHAR messages
	 *
	 * @param[in]		message		Message to handle
	 * @param[in]		wParam		Additional message-specific information
	 * @param[in]		lParam		Additional message-specific information
	 * @param[out]		retval		Value returned by message handler
	 *
	 * @retval	true	message was handled
	 * @retval	false	message was not handled
	 */
	bool HandleMenuMessage(UINT message, WPARAM wParam, LPARAM lParam, LRESULT& retval);

	/**
	 * @brief	Handles selected menu command
	 *
	 * @param[in]	nCmd	Menu item identifier returned by TrackPopupMenu[Ex]()
	 * @param[in]	hWnd	Handle to the window that owns popup menu ( window handle passed to TrackPopupMenu[Ex]() )
	 *
	 * @retval	true	Everything is OK
	 * @retval	false	Something failed
	 */
	bool InvokeCommand(UINT nCmd, HWND hWnd);

	void ReleaseShellContextMenu();

private:
	/**
	 * @brief	Queries context menu from the shell
	 *
	 * Initializes \ref m_pPreferredMenu, \ref m_pShellContextMenu2, \ref m_pShellContextMenu3 and \ref m_hShellContextMenu
	 * that are used later for showing menu and handling commands
	 *
	 * @retval	true	Menu is queried successfully
	 * @retval	false	Failed to query context menu
	 */
	bool QueryShellContextMenu();

private:
	typedef std::list<std::wstring> FilenamesContainer;

	FilenamesContainer m_files; /**< List of files to show context menu for */

	LPCONTEXTMENU m_pPreferredMenu; /**< Shell context menu for group of files. 
										 Points either to IContextMenu, IContextMenu2 or IContextMenu3 interface, 
										 the highest available. Used to process command in InvokeCommand() */
	IContextMenu2Ptr m_pShellContextMenu2; /**< IContextMenu2 interface of current preferred context menu */
	IContextMenu3Ptr m_pShellContextMenu3; /**< IContextMenu3 interface of current preferred context menu */

	HMENU m_hShellContextMenu; /**< HMENU handle of shell context menu for group of files */

	const UINT m_cmdFirst; /**< minimum value for a menu item identifier */
	const UINT m_cmdLast; /**< maximum value for a menu item identifier */
};
</file>

<file path="Winmerge-Src/Src/Common/ShellFileOperations.cpp">
// SPDX-License-Identifier: GPL-2.0-or-later
/**
 * @file  ShellFileOperations.cpp
 *
 * @brief Implementation of ShellFileOperations class.
 */

#include "pch.h"
#include "ShellFileOperations.h"
#include <windows.h>
#include <vector>
#include <shellAPI.h>
#pragma warning (push)			// prevent "warning C4091: 'typedef ': ignored on left of 'tagGPFIDL_FLAGS' when no variable is declared"
#pragma warning (disable:4091)	// VC bug when using XP enabled toolsets.
#include <shlobj.h>
#pragma warning (pop)
#include <shlobj.h>
#include <comip.h>
#include "UnicodeString.h"
#include "paths.h"
#include "TFile.h"

using std::vector;
typedef _com_ptr_t<_com_IIID<IFileOperation, &__uuidof(IFileOperation)>> IFileOperationPtr;
typedef _com_ptr_t<_com_IIID<IShellItem, &__uuidof(IShellItem)>> IShellItemPtr;

/**
 * @brief Constructor.
 */
ShellFileOperations::ShellFileOperations()
 : m_bOneToOneMapping(false)
 , m_function(0)
 , m_flags(0)
 , m_parentWindow(nullptr)
 , m_isCanceled(false)
{
}

/**
 * @brief Add source- and destination paths.
 * @param [in] source Source path.
 * @param [in] destination Destination path.
 */
void ShellFileOperations::AddSourceAndDestination(const String &source,
		const String &destination)
{
	m_sources.push_back(source);
	m_destinations.push_back(destination);
}

/**
 * @brief Add source path.
 * @param [in] source Source path.
 */
void ShellFileOperations::AddSource(const String &source)
{
	m_sources.push_back(source);
	m_bOneToOneMapping = false;
}

/**
 * @brief Add destination path.
 * @param [in] destination Destination path.
 */
void ShellFileOperations::SetDestination(const String &destination)
{
	m_destinations.push_back(destination);
	m_bOneToOneMapping = false;
}

/**
 * @brief Get a path list as C string with NULLs.
 * This function returns C-string with NULLs between paths and two NULLs
 * at the end of the paths. As the ShellFileOp() requires.
 * @param [in] source If true, return source paths, else return destination
 *   paths.
 * @param [out] string of the paths.
 */
vector<tchar_t> ShellFileOperations::GetPathList(bool source) const
{
	vector<tchar_t> paths;
	const size_t len = CountStringSize(source);
	paths.resize(len, 0);

	vector<String>::const_iterator iter;
	vector<String>::const_iterator end;
	if (source)
	{
		iter = m_sources.begin();
		end = m_sources.end();
	}
	else
	{
		iter = m_destinations.begin();
		end = m_destinations.end();
	}

	size_t ind = 0;
	while (iter != end)
	{
		const size_t slen = (*iter).length();
		memcpy(&paths[ind], (*iter).c_str(), slen * sizeof(tchar_t));
		ind += slen;
		ind++; // NUL between strings
		++iter;
	}
	return paths;
}

/**
 * @brief Calculate length of the C-string required for paths.
 * @param [in] source If true calculate source paths, else calculate
 *   destination paths.
 * @return Length of the string.
 */
size_t ShellFileOperations::CountStringSize(bool source) const
{
	vector<String>::const_iterator iter;
	vector<String>::const_iterator end;
	if (source)
	{
		iter = m_sources.begin();
		end = m_sources.end();
	}
	else
	{
		iter = m_destinations.begin();
		end = m_destinations.end();
	}

	size_t size = 0;
	while (iter != end)
	{
		size += (*iter).length() * sizeof(tchar_t);
		size += sizeof(tchar_t); // NUL between strings
		++iter;
	}
	size += 2; // Two zeros at end of the string
	return size;
}

/**
 * @brief Set the operation, flags and parent window.
 * @param [in] operation Operation to run (copy/move/delete/rename).
 * @param [in] flags Flags related to the operation.
 * @param [in] parentWindow Window getting notifications.
 */
void ShellFileOperations::SetOperation(UINT operation, FILEOP_FLAGS flags,
		HWND parentWindow /*= nullptr*/)
{
	m_function = operation;
	m_flags = flags;
	m_parentWindow = parentWindow;
}

/**
 * @brief Run the file operation(s).
 * This method runs the filesystem operation(s) added earlier.
 * @return true if succeeds and user did not cancel, false otherwise.
 */
bool ShellFileOperations::Run()
{
	if (m_function == 0)
		return false; // Operation not set!

	HRESULT hr;
	IFileOperationPtr pFileOperation;
	if (FAILED(hr = pFileOperation.CreateInstance(CLSID_FileOperation, nullptr, CLSCTX_ALL)))
	{
		vector<tchar_t> destStr;
		vector<tchar_t> sourceStr = GetPathList(true);
		if (m_function != FO_DELETE)
			destStr = GetPathList(false);

		SHFILEOPSTRUCT fileop = {m_parentWindow, m_function, &sourceStr[0],
			m_function != FO_DELETE ? &destStr[0] : nullptr, m_flags, FALSE, 0, 0};
		int ret = SHFileOperation(&fileop);

		if (ret == 0x75 || fileop.fAnyOperationsAborted) // DE_OPCANCELLED
			m_isCanceled = true;

		bool anyAborted = !!fileop.fAnyOperationsAborted;

		// SHFileOperation returns 0 when succeeds
		if (ret == 0 && !anyAborted)
			return true;
		return false;
	}

	auto CreateShellItemParseDisplayName = [](const String& path, IShellItem **psi)
	{
		HRESULT hr;
		PIDLIST_ABSOLUTE pidl;
		if (FAILED(hr = SHParseDisplayName(path.c_str(), nullptr, &pidl, 0, nullptr)))
		{
			tchar_t szShortPath[32768] = {};
			if (GetShortPathName(TFile(path).wpath().c_str(), szShortPath, sizeof(szShortPath) / sizeof(szShortPath[0])) == 0)
			{
				hr = E_FAIL;
			}
			else
			{
				String shortPath = szShortPath;
				strutils::replace(shortPath, _T("\\\\?\\UNC\\"), _T("\\\\"));
				strutils::replace(shortPath, _T("\\\\?\\"), _T(""));
				hr = SHParseDisplayName(shortPath.c_str(), nullptr, &pidl, 0, nullptr);
			}
		}
		if (SUCCEEDED(hr))
		{
			hr = SHCreateShellItem(nullptr, nullptr, pidl, psi);
			ILFree(pidl);
		}
		return hr;
	};

	pFileOperation->SetOperationFlags(m_flags & ~FOF_MULTIDESTFILES);

	auto itsrc = m_sources.begin();
	auto itdst = m_destinations.begin();

	while (itsrc != m_sources.end() || itdst != m_destinations.end())
	{
		IShellItemPtr pShellItemSrc;
		IShellItemPtr pShellItemDst;
		String dstFileName;
		if (itsrc != m_sources.end())
		{
			if (FAILED(CreateShellItemParseDisplayName(*itsrc, &pShellItemSrc)))
				return false;
			++itsrc;
		}
		if (itdst != m_destinations.end())
		{
			String parent = paths::GetParentPath(*itdst);
			if (FAILED(CreateShellItemParseDisplayName(parent, &pShellItemDst)))
			{
				TFile(parent).createDirectories();
				if (FAILED(CreateShellItemParseDisplayName(parent, &pShellItemDst)))
					return false;
			}
			dstFileName = paths::FindFileName(*itdst);
			++itdst;
		}
		switch (m_function)
		{
		case FO_COPY:
			hr = pFileOperation->CopyItem(pShellItemSrc, pShellItemDst, dstFileName.c_str(), nullptr);
			break;
		case FO_MOVE:
			hr = pFileOperation->MoveItem(pShellItemSrc, pShellItemDst, dstFileName.c_str(), nullptr);
			break;
		case FO_DELETE:
			hr = pFileOperation->DeleteItem(pShellItemSrc, nullptr);
			break;
		case FO_RENAME:
			hr = pFileOperation->RenameItem(pShellItemSrc, dstFileName.c_str(), nullptr);
			break;
		}
		if (FAILED(hr))
			return false;
	}
	hr = pFileOperation->PerformOperations();
	BOOL fAnyOperationsAborted = FALSE;
	pFileOperation->GetAnyOperationsAborted(&fAnyOperationsAborted);
	m_isCanceled = fAnyOperationsAborted;
	return SUCCEEDED(hr) && !fAnyOperationsAborted;
}

/**
 * @brief Reset the class.
 */
void ShellFileOperations::Reset()
{
	m_bOneToOneMapping = false;
	m_function = 0;
	m_flags = 0;
	m_parentWindow = nullptr;
	m_isCanceled = false;

	m_sources.clear();
	m_destinations.clear();
}
</file>

<file path="Winmerge-Src/Src/Common/ShellFileOperations.h">
// SPDX-License-Identifier: GPL-2.0-or-later
/**
 * @file  ShellFileOperations.h
 *
 * @brief Declaration file for ShellFileOperations class.
 */
#pragma once

#include <vector>
#include <windows.h>
#include <ShellAPI.h>
#include "UnicodeString.h"

/**
 * @brief A wrapper class for SHFileOperation().
 * This class offers easier way to use SHFileOperation(). User can just add
 * paths without needing to care about adding correct amount of NULLs.
 */
class ShellFileOperations
{
public:
	ShellFileOperations();

	void AddSourceAndDestination(const String &source, const String &destination);
	void AddSource(const String &source);
	void SetDestination(const String &destination);
	void SetOperation(UINT operation, FILEOP_FLAGS flags, HWND parentWindow = nullptr);
	bool Run();
	bool IsCanceled() const;
	void Reset();

protected:
	std::vector<tchar_t> GetPathList(bool source) const;
	size_t CountStringSize(bool source) const;

private:
	std::vector<String> m_sources; /**< Source paths. */
	std::vector<String> m_destinations; /**< Destination paths. */
	UINT m_function; /**< Operation used, copy, move, rename or delete. */
	FILEOP_FLAGS m_flags; /**< Flags for the operation. */
	HWND m_parentWindow; /**< Parent window getting notifications. */
	bool m_bOneToOneMapping; /**< Same amount of sources and destinations? */
	bool m_isCanceled; /**< Did user cancel the operation? */
};

/**
 * @brief Did the user cancel the operation?
 * @return true if the operation was canceled by the user.
 */
inline bool ShellFileOperations::IsCanceled() const
{
	return m_isCanceled;
}

</file>

<file path="Winmerge-Src/Src/Common/sizecbar.h">
/////////////////////////////////////////////////////////////////////////
//
// CSizingControlBar            Version 2.44
//
// Created: Jan 24, 1998        Last Modified: March 31, 2002
//
// See the official site at www.datamekanix.com for documentation and
// the latest news.
//
/////////////////////////////////////////////////////////////////////////
// Copyright (C) 1998-2002 by Cristi Posea. All rights reserved.
//
// This code is free for personal and commercial use, providing this 
// notice remains intact in the source files and all eventual changes are
// clearly marked with comments.
//
// You must obtain the author's consent before you can include this code
// in a software library.
//
// No warrantee of any kind, express or implied, is included with this
// software; use at your own risk, responsibility for damages (if any) to
// anyone resulting from the use of this software rests entirely with the
// user.
//
// Send bug reports, bug fixes, enhancements, requests, flames, etc. to
// cristi@datamekanix.com or post them at the message board at the site.
/////////////////////////////////////////////////////////////////////////
#pragma once

#include <afxpriv.h>    // for CDockContext
#include <afxtempl.h>   // for CTypedPtrArray

#if defined(_SCB_MINIFRAME_CAPTION) && !defined(_SCB_REPLACE_MINIFRAME)
    #error "_SCB_MINIFRAME_CAPTION requires _SCB_REPLACE_MINIFRAME"
#endif

/////////////////////////////////////////////////////////////////////////
// CSCBDockBar dummy class for access to protected members

class CSCBDockBar : public CDockBar
{
    friend class CSizingControlBar;
};

/////////////////////////////////////////////////////////////////////////
// CSizingControlBar control bar styles

#define SCBS_EDGELEFT       0x00000001
#define SCBS_EDGERIGHT      0x00000002
#define SCBS_EDGETOP        0x00000004
#define SCBS_EDGEBOTTOM     0x00000008
#define SCBS_EDGEALL        0x0000000F
#define SCBS_SHOWEDGES      0x00000010
#define SCBS_SIZECHILD      0x00000020

/////////////////////////////////////////////////////////////////////////
// CSizingControlBar control bar

#ifndef baseCSizingControlBar
#define baseCSizingControlBar CControlBar
#endif

class CSizingControlBar;
typedef CTypedPtrArray <CPtrArray, CSizingControlBar*> CSCBArray;

class CSizingControlBar : public baseCSizingControlBar
{
    DECLARE_DYNAMIC(CSizingControlBar);

// Construction
public:
    CSizingControlBar();

    virtual BOOL Create(LPCTSTR lpszWindowName, CWnd* pParentWnd,
        UINT nID, DWORD dwStyle = WS_CHILD | WS_VISIBLE | CBRS_TOP);

// Attributes
public:
    bool IsFloating() const;
    bool IsHorzDocked() const;
    bool IsVertDocked() const;
    bool IsSideTracking() const;
    bool GetSCBStyle() const {return (m_dwSCBStyle != 0);}

// Operations
public:
#if defined(_SCB_REPLACE_MINIFRAME) && !defined(_SCB_MINIFRAME_CAPTION)
    void EnableDocking(DWORD dwDockStyle);
#endif
    virtual void LoadState(LPCTSTR lpszProfileName);
    virtual void SaveState(LPCTSTR lpszProfileName);
    static void GlobalLoadState(CFrameWnd* pFrame, LPCTSTR lpszProfileName);
    static void GlobalSaveState(CFrameWnd* pFrame, LPCTSTR lpszProfileName);
    void SetSCBStyle(DWORD dwSCBStyle)
        {m_dwSCBStyle = (dwSCBStyle & ~SCBS_EDGEALL);}

// Overridables
    virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);

// Overrides
public:
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CSizingControlBar)
    public:
    virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz);
    virtual CSize CalcDynamicLayout(int nLength, DWORD dwMode);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CSizingControlBar();
    
protected:
    // implementation helpers
    UINT GetEdgeHTCode(int nEdge);
    bool GetEdgeRect(const CRect& rcWnd, UINT nHitTest, CRect& rcEdge);
    virtual void StartTracking(UINT nHitTest, CPoint point);
    virtual void StopTracking();
    virtual void OnTrackUpdateSize(CPoint& point);
    virtual void OnTrackInvertTracker();
    virtual void NcPaintGripper(CDC* pDC, const CRect& rcClient);
    virtual void NcCalcClient(LPRECT pRc, UINT nDockBarID);

    virtual void AlignControlBars();
    void GetRowInfo(int& nFirst, int& nLast, int& nThis);
    void GetRowSizingBars(CSCBArray& arrSCBars);
    void GetRowSizingBars(CSCBArray& arrSCBars, int& nThis);
    bool NegotiateSpace(int nLengthTotal, bool bHorz);

protected:
    DWORD   m_dwSCBStyle = 0;
    UINT    m_htEdge = 0;

    CSize   m_szHorz = CSize(120, 200);
    CSize   m_szVert = CSize(120, 200);
    CSize   m_szFloat = CSize(120, 200);
    CSize   m_szMinHorz = CSize(33, 32);
    CSize   m_szMinVert = CSize(33, 32);
    CSize   m_szMinFloat = CSize(37, 32);
    int     m_nTrackPosMin = 0;
    int     m_nTrackPosMax = 0;
    int     m_nTrackPosOld = 0;
    int     m_nTrackEdgeOfs = 0;
    bool    m_bTracking = false;
    bool    m_bKeepSize = false;
    bool    m_bParentSizing = false;
    bool    m_bDragShowContent = false;
    UINT    m_nDockBarID = 0;
    int     m_cxEdge = 5;

// Generated message map functions
protected:
    //{{AFX_MSG(CSizingControlBar)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnNcPaint();
    afx_msg void OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS* lpncsp);
    afx_msg LRESULT OnNcHitTest(CPoint point);
    afx_msg void OnCaptureChanged(CWnd *pWnd);
    afx_msg void OnSettingChange(UINT uFlags, LPCTSTR lpszSection);
    afx_msg void OnSysColorChange();
    afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
    afx_msg void OnMouseMove(UINT nFlags, CPoint point);
    afx_msg void OnNcLButtonDown(UINT nHitTest, CPoint point);
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
    afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnWindowPosChanging(WINDOWPOS* lpwndpos);
    afx_msg void OnPaint();
    afx_msg void OnClose();
    afx_msg void OnSize(UINT nType, int cx, int cy);
    //}}AFX_MSG
    afx_msg LRESULT OnSetText(WPARAM wParam, LPARAM lParam);

    DECLARE_MESSAGE_MAP()

#ifdef _SCB_REPLACE_MINIFRAME
    friend class CSCBMiniDockFrameWnd;
#endif //_SCB_REPLACE_MINIFRAME
};

#ifdef _SCB_REPLACE_MINIFRAME
#ifndef _SCB_MINIFRAME_CAPTION
/////////////////////////////////////////////////////////////////////////
// CSCBDockContext dockcontext

class CSCBDockContext : public CDockContext
{
public:
// Construction
    explicit CSCBDockContext(CControlBar* pBar) : CDockContext(pBar) {}

// Drag Operations
    virtual void StartDrag(CPoint pt);
};
#endif //_SCB_MINIFRAME_CAPTION

/////////////////////////////////////////////////////////////////////////
// CSCBMiniDockFrameWnd miniframe

#ifndef baseCSCBMiniDockFrameWnd
#define baseCSCBMiniDockFrameWnd CMiniDockFrameWnd
#endif

class CSCBMiniDockFrameWnd : public baseCSCBMiniDockFrameWnd
{
    DECLARE_DYNCREATE(CSCBMiniDockFrameWnd)

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CSCBMiniDockFrameWnd)
    public:
    virtual BOOL Create(CWnd* pParent, DWORD dwBarStyle);
    //}}AFX_VIRTUAL

// Implementation
public:
    CSizingControlBar* GetSizingControlBar();

    //{{AFX_MSG(CSCBMiniDockFrameWnd)
    afx_msg void OnNcLButtonDown(UINT nHitTest, CPoint point);
    afx_msg void OnGetMinMaxInfo(MINMAXINFO* lpMMI);
    afx_msg void OnWindowPosChanging(WINDOWPOS* lpwndpos);
    afx_msg void OnSize(UINT nType, int cx, int cy);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};
#endif //_SCB_REPLACE_MINIFRAME
</file>

<file path="Winmerge-Src/Src/Common/SortHeaderCtrl.cpp">
/**
 *  @file SortHeaderCtrl.cpp
 *
 *  @brief Implementation of CSortHeaderCtrl
 */ 

#include "StdAfx.h"
#include "SortHeaderCtrl.h"

/////////////////////////////////////////////////////////////////////////////
// CSortHeaderCtrl

IMPLEMENT_DYNAMIC(CSortHeaderCtrl, CHeaderCtrl)

BEGIN_MESSAGE_MAP(CSortHeaderCtrl, CHeaderCtrl)
	//{{AFX_MSG_MAP(CSortHeaderCtrl)
	ON_WM_PAINT()
	ON_WM_ERASEBKGND()
	ON_WM_MOUSEMOVE()
	ON_WM_MOUSELEAVE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CSortHeaderCtrl::CSortHeaderCtrl() : m_bSortAsc(true), m_nSortCol(-1), m_bMouseTracking(false), m_nTrackingPane(-1)
{
}

CSortHeaderCtrl::~CSortHeaderCtrl()
{
}

int CSortHeaderCtrl::SetSortImage(int nCol, bool bAsc)
{
	int nPrevCol = m_nSortCol;

	m_nSortCol = nCol;
	m_bSortAsc = bAsc;

	HD_ITEM hditem;

	hditem.mask = HDI_FORMAT;

	// Clear HDF_SORTDOWN and HDF_SORTUP flag in all columns.
	int i;
	for (i = 0; i < this->GetItemCount(); i++)
	{
		GetItem( i, &hditem );
		if (hditem.fmt & (HDF_SORTDOWN | HDF_SORTUP))
		{
			hditem.fmt &= ~(HDF_SORTUP | HDF_SORTDOWN);
			SetItem( i, &hditem );
		}
	}

	GetItem( nCol, &hditem );

	// We can use HDF_SORTUP and HDF_SORTDOWN flag to draw a sort arrow on the header.
	hditem.fmt &= ~(HDF_SORTUP | HDF_SORTDOWN);
	hditem.fmt |= bAsc ? HDF_SORTUP : HDF_SORTDOWN;
	SetItem( nCol, &hditem );

	// Invalidate header control so that it gets redrawn
	Invalidate();

	return nPrevCol;
}

BOOL CSortHeaderCtrl::OnEraseBkgnd(CDC* pDC)
{
	CRect rcClient;
	GetClientRect(rcClient);
	pDC->FillSolidRect(rcClient, GetSysColor(COLOR_3DHIGHLIGHT));
	return TRUE;
}

static void DrawSortArrow(CDC& dc, bool up, int cx, int cy)
{
	const int lpx = dc.GetDeviceCaps(LOGPIXELSX);
	auto pointToPixelF = [lpx](float point) { return point * lpx / 72.f; };
	const int arrowWidth = static_cast<int>(pointToPixelF(2.25));
	Gdiplus::Graphics graphics(dc.m_hDC);
	graphics.SetSmoothingMode(Gdiplus::SmoothingModeAntiAlias);
	Gdiplus::Color penColor;
	penColor.SetFromCOLORREF(GetSysColor(COLOR_BTNTEXT));
	Gdiplus::Pen pen(penColor, pointToPixelF(0.75));
	Gdiplus::Point points[3];
	if (up)
	{
		points[0] = Gdiplus::Point(cx - arrowWidth, cy + arrowWidth);
		points[1] = Gdiplus::Point(cx, cy);
		points[2] = Gdiplus::Point(cx + arrowWidth, cy + arrowWidth);
	}
	else
	{
		points[0] = Gdiplus::Point(cx - arrowWidth, cy);
		points[1] = Gdiplus::Point(cx, cy + arrowWidth);
		points[2] = Gdiplus::Point(cx + arrowWidth, cy);
	}
	graphics.DrawLines(&pen, points, 3);
}

void CSortHeaderCtrl::OnPaint()
{
	CPaintDC dc(this);
	CPen pen;
	pen.CreatePen(PS_SOLID, 1, GetSysColor(COLOR_3DFACE));
	CPen* pOldPen = dc.SelectObject(&pen);
	dc.SelectObject(GetFont());
	dc.SetTextColor(GetSysColor(COLOR_BTNTEXT));
	dc.SetBkMode(TRANSPARENT);
	const int nItems = this->GetItemCount();
	for (int i = 0; i < nItems; ++i)
	{
		TCHAR buf[256]{};
		HDITEM hi;
		hi.mask = HDI_TEXT | HDI_FORMAT;
		hi.pszText = buf;
		hi.cchTextMax = sizeof(buf) / sizeof(buf[0]);
		GetItem(i, &hi);
		CRect rc;
		GetItemRect(i, &rc);
		dc.FillSolidRect(&rc, GetSysColor(
			m_nTrackingPane == i ? COLOR_3DFACE : COLOR_3DHIGHLIGHT));
		dc.DrawText(hi.pszText, &rc, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
		dc.MoveTo(rc.right - 1, rc.top);
		dc.LineTo(rc.right - 1, rc.bottom);
		if ((hi.fmt & (HDF_SORTDOWN | HDF_SORTUP)) != 0)
			DrawSortArrow(dc, (hi.fmt & HDF_SORTUP) != 0, (rc.left + rc.right) / 2, rc.top);
	}
	dc.SelectObject(pOldPen);
	pen.DeleteObject();
}

void CSortHeaderCtrl::OnMouseMove(UINT nFlags, CPoint point)
{
	if ((nFlags & MK_LBUTTON) == 0)
	{
		if (!m_bMouseTracking)
		{
			TRACKMOUSEEVENT tme = { sizeof TRACKMOUSEEVENT, TME_LEAVE, m_hWnd };
			TrackMouseEvent(&tme);
			m_bMouseTracking = true;
		}
		HDHITTESTINFO hhti;
		GetCursorPos(&hhti.pt);
		ScreenToClient(&hhti.pt);
		HitTest(&hhti);
		for (int pane : {hhti.iItem, m_nTrackingPane})
		{
			if (pane >= 0)
			{
				CRect rcPart;
				GetItemRect(pane, rcPart);
				InvalidateRect(&rcPart, false);
			}
		}
		m_nTrackingPane = hhti.iItem;
	}
	__super::OnMouseMove(nFlags, point);
}

void CSortHeaderCtrl::OnMouseLeave()
{
	TRACKMOUSEEVENT tme = { sizeof(TRACKMOUSEEVENT), TME_LEAVE | TME_CANCEL, m_hWnd };
	TrackMouseEvent(&tme);
	m_bMouseTracking = false;
	if (m_nTrackingPane >= 0)
	{
		CRect rcPart;
		GetItemRect(m_nTrackingPane, rcPart);
		InvalidateRect(&rcPart, false);
	}
	m_nTrackingPane = -1;
}
</file>

<file path="Winmerge-Src/Src/Common/SortHeaderCtrl.h">
/**
 *  @file SortHeaderCtrl.h
 *
 *  @brief Declaration of CSortHeaderCtrl
 */ 
#pragma once

/////////////////////////////////////////////////////////////////////////////
// CSortHeaderCtrl

class CSortHeaderCtrl : public CHeaderCtrl
{
	DECLARE_DYNAMIC(CSortHeaderCtrl)

// Construction
public:
	CSortHeaderCtrl();

// Attributes
protected:
	int 	m_nSortCol;
	bool	m_bSortAsc;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSortHeaderCtrl)
	//}}AFX_VIRTUAL

	virtual int 	SetSortImage(int nCol, bool bAsc);

// Implementation
public:
	virtual ~CSortHeaderCtrl();

// Generated message map functions
protected:
	//{{AFX_MSG(CSortHeaderCtrl)
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnPaint();
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnMouseLeave();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

	bool m_bMouseTracking;
	int m_nTrackingPane;
};
</file>

<file path="Winmerge-Src/Src/Common/SplitterWndEx.cpp">
//////////////////////////////////////////////////////////////////////
/** 
 * @file  SplitterWndEx.cpp
 *
 * @brief Implementation file for CSplitterWndEx
 *
 */
//
//////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include <vector>
#include "SplitterWndEx.h"
#include "cecolor.h"
#include "MergeDarkMode.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

BEGIN_MESSAGE_MAP(CSplitterWndEx, CSplitterWnd)
	//{{AFX_MSG_MAP(CSplitterWndEx)
	ON_WM_HSCROLL()
	ON_WM_VSCROLL()
	ON_WM_SIZE()
	ON_WM_SETTINGCHANGE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CSplitterWndEx, CSplitterWnd)

CSplitterWndEx::CSplitterWndEx()
{
	m_bBarLocked = false;
	m_bResizePanes = false;
	m_bAutoResizePanes = false;
	m_bHideBorders = false;
}

CSplitterWndEx::~CSplitterWndEx()
{

}

int CSplitterWndEx::HitTest(CPoint pt) const
{
	if (m_bBarLocked)
		return 0;
	return CSplitterWnd::HitTest(pt);
}

BOOL CSplitterWndEx::CreateScrollBarCtrl(DWORD dwStyle, UINT nID)
{
	BOOL bResult = CSplitterWnd::CreateScrollBarCtrl(dwStyle, nID);
	auto pBar = static_cast<CScrollBar*>(GetDlgItem(nID));
	if (pBar != nullptr && pBar->GetSafeHwnd())
	{
		DarkMode::setDarkScrollBar(pBar->GetSafeHwnd());
		pBar->Invalidate();
	}
	return bResult;
}

CScrollBar* CSplitterWndEx::GetScrollBarCtrl(CWnd* pWnd, int nBar) const
{
	UINT nID = pWnd->GetDlgCtrlID();
	//IdFromRowCol(row, col);
	if (nID < AFX_IDW_PANE_FIRST || nID > AFX_IDW_PANE_LAST)
		return nullptr;            // not a standard pane ID

	// appropriate PANE id - look for sibling (splitter, or just frame)
	UINT nIDScroll;
	if (nBar == SB_HORZ)
		nIDScroll = AFX_IDW_HSCROLL_FIRST + (nID - AFX_IDW_PANE_FIRST) % 16;
	else
		nIDScroll = AFX_IDW_VSCROLL_FIRST + (nID - AFX_IDW_PANE_FIRST) / 16;

	// return shared scroll bars that are immediate children of splitter
	return (CScrollBar*)GetDlgItem(nIDScroll);
}

void CSplitterWndEx::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar *pScrollBar)
{
  // Ignore scroll events sent directly to the splitter (i.e. not from a
  // scroll bar)
  if (pScrollBar == nullptr)
    return;
	// maintain original synchronization functionality (all panes above the scrollbar)
	CSplitterWnd::OnHScroll(nSBCode, nPos, pScrollBar);

	// only sync if shared horizontal bars
	if((GetScrollStyle()&WS_HSCROLL) == 0)
		return;

	// enhance with proportional horizontal scroll synchronization
	ASSERT(pScrollBar != nullptr);
	int curCol = ::GetDlgCtrlID(pScrollBar->m_hWnd) - AFX_IDW_HSCROLL_FIRST;
	ASSERT(curCol >= 0 && curCol < m_nMaxCols);

	ASSERT(m_nRows > 0);

	// broadcast to all panes (other horizontal scrollbars and other panes)
	for (int col = 0; col < m_nCols; col++)
	{
		// for current column, already handled in base OnHScroll
		if(col==curCol)
			continue;

		CScrollBar* curBar = GetScrollBarCtrl(GetPane(0, col), SB_HORZ);
		int newPos = min(pScrollBar->GetScrollPos(), curBar->GetScrollLimit());

		// Set the scrollbar info using SetScrollInfo(), limited to 2.000.000.000 characters,
		// better than the 32.768 characters (signed short) of SendMessage(WM_HSCROLL,...) 
		SCROLLINFO si;
		si.nPos = newPos;
		si.nTrackPos = newPos;
		si.fMask = SIF_POS | SIF_TRACKPOS;
		curBar->SetScrollInfo(&si, FALSE);

		// iterate through all rows
		for (int row = 0; row < m_nRows; row++)
		{
			// repaint all rows
			GetPane(row, col)->SendMessage(WM_HSCROLL,
				MAKELONG(SB_THUMBPOSITION, newPos), (LPARAM)curBar->m_hWnd);
		}
	}

}


void CSplitterWndEx::OnVScroll(UINT nSBCode, UINT nPos, CScrollBar *pScrollBar)
{
  // Ignore scroll events sent directly to the splitter (i.e. not from a
  // scroll bar)
  if (pScrollBar == nullptr)
    return;

	// only sync if shared vertical bars
	if((GetScrollStyle()&WS_VSCROLL) == 0)
		return;

	// maintain original synchronization functionality (all panes left from the scrollbar)
	CSplitterWnd::OnVScroll(nSBCode, nPos, pScrollBar);

	// enhance with proportional vertical scroll synchronization
	ASSERT(pScrollBar != nullptr);
	int curRow = ::GetDlgCtrlID(pScrollBar->m_hWnd) - AFX_IDW_VSCROLL_FIRST;
	ASSERT(curRow >= 0 && curRow < m_nMaxRows);

	ASSERT(m_nCols > 0);
	const int oldLimit = pScrollBar->GetScrollLimit();

	// broadcast to all panes (other vertical scrollbars and other panes)
	for (int row = 0; row < m_nRows; row++)
	{
		// for current row, already handled in base OnHScroll
		if(row==curRow)
			continue;

		CScrollBar* curBar = GetScrollBarCtrl(GetPane(row, 0), SB_VERT);
		double temp = ((double) pScrollBar->GetScrollPos()) * curBar->GetScrollLimit() + oldLimit/2;
		int newPos = (int) (temp/oldLimit);

		// Set the scrollbar info using SetScrollInfo(), limited to 2.000.000.000 characters,
		// better than the 32.768 characters (signed short) of SendMessage(WM_HSCROLL,...) 
		SCROLLINFO si;
		si.nPos = newPos;
		si.nTrackPos = newPos;
		si.fMask = SIF_POS | SIF_TRACKPOS;
		curBar->SetScrollInfo(&si, FALSE);

		// iterate through all columns
		for (int col = 0; col < m_nCols; col++)
		{
			// repaint all columns
			GetPane(row, col)->SendMessage(WM_VSCROLL,
				MAKELONG(SB_THUMBPOSITION, newPos), (LPARAM)curBar->m_hWnd);
		}
	}

}

static void initializeRatios(std::vector<int>& ratios, int n)
{
	ratios.clear();
	for (int sum = 0, i = 0; i < n; ++i)
	{
		ratios.push_back((i + 1) * 10000 / n - sum);
		sum = (i + 1) * 10000 / n;
	}
}

static void updateRatios(CSplitterWnd& wnd, int pane, int newpos, std::vector<int>& ratios, bool horizontal)
{
	const int n = horizontal ? wnd.GetColumnCount(): wnd.GetRowCount();
	if (static_cast<size_t>(n) != ratios.size())
		initializeRatios(ratios, n);

	int sum = 0;
	std::vector<int> sizes(n);
	for (int i = 0 ; i < n; i++)
	{
		int min;
		if (horizontal)
			wnd.GetColumnInfo(i, sizes[i], min);
		else
			wnd.GetRowInfo(i, sizes[i], min);
		sum += sizes[i];
	}
	int sumratio = 0;
	int i;
	for (i = 0; i < pane; i++)
	{
		ratios[i] = sizes[i] * 10000 / sum;
		sumratio += ratios[i];
	}
	ratios[i] = newpos * 10000 / sum - sumratio;
	sumratio += ratios[i];
	++i;
	for (; i < n - 1; i++)
	{
		if (ratios[i] + sumratio > 10000)
			ratios[i] = 10000 - sumratio;
		sumratio += ratios[i];
	}
	ratios[n - 1] = 10000 - sumratio;
}

void CSplitterWndEx::EqualizeRows() 
{
	if (m_nRows < 2)
		return;

	if (static_cast<size_t>(m_nRows) != m_rowRatios.size())
		initializeRatios(m_rowRatios, m_nRows);

	int i;
	int sum = 0;
	int hmin = 0;
	for (i = 0 ; i < m_nRows ; i++)
	{
		int h;
		GetRowInfo(i, h, hmin);
		sum += h;
	}
	if (sum > 0)
	{
		int remain = sum;
		for (i = 0 ; i < m_nRows-1 ; i++)
		{
			const int height = m_rowRatios[i] * sum / 10000;
			SetRowInfo(i, height, hmin);
			remain -= height;
		}
		SetRowInfo(i, remain, hmin);
		CSplitterWnd::RecalcLayout();
	}
}

void CSplitterWndEx::EqualizeCols() 
{
	if (m_nCols < 2)
		return;

	if (static_cast<size_t>(m_nCols) != m_colRatios.size())
		initializeRatios(m_colRatios, m_nCols);

	int i;
	int sum = 0;
	int hmin = 0;

	for (i = 0 ; i < m_nCols ; i++)
	{
		int v;
		GetColumnInfo(i, v, hmin);
		sum += v;
	}

	// Sum is negative if WinMerge started minimized.
	if (sum > 0)
	{
		int remain = sum;
		for (i = 0 ; i < m_nCols-1 ; i++)
		{
			const int width = m_colRatios[i] * sum / 10000;
			SetColumnInfo(i, width, hmin);
			remain -= width;
		}
		SetColumnInfo(i, remain, hmin);
		CSplitterWnd::RecalcLayout();
	}
}

void CSplitterWndEx::RecalcLayout()
{
	if (m_nCols == 2 && m_bAutoResizePanes)
	{
		// If WinMerge spans multiple monitors, split the panes on the monitor split.
		CRect vSplitterWndRect;
		GetWindowRect(vSplitterWndRect);
		HMONITOR hLeftMonitor = MonitorFromPoint(vSplitterWndRect.TopLeft(), MONITOR_DEFAULTTONEAREST);
		HMONITOR hRightMonitor = MonitorFromPoint(CPoint(vSplitterWndRect.right, vSplitterWndRect.top), MONITOR_DEFAULTTONEAREST);

		bool bSplitPanesInHalf = true;
		if (hLeftMonitor != hRightMonitor)
		{
			MONITORINFO info{ sizeof(MONITORINFO) };
			GetMonitorInfo(hLeftMonitor, &info);

			int iDesiredWidthOfLeftPane = info.rcMonitor.right - vSplitterWndRect.left;
			int iDesiredWidthOfRightPane = vSplitterWndRect.right - info.rcMonitor.right;

			// Edge case - don't split if either pane would be less than 100 pixels.
			if (iDesiredWidthOfLeftPane > 100 && iDesiredWidthOfRightPane > 100)
			{
				bSplitPanesInHalf = false;
				SetColumnInfo(0, iDesiredWidthOfLeftPane, 0);
				SetColumnInfo(1, iDesiredWidthOfRightPane, 0);
			}
		}
		
		// If we don't want to split panes across monitors, just split them in half.
		// We want to do this so that if the window used to be split across monitors,
		// but now occupies only a single monitor, then the panes are updated correctly.
		if (bSplitPanesInHalf)
		{
			EqualizeCols();
		}
	}

	CSplitterWnd::RecalcLayout();
}

void CSplitterWndEx::TrackRowSize(int y, int row)
{
	__super::TrackRowSize(y, row);
	updateRatios(*this, row, y, m_rowRatios, false);
}

void CSplitterWndEx::TrackColumnSize(int x, int col)
{
	__super::TrackColumnSize(x, col);
	updateRatios(*this, col, x, m_colRatios, true);
}

// Override GetActivePane() because CSplitterWnd::GetActivePane() does not take into account the case of nested Splitter Windows.
CWnd* CSplitterWndEx::GetActivePane(int* pRow, int* pCol)
{
	ASSERT_VALID(this);

	// attempt to use active view of frame window
	CWnd* pView = NULL;
	CFrameWnd* pFrameWnd = EnsureParentFrame();
	pView = pFrameWnd ? pFrameWnd->GetActiveView() : nullptr;

	// failing that, use the current focus
	if (pView == NULL)
		pView = GetFocus();

	CWnd* pActiveView = pView;
	if (pView)
	{
		while (pView && pView->GetParent() != this)
			pView = pView->GetParent();
	}

	// make sure the pane is a child pane of the splitter
	if (pView != NULL && !IsChildPane(pView, pRow, pCol))
		pActiveView = NULL;

	return pActiveView;
}

void CSplitterWndEx::OnSize(UINT nType, int cx, int cy) 
{
	CSplitterWnd::OnSize(nType, cx, cy);

	// and resize the panes 
	if (m_bResizePanes)
	{
		if (m_nCols == 2 && m_bAutoResizePanes)
		{
			RecalcLayout();
			EqualizeRows();
		}
		else
		{
			EqualizeCols();
			EqualizeRows();
		}
	}
}

void CSplitterWndEx::OnSettingChange(UINT uFlags, LPCTSTR lpszSection)
{
	if (WinMergeDarkMode::IsImmersiveColorSet(lpszSection))
		DarkMode::setChildCtrlsTheme(GetSafeHwnd());
	__super::OnSettingChange(uFlags, lpszSection);
}

void CSplitterWndEx::FlipSplit()
{
	int nRows = m_nCols, nCols = m_nRows;
	std::vector<CWnd *> pColPanes(nCols);
	std::vector<CWnd *> pRowPanes(nRows);

	bool bHasVScroll = !!m_bHasHScroll;
	bool bHasHScroll = !!m_bHasVScroll;

	CScrollBar *pBar;
	int pane;
	for (pane = 1; pane < nRows; pane++)
	{
		pRowPanes[pane] = GetDlgItem(IdFromRowCol( 0, pane ));
		pBar = pRowPanes[pane]->GetScrollBarCtrl(SB_HORZ);
		if (pBar != nullptr)
			pBar->ShowWindow(SW_HIDE);
		pBar = pRowPanes[pane]->GetScrollBarCtrl(SB_VERT);
		if (pBar != nullptr)
			pBar->ShowWindow(SW_HIDE);
	}
	for (pane = 1; pane < nCols; pane++)
	{
		pColPanes[pane] = GetDlgItem(IdFromRowCol( pane, 0 ));
		pBar = pColPanes[pane]->GetScrollBarCtrl(SB_HORZ);
		if (pBar != nullptr)
			pBar->ShowWindow(SW_HIDE);
		pBar = pColPanes[pane]->GetScrollBarCtrl(SB_VERT);
		if (pBar != nullptr)
			pBar->ShowWindow(SW_HIDE);
	}

	m_nMaxCols = m_nCols = nCols;
	m_nMaxRows = m_nRows = nRows;

	CRowColInfo* pTmp = m_pColInfo;
	m_pColInfo = m_pRowInfo;
	m_pRowInfo = pTmp;

	for (pane = 1; pane < nRows; pane++)
		pRowPanes[pane]->SetDlgCtrlID( IdFromRowCol( pane, 0 ));
	for (pane = 1; pane < nCols; pane++)
		pColPanes[pane]->SetDlgCtrlID( IdFromRowCol( 0, pane ));

	SetScrollStyle(0);
	SetScrollStyle(
		(bHasVScroll ? WS_VSCROLL : 0) | 
		(bHasHScroll ? WS_HSCROLL : 0));

	RecalcLayout();

	EqualizeCols();
	EqualizeRows();

}

void CSplitterWndEx::OnDrawSplitter(CDC* pDC, ESplitType nType, const CRect& rectArg)
{
	if (nType == splitBorder && pDC != nullptr && !m_bHideBorders)
	{
		CRect rect = rectArg;
		COLORREF clrShadow  = GetSysColor(COLOR_BTNSHADOW);
		COLORREF clrFace    = GetSysColor(COLOR_BTNFACE);
		COLORREF clrShadow2 = CEColor::GetIntermediateColor(clrFace, clrShadow, 0.9f);
		COLORREF clrShadow3 = CEColor::GetIntermediateColor(clrFace, clrShadow2, 0.5f);
		COLORREF clrShadow4 = CEColor::GetIntermediateColor(clrFace, clrShadow3, 0.5f);
		COLORREF clrShadow5 = CEColor::GetIntermediateColor(clrFace, clrShadow4, 0.5f);
		pDC->Draw3dRect(rect, clrShadow5, clrShadow4);
		rect.InflateRect(-1, -1);
		pDC->Draw3dRect(rect, clrShadow3, clrShadow2);
		return;
	}
	return CSplitterWnd::OnDrawSplitter(pDC, nType, rectArg);
}
</file>

<file path="Winmerge-Src/Src/Common/SplitterWndEx.h">
/** 
 * @file  SplitterWndEx.h
 *
 * @brief Declaration of CSplitterWndEx class
 */
#pragma once

#include <vector>

class CSplitterWndEx : public CSplitterWnd  
{
	DECLARE_DYNCREATE(CSplitterWndEx)

public:
	CSplitterWndEx();
	virtual ~CSplitterWndEx();
	void LockBar(bool bState=true){m_bBarLocked=bState;};
	void ResizablePanes(bool bState=true){m_bResizePanes=bState;};
	void AutoResizePanes(bool bState=true){m_bAutoResizePanes=bState;};
	void HideBorders(bool bHide)
	{
		m_cxBorder = m_cyBorder = bHide ? 0 : 2;
		m_bHideBorders = bHide;
	}
	void FlipSplit();

	int HitTest(CPoint pt) const;

	void EqualizeRows(); 
	void EqualizeCols(); 

	virtual void RecalcLayout() override;
	virtual void TrackRowSize(int y, int row) override;
	virtual void TrackColumnSize(int x, int col) override;
	virtual CWnd* GetActivePane(int* pRow = NULL, int* pCol = NULL) override;

	CScrollBar* GetScrollBarCtrl(CWnd* pWnd, int nBar) const;

private:
	bool m_bBarLocked;
	bool m_bResizePanes;
	bool m_bAutoResizePanes;
	bool m_bHideBorders;
	std::vector<int> m_rowRatios;
	std::vector<int> m_colRatios;

	BOOL CreateScrollBarCtrl(DWORD dwStyle, UINT nID) override;

protected:
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnSettingChange(UINT uFlags, LPCTSTR lpszSection);
	virtual void OnDrawSplitter(CDC* pDC, ESplitType nType, const CRect& rect);
	DECLARE_MESSAGE_MAP()
};
</file>

<file path="Winmerge-Src/Src/Common/SuperComboBox.cpp">
// CSuperComboBox.cpp : implementation file
//

#include "StdAfx.h"
#include "SuperComboBox.h"
#include <vector>
#include "DropHandler.h"

// Wrap placement new to avoid the need to temporarily #undef new
template<typename T>
T &placement_cast(void *p)
{
	return *new(p) T;
}

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

#define DEF_MAXSIZE		20	// default maximum items to retain in each SuperComboBox


/////////////////////////////////////////////////////////////////////////////
// CSuperComboBox

HIMAGELIST CSuperComboBox::m_himlSystem = nullptr;

CSuperComboBox::CSuperComboBox()
	: m_pDropHandler(nullptr)
	, m_bInEditchange(false)
	, m_bDoComplete(false)
	, m_bAutoComplete(false)
	, m_bHasImageList(false)
	, m_bComboBoxEx(false)
	, m_bExtendedFileNames(false)
	, m_bCanBeEmpty(false)
	, m_nMaxItems(DEF_MAXSIZE)
{


	// Initialize OLE libraries if not yet initialized
	m_bMustUninitOLE = false;
	_AFX_THREAD_STATE* pState = AfxGetThreadState();
	if (!pState->m_bNeedTerm)
	{
		SCODE sc = ::OleInitialize(nullptr);
		if (FAILED(sc))
			AfxMessageBox(_T("OLE initialization failed. Make sure that the OLE libraries are the correct version"));
		else
			m_bMustUninitOLE = true;
	}
}

CSuperComboBox::~CSuperComboBox()
{
	// Uninitialize OLE support
	if (m_bMustUninitOLE)
		::OleUninitialize();
}

BEGIN_MESSAGE_MAP(CSuperComboBox, CComboBoxEx)
	//{{AFX_MSG_MAP(CSuperComboBox)
	ON_CONTROL_REFLECT_EX(CBN_EDITCHANGE, OnEditchange)
	ON_CONTROL_REFLECT_EX(CBN_SETFOCUS, OnSetfocus)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_WM_DRAWITEM()
	ON_NOTIFY_REFLECT(CBEN_GETDISPINFO, OnGetDispInfo)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSuperComboBox message handlers

void CSuperComboBox::PreSubclassWindow()
{
	__super::PreSubclassWindow();
	m_pDropHandler = new DropHandler(std::bind(&CSuperComboBox::OnDropFiles, this, std::placeholders::_1));
	RegisterDragDrop(m_hWnd, m_pDropHandler);
	
	TCHAR szClassName[256];
	GetClassName(m_hWnd, szClassName, sizeof(szClassName)/sizeof(szClassName[0]));
	if (lstrcmpi(_T("ComboBoxEx32"), szClassName) == 0)
		m_bComboBoxEx = true;
}

/**
 * @brief Sets additional state for handling Extended Length file names.
 */
void CSuperComboBox::SetFileControlStates(bool bCanBeEmpty /*= false*/, int nMaxItems /*= -1*/)
{
	ASSERT(m_bComboBoxEx);

	m_bExtendedFileNames = true;
	m_bCanBeEmpty = bCanBeEmpty;
	if (nMaxItems > 0)
		m_nMaxItems = nMaxItems;
}

/**
 * @brief Adds a string to the list box of a combo box
 * @param lpszItem Pointer to the null-terminated string that is to be added. 
 */
int CSuperComboBox::AddString(LPCTSTR lpszItem)
{
	return InsertString(GetCount(), lpszItem);
}

/**
 * @brief Inserts a string into the list box of a combo box.
 * @param nIndex The zero-based index to the position in the list box that receives the string.
 * @param lpszItem Pointer to the null-terminated string that is to be added. 
 */
int CSuperComboBox::InsertString(int nIndex, LPCTSTR lpszItem)
{
	if (m_bComboBoxEx)
	{
		CString sShortName;		// scoped to remain valid for calling __super::InsertItem()
		if (m_bExtendedFileNames)
		{
			if (nIndex >= static_cast<int>(m_sFullStateText.size()))
				m_sFullStateText.resize(nIndex + 10);
			sShortName = m_sFullStateText[nIndex] = lpszItem;

			const int nPartLen = 72;
			if (sShortName.GetLength() > (nPartLen*2+8)) 
			{
				if (sShortName.Left(4) == _T("\\\\?\\"))
					sShortName.Delete(0, 4);
				else
				if (sShortName.Left(8) == _T("\\\\?\\UNC\\"))
					sShortName.Delete(1, 6);
				CString sL = sShortName.Left(nPartLen);
				int nL = sL.ReverseFind(_T('\\'));
				if (nL > 0) sL = sL.Left(nL+1);

				CString sR = sShortName.Right(nPartLen);
				int nR = sR.Find(_T('\\'));
				if (nR > 0) sR = sR.Right(sR.GetLength() - nR);

				sShortName = sL + _T(" ... ") + sR;
				lpszItem = (LPCTSTR)sShortName;
			}
		}
		COMBOBOXEXITEM cbitem = {0};
		cbitem.mask = CBEIF_TEXT |
			(m_bHasImageList ? CBEIF_IMAGE|CBEIF_SELECTEDIMAGE : 0);
		cbitem.pszText = (LPTSTR)lpszItem;
		cbitem.cchTextMax = (int)_tcslen(lpszItem);
		cbitem.iItem = nIndex;
		cbitem.iImage = I_IMAGECALLBACK;
		cbitem.iSelectedImage = I_IMAGECALLBACK;
		return __super::InsertItem(&cbitem);
	}
	else
	{
		return CComboBox::InsertString(nIndex, lpszItem);
	}
}

int CSuperComboBox::DeleteString(int nIndex)
{
	if (m_bComboBoxEx && m_bExtendedFileNames &&
	    nIndex >= 0 && nIndex < static_cast<int>(m_sFullStateText.size()))
	{
		m_sFullStateText.erase(m_sFullStateText.begin() + nIndex);
	}
	return __super::DeleteString(nIndex);
}

int CSuperComboBox::FindString(int nStartAfter, LPCTSTR lpszString) const
{
	
	if (m_bComboBoxEx)
	{
		ASSERT(m_bExtendedFileNames);
		CString sSearchString = lpszString;
		int nSearchStringLen = sSearchString.GetLength();
		if (nSearchStringLen <= 0)
			return CB_ERR;
		int nLimit = static_cast<int>(m_sFullStateText.size());
		for (int i = nStartAfter+1; i < nLimit; i++)
		{
			CString sListString = m_sFullStateText[i];
			int nListStringLen = sListString.GetLength();
			if (nSearchStringLen <= nListStringLen && sSearchString.CompareNoCase(sListString.Left(nSearchStringLen))==0)
				return i;
		}
		return CB_ERR;
	}
	else
	{
		return CComboBox::FindString(nStartAfter, lpszString);
	}
}

/**
 * @brief Gets the system image list and attaches the image list to a combo box control.
 */
bool CSuperComboBox::AttachSystemImageList()
{
	ASSERT(m_bComboBoxEx);
	if (m_himlSystem==nullptr)
	{
		SHFILEINFO sfi = {0};
		m_himlSystem = (HIMAGELIST)SHGetFileInfo(_T(""), 0, 
			&sfi, sizeof(sfi), SHGFI_SMALLICON | SHGFI_SYSICONINDEX);
		if (m_himlSystem==nullptr)
			return false;
	}
	SetImageList(CImageList::FromHandle(m_himlSystem));
	m_bHasImageList = true;
	return true;
}

void CSuperComboBox::LoadState(LPCTSTR szRegSubKey)
{
	ResetContent();

	int cnt = AfxGetApp()->GetProfileInt(szRegSubKey, _T("Count"), 0);
	int idx = 0;
	for (int i=0; i < cnt && idx < m_nMaxItems; i++)
	{
		CString s,s2;
		s2.Format(_T("Item_%d"), i);
		s = AfxGetApp()->GetProfileString(szRegSubKey, s2);
		if (FindStringExact(-1, s) == CB_ERR && !s.IsEmpty())
		{
			AddString(s);
			idx++;
		}
	}
	if (idx > 0)
	{
		bool bIsEmpty = (m_bCanBeEmpty ? (AfxGetApp()->GetProfileInt(szRegSubKey, _T("Empty"), FALSE) == TRUE) : false);
		if (bIsEmpty)
		{
			SetCurSel(-1);
		}
		else
		{
			SetCurSel(0);
			if (m_bExtendedFileNames)
				GetEditCtrl()->SetWindowText(m_sFullStateText[0]);
		}
	}
}

void CSuperComboBox::GetLBText(int nIndex, CString &rString) const
{
	ASSERT(::IsWindow(m_hWnd));

	if (m_bExtendedFileNames)
	{
		rString = m_sFullStateText[nIndex];
	}
	else
	{
		__super::GetLBText(nIndex, rString.GetBufferSetLength(GetLBTextLen(nIndex)));
		rString.ReleaseBuffer();
	}
}

int CSuperComboBox::GetLBTextLen(int nIndex) const
{
	if (m_bExtendedFileNames)
	{
		return m_sFullStateText[nIndex].GetLength();
	}
	else
	{
		return __super::GetLBTextLen(nIndex);
	}
}

/** 
 * @brief Saves strings in combobox.
 * This function saves strings in combobox, in editbox and in dropdown.
 * Whitespace characters are stripped from begin and end of the strings
 * before saving. Empty strings are not saved. So strings which have only
 * whitespace characters aren't save either.
 * @param [in] szRegSubKey Registry subkey where to save strings.
 * @param [in] bCanBeEmpty
 * @param [in] nMaxItems Max number of strings to save.
 */
void CSuperComboBox::SaveState(LPCTSTR szRegSubKey)
{
	CString strItem;
	if (m_bComboBoxEx)
		GetEditCtrl()->GetWindowText(strItem);
	else
		GetWindowText(strItem);
	strItem.TrimLeft();
	strItem.TrimRight();

	int idx = 0;
	if (!strItem.IsEmpty())
	{
		AfxGetApp()->WriteProfileString(szRegSubKey, _T("Item_0"), strItem);
		idx=1;
	}

	int cnt = GetCount();
	for (int i=0; i < cnt && idx < m_nMaxItems; i++)
	{		
		CString s;
		GetLBText(i, s);
		s.TrimLeft();
		s.TrimRight();
		if (s != strItem && !s.IsEmpty())
		{
			CString s2;
			s2.Format(_T("Item_%d"), idx);
			AfxGetApp()->WriteProfileString(szRegSubKey, s2, s);
			idx++;
		}
	}
	AfxGetApp()->WriteProfileInt(szRegSubKey, _T("Count"), idx);
	
	if (m_bCanBeEmpty)
		AfxGetApp()->WriteProfileInt(szRegSubKey, _T("Empty"), strItem.IsEmpty());
}

void CSuperComboBox::ClearState(LPCTSTR szRegSubKey)
{
	AfxGetApp()->WriteProfileString(szRegSubKey, nullptr, nullptr);
}

BOOL CSuperComboBox::OnEditchange()
{
	if (m_bHasImageList)
	{
		// Trigger a WM_WINDOWPOSCHANGING to help the client area receive an update trough WM_DRAWITEM
		SetWindowPos(NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_NOREDRAW | SWP_NOACTIVATE);
	}

	// bail if not auto completing 
	if (!m_bDoComplete) 
		return FALSE;
	
	int length = GetWindowTextLength();

	// bail if no text
	if (length <= 0) 
		return FALSE;
	
	if (m_bInEditchange)
		return FALSE;
	m_bInEditchange = true;

	// Get the text in the edit box
	CString s;
	GetWindowText(s);
	
	// get the current selection
	DWORD sel = GetEditSel();
	int start = (short)LOWORD(sel), end = (short)HIWORD(sel);
	
	// look for the string that is prefixed by the typed text
	int idx = FindString(-1, s);
	if (idx != CB_ERR)
	{
		// set the new string
		CString strNew;
		GetLBText(idx, strNew);
		SetWindowText(strNew);
	}
	
	// select the text after our typing
	if (sel == CB_ERR || end >= length)
	{
		start = length;
		end = -1;
	}

	// get the caret back in the right spot
	if (m_bComboBoxEx)
		GetEditCtrl()->SetSel(start, end);
	else
		CComboBox::SetEditSel(start, end);  

	m_bInEditchange = false;

	return FALSE;
}

BOOL CSuperComboBox::OnSetfocus()
{
	if (m_bHasImageList)
		GetEditCtrl()->SetModify(FALSE);

	return FALSE;
}

BOOL CSuperComboBox::PreTranslateMessage(MSG* pMsg)
{
    if (pMsg->message == WM_KEYDOWN)
    {
		int nVirtKey = (int) pMsg->wParam;
		// If Shift+Del pressed when dropdown is open, delete selected item
		// from dropdown list
		if (GetAsyncKeyState(VK_SHIFT))
		{
			if (GetDroppedState() && nVirtKey == VK_DELETE)
			{
				int cursel = GetCurSel();
				if (cursel != CB_ERR)
				{
					DeleteString(cursel);
					if (cursel >= GetCount())
						cursel = GetCount() - 1;
					if (cursel >= 0)
						SetCurSel(cursel);
				}
				return FALSE; // No need to further handle this message
			}
		}
		if (m_bAutoComplete)
		{
			m_bDoComplete = true;

			if (nVirtKey == VK_DELETE || nVirtKey == VK_BACK)
					m_bDoComplete = false;
		}
    }

    return __super::PreTranslateMessage(pMsg);
}

void CSuperComboBox::SetAutoComplete(INT nSource)
{
	switch (nSource)
	{
		case AUTO_COMPLETE_DISABLED:
			m_bAutoComplete = false;
			break;

		case AUTO_COMPLETE_FILE_SYSTEM:
		{
			// Disable the build-in auto-completion and use the Windows
			// shell functionality.
			m_bAutoComplete = false;

			// ComboBox's edit control is always 1001.
			CWnd *pWnd = m_bComboBoxEx ? this->GetEditCtrl() : GetDlgItem(1001);
			ASSERT(pWnd != nullptr);
			SHAutoComplete(pWnd->m_hWnd, SHACF_FILESYSTEM);
			break;
		}

		case AUTO_COMPLETE_RECENTLY_USED:
			m_bAutoComplete = true;
			break;

		default:
			ASSERT(!"Unknown AutoComplete source.");
			m_bAutoComplete = false;
	}
}

void CSuperComboBox::ResetContent()
{
	if (m_bExtendedFileNames)
	{
		m_sFullStateText.resize(m_nMaxItems);
		for (int i = 0; i < m_nMaxItems; i++)
		{
			m_sFullStateText[i].Empty();
		}
	}
	__super::ResetContent();
}

int CSuperComboBox::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (__super::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	m_pDropHandler = new DropHandler(std::bind(&CSuperComboBox::OnDropFiles, this, std::placeholders::_1));
	RegisterDragDrop(m_hWnd, m_pDropHandler);
	return 0;
}

void CSuperComboBox::OnDestroy(void)
{
	if (m_pDropHandler != nullptr)
		RevokeDragDrop(m_hWnd);
}

/////////////////////////////////////////////////////////////////////////////
//
//	OnDropFiles code from CDropEdit
//	Copyright 1997 Chris Losinger
//
//	shortcut expansion code modified from :
//	CShortcut, 1996 Rob Warner
//
void CSuperComboBox::OnDropFiles(const std::vector<String>& files)
{
	GetParent()->SendMessage(WM_COMMAND, GetDlgCtrlID() +
		(CBN_EDITUPDATE << 16), (LPARAM)m_hWnd);
	SetWindowText(files[0].c_str());
	GetParent()->SendMessage(WM_COMMAND, GetDlgCtrlID() +
		(CBN_EDITCHANGE << 16), (LPARAM)m_hWnd);
}

static DWORD WINAPI SHGetFileInfoThread(LPVOID pParam)
{
	CString &sPath = reinterpret_cast<CString &>(pParam);
	SHFILEINFO sfi = {0};
	// If SHGetFileInfo() fails, intentionally leave sfi.iIcon as 0 (indicating
	// a file of inspecific type) so as to not obstruct CBEIF_DI_SETITEM logic.
	if (!sPath.IsEmpty())
	{
		if (SUCCEEDED(CoInitialize(nullptr)))
		{
			SHGetFileInfo(sPath, 0, &sfi, sizeof(sfi), SHGFI_SYSICONINDEX);
			CoUninitialize();
		}
	}
	sPath.~CString();
	return sfi.iIcon;
}

static int GetFileTypeIconIndex(LPVOID pParam)
{
	CString &sText = reinterpret_cast<CString &>(pParam);
	DWORD dwIconIndex = 0;
	bool isNetworkDrive = false;
	if (sText.GetLength() >= 2 && (sText[1] == L'\\'))
	{
		if (sText.GetLength() > 4 && sText.Left(4) == L"\\\\?\\")
			if (sText.GetLength() > 8 && sText.Left(8) == L"\\\\?\\UNC\\")
				isNetworkDrive = true;
			else
				isNetworkDrive = false;	// Just a Long File Name indicator
		else
			isNetworkDrive = true;
	}
	else
	if (sText.GetLength() >= 3 && GetDriveType(sText.Left(3)) == DRIVE_REMOTE)
		isNetworkDrive = true;	// Drive letter, but mapped to Remote UNC device.

	// Unless execution drops into the final else block,
	// SHGetFileInfoThread() takes ownership of, and will eventually trash sText
	if (!isNetworkDrive)
	{
		dwIconIndex = SHGetFileInfoThread(pParam);
	}
	else
	if (HANDLE hThread = CreateThread(nullptr, 0, SHGetFileInfoThread, pParam, 0, nullptr))
	{
		// The path is a network path. 
		// Try to get the index of a system image list icon, with 1-sec timeout.

		DWORD dwResult = WaitForSingleObject(hThread, 1000);
		if (dwResult == WAIT_OBJECT_0)
		{
			GetExitCodeThread(hThread, &dwIconIndex);
		}
		CloseHandle(hThread);
	}
	else
	{
		// Ownership of sText was retained, so trash it here
		sText.~CString();
	}
	return static_cast<int>(dwIconIndex);
}

void CSuperComboBox::OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct)
{
	if ((lpDrawItemStruct->itemState & ODS_COMBOBOXEDIT) != 0 && m_bHasImageList)
	{
		LPVOID pvText;
		CString &sText = placement_cast<CString>(&pvText);
		CEdit *const pEdit = GetEditCtrl();
		if (!pEdit->GetModify() || GetFocus() != pEdit)
			GetWindowText(sText);
		int iIcon = GetFileTypeIconIndex(pvText);
		ImageList_DrawEx(m_himlSystem, iIcon, lpDrawItemStruct->hDC,
			lpDrawItemStruct->rcItem.left, lpDrawItemStruct->rcItem.top,
			0, 0, GetSysColor(COLOR_WINDOW), CLR_NONE, ILD_NORMAL);
		return;
	}
	__super::OnDrawItem(nIDCtl, lpDrawItemStruct);
}

/**
 * @brief A message handler for CBEN_GETDISPINFO message
 */
void CSuperComboBox::OnGetDispInfo(NMHDR *pNotifyStruct, LRESULT *pResult)
{
	NMCOMBOBOXEX *pDispInfo = (NMCOMBOBOXEX *)pNotifyStruct;
	if (pDispInfo && pDispInfo->ceItem.pszText && m_bHasImageList)
	{
		pDispInfo->ceItem.mask |= CBEIF_DI_SETITEM;
		LPVOID pvText;
		GetLBText(static_cast<int>(pDispInfo->ceItem.iItem), placement_cast<CString>(&pvText));
		int iIcon = GetFileTypeIconIndex(pvText);
		pDispInfo->ceItem.iImage = iIcon;
		pDispInfo->ceItem.iSelectedImage = iIcon;
	}
	*pResult = 0;
}
</file>

<file path="Winmerge-Src/Src/Common/SuperComboBox.h">
#pragma once

// SuperComboBox.h : header file
//

#include <vector>
#include "UnicodeString.h"

class DropHandler;

/////////////////////////////////////////////////////////////////////////////
// CSuperComboBox window

class CSuperComboBox : public CComboBoxEx
{
// Construction
public:
	CSuperComboBox();
	virtual ~CSuperComboBox();

// Attributes
protected:
	bool m_bInEditchange;
	bool m_bAutoComplete;
	bool m_bDoComplete;
	bool m_bHasImageList;

	int m_nMaxItems;
	bool m_bComboBoxEx;
	bool m_bExtendedFileNames;
	bool m_bCanBeEmpty;

	bool m_bMustUninitOLE;
	static HIMAGELIST m_himlSystem;

	DropHandler *m_pDropHandler;

	std::vector<CString> m_sFullStateText;

public:

	enum
	{
		AUTO_COMPLETE_DISABLED		= 0,
		AUTO_COMPLETE_FILE_SYSTEM,
		AUTO_COMPLETE_RECENTLY_USED
	};

// Operations
	void SetAutoComplete(INT nSource);

public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSuperComboBox)
	public:
    virtual BOOL PreTranslateMessage(MSG* pMsg);
    //}}AFX_VIRTUAL

// Implementation
public:
	void SetFileControlStates(bool bCanBeEmpty = false, int nMaxItems = -1);
	void SaveState(LPCTSTR szRegSubKey);
	void LoadState(LPCTSTR szRegSubKey);
	static void ClearState(LPCTSTR szRegSubKey);
	bool AttachSystemImageList();
	int AddString(LPCTSTR lpszItem);
	int InsertString(int nIndex, LPCTSTR lpszItem);
	int DeleteString(int nIndex);
	int FindString(int nStartAfter, LPCTSTR lpszString) const;
	int GetLBTextLen(int nIndex) const;
	void GetLBText(int nIndex, CString &rString) const;

	// Generated message map functions
protected:
	void ResetContent();

	virtual void PreSubclassWindow();

	//{{AFX_MSG(CSuperComboBox)
	afx_msg BOOL OnEditchange();
	afx_msg BOOL OnSetfocus();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDropFiles(const std::vector<String>& files);
	afx_msg void OnGetDispInfo(NMHDR *pNotifyStruct, LRESULT *pResult);
	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
	afx_msg void OnDestroy();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};
</file>

<file path="Winmerge-Src/Src/Common/SysColorHook.cpp">
/**
 * @file  SysColorHook.cpp
 *
 * @brief Provides functionality to hook the GetSysColor() API and return custom colors.
 */
// SPDX-License-Identifier: MIT
#include "stdafx.h"
#include "SysColorHook.h"
#include "MergeDarkMode.h"

#if defined(_DARKMODELIB_EXTERNAL_IATHOOK) || !defined(USE_DARKMODELIB)
#include "IatHook.h"
#else
extern PIMAGE_THUNK_DATA FindAddressByName(void* moduleBase, PIMAGE_THUNK_DATA impName, PIMAGE_THUNK_DATA impAddr, const char* funcName);
extern PIMAGE_THUNK_DATA FindAddressByOrdinal(void* moduleBase, PIMAGE_THUNK_DATA impName, PIMAGE_THUNK_DATA impAddr, uint16_t ordinal);
extern PIMAGE_THUNK_DATA FindIatThunkInModule(void* moduleBase, const char* dllName, const char* funcName);
extern PIMAGE_THUNK_DATA FindDelayLoadThunkInModule(void* moduleBase, const char* dllName, const char* funcName);
extern PIMAGE_THUNK_DATA FindDelayLoadThunkInModule(void* moduleBase, const char* dllName, uint16_t ordinal);
#endif

using fnGetSysColor = DWORD(WINAPI*)(int nIndex);
using fnGetSysColorBrush = HBRUSH(WINAPI*)(int nIndex);

struct SysColor
{
	DWORD color;
	HBRUSH brush;
	bool isCustom;
} g_syscolor[COLOR_MENUBAR + 1];

static fnGetSysColor g_orgGetSysColor;
static fnGetSysColorBrush g_orgGetSysColorBrush;

namespace SysColorHook
{

DWORD __stdcall MyGetSysColor(int nIndex)
{
	if (nIndex < 0 || nIndex >= static_cast<int>(std::size(g_syscolor)))
		return 0;
	return g_syscolor[nIndex].color;
}

HBRUSH __stdcall MyGetSysColorBrush(int nIndex)
{
	if (nIndex < 0 || nIndex >= static_cast<int>(std::size(g_syscolor)))
		return 0;
	return g_syscolor[nIndex].brush;
}

bool IsCustomSysColor(int nIndex)
{
	if (nIndex < 0 || nIndex >= static_cast<int>(std::size(g_syscolor)))
		return false;
	return g_syscolor[nIndex].isCustom;
}

size_t GetSysColorCount()
{
	return std::size(g_syscolor);
}

unsigned GetOrgSysColor(int nIndex)
{
	if (!g_orgGetSysColor)
		return GetSysColor(nIndex);
	return g_orgGetSysColor(nIndex);
}

uintptr_t ReplaceFunction(IMAGE_THUNK_DATA* addr, uintptr_t newFunction)
{
	DWORD oldProtect;
	if (!VirtualProtect(addr, sizeof(IMAGE_THUNK_DATA), PAGE_READWRITE, &oldProtect))
		return 0;
	uintptr_t oldFunction = addr->u1.Function;
	addr->u1.Function = newFunction;
	VirtualProtect(addr, sizeof(IMAGE_THUNK_DATA), oldProtect, &oldProtect);
	return oldFunction;
}

void Init()
{
	auto getSysColor = (g_orgGetSysColor ? g_orgGetSysColor : GetSysColor);
	auto getSysColorBrush = (g_orgGetSysColorBrush ? g_orgGetSysColorBrush : GetSysColorBrush);
	for (int i = 0; i < static_cast<int>(std::size(g_syscolor)); ++i)
	{
		if (g_syscolor[i].isCustom)
			DeleteObject(g_syscolor[i].brush);
		g_syscolor[i].color = getSysColor(i);
		g_syscolor[i].brush = getSysColorBrush(i);
		g_syscolor[i].isCustom = false;
	}
}

bool Hook(void* moduleBase)
{
	auto addrGetSysColor = FindIatThunkInModule(moduleBase, "user32.dll", "GetSysColor");
	auto addrGetSysColorBrush = FindIatThunkInModule(moduleBase, "user32.dll", "GetSysColorBrush");
	if (!addrGetSysColor || !addrGetSysColorBrush)
		return false;
	auto orgGetSysColor = reinterpret_cast<fnGetSysColor>(ReplaceFunction(addrGetSysColor, reinterpret_cast<uintptr_t>(static_cast<fnGetSysColor>(MyGetSysColor))));
	if (!g_orgGetSysColor)
		g_orgGetSysColor = orgGetSysColor;
	auto orgGetSysColorBrush = reinterpret_cast<fnGetSysColorBrush>(ReplaceFunction(addrGetSysColorBrush, reinterpret_cast<uintptr_t>(static_cast<fnGetSysColorBrush>(MyGetSysColorBrush))));
	if (!g_orgGetSysColorBrush)
		g_orgGetSysColorBrush = orgGetSysColorBrush;
	return true;
}

void Unhook(void* moduleBase)
{
	if (!g_orgGetSysColor)
		return;
	auto addrGetSysColor = FindIatThunkInModule(moduleBase, "user32.dll", "GetSysColor");
	auto addrGetSysColorBrush = FindIatThunkInModule(moduleBase, "user32.dll", "GetSysColorBrush");
	if (!addrGetSysColor || !addrGetSysColorBrush)
		return;
	ReplaceFunction(addrGetSysColor, reinterpret_cast<uintptr_t>(static_cast<fnGetSysColor>(g_orgGetSysColor)));
	ReplaceFunction(addrGetSysColorBrush, reinterpret_cast<uintptr_t>(static_cast<fnGetSysColorBrush>(g_orgGetSysColorBrush)));
	g_orgGetSysColor = nullptr;
	g_orgGetSysColorBrush = nullptr;
}

void SetSysColor(int nIndex, unsigned color)
{
	if (nIndex < 0 || nIndex >= static_cast<int>(std::size(g_syscolor)))
		return;
	if (g_syscolor[nIndex].color == color)
		return;
	if (g_syscolor[nIndex].isCustom)
		DeleteObject(g_syscolor[nIndex].brush);
	g_syscolor[nIndex].brush = CreateSolidBrush(color);
	g_syscolor[nIndex].color = color;
	g_syscolor[nIndex].isCustom = true;
}

void Deserialize(const String& colorsStr, COLORREF* colors)
{
	auto sysColorMapping = strutils::split(colorsStr, ',');
	for (auto&& sysColorEntry : sysColorMapping)
	{
		auto pair = strutils::split(sysColorEntry, ':');
		if (pair.size() == 2)
		{
			const int index = tc::ttoi(String(pair[0].data(), pair[0].length()).c_str());
			tchar_t* endptr = nullptr;
			const String colorStr = String(pair[1].data(), pair[1].length());
			unsigned color = static_cast<unsigned>(tc::tcstoll(colorStr.c_str(), &endptr,
				(colorStr.length() >= 2 && colorStr[1] == 'x') ? 16 : 10));
			if (colors)
			{
				if (index >= 0 && index < static_cast<int>(std::size(g_syscolor)))
					colors[index] = color;
			}
			else
				SysColorHook::SetSysColor(index, color);
		}
	}
}

String Serialize()
{
	std::vector<String> sysColorMapping;
	const int count = static_cast<int>(SysColorHook::GetSysColorCount());
	for (int i = 0; i < count; ++i)
	{
		if (g_syscolor[i].isCustom)
			sysColorMapping.push_back(strutils::format(_T("%d:0x%08x"), i, g_syscolor[i].color));
	}
	return strutils::join(sysColorMapping.begin(), sysColorMapping.end(), _T(","));
}

}


</file>

<file path="Winmerge-Src/Src/Common/SysColorHook.h">
/**
 * @file  SysColorHook.h
 *
 * @brief Provides functionality to hook the GetSysColor() API and return custom colors.
 */
#pragma once

namespace SysColorHook
{
void Init();
bool Hook(void* moduleBase);
void Unhook(void* moduleBase);
void SetSysColor(int nIndex, unsigned color);
unsigned GetOrgSysColor(int nIndex);
bool IsCustomSysColor(int nIndex);
size_t GetSysColorCount();
void Deserialize(const String& colorStr, COLORREF* colors = nullptr);
String Serialize();

}
</file>

<file path="Winmerge-Src/Src/Common/unicoder.cpp">
/**
 *  @file   unicoder.cpp
 *  @author Perry Rapp, Creator, 2003-2006
 *  @date   Created: 2003-10
 *  @date   Edited:  2006-02-20 (Perry Rapp)
 *
 *  @brief  Implementation of utility unicode conversion routines
 */

/* The MIT License
Copyright (c) 2003 Perry Rapp
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

#include "pch.h"
#include "unicoder.h"
#include <windows.h>
#include <cassert>
#include <memory>
#include <Poco/UnicodeConverter.h>
#include "UnicodeString.h"
#include "ExConverter.h"

using Poco::UnicodeConverter;

namespace ucr
{

// store the default codepage as specified by user in options
static int f_nDefaultCodepage = GetACP();


# pragma warning(push)          // Saves the current warning state.
# pragma warning(disable:4244)  // Temporarily disables warning 4244: "conversion from 'int' to 'char', possible loss of data"
/**
 * @brief Convert unicode codepoint to UTF-8 byte string
 *
 * utf8 must be a 7+ byte buffer
 * returns length of byte string written
 * Does not zero-terminate!
 */
int Ucs4_to_Utf8(unsigned unich, unsigned char * utf8)
{
	if (unich <= 0x7f)
	{
		utf8[0] = (unsigned char)unich;
		return 1;
	}
	else if (unich <= 0x7ff)
	{
		utf8[0] = 0xc0 + (unich >> 6);
		utf8[1] = 0x80 + (unich & 0x3f);
		return 2;
	}
	else if (unich <= 0xffff)
	{
		utf8[0] = 0xe0 + (unich >> 12);
		utf8[1] = 0x80 + ((unich >> 6) & 0x3f);
		utf8[2] = 0x80 + (unich & 0x3f);
		return 3;
	}
	else if (unich <= 0x1fffff)
	{
		utf8[0] = 0xf0 + (unich >> 18);
		utf8[1] = 0x80 + ((unich >> 12) & 0x3f);
		utf8[2] = 0x80 + ((unich >> 6) & 0x3f);
		utf8[3] = 0x80 + (unich & 0x3f);
		return 4;
	}
	else if (unich <= 0x3ffffff)
	{
		utf8[0] = 0xf8 + (unich >> 24);
		utf8[1] = 0x80 + ((unich >> 18) & 0x3f);
		utf8[2] = 0x80 + ((unich >> 12) & 0x3f);
		utf8[3] = 0x80 + ((unich >> 6) & 0x3f);
		utf8[4] = 0x80 + (unich & 0x3f);
		return 5;
	}
	else if (unich <= 0x7fffffff)
	{
		utf8[0] = 0xfc + (unich >> 30);
		utf8[1] = 0x80 + ((unich >> 24) & 0x3f);
		utf8[2] = 0x80 + ((unich >> 18) & 0x3f);
		utf8[3] = 0x80 + ((unich >> 12) & 0x3f);
		utf8[4] = 0x80 + ((unich >> 6) & 0x3f);
		utf8[5] = 0x80 + (unich & 0x3f);
		return 6;
	}
	else
	{
		// Invalid Unicode codepoint (high bit was set)
		// TODO: What do we do ?
		utf8[0] = '?';
		return 1;
	}
}
# pragma warning(pop)           // Restores the warning state.

/**
 * @brief Gets a length of UTF-8 character in bytes.
 * @param [in] ch The character for which to get the length.
 * @return Byte length of UTF-8 character, -1 if invalid.
 */
int Utf8len_fromLeadByte(unsigned char ch)
{
	if (ch < 0x80) return 1;
	if (ch < 0xC0) return -1;
	if (ch < 0xE0) return 2;
	if (ch < 0xF0) return 3;
	if (ch < 0xF8) return 4;
	if (ch < 0xFC) return 5;
	if (ch < 0xFE) return 6;
	return -1;
}

/**
 * @brief return #bytes required to represent Unicode codepoint as UTF-8
 */
int Utf8len_fromCodepoint(unsigned ch)
{
	if (ch <= 0x7F) return 1;
	if (ch <= 0x7FF) return 2;
	if (ch <= 0xFFFF) return 3;
	if (ch <= 0x1FFFFF) return 4;
	if (ch <= 0x3FFFFFF) return 5;
	if (ch <= 0x7FFFFFFF) return 6;
	return -1;
}

/**
 * @brief How many chars in this UTF-8 string ?
 *
 * @param size size argument as filemapping are not 0 terminated
 *
 * @bug Fails for files larger than 2gigs
 */
size_t stringlen_of_utf8(const char* text, size_t size)
{
	size_t len = 0;
	for (size_t i = 0; i < size;)
	{
		int chlen = Utf8len_fromLeadByte(text[i]);
		if (chlen < 1) chlen = 1;
		i += chlen;
		len ++;
	}
	return len;
}

/**
 * @brief Read UTF-8 character and return as Unicode
 */
unsigned GetUtf8Char(unsigned char * str)
{
	/* test short cases first, as probably much more common */
	if (!(*str & 0x80 && *str & 0x40))
	{
		return str[0];
	}
	if (!(*str & 0x20))
	{
		unsigned ch = ((str[0] & 0x1F) << 6)
				+ (str[1] & 0x3F);
		return ch;
	}
	if (!(*str & 0x10))
	{
		unsigned ch = ((str[0] & 0x0f) << 12)
				+ ((str[1] & 0x3F) << 6)
				+ (str[2] & 0x3F);
		return ch;
	}
	if (!(*str & 0x08))
	{
		unsigned ch = ((str[0] & 0x0F) << 18)
				+ ((str[1] & 0x3F) << 12)
				+ ((str[2] & 0x3F) << 6)
				+ (str[3] & 0x3F);
		return ch;
	}
	if (!(*str & 0x04))
	{
		unsigned ch = ((str[0] & 0x0F) << 24)
				+ ((str[1] & 0x3F) << 18)
				+ ((str[2] & 0x3F) << 12)
				+ ((str[3] & 0x3F) << 6)
				+ (str[4] & 0x3F);
		return ch;
	}
	else
	{
		unsigned ch = ((str[0] & 0x0F) << 30)
				+ ((str[1] & 0x3F) << 24)
				+ ((str[2] & 0x3F) << 18)
				+ ((str[3] & 0x3F) << 12)
				+ ((str[4] & 0x3F) << 6)
				+ (str[5] & 0x3F);
		return ch;
	}
}


# pragma warning(push)          // Saves the current warning state.
# pragma warning(disable:4244)  // Temporarily disables warning 4244: "conversion from 'int' to 'char', possible loss of data"
/**
 * @brief Write unicode codepoint u out as UTF-8 to lpd, and advance lpd
 *
 * Returns number of bytes written (or -1 for error, in which case it writes '?')
 */
int to_utf8_advance(unsigned u, unsigned char * &lpd)
{
	if (u < 0x80)
	{
		*lpd++ = u;
		return 1;
	}
	else if (u < 0x800)
	{
		*lpd++ = 0xC0 + (u >> 6);
		*lpd++ = 0x80 + (u & 0x3F);
		return 2;
	}
	else if (u < 0x10000)
	{
		*lpd++ = 0xE0 + (u >> 12);
		*lpd++ = 0x80 + ((u >> 6) & 0x3F);
		*lpd++ = 0x80 + (u & 0x3F);
		return 3;
	}
	else if (u < 0x200000)
	{
		*lpd++ = 0xF0 + (u >> 18);
		*lpd++ = 0x80 + ((u >> 12) & 0x3F);
		*lpd++ = 0x80 + ((u >> 6) & 0x3F);
		*lpd++ = 0x80 + (u & 0x3F);
		return 4;
	}
	else if (u < 0x4000000)
	{
		*lpd++ = 0xF8 + (u >> 24);
		*lpd++ = 0x80 + ((u >> 18) & 0x3F);
		*lpd++ = 0x80 + ((u >> 12) & 0x3F);
		*lpd++ = 0x80 + ((u >> 6) & 0x3F);
		*lpd++ = 0x80 + (u & 0x3F);
		return 5;
	}
	else if (u < 0x80000000)
	{
		*lpd++ = 0xFC + (u >> 30);
		*lpd++ = 0x80 + ((u >> 24) & 0x3F);
		*lpd++ = 0x80 + ((u >> 18) & 0x3F);
		*lpd++ = 0x80 + ((u >> 12) & 0x3F);
		*lpd++ = 0x80 + ((u >> 6) & 0x3F);
		*lpd++ = 0x80 + (u & 0x3F);
		return 6;
	}
	else
	{
		*lpd++ = '?';
		return 1;
	}
}
# pragma warning(pop)           // Restores the warning state.

/**
 * @brief convert character passed (Unicode codepoint) to a tchar_t (set lossy flag if imperfect conversion)
 */
void maketchar(String & ch, unsigned unich, bool & lossy)
{
	// NB: Windows always draws in CP_ACP, not CP_THREAD_ACP, so we must use CP_ACP as an internal codepage

	maketchar(ch, unich, lossy, CP_ACP);
}

/**
 * @brief convert character passed (Unicode codepoint) to a tchar_t (set lossy flag if imperfect conversion)
 */
void maketchar(String & ch, unsigned unich, bool & lossy, unsigned codepage)
{
#ifdef _UNICODE
	if (unich < 0x10000)
	{
		ch = static_cast<tchar_t>(unich);
		return;
	}
	else if (unich < 0x110000)
	{
		ch = static_cast<tchar_t>(((unich - 0x10000)/0x400 + 0xd800));
		ch += static_cast<tchar_t>(((unich % 0x400) + 0xdc00));
		return;
	}
	lossy = true;
	ch = '?';
	return;
#else
	if (unich < 0x80)
	{
		ch = (tchar_t)unich;
		return;
	}
	wchar_t wch = (wchar_t)unich;
	if (!lossy)
	{
		// So far it isn't lossy, so try for lossless conversion
		char outch[3] = {0};
		BOOL defaulted = FALSE;
		DWORD flags = WC_NO_BEST_FIT_CHARS;
		if (WideCharToMultiByte(codepage, flags, &wch, 1, outch, sizeof(outch), nullptr, &defaulted)
				&& !defaulted)
		{
			ch = outch;
			return;
		}
		lossy = true;
	}
	// already lossy, so make our best shot
	DWORD flags = WC_COMPOSITECHECK + WC_DISCARDNS + WC_SEPCHARS + WC_DEFAULtchar_t;
	tchar_t outbuff[16];
	int n = WideCharToMultiByte(codepage, flags, &wch, 1, outbuff, sizeof(outbuff) - 1, nullptr, nullptr);
	if (n > 0)
	{
		outbuff[n] = 0;
		ch = outbuff;
		return;
	}
	ch = _T("?");
#endif
}

/**
 * @brief convert 8-bit character input to Unicode codepoint and return it
 */
unsigned byteToUnicode(unsigned char ch)
{
	// NB: Windows always draws in CP_ACP, not CP_THREAD_ACP, so we must use CP_ACP as an internal codepage
	return byteToUnicode(ch, CP_ACP);
}

/**
 * @brief convert 8-bit character input to Unicode codepoint and return it
 */
unsigned byteToUnicode(unsigned char ch, unsigned codepage)
{

	if (ch < 0x80)
		return ch;

	DWORD flags = 0;
	wchar_t wbuff;
	int n = MultiByteToWideChar(codepage, flags, (const char*) & ch, 1, &wbuff, 1);
	if (n > 0)
		return wbuff;
	else
		return '?';
}

/**
 * @brief Return encoding used for tchar_t & String
 */
void getInternalEncoding(UNICODESET * unicoding, int * codepage)
{
#ifdef _UNICODE
	*unicoding = UCS2LE;
	*codepage = CP_UCS2LE;
#else
	// NB: Windows always draws in CP_ACP, not CP_THREAD_ACP, so we must use CP_ACP as an internal codepage
	*unicoding = NONE;
	*codepage = CP_ACP;
#endif
}

/**
 * @brief Write appropriate BOM (Unicode byte order marker)
 * returns #bytes written
 */
int writeBom(void* dest, UNICODESET unicoding)
{
	unsigned char * lpd = reinterpret_cast<unsigned char *>(dest);
	// write Unicode byte order marker (BOM)
	if (unicoding == UCS2LE)
	{
		*lpd++ = 0xFF;
		*lpd++ = 0xFE;
		return 2;
	}
	else if (unicoding == UCS2BE)
	{
		*lpd++ = 0xFE;
		*lpd++ = 0xFF;
		return 2;
	}
	else if (unicoding == UTF8)
	{
		*lpd++ = 0xEF;
		*lpd++ = 0xBB;
		*lpd++ = 0xBF;
		return 3;
	}
	return 0;
}

int getBomSize(UNICODESET unicoding)
{
	if (unicoding == UCS2LE)
		return 2;
	else if (unicoding == UCS2BE)
		return 2;
	else if (unicoding == UTF8)
		return 3;
	return 0;
}

/**
 * @brief Extract character from pointer, handling UCS-2 codesets
 *  This does not handle MBCS or UTF-8 codepages correctly!
 *  Client should not use this except for Unicode or SBCS codepages.
 */
unsigned get_unicode_char(unsigned char * ptr, UNICODESET codeset, int codepage)
{
	unsigned ch;
	switch (codeset)
	{
	case UCS2LE:
		ch = *((WORD *)ptr);
		break;
	case UCS2BE:
		ch = (ptr[0] << 8) + ptr[1];
		break;
	default:
		// TODO: How do we recognize valid codepage ?
		// if not, use byteToUnicode(*ptr)
		ch = byteToUnicode(*ptr, codepage);
	}
	return ch;
}

/**
 * @brief Convert series of bytes (8-bit chars) to tchar_ts.
 *
 * @param [out] str String returned.
 * @param [in] lpd Original byte array to convert.
 * @param [in] len Length of the original byte array.
 * @param [in] codepage Codepage used.
 * @param [out] lossy Was conversion lossy?
 * @return true if conversion succeeds, false otherwise.
 * @todo This doesn't inform the caller whether translation was lossy
 *  In fact, this doesn't even know. Probably going to have to make
 *  two passes, the first with MB_ERR_INVALID_CHARS. Ugh. :(
 */
bool maketstring(String & str, const char* lpd, size_t len, int codepage, bool * lossy)
{
	if (!len)
	{
		str.clear();
		return true;
	}

	int defcodepage = getDefaultCodepage();
	
	// 0 is a valid value (CP_ACP)!
	if (codepage == -1)
		codepage = defcodepage;

#ifdef UNICODE
	// Convert input to Unicode, using specified codepage
	// tchar_t is wchar_t, so convert into String (str)
	DWORD flags = MB_ERR_INVALID_CHARS;
	size_t wlen = len * 2 + 6;
	assert(wlen < INT_MAX);

	try
	{
		str.resize(wlen);
	}
	catch (std::bad_alloc&)
	{
		// Not enough memory - exit
		return false;
	}

	LPWSTR wbuff = &*str.begin();
	if (codepage == CP_ACP || IsValidCodePage(codepage))
	{
		int n = MultiByteToWideChar(codepage, flags, lpd, static_cast<int>(len), wbuff, static_cast<int>(wlen - 1));
		if (n)
		{
			/*
			NB: MultiByteToWideChar is documented as only zero-terminating
			if input was zero-terminated, but it appears that it can
			zero-terminate even if input wasn't.
			So we check if it zero-terminated and adjust count accordingly.
			*/
			//>2007-01-11 jtuc: We must preserve an embedded zero even if it is
			// the last input character. As we don't expect MultiByteToWideChar to
			// add a zero that does not originate from the input string, it is a
			// good idea to ASSERT that the assumption holds.
			if (wbuff[n-1] == 0 && lpd[len-1] != 0)
			{
				//assert(false);
				*lossy = true;
				--n;
			}
			try
			{
				str.resize(n);
			}
			catch (std::bad_alloc&)
			{
				// Not enough memory - exit
				return false;
			}
			return true;
		}
		else
		{
			if (GetLastError() == ERROR_INVALID_FLAGS)
			{
				n = MultiByteToWideChar(codepage, 0, lpd, static_cast<int>(len), wbuff, static_cast<int>(wlen-1));
				if (n)
				{
					/* NB: MultiByteToWideChar is documented as only zero-terminating 
					if input was zero-terminated, but it appears that it can 
					zero-terminate even if input wasn't.
					So we check if it zero-terminated and adjust count accordingly.
					*/
					if (wbuff[n-1] == 0 && lpd[len-1] != 0)
					{
						//assert(false);
						*lossy = true;
						--n;
					}
					try
					{
						str.resize(n);
					}
					catch (std::bad_alloc&)
					{
						// Not enough memory - exit
						return false;
					}
					return true;
				}
			}
			if (GetLastError() == ERROR_NO_UNICODE_TRANSLATION)
			{
				*lossy = true;
				flags = 0;
				// wlen & wbuff are still fine
				n = MultiByteToWideChar(codepage, flags, lpd, static_cast<int>(len), wbuff, static_cast<int>(wlen-1));
				if (n)
				{
					try
					{
						str.resize(n);
					}
					catch (std::bad_alloc&)
					{
						// Not enough memory - exit
						return false;
					}
					return true;
				}
			}
			str = _T("?");
			return true;
		}
	}
	else
	{
		IExconverter *pexconv = Exconverter::getInstance();
		if (pexconv != nullptr)
		{
			size_t n = wlen;
			if (pexconv->convertToUnicode(codepage, lpd, &len, wbuff, &n))
			{
				try
				{
					str.resize(n);
				}
				catch (std::bad_alloc&)
				{
					// Not enough memory - exit
					return false;
				}
				return true;
			}
			else
			{
				*lossy = true;
				str = _T("?");
			}
			return true;
		}
		else
		{
			*lossy = true;
			str = _T("?");
		}
		return true;
	}

#else
	int dstcodepage = IsValidCodePage(defcodepage) ? defcodepage : GetACP();

	if (EqualCodepages(codepage, dstcodepage))
	{
		// trivial case, they want the bytes in the file interpreted in our current codepage
		// Only caveat is that input (lpd) is not zero-terminated
		str = String(lpd, len);
		return true;
	}

	if (codepage == CP_ACP || IsValidCodePage(codepage))
	{
		str = CrossConvertToStringA(lpd, len, codepage, dstcodepage, lossy);
		if (*lossy)
			str = _T("?");
		return true;
	}
	else
	{
		IExconverter *pexconv = Exconverter::getInstance();
		if (pexconv != nullptr)
		{		
			size_t n = len * 6 + 6;
			try
			{
				str.resize(n);
			}
			catch (std::bad_alloc&)
			{
				// Not enough memory - exit
				return false;
			}
			char *buff = &*str.begin();
			pexconv->convert(codepage, dstcodepage, (const unsigned char *)lpd, &len, (unsigned char *)buff, &n);
			if (n)
			{
				try
				{
					str.resize(n);
				}
				catch (std::bad_alloc&)
				{
					// Not enough memory - exit
					return false;
				}
			}
			else
				str = _T("?");
		}
		else
			str = _T("?");		
		return true;
	}
#endif
}

/**
 * @brief (ANSI build only) Convert from one 8 bit codepage to another
 */
#ifndef UNICODE
String CrossConvertToStringA(const char* src, unsigned srclen, int cpin, int cpout, bool * lossy)
{
	int wlen = srclen * 2 + 6;
	int clen = wlen * 2 + 6;
	String str;
	str.resize(clen);
	char* cbuff = &*str.begin();
	int nbytes = CrossConvert(src, srclen, cbuff, clen, cpin, cpout, lossy);
	str.resize(nbytes);
	return str;
}
#endif

/**
 * @brief Convert from one 8-bit codepage to another
 *
 * destsize must be at least 2
 */
int CrossConvert(const char* src, unsigned srclen, char* dest, unsigned destsize, int cpin, int cpout, bool * lossy)
{
	assert(destsize > 1);

	// Convert input to Unicode, using specified codepage
	DWORD flags = 0;
	int wlen = srclen * 2 + 6;
	auto wbuff = std::make_unique<wchar_t[]>(wlen);
	int n;
	if (cpin == CP_UCS2LE)
	{
		if (srclen == -1)
			srclen = static_cast<unsigned>(wcslen((wchar_t *)src) * sizeof(wchar_t));
		memcpy(wbuff.get(), src, srclen);
		n = srclen / sizeof(wchar_t);
	}
	else if (cpin == CP_UCS2BE)
	{
		if (srclen == -1)
			srclen = static_cast<unsigned>(wcslen((wchar_t *)src) * sizeof(wchar_t));
		_swab((char *)src, (char *)wbuff.get(), srclen);
		n = srclen / sizeof(wchar_t);
	}
	else
	{
		n = MultiByteToWideChar(cpin, flags, (const char*)src, srclen, wbuff.get(), wlen - 1);
		if (!n)
		{
			int nsyserr = ::GetLastError();
			dest[0] = '?';
			return 1;
		}
	}
	/*
	NB: MultiByteToWideChar is documented as only zero-terminating
	if input was zero-terminated, but it appears that it can
	zero-terminate even if input wasn't.
	So we check if it zero-terminated and adjust count accordingly.
	*/
	if (wbuff[n-1] == 0)
		--n;
	wbuff[n] = 0; // zero-terminate string

	// Now convert to tchar_t (which means defcodepage)
	flags = WC_NO_BEST_FIT_CHARS; // TODO: Think about this
	BOOL defaulted = FALSE;
	BOOL * pdefaulted = &defaulted;
	if (cpout == CP_UTF8)
	{
		flags = 0;
		pdefaulted = nullptr;
	}
	if (cpout == CP_UCS2LE)
	{
		memcpy(dest, wbuff.get(), n * sizeof(wchar_t));
		n = n * sizeof(wchar_t);
		dest[n] = 0;
		dest[n + 1] = 0;
	}
	else if (cpout == CP_UCS2BE)
	{
		_swab((char *)wbuff.get(), dest, n * sizeof(wchar_t));
		n = n * sizeof(wchar_t);
		dest[n] = 0;
		dest[n + 1] = 0;
	}
	else
	{
		n = WideCharToMultiByte(cpout, flags, wbuff.get(), n, dest, destsize - 1, nullptr, pdefaulted);
		if (!n)
		{
			int nsyserr = ::GetLastError();
		}
		dest[n] = 0;
	}
	if (lossy)
		*lossy = !!defaulted;
	return n;
}

/**
 * @brief Buffer constructor.
 * The constructor creates buffer with given size.
 * @param [in] initialSize Buffer's size.
 */
buffer::buffer(size_t initialSize)
{
	size = 0;
	capacity = initialSize;
	ptr = (unsigned char *)calloc(capacity, 1);
}

/**
 * @brief Buffer destructor.
 * Frees the reserved buffer.
 */
buffer::~buffer()
{
	free(ptr);
}

/**
 * @brief Resize the buffer.
 * @param [in] newSize New size of the buffer.
 */
void buffer::resize(size_t newSize)
{
	if (capacity < newSize)
	{
		unsigned char *tmp = static_cast<unsigned char *>(realloc(ptr, newSize));
		if (tmp == nullptr)
			throw std::bad_alloc();
		capacity = newSize;
		ptr = tmp;
	}
}

unsigned char *convertTtoUTF8(buffer * buf, const tchar_t *src, int srcbytes/* = -1*/)
{
	bool bSucceeded;
#ifdef _UNICODE
	bSucceeded = convert(CP_UCS2LE, 
		(unsigned char *)src, (int)((srcbytes < 0) ? wcslen((const wchar_t *)src) * sizeof(wchar_t) : srcbytes),
		CP_UTF8, buf);
#else
	bSucceeded = convert(GetACP(),	
		(unsigned char *)src, (int)((srcbytes < 0) ? strlen((const char *)src) : srcbytes),
		CP_UTF8, buf);
#endif
	if (!bSucceeded)
		*((unsigned char *)buf->ptr) = 0;
	return buf->ptr;
}

unsigned char *convertTtoUTF8(const tchar_t *src, int srcbytes/* = -1*/)
{
	buffer buf(256);
	convertTtoUTF8(&buf, src, srcbytes);
	return (unsigned char *)_strdup((const char *)buf.ptr);
}

tchar_t *convertUTF8toT(buffer * buf, const char *src, int srcbytes/* = -1*/)
{
	bool bSucceeded;
#ifdef _UNICODE
	bSucceeded = convert(CP_UTF8,
		(const unsigned char *)src, (int)((srcbytes < 0) ? strlen((const char *)src) : srcbytes),
		CP_UCS2LE, buf);
#else
	bSucceeded = convert(CP_UTF8,
		(const unsigned char *)src, (int)((srcbytes < 0) ? strlen((const char *)src) : srcbytes),
		GetACP(), buf);
#endif
	if (!bSucceeded)
		*((tchar_t *)buf->ptr) = 0;
	return (tchar_t *)buf->ptr;
}

tchar_t *convertUTF8toT(const char *src, int srcbytes/* = -1*/)
{
	buffer buf(256);
	convertUTF8toT(&buf, src, srcbytes);
	return (tchar_t *)tc::tcsdup((const tchar_t*)buf.ptr);
}

void dealloc(void *ptr)
{
	free(ptr);
}

String toTString(const std::wstring& str)
{
#ifdef UNICODE
	return str;
#else
	return toThreadCP(str);
#endif
}

String toTString(const std::string& str)
{
#ifdef UNICODE
	std::wstring wstr;
	UnicodeConverter::toUTF16(str, wstr);
	return wstr;
#else
	const char *p = convertUTF8toT(str.c_str(), str.length());
	std::string astr = p;
	dealloc((void *)p);
	return astr;
#endif
}

String toTStringFromACP(const std::string& str)
{
#ifndef UNICODE
	return str;
#else
	String retval;
	bool lossy = false;
	maketstring(retval, str.c_str(), str.length(), GetACP(), &lossy);
	return retval;
#endif
}

void toUTF16(const String& tstr, std::wstring& wstr)
{
#ifdef UNICODE
	wstr = tstr;
#else
	UnicodeConverter::toUTF16(tstr, wstr);
#endif
}

std::string toUTF8(const String& tstr)
{
	std::string u8str;
	toUTF8(tstr, u8str);
	return u8str;
}

void toUTF8(const String& tstr, std::string& u8str)
{
#ifdef _UNICODE
	const size_t len = tstr.length();
	u8str.resize(len * 3);

	if (len == 0)
		return;

	char *p = &u8str[0];
	for (size_t i = 0; i < len; ++i)
	{
		unsigned uc = tstr[i];
		if (uc >= 0xd800 && uc < 0xdc00)
		{
			if (++i != len)
			{
				wchar_t uc2 = tstr[i];
				uc = ((uc & 0x3ff) << 10) + (uc2 & 0x3ff) + 0x10000;
			}
		}
		p += Ucs4_to_Utf8(uc, reinterpret_cast<unsigned char *>(p));
	}
	u8str.resize(p - &u8str[0]);
#else
	const char *p = (const char *)convertTtoUTF8(tstr.c_str(), tstr.length());
	u8str = p;
	dealloc((void *)p);
#endif
}

bool convert(int codepage1, const unsigned char * src, int srcbytes, int codepage2, buffer * dest)
{
	UNICODESET unicoding[2];
	int codepage[2] = {codepage1, codepage2};

	int i;
	for (i = 0; i < 2; i++)
	{
		switch (codepage[i])
		{
		case CP_UCS2LE:
			unicoding[i] = UCS2LE; break;
		case CP_UCS2BE:
			unicoding[i] = UCS2BE; break;
		case CP_UTF8:
			unicoding[i] = UTF8; break;
		default:
			unicoding[i] = NONE; break;
		}
	}

	return convert(unicoding[0], codepage1, src, srcbytes, unicoding[1], codepage2, dest);
}

/**
 * @brief Convert from one text encoding to another; return false if any lossing conversions
 */
bool convert(UNICODESET unicoding1, int codepage1, const unsigned char * src, size_t srcbytes, UNICODESET unicoding2, int codepage2, buffer * dest)
{
	if (unicoding1 == unicoding2 && (unicoding1 || EqualCodepages(codepage1, codepage2)))
	{
		// simple byte copy
		dest->resize(srcbytes + 2);
		CopyMemory(dest->ptr, src, srcbytes);
		dest->ptr[srcbytes] = 0;
		dest->ptr[srcbytes+1] = 0;
		dest->size = srcbytes;
		return true;
	}
	if ((unicoding1 == UCS2LE && unicoding2 == UCS2BE)
			|| (unicoding1 == UCS2BE && unicoding2 == UCS2LE))
	{
		// simple byte swap
		dest->resize(srcbytes + 2);
		for (size_t i = 0; i < srcbytes; i += 2)
		{
			// Byte-swap into destination
			uint16_t c = *(const uint16_t*)(src + i);
			*(uint16_t*)(dest->ptr + i) = ((c << 8) | (c >> 8));
		}
		dest->ptr[srcbytes] = 0;
		dest->ptr[srcbytes+1] = 0;
		dest->size = srcbytes;
		return true;
	}
	if (unicoding1 != UCS2LE && unicoding2 != UCS2LE)
	{
		// Break problem into two simpler pieces by converting through UCS-2LE
		buffer intermed(dest->capacity + 2);
		bool step1 = convert(unicoding1, codepage1, src, srcbytes, UCS2LE, 0, &intermed);
		bool step2 = convert(UCS2LE, 0, intermed.ptr, intermed.size, unicoding2, codepage2, dest);
		return step1 && step2;
	}
	if (unicoding1 == UCS2LE)
	{
		// From UCS-2LE to 8-bit (or UTF-8)

		// WideCharToMultiByte: lpDefaultChar & lpUsedDefaultChar must be `nullptr` when using UTF-8

		int destcp = (unicoding2 == UTF8 ? CP_UTF8 : codepage2);
		if (destcp == CP_ACP || IsValidCodePage(destcp))
		{
			DWORD flags = 0;
			int bytes = WideCharToMultiByte(destcp, flags, (LPCWSTR)src, static_cast<int>(srcbytes/2), 0, 0, nullptr, nullptr);
			dest->resize(bytes + 2);
			int losses = 0;
			bytes = WideCharToMultiByte(destcp, flags, (LPCWSTR)src, static_cast<int>(srcbytes/2), (char *)dest->ptr, static_cast<int>(dest->capacity), nullptr, nullptr);
			dest->ptr[bytes] = 0;
			dest->ptr[bytes+1] = 0;
			dest->size = bytes;
			return losses==0;
		}
		else
		{
			size_t srcsize = srcbytes / 2;
			size_t dstsize = srcbytes * 6; 
			dest->resize(dstsize + 2);
			IExconverter *pexconv = Exconverter::getInstance();
			if (pexconv != nullptr)
			{
				bool result = pexconv->convertFromUnicode(destcp, (LPWSTR)src, &srcsize, (char *)dest->ptr, &dstsize);
				dest->ptr[dstsize] = 0;
				dest->ptr[dstsize+1] = 0;
				dest->size = dstsize;
				return result;
			}
			else
				return false;
		}
	}
	else
	{
		// From 8-bit (or UTF-8) to UCS-2LE
		int srccp = (unicoding1 == UTF8 ? CP_UTF8 : codepage1);
		if (srccp == CP_ACP || IsValidCodePage(srccp))
		{
			DWORD flags = 0;
			int wchars = MultiByteToWideChar(srccp, flags, (LPCSTR)src, static_cast<int>(srcbytes), 0, 0);
			dest->resize((wchars + 1) *2);
			wchars = MultiByteToWideChar(srccp, flags, (LPCSTR)src, static_cast<int>(srcbytes), (LPWSTR)dest->ptr, static_cast<int>(dest->capacity/2));
			dest->ptr[wchars * 2] = 0;
			dest->ptr[wchars * 2 + 1] = 0;
			dest->size = wchars * 2;
			return true;
		}
		else
		{
			size_t srcsize = srcbytes;
			size_t dstsize = srcbytes; 
			dest->resize((srcbytes + 1) * sizeof(wchar_t));
			IExconverter *pexconv = Exconverter::getInstance();
			if (pexconv != nullptr)
			{
				bool result = pexconv->convertToUnicode(srccp, (LPCSTR)src, &srcsize, (LPWSTR)dest->ptr, &dstsize);
				dest->ptr[dstsize * sizeof(wchar_t)] = 0;
				dest->ptr[dstsize * sizeof(wchar_t) + 1] = 0;
				dest->size = dstsize * sizeof(wchar_t);
				return result;
			}
			else
				return false;
		}
	}
}

/**
 * @brief Convert from Unicode to Ansi using given codepage.
 * @param [in] from String to convert.
 * @param [in] codepage Codepage to use in conversion.
 * @param [out] to Ansi string.
 */
static void convert(const std::wstring& from, unsigned codepage, std::string& to)
{
	int len = WideCharToMultiByte(codepage, 0, from.c_str(), static_cast<int>(from.length()), 0, 0, 0, 0);
	if (len)
	{
		to.resize(len);
		WideCharToMultiByte(codepage, 0, from.c_str(), static_cast<int>(from.length()), &to[0], static_cast<int>(len), nullptr, nullptr);
	}
	else
	{
		to.clear();
	}
}

/**
 * @brief Convert from Unicode to Ansi using system codepage.
 * This function converts Unicode string to ansi string using system codepage.
 * This conversion function should be used when converting strings containing
 * paths. As paths are handled by the system and are not file content.
 * @param [in] str String to convert.
 * @return Ansi string.
 */
std::string toSystemCP(const std::string& str)
{
	return str;
}

std::string toSystemCP(const std::wstring& str)
{
	std::string to;
	convert(str, CP_ACP, to);
	return to;
}

/**
 * @brief Convert from Unicode to Ansi using thread codepage.
 * This function converts Unicode string to ansi string using thread codepage.
 * Thread codepage is practically the codepage WinMerge is using internally.
 * @param [in] str String to convert.
 * @return Ansi string.
 */
std::string toThreadCP(const std::string& str)
{
	return str;
}

std::string toThreadCP(const std::wstring& str)
{
	std::string to;
	convert(str, CP_THREAD_ACP, to);
	return to;
}

// Algorithm originally from:
// TortoiseMerge - a Diff/Patch program
// Copyright (C) 2007 - TortoiseSVN
/**
 * @brief Check for invalid UTF-8 bytes in buffer.
 * This function checks if there are invalid UTF-8 bytes in the given buffer.
 * If such bytes are found, caller knows this buffer is not valid UTF-8 file.
 * @param [in] pBuffer Pointer to begin of the buffer.
 * @param [in] size Size of the buffer in bytes.
 * @return true if invalid bytes found, false otherwise.
 */
bool CheckForInvalidUtf8(const char* pBuffer, size_t size)
{
	bool bUTF8 = false;
	for (unsigned char* pb = (unsigned char*)pBuffer, *end = pb + size; pb < end;)
	{
		unsigned c = *pb++;
		
		if (!(c & 0x80)) continue;
		
		if ((c >= 0xF5) || (c == 0xC0) || (c == 0xC1))
			return true;

		uint32_t v = 0x80808000; //1st 0-byte covers scenario if no any next "if" fired at all

		if ((c & 0xE0) == 0xC0)
		{
			if (pb == end)
				return true;
			*reinterpret_cast<unsigned char*>(&v) = *pb++;
		}
		else if ((c & 0xF0) == 0xE0)
		{
			if (pb > end - 2)
				return true;
			*reinterpret_cast<uint16_t*>(&v) = *reinterpret_cast<uint16_t*>(pb);
			pb += 2;
		}
		else if ((c & 0xF8) == 0xF0)
		{
			if (pb > end - 3)
				return true;
			static_assert(sizeof(char) == sizeof(uint8_t), "unexpected char-size");

			*reinterpret_cast<uint16_t*>(&v) = *reinterpret_cast<uint16_t*>(pb);
			reinterpret_cast<uint8_t*>(&v)[2] = pb[2];
			pb += 3;
		}

		if ((v & (0xC0C0C0C0)) != 0x80808080)
			return true;
		bUTF8 = true;
	}
	return !bUTF8;
}

/**
 * @brief Determine encoding from byte buffer.
 * @param [in] pBuffer Pointer to the begin of the buffer.
 * @param [in] size Size of the buffer.
 * @param [out] pBom Returns true if buffer had BOM bytes, false otherwise.
 * @return One of UNICODESET values as encoding.
 * EF BB BF UTF-8
 * FF FE UTF-16, little endian
 * FE FF UTF-16, big endian
 * FF FE 00 00 UTF-32, little endian
 * 00 00 FE FF UTF-32, big-endian
 */
UNICODESET DetermineEncoding(const unsigned char *pBuffer, uint64_t size, bool * pBom)
{
	UNICODESET unicoding = NONE;
	*pBom = false;

	if (size >= 2)
	{
		if (pBuffer[0] == 0xFF && pBuffer[1] == 0xFE)
		{
			unicoding = UCS2LE; //UNI little endian
			*pBom = true;
		}
		else if (pBuffer[0] == 0xFE && pBuffer[1] == 0xFF)
		{
			unicoding = UCS2BE; //UNI big endian
			*pBom = true;
		}
	}
	if (size >= 3)
	{
		if (pBuffer[0] == 0xEF && pBuffer[1] == 0xBB && pBuffer[2] == 0xBF)
		{
			unicoding = UTF8;
			*pBom = true;
		}
	}
	if (size >= 4)
	{
		if (pBuffer[0] == 0xFF && pBuffer[1] == 0xFE &&
				pBuffer[2] == 0x00 && pBuffer[3] == 0x00)
		{
			unicoding = UCS4LE; //UTF-32, little endian
			*pBom = true;
		}
		else if (pBuffer[0] == 0x00 && pBuffer[1] == 0x00 &&
				pBuffer[2] == 0xFE && pBuffer[3] == 0xFF)
		{
			unicoding = UCS4BE; //UTF-32, big endian
			*pBom = true;
		}
	}

	return unicoding;
}

/**
 * @brief Change any special codepage constants into real codepage numbers
 */
static int NormalizeCodepage(int cp)
{
	if (cp == CP_THREAD_ACP) // should only happen on Win2000+
	{
		tchar_t buff[32];
		if (GetLocaleInfo(GetThreadLocale(), LOCALE_IDEFAULTANSICODEPAGE, buff, sizeof(buff) / sizeof(buff[0])))
			cp = tc::ttol(buff);
		else
			// a valid codepage is better than no codepage
			cp = GetACP();
	}
	if (cp == CP_ACP) cp = GetACP();
	if (cp == CP_OEMCP) cp = GetOEMCP();
	return cp;
}

/**
 * @brief Compare two codepages for equality
 */
bool EqualCodepages(int cp1, int cp2)
{
	return (cp1 == cp2)
			|| (NormalizeCodepage(cp1) == NormalizeCodepage(cp2));
}

int getDefaultCodepage()
{
	return f_nDefaultCodepage;
}

void setDefaultCodepage(int cp)
{
	f_nDefaultCodepage = cp;
}

} // namespace ucr

</file>

<file path="Winmerge-Src/Src/Common/unicoder.h">
/**
 *  @file   unicoder.h
 *  @author Perry Rapp, Creator, 2003-2004
 *  @date   Created: 2003-10
 *  @date   Edited:  2006-02-20 (Perry Rapp)
 *
 *  @brief  Declaration of utility unicode conversion routines
 */
#pragma once

#include "UnicodeString.h"

namespace ucr
{

/**
 * @brief A simple buffer struct.
 */
struct buffer
{
	unsigned char * ptr; /**< Pointer to a buffer. */
	size_t capacity; /**< Buffer's size in bytes. */
	size_t size; /**< Size of the data in the buffer, <= capacity. */

	explicit buffer(size_t initialSize);
	~buffer();
	void resize(size_t newSize);
};

enum
{
	CP_UTF_8  = 65001,
	CP_UCS2LE = 1200,
	CP_UCS2BE = 1201,
#ifdef _UNICODE
	CP_TCHAR = CP_UCS2LE
#else
	CP_TCHAR = 0
#endif
};

/** @brief Known Unicode encodings. */
enum UNICODESET : char
{
	NONE = 0,  /**< No unicode. */
	UCS2LE,    /**< UCS-2 / UTF-16 little endian. */
	UCS2BE,    /**< UCS-2 / UTF-16 big endian. */
	UTF8,      /**< UTF-8. */
	UCS4LE,    /**< UTF-32 little endian */
	UCS4BE,    /**< UTF-32 big-endian */
};

int Ucs4_to_Utf8(unsigned unich, unsigned char * utf8);
int Utf8len_fromLeadByte(unsigned char ch);
int Utf8len_fromCodepoint(unsigned ch);
/**
 * @brief How many bytes will it take to write string as UTF-8 ?
 *
 * @param size size argument as filemapping are not 0 terminated
 *
 * @bug Fails for files larger than 2gigs
 */
template <typename C>
size_t Utf8len_of_string(const C* text, size_t size)
{
	size_t len = 0;
	for (size_t i = 0; i < size; ++i)
	{
		int chlen = Utf8len_fromCodepoint(text[i]);
		if (chlen < 1) chlen = 1;
		len += chlen;
	}
	return len;
}
size_t stringlen_of_utf8(const char* text, size_t size);
unsigned GetUtf8Char(unsigned char * str);
int to_utf8_advance(unsigned u, unsigned char * &lpd);
void maketchar(String & ch, unsigned unich, bool & lossy);
int writeBom(void* dest, UNICODESET unicoding);
int getBomSize(UNICODESET unicoding);
unsigned get_unicode_char(unsigned char * ptr, UNICODESET unicoding, int codepage=0);
bool maketstring(String & line, const char* lpd, size_t len, int codepage, bool * lossy);
void maketchar(String & ch, unsigned unich, bool & lossy, unsigned codepage);
unsigned byteToUnicode(unsigned char ch);
unsigned byteToUnicode(unsigned char ch, unsigned codepage);
void getInternalEncoding(UNICODESET * unicoding, int * codepage);

// generic function to do all conversions
bool convert(UNICODESET unicoding1, int codepage1, const unsigned char * src, size_t srcbytes, UNICODESET unicoding2, int codepage2, buffer * dest);
bool convert(int codepage1, const unsigned char * src, int srcbytes, int codepage2, buffer * dest);

unsigned char *convertTtoUTF8(buffer * dest, const tchar_t *src, int srcbytes = -1);
unsigned char *convertTtoUTF8(const tchar_t *src, int srcbytes = -1);
tchar_t *convertUTF8toT(buffer * dest, const char* src, int srcbytes = -1);
tchar_t *convertUTF8toT(const char* src, int srcbytes = -1);
void dealloc(void *ptr);

String toTString(const std::wstring& str);
String toTString(const std::string& str);
String toTStringFromACP(const std::string& str);
void toUTF16(const String& tstr, std::wstring& wstr);
inline std::wstring toUTF16(const String& tstr)
{
#ifdef UNICODE
	return tstr;
#else
	std::wstring wstr;
	toUTF16(tstr, wstr);
	return wstr;
#endif
}

void toUTF8(const String& tstr, std::string& u8str);
std::string toUTF8(const String& tstr);
std::string toSystemCP(const std::string& str);
std::string toSystemCP(const std::wstring& str);
std::string toThreadCP(const std::string& str);
std::string toThreadCP(const std::wstring& str);

int CrossConvert(const char* src, unsigned srclen, char* dest, unsigned destsize, int cpin, int cpout, bool * lossy);
#ifndef UNICODE
String CrossConvertToStringA(const char* src, unsigned srclen, int cpin, int cpout, bool * lossy);
#endif

bool CheckForInvalidUtf8(const char *pBuffer, size_t size);

UNICODESET DetermineEncoding(const unsigned char *pBuffer, uint64_t size, bool * pBom);

int getDefaultCodepage();
void setDefaultCodepage(int cp);

bool EqualCodepages(int cp1, int cp2);

} // namespace ucr
</file>

<file path="Winmerge-Src/Src/Common/UnicodeString.cpp">
// SPDX-License-Identifier: GPL-2.0-or-later
/** 
 * @file  UnicodeString.cpp
 *
 * @brief String utilities.
 */

// String formatting code originally from Paul Senzee:
// http://www.senzee5.com/2006/05/c-formatting-stdstring.html

#include "pch.h"
#include "UnicodeString.h"
#include <cstdarg>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cerrno>
#include <vector>

namespace strutils
{

/**
 * @brief Convert a string to lower case string.
 * @param [in] str String to convert to lower case.
 * @return Lower case string.
 */
String makelower(const String &str)
{
	String ret(str);
	String::size_type i = 0;
	for (i = 0; i < ret.length(); i++)
		ret[i] = tc::totlower(ret[i]);
	return ret;
}

/**
 * @brief Convert a string to upper case string.
 * @param [in] str String to convert to upper case.
 * @return upper case string.
 */
String makeupper(const String &str)
{
	String ret(str);
	String::size_type i = 0;
	for (i = 0; i < ret.length(); i++)
		ret[i] = tc::totupper(ret[i]);
	return ret;
}

String strip_hot_key(const String& str)
{
	String str2 = str;
	auto it = str2.find(_T("(&"));
	if (it != String::npos)
		str2.erase(it, it + 2);
	strutils::replace(str2, _T("&"), _T(""));
	return str2;
}

tchar_t from_charstr(const String& str)
{
	tchar_t ch = 0;
	String str2 = strutils::makelower(str);
	strutils::replace(str2, _T("-"), _T(""));
	if (str2 == _T("\\a") || str2 == _T("bel"))
		ch = '\a';
	else if (str2 == _T("\\b") || str2 == _T("bs"))
		ch = '\b';
	else if (str2 == _T("\\f") || str2 == _T("ff"))
		ch = '\f';
	else if (str2 == _T("\\n") || str2 == _T("lf"))
		ch = '\n';
	else if (str2 == _T("\\r") || str2 == _T("cr"))
		ch = '\r';
	else if (str2 == _T("\\t") || str2 == _T("tab"))
		ch = '\t';
	else if (str2 == _T("\\v") || str2 == _T("vt"))
		ch = '\v';
	else if (str2 == _T("\\'") || str2 == _T("sq") || str2 == _T("singlequote"))
		ch = '\'';
	else if (str2 == _T("\\\"") || str2 == _T("dq") || str2 == _T("doublequote"))
		ch = '"';
	else if (str2.find(_T("\\x"), 0) == 0 || str2.find(_T("0x"), 0) == 0)
	{
		tchar_t *pend = nullptr;
		ch = static_cast<tchar_t>(tc::tcstol(str2.substr(2).c_str(), &pend, 16));
	}
	else
		ch = str.c_str()[0];
	return ch;
}

String to_charstr(tchar_t ch)
{
	if (iscntrl(ch))
		return strutils::format(_T("\\x%02x"), ch);
	return String(1, ch);
}

String to_regex(const String& text)
{
	String ret;
	for (auto ch : text)
	{
		switch (ch)
		{
		case '\\': ret += _T("\\\\"); break;
		case '*':  ret += _T("\\*");  break;
		case '+':  ret += _T("\\+");  break;
		case '?':  ret += _T("\\?");  break;
		case '|':  ret += _T("\\|");  break;
		case '.':  ret += _T("\\.");  break;
		case '^':  ret += _T("\\^");  break;
		case '$':  ret += _T("\\$");  break;
		case '(':  ret += _T("\\(");  break;
		case ')':  ret += _T("\\)");  break;
		case '[':  ret += _T("\\[");  break;
		case ']':  ret += _T("\\]");  break;
		case '\t': ret += _T("\\t");  break;
		case '\n': ret += _T("\\n");  break;
		case '\r': ret += _T("\\r");  break;
		case '\a': ret += _T("\\a");  break;
		default:  ret += ch; break;
		}
	}
	return ret;
}

/**
 * @brief Replace a string inside a string with another string.
 * This function searches for a string inside another string an if found,
 * replaces it with another string. Function can replace several instances
 * of the string inside one string.
 * @param [in,out] target A string containing another string to replace.
 * @param [in] find A string to search and replace with another (@p replace).
 * @param [in] replace A string used to replace original (@p find).
 */
void replace(String &target, const String &find, const String &replace)
{
	const String::size_type find_len = find.length();
	const String::size_type replace_len = replace.length();
	String::size_type pos = 0;
	while ((pos = target.find(find, pos)) != String::npos)
	{
		target.replace(pos, find_len, replace);
		pos += replace_len;
	}
}

/**
 * @brief Replace the characters that matche characters specified in its arguments
 * @param [in,out] str - A string containing another string to replace.
 * @param [in] chars - characters to search for
 * @param [in] rep - String to replace
 */
void replace_chars(String& str, const tchar_t* chars, const tchar_t *rep)
{
	String::size_type pos = 0;
	size_t replen = tc::tcslen(rep);
	while ((pos = str.find_first_of(chars, pos)) != std::string::npos)
	{
		std::string::size_type posend = str.find_first_not_of(chars, pos);
		if (posend != String::npos)
			str.replace(pos, posend - pos, rep);
		else
			str.replace(pos, str.length() - pos, rep);
		pos += replen;
	}
}

/**
 * @brief Compare two strings ignoring the character casing.
 * @param [in] str1 First string to compare.
 * @param [in] str2 Second string to compare.
 * @return As strcmp(), 0 if strings match.
 */
int compare_nocase(const String &str1, const String &str2)
{
	return tc::tcsicoll(str1.c_str(), str2.c_str());
}

/**
 * @brief Compare two strings ignoring the character casing. 
 *        Digits in the strings are considered as numerical content rather than text.
 * @param [in] str1 First string to compare.
 * @param [in] str2 Second string to compare.
 * @return As strcmp(), 0 if strings match.
 */
int compare_logical(const String& str1, const String& str2)
{
	return tc::tcscmplogical(str1.c_str(), str2.c_str());
}

/**
 * @brief Trims whitespace chars from begin and end of the string.
 * @param [in] str the original string.
 * @return Trimmed string.
 */
String trim_ws(const String & str)
{
	if (str.empty())
		return str;

	String result(str);
	String::iterator it = result.begin();
	while (it != result.end() && tc::istspace(*it))
		++it;
	
	if (it != result.begin())
		result.erase(result.begin(), it);

	if (result.empty())
		return result;

	it = result.end() - 1;
	while (it != result.begin() && tc::istspace(*it))
		--it;

	if (it != result.end() - 1)
		result.erase(it + 1, result.end());
	return result;
}

/**
 * @brief Trims whitespace chars from begin of the string.
 * @param [in] str the original string.
 * @return Trimmed string.
 */
String trim_ws_begin(const String & str)
{
	if (str.empty())
		return str;

	String result(str);
	String::iterator it = result.begin();
	while (it != result.end() && tc::istspace(*it))
		++it;
	
	if (it != result.begin())
		result.erase(result.begin(), it);
	return result;
}

/**
 * @brief Trims whitespace chars from end of the string.
 * @param [in] str the original string.
 * @return Trimmed string.
 */
String trim_ws_end(const String & str)
{
	if (str.empty())
		return str;

	String result(str);
	String::reverse_iterator it = result.rbegin();
	while (it != result.rend() && tc::istspace(*it))
		++it;

	if (it != result.rbegin())
		result.erase(it.base(), result.end());
	return result;
}

String format_arg_list(const tchar_t *fmt, va_list args)
{
	if (fmt == nullptr)
		return _T("");
	int result = -1;
	int length = 256;
	std::vector<tchar_t> buffer(length, 0);
	while (result == -1)
	{
		result = tc::vsntprintf_s(&buffer[0], length, _TRUNCATE, fmt, args);
		length *= 2;
		buffer.resize(length, 0);
	}
	String s(&buffer[0]);
	return s;
}

/**
 * @brief printf()-style formatting for STL string.
 * Use this function to format String:s in printf() style.
 */
String format_varg(const tchar_t *fmt, ...)
{
	va_list args;
	va_start(args, fmt);
	String s = format_arg_list(fmt, args);
	va_end(args);
	return s;
}

String format_strings(const String& fmt, const String *args[], size_t nargs)
{
	String str;
	str.reserve(fmt.length() * 2);
	String::const_iterator it;
	for (it = fmt.begin(); it != fmt.end(); ++it)
	{
		if (*it == '%')
		{
			++it;
			if (it == fmt.end())
				break;
			int n = *it - '0';
			if (n > 0 && static_cast<unsigned int>(n) <= nargs)
				str += *args[n - 1];
			else
				str += *it;
		}
		else
		{
			str += *it;
		}
	}
	return str;
}

String format_string1(const String& fmt, const String& arg1)
{
	const String* args[] = {&arg1};
	return format_strings(fmt, args, 1);
}

String format_string2(const String& fmt, const String& arg1, const String& arg2)
{
	const String* args[] = {&arg1, &arg2};
	return format_strings(fmt, args, 2);
}

/**
 * @brief Output the converted string according to the printf()-style formatting.
 * @param [in] fmt printf()-style formatting.
 * @param [in] arg1 Value of "%1" of fmt.
 * @param [in] arg2 Value of "%2" of fmt.
 * @param [in] arg3 Value of "%3" of fmt.
 * @return Formatted output string.
 */
String format_string3(const String& fmt, const String& arg1, const String& arg2, const String& arg3)
{
	const String* args[] = { &arg1, &arg2, &arg3 };
	return format_strings(fmt, args, 3);
}

}
</file>

<file path="Winmerge-Src/Src/Common/UnicodeString.h">
// SPDX-License-Identifier: GPL-2.0-or-later
/** 
 * @file UnicodeString.h
 *
 * @brief Unicode string based on std::wstring.
 *
 */
#pragma once

#include <string>
#include <string_view>
#include "../Externals/crystaledit/editlib/utils/ctchar.h"

using namespace std::string_literals;

typedef std::basic_string<tchar_t> String;
typedef std::basic_string_view<tchar_t> StringView;

namespace strutils
{
String makelower(const String &str);
String makeupper(const String &str);

String strip_hot_key(const String& str);

tchar_t from_charstr(const String& str);
String to_charstr(tchar_t ch);
String to_regex(const String& text);

void replace(String &target, const String &find, const String &replace);
void replace_chars(String& str, const tchar_t* chars, const tchar_t* rep);

// Comparing
int compare_nocase(const String &str1, const String &str2);
int compare_logical(const String& str1, const String& str2);

// Trimming
String trim_ws(const String & str);
String trim_ws_begin(const String & str);
String trim_ws_end(const String & str);

// Formatting
String format_arg_list(const tchar_t *fmt, va_list args);
String format_varg(const tchar_t *fmt, ...);
namespace detail
{
	template <typename T> inline T arg(T value) { return value; }
	template <typename T> inline T const * arg(std::basic_string<T> const & value) { return value.c_str(); }
}
template <typename ... Args>
inline String format(tchar_t const * const fmt, Args const & ... args)
{
	return format_varg(fmt, detail::arg(args) ...);
}
template <typename ... Args>
inline String format(String const & fmt, Args const & ... args)
{
	return format_varg(fmt.c_str(), detail::arg(args) ...);
}
String format_strings(const String& fmt, const String *args[], size_t nargs);
String format_string1(const String& fmt, const String& arg1);
String format_string2(const String& fmt, const String& arg1, const String& arg2);
String format_string3(const String& fmt, const String& arg1, const String& arg2, const String& arg3);

template <class InputIterator>
String join(const InputIterator& begin, const InputIterator& end, const String& delim)
{
	size_t sum = 0, delim_len = delim.length();
	for (InputIterator it = begin; it != end; ++it)
	{
		if (sum != 0) sum += delim_len;
		sum += (*it).length();
	}
	String result;
	result.reserve(sum);
	for (InputIterator it = begin; it != end; ++it)
	{
		if (it != begin) result.append(delim);
		result += *it;
	}
	return result;
}

template <class Formatter, class InputIterator>
String join(const InputIterator& begin, const InputIterator& end, const String& delim, Formatter func)
{
	String result;
	for (InputIterator it = begin; it != end; ++it)
	{
		if (it != begin) result.append(delim);
		result += func(*it);
	}
	return result;
}

template<class T = std::vector<StringView>>
T split(StringView str, tchar_t delim)
{
	T result;
	size_t start = 0;
	for (size_t i = 0; i < str.size(); i++)
	{
		if (str[i] == delim)
		{
			result.emplace_back(str.data() + start, i - start);
			start = i + 1;
		}
	}
	result.emplace_back(str.data() + start, str.size() - start);
	return result;
}


inline String to_str(int val) { return strutils::format(_T("%d"), val); }
inline String to_str(unsigned val) { return strutils::format(_T("%u"), val); }
inline String to_str(long val) { return strutils::format(_T("%ld"), val); }
inline String to_str(unsigned long val) { return strutils::format(_T("%lu"), val); }
inline String to_str(long long val) { return strutils::format(_T("%I64d"), val); }
inline String to_str(unsigned long long val) { return strutils::format(_T("%I64u"), val); }
inline String to_str(float val) { return strutils::format(_T("%f"), val); }
inline String to_str(double val) { return strutils::format(_T("%f"), val); }
inline String to_str(const StringView& val) { return { val.data(), val.size() }; }

}
</file>

<file path="Winmerge-Src/Src/Common/UniFile.cpp">
/**
 *  @file   UniFile.cpp
 *  @author Perry Rapp, Creator, 2003-2006
 *  @author Kimmo Varis, 2004-2006
 *  @date   Created: 2003-10
 *  @date   Edited:  2006-12-07 (Kimmo Varis)
 *
 *  @brief Implementation of Unicode enabled file classes.
 *  Classes include memory-mapped reader class and Stdio replacement class.
 */

/* The MIT License
Copyright (c) 2003 Perry Rapp
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

#include "pch.h"
#include "UniFile.h"
#include <cstdio>
#include <cassert>
#include <memory>
#include <Poco/SharedMemory.h>
#include <Poco/Exception.h>
#include "UnicodeString.h"
#include "unicoder.h"
#include "paths.h" // paths::GetLongbPath()
#include "TFile.h"
#include "cio.h"
#include <windows.h>

using Poco::SharedMemory;
using Poco::Exception;

static void Append(String &strBuffer, const tchar_t *pchTail, size_t cchTail,
		size_t cchBufferMin = 1024);

/**
 * @brief The constructor.
 */
UniFile::UniError::UniError()
{
	ClearError();
}

/////////////
// UniLocalFile
/////////////

/** @brief Create disconnected UniLocalFile, but with name */
UniLocalFile::UniLocalFile()
{
	Clear();
}

/** @brief Reset all variables to empty */
void UniLocalFile::Clear()
{
	m_statusFetched = 0;
	m_lineno = -1;
	m_filesize = 0;
	m_filepath.clear();
	m_filename.clear();
	m_charsize = 1;
	m_codepage = ucr::getDefaultCodepage();
	m_txtstats.clear();
	m_unicoding = ucr::NONE;
	m_bom = false;
	m_bUnicodingChecked = false;
	m_bUnicode = false;
}

/**
 * @brief Get file status into member variables
 *
 * Reads file's status (size and full path).
 * @return true on success, false on failure.
 * @note Function sets filesize member to zero, and status as read
 * also when failing. That is needed so caller doesn't need to waste
 * time checking if file already exists (and ignores return value).
 */
bool UniLocalFile::DoGetFileStatus()
{
	m_statusFetched = -1;
	m_lastError.ClearError();

	m_filepath = paths::GetLongPath(m_filepath);

	try
	{
		m_filesize = TFile(m_filepath).getSize();
		if (m_filesize == 0)
		{
			// if m_filesize equals zero, the file size is really zero or the file is a symbolic link.
			// use GetCompressedFileSize() to get the file size of the symbolic link target whether the file is symbolic link or not.
			// if the file is not symbolic link, GetCompressedFileSize() will return zero.
			// NOTE: GetCompressedFileSize() returns error for pre-W2K windows versions
			DWORD dwFileSizeLow, dwFileSizeHigh;
			
			dwFileSizeLow = GetCompressedFileSize(TFile(m_filepath).wpath().c_str(), &dwFileSizeHigh);
			if (GetLastError() == 0)
				m_filesize = ((int64_t)dwFileSizeHigh << 32) + dwFileSizeLow;
		}
		m_statusFetched = 1;

		return true;
	}
	catch (Exception& e)
	{
		m_filesize = 0;
		m_statusFetched = 1; // Yep, done for this file still
		LastErrorCustom(ucr::toTString(e.displayText()));
		return false;
	}
}

/**
 * @brief Checks if the file is an unicode file.
 * This function Checks if the file is recognized unicode file. This detection
 * includes reading possible BOM bytes and trying to detect UTF-8 files
 * without BOM bytes.
 * @return true if file is an unicode file, false otherwise.
 */
bool UniLocalFile::IsUnicode()
{
	if (!m_bUnicodingChecked)
		m_bUnicode = ReadBom();
	return m_bUnicode;
}

/** @brief Record a custom error */
void UniLocalFile::LastErrorCustom(const String& desc)
{
	m_lastError.ClearError();

	m_lastError.desc = desc;
}

/////////////
// UniMemFile
/////////////

UniMemFile::UniMemFile()
		: m_hMapping(nullptr)
		, m_base(nullptr)
		, m_data(nullptr)
		, m_current(nullptr)
{
}

void UniMemFile::Close()
{
	Clear();
	m_base = nullptr;
	m_data = nullptr;
	m_current = nullptr;
	if (m_hMapping != nullptr)
	{
		delete m_hMapping;
		m_hMapping = nullptr;
	}
}

/** @brief Get file status into member variables */
bool UniMemFile::GetFileStatus()
{
	if (!IsOpen()) return false;
	return DoGetFileStatus();
}

/** @brief Open file for generic read-only access */
bool UniMemFile::OpenReadOnly(const String& filename)
{
	return Open(filename, AM_READ);
}

/** @brief Open file for generic read-write access */
bool UniMemFile::Open(const String& filename)
{
	return Open(filename, AM_WRITE);
}

/** @brief Open file with specified arguments */
bool UniMemFile::Open(const String& filename, AccessMode mode)
{
	// We use an internal workhorse to make it easy to close on any error
	if (!DoOpen(filename, mode))
	{
		Close();
		return false;
	}
	return true;
}

/** @brief Internal implementation of Open */
bool UniMemFile::DoOpen(const String& filename, AccessMode mode)
{
	Close();

	m_filename = filename;
	m_filepath = m_filename; // TODO: Make canonical ?

	try
	{
		TFile file(filename);
		try
		{
			m_hMapping = new SharedMemory(file, static_cast<SharedMemory::AccessMode>(mode));
		}
		catch (Exception&)
		{
			if (file.getSize() == 0)
			{
				m_lineno = 0;
				return true;
			}
			throw;
		}
	}
	catch (Exception& e)
	{
		LastErrorCustom(ucr::toTString(e.displayText()));
		m_hMapping = nullptr;
		return false;
	}

	m_lineno = 0; // GetFileStatus requires file be "open", which means nonnegative line number
	if (!GetFileStatus())
		return false;
	m_lineno = -1;

#ifndef _WIN64
	unsigned sizehi = (unsigned)(m_filesize >> 32);
	unsigned sizelo = (unsigned)(m_filesize & 0xFFFFFFFF);

	if (sizehi || sizelo > 0x7FFFFFFF)
	{
		LastErrorCustom(_T("UniMemFile cannot handle files over 2 gigabytes"));
		return false;
	}
#endif

	if (m_filesize == 0)
	{
		// Allow opening empty file, but memory mapping doesn't work on such
		// m_base and m_current are 0 from the Close call above
		// so ReadString will correctly return empty EOF immediately
		m_lineno = 0;
		return true;
	}

	m_base = reinterpret_cast<unsigned char *>(m_hMapping->begin());
	m_data = m_base;
	m_current = m_base;
	m_lineno = 0;

	return true;
}

/**
 * @brief Check for Unicode BOM (byte order mark) at start of file
 *
 * @note This code only checks for UCS-2LE, UCS-2BE, and UTF-8 BOMs (no UCS-4).
 */
bool UniMemFile::ReadBom()
{
	if (!IsOpen())
		return false;

	unsigned char * lpByte = m_base;
	m_charsize = 1;
	bool unicode = true;
	bool bom = false;

	m_unicoding = ucr::DetermineEncoding(lpByte, m_filesize, &bom);
	switch (m_unicoding)
	{
	case ucr::UCS2LE:
		m_codepage = ucr::CP_UCS2LE;
		m_charsize = 2;
		m_data = lpByte + 2;
		break;
	case ucr::UCS2BE:
		m_codepage = ucr::CP_UCS2BE;
		m_charsize = 2;
		m_data = lpByte + 2;
		break;
	case ucr::UTF8:
		m_codepage = ucr::CP_UTF_8;
		m_data = lpByte + (bom ? 3 : 0);
		break;
	default:
		m_data = m_base;
		unicode = false;
		break;
	}

	m_bom = bom;
	m_current = m_data;
	m_bUnicodingChecked = true;
	return unicode;
}

/**
 * @brief Read one (DOS or UNIX or Mac) line. Do not include eol chars.
 * @param [out] line Line read.
 * @param [out] lossy `true` if there were lossy encoding.
 * @return `true` if there is more lines to read, `false` when last line is read.
 */
bool UniMemFile::ReadString(String & line, bool * lossy)
{
	String eol;
	return ReadString(line, eol, lossy);
}

bool UniMemFile::ReadStringAll(String& text)
{
	text.clear();
	text.reserve(static_cast<size_t>(m_filesize));

	String tmp, eol;
	bool lossy = false, lossytmp = false, last;
	do
	{
		last = ReadString(tmp, eol, &lossytmp);
		text += tmp;
		text += eol;
		if (lossytmp)
			lossy = true;
	} while (last);
	return lossy;
}

/**
 * @brief Append characters to string.
 * This function appends characters to the string. The storage for the string
 * is grown exponentially to avoid unnecessary allocations and copying.
 * @param [in, out] strBuffer A string to which new characters are appended.
 * @param [in] ccHead Index in the string where new chars are appended.
 * @param [in] pchTail Characters to append.
 * @param [in] cchTail Amount of characters to append.
 * @param [in] cchBufferMin Minimum size for the buffer.
 * @return New length of the string.
 */
static void Append(String &strBuffer, const tchar_t *pchTail,
		size_t cchTail, size_t cchBufferMin)
{
	size_t cchBuffer = strBuffer.capacity();
	size_t cchHead = strBuffer.length();
	size_t cchLength = cchHead + cchTail;
	while (cchBuffer < cchLength)
	{
		assert((cchBufferMin & cchBufferMin - 1) == 0); // must be a power of 2
		cchBuffer &= ~(cchBufferMin - 1); // truncate to a multiple of cchBufferMin
		cchBuffer += cchBuffer;
		if (cchBuffer < cchBufferMin)
			cchBuffer = cchBufferMin;
	}
	strBuffer.reserve(cchBuffer);
	strBuffer.append(pchTail, cchTail);
}

/**
 * @brief Record occurrence of binary zero to stats
 */
static void RecordZero(UniFile::txtstats & txstats, size_t offset)
{
	++txstats.nzeros;
}

/**
 * @brief Read one (DOS or UNIX or Mac) line.
 * @param [out] line Line read.
 * @param [out] eol EOL bytes read (if any).
 * @param [out] lossy `true` if there were lossy encoding.
 * @return true if there is more lines to read, false when last line is read.
 */
bool UniMemFile::ReadString(String & line, String & eol, bool * lossy)
{
	line.clear();
	eol.clear();
	const tchar_t * pchLine = (const tchar_t *)m_current;
	
	// shortcut methods in case file is in the same encoding as our Strings

#ifdef _UNICODE
	if (m_unicoding == ucr::UCS2LE)
	{
		int cchLine = 0;
		// If there aren't any wchars left in the file, return `false` to indicate EOF
		if (m_current - m_base + 1 >= m_filesize)
			return false;
		// Loop through wchars, watching for eol chars or zero
		while (m_current - m_base + 1 < m_filesize)
		{
			wchar_t wch = *(wchar_t *)m_current;
			size_t wch_offset = (m_current - m_base);
			m_current += 2;
			if (wch == '\n' || wch == '\r')
			{
				eol += wch;
				if (wch == '\r')
				{
					if (m_current - m_base + 1 < m_filesize && *(wchar_t *)m_current == '\n')
					{
						eol += '\n';
						m_current += 2;
						++m_txtstats.ncrlfs;
					}
					else
					{
						++m_txtstats.ncrs;
					}
				}
				else
				{
					++m_txtstats.nlfs;
				}
				++m_lineno;
				line.assign(pchLine, cchLine);
				return true;
			}
			if (!wch)
			{
				RecordZero(m_txtstats, wch_offset);
			}
			++cchLine;
		}
		line.assign(pchLine, cchLine);
		return true;
	}
#else
	if (m_unicoding == ucr::NONE && ucr::EqualCodepages(m_codepage, GetACP()))
	{
		int cchLine = 0;
		// If there aren't any bytes left in the file, return `false` to indicate EOF
		if (m_current - m_base >= m_filesize)
			return false;
		// Loop through chars, watching for eol chars or zero
		while (m_current - m_base < m_filesize)
		{
			char ch = *m_current;
			size_t ch_offset = (m_current - m_base);
			++m_current;
			if (ch == '\n' || ch == '\r')
			{
				eol += ch;
				if (ch == '\r')
				{
					if (m_current - m_base < m_filesize && *m_current == '\n')
					{
						eol += '\n';
						++m_current;
						++m_txtstats.ncrlfs;
					}
					else
					{
						++m_txtstats.ncrs;
					}
				}
				else
				{
					++m_txtstats.nlfs;
				}
				++m_lineno;
				line.assign(pchLine, cchLine);
				return true;
			}
			if (!ch)
			{
				RecordZero(m_txtstats, ch_offset);
			}
			++cchLine;
		}
		line.assign(pchLine, cchLine);
		return true;
	}
#endif

	if (m_current - m_base + (m_charsize - 1) >= m_filesize)
		return false;

	// Handle 8-bit strings in line chunks because of multibyte codings (eg, 936)
	if (m_unicoding == ucr::NONE)
	{
		bool eof = true;
		unsigned char *eolptr = nullptr;
		for (eolptr = m_current; (eolptr - m_base + (m_charsize - 1) < m_filesize); ++eolptr)
		{
			if (*eolptr == '\n' || *eolptr == '\r')
			{
				eof = false;
				break;
			}
			
			if (*eolptr == '\x00')
			{
				size_t offset = (eolptr - m_base);
				RecordZero(m_txtstats, offset);
			}
		}
		bool success = ucr::maketstring(line, (const char *)m_current, eolptr-m_current, m_codepage, lossy);
		if (!success)
		{
			return false;
		}
		if (lossy && *lossy)
			++m_txtstats.nlosses;
		if (!eof)
		{
			eol += (tchar_t) * eolptr;
			++m_lineno;
			if (*eolptr == '\r')
			{
				if (eolptr - m_base + m_charsize + (m_charsize - 1) < m_filesize && eolptr[1] == '\n')
				{
					eol += '\n';
					++m_txtstats.ncrlfs;
				}
				else
					++m_txtstats.ncrs;
			}
			else
				++m_txtstats.nlfs;
		}
		m_current = eolptr + eol.length();
		// TODO: What do we do if save was lossy ?
		return !eof;
	}

	while (m_current - m_base + (m_charsize - 1) < m_filesize)
	{
		unsigned ch = 0;
		int  utf8len = 0;
		bool doneline = false;

		if (m_unicoding == ucr::UTF8)
		{
			// check for end in middle of UTF-8 character
			utf8len = ucr::Utf8len_fromLeadByte(*m_current);
			if (m_current - m_base + utf8len > m_filesize)
			{
				ch = '?';
				m_current = m_base + m_filesize;
				doneline = true;
			}
			// Handle bad UTF-8 or UTF-8 outside of UCS-2
			// (Convert bad bytes individually to '?'
			else if (utf8len < 1 || utf8len > 4)
			{
				ch = '?';
				utf8len = 1;
			}
			else
			{
				ch = ucr::GetUtf8Char(m_current);
			}
		}
		else
		{
			ch = ucr::get_unicode_char(m_current, (ucr::UNICODESET)m_unicoding, m_codepage);
		}
		// convert from Unicode codepoint to tchar_t string
		// could be multicharacter if decomposition took place, for example
		bool lossy1 = false; // try to avoid lossy conversion
		String sch;
		ucr::maketchar(sch, ch, lossy1);
		if (lossy1)
			++m_txtstats.nlosses;
		if (sch.length() >= 1)
			ch = sch[0];
		else
			ch = 0;


		if (ch == '\r')
		{
			eol = _T("\r");
			doneline = true;
			bool crlf = false;
			// check for crlf pair
			if (m_current - m_base + 2 * m_charsize - 1 < m_filesize)
			{
				// For UTF-8, this ch1 will be wrong if character is non-ASCII
				// but we only check it against \n here, so it doesn't matter
				unsigned ch1 = ucr::get_unicode_char(m_current + m_charsize, (ucr::UNICODESET)m_unicoding);
				if (ch1 == '\n')
				{
					crlf = true;
				}
			}
			if (crlf)
			{
				eol = _T("\r\n");
				++m_txtstats.ncrlfs;
				// advance an extra character to skip the following lf
				m_current += m_charsize;
			}
			else
			{
				++m_txtstats.ncrs;
			}
		}
		else if (ch == '\n')
		{
			eol = _T("\n");
			doneline = true;
			++m_txtstats.nlfs;
		}
		else if (!ch)
		{
			size_t offset = (m_current - m_base);
			RecordZero(m_txtstats, offset);
		}
		// always advance to next character
		if (m_unicoding == ucr::UTF8)
		{
			m_current += utf8len;
		}
		else
		{
			m_current += m_charsize;
		}
		if (doneline)
		{
			if (!eol.empty())
				++m_lineno;
			return true;
		}
		Append(line, sch.c_str(), sch.length());
	}
	return true;
}

/**
 * @brief Write one line (doing any needed conversions)
 */
bool UniMemFile::WriteString(const String & line)
{
	assert(false); // unimplemented -- currently cannot write to a UniMemFile!
	return false;
}

/////////////
// UniStdioFile
/////////////

UniStdioFile::UniStdioFile()
		: m_fp(nullptr)
		, m_data(0)
		, m_ucrbuff(128)
{
}

UniStdioFile::~UniStdioFile()
{
	Close();
}

void UniStdioFile::Close()
{
	if (IsOpen())
	{
		fclose(m_fp);
		m_fp = nullptr;
	}
	m_statusFetched = 0;
	m_filesize = 0;
	// preserve m_filepath
	// preserve m_filename
	m_data = 0;
	m_lineno = -1;
	// preserve m_unicoding
	// preserve m_charsize
	// preserve m_codepage
	m_txtstats.clear();
}

/** @brief Get file status into member variables */
bool UniStdioFile::GetFileStatus()
{
	if (IsOpen()) return false; // unfortunately we'll hit our lock

	return DoGetFileStatus();
}

bool UniStdioFile::OpenReadOnly(const String& filename)
{
	return Open(filename, _T("rb"));
}
bool UniStdioFile::OpenCreate(const String& filename)
{
	return Open(filename, _T("w+b"));
}
bool UniStdioFile::OpenCreateUtf8(const String& filename)
{
	if (!OpenCreate(filename))
		return false;
	SetUnicoding(ucr::UTF8);
	return true;

}
bool UniStdioFile::Open(const String& filename, const String& mode)
{
	if (!DoOpen(filename, mode))
	{
		Close();
		return false;
	}
	return true;
}

bool UniStdioFile::DoOpen(const String& filename, const String& mode)
{
	Close();

	m_filepath = filename;
	m_filename = filename; // TODO: Make canonical ?

	// Fails if file doesn't exist (when we are creating new file)
	// But we don't care since size is set to 0 anyway.
	GetFileStatus();

	if (cio::tfopen_s(&m_fp, m_filepath, mode.c_str()) != 0)
		return false;

#ifndef _WIN64
	unsigned sizehi = (unsigned)(m_filesize >> 32);

	if (sizehi)
	{
		// TODO: We could do this in MSC_VER 7+ I think

		LastErrorCustom(_T("UniStdioFile cannot handle files over 4 gigabytes"));
		return false;
	}
#endif

	m_lineno = 0;
	return true;
}

bool UniStdioFile::SetVBuf(int mode, size_t size)
{
	if (!IsOpen())
		return false;
	return setvbuf(m_fp, NULL, mode, size) == 0;
}

/** @brief Record a custom error */
void UniStdioFile::LastErrorCustom(const String& desc)
{
	m_lastError.ClearError();

	m_lastError.desc = desc;
}

/**
 * @brief Check for Unicode BOM (byte order mark) at start of file
 *
 * @note This code only checks for UCS-2LE, UCS-2BE, and UTF-8 BOMs (no UCS-4).
 */
bool UniStdioFile::ReadBom()
{
	if (!IsOpen())
		return false;

	fseek(m_fp, 0, SEEK_SET);

	// Read 8 KB at max for get enough data determining UTF-8 without BOM.
	const size_t max_size = 8 * 1024;
	unsigned char buff[max_size];

	size_t bytes = fread(buff, 1, max_size, m_fp);
	m_charsize = 1;
	bool unicode = true;
	bool bom = false;

	m_unicoding = ucr::DetermineEncoding(buff, bytes, &bom);
	switch (m_unicoding)
	{
	case ucr::UCS2LE:
		m_codepage = ucr::CP_UCS2LE;
		m_charsize = 2;
		m_data = 2;
		break;
	case ucr::UCS2BE:
		m_codepage = ucr::CP_UCS2BE;
		m_charsize = 2;
		m_data = 2;
		break;
	case ucr::UTF8:
		m_codepage = ucr::CP_UTF_8;
		m_data = bom ? 3 : 0;
		break;
	default:
		m_data = 0;
		unicode = false;
		break;
	}

	fseek(m_fp, (long)m_data, SEEK_SET);
	m_bom = bom;
	return unicode;
}

bool UniStdioFile::ReadString(String & line, bool * lossy)
{
	assert(false); // unimplemented -- currently cannot read from a UniStdioFile!
	return false;
}

bool UniStdioFile::ReadString(String & line, String & eol, bool * lossy)
{
	assert(false); // unimplemented -- currently cannot read from a UniStdioFile!
	return false;
}

bool UniStdioFile::ReadStringAll(String & line)
{
	assert(false); // unimplemented -- currently cannot read from a UniStdioFile!
	return false;
}

/** @brief Write BOM (byte order mark) if Unicode file */
int UniStdioFile::WriteBom()
{
	if (m_unicoding == ucr::UCS2LE && m_bom)
	{
		unsigned char bom[] = "\xFF\xFE";
		fseek(m_fp, 0, SEEK_SET);
		fwrite(bom, 1, 2, m_fp);
		m_data = 2;
	}
	else if (m_unicoding == ucr::UCS2BE && m_bom)
	{
		unsigned char bom[] = "\xFE\xFF";
		fseek(m_fp, 0, SEEK_SET);
		fwrite(bom, 1, 2, m_fp);
		m_data = 2;
	}
	else if (m_unicoding == ucr::UTF8 && m_bom)
	{
		unsigned char bom[] = "\xEF\xBB\xBF";
		fseek(m_fp, 0, SEEK_SET);
		fwrite(bom, 1, 3, m_fp);
		m_data = 3;
	}
	else
	{
		m_data = 0;
	}
	return (int)m_data;
}

/**
 * @brief Write one line (doing any needed conversions)
 */
bool UniStdioFile::WriteString(const String & line)
{
	// shortcut the easy cases
#ifdef _UNICODE
	if (m_unicoding == ucr::UCS2LE)
#else
	if (m_unicoding == ucr::NONE && ucr::EqualCodepages(m_codepage, GetACP()))
#endif
	{
		size_t bytes = line.length() * sizeof(tchar_t);
		size_t wbytes = fwrite(line.c_str(), 1, bytes, m_fp);
		if (wbytes != bytes)
			return false;
		return true;
	}

	ucr::UNICODESET unicoding1 = ucr::NONE;
	int codepage1 = 0;
	ucr::getInternalEncoding(&unicoding1, &codepage1); // What String & tchar_ts represent
	const unsigned char * src = (const unsigned char *)line.c_str();
	size_t srcbytes = line.length() * sizeof(tchar_t);
	bool lossy = ucr::convert(unicoding1, codepage1, src, srcbytes, (ucr::UNICODESET)m_unicoding, m_codepage, &m_ucrbuff);
	// TODO: What to do about lossy conversion ?
	size_t wbytes = fwrite(m_ucrbuff.ptr, 1, m_ucrbuff.size, m_fp);
	if (wbytes != m_ucrbuff.size)
		return false;
	return true;
}

int64_t UniStdioFile::GetPosition() const
{
	if (!IsOpen()) return 0;
	return ftell(m_fp);
}
</file>

<file path="Winmerge-Src/Src/Common/UniFile.h">
/**
 *  @file   UniFile.h
 *  @author Perry Rapp, Creator, 2003-2006
 *  @date   Created: 2003-10
 *  @date   Edited:  2006-02-20 (Perry Rapp)
 *
 *  @brief  Declaration of Unicode file classes.
 */
#pragma once

#include "unicoder.h"
#include <cstdio>

namespace Poco { class SharedMemory; }

/**
 * @brief Interface to file classes in this module
 */
class UniFile
{
public:

	/**
	 * @brief A struct for error message or error code.
	 */
	struct UniError
	{
		String desc; // valid if apiname empty

		UniError();
		bool HasError() const;
		void ClearError();
		const String& GetError() const;
	};

	virtual ~UniFile() { }
	virtual bool OpenReadOnly(const String& filename) = 0;
	virtual void Close() = 0;
	virtual bool IsOpen() const = 0;

	virtual String GetFullyQualifiedPath() const = 0;
	virtual const UniError & GetLastUniError() const = 0;

	virtual bool IsUnicode() = 0;
	virtual bool ReadBom() = 0;
	virtual bool HasBom() const = 0;
	virtual void SetBom(bool bom) = 0;

	virtual ucr::UNICODESET GetUnicoding() const = 0;
	virtual void SetUnicoding(ucr::UNICODESET unicoding) = 0;
	virtual int GetCodepage() const = 0;
	virtual void SetCodepage(int codepage) = 0;

public:
	virtual bool ReadString(String & line, bool * lossy) = 0;
	virtual bool ReadString(String & line, String & eol, bool * lossy) = 0;
	virtual bool ReadStringAll(String & line) = 0;
	virtual int GetLineNumber() const = 0;
	virtual int64_t GetPosition() const = 0;
	virtual bool WriteString(const String & line) = 0;

	struct txtstats
	{
		int ncrs;
		int nlfs;
		int ncrlfs;
		int nzeros;
		int nlosses;
		txtstats() { clear(); }
		void clear() { ncrs = nlfs = ncrlfs = nzeros = nlosses = 0; }
	};
	virtual const txtstats & GetTxtStats() const = 0;
};

/**
 * @brief Check if there is error.
 * @return true if there is an error.
 */
inline bool UniFile::UniError::HasError() const
{
	return !desc.empty();
}

/**
 * @brief Clears the existing error.
 */
inline void UniFile::UniError::ClearError()
{
	desc.clear();
}

/**
 * @brief Get the error string.
 * @return Error string.
 */
inline const String& UniFile::UniError::GetError() const
{
	return desc;
}

/**
 * @brief Local file access code used by both UniMemFile and UniStdioFile
 *
 * This class lacks an actual handle to a file
 */
class UniLocalFile : public UniFile
{
public:
	UniLocalFile();
	void Clear();

	virtual String GetFullyQualifiedPath() const override { return m_filepath; }
	virtual const UniError & GetLastUniError() const override { return m_lastError; }

	virtual ucr::UNICODESET GetUnicoding() const override { return m_unicoding; }
	virtual void SetUnicoding(ucr::UNICODESET unicoding) override { m_unicoding = unicoding; }
	virtual int GetCodepage() const override { return m_codepage; }
	virtual void SetCodepage(int codepage) override { 
		m_codepage = codepage;
		switch (m_codepage)
		{
		case ucr::CP_UCS2LE:
			m_unicoding = ucr::UCS2LE;
			m_charsize = 2;
			break;
		case ucr::CP_UCS2BE:
			m_unicoding = ucr::UCS2BE;
			m_charsize = 2;
			break;
		case ucr::CP_UTF_8:
			m_charsize = 1;
			m_unicoding = ucr::UTF8;
			break;
		default:
			m_charsize = 1;
			m_unicoding = ucr::NONE;
			break;
		}
	}

	virtual int GetLineNumber() const override { return m_lineno; }
	virtual const txtstats & GetTxtStats() const override { return m_txtstats; }
	virtual int64_t GetFileSize() const{ return m_filesize; }

	bool IsUnicode() override;

protected:
	virtual bool DoGetFileStatus();
	virtual void LastErrorCustom(const String& desc);

protected:
	int m_statusFetched; // 0 not fetched, -1 error, +1 success
	int m_lineno; // current 0-based line of m_current
	int64_t m_filesize;
	String m_filepath;
	String m_filename;
	UniError m_lastError;
	int m_charsize; // 2 for UCS-2, else 1
	int m_codepage; // only valid if m_unicoding==ucr::NONE;
	txtstats m_txtstats;
	ucr::UNICODESET m_unicoding;
	bool m_bom; /**< Did the file have a BOM when reading? */
	bool m_bUnicodingChecked; /**< Has unicoding been checked for the file? */
	bool m_bUnicode; /**< Is the file unicode file? */
};

/**
 * @brief Memory-Mapped disk file (read-only access)
 */
class UniMemFile : public UniLocalFile
{
public:
	enum AccessMode
	{
		AM_READ = 0,
		AM_WRITE
	};

	UniMemFile();
	virtual ~UniMemFile() { Close(); }

	virtual bool GetFileStatus();

	virtual bool OpenReadOnly(const String& filename) override;
	virtual bool Open(const String& filename);
	virtual bool Open(const String& filename, AccessMode mode);
	void Close() override;
	virtual bool IsOpen() const override;

	virtual bool ReadBom() override;
	virtual bool HasBom() const override;
	virtual void SetBom(bool bom) override;

public:
	virtual bool ReadString(String & line, bool * lossy) override;
	virtual bool ReadString(String & line, String & eol, bool * lossy) override;
	virtual bool ReadStringAll(String & line) override;
	virtual int64_t GetPosition() const override { return m_current - m_base; }
	virtual bool WriteString(const String & line) override;
	unsigned char* GetBase() const { return m_base; }

// Implementation methods
protected:
	virtual bool DoOpen(const String& filename, AccessMode mode);

// Implementation data
private:
	Poco::SharedMemory *m_hMapping;
	unsigned char *m_base; // points to base of mapping
	unsigned char *m_data; // similar to m_base, but after BOM if any
	unsigned char *m_current; // current location in file
};

/** @brief Is it currently attached to a file ? */
inline bool UniMemFile::IsOpen() const
{
	// We don't test the handle here, because we allow "opening" empty file
	// but memory-mapping doesn't work on that, so that uses a special state
	// of no handle, but linenumber of 0
	return m_lineno >= 0;
}

/**
 * @brief Returns if file has a BOM bytes.
 * @return true if file has BOM bytes, false otherwise.
 */
inline bool UniMemFile::HasBom() const
{
	return m_bom;
}

/**
 * @brief Sets if file has BOM or not.
 * @param [in] true to have a BOM in file, false to not to have.
 */
inline void UniMemFile::SetBom(bool bom)
{
	m_bom = bom;
}

/**
 * @brief Regular buffered file (write-only access)
 * (ReadString methods have never been implemented,
 *  because UniMemFile above is good for reading)
 */
class UniStdioFile : public UniLocalFile
{
public:
	UniStdioFile();
	~UniStdioFile();

	virtual bool GetFileStatus();

	virtual bool OpenReadOnly(const String& filename) override;
	virtual bool OpenCreate(const String& filename);
	virtual bool OpenCreateUtf8(const String& filename);
	virtual bool Open(const String& filename, const String& mode);
	virtual bool SetVBuf(int mode, size_t size);
	void Close() override;

	virtual bool IsOpen() const override;

	virtual bool ReadBom() override;
	virtual bool HasBom() const override;
	virtual void SetBom(bool bom) override;

protected:
	virtual bool ReadString(String & line, bool * lossy) override;
	virtual bool ReadString(String & line, String & eol, bool * lossy) override;
	virtual bool ReadStringAll(String & line) override;

public:
	virtual int64_t GetPosition() const override;

	virtual int WriteBom();
	virtual bool WriteString(const String & line) override;

// Implementation methods
protected:
	virtual bool DoOpen(const String& filename, const String& mode);
	virtual void LastErrorCustom(const String& desc) override;

// Implementation data
private:
	FILE * m_fp;
	int64_t m_data; // offset after any initial BOM
	ucr::buffer m_ucrbuff;
};

/** @brief Is it currently attached to a file ? */
inline bool UniStdioFile::IsOpen() const
{
	return m_fp != 0;
}

/**
 * @brief Returns if file has a BOM bytes.
 * @return true if file has BOM bytes, false otherwise.
 */
inline bool UniStdioFile::HasBom() const
{
	return m_bom;
}

/**
 * @brief Sets if file has BOM or not.
 * @param [in] true to have a BOM in file, false to not to have.
 */
inline void UniStdioFile::SetBom(bool bom)
{
	m_bom = bom;
}


</file>

<file path="Winmerge-Src/Src/Common/ValidatingEdit.cpp">
/** 
 * @file  ValidatingEdit.cpp
 *
 * @brief Implementation file for CValidatingEdit
 *
 */
#include "stdafx.h"
#include "ValidatingEdit.h"

IMPLEMENT_DYNAMIC(CValidatingEdit, CEdit)

#define ID_VALIDATE_TIMER 1001
#define ID_UPDATE_TIMER 1002
#define VALIDATE_DELAY_MS 700
#define UPDATE_DELAY_MS 200


static COLORREF getDefaultErrorColor()
{
	const COLORREF sysBk = GetSysColor(COLOR_WINDOW);
	if ((GetRValue(sysBk) + GetGValue(sysBk) + GetBValue(sysBk)) / 3 < 128)
		return RGB(80, 40, 40);
	return RGB(255, 200, 200);
}

CValidatingEdit::CValidatingEdit()
	: m_hasError(false)
	, m_errorColor(getDefaultErrorColor())
	, m_errorBrush(m_errorColor)
	, m_toolItem{}
{
}

CValidatingEdit::~CValidatingEdit()
{
	m_errorBrush.DeleteObject();
}

BEGIN_MESSAGE_MAP(CValidatingEdit, CEdit)
	ON_WM_CTLCOLOR_REFLECT()
	ON_WM_KILLFOCUS()
	ON_WM_TIMER()
END_MESSAGE_MAP()

void CValidatingEdit::SetBackColor(COLORREF color)
{
	m_errorColor = color;
	m_errorBrush.DeleteObject();
	m_errorBrush.CreateSolidBrush(m_errorColor);
}

void CValidatingEdit::Validate()
{
	CString text;
	GetWindowText(text);

	const CString prevErrorMessage = m_errorMessage;
	m_hasError = false;
	m_errorMessage.Empty();

	if (m_validator)
	{
		CString msg;
		if (!m_validator(text, msg))
		{
			m_hasError = true;
			m_errorMessage = msg;
		}
	}
	if (prevErrorMessage != m_errorMessage)
	{
		KillTimer(ID_UPDATE_TIMER);
		SetTimer(ID_UPDATE_TIMER, UPDATE_DELAY_MS, nullptr);
	}

	Invalidate();
}

HBRUSH CValidatingEdit::CtlColor(CDC* pDC, UINT /*nCtlColor*/)
{
	if (m_hasError)
	{
		pDC->SetTextColor(GetSysColor(COLOR_WINDOWTEXT));
		pDC->SetBkColor(m_errorColor);
		return (HBRUSH)m_errorBrush.GetSafeHandle();
	}
	return nullptr;
}

BOOL CValidatingEdit::PreTranslateMessage(MSG* pMsg)
{
	if (m_toolTip.m_hWnd)
		m_toolTip.RelayEvent(pMsg);
	return CEdit::PreTranslateMessage(pMsg);
}

void CValidatingEdit::OnKillFocus(CWnd* pNewWnd)
{
	CEdit::OnKillFocus(pNewWnd);
	Validate();
}

void CValidatingEdit::OnEnChange()
{
	if (!m_hWnd)
		return;
	KillTimer(ID_VALIDATE_TIMER);
	SetTimer(ID_VALIDATE_TIMER, VALIDATE_DELAY_MS, nullptr);
}

void CValidatingEdit::OnTimer(UINT_PTR nIDEvent)
{
	if (nIDEvent == ID_VALIDATE_TIMER)
	{
		KillTimer(ID_VALIDATE_TIMER);
		Validate();
		return;
	}
	if (nIDEvent == ID_UPDATE_TIMER)
	{
		KillTimer(ID_UPDATE_TIMER);

		if (m_hasError)
		{
			CRect rc;
			GetWindowRect(&rc);

			if (!m_toolTip.GetSafeHwnd())
			{
				m_toolTip.Create(this, TTS_NOPREFIX | TTS_BALLOON | TTS_ALWAYSTIP);
				m_toolItem.cbSize = sizeof(TOOLINFO);
				m_toolItem.uFlags = TTF_TRACK | TTF_ABSOLUTE;
				m_toolItem.hwnd = m_hWnd;
				m_toolItem.uId = 1;
				m_toolItem.lpszText = _T("");
				m_toolTip.SendMessage(TTM_ADDTOOL, 0, (LPARAM)&m_toolItem);
				m_toolTip.SetMaxTipWidth(rc.Width());
			}

			m_toolItem.lpszText = (LPTSTR)(LPCTSTR)m_errorMessage;
			m_toolTip.SetToolInfo(&m_toolItem);

			POINT pt{ rc.left, rc.bottom };
			m_toolTip.SendMessage(TTM_TRACKPOSITION, 0, (LPARAM)MAKELONG(pt.x, pt.y));

			m_toolTip.SendMessage(TTM_TRACKACTIVATE, TRUE, (LPARAM)&m_toolItem);
		}
		else
		{
			if (m_toolTip.GetSafeHwnd())
			{
				m_toolTip.UpdateTipText(_T(""), this);
				m_toolTip.SendMessage(TTM_TRACKACTIVATE, FALSE, (LPARAM)&m_toolItem);
			}
		}
		return;
	}
	CEdit::OnTimer(nIDEvent);
}

</file>

<file path="Winmerge-Src/Src/Common/ValidatingEdit.h">
/** 
 * @file  ValidatingEdit.h
 *
 * @brief Declaration file for CValidatingEdit class
 */
#pragma once

class CValidatingEdit : public CEdit
{
	DECLARE_DYNAMIC(CValidatingEdit);
public:

	CValidatingEdit();
	virtual ~CValidatingEdit();

	std::function<bool(const CString&, CString&)> m_validator;

	void SetBackColor(COLORREF color);
	void Validate();
	void OnEnChange();

protected:
	DECLARE_MESSAGE_MAP()

	afx_msg HBRUSH CtlColor(CDC* pDC, UINT nCtlColor);
	afx_msg BOOL PreTranslateMessage(MSG* pMsg);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnTimer(UINT_PTR nIDEvent);

	CToolTipCtrl m_toolTip;
	bool m_hasError;
	COLORREF m_errorColor;
	CString m_errorMessage;
	CBrush m_errorBrush;
	TOOLINFO m_toolItem;
};
</file>

<file path="Winmerge-Src/Src/Common/varprop.cpp">
/**
 *  @file varprop.cpp
 *
 *  @brief Implementation of generic named property classes
 */ 

#include "pch.h"
#include "varprop.h"
#include <cassert>

namespace varprop
{
/**
 * @brief Default constructor.
 */
VariantValue::VariantValue()
: m_vtype(VT_NULL), m_bvalue(false), m_ivalue(0), m_fvalue(0),
  m_tvalue(0)
{
}

/**
 * @brief Copy constructor.
 * @param [in] value Object to copy.
 */
VariantValue::VariantValue(const VariantValue &value)
	: m_vtype(value.m_vtype)
	, m_bvalue(value.m_bvalue)
	, m_ivalue(value.m_ivalue)
	, m_fvalue(value.m_fvalue)
	, m_tvalue(value.m_tvalue)
	, m_svalue(value.m_svalue)
{
}

/**
 * @brief Assignment operator override.
 * @param [in] Object to copy.
 * @return Copy of given object.
 */
VariantValue& VariantValue::operator=(const VariantValue& value)
{
	if (this != &value)
	{
		m_vtype = value.m_vtype;
		m_bvalue = value.m_bvalue;
		m_ivalue = value.m_ivalue;
		m_fvalue = value.m_fvalue;
		m_svalue = value.m_svalue;
		m_tvalue = value.m_tvalue;
	}
	return *this;
}

/**
 * @brief Set boolean value.
 * @param [in] v Boolean value to set.
 */
void VariantValue::SetBool(bool v)
{
	Clear();
	m_vtype = VT_BOOL;
	m_bvalue = v;
}

/**
 * @brief Set integer value.
 * @param [in] v Integer value to set.
 */
void VariantValue::SetInt(int v)
{ 
	Clear();
	m_vtype = VT_INT;
	m_ivalue = v;
}

/**
 * @brief Set floating point value.
 * @param [in] v Floating point value to set.
 */
void VariantValue::SetFloat(double v)
{
	Clear();
	m_vtype = VT_FLOAT;
	m_fvalue = v;
}

/**
 * @brief Set string value.
 * @param [in] sz String value to set. Can be a `nullptr`.
 */
void VariantValue::SetString(const tchar_t *sz)
{
	Clear();
	m_vtype = VT_STRING;
	if (sz != nullptr)
		m_svalue = sz;
}

/**
 * @brief Set string value.
 * @param [in] sz String value to set.
 */
void VariantValue::SetString(const String& sz)
{
	m_svalue = sz;
	m_vtype = VT_STRING;
}

/**
 * @brief Set time value.
 * @param [in] v Time value to set.
 */
void VariantValue::SetTime(time_t v)
{
	Clear();
	m_vtype = VT_TIME;
	m_tvalue = v;
}

/**
 * @brief Clear variant's value (reset to defaults).
 */
void VariantValue::Clear()
{
	m_vtype = VT_NULL;
	m_bvalue = false;
	m_ivalue = 0;
	m_fvalue = 0;
	m_svalue.erase();
	m_tvalue = 0;
}

/**
 * @brief Get boolean value.
 * @return Boolean value.
 */
bool VariantValue::GetBool() const
{
	assert(m_vtype == VT_BOOL);
	return m_bvalue;
}

/**
 * @brief Get integer value.
 * @return Integer value.
 */
int VariantValue::GetInt() const
{
	assert(m_vtype == VT_INT);
	return m_ivalue;
}

/**
 * @brief Get floating point value.
 * @return Floating point value.
 */
double VariantValue::GetFloat() const
{
	assert(m_vtype == VT_FLOAT);
	return m_fvalue;
}

/**
 * @brief Get string value.
 * @return String value.
 */
const String& VariantValue::GetString() const
{
	assert(m_vtype == VT_STRING);
	return m_svalue;
}

/**
 * @brief Get time value.
 * @return Time value.
 */
time_t VariantValue::GetTime() const
{
	assert(m_vtype == VT_TIME);
	return m_tvalue;
}

} // namespace
</file>

<file path="Winmerge-Src/Src/Common/varprop.h">
/**
 *  @file varprop.h
 *
 *  @brief Declaration of generic named property classes
 */ 
#pragma once

#include <ctime>
#include "UnicodeString.h"

namespace varprop
{

/**
 * @brief Types that variant type can contain.
 */
typedef enum
{
	VT_NULL,     /**< No type */
	VT_BOOL,     /**< Boolean type */
	VT_INT,      /**< Integer type */
	VT_FLOAT,    /**< Floating point type */
	VT_STRING,   /**< String type */
	VT_TIME      /**< Time type */
} VT_TYPE;

/**
 * @brief A variant class.
 * This class can hold several base types. Type is set when the value is set.
 * @todo Add function to get/set string values as UTF-8 string - to avoid
 *  conversions in call sites.
 */
class VariantValue
{
public:
	VariantValue();
	VariantValue(const VariantValue &value);
	VariantValue& operator=(const VariantValue& value);

	bool IsBool() const { return m_vtype == VT_BOOL; }
	bool IsInt() const { return m_vtype == VT_INT; }
	bool IsFloat() const { return m_vtype == VT_FLOAT; }
	bool IsString() const { return m_vtype == VT_STRING; }
	bool IsTime() const { return m_vtype == VT_TIME; }
	VT_TYPE GetType() const { return m_vtype; }

	void SetBool(bool v);
	void SetInt(int v);
	void SetFloat(double v);
	void SetString(const tchar_t *sz);
	void SetString(const String& sz);
	void SetTime(time_t v);

	void Clear();

	bool GetBool() const;
	int GetInt() const;
	double GetFloat() const;
	const String& GetString() const;
	time_t GetTime() const;

private:
	VT_TYPE m_vtype;  /**< Type of the variant. */
	bool m_bvalue;    /**< Boolean value of the variant. */
	int m_ivalue;     /**< Integer value of the variant. */
	double m_fvalue;  /**< Floating point value of the variant. */
	String m_svalue;  /**< String value of the variant. */
	time_t m_tvalue;  /**< Time value of the variant. */
};

} // namespace
</file>

<file path="Winmerge-Src/Src/Common/VersionInfo.cpp">
/**
 *  @file VersionInfo.cpp
 *
 *  @brief Implementation of CVersionInfo class
 */ 

#include "pch.h"
#include "VersionInfo.h"
#include <windows.h>
#include <cstdio>
#include <cassert>
#include <strsafe.h>
#include "UnicodeString.h"

/** 
 * @brief Structure used to store language and codepage.
 */
struct LANGUAGEANDCODEPAGE
{
	WORD wLanguage;
	WORD wCodePage;
};

/** 
 * @brief Constructor for asking only numeric version info.
 * This constructor creates instance that only reads version numbers,
 * not several strings there are. This saves some time.
 * @param [in] bVersionOnly If `true` only version numbers are read.
 */
CVersionInfo::CVersionInfo(bool bVersionOnly)
: m_wLanguage(0)
, m_bVersionOnly(bVersionOnly)
, m_bDllVersion(false)
{
	GetVersionInfo();
}

/** 
 * @brief Constructor for asking version infor when language is known.
 * This constructor creates instance which gets version-info matching
 * given language-ID. There can be several different language-codepage
 * combinations, but we use first version info block that matches the
 * given language. So even if codepage isn't correct, we get correct
 * version information.
 * @param [in] wLanguage Language-ID for which the version info is wanted.
 */
CVersionInfo::CVersionInfo(WORD wLanguage)
: m_wLanguage(wLanguage)
, m_bVersionOnly(false)
, m_bDllVersion(false)
{
	GetVersionInfo();
}

/** 
 * @brief Constructor.
 * @param [in] szFileToVersion Filename to read version from.
 * @param [in] bDllVersion If `true` queries DLL version.
 */
CVersionInfo::CVersionInfo(const tchar_t* szFileToVersion, 
						   bool bDllVersion)
: m_wLanguage(0)
, m_bVersionOnly(false)
, m_bDllVersion(bDllVersion)
{
	if (szFileToVersion != nullptr)
		m_strFileName = szFileToVersion;
	GetVersionInfo();
}

/** 
 * @brief Constructor.
 * @param [in] szFileToVersion Filename to read version from.
 * @param [in] szLanguage Language for version.
 * @param [in] szCodePage Codepage for version.
 */
CVersionInfo::CVersionInfo(const tchar_t* szFileToVersion /* = nullptr*/, 
						   const tchar_t* szLanguage /* = nullptr*/,
						   const tchar_t* szCodepage /* = nullptr*/)
: m_wLanguage(0)
, m_bVersionOnly(false)
, m_bDllVersion(false)
{
	if (szFileToVersion != nullptr)
		m_strFileName = szFileToVersion;
	if (szLanguage != nullptr)
		m_strLanguage = szLanguage;
	if (szCodepage != nullptr)
		m_strCodepage = szCodepage;
	GetVersionInfo();
}

/** 
 * @brief Constructor for asking version number from known module.
 * @param [in] hModule Handle to module for version info.
 */
CVersionInfo::CVersionInfo(HINSTANCE hModule)
: m_wLanguage(0)
, m_bVersionOnly(false)
, m_bDllVersion(false)
{
	tchar_t szFileName[MAX_PATH];
	GetModuleFileName(hModule, szFileName, MAX_PATH);
	m_strFileName = szFileName;
	GetVersionInfo();
}

/** 
 * @brief Format version string from numbers.
 * Version number consists of four WORD (16-bit) numbers. This function
 * formats those numbers to string, where numbers are separated by
 * dots. If the last number is zero it is not printed.
 * @param [in] First two (most significant) numbers for version number.
 * @param [in] Last two numbers for version number.
 * @return Formatted version string.
 */
static String MakeVersionString(DWORD hi, DWORD lo)
{
	tchar_t ver[50];
	if (LOWORD(lo) == 0)
	{
		StringCchPrintf(ver, std::size(ver) - 1, _T("%d.%d.%d"), HIWORD(hi),
				LOWORD(hi), HIWORD(lo));
	}
	else
	{
		StringCchPrintf(ver, std::size(ver) - 1, _T("%d.%d.%d.%d"), HIWORD(hi),
				LOWORD(hi), HIWORD(lo), LOWORD(lo));
	}
	String sver(ver);
	return sver;
}

/** 
 * @brief Return numeric product's version number.
 * This function returns version number given as a number in version info.
 * @return Product's version number as string.
 */
String CVersionInfo::GetFixedProductVersion()
{
	if (!m_bVersionFound)
		return _T("");
	return MakeVersionString(m_FixedFileInfo.dwProductVersionMS
		, m_FixedFileInfo.dwProductVersionLS);
}

/** 
 * @brief Return numeric file's version number.
 * This function returns version number given as a number in version info.
 * @return File's version number as string.
 */
String CVersionInfo::GetFixedFileVersion()
{
	if (!m_bVersionFound)
		return _T("");
	return MakeVersionString(m_FixedFileInfo.dwFileVersionMS
		, m_FixedFileInfo.dwFileVersionLS);
}

/** 
 * @brief Return numeric file's version number.
 * This function returns version number given as two DWORDs.
 * @param [out] versionMS High DWORD for version number.
 * @param [out] versionLS Low DWORD for version number.
 * @return `true` if version info was found, `false` otherwise.
 */
bool CVersionInfo::GetFixedFileVersion(unsigned& versionMS, unsigned& versionLS)
{
	if (m_bVersionFound)
	{
		versionMS = m_FixedFileInfo.dwFileVersionMS;
		versionLS = m_FixedFileInfo.dwFileVersionLS;
		return true;
	}
	return false;
}

/** 
 * @brief Read version info from file.
 * This function reads version information from file's version resource
 * to member variables.
 */
void CVersionInfo::GetVersionInfo()
{
	ZeroMemory(&m_FixedFileInfo, sizeof(m_FixedFileInfo));
	ZeroMemory(&m_dvi, sizeof(m_dvi));

	DWORD dwVerHnd = 0;			// An 'ignored' parameter, always '0'
	tchar_t szFileName[MAX_PATH];

	if (m_strFileName.empty())
	{
		::GetModuleFileName(nullptr, szFileName, MAX_PATH);
		m_strFileName = szFileName;
	}
	else
		StringCchCopy(szFileName, MAX_PATH, m_strFileName.c_str());
	
	DWORD dwVerInfoSize = ::GetFileVersionInfoSize(szFileName, &dwVerHnd);
	if (dwVerInfoSize)
	{
		m_bVersionFound = true;
		m_pVffInfo.reset(new BYTE[dwVerInfoSize]);
		if (::GetFileVersionInfo(szFileName, 0, dwVerInfoSize, m_pVffInfo.get()))
		{
			GetFixedVersionInfo();
			if (!m_bVersionOnly)
				QueryStrings();
		}
	}

	if (m_bDllVersion)
	{
		if (HINSTANCE hinstDll = ::LoadLibrary(szFileName))
		{
			DLLGETVERSIONPROC DllGetVersion = (DLLGETVERSIONPROC) 
					::GetProcAddress(hinstDll, "DllGetVersion");
			if (DllGetVersion)
			{
				m_dvi.cbSize = sizeof(m_dvi);
				if (FAILED(DllGetVersion(&m_dvi)))
				{
					m_dvi.cbSize = 0;
				}
			}
			::FreeLibrary(hinstDll);
		}
	}
}

/** 
 * @brief Read strings from version info data.
 */
void CVersionInfo::QueryStrings()
{
	if (m_wLanguage != 0)
	{
		WORD codepage;
		GetCodepageForLanguage(m_wLanguage, codepage);
		tchar_t temp[20];
		StringCchPrintf(temp, std::size(temp) - 1, _T("%04x"), m_wLanguage);
		m_strLanguage = temp;
		StringCchPrintf(temp, std::size(temp) - 1, _T("%04x"), codepage);
		m_strCodepage = temp;
	}
	else if (m_strLanguage.empty()
		|| m_strCodepage.empty())
	{
		LANGUAGEANDCODEPAGE *lpTranslate;
		DWORD langLen;
		if (!!VerQueryValue((LPVOID)m_pVffInfo.get(),
				_T("\\VarFileInfo\\Translation"),
				(LPVOID *)&lpTranslate, (UINT *)&langLen))
		{
			tchar_t temp[20];
			StringCchPrintf(temp, std::size(temp) - 1, _T("%4.4X"),
					lpTranslate[0].wLanguage);
			m_strLanguage = temp;
			StringCchPrintf(temp, std::size(temp) - 1, _T("%4.4X"),
					lpTranslate[0].wCodePage);
			m_strCodepage = temp;
		}
	}
	QueryValue(_T("CompanyName"), m_strCompanyName);
	QueryValue(_T("FileDescription"), m_strFileDescription);
	QueryValue(_T("FileVersion"), m_strFileVersion); 
	QueryValue(_T("InternalName"), m_strInternalName); 
	QueryValue(_T("LegalCopyright"), m_strLegalCopyright); 
	QueryValue(_T("OriginalFilename"), m_strOriginalFilename); 
	QueryValue(_T("ProductName"), m_strProductName); 
	QueryValue(_T("ProductVersion"), m_strProductVersion); 
	QueryValue(_T("Comments"), m_strComments);
	QueryValue(_T("SpecialBuild"), m_strSpecialBuild);
	QueryValue(_T("PrivateBuild"), m_strPrivateBuild);
}

/** 
 * @brief Read value from version info data.
 * @param [in] szId Name of value/string to read.
 * @param [out] Value read.
 */
void CVersionInfo::QueryValue(const tchar_t* szId, String& s)
{
	assert(m_pVffInfo != nullptr);
	tchar_t* lpVersion;			// String pointer to 'version' text
	UINT    uVersionLen;
	bool    bRetCode;

	tchar_t szSelector[256];
	StringCchPrintf(szSelector, std::size(szSelector) - 1,
			_T("\\StringFileInfo\\%s%s\\%s"),
			m_strLanguage.c_str(), m_strCodepage.c_str(), szId);
	bRetCode = !!VerQueryValue((LPVOID)m_pVffInfo.get(),
		szSelector,
		(LPVOID *)&lpVersion,
		&uVersionLen);
	
	if (bRetCode)
	{
		s = lpVersion;
		if (!s.empty())
			s = strutils::trim_ws(s);
	}
	else
		s.clear();
}

/** 
 * @brief Read numeric version information.
 */
void CVersionInfo::GetFixedVersionInfo()
{
	VS_FIXEDFILEINFO * pffi;
	UINT len = sizeof(*pffi);
	bool bRetCode = !!VerQueryValue(
		(LPVOID)m_pVffInfo.get(), _T("\\"), (LPVOID *)&pffi, &len);
	if (bRetCode)
		m_FixedFileInfo = *pffi;
	else
		m_FixedFileInfo = { 0 };
	m_dvi.dwMajorVersion = HIWORD(m_FixedFileInfo.dwFileVersionMS);
	m_dvi.dwMinorVersion = LOWORD(m_FixedFileInfo.dwFileVersionMS);
	m_dvi.dwBuildNumber = HIWORD(m_FixedFileInfo.dwFileVersionLS);
}

/** 
 * @brief Get codepage for given language.
 * This function finds codepage value for given language from version info.
 * That is, we have certain combinations of language-codepage in version info.
 * This function tells which codepage exists with given language, so we can
 * find existing version info data.
 * @param [in] wLanguage Language ID for which we need matching codepage.
 * @param [out] wCodePage Found codepage.
 * @return `true` if language was found from version info block.
 */
bool CVersionInfo::GetCodepageForLanguage(WORD wLanguage, WORD & wCodePage)
{
	LANGUAGEANDCODEPAGE *lpTranslate;
	UINT cbTranslate;
	// Read the list of languages and code pages.

	VerQueryValue((LPVOID)m_pVffInfo.get(), 
				_T("\\VarFileInfo\\Translation"),
				(LPVOID*)&lpTranslate,
				&cbTranslate);

	// Read the file description for each language and code page.

	const int nLangCount = cbTranslate / sizeof(LANGUAGEANDCODEPAGE);
	int i = 0;
	bool bFound = false;
	while (!bFound && i < nLangCount)
	{
		if (lpTranslate[i].wLanguage == wLanguage)
		{
			wCodePage = lpTranslate[i].wCodePage;
			bFound = true;
		}
		else
			++i;
	}
	return bFound;
}
</file>

<file path="Winmerge-Src/Src/Common/VersionInfo.h">
/**
 *  @file VersionInfo.h
 *
 *  @brief Declaration of CVersionInfo class
 */ 
#pragma once

#include <shlwapi.h>
#include <memory>
#include "UnicodeString.h"

/**
 * @brief Class providing access to version information of a file.
 * This class reads version information block from a file. Version information
 * consists of version numbers, copyright, descriptions etc. Since that is
 * many strings to read, there is constructor taking `bool` parameter and
 * only reading version numbers. That constructor is suggested to be used
 * if string information is not needed.
 */
class CVersionInfo
{
private:
	VS_FIXEDFILEINFO m_FixedFileInfo; /**< Fixed file information */
	std::unique_ptr<BYTE[]> m_pVffInfo; /**< Pointer to version information block */
	bool m_bVersionOnly; /**< Ask version numbers only */
	bool m_bDllVersion; /**< Dll file version is being queried */
	WORD m_wLanguage; /**< Language-ID to use (if given) */
	bool m_bVersionFound; /**< Was version info found from file? */

	String m_strFileName;
	String m_strLanguage;
	String m_strCodepage;
	String m_strCompanyName;
	String m_strFileDescription;
	String m_strFileVersion;
	String m_strInternalName; 
	String m_strLegalCopyright; 
	String m_strOriginalFilename; 
	String m_strProductName; 
	String m_strProductVersion; 
	String m_strComments;
	String m_strSpecialBuild;
	String m_strPrivateBuild;

public:
	explicit CVersionInfo(bool bVersionOnly);
	explicit CVersionInfo(WORD wLanguage);
	CVersionInfo(const tchar_t* szFileToVersion,
				   bool bDllVersion);
	CVersionInfo(const tchar_t* szFileToVersion = nullptr,
				   const tchar_t* szLanguage = nullptr,
				   const tchar_t* szCodepage = nullptr);
	explicit CVersionInfo(HINSTANCE hModule);
	const String& GetFileVersion() const;
	const String& GetCompanyName() const;
	const String& GetFileDescription() const;
	const String& GetInternalName() const;
	const String& GetFullFileName() const;
	const String& GetLegalCopyright() const;
	const String& GetOriginalFilename() const;
	const String& GetProductVersion() const;
	const String& GetComments() const;
	const String& GetSpecialBuild() const;
	const String& GetPrivateBuild() const;
	String GetFixedProductVersion();
	String GetFixedFileVersion();
	DLLVERSIONINFO m_dvi;
	bool GetFixedFileVersion(unsigned& versionMS, unsigned& versionLS);

protected:
	void GetVersionInfo();
	void GetFixedVersionInfo();
	void QueryStrings();
	void QueryValue(const tchar_t* szId, String& s);
	bool GetCodepageForLanguage(WORD wLanguage, WORD & wCodePage);
};

/** 
 * @brief Return file version string.
 * @return File version as string.
 */
inline const String& CVersionInfo::GetFileVersion() const
{
	return m_strFileVersion;
}

/** 
 * @brief Return private build value.
 * @return Private build number as string.
 */
inline const String& CVersionInfo::GetPrivateBuild() const
{
	return m_strPrivateBuild;
}

/** 
 * @brief Return special build value.
 * @return Special build number as string.
 */
inline const String& CVersionInfo::GetSpecialBuild() const
{
	return m_strSpecialBuild;
}

/** 
 * @brief Return company name.
 * @return Company name.
 */
inline const String& CVersionInfo::GetCompanyName() const
{
	return m_strCompanyName;
}

/** 
 * @brief Return file description string.
 * @return File description string.
 */
inline const String& CVersionInfo::GetFileDescription() const
{
	return m_strFileDescription;
}

/** 
 * @brief Return internal name.
 * @return Internal name.
 */
inline const String& CVersionInfo::GetInternalName() const
{
	return m_strInternalName;
}

/** 
 * @brief Return full file name.
 * @return full file name.
 */
inline const String& CVersionInfo::GetFullFileName() const
{
	return m_strFileName;
}

/** 
 * @brief Return copyright info.
 * @return Copyright info.
 */
inline const String& CVersionInfo::GetLegalCopyright() const
{
	return m_strLegalCopyright;
}

/** 
 * @brief Return original filename.
 * @return Original filename.
 */
inline const String& CVersionInfo::GetOriginalFilename() const
{
	return m_strOriginalFilename;
}

/** 
 * @brief Return product's version number.
 * @return Product's version number as string.
 */
inline const String& CVersionInfo::GetProductVersion() const
{
	return m_strProductVersion;
}

/** 
 * @brief Return comment string.
 * @return Comment string.
 */
inline const String& CVersionInfo::GetComments() const
{
	return m_strComments;
}

</file>

<file path="Winmerge-Src/Src/res/Merge.rc2">
//
// MERGE.RC2 - resources Microsoft Visual C++ does not edit directly
//

#ifdef APSTUDIO_INVOKED
	#error this file is not editable by Microsoft Visual C++
#endif //APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
// Add manually edited resources here...
#include "..\Merge2.rc"
#include "..\Externals\crystaledit\editlib\editres.rc"
/////////////////////////////////////////////////////////////////////////////
</file>

<file path="Winmerge-Src/Src/res/mg_cur.cur">
</file>

