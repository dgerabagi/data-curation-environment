<!--
  File: flattened_repo.md
  Source Directory: c:\Projects\DCE
  Date Generated: 2025-09-15T22:18:57.109Z
  ---
  Total Files: 84
  Approx. Tokens: 93589
-->

<!-- Top 10 Text Files by Token Count -->
1. src\Artifacts\A52.2 DCE - Interaction Schema Source.md (2473 tokens)
2. src\Artifacts\A78. DCE - Whitepaper - Process as Asset.md (2455 tokens)
3. src\Artifacts\A21. DCE - Phase 1 - Feature Drift Analysis vs. VS Code Explorer.md (1847 tokens)
4. src\Artifacts\A10. DCE - Metadata and Statistics Display.md (1822 tokens)
5. src\Artifacts\A20. DCE - Phase 1 - Advanced UX & Automation Plan.md (1817 tokens)
6. src\Artifacts\A15. DCE - Phase 1 - Multi-Select & Sorting Feature Plan.md (1816 tokens)
7. src\Artifacts\A34. DCE - Phase 2 - Parallel Co-Pilot Panel - Vision & Requirements.md (1713 tokens)
8. src\Artifacts\A13. DCE - Phase 1 - Right-Click Context Menu.md (1517 tokens)
9. src\Artifacts\A8. DCE - Phase 1 - Selection Sets Feature Plan.md (1511 tokens)
10. src\Artifacts\A52.1 DCE - Parser Logic and AI Guidance.md (1463 tokens)

<!-- Full File List -->
1. src\Artifacts\A1. DCE - Project Vision and Goals.md - Lines: 41 - Chars: 3995 - Tokens: 999
2. src\Artifacts\A2. DCE - Phase 1 - Context Chooser - Requirements & Design.md - Lines: 20 - Chars: 3329 - Tokens: 833
3. src\Artifacts\A3. DCE - Technical Scaffolding Plan.md - Lines: 55 - Chars: 3684 - Tokens: 921
4. src\Artifacts\A4. DCE - Analysis of The-Creator-AI Repo.md - Lines: 56 - Chars: 5722 - Tokens: 1431
5. src\Artifacts\A5. DCE - Target File Structure.md - Lines: 67 - Chars: 1977 - Tokens: 495
6. src\Artifacts\A7. DCE - Development and Testing Guide.md - Lines: 47 - Chars: 3075 - Tokens: 769
7. src\Artifacts\A8. DCE - Phase 1 - Selection Sets Feature Plan.md - Lines: 65 - Chars: 6043 - Tokens: 1511
8. src\Artifacts\A9. DCE - GitHub Repository Setup Guide.md - Lines: 88 - Chars: 4916 - Tokens: 1229
9. src\Artifacts\A10. DCE - Metadata and Statistics Display.md - Lines: 53 - Chars: 7286 - Tokens: 1822
10. src\Artifacts\A12. DCE - Logging and Debugging Guide.md - Lines: 80 - Chars: 5687 - Tokens: 1422
11. src\Artifacts\A13. DCE - Phase 1 - Right-Click Context Menu.md - Lines: 45 - Chars: 6068 - Tokens: 1517
12. src\Artifacts\A14. DCE - Ongoing Development Issues.md - Lines: 64 - Chars: 4324 - Tokens: 1081
13. src\Artifacts\A15. DCE - Phase 1 - Multi-Select & Sorting Feature Plan.md - Lines: 43 - Chars: 7263 - Tokens: 1816
14. src\Artifacts\A16. DCE - Phase 1 - UI & UX Refinements Plan.md - Lines: 24 - Chars: 4349 - Tokens: 1088
15. src\Artifacts\A17. DCE - Phase 1 - Advanced Tree View Features.md - Lines: 47 - Chars: 3888 - Tokens: 972
16. src\Artifacts\A18. DCE - Phase 1 - Active File Sync Feature Plan.md - Lines: 46 - Chars: 4548 - Tokens: 1137
17. src\Artifacts\A19. DCE - Phase 1 - Double-Click & Quick-Remove Feature Plan.md - Lines: 42 - Chars: 4603 - Tokens: 1151
18. src\Artifacts\A20. DCE - Phase 1 - Advanced UX & Automation Plan.md - Lines: 47 - Chars: 7268 - Tokens: 1817
19. src\Artifacts\A21. DCE - Phase 1 - Feature Drift Analysis vs. VS Code Explorer.md - Lines: 48 - Chars: 7385 - Tokens: 1847
20. src\Artifacts\A22. DCE - Phase 1 - Search & Filter Feature Plan.md - Lines: 58 - Chars: 3663 - Tokens: 916
21. src\Artifacts\A23. DCE - Phase 1 - Advanced Interactions (Keyboard & Drag-Drop) Plan.md - Lines: 37 - Chars: 5504 - Tokens: 1376
22. src\Artifacts\A24. DCE - Selection Paradigm Terminology.md - Lines: 57 - Chars: 3330 - Tokens: 833
23. src\Artifacts\A25. DCE - Phase 1 - Git & Problems Integration Plan.md - Lines: 48 - Chars: 5004 - Tokens: 1251
24. src\Artifacts\A26. DCE - Phase 1 - File System Traversal & Caching Strategy.md - Lines: 42 - Chars: 3593 - Tokens: 899
25. src\Artifacts\A27. DCE - Phase 1 - Undo-Redo Feature Plan.md - Lines: 55 - Chars: 5701 - Tokens: 1426
26. src\Artifacts\A28. DCE - Packaging and Distribution Guide.md - Lines: 95 - Chars: 4366 - Tokens: 1092
27. src\Artifacts\A29. DCE - Phase 1 - Binary and Image File Handling Strategy.md - Lines: 81 - Chars: 4217 - Tokens: 1055
28. src\Artifacts\A30. DCE - Phase 1 - PDF Handling and Virtualization Strategy.md - Lines: 44 - Chars: 4431 - Tokens: 1108
29. src\Artifacts\A31. DCE - Phase 2 - Multimodal Content Extraction (PDF Images).md - Lines: 44 - Chars: 4035 - Tokens: 1009
30. src\Artifacts\A32. DCE - Phase 1 - Excel and CSV Handling Strategy.md - Lines: 44 - Chars: 4295 - Tokens: 1074
31. src\Artifacts\A33. DCE - Phase 1 - Copy-Paste Feature Plan.md - Lines: 42 - Chars: 4456 - Tokens: 1114
32. src\Artifacts\A34. DCE - Phase 2 - Parallel Co-Pilot Panel - Vision & Requirements.md - Lines: 45 - Chars: 6849 - Tokens: 1713
33. src\Artifacts\A35. DCE - Phase 2 - UI Mockups and Flow.md - Lines: 54 - Chars: 3584 - Tokens: 896
34. src\Artifacts\A36. DCE - Phase 2 - Technical Implementation Plan.md - Lines: 56 - Chars: 3621 - Tokens: 906
35. src\Artifacts\A37. DCE - Phase 2 - Cycle Navigator & Knowledge Graph - Vision.md - Lines: 28 - Chars: 3242 - Tokens: 811
36. src\Artifacts\A38. DCE - Phase 2 - Cycle Navigator - UI Mockup.md - Lines: 69 - Chars: 4621 - Tokens: 1156
37. src\Artifacts\A39. DCE - Phase 2 - Cycle Navigator - Technical Plan.md - Lines: 84 - Chars: 4595 - Tokens: 1149
38. src\Artifacts\A40. DCE - Phase 2 - Parallel Co-Pilot - Target File Structure.md - Lines: 66 - Chars: 3659 - Tokens: 915
39. src\Artifacts\A40.1. DCE - Phase 2 - Competitive Analysis & Feature Ideas.md - Lines: 43 - Chars: 4784 - Tokens: 1196
40. src\Artifacts\A41. DCE - Phase 2 - API Key Management - Feature Plan.md - Lines: 47 - Chars: 4542 - Tokens: 1136
41. src\Artifacts\A41.1. DCE - Phase 2 - Advanced Features & Integrations Plan.md - Lines: 44 - Chars: 3946 - Tokens: 987
42. src\Artifacts\A41.2. DCE - Phase 2 - Feature Ideation & Competitive Analysis.md - Lines: 40 - Chars: 4566 - Tokens: 1142
43. src\Artifacts\A43. DCE - Phase 2 - Implementation Roadmap.md - Lines: 69 - Chars: 4694 - Tokens: 1174
44. src\Artifacts\A44. DCE - Phase 1 - Word Document Handling Strategy.md - Lines: 45 - Chars: 4626 - Tokens: 1157
45. src\Artifacts\A45. DCE - Phase 2 - Pop-out Co-Pilot Window - Feature Plan.md - Lines: 49 - Chars: 4156 - Tokens: 1039
46. src\Artifacts\A46. DCE - Phase 2 - Paste and Parse Response - Feature Plan.md - Lines: 38 - Chars: 3587 - Tokens: 897
47. src\Artifacts\A47. DCE - Phase 2 - Prompt Amalgamation Feature Plan.md - Lines: 42 - Chars: 3499 - Tokens: 875
48. src\Artifacts\A48. DCE - Phase 2 - Advanced Syntax Highlighting Plan.md - Lines: 49 - Chars: 4044 - Tokens: 1011
49. src\Artifacts\A49. DCE - Phase 2 - File Association & Diffing Plan.md - Lines: 44 - Chars: 4452 - Tokens: 1113
50. src\Artifacts\A50. DCE - Phase 2 - UI Component Plan (Resizable Panes & Inner Editors).md - Lines: 51 - Chars: 5128 - Tokens: 1282
51. src\Artifacts\A51. DCE - A-B-C Testing Strategy for UI Bugs.md - Lines: 81 - Chars: 5490 - Tokens: 1373
52. src\Artifacts\A52. DCE - Interaction Schema Refinement.md - Lines: 66 - Chars: 3444 - Tokens: 861
53. src\Artifacts\A52.1 DCE - Parser Logic and AI Guidance.md - Lines: 123 - Chars: 5850 - Tokens: 1463
54. src\Artifacts\A52.2 DCE - Interaction Schema Source.md - Lines: 57 - Chars: 9891 - Tokens: 2473
55. src\Artifacts\A53. DCE - Phase 2 - Token Count and Similarity Analysis.md - Lines: 43 - Chars: 3500 - Tokens: 875
56. src\Artifacts\A55. DCE - FSService Refactoring Plan.md - Lines: 77 - Chars: 4022 - Tokens: 1006
57. src\Artifacts\A56. DCE - Phase 2 - Advanced Diff Viewer Plan.md - Lines: 47 - Chars: 5687 - Tokens: 1422
58. src\Artifacts\A57. DCE - Phase 2 - Cycle Management Plan.md - Lines: 44 - Chars: 3625 - Tokens: 907
59. src\Artifacts\A58. DCE - WinMerge Source Code Analysis.md - Lines: 56 - Chars: 5322 - Tokens: 1331
60. src\Artifacts\A59. DCE - Phase 2 - Debugging and State Logging.md - Lines: 40 - Chars: 3737 - Tokens: 935
61. src\Artifacts\A60. DCE - Phase 2 - Cycle 0 Onboarding Experience.md - Lines: 35 - Chars: 4177 - Tokens: 1045
62. src\Artifacts\A61. DCE - Phase 2 - Cycle History Management Plan.md - Lines: 45 - Chars: 3559 - Tokens: 890
63. src\Artifacts\A65. DCE - Universal Task Checklist.md - Lines: 87 - Chars: 5422 - Tokens: 1356
64. src\Artifacts\A67. DCE - PCPP View Refactoring Plan.md - Lines: 47 - Chars: 3537 - Tokens: 885
65. src\Artifacts\A68. DCE - PCPP Context Pane UX Plan.md - Lines: 37 - Chars: 3347 - Tokens: 837
66. src\Artifacts\A69. DCE - Animated UI Workflow Guide.md - Lines: 68 - Chars: 3772 - Tokens: 943
67. src\Artifacts\A72. DCE - README for Artifacts.md - Lines: 47 - Chars: 3127 - Tokens: 782
68. src\Artifacts\A73. DCE - GitService Plan.md - Lines: 44 - Chars: 2548 - Tokens: 637
69. src\Artifacts\A74. DCE - Per-Input Undo-Redo Feature Plan.md - Lines: 49 - Chars: 3624 - Tokens: 906
70. src\Artifacts\A75. DCE - Text Area Component A-B-C Test Plan.md - Lines: 50 - Chars: 4761 - Tokens: 1191
71. src\Artifacts\A77. DCE - Monaco Editor Replacement Plan.md - Lines: 42 - Chars: 3610 - Tokens: 903
72. src\Artifacts\A78. DCE - VSIX Packaging and FTV Flashing Bug.md - Lines: 50 - Chars: 3687 - Tokens: 922
73. src\Artifacts\A78. DCE - Whitepaper - Process as Asset.md - Lines: 108 - Chars: 9820 - Tokens: 2455
74. src\Artifacts\A79. DCE - Autosave and Navigation Locking Plan.md - Lines: 49 - Chars: 4291 - Tokens: 1073
75. src\Artifacts\A80. DCE - Settings Panel Plan.md - Lines: 39 - Chars: 3592 - Tokens: 898
76. src\Artifacts\A81. DCE - Curator Activity Plan.md - Lines: 34 - Chars: 2346 - Tokens: 587
77. src\Artifacts\A82. DCE - Advanced Exclusion Management Plan.md - Lines: 40 - Chars: 3010 - Tokens: 753
78. src\Artifacts\A83. DCE - Universal Task Checklist for Cycle 6.md - Lines: 95 - Chars: 5172 - Tokens: 1293
79. src\Artifacts\A84. DCE - Universal Task Checklist for Cycle 10+.md - Lines: 55 - Chars: 2541 - Tokens: 636
80. src\Artifacts\A85. DCE - Model Card Feature Plan.md - Lines: 28 - Chars: 3060 - Tokens: 765
81. src\Artifacts\A85. DCE - Model Card Management Plan.md - Lines: 42 - Chars: 3466 - Tokens: 867
82. src\Artifacts\A85. DCE - Phase 2 - Model Card Management Plan.md - Lines: 48 - Chars: 4046 - Tokens: 1012
83. src\Artifacts\A85. DCE - Phase 3 - Model Cards Feature Plan.md - Lines: 53 - Chars: 4197 - Tokens: 1050
84. src\Artifacts\README.md - Lines: 33 - Chars: 2764 - Tokens: 691

<file path="src/Artifacts/A1. DCE - Project Vision and Goals.md">
# Artifact A1: DCE - Project Vision and Goals
# Date Created: Cycle 1
# Author: AI Model
# Updated on: C87 (Shifted Diff Tool to Phase 2, defined Phase 3 as LLM Integration)

## 1. Project Vision

The vision of the Data Curation Environment (DCE) is to create a seamless, integrated toolset within VS Code that streamlines the workflow of interacting with large language models. The core problem this project solves is the manual, cumbersome process of selecting, packaging, and managing the context (code files, documents, etc.) required for effective AI-assisted development.

## 2. High-Level Goals & Phases

The project will be developed in three distinct phases.

**Note on Reference Repository:** The discovery of the `The-Creator-AI-main` repository in Cycle 2 has provided a significant head-start, especially for Phase 1 and 2. The project's focus shifts from building these components from the ground up to adapting and extending the powerful, existing foundation.

### Phase 1: The Context Chooser

The goal of this phase is to eliminate the manual management of a `files_list.txt`. Users should be able to intuitively select files and folders for their AI context directly within the VS Code file explorer UI.

-   **Core Functionality:** Implement a file explorer view with checkboxes for every file and folder.
-   **Action:** A "Flatten Context" button will take all checked items and generate a single `flattened_repo.md` file in the project root.
-   **Outcome:** A user can curate a complex context with simple mouse clicks, completely removing the need to edit a text file.
-   **Status:** Largely complete.

### Phase 2: The Parallel Co-Pilot Panel & Integrated Diff Tool

This phase addresses the limitation of being locked into a single conversation with an AI assistant and brings the critical "diffing" workflow directly into the extension. The goal is to enable multiple, parallel interactions and to create a navigable record of the AI-driven development process.

-   **Core Functionality (Parallel Co-Pilot):** Create a custom panel within VS Code that hosts a multi-tabbed text editor. Users can manually paste or have the extension ingest different AI-generated code responses into each tab for side-by-side comparison.
-   **Key Feature ("Swap & Test"):** A button on each tab allows the user to "swap" the content of that tab with the corresponding source file in their workspace. This provides an immediate, low-friction way to test a given AI response.
-   **Core Functionality (Integrated Diff):** The panel will include a built-in diff viewer to compare the content of any two tabs, or a tab and the source file. This eliminates the need for external tools like WinMerge.
-   **Core Functionality (Cycle Navigator):** Integrate a UI element to navigate back and forth between development cycles. Each cycle will be associated with the set of AI responses generated during that cycle.
-   **Outcome:** A user can efficiently manage, compare, and test multiple AI solutions, and also review the historical evolution of the code by navigating through past cycles and their corresponding AI suggestions, creating a powerful "knowledge graph" of the project's development.

### Phase 3: Advanced AI & Local LLM Integration

This phase focuses on deeper integration with AI services and providing support for local models.

-   **Core Functionality:** Implement direct API calls to various LLM providers (e.g., Gemini, OpenAI, Anthropic) from within the Parallel Co-Pilot panel, populating the tabs automatically. This requires building a secure API key management system.
-   **Local LLM Support:** Allow users to configure an endpoint URL for a locally hosted LLM (e.g., via LM Studio, Ollama), enabling fully offline and private AI-assisted development.
-   **Outcome:** The DCE becomes a fully-featured AI interaction environment, supporting both cloud and local models, and automating the entire prompt-to-test workflow.
</file_artifact>

<file path="src/Artifacts/A2. DCE - Phase 1 - Context Chooser - Requirements & Design.md">
# Artifact A2: DCE - Phase 1 - Context Chooser - Requirements & Design
# Date Created: Cycle 1
# Author: AI Model
# Updated on: C46 (Remove requirement for ignoring binary files, per A29)

## 1. Overview

This document outlines the requirements for Phase 1 of the Data Curation Environment (DCE) project. The primary goal of this phase is to replace the manual, error-prone process of managing context via a `files_list.txt` with an intuitive, UI-driven approach within VS Code.

**Major Update (Cycle 2):** The analysis of the `The-Creator-AI-main` repository revealed an existing, highly-functional file tree component (`src/client/components/file-tree/FileTree.tsx`) with checkbox selection. The project requirements have been updated to reflect a shift from *building* this component from scratch to *analyzing, adapting, and integrating* the existing solution.

## 2. Functional Requirements

| ID | Requirement | User Story | Acceptance Criteria | Update (Cycle 2) |
|---|---|---|---|---|
| FR-01 | **Analyze Existing File Tree** | As a developer, I want to understand the capabilities of the `FileTree.tsx` component | - Analyze the component's props and state. <br> - Document its dependencies on other frontend components and backend services (`FSService`). <br> - Determine how checkbox state is managed and communicated. | **New** |
| FR-02 | **Display File Tree in View** | As a user, I want to see a tree of all files and folders in my workspace within a dedicated VS Code view. | - The view should accurately reflect the workspace's file system structure. <br> - It should respect `.gitignore` rules to hide irrelevant files. | **Adaptation.** The `FileTree.tsx` component and `FSService` already provide this. We need to ensure it's correctly instantiated in our extension's view. |
| FR-03 | **Checkbox Selection** | As a user, I want to select and deselect files and folders for my context using checkboxes. | - Every file and folder in the tree has a checkbox. <br> - Checking a folder checks all its children. <br> - Unchecking a folder unchecks all its children. <br> - A folder shows an "indeterminate" state if only some of its children are checked. | **Adaptation.** The reference component appears to support this logic. We must verify and adapt its state management (`selectedFiles` array). |
| FR-04 | **Flatten Selected Context** | As a user, I want a single button to package all my selected files into one context file. | - A "Flatten Context" button is present in the view. <br> - Clicking it triggers a process that reads the content of all checked files. <br> - The contents are concatenated into a single `flattened_repo.md` file in the project root. | **Implementation.** The logic for this will need to be implemented, using the state from the `FileTree` component as input for our enhanced `bootstrap-flattener.js` logic. |
| FR-05 | **Handle Binary Files** | As a user, I want to be able to select binary/image files to include their metadata in the context, without including their raw content. | - All files, including binary and image files, are selectable via their checkbox. <br> - When a binary/image file is selected and flattened, only its metadata (path, size, type) is included in `flattened_repo.md`. <br> - See `A29` for the full strategy. | **Revised (C46)** |
</file_artifact>

<file path="src/Artifacts/A3. DCE - Technical Scaffolding Plan.md">
# Artifact A3: DCE - Technical Scaffolding Plan
# Date Created: Cycle 1
# Author: AI Model
# Updated on: Cycle 2 (Adopted architecture from `The-Creator-AI-main` repository)

## 1. Overview

This document outlines the technical scaffolding and file structure for the Data Curation Environment (DCE) VS Code extension.

**Major Update (Cycle 2):** The initial plan for a simple file structure has been superseded. We are officially adopting the mature and robust architecture of the `The-Creator-AI-main` reference repository as our project's blueprint. This provides a proven, scalable foundation for all three project phases.

## 2. Adopted File Structure

The project will adhere to the following directory structure, derived directly from the reference repository:

```
.
├── public/                     # Static assets for webviews (icons, css)
├── src/
│   ├── backend/                # Extension Host code (Node.js environment)
│   │   ├── commands/           # Command definitions and registration
│   │   ├── repositories/       # Data persistence logic (workspace state)
│   │   ├── services/           # Core backend services (LLM, FS, Git, etc.)
│   │   ├── types/              # TypeScript types for the backend
│   │   └── utils/              # Utility functions for the backend
│   │
│   ├── client/                 # Webview code (Browser environment)
│   │   ├── components/         # Generic, reusable React components (FileTree, Modal)
│   │   ├── modules/            # Feature-specific modules (Context, Plan)
│   │   ├── store/              # Global state management for webviews (RxJS)
│   │   └── views/              # Entry points for each webview panel
│   │
│   ├── common/                 # Code shared between backend and client
│   │   ├── constants/
│   │   ├── ipc/                # IPC channel definitions and managers
│   │   ├── types/              # Shared TypeScript types (FileNode)
│   │   └── utils/              # Shared utility functions (parse-json)
│   │
│   └── extension.ts            # Main entry point for the VS Code extension
│
├── package.json                # Extension manifest, dependencies, and scripts
├── tsconfig.json               # TypeScript configuration
├── webpack.config.js           # Webpack configuration for bundling client/server code
└── ... (config files like .eslintrc.json, .gitignore)
```

## 3. Key Architectural Concepts

-   **Separation of Concerns:** The structure strictly separates backend (Node.js) logic from frontend (React/webview) logic.
-   **Shared Code:** The `src/common/` directory is critical for sharing types and IPC definitions, ensuring type safety and consistency between the extension host and the webview.
-   **Service-Oriented Backend:** The `src/backend/services/` directory promotes modularity. Each service has a single responsibility (e.g., `FSService` for file operations, `LlmService` for AI interaction), making the system easier to maintain and test.
-   **Dependency Injection:** The `Services.ts` class acts as a simple injector, managing the instantiation and provision of backend services.
-   **Modular Frontend:** The `src/client/modules/` directory allows for building complex UIs by composing smaller, feature-focused modules.
-   **Component-Based UI:** The `src/client/components/` directory holds the fundamental building blocks of the UI, promoting reusability.
-   **Typed IPC Communication:** The use of `channels.enum.ts` and `channels.type.ts` in `src/common/ipc/` provides a strongly-typed and well-documented contract for communication between the webview and the extension host, reducing runtime errors.
</file_artifact>

<file path="src/Artifacts/A4. DCE - Analysis of The-Creator-AI Repo.md">
# Artifact A4: DCE - Analysis of The-Creator-AI Repo
# Date Created: Cycle 2
# Author: AI Model
- **Description:** Provides a detailed analysis of the `The-Creator-AI-main` reference repository, its architecture, and its mapping to the Data Curation Environment project goals.
- **Tags:** analysis, repository, architecture, vscode-extension, project-planning

## 1. Overview

The `The-Creator-AI-main` repository is a comprehensive and well-structured VS Code extension that functions as a sophisticated AI coding assistant. It utilizes a modern tech stack including TypeScript, React for webviews, and TailwindCSS for styling. Its architecture is service-oriented on the backend (extension host) and modular on the frontend (webview). The discovery of this repository provides a massive head-start for our project, as it contains pre-built solutions for many of our planned features.

## 2. Backend Architecture (Extension Host)

The backend, located primarily in `src/backend/`, follows a clean, service-oriented architecture.

-   **`extension.ts`**: The main entry point. It initializes services and registers the commands and webview providers.
-   **`services/`**: A directory containing distinct services for handling specific concerns:
    -   `LlmService.ts`: Manages interactions with multiple AI models (Gemini, OpenAI). It includes logic for API key management and prompt construction.
    -   `FSService.ts`: Handles all file system operations, including reading files, creating a file tree, and respecting `.gitignore`.
    -   `CodeService.ts`: Contains logic for applying code changes, parsing diffs, and generating code.
    -   `GitService.ts`: Provides an interface for Git operations, like committing changes.
    -   `MessageService.ts`: Orchestrates the flow of messages between the frontend and the LLM service.
    -   `PlanExImService.ts`: Manages exporting and importing of "Change Plans".
    -   `Services.ts`: A dependency injection container that initializes and provides access to all other services.
-   **`repositories/`**: Manages data persistence within the VS Code workspace state (e.g., `PersistentStoreRepository.ts`, `SettingsRepository.ts`).
-   **`commands/`**: Defines all the commands exposed by the extension in `package.json`.

## 3. Frontend Architecture (Webview)

The frontend, located in `src/client/`, is a React application bundled with Webpack.

-   **`views/`**: The application is divided into distinct views, each with its own entry point, state management, and logic (e.g., `change-plan.view`).
-   **`modules/`**: Contains reusable UI/logic modules that are composed into the main view, such as:
    -   `context.module/Context.tsx`: Renders the file explorer.
    -   `plan.module/Plan.tsx`: Handles displaying the AI-generated plan and user input.
-   **`components/`**: A collection of generic, reusable React components:
    -   `file-tree/FileTree.tsx`: A fully functional file tree component with checkbox selection, expansion state, and active file highlighting. This is directly applicable to our Phase 1 goal.
    -   `AutoResizingTextarea.tsx`, `Modal.tsx`, `ProgressSteps.tsx`: Other useful UI components.
-   **State Management**: Each view appears to have its own local store (`store/`), using RxJS `BehaviorSubject` for reactivity. This is a simple yet effective approach for managing state within a contained webview.
-   **IPC**: Communication with the backend is handled via a robust `ClientPostMessageManager` (`src/common/ipc/`) which defines clear channels for client-server interaction.

## 4. Mapping to DCE Project Goals

The reference repository provides solutions or strong foundations for all three of our project phases.

-   **Phase 1 (Context Chooser):** **Largely Complete.** The `FileTree.tsx` component in `src/client/components/file-tree/` combined with `FSService.ts` on the backend already provides the core functionality of a checkbox-based file explorer for context selection. Our work shifts from building this from scratch to adapting and integrating this existing, powerful component.

-   **Phase 2 (Parallel 'Co-pilot' Panel):** **Partially Complete.** The "Change Plan" view (`src/client/views/change-plan.view/`) is essentially a single "co-pilot" panel. It allows a user to describe a change, get an AI-generated plan, and interact with it. Our goal of *parallel* panels is not implemented, but the foundation for a single panel is incredibly strong.

-   **Phase 3 (Diff Tool):** **Not Present.** There is no integrated diff-viewing tool like WinMerge. However, the `CodeService.ts` *does* contain logic for parsing and applying diffs in a custom `<<<<<<< SEARCH` format, and the extension can trigger VS Code's native diff viewer (`git.openChange`).

## 5. Recommendations & Path Forward

1.  **Adopt the Architecture:** We should officially adopt the architecture of `The-Creator-AI-main` as the blueprint for our project. It is robust, scalable, and well-organized.
2.  **Focus on Adaptation:** Our immediate efforts for Phase 1 should be to isolate the `FileTree` component and its backend dependencies (`FSService.ts`) and ensure they can be used to generate the `flattened_repo.md` as originally specified.
3.  **De-risk Phase 2:** The "Change Plan" functionality is a perfect starting point for our parallel co-pilot. We should analyze its state management and IPC communication to understand how we might instantiate multiple, independent instances of it.
4.  **Update All Documentation:** All planning artifacts (`A1`, `A2`, `A3`) must be updated immediately to reflect this new context. Our plan has evolved from "build" to "analyze, adapt, and extend".
</file_artifact>

<file path="src/Artifacts/A5. DCE - Target File Structure.md">
# Artifact A5: DCE - Target File Structure
# Date Created: Cycle 3
# Author: AI Model

- **Description:** A text-based representation of the target file structure for the DCE extension, outlining the layout of directories and key files.
- **Tags:** file structure, architecture, project layout, scaffolding

## 1. Overview

This document provides a visual representation of the file structure that the `A6. DCE - Initial Scaffolding Deployment Script` will create. It is based on the robust and scalable architecture of the `The-Creator-AI-main` reference repository, as detailed in `A3. DCE - Technical Scaffolding Plan`.

## 2. File Tree

```
DCE/
├── .gitignore
├── .vscodeignore
├── package.json
├── tsconfig.json
├── webpack.config.js
├── public/
│   └── spiral.svg
└── src/
    ├── backend/
    │   ├── commands/
    │   │   ├── commands.ts
    │   │   └── register-commands.ts
    │   ├── repositories/
    │   │   └── persistent-store.repository.ts
    │   ├── services/
    │   │   ├── fs.service.ts
    │   │   ├── services.ts
    │   │   └── flattener.service.ts
    │   └── types/
    │       └── storage-keys.enum.ts
    │
    ├── client/
    │   ├── components/
    │   │   └── file-tree/
    │   │       ├── FileTree.tsx
    │   │       └── FileTree.utils.ts
    │   ├── views/
    │   │   ├── context-chooser.view/
    │   │   │   ├── index.ts
    │   │   │   ├── on-message.ts
    │   │   │   ├── view.scss
    │   │   │   └── view.tsx
    │   │   └── index.ts
    │   └── store/
    │       ├── store.ts
    │       └── useStore.ts
    │
    ├── common/
    │   ├── ipc/
    │   │   ├── channels.enum.ts
    │   │   ├── channels.type.ts
    │   │   ├── client-ipc.ts
    │   │   ├── get-vscode-api.ts
    │   │   └── server-ipc.ts
    │   ├── types/
    │   │   ├── file-node.ts
    │   │   └── vscode-webview.d.ts
    │   └── utils/
    │       └── view-html.ts
    │
    └── extension.ts
```
</file_artifact>

<file path="src/Artifacts/A7. DCE - Development and Testing Guide.md">
# Artifact A7: DCE - Development and Testing Guide
# Date Created: Cycle 7
# Author: AI Model
# Updated on: Cycle 9 (Revised workflow to use integrated debugger configuration)

- **Description:** A step-by-step guide explaining how to run, debug, and test the DCE extension within VS Code using the Extension Development Host.
- **Tags:** development, testing, debugging, workflow, vs code extension, f5, launch.json

## 1. Purpose

This guide provides the correct and simplified procedure for running and testing the Data Curation Environment (DCE) extension locally. Following these steps is crucial to see your changes and the extension's UI in action.

## 2. The Core Concept: The Extension Development Host

You cannot see the extension's UI (like the spiral icon or the custom panel) in the same VS Code window where you are writing the code. Instead, you must launch a special, separate VS Code window called the **Extension Development Host**. This new window has your extension installed and running, allowing you to test it as a user would.

Our project now includes the necessary `.vscode/launch.json` and `.vscode/tasks.json` files to make this process seamless.

## 3. Step-by-Step Workflow

Follow these steps every time you want to test the extension:

### Step 1: Open the "Run and Debug" View

In your main project window (e.g., `C:\Projects\DCE`), navigate to the "Run and Debug" panel in the activity bar on the left. The icon looks like a play button with a bug on it.

### Step 2: Launch the Extension

At the top of the "Run and Debug" panel, you will see a dropdown menu. It should already have **"Run Extension"** selected.

Simply press the **F5** key or click the green play button next to the "Run Extension" dropdown.

This single action will now:
1.  Automatically start the `npm run watch` task in the background to compile your code.
2.  Launch the new **"[Extension Development Host]"** VS Code window.

### Step 3: Find the Extension UI

In the newly opened **Extension Development Host** window, look at the activity bar on the far left. You should now see our spiral icon. Clicking this icon will open the "Context Chooser" panel, where you'll see the file tree with checkboxes.

### Step 4: Making and Viewing Changes

1.  **Make Code Changes:** Edit the source code in your **original** project window.
2.  **Auto-Compile:** When you save a file, the `npm run watch` task (which was started automatically) will recompile it. You can see its progress in the terminal panel of your original window.
3.  **Reload the Host:** To see your changes, go to the **Extension Development Host** window (the one you launched with F5) and reload it. The easiest way is to open the Command Palette (`Ctrl+Shift+P` or `Cmd+Shift+P`) and run the command **`Developer: Reload Window`**.

You only need to stop the debugger (Shift+F5) and restart it (F5) if you make changes to configuration files like `package.json`. For all other code changes, simply reloading the host window is sufficient and much faster.
</file_artifact>

<file path="src/Artifacts/A8. DCE - Phase 1 - Selection Sets Feature Plan.md">
# Artifact A8: DCE - Phase 1 - Selection Sets Feature Plan
# Date Created: Cycle 11
# Author: AI Model
# Updated on: C23 (Add requirement for selection persistence)

- **Key/Value for A0:**
- **Description:** A plan outlining the user stories, UI/UX, and technical implementation for saving, loading, and persisting different sets of selected files (selection profiles).
- **Tags:** feature plan, selection sets, profiles, context management, persistence, phase 1

## 1. Overview & Goal

The goal of the "Selection Sets" feature is to address the user feedback regarding the need to save and switch between different file selections, and to ensure the current selection is not lost during a session. Users often work on multiple tasks or projects concurrently, each requiring a different context. Manually re-selecting files is tedious and losing the current selection when switching tabs is a critical usability flaw. This feature will allow users to save a named "set" of their current selections, quickly load it back later, and have their current selection state persist automatically.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| US-01 | **Selection Persistence** | As a user, I expect my current selection of checked files to remain active when I switch to another VS Code tab and then return, so my work is not lost. | - The current array of selected file paths is automatically saved to the webview's persistent state whenever it changes. <br> - When the webview is re-activated (e.g., tab is clicked), it restores the last saved selection state. |
| US-02 | **Save Current Selection** | As a developer, I want to save my currently checked files as a named set, so I don't have to re-select them manually when I switch tasks. | - A UI element (e.g., button or menu item) exists to "Save current selection". <br> - Clicking it prompts me to enter a name for the selection set. <br> - After providing a name, the current list of selected file paths is saved. <br> - I receive a confirmation that the set was saved. |
| US-03 | **Load a Saved Selection** | As a developer, I want to load a previously saved selection set, so I can quickly restore a specific context. | - A UI element (e.g., a dropdown menu) lists all saved selection sets by name. <br> - Selecting a set from the list immediately updates the file tree, checking all the files and folders from that set. <br> - Any previously checked files that are not part of the loaded set become unchecked. |
| US-04 | **Delete a Saved Selection** | As a developer, I want to delete a selection set that I no longer need, so I can keep my list of saved sets clean. | - A UI element exists to manage or delete saved sets. <br> - I can select a set to delete from a list. <br> - I am asked to confirm the deletion. <br> - Upon confirmation, the set is removed from the list of saved sets. |

## 3. Proposed UI/UX

The functionality will be consolidated into the `view-header` of our Context Chooser panel for easy access.

1.  **Header Controls:**
    *   A dropdown menu and/or a set of dedicated toolbar buttons for managing selection sets.
    *   Example: A "Save" icon button and a "Load" icon button.
    *   Clicking "Save" would trigger the save workflow.
    *   Clicking "Load" would open a Quick Pick menu of saved sets.

2.  **Saving a Set:**
    *   Clicking the "Save" button will execute the `dce.saveSelectionSet` command.
    *   This command will trigger a VS Code input box (`vscode.window.showInputBox`).
    *   The user will enter a name (e.g., "API Feature", "Frontend Refactor").
    *   On submission, the backend saves the current `selectedFiles` array under that name.

3.  **Loading a Set:**
    *   Clicking the "Load" button will execute the `dce.loadSelectionSet` command.
    *   This command shows a Quick Pick list (`vscode.window.showQuickPick`) of all saved sets.
    *   Selecting a set triggers an IPC message (`ApplySelectionSet`) to the frontend with the array of file paths for that set.
    *   The frontend updates its `selectedFiles` state, causing the tree to re-render with the new selections.

## 4. Technical Implementation Plan

1.  **State Persistence (`view.tsx`):**
    *   Define a state type in `vscode-webview.d.ts`: `interface ViewState { selectedFiles: string[] }`.
    *   In the main `App` component in `view.tsx`, use a `useEffect` hook that triggers whenever the `selectedFiles` state changes. Inside this effect, call `vscode.setState({ selectedFiles })`.
    *   On initial component mount, retrieve the persisted state using `const savedState = vscode.getState();` and if it exists, use it to initialize the `selectedFiles` state: `useState<string[]>(savedState?.selectedFiles || [])`.

2.  **Data Storage (`selection.service.ts`):**
    *   Selection sets will continue to be stored in the VS Code `workspaceState`. This is a key-value store specific to the current workspace.
    *   A single key, e.g., `dce.selectionSets`, will hold an object where keys are the set names and values are the `string[]` of absolute file paths.

3.  **IPC Channels & Commands (`commands.ts`):**
    *   The existing commands (`dce.saveSelectionSet`, `dce.loadSelectionSet`, `dce.deleteSelectionSet`) are suitable.
    *   The backend `loadSelectionSet` command will trigger the `ApplySelectionSet` IPC message to the client with the file paths.

4.  **Frontend Logic (`view.tsx`):**
    *   Add state to store the map of selection sets: `const [selectionSets, setSelectionSets] = useState({});`
    *   On mount, request the list of sets from the backend to populate any UI elements.
    *   Implement an effect to listen for `ApplySelectionSet` and call `setSelectedFiles()` with the new paths.
    *   Render the new "Save" and "Load" buttons in the header toolbar.
    *   The `onClick` handler for the "Save" button will trigger an IPC message that executes the `dce.saveSelectionSet` command, passing the current `selectedFiles` state.
</file_artifact>

<file path="src/Artifacts/A9. DCE - GitHub Repository Setup Guide.md">
# Artifact A9: DCE - GitHub Repository Setup Guide
# Date Created: Cycle 12
# Author: AI Model
# Updated on: C160 (Add sample workflow with `git restore`)

- **Description:** A step-by-step guide with the necessary git commands to initialize the project as a local repository and push it to a new remote repository on GitHub, including a sample workflow for testing AI responses.
- **Tags:** git, github, version control, setup, repository, workflow

## 1. Overview

This guide provides the necessary commands to turn your local project folder into a Git repository and link it to a new, empty repository on GitHub. It also describes a sample workflow for using Git to efficiently test multiple AI-generated responses.

## 2. Prerequisites

*   You have `git` installed on your machine.
*   You have a GitHub account.

## 3. Step-by-Step Setup

### Step 1: Create a New Repository on GitHub

1.  Go to [github.com](https://github.com) and log in.
2.  In the top-right corner, click the `+` icon and select **"New repository"**.
3.  **Repository name:** A good name would be `data-curation-environment` or `vscode-dce-extension`.
4.  **Description:** (Optional) "A VS Code extension for curating context for Large Language Models."
5.  Choose **"Private"** or **"Public"** based on your preference.
6.  **IMPORTANT:** Do **not** initialize the repository with a `README`, `.gitignore`, or `license`. We will be pushing our existing files, and this will prevent conflicts.
7.  Click **"Create repository"**.

GitHub will now show you a page with several command-line instructions. We will use the section titled **"...or push an existing repository from the command line"**.

### Step 2: Initialize Git in Your Local Project

Open a terminal (like the one integrated into VS Code) and navigate to your project's root directory (e.g., `C:\Projects\DCE`). Then, run the following commands one by one.

1.  **Initialize the repository:** This creates a new `.git` subdirectory in your project folder.
    ```bash
    git init
    ```

2.  **Add all existing files to the staging area:** The `.` adds all files in the current directory and subdirectories.
    ```bash
    git add .
    ```

3.  **Create the first commit:** This saves the staged files to the repository's history.
    ```bash
    git commit -m "Initial commit"
    ```

4.  **Rename the default branch to `main`:** This is the modern standard, replacing the older `master`.
    ```bash
    git branch -M main
    ```

### Step 3: Link and Push to GitHub

Now, you will link your local repository to the empty one you created on GitHub.

1.  **Add the remote repository:** Replace the URL with the one from your GitHub repository page. It should look like the example below.
    ```bash
    git remote add origin https://github.com/dgerabagi/data-curation-environment.git
    ```

2.  **Push your local `main` branch to GitHub:** The `-u` flag sets the upstream remote so that in the future, you can simply run `git push`.
    ```bash
    git push -u origin main
    ```

After these commands complete, refresh your GitHub repository page. You should see all of your project files. You have successfully created and linked your repository.

## 4. Sample Workflow for Testing AI Responses

Once your project is set up with Git, you can leverage it to create a powerful and non-destructive testing workflow with the DCE.

1.  **Start with a Clean State:** Make sure your working directory is clean. You can check this with `git status`. If you have any uncommitted changes, either commit them or stash them.
2.  **Generate Responses:** Use the DCE to generate a `prompt.md` file and get several responses from your AI. Paste these into the Parallel Co-Pilot Panel and parse them.
3.  **Accept a Response:** Choose the response you want to test (e.g., "Resp 1"). Select its files in the "Associated Files" list and click "Accept Selected Files". This will overwrite the files in your workspace.
4.  **Test the Changes:** Run your project's build process (`npm run watch`), check for errors, and test the functionality in the VS Code Extension Development Host.
5.  **Revert and Test the Next One:**
    *   If you're not satisfied with the changes from "Resp 1," you can instantly and safely revert all the changes by running a single command in your terminal:
        ```bash
        git restore .
        ```
    *   This command discards all uncommitted changes in your working directory, restoring your files to the state of your last commit.
6.  **Repeat:** Your workspace is now clean again. You can go back to the Parallel Co-Pilot Panel, accept the files from "Resp 2," and repeat the testing process.

This workflow allows you to rapidly test multiple complex, multi-file changes from different AI responses without the risk of permanently breaking your codebase.
</file_artifact>

<file path="src/Artifacts/A10. DCE - Metadata and Statistics Display.md">
# Artifact A10: DCE - Metadata and Statistics Display
# Date Created: Cycle 14
# Author: AI Model
# Updated on: C40 (Clarify file counter label and tooltip)

- **Key/Value for A0:**
- **Description:** Outlines the requirements and design for displaying live metadata (total selected files, total tokens) and for showing aggregate statistics (token and file counts) for folders in the file tree.
- **Tags:** feature plan, metadata, statistics, token count, ui, ux

## 1. Overview & Goal

To enhance the data curation process, it is critical for the user to have immediate, quantitative feedback on their selections. This feature will provide at-a-glance statistics at both the folder level and the overall selection level. The goal is to empower the user to make informed decisions about context size and composition without needing to perform manual calculations.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| US-01 | **Folder Statistics** | As a data curator, I want to see the total token count and the total number of files contained within each folder, so I can quickly assess the size and complexity of different parts of my project. | - Next to each folder name in the file tree, a token count is displayed. <br> - This token count is the recursive sum of all tokens from all non-image files within that folder and its subfolders. <br> - Next to the token count, a file count is also displayed, formatted with commas (e.g., "1,234"). <br> - These numbers are calculated on the backend and provided with the initial file tree data. |
| US-02 | **Live Selection Summary** | As a data curator, I want to see a live summary of my total selection as I check and uncheck files, so I can monitor the total size of my context in real-time. | - A dedicated summary panel/footer is visible in the UI. <br> - This panel displays "X files" and "Y tokens". <br> - **(C40 Update)** The label for the file count is "Selected Files". The tooltip reads: "Total number of individual files selected for flattening. This does not include empty directories." <br> - "X" is the total count of all individual files included in the current selection, formatted with commas. <br> - "Y" is the sum of all token counts for those selected non-image files. <br> - These values update instantly whenever a checkbox is changed. |
| US-03 | **Readable Numbers & Icons** | As a data curator, I want large token counts to be formatted in a compact and readable way (e.g., 1,234 becomes "1.2K"), and for icons to visually represent the data, so I can easily parse the information. | - All token counts use K/M/B suffixes for numbers over 1,000. <br> - All file counts use commas for thousands separators. <br> - An icon is displayed next to the token count and file count for visual distinction. <br> - The statistics are right-justified in the file tree for better readability. |
| US-04 | **Image File Handling** | As a data curator, I want to see the file size for images instead of a token count, so I can understand their contribution to storage/transfer size rather than context length. | - The backend identifies common image file types (png, jpg, etc.). <br> - For image files, the token count is treated as 0. <br> - In the file tree, instead of a token count, the human-readable file size is displayed (e.g., "15.2 KB", "2.1 MB"). |
| US-05 | **Selected Token Count in Folders** | As a data curator, I want to see how many tokens are selected within a folder, so I can understand the composition of my selection without expanding the entire directory. | - Next to a folder's total token count, a secondary count in parentheses `(x)` appears. <br> - `x` is the recursive sum of tokens from all selected files within that folder. <br> - The display format is `TotalTokens (SelectedTokens)`, e.g., `347K (13K)`. <br> - This count only appears if selected tokens are > 0 and less than the total tokens. |
| US-06 | **Visual Cue for Selected Tokens** | As a curator, I want a clear visual indicator on the token count itself when an item is included in the selection, so I can confirm its inclusion without looking at the checkbox. | - When an individual file is checked, its token count is wrapped in parentheses, e.g., `(168)`. <br> - When a folder is checked, and *all* of its children are included in the selection, its total token count is wrapped in parentheses, e.g., `(336)`. <br> - This complements the `Total (Selected)` format for partially selected folders. |

## 3. Technical Implementation Plan

1.  **Backend (`fs.service.ts`):**
    *   The `FileNode` interface in `src/common/types/file-node.ts` will be updated to include `isImage: boolean` and `sizeInBytes: number`.
    *   The backend service will maintain a list of image file extensions.
    *   When building the tree, it will check each file's extension.
    *   If it's an image, it will use `fs.stat` to get the `sizeInBytes`, set `isImage: true`, and set `tokenCount: 0`.
    *   If it's not an image, it will calculate the `tokenCount` and get the `sizeInBytes`.
    *   The recursive sum logic for folders will aggregate `tokenCount`, `fileCount`, and `sizeInBytes` from their children.
    *   The `vscode.workspace.findFiles` call will be updated to exclude the `node_modules` directory.

2.  **Frontend - Formatting (`formatting.ts`):**
    *   A new `formatBytes(bytes)` utility will be created to convert bytes to KB, MB, etc.
    *   A new `formatNumberWithCommas(number)` utility will be created.

3.  **Frontend - File Tree (`FileTree.tsx` & `view.scss`):**
    *   The `FileTree.tsx` component will be updated to render the new data.
    *   It will conditionally display either a formatted token count (using `formatLargeNumber`) or a formatted file size (using `formatBytes`) based on the `isImage` flag.
    *   It will display folder file counts using `formatNumberWithCommas`.
    *   **Selected Token Calculation:** A new memoized, recursive function will be created within `FileTree.tsx` to calculate the selected token count for a given directory node by checking its descendants against the `selectedFiles` prop.
    *   The rendering logic will be updated to display the `(SelectedTokens)` value conditionally.
    *   **Parenthesis Logic (US-06):** The rendering logic will be further updated. For files, it will check if the file's path is in the `selectedFiles` list. For folders, it will compare the calculated `selectedTokensInDir` with the `node.tokenCount`. Based on these checks, it will conditionally wrap the output string in parentheses.
    *   It will incorporate icons from `react-icons/vsc` for tokens and file counts.
    *   The stylesheet (`view.scss`) will be updated to right-align all statistics, pushing them to the end of the file/folder row.

4.  **Frontend - Live Summary Panel (`context-chooser.view.tsx`):**
    *   The `useMemo` hook that calculates the summary will be updated to correctly sum the total number of files and total tokens from the selected items. It will continue to ignore image sizes for the token total to avoid mixing units.
    *   The rendered output will use the new formatting utilities and icons.
    *   **(C40)** The label and title attribute will be updated for clarity.
</file_artifact>

<file path="src/Artifacts/A12. DCE - Logging and Debugging Guide.md">
# Artifact A12: DCE - Logging and Debugging Guide
# Date Created: Cycle 19
# Author: AI Model & Curator
# Updated on: C185 (Mandate truncated logging for large data)

- **Key/Value for A0:**
- **Description:** Explains how to access and use the integrated logging solution for debugging the extension's backend and frontend components.
- **Tags:** logging, debugging, troubleshooting, development, output channel

## 1. Purpose

This document provides instructions on how to access and use the logging features built into the Data Curation Environment (DCE) extension. Effective logging is crucial for diagnosing performance issues, tracking down bugs, and understanding the extension's behavior during development.

## 2. Two Primary Log Locations

There are two separate places to look for logs, depending on where the code is running.

### Location 1: The "Debug Console" (For `console.log`)

This is where you find logs from the **backend** (the extension's main Node.js process).

-   **What you'll see here:** `console.log()` statements from files in `src/backend/` and `src/extension.ts`. This is useful for debugging the extension's core activation and services *before* the UI is even visible.
-   **Where to find it:** In your **main development window** (the one where you press `F5`), look in the bottom panel for the **"DEBUG CONSOLE"** tab.

    ```
    -----------------------------------------------------------------------------------
    | PROBLEMS    OUTPUT    DEBUG CONSOLE    TERMINAL                                 |
    |---------------------------------------------------------------------------------|
    |                                                                                 |
    |  > Congratulations, your extension "Data Curation Environment" is now active!   |
    |  > FSService watcher initialized.                                               |
    |  ...                                                                            |
    -----------------------------------------------------------------------------------
    ```

### Location 2: The "Output" Channel (For Centralized Logging)

This is the primary, centralized log for the entire extension, including messages from the **frontend (WebView)**.

-   **What you'll see here:** Formatted log messages from both the backend (`LoggerService`) and the frontend (`logger.ts`). All messages are prefixed with a level (`[INFO]`, `[WARN]`, `[ERROR]`) and a timestamp. Frontend messages are also prefixed with `[WebView]`.
-   **Where to find it:** In the **"[Extension Development Host]" window** (the new window that opens after you press `F5`), follow these steps:
    1.  **Open the Panel:** Press `Ctrl+J` (or `Cmd+J` on Mac).
    2.  **Navigate to the "OUTPUT" Tab.**
    3.  In the dropdown menu on the right, select **`Data Curation Environment`**.

    ```
    -----------------------------------------------------------------------------------
    | PROBLEMS    OUTPUT    DEBUG CONSOLE    TERMINAL                                 |
    |---------------------------------------------------------------------------------|
    |                                                 [Data Curation Environment v]   |
    |                                                                                 |
    |  [INFO] [2:30:00 PM] Services initialized.                                      |
    |  [INFO] [2:30:01 PM] Received request for workspace files.                      |
    |  [INFO] [2:30:01 PM] [WebView] Initializing view and requesting workspace files.|
    |  [INFO] [2:30:01 PM] Scanning for files with exclusion pattern: ...             |
    |  ...                                                                            |
    -----------------------------------------------------------------------------------
    ```

## 3. Tactical Debugging with Logs (C93)

When a feature is not working as expected, especially one that involves communication between the frontend and backend, the most effective debugging technique is to add **tactical logs** at every step of the data's journey.

### Case Study: Fixing the "Associated Files" Parser (Cycle 93)

-   **Problem:** The UI was incorrectly reporting that files from a parsed AI response did not exist in the workspace.
-   **Data Flow:**
    1.  **Frontend (`view.tsx`):** User clicks "Parse All".
    2.  **Frontend (`response-parser.ts`):** Raw text is parsed into a list of relative file paths (e.g., `src/main.ts`).
    3.  **IPC (`RequestFileExistence`):** The list of relative paths is sent to the backend.
    4.  **Backend (`fs.service.ts`):** The backend receives the list and compares it against its own list of known workspace files, which are stored as absolute paths (e.g., `c:/project/src/main.ts`). The comparison fails.

## 4. Truncated Logging for Large Content (C185)

To prevent the output channel from becoming overwhelmed with large blocks of text (e.g., entire file contents or full AI responses), a logging utility has been implemented to truncate long strings.

-   **Behavior:** When a service logs a large piece of content (like a code block for syntax highlighting or the entire application state), it **must** use the `truncateCodeForLogging` utility.
-   **Format:** If a string is longer than a set threshold, it will be displayed in the logs in a format like this:
    `[First 15 lines]...// (content truncated) ...[Last 15 lines]`
-   **Benefit:** This keeps the logs clean and readable, allowing you to see that a large piece of data was processed without having its entire content flood the output. You can still see the beginning and end of the content to verify its identity.
</file_artifact>

<file path="src/Artifacts/A13. DCE - Phase 1 - Right-Click Context Menu.md">
# Artifact A13: DCE - Phase 1 - Right-Click Context Menu
# Date Created: C19
# Author: AI Model
# Updated on: C131 (Add Create File action for non-existent associated files)

- **Key/Value for A0:**
- **Description:** A plan for implementing standard file explorer context menu actions (e.g., Rename, Delete, Copy Path) in the custom file tree and other UI lists.
- **Tags:** feature plan, context menu, right-click, file operations, ux, phase 1

## 1. Overview & Goal

To enhance the user experience and make the Data Curation Environment a more complete replacement for the native VS Code explorer, this feature adds standard right-click context menus. The goal is to provide essential file and list management operations directly within our extension's view, reducing the need for users to switch contexts for common tasks.

This plan covers three distinct context menus: one for the main file tree, one for the "Selected Items" list, and one for the "Associated Files" list in the Parallel Co-Pilot Panel.

## 2. Main File Tree Context Menu

| ID | User Story | Acceptance Criteria |
|---|---|---|
| US-01 | **Copy Path** | As a user, I want to right-click a file or folder and copy its absolute or relative path to my clipboard, so I can easily reference it elsewhere. | - Right-clicking a node in the file tree opens a context menu. <br> - The menu contains "Copy Path" and "Copy Relative Path" options. <br> - Selecting an option copies the corresponding path string to the system clipboard. |
| US-02 | **Rename File/Folder** | As a user, I want to right-click a file or folder and rename it, so I can correct mistakes or refactor my project structure. | - The context menu contains a "Rename" option. <br> - Selecting it turns the file/folder name into an editable input field. <br> - Pressing Enter or clicking away saves the new name. <br> - The underlying file/folder is renamed on the file system. <br> - The file tree updates to reflect the change. |
| US-03 | **Delete File/Folder** | As a user, I want to right-click a file or folder and delete it, so I can remove unnecessary files from my project. | - The context menu contains a "Delete" option. <br> - Selecting it shows a confirmation dialog to prevent accidental deletion. <br> - Upon confirmation, the file or folder (and its contents, recursively) is moved to the trash/recycling bin. <br> - The file tree updates to reflect the change. |
| US-04 | **Reveal in OS Explorer** | As a user, I want to right-click a file or folder and have it revealed in the native OS file explorer, so I can interact with it outside of VS Code. | - The context menu contains a "Reveal in File Explorer" (or "Reveal in Finder" on macOS) option. <br> - Selecting it opens the parent directory of the item in the **operating system's default file manager** (e.g., Windows File Explorer) with the item selected. This should not simply switch to the VS Code Explorer tab. |
| US-05 | **New File/Folder** | As a user, I want to create new files and folders from the toolbar or context menu in the correct location, so I can build out my project structure without leaving the view. | - The header toolbar has "New File" and "New Folder" buttons. <br> - Clicking either prompts for a name. <br> - The new file/folder is created in the directory of the currently *active/highlighted* item in the tree. <br> - If the active item is a file, the new item is created in that file's parent directory. <br> - If no item is active, it defaults to the workspace root. <br> - The file tree automatically refreshes. |

## 3. "Selected Items" Panel Context Menu

| ID | User Story | Acceptance Criteria |
|---|---|---|
| US-06 | **Select All/Deselect All** | As a user, I want to right-click in the "Selected Items" panel to quickly select or deselect all items in the list, so I can perform batch removal operations more efficiently. | - Right-clicking anywhere within the list of selected files opens a context menu. <br> - The menu contains a "Select All" option. <br> - Clicking "Select All" highlights every item in the list, updating the "Remove selected" button count. <br> - The menu also contains a "Deselect All" option. <br> - Clicking "Deselect All" clears all selections in the list. |

## 4. "Associated Files" List Actions (C131)

| ID | User Story | Acceptance Criteria |
|---|---|---|
| US-07 | **Create Missing File** | As a developer, when an AI response refers to a file that doesn't exist, I want an easy way to create it directly from the "Associated Files" list, so I can quickly implement the AI's suggestion for a new file. | - In the "Associated Files" list, a file that does not exist is marked with an '✗'. <br> - When I hover over this item, a "Create File" button appears next to it. <br> - Clicking the button creates a new, empty file at that path in the workspace. <br> - The file tree and the "Associated Files" list automatically refresh, and the indicator changes to a '✓'. |

## 5. Technical Implementation Plan

-   **Main Tree Menu:** Implemented in `TreeView.tsx` and `ContextMenu.tsx` using an `onContextMenu` event handler and state management to control visibility and position.
-   **"Selected Items" Menu (C37):** Implemented in `SelectedFilesView.tsx` with its own context menu state and handlers for "Select All" / "Deselect All".
-   **"Create Missing File" Action (C131):**
    1.  **IPC:** Create a new `ClientToServerChannel.RequestCreateFile` channel with a payload of `{ filePath: string }`.
    2.  **Backend (`file-operation.service.ts`):** Implement `handleCreateFileRequest`. It will receive the relative path, resolve it to an absolute path, and use `vscode.workspace.fs.writeFile` with an empty `Uint8Array` to create the file. The file watcher will trigger a refresh.
    3.  **Frontend (`view.tsx`):** In the "Associated Files" list rendering logic, if a file does not exist (`!fileExistenceMap.get(file)`), render a "Create File" button. The button will be visible on hover. Its `onClick` handler will send the new IPC message.
</file_artifact>

<file path="src/Artifacts/A14. DCE - Ongoing Development Issues.md">
# Artifact A14: DCE - Ongoing Development Issues
# Date Created: C20
# Author: AI Model & Curator
# Updated on: C23 (Add issues for selection persistence and remove button)

- **Key/Value for A0:**
- **Description:** A tracking document for recurring or persistent issues that need to be monitored across development cycles until they are confirmed as resolved.
- **Tags:** bugs, tracking, issues, logging, node_modules, performance

## 1. Purpose

This artifact serves as a centralized list to track ongoing and recurring issues during the development of the Data Curation Environment (DCE) extension. This ensures that persistent problems are not forgotten and are actively monitored across cycles until a definitive solution is implemented and verified.

## 2. Active Issues

---

### Issue #5: Selection State is Not Persistent

-   **Symptom:** When the user makes selections in the "Data Curation" view, then switches to another VS Code tab and back, all selections are lost.
-   **First Reported:** Cycle 23
-   **Status (C23):** **Active.** The frontend state for `selectedFiles` is not being persisted in the VS Code `workspaceState`.
-   **Next Steps (C23):** Implement a mechanism to save the `selectedFiles` array to `workspaceState` on every change and load it when the view is initialized. This will involve both frontend (`view.tsx`) and backend (`selection.service.ts`) changes.

---

### Issue #6: "Remove selected" Button is Non-Functional

-   **Symptom:** In the "Selected Items" view, selecting one or more files and clicking the "Remove selected" button does not remove them from the list or from the main selection. It also causes the file tree in the main view to collapse.
-   **First Reported:** Cycle 23
-   **Status (C23):** **Active.** The logic in `removePathsFromSelected` or the way its result is being used to update the state is flawed. The tree collapsing indicates an improper state update is causing a major re-render.
-   **Next Steps (C23):** Debug the `removePathsFromSelected` function in `FileTree.utils.ts`. Add logging to the `onClick` handler in `SelectedFilesView.tsx` to trace the data flow. Fix the state update to prevent the side-effect of collapsing the tree.

---

### Issue #1: Logging Visibility

-   **Symptom:** The custom "Data Curation Environment" output channel is not visible in the "OUTPUT" tab's dropdown menu in the Extension Development Host window. This prevents the primary logging mechanism from being used for debugging.
-   **First Reported:** Cycle 19
-   **Status (C23):** **Resolved (C21).** The issue was caused by an early-exit error during extension activation. Adding robust `try...catch` blocks around service initializations in `extension.ts` allowed the extension to fully load, making the output channel visible.

---

### Issue #2: `node_modules` Exclusion and Performance

-   **Symptom:** The `node_modules` directory is included in file tree scans, leading to incorrect file and token counts and a significant performance delay.
-   **First Reported:** Cycle 15 (and earlier)
-   **Status (C23):** **Resolved (C20).** The `vscode.workspace.findFiles` call in `fs.service.ts` was updated with a more robust glob pattern `'{**/node_modules/**,**/dist/**,**/out/**,**/.git/**,**/flattened_repo.md}'` which now correctly excludes these directories.

---

### Issue #3: Incorrect Image Token Counting

-   **Symptom:** Image files are being assigned a token count instead of displaying their file size.
-   **First Reported:** Cycle 18
-   **Status (C23):** **Resolved (C20).** The logic in `fs.service.ts` was corrected to identify images by extension, set `tokenCount` to 0, and get their `sizeInBytes`. The frontend (`FileTree.tsx`) now uses an `isImage` flag to display the formatted byte size instead of tokens.

---

### Issue #4: File Tree Caching and Refresh Behavior

-   **Symptom:** The file tree reloaded from scratch on every tab switch and did not auto-update on file changes.
-   **First Reported:** Cycle 19
-   **Status (C23):** **Resolved (C20).** A frontend cache was implemented by changing the `useEffect` dependency array. A backend `FileSystemWatcher` was implemented in `fs.service.ts` to detect changes and push updates to the client, triggering a refresh.
</file_artifact>

<file path="src/Artifacts/A15. DCE - Phase 1 - Multi-Select & Sorting Feature Plan.md">
# Artifact A15: DCE - Phase 1 - Multi-Select & Sorting Feature Plan
# Date Created: Cycle 22
# Author: AI Model
# Updated on: C40 (Documented RCA and fix for batch removal bug)

- **Key/Value for A0:**
- **Description:** Details the requirements for multi-selection (click, Ctrl, Shift) in both the main file tree and the "Selected Items" panel, and multi-level column sorting.
- **Tags:** feature plan, multi-select, sorting, list view, ux, phase 1

## 1. Overview & Goal

To elevate the Data Curation Environment beyond basic functionality, this plan introduces advanced list-interaction features common in modern applications. The goal is to provide users with powerful and intuitive tools for managing their file selections, mirroring the behavior of native operating system file explorers. This includes robust multi-selection capabilities in both the main file tree and the "Selected Items" panel, and comprehensive sorting for the "Selected Items" list.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| US-01 | **"Selected Items" Multi-Selection** | As a curator, after selecting a large folder, I want to quickly remove a small group of unwanted files from the "Selected Items" list using standard Shift-click and Ctrl-click, so I don't have to uncheck them one by one in the main tree. | - Clicking a single item in the "Selected Items" list selects it and deselects all others. <br> - Ctrl-clicking an item toggles its selection state without affecting other items. <br> - Shift-clicking an item selects the range of items between the last-clicked anchor item and the current one. The anchor is set by the last non-Shift click. <br> - A "Remove Selected" button acts on all currently selected items in this list. |
| US-02 | **"Selected Items" Column Sorting** | As a curator, I want to sort the "Selected Items" list by file name or token count, so I can easily find specific files or identify the largest contributors to my context. | - The "Selected Items" panel has a header row with clickable "File" and "Tokens" labels. <br> - Clicking a column header sorts the list by that column. <br> - Clicking the same header again reverses the sort direction (ascending/descending). <br> - A visual indicator (e.g., an arrow) shows the current sort column and direction. <br> - The default, initial sort is by Token Count, descending. |
| US-03 | **"Selected Items" Multi-Layer Sorting** | As a curator, I want to apply a secondary sort, so I can group my selected files by type and then see the largest files within each group. | - The sorting mechanism supports at least two levels of sorting. <br> - The UI provides a way to define a primary and secondary sort key (e.g., Shift-clicking a second column header). <br> - The list first organizes by the primary key, then sorts items within those groups by the secondary key. For example, sort by Type (asc), then by Token Count (desc). |
| US-04 | **Main Tree Multi-Selection** | As a user, I want to select multiple files and folders in the main "Data Curation" file tree using standard OS conventions (Ctrl/Shift click), so I can perform context menu actions (like Delete) on multiple items at once. | - Standard multi-selection is implemented in the main file tree. <br> - This selection is a separate state from the checkbox state and is used for contextual actions, not for flattening. <br> - Right-clicking on any item within a multi-selected group opens a context menu that applies its actions to all selected items. <br> - **(Bug C31):** Ctrl-click is non-functional. Shift-click is inconsistent and difficult to use. |
| US-05 | **"As-Is" Sorting** | As a user, I want to be able to revert the "Selected Items" list to its default sort order, so I can see the files as they appear in the native VS Code explorer. | - A sort option for "Default" or "As-Is" is available. <br> - Selecting it sorts the items based on their original file system order (folders first, then files, all alphabetized). |

## 3. Technical Implementation Plan

1.  **`SelectedFilesView.tsx` Refactor:**
    *   **State Management:** Introduce new state variables to manage selection, sorting, and multi-selection.
        *   `const [selection, setSelection] = useState<Set<string>>(new Set());`
        *   `const [selectionAnchor, setSelectionAnchor] = useState<string | null>(null);` // For stable shift-click
        *   `const [sortConfig, setSortConfig] = useState<{ key: string; direction: 'asc' | 'desc' }[]>([{ key: 'tokenCount', direction: 'desc' }]);`
    *   **Event Handling:** Implement a comprehensive `onClick` handler for list items that inspects `event.ctrlKey` and `event.shiftKey`. A non-modifier click will set both the `selection` and the `selectionAnchor`. A shift-click will select from the `selectionAnchor` to the current item.
    *   **Sorting Logic:** The `useMemo` hook that sorts the `selectedFileNodes` prop will be updated to handle an array of `sortConfig` objects. It will perform a stable sort, iterating through the sort criteria until a non-zero comparison result is found. A new "Type" column will be added, requiring a utility to extract the file extension.

2.  **Batch Removal Logic (`FileTree.utils.ts`):**
    *   **Root Cause of C40 Bug:** The `removePathsFromSelected` function was buggy. It iterated through the list of files to remove, calling the single-item removal utility (`addRemovePathInSelectedFiles`) on each. This created a race condition where the first removal would perform a "subtractive uncheck" (e.g., removing `src` and adding back all its other children), drastically changing the selection state that subsequent iterations of the loop were relying on.
    *   **Codified Solution (C40):** The `removePathsFromSelected` function will be rewritten to be non-iterative and set-based. It will calculate the final desired state in a single pass by determining the full set of effectively selected files, removing the unwanted files from that set, and then "compressing" the remaining set of files back into the most efficient list of parent directories and individual files. This atomic approach is more robust and avoids the state mutation bug.

3.  **`FileTree.tsx` & `TreeView.tsx` (Main Tree Multi-Select):**
    *   This is a more complex task that mirrors the `SelectedFilesView` implementation but within a recursive tree structure.
    *   A new selection state for contextual actions (`const [contextSelection, setContextSelection] = useState<Set<string>>(new Set())`) will be managed at the top level (`view.tsx`).
    *   The selection state and handler functions will need to be passed down through `FileTree` to `TreeView`.
    *   **(Fix for C31):** The `handleNodeClick` event handler in `TreeView.tsx` must be corrected. The anchor for shift-click (`lastClickedPath`) must only be updated on a click *without* the Shift key pressed. The logic for Ctrl-click must be revised to correctly toggle a path's inclusion in the selection set without clearing other selections.
    *   The `onContextMenu` handler will need to be updated to check if the right-clicked node is part of the current `contextSelection` and pass the entire selection to the backend if an action is chosen.
</file_artifact>

<file path="src/Artifacts/A16. DCE - Phase 1 - UI & UX Refinements Plan.md">
# Artifact A16: DCE - Phase 1 - UI & UX Refinements Plan
# Date Created: Cycle 22
# Author: AI Model
# Updated on: C187 (Add Associated Files animation glitch)

- **Key/Value for A0:**
- **Description:** Covers visual and usability improvements like fixing panel layouts, resolving overflow bugs, adding loading indicators, and improving scrollbar visibility.
- **Tags:** feature plan, ui, ux, layout, bug fix, loading indicator, phase 1

## 1. Overview & Goal

This document outlines a series of user interface (UI) and user experience (UX) refinements identified during playtesting. The goal is to address layout bugs, provide better visual feedback to the user, and improve the overall professional feel of the extension. These changes focus on fixing immediate usability problems and making the extension more intuitive to operate.

## 2. User Stories & Issues

| ID | User Story / Issue | Acceptance Criteria |
|---|---|---|
| UI-01 | **Header Layout Bug** | As a user, I want the header of the "Data Curation" panel to be compact, without the extra vertical space between the title and the toolbar buttons, so it looks clean and professional. | - The vertical gap between the view title row and the toolbar button row is removed. <br> - The header area takes up minimal vertical space. <br> - This is a CSS fix, likely involving adjusting `padding`, `margin`, or `gap` in the flex container. |
| UI-02 | **"Selected Items" Overflow Bug** | As a user, when I select many files, I want the "Selected Items" list to scroll within its panel instead of running off the screen behind the "Flatten Context" footer, so I can see and manage all my selections. | - The "Selected Items" panel has a defined `max-height`. <br> - When the content exceeds this height, a vertical scrollbar appears. <br> - The panel never overlaps or pushes the footer out of view. <br> - This is a CSS fix involving `flex-grow`, `flex-shrink`, `min-height: 0` on the file tree container, and `overflow-y: auto` on the list container. |
| UI-03 | **Resizable "Selected Items" Panel** | As a user, I want to be able to vertically resize the "Selected Items" panel, so I can see more or fewer items as needed for my current task. | - A draggable handle or resizer element is added to the top border of the "Selected Items" panel. <br> - Clicking and dragging this handle adjusts the `height` or `max-height` of the panel. <br> - The main file tree above it resizes accordingly to fill the remaining space. |
| UI-04 | **Visible Loading State** | As a user, when I perform a slow action like renaming a file or refreshing the explorer, I want to see a loading indicator, so I have clear feedback that the system is working and not frozen. | - A loading state (e.g., `isLoading`) is added to the main view's state. <br> - This state is set to `true` when a file system scan begins (e.g., on initial load or refresh). <br> - A loading indicator (e.g., a spinning icon) is displayed in the UI (e.g., in the header toolbar) while `isLoading` is true. <br> - The state is set to `false` when the file data is received from the backend. |
| UI-05 | **Improved Scrollbar Gutter** | As a user, I find it difficult to distinguish between the extension's internal scrollbar and the main VS Code scrollbar when they are side-by-side. I want a clearer visual separation between them. | - A subtle vertical border (`border-right`) is added to the main file tree container. <br> - This creates a persistent, visible dividing line between the two scrollable areas, making it easier to position the mouse. |
| UI-06 | **Expand All Button** | As a user, I want an "Expand All" button in the toolbar, so I can quickly see all files in the project without manually clicking every folder. | - An "Expand All" button is added to the main header toolbar. <br> - Clicking it expands every collapsed folder in the file tree. <br> - The button complements the existing "Collapse All" button. |
| UI-07 | **Associated Files Animation Glitch** | As a user, I want the animated highlight on the "Associated Files" panel to be fully visible, so the guided workflow is clear. | - The top and left edges of the pulsing blue highlight are currently slightly obscured. <br> - A small `margin` will be added to the `.collapsible-section-inner` class to provide space for the `box-shadow` to render completely. |
</file_artifact>

<file path="src/Artifacts/A17. DCE - Phase 1 - Advanced Tree View Features.md">
# Artifact A17: DCE - Phase 1 - Advanced Tree View Features
# Date Created: Cycle 22
# Author: AI Model

- **Key/Value for A0:**
- **Description:** Outlines the plan for advanced tree view interactions, specifically the implementation of scrollable, self-contained views for large, expanded folders.
- **Tags:** feature plan, tree view, ux, scrollable, phase 1

## 1. Overview & Goal

The current file tree view expands vertically, which can create a poor user experience when a folder containing hundreds of files is opened. The entire view becomes excessively long, forcing the user to scroll a great distance to see files or folders below the expanded one. The goal of this feature is to innovate on the traditional tree view by containing the contents of a large expanded folder within a scrollable, "inline" window, preventing the main view from becoming unmanageable.

## 2. User Story

| ID | User Story | Acceptance Criteria |
|---|---|---|
| TV-01 | **Contained Folder Expansion** | As a user, when I expand a folder with a large number of children, I want its contents to appear in a scrollable sub-panel within the tree instead of pushing all subsequent items down, so I can browse the folder's contents without losing my place in the main file tree. | - When a folder is expanded, the extension checks the number of direct children. <br> - If the child count exceeds a certain threshold (e.g., 50), the children are rendered inside a nested, scrollable `div`. <br> - This `div` has a fixed `max-height`. <br> - A small 'x' icon is visible within this sub-panel. Clicking it closes the sub-panel and reverts the folder to the standard, fully expanded view for that session. |

## 3. Technical Implementation Plan

This is a significant UI/UX enhancement and will require careful implementation within the React component hierarchy.

1.  **Component (`TreeView.tsx`):**
    *   The core logic will reside in the `renderTreeNodes` function.
    *   **Threshold Check:** When rendering a directory node, check `if (node.children && node.children.length > FOLDER_CONTENT_THRESHOLD)`. The threshold will be a configurable constant.
    *   **State Management:** A new state variable will be needed to track which "large" folders have been reverted to the standard view by the user clicking the 'x' button. `const [standardViewFolders, setStandardViewFolders] = useState<Set<string>>(new Set());`
    *   **Conditional Rendering:**
        *   If the folder is expanded (`isExpanded`) AND its path is **not** in `standardViewFolders` AND it exceeds the threshold, render the children inside a special container:
            ```jsx
            <div className="large-folder-container" style={{ maxHeight: '300px', overflowY: 'auto' }}>
              <button onClick={() => setStandardViewFolders(prev => new Set(prev).add(node.absolutePath))}>X</button>
              <ul>{renderTreeNodes(node.children)}</ul>
            </div>
            ```
        *   Otherwise, render the children normally as is currently done:
            ```jsx
            <ul className="treenode-children">{renderTreeNodes(node.children)}</ul>
            ```

2.  **Styling (`view.scss`):**
    *   Create styles for `.large-folder-container`.
    *   It will need `position: relative`, a subtle `border` or `background-color` to distinguish it from the rest of the tree.
    *   The close button will need to be positioned appropriately within the container.

3.  **Performance Considerations:**
    *   This approach avoids virtualizing the entire tree, which is much more complex. It only contains the content of single, large folders.
    *   Rendering hundreds of nodes within the scrollable container might still have a minor performance impact on initial render, but it will be contained and will not affect the performance of the main tree's scrolling.
</file_artifact>

<file path="src/Artifacts/A18. DCE - Phase 1 - Active File Sync Feature Plan.md">
# Artifact A18: DCE - Phase 1 - Active File Sync Feature Plan
# Date Created: Cycle 24
# Author: AI Model
# Updated on: C44 (Add logic for suppressing auto-reveal after file operations)

- **Key/Value for A0:**
- **Description:** Details the requirements and implementation for automatically revealing and highlighting the active editor's file in the custom Data Curation file tree.
- **Tags:** feature plan, active file, sync, reveal, tree view, ux, phase 1

## 1. Overview & Goal

To create a more seamless and integrated experience, the Data Curation Environment's file tree should stay in sync with the user's focus in the main editor. Currently, selecting a file in the editor does not reflect in our custom view. The goal of this feature is to replicate the behavior of the native VS Code Explorer, where the active file is automatically revealed and highlighted in the file tree.

## 2. User Story

| ID | User Story | Acceptance Criteria |
|---|---|---|
| UX-01 | **Sync with Active Editor** | As a user, when I click on a file in the VS Code editor tabs or the native Explorer, I want the "Data Curation" file tree to automatically scroll to and highlight that file, so I can easily see its location in the project hierarchy and interact with its checkbox without manually searching for it. | - When the active text editor changes in VS Code, the new file is highlighted in the "Data Curation" tree view. <br> - All parent folders of the active file are automatically expanded to ensure it is visible. <br> - The file tree view scrolls so that the active file item is visible on the screen. |
| UX-02 | **Preserve View State** | As a user, after I perform an action that collapses the tree (e.g., "Collapse All") and then perform a file operation (e.g., drag-and-drop), I do not want the tree to automatically re-expand to reveal the active file, so my intended view state is respected. | - After a file operation (move, delete, rename, new file) triggers a refresh, the "Sync with Active Editor" feature is temporarily suppressed for the next event. <br> - This prevents the tree from re-expanding against the user's will. |

## 3. Technical Implementation Plan

1.  **Backend Listener (`extension.ts`):**
    *   Utilize the `vscode.window.onDidChangeActiveTextEditor` event listener in the `activate` function.
    *   This event provides the `TextEditor` object, from which `editor.document.uri.fsPath` can be extracted.
    *   When the event fires and an editor is present, the backend will normalize the file path (to use forward slashes) and send an IPC message to the webview containing the active file's path.

2.  **IPC Channel:**
    *   The existing `ServerToClientChannel.SetActiveFile` will be used.
    *   **(C44 Update)** The `ServerToClientChannel.ForceRefresh` channel's payload is updated from `{}` to `{ reason?: 'fileOp' | 'manual' }`.

3.  **Frontend View Logic (`TreeView.tsx`):**
    *   A `useEffect` hook in the `TreeView` component triggers whenever the `activeFile` prop changes.
    *   This effect is responsible for "revealing" the file by calculating all parent directory paths, adding them to the `expandedNodes` state, and then calling `scrollIntoView()` on the file's element ref.

4.  **Auto-Reveal Suppression Logic (C44):**
    *   **Backend (`fs.service.ts`):** The file watcher, upon detecting a change, will now send the `ForceRefresh` message with a payload: `{ reason: 'fileOp' }`.
    *   **Frontend (`view.tsx`):**
        *   A `useRef` flag (`suppressActiveFileReveal`) is used to track the suppression state.
        *   The message handler for `ForceRefresh` checks for the `fileOp` reason and sets the suppression flag to `true`, with a timeout to reset it.
        *   The message handler for `SetActiveFile` checks the flag. If `true`, it ignores the event, resets the flag, and prevents the `activeFile` state from being updated, thus preventing the reveal.

## 5. Debugging Notes & Regression Prevention

-   **Root Cause of C30 Regression:** The feature failed because of a path normalization mismatch. The `editor.document.uri.fsPath` property from the VS Code API returns paths with **backslashes (`\`)** on Windows. The frontend webview components, however, exclusively use and expect **forward slashes (`/`)** for path comparisons and manipulations.
-   **Codified Solution:** The path from the `onDidChangeActiveTextEditor` event **must** be normalized to use forward slashes *before* it is sent to the frontend via the IPC channel.
</file_artifact>

<file path="src/Artifacts/A19. DCE - Phase 1 - Double-Click & Quick-Remove Feature Plan.md">
# Artifact A19: DCE - Phase 1 - File Interaction Plan (Click & Remove)
# Date Created: Cycle 26
# Author: AI Model
# Updated on: C28 (Changed interaction model from double-click to single-click to open files)

- **Key/Value for A0:**
- **Description:** Details the requirements for opening files by single-clicking them and quickly removing single files from the selection list via a mouse-over action.
- **Tags:** feature plan, single-click, open file, quick remove, ux, phase 1

## 1. Overview & Goal

To further align the Data Curation Environment with standard, intuitive user workflows, this plan introduces two high-impact interaction enhancements. The first is the ability to **single-click** any file to open it in the main editor, mimicking the native VS Code Explorer behavior. The second is a "quick-remove" feature in the "Selected Items" panel, allowing for rapid, single-click removal of files. The goal is to reduce friction and increase the speed at which a user can curate their context.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| UX-01 | **Single-Click to Open (Main Tree)** | As a user, I want to be able to single-click on a file in the main "Data Curation" file tree and have it open in the editor, so I can quickly view its contents just like in the native Explorer. | - A single click on a file item (not a folder) in the main file tree opens that file in the main VS Code editor pane. <br> - If the file is already open in a tab, the editor switches focus to that tab. <br> - A single click on a folder still expands or collapses it. |
| UX-02 | **Single-Click to Open (Selected List)** | As a user, I want to single-click a file in the "Selected Items" list to open it, so I can easily inspect the files that are contributing the most tokens to my context. | - A single click on a file item in the "Selected Items" list opens that file in the main VS Code editor pane. <br> - If the file is already open, focus is switched to its tab. |
| UX-03 | **Quick Remove from Selection** | As a user, after selecting a large folder, I want to quickly remove a single file from the "Selected Items" list with one click, so I don't have to select it and then click the "Remove Selected" button. | - In the "Selected Items" list, when I mouse over a file row, the row number (in the `#` column) is replaced by an 'X' icon. <br> - Clicking the 'X' icon immediately removes that single file from the selection. <br> - This action is equivalent to selecting only that file and clicking "Remove Selected". <br> - The mouse leaving the row restores the row number. |

## 3. Technical Implementation Plan

1.  **IPC Channel (`channels.enum.ts`, `channels.type.ts`):**
    *   The existing `ClientToServerChannel.RequestOpenFile` is sufficient.
    *   The `ChannelBody` remains `{ path: string }`.

2.  **Backend Handler (`on-message.ts`, `fs.service.ts`):**
    *   The existing handler for `RequestOpenFile` in `fs.service.ts` is sufficient. It uses `vscode.workspace.openTextDocument` and `vscode.window.showTextDocument`.

3.  **Frontend - Single-Click (`TreeView.tsx`, `SelectedFilesView.tsx`):**
    *   In `TreeView.tsx`, the main `onClick` handler (`handleToggleNode`) will be modified. It will now check if the clicked node is a file or a directory.
        *   If it's a file, it will call `clientIpc.sendToServer(ClientToServerChannel.RequestOpenFile, ...)`.
        *   If it's a directory, it will perform the existing expand/collapse logic.
    *   In `SelectedFilesView.tsx`, the `onDoubleClick` handler will be removed and the `onClick` handler will be simplified to *only* open the file, as the multi-selection logic is handled by checking for modifier keys (`ctrlKey`, `shiftKey`).

4.  **Frontend - Quick Remove (`SelectedFilesView.tsx`, `view.scss`):**
    *   **State:** A state variable will track the hovered item's path: `const [hoveredPath, setHoveredPath] = useState<string | null>(null);`.
    *   **Event Handlers:** Add `onMouseEnter` and `onMouseLeave` to the `<li>` element to update the hover state.
    *   **Conditional Rendering:** In the JSX for the index column, render conditionally: if the row is hovered, show an 'X' icon with an `onClick` handler; otherwise, show the row number.
    *   **Styling:** Add styles for the `.quick-remove` class in `view.scss` to ensure it's clickable and has appropriate hover effects.
    *   The `onClick` handler for the 'X' icon will call the existing `onRemove` prop and use `stopPropagation` to prevent the click from also selecting the row.
</file_artifact>

<file path="src/Artifacts/A20. DCE - Phase 1 - Advanced UX & Automation Plan.md">
# Artifact A20: DCE - Phase 1 - Advanced UX & Automation Plan
# Date Created: C27
# Author: AI Model
# Updated on: C73 (Adjust token count color scheme to make red the highest risk)

- **Key/Value for A0:**
- **Description:** Details plans for several UX enhancements, including auto-revealing the flattened file, showing selected counts in folder stats, and providing an option to auto-add new files to the selection.
- **Tags:** feature plan, ux, automation, reveal, statistics, auto-add, phase 1

## 1. Overview & Goal

This document outlines a series of advanced user experience (UX) and automation features designed to further streamline the data curation workflow. The goal is to reduce manual steps, provide more insightful contextual information, and make the extension's UI more flexible and powerful.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| UXA-01 | **Auto-Reveal Flattened File** | As a user, after I click "Flatten Context," I want the newly created `flattened_repo.md` file to be automatically selected and revealed in the file tree, so I can immediately open it without searching. | - After the `flattened_repo.md` file is created or updated, it becomes the `activeFile` in the Data Curation view. <br> - The tree view automatically expands and scrolls to show the `flattened_repo.md` file. |
| UXA-02 | **Contextual Selected Count** | As a user, when I have files selected inside a folder, I want to see a count of how many files are selected within that folder, displayed next to the folder's total file count, so I can understand my selection density at a glance. | - Next to a folder's total file count, a secondary count in parentheses `(x)` appears. <br> - `x` represents the number of files within that folder (recursively) that are part of the current selection. <br> - This count only appears if `x` is greater than 0 and less than the folder's total file count. |
| UXA-03 | **Minimize Selection Panel** | As a user, once I've made my selection, I want to minimize the "Selected Items" list to reclaim vertical space while keeping the "Flatten Context" button accessible, so I can focus on the main file tree. | - A minimize/expand button is present in the "Selected Items" panel header. <br> - Clicking it collapses the list of selected files, but the panel's header, toolbar, and the main footer (with the Flatten button) remain visible. <br> - Clicking it again expands the list to its previous state. |
| UXA-04 | **Auto-Add New Files** | As a user, I want to enable an "auto-add" mode where any new file I create in the workspace is automatically added to my current selection, so I don't have to break my coding flow to manually check the new file. | - A toggle button or checkbox exists in the UI to enable/disable "Auto-Add New Files" mode. <br> - When enabled, any file created in the workspace is automatically added to the `selectedFiles` list. <br> - The file system watcher is responsible for detecting file creation and triggering this logic. <br> - The state of this toggle is persisted in the workspace state. |
| UXA-05 | **Resizable Panels** | As a user, I want to be able to click and drag the divider between the main file tree and the "Selected Items" panel to vertically resize them, so I can customize the layout to my needs. | - The horizontal divider between the two main panels is a draggable handle. <br> - Dragging it up or down resizes both panels accordingly, while respecting their minimum and maximum height constraints. |
| UXA-06 | **Token Count Color Coding** | As a user, I want the items in the "Selected Items" list to be color-coded based on their token count, so I can immediately identify potentially problematic large files. | - List items have a background color that corresponds to their token count. <br> - **(C73 Update)** The color scheme indicates increasing risk: <br> - **0-8k tokens:** Green (Low risk). <br> - **8k-10k tokens:** Yellow (Slight risk). <br> - **10k-12k tokens:** Orange (Moderate risk). <br> - **12k+ tokens:** Red (High risk). <br> - A tooltip explains the color coding and associated risk. |
| UXA-07 | **Auto-Uncheck Empty Folder** | As a user, when I remove the last selected file from a folder via the "Selected Items" panel, I want the parent folder to become unchecked in the main file tree, so the UI state remains consistent. | - When a file removal action is processed, the logic checks if any sibling files of the removed file are still selected. <br> - If no siblings remain selected under a parent folder that was previously checked, that parent folder is also removed from the selection. |


## 3. Technical Implementation Plan

-   **Auto-Reveal (UXA-01):**
    -   Create a new IPC channel `ServerToClientChannel.FocusFile`.
    -   Backend (`flattener.service.ts`): After writing the file, send the `FocusFile` message with the file's absolute path. A small delay might be needed to allow the file watcher to trigger a UI refresh first.
    -   Frontend (`view.tsx`): Listen for `FocusFile` and call `setActiveFile` with the received path. The existing `useEffect` in `TreeView.tsx` will handle the reveal.
-   **Selected Count (UXA-02):**
    -   Frontend (`FileTree.tsx`): Implement a memoized recursive function that traverses a `FileNode`'s children and checks against the `selectedFiles` list to calculate the selected count. Render this count conditionally in the `renderFileNodeContent` function. This is a frontend-only calculation.
-   **Minimize Panel (UXA-03):**
    -   Frontend (`view.tsx`): Add a new state, `isSelectionListMinimized`.
    -   Frontend (`SelectedFilesView.tsx`): Add a button to the header that calls a prop function to toggle this state. Conditionally render the `<ul>` based on the state.
-   **Auto-Add Files (UXA-04):**
    -   Frontend (`view.tsx`): Add a toggle button and a state for this mode. When toggled, send an IPC message to the backend to update its persisted state.
    -   Backend (`selection.service.ts`): Store the toggle's state in `workspaceState`.
    -   Backend (`fs.service.ts`): The `onDidCreate` handler in the file watcher will check this state. If true, it will get the current selection, add the new file's path, and save it back using `selection.service.ts` before triggering the UI refresh.
-   **Token Count Coloring (UXA-06):**
    -   Frontend (`SelectedFilesView.tsx`): Create a helper function `getTokenBackgroundColor(tokenCount)` that returns an HSL color string based on the specified token ranges.
    -   Apply the returned color to the `<li>` element's `style` prop.
    -   Add a `title` attribute to the `<li>` to explain the risk associated with the token count.
-   **Auto-Uncheck Folder (UXA-07):**
    -   Frontend (`FileTree.utils.ts`): The `removePathsFromSelected` function will be enhanced. After calculating the new effective selection set, it will need to perform a check. For each removed path, it can traverse up the tree to find its parent directories. For each parent, it can check if any of its other children are still in the effective selection set. If not, the parent should not be included in the final compressed path list. This is complex and requires careful state calculation.
</file_artifact>

<file path="src/Artifacts/A21. DCE - Phase 1 - Feature Drift Analysis vs. VS Code Explorer.md">
# Artifact A21: DCE - Phase 1 - Feature Drift Analysis vs. VS Code Explorer
# Date Created: C28
# Author: AI Model
# Updated on: C39 (Update Keyboard Nav status to Complete)

- **Key/Value for A0:**
- **Description:** A comparative analysis documenting the functional and behavioral differences between the DCE custom file view and the native VS Code Explorer to guide future development and feature parity.
- **Tags:** feature plan, analysis, drift, ux, vs code explorer, parity

## 1. Overview & Goal

The primary goal of the Data Curation Environment (DCE) is to enhance, not replace, the core developer workflow. To minimize friction and maximize adoption, its custom file view must achieve a high degree of feature parity with the native VS Code Explorer. This document analyzes the "drift," or the set of features present in the native Explorer that are currently missing from the DCE view. This analysis will serve as a backlog and prioritization guide for future development cycles.

## 2. Feature Comparison Matrix

| Feature Category            | Native VS Code Explorer         | DCE (as of C39)        | Status & Notes                                                                                                                                              |
| --------------------------- | ------------------------------- | ---------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **File Display**            |                                 |                        |                                                                                                                                                             |
| Hierarchical Tree           | ✅                              | ✅                     | **Complete.** Core functionality is present.                                                                                                                |
| File/Folder Icons           | ✅                              | ✅                     | **Complete.** Icons match file types.                                                                                                                       |
| Active File Highlighting    | ✅                              | ✅                     | **Complete.**                                                                                                                                               |
| Problems/Git Status         | ✅ (Colors, badges)             | ✅                     | **Complete.** Displays Git status colors/badges and problem indicators.                                                                                     |
| **Selection**               |                                 |                        |                                                                                                                                                             |
| Single-Click (Files)        | ✅ Opens file                   | ✅ Opens & Selects file| **Complete.** Aligns with native behavior.                                                                                                                  |
| Single-Click (Folders)      | ✅ Expands/Collapses            | ✅ Expands/Collapses   | **Complete.** |
| Multi-Select (Ctrl)         | ✅                              | ✅                     | **Complete.**                                                                                                                                               |
| Multi-Select (Shift)        | ✅ (Selects rows)               | ✅ (Selects rows)      | **Complete.**                                                                                                                                               |
| Select All (Ctrl+A)         | ✅ (In focused list)            | ✅                     | **Complete.** The focus-stealing bug is now resolved, making `Ctrl+A` in the "Selected Items" list reliable.                                           |
| **Interaction**             |                                 |                        |                                                                                                                                                             |
| Drag and Drop               | ✅ (Move files/folders)         | ✅                     | **Complete.**                                                                                                                                               |
| Right-Click Context Menu    | ✅ (Extensive options)          | ✅ (Basic + List actions) | **Partial.** DCE has basic file ops. Added "Select All" for lists in C37. Missing advanced options like `Open in Integrated Terminal`, `Compare...`.       |
| Keyboard Navigation         | ✅ (Arrows, Enter, Space)       | ✅                     | **Complete (C39).** Arrow keys, Enter, and Spacebar now function as expected. The focus-stealing bug has been resolved.                                   |
| Inline Rename               | ✅ (F2 or slow double-click)    | ✅                     | **Complete.** |
| **File Operations**         |                                 |                        |                                                                                                                                                             |
| New File / Folder           | ✅                              | ✅                     | **Complete.** |
| Delete (to Trash)           | ✅                              | ✅                     | **Complete.** |
| Cut / Copy / Paste          | ✅                              | ❌                     | **Missing.** Standard file system operations are not yet implemented.                                                                                       |
| Undo / Redo (Ctrl+Z)        | ✅                              | ❌                     | **Missing.** A critical feature for parity. Requires an action stack to reverse moves/deletes. Planned in A27.                                            |
| **Search & Filter**         |                                 |                        |                                                                                                                                                             |
| Filter by Name              | ✅ (Start typing)               | ✅                     | **Complete.**                                                                                                                                               |

## 3. High-Priority Features for Future Cycles

Based on the analysis, the following features represent the most significant gaps in user experience and should be prioritized:

1.  **Undo / Redo (Ctrl+Z):** The ability to undo a file move or deletion is a fundamental expectation for any file manager and its absence is a major point of friction.
2.  **Cut / Copy / Paste:** Adding standard clipboard operations for files is a key missing piece of basic file management.
3.  **Expanded Context Menu:** Adding more of the native right-click options, especially `Open in Integrated Terminal` and `Compare Selected`, would significantly reduce the need for users to switch back to the native Explorer.
</file_artifact>

<file path="src/Artifacts/A22. DCE - Phase 1 - Search & Filter Feature Plan.md">
# Artifact A22: DCE - Phase 1 - Search & Filter Feature Plan
# Date Created: C29
# Author: AI Model

- **Key/Value for A0:**
- **Description:** Outlines the requirements and implementation for a search bar to filter the main file tree view by file or folder name.
- **Tags:** feature plan, search, filter, tree view, ux, phase 1

## 1. Overview & Goal

To improve navigation and usability in large projects, this feature introduces a search and filter capability to the Data Curation Environment. The goal is to allow users to quickly find specific files or folders by typing a part of their name, mirroring the incremental filtering behavior of the native VS Code Explorer.

## 2. User Story

| ID | User Story | Acceptance Criteria |
|---|---|---|
| SF-01 | **Filter File Tree** | As a user working in a large repository, I want to type in a search bar to filter the file tree in real-time, so I can quickly locate the files and folders I need without extensive scrolling. | - A search icon/button is present in the main header toolbar. <br> - Clicking the icon reveals a text input field. <br> - As I type into the input field, the file tree dynamically updates to show only the files and folders whose names match the search string. <br> - All parent directories of a matching file are also shown to preserve the tree structure. <br> - The search is case-insensitive. <br> - Clearing the search input restores the full, unfiltered tree. |

## 3. Technical Implementation Plan

1.  **Frontend - UI (`view.tsx`, `view.scss`):**
    *   Add a new state variable to the main `App` component: `const [filterTerm, setFilterTerm] = useState('');`.
    *   Add a search icon (`VscSearch`) to the header toolbar. A second state, `isSearchVisible`, can be used to toggle the visibility of the input field when the icon is clicked.
    *   The search `<input>` element's `value` will be bound to `filterTerm`, and its `onChange` handler will call `setFilterTerm`.

2.  **Frontend - Filtering Logic (`FileTree.tsx`):**
    *   The `FileTree` component will receive the `filterTerm` as a new prop.
    *   A `useMemo` hook will be used to compute the filtered tree whenever the source `data` or the `filterTerm` changes.
    *   This hook will call a new recursive filtering function:
        ```typescript
        function filterTree(nodes: FileNode[], term: string): FileNode[] {
            if (!term) return nodes;
            const lowerCaseTerm = term.toLowerCase();

            return nodes.reduce((acc, node) => {
                if (node.name.toLowerCase().includes(lowerCaseTerm)) {
                    // If the node itself matches, include it and all its children
                    acc.push(node);
                    return acc;
                }

                if (node.children) {
                    // If the node is a directory, filter its children
                    const filteredChildren = filterTree(node.children, term);
                    if (filteredChildren.length > 0) {
                        // If any children match, include the parent with its filtered children
                        acc.push({ ...node, children: filteredChildren });
                    }
                }
                return acc;
            }, [] as FileNode[]);
        }
        ```
    *   The `TreeView` component will then be rendered with this new, filtered data.

3.  **State Management:**
    *   The filtering is a pure frontend operation. No backend changes or IPC communication are required for this feature.
    *   The search term is transient UI state and does not need to be persisted.
</file_artifact>

<file path="src/Artifacts/A23. DCE - Phase 1 - Advanced Interactions (Keyboard & Drag-Drop) Plan.md">
# Artifact A23: DCE - Phase 1 - Advanced Interactions (Keyboard & Drag-Drop) Plan
# Date Created: C29
# Author: AI Model
# Updated on: C71 (Add Delete key functionality)

- **Key/Value for A0:**
- **Description:** Details the requirements for implementing full keyboard navigation and drag-and-drop file/folder operations within the main file tree.
- **Tags:** feature plan, keyboard navigation, drag and drop, file operations, accessibility, ux, phase 1

## 1. Overview & Goal

To achieve true feature parity with the native VS Code Explorer and cater to power users, the Data Curation Environment must support advanced interactions. This plan outlines the requirements for two major features: full keyboard navigation for accessibility and speed, and drag-and-drop functionality for intuitive file system manipulation.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| AI-01 | **Keyboard Navigation** | As a power user, I want to navigate the file tree using only my keyboard, so I can find, select, and manage files without taking my hands off the keyboard. | - Arrow Up/Down keys move the focus between visible nodes. <br> - Arrow Right on a collapsed folder expands it. <br> - Arrow Left on an open folder collapses it. <br> - `Enter` key opens the focused file or toggles expansion. <br> - `Spacebar` toggles the checkbox of the focused node. <br> - **(Bug C68):** When a file within a checked parent folder is focused, pressing spacebar incorrectly de-selects a higher-level directory instead of just the single file. |
| AI-02 | **Internal Drag-and-Drop** | As a user, I want to be able to drag a file or folder and drop it into another folder within the DCE view to move it, so I can reorganize my project intuitively. | - Clicking and dragging a file or folder initiates a drag operation. <br> - Dragging over a folder highlights it as a potential drop target. <br> - Dropping a file/folder onto another folder moves the dragged item. <br> - **Validation:** A folder cannot be dropped into itself or one of its own descendants. |
| AI-03 | **External Drag-and-Drop** | As a user, I want to drag a file (e.g., a PDF) from my computer's file explorer or the VS Code Explorer and drop it into a folder in the DCE view to add it to my project, so I can quickly incorporate new assets. | - Dragging a file from the OS or VS Code Explorer and dropping it onto a folder in the DCE view copies that file into the target folder in the workspace. <br> - The file tree automatically refreshes to show the newly added file. |
| AI-04 | **Delete Key** | As a user, I want to press the `Delete` key on my keyboard when an item is focused in the file tree to delete it, so I can manage files quickly without using the mouse. | - Focusing an item in the main file tree and pressing `Delete` initiates the delete workflow. <br> - It uses the same backend logic as the context menu, including the confirmation dialog and moving the item to the trash. |
| AI-05 | **Copy & Paste** | As a user, I want to use `Ctrl+C` and `Ctrl+V` to copy and paste files/folders within the tree, so I can use standard keyboard shortcuts for file duplication. | - `Ctrl+C` on a focused item copies its path to an internal clipboard. <br> - `Ctrl+V` on another item pastes the copied item into that location. <br> - Handles name collisions gracefully (e.g., `file-copy.ts`). |
| AI-06 | **Hover to Expand Folder** | As a user dragging a file, when I hover over a collapsed folder for a moment, I want it to automatically expand, so I can drop the file into a nested subdirectory without having to cancel the drag operation. | - During a drag operation, hovering over a collapsed folder for ~500ms triggers its expansion. <br> - Moving the mouse away from the folder before the timer completes cancels the expansion. |

## 3. Implementation Status & Notes

### Keyboard Navigation & Internal Drag-Drop
These features are stable and complete, with the exception of the noted spacebar bug.

### External Drag and Drop (De-Prioritized as of C61)

-   **Status:** **On Hold.**
-   **Summary of Attempts:** Multiple approaches were attempted between C54 and C60 to implement file drops from outside the webview (e.g., from the OS or the native VS Code Explorer).
    1.  **Standard HTML5 API (`dataTransfer.files`):** This worked for drops from the OS but failed for drops from the VS Code Explorer, as the `files` collection is empty for security reasons.
    2.  **VS Code URI-based API (`text/uri-list`):** This approach correctly captured the URI of the file being dropped from the VS Code Explorer. The URI was passed to the backend, which then used the `vscode.workspace.fs.copy()` API.
-   **Root Cause of Failure:** Despite correctly implementing the URI-based approach, the drag-and-drop events (`onDrop`, `onDragOver`) failed to fire reliably or at all when dragging from an external source into the webview. The root cause appears to be a complex interaction with VS Code's webview security model, event propagation, and possibly the Workspace Trust feature, which could not be resolved within a reasonable number of cycles.
-   **Path Forward:** This feature is now considered a **tertiary, long-term research goal**. The core functionality of the extension is not dependent on it. For now, users can add new files using the native VS Code Explorer, the "New File..." button in the DCE toolbar, or by simply creating the file, which will then appear on refresh.
</file_artifact>

<file path="src/Artifacts/A24. DCE - Selection Paradigm Terminology.md">
# Artifact A24: DCE - Selection Paradigm Terminology
# Date Created: C29
# Author: AI Model

- **Key/Value for A0:**
- **Description:** A document to clarify the terminology used within the project to distinguish between different types of user selections (e.g., "checking" for flattening vs. "selecting" for actions).
- **Tags:** documentation, terminology, selection, checking, design

## 1. Problem Statement

During development and feedback cycles, the term "select" has been used ambiguously, leading to confusion. It has been used to describe two distinct user actions with different purposes:
1.  Clicking a checkbox to include a file/folder in the context to be flattened.
2.  Clicking a file/folder row (with optional Ctrl/Shift modifiers) to highlight it for a contextual action (e.g., Rename, Delete).

This ambiguity makes feature requests and technical discussions difficult. The goal of this document is to establish clear, consistent terminology for use in all future artifacts, code, and discussions.

## 2. Defined Terminology

Henceforth, the following terms will be used to describe user interactions with the file tree:

### **Checking / Unchecking**

*   **Action:** Clicking the `checkbox` next to a file or folder item.
*   **Purpose:** To include or exclude an item from the set of files that will be processed by the **"Flatten Context"** action.
*   **UI State:** A visible checkmark (`✓`), indeterminate mark (`-`), or empty state in the checkbox.
*   **State Variable (conceptual):** `checkedPaths: Set<string>`
*   **User Phrasing:** "I **checked** the `src` folder."

---

### **Selecting / Highlighting**

*   **Action:** Single-clicking a file/folder row. Using `Ctrl+Click` or `Shift+Click` to highlight multiple rows.
*   **Purpose:** To designate one or more items as the target for a contextual action, such as those in the **right-click context menu** (e.g., Rename, Delete, Copy Path). This is also used to identify the "active" item for operations like "New File".
*   **UI State:** A visual highlight on the entire row, typically matching the VS Code theme's selection color.
*   **State Variable (conceptual):** `selectedPaths: Set<string>`
*   **User Phrasing:** "I **selected** three files and then right-clicked to delete them."

---

### **Focusing**

*   **Action:** Navigating the tree with keyboard arrow keys.
*   **Purpose:** To move a visual indicator (a focus ring or subtle highlight) to an item, making it the active target for keyboard actions (`Enter` to open, `Spacebar` to check/uncheck).
*   **UI State:** A focus outline around the item row.
*   **State Variable (conceptual):** `focusedPath: string | null`
*   **User Phrasing:** "The `README.md` file is currently **focused**."

## 3. Summary Table

| Term | Action | Purpose | UI Cue | State Name |
| :--- | :--- | :--- | :--- | :--- |
| **Check** | Click checkbox | Include in Flatten Context | Checkmark | `checkedPaths` |
| **Select** | Click / Ctrl+Click / Shift+Click row | Target for Context Menu Actions | Row highlight | `selectedPaths` |
| **Focus** | Keyboard navigation | Target for Keyboard Actions | Focus ring | `focusedPath` |

By adhering to this terminology, we can ensure clarity in communication and precision in our technical implementation.
</file_artifact>

<file path="src/Artifacts/A25. DCE - Phase 1 - Git & Problems Integration Plan.md">
# Artifact A25: DCE - Phase 1 - Git & Problems Integration Plan
# Date Created: C30
# Author: AI Model
# Updated on: C184 (Reflect new decoration-based update architecture)

- **Key/Value for A0:**
- **Description:** Outlines the user stories and technical approach for integrating Git status indicators and VS Code Problem Diagnostics into the custom file tree.
- **Tags:** feature plan, git, problems, diagnostics, ux, phase 1

## 1. Overview & Goal

To achieve full feature parity with the native VS Code Explorer and provide critical context to the user, the Data Curation Environment (DCE) file tree must display information about a file's Git status and any associated problems (errors/warnings). The goal of this feature is to overlay this diagnostic and source control information directly onto the file tree, allowing users to make more informed decisions during context curation.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| GP-01 | **Git Status Coloring** | As a user, I want to see files and folders colored according to their Git status (e.g., green for new, yellow for modified, gray for ignored), so I can quickly identify changes in my workspace. | - The file/folder name text color in the tree view changes based on its Git status. <br> - Colors should align with the user's current VS Code theme for Git decorations. <br> - A new, untracked file is green. <br> - A modified file is yellow/orange. <br> - A deleted file (in some views) is red. <br> - An ignored file is gray. |
| GP-02 | **Git Status Badges** | As a user, I want to see a letter badge next to a file's name indicating its specific Git status (e.g., 'U' for untracked, 'M' for modified), so I have an unambiguous indicator of its state. | - A small, colored badge with a letter appears to the right of the file name. <br> - 'U' for Untracked. <br> - 'M' for Modified. <br> - 'D' for Deleted. <br> - 'A' for Added. <br> - 'C' for Conflicted. <br> - The badge has a tooltip explaining the status (e.g., "Modified"). |
| GP-03 | **Problem Indicator Badges** | As a user, I want to see a badge with a count of errors and warnings on files and their parent folders, so I can immediately identify parts of the codebase that have issues. | - A file with problems displays a badge with the number of errors (e.g., in red). <br> - A folder recursively aggregates the problem counts of its children and displays a summary badge. <br> - Tooltips on the badge provide a breakdown (e.g., "2 Errors, 3 Warnings"). <br> - The file name may also be colored (e.g., red for errors, yellow for warnings) to match the Problems panel. |

## 3. Technical Implementation Plan (C184 Revision)

### Phase 1: Data Gathering (Backend)
The backend is responsible for collecting Git and Problem data and sending it to the client.

-   **Git Status (`file-tree.service.ts`):** A `getGitStatusMap()` method builds a `Map<string, string>` of file paths to their status character by querying the Git API.
-   **Problems (`file-tree.service.ts`):** A `getProblemCountsMap()` method builds a map of file paths to their error/warning counts by querying `vscode.languages.getDiagnostics()`.

### Phase 2: Decoupled Refresh Architecture
To solve the FTV flashing bug, structural refreshes are now decoupled from decoration refreshes.

1.  **Structural Refresh (File Watcher):** The `FileSystemWatcher` is the sole trigger for a full tree rebuild (`ForceRefresh`). This is for file creations, deletions, and renames.
2.  **Decoration Refresh (Git API):** The overly sensitive `repo.state.onDidChange` listener no longer triggers a full refresh. Instead, it triggers a new, lightweight update.
    *   **New IPC Channel:** `ServerToClientChannel.UpdateDecorations` is created to carry the Git status map and the problem map to the client.
    *   **New Backend Method:** A `triggerDecorationsUpdate` method in `file-tree.service.ts` is called by the Git listener. It gathers the latest decoration data and sends it over the new channel.

### Phase 3: Rendering (Frontend)
The frontend receives the file tree structure and decoration data separately and combines them at render time.

-   **State Management (`context-chooser.view/view.tsx`):**
    *   The component maintains the `files` (tree structure), `problemMap`, and a new `gitStatusMap` in its state.
    *   A message handler for `UpdateDecorations` updates the `problemMap` and `gitStatusMap` state variables.
-   **Rendering (`FileTree.tsx`):**
    *   The component receives the `gitStatusMap` and `problemMap` as props.
    *   The `gitStatus` and `problemCounts` properties are **removed** from the `FileNode` type, as this data is no longer static.
    *   When rendering a file node, the component looks up the node's `absolutePath` in the `gitStatusMap` and `problemMap` props to get the most current decoration data.
    *   This allows the Git and problem indicators to update frequently without the expensive process of rebuilding the entire tree structure.
</file_artifact>

<file path="src/Artifacts/A26. DCE - Phase 1 - File System Traversal & Caching Strategy.md">
# Artifact A26: DCE - Phase 1 - File System Traversal & Caching Strategy
# Date Created: C31
# Author: AI Model
# Updated on: C152 (Update node_modules handling)

- **Key/Value for A0:**
- **Description:** Documents the root cause of the folder visibility bug and outlines the new strategy of using recursive directory traversal instead of `findFiles` to build a complete and accurate file system map. Also defines the performance-oriented handling of `node_modules`.
- **Tags:** bug fix, file system, traversal, refresh, cache, architecture, performance

## 1. Overview & Goal

This document addresses a critical bug where newly created empty folders do not appear in the Data Curation file tree. It also defines the strategy for handling large directories like `node_modules` to ensure the UI remains performant. The goal is to define a robust file system traversal strategy that guarantees an accurate and fast representation of the workspace.

## 2. Root Cause Analysis (RCA) - Folder Visibility

-   **Symptom:** Creating a new, empty folder in the workspace does not result in that folder appearing in the DCE file tree, even after a refresh.
-   **Root Cause:** The file discovery mechanism was using `vscode.workspace.findFiles("**/*", ...)`. This API is optimized to return a flat list of **files** and does **not** return directories, especially empty ones. When the tree was reconstructed from this file-only list, empty directories were invisible.

## 3. New Traversal Strategy

To resolve this, the reliance on `vscode.workspace.findFiles` for building the tree structure has been replaced with a manual, recursive directory traversal.

### 3.1. Technical Implementation Plan

1.  **Primary API:** The new strategy is centered around `vscode.workspace.fs.readDirectory(uri)`. This function returns an array of `[name, fileType]` tuples for all immediate children of a given directory.
2.  **Recursive Function:** A `private async _traverseDirectory(uri)` method in `file-tree.service.ts` implements the recursive scan. It iterates through directory contents, creating `FileNode` objects and recursively calling itself for subdirectories.

## 4. Performance Strategy for `node_modules` (C152)

-   **Problem:** Scanning `node_modules` for file and token counts is extremely slow and provides no value for context curation. However, completely hiding it can be confusing if a user needs to reference its structure.
-   **New Strategy:** The `node_modules` directory will be **visible but not counted**.
-   **Implementation (`_traverseDirectory`):**
    1.  When the traversal encounters a directory named `node_modules`, it will **not** skip it. It will create a `FileNode` for it.
    2.  However, it will **not** recursively call `_traverseDirectory` on its contents.
    3.  The `FileNode` for `node_modules` will be returned with an empty `children` array and `fileCount`/`tokenCount` set to 0.
-   **Benefit:** This approach makes the UI load instantly while still showing the `node_modules` folder in the tree, achieving the best of both worlds. The `flattener.service.ts` will continue to explicitly ignore this directory to prevent its inclusion in the flattened output.

## 5. Benefits of the New Approach

-   **Accuracy:** The method builds a true representation of the file system, including empty directories.
-   **Performance:** By special-casing `node_modules`, the initial tree scan remains fast and responsive.
-   **Control:** It gives us full control over the traversal, allowing for sophisticated filtering and caching.
</file_artifact>

<file path="src/Artifacts/A27. DCE - Phase 1 - Undo-Redo Feature Plan.md">
# Artifact A27: DCE - Phase 1 - Undo-Redo Feature Plan
# Date Created: C35
# Author: AI Model
# Updated on: C12 (Add requirement for preserving selection state)

- **Key/Value for A0:**
- **Description:** Details the requirements for implementing an undo/redo stack for file system operations (move, delete) performed within the DCE view, to achieve parity with the native explorer's Ctrl+Z functionality.
- **Tags:** feature plan, undo, redo, ctrl+z, file operations, ux, phase 1

## 1. Overview & Goal

A critical feature for achieving parity with the native VS Code Explorer is the ability to undo file system operations. Users expect to be able to press `Ctrl+Z` to revert an accidental file move or deletion. The goal of this feature is to implement a robust undo/redo stack for file operations initiated from within the Data Curation Environment view.

**Status (C10):** In Progress.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| UR-01 | **Undo File Move** | As a user, after I drag and drop a file to a new location, I want to be able to press `Ctrl+Z` to move it back to its original location, so I can easily correct mistakes. | - Performing a file/folder move pushes an "action" object onto an undo stack. <br> - Pressing `Ctrl+Z` while the DCE view is focused pops the last action and reverses it (moves the file back). <br> - The file tree updates to reflect the reversed move. |
| UR-02 | **Undo File Deletion** | As a user, after I delete a file or folder (to the trash), I want to be able to press `Ctrl+Z` to restore it, so I don't lose work accidentally. | - Deleting a file/folder pushes an "action" object onto the undo stack. <br> - Pressing `Ctrl+Z` reverses the deletion. Since we use `useTrash: true`, this might be handled by a native VS Code command, or we may need to implement a restore from trash mechanism if possible. |
| UR-03 | **Redo Operation** | As a user, after I undo an action, I want to be able to press `Ctrl+Y` (or `Ctrl+Shift+Z`) to redo the action, so I can toggle between states. | - Undoing an action moves it from the undo stack to a redo stack. <br> - Pressing `Ctrl+Y` pops the last action from the redo stack and re-applies it. <br> - The file tree updates accordingly. |
| UR-04 | **Preserve Selection State** | As a user, if I move a file that is *not* checked for flattening, and then I undo that move, I expect the file to still be unchecked when it returns to its original location, so its selection state is preserved. | - The "auto-add new files" feature must not incorrectly re-check a file that is being restored via an undo operation. |

## 3. Technical Implementation Plan

This feature will be implemented primarily on the backend to manage the file system state and the action history.

1.  **Action Stack Service (New Backend Service):**
    *   Create a new service, `action.service.ts`, to manage the undo and redo stacks.
    *   It will contain two arrays: `undoStack: Action[]` and `redoStack: Action[]`.
    *   An `Action` will be a typed object, e.g., `{ type: 'move', payload: { from: string, to: string } }` or `{ type: 'delete', payload: { path: string } }`.
    *   It will expose methods: `push(action: Action)`, `undo()`, and `redo()`.
        *   `push`: Adds an action to `undoStack` and clears `redoStack`.
        *   `undo`: Pops from `undoStack`, performs the reverse operation, and pushes the original action to `redoStack`.
        *   `redo`: Pops from `redoStack`, performs the original operation, and pushes it back to `undoStack`.

2.  **Integrate with `file-operation.service.ts`:**
    *   The `handleMoveFileRequest` and `handleFileDeleteRequest` methods in `file-operation.service.ts` will be updated.
    *   *Before* performing the file system operation, they will create the corresponding `Action` object.
    *   *After* the operation succeeds, they will call `Services.actionService.push(action)`.

3.  **IPC Channels and Commands:**
    *   Create two new `ClientToServerChannel` entries: `RequestUndo` and `RequestRedo`.
    *   The frontend (`TreeView.tsx`) will have a top-level `onKeyDown` handler. When `Ctrl+Z` or `Ctrl+Y` is detected, it will send the appropriate IPC message to the backend.
    *   Create two new backend commands, `dce.undo` and `dce.redo`, which will be called by the message handlers. These commands will simply call `Services.actionService.undo()` and `Services.actionService.redo()`.

4.  **Reverse Operations Logic (`action.service.ts`):**
    *   The `undo()` method will contain the logic to reverse actions.
    *   **Move:** To undo a move from `A` to `B`, it calls `vscode.workspace.fs.rename(B, A)`.
    *   **Delete:** Undoing a delete is more complex. Since we use `useTrash: true`, VS Code might not expose a direct API to "un-delete". Research is needed. The simplest approach might be to leverage a built-in command like `files.restoreFromTrash` if it can be targeted, or we may need to inform the user to use the native Explorer's undo for deletions. For a first pass, we might only support undo for **move** operations.
    *   **Selection State Preservation (UR-04):** Before performing the reverse `rename`, the `undo` method will call a new method on the `FileOperationService` to temporarily add the original file path to an "ignore" list for the "auto-add new files" feature. This prevents the file watcher from incorrectly re-checking the file when it reappears.

5.  **Frontend Focus:**
    *   The main `TreeView` component needs to be focusable (`tabIndex="0"`) to capture the keyboard shortcuts. The `onKeyDown` handler will check for `event.ctrlKey` and the specific key (`z` or `y`) and then send the IPC message.
</file_artifact>

<file path="src/Artifacts/A28. DCE - Packaging and Distribution Guide.md">
# Artifact A28: DCE - Packaging and Distribution Guide
# Date Created: C43
# Author: AI Model
# Updated on: C164 (Add critical step for including static assets)

- **Key/Value for A0:**
- **Description:** Provides a step-by-step guide on how to package the extension into a `.vsix` file for beta testing and distribution.
- **Tags:** packaging, distribution, vsix, vsce, deployment

## 1. Overview

This document provides instructions on how to package the Data Curation Environment (DCE) extension into a single `.vsix` file. This file is the standard format for distributing and installing VS Code extensions, making it easy to share with beta testers or submit to the official marketplace.

The primary tool used for this process is `vsce` (Visual Studio Code Extensions), the official command-line tool for managing extensions.

## 2. Prerequisites

1.  **Node.js and npm:** You must have Node.js and npm installed.
2.  **Install `vsce`:** If you haven't already, install `vsce` globally by running the following command in your terminal:
    ```bash
    npm install -g @vscode/vsce
    ```

## 3. Packaging the Extension

Follow these steps in your terminal from the root directory of the DCE project (e.g., `C:\Projects\DCE`):

### Step 0: Update `package.json` (Important!)

Before packaging, ensure your `package.json` file is complete. The `vsce` tool will warn you if important fields are missing. At a minimum, make sure the following fields are present and correct:

-   `publisher`: Your publisher ID from the VS Code Marketplace.
-   `repository`: An object pointing to your source code repository (e.g., on GitHub).
-   `homepage`: A link to your project's homepage.
-   `bugs`: A link to your project's issue tracker.
-   `version`: Increment the version number for each new release.

### Step 1: Verify Static Asset Handling (CRITICAL)

The extension's backend code runs from the compiled `dist` directory. Any static files that the backend needs to read at runtime (like our `T*` template artifacts in `src/Artifacts`) **must be copied into the `dist` directory** during the build process.

-   **Check `webpack.config.js`:** Ensure the `CopyPlugin` includes a rule to copy `src/Artifacts` to the `dist` folder.
    ```javascript
    // Example rule in CopyPlugin patterns:
    { from: "src/Artifacts", to: "Artifacts" }
    ```
-   **Check Backend Code:** Ensure any code that reads these files (e.g., `prompt.service.ts`) constructs the path relative to the final `dist` directory (e.g., `path.join(context.extensionPath, 'dist', 'Artifacts', ...)`).

### Step 2: Ensure Dependencies are Installed

Make sure your project's dependencies are up to date.

```bash
npm install
```

### Step 3: Create a Production Build

Before packaging, it's essential to create an optimized production build of the extension. Our `package.json` already has a script for this.

```bash
npm run package
```

This command runs webpack in `production` mode, which minifies the code and removes source maps, resulting in a smaller and faster extension. It will update the files in the `/dist` directory.

### Step 4: Run the Packaging Command

Once the production build is complete, you can run the `vsce` packaging command.

```bash
vsce package
```

This command will:
1.  Read the `package.json` manifest file.
2.  Gather all the necessary files, respecting the rules in `.vscodeignore`.
3.  Bundle everything into a single file named `data-curation-environment-X.X.X.vsix`, where `X.X.X` is the version number from `package.json`.

You will see the `.vsix` file in the root of your project directory.

## 4. Sharing and Installing the `.vsix` File

### For Beta Testers:

1.  **Share the File:** You can send the generated `.vsix` file directly to your testers (e.g., via email, Slack, or a shared drive).

2.  **Installation Instructions:** Your testers can install it in VS Code by following these steps:
    *   Open VS Code.
    *   Go to the **Extensions** view (Ctrl+Shift+X).
    *   Click the **...** (More Actions) button at the top of the Extensions view.
    *   Select **"Install from VSIX..."**.
    *   In the file dialog that opens, navigate to and select the `.vsix` file you provided.
    *   VS Code will install the extension and prompt for a reload.
</file_artifact>

<file path="src/Artifacts/A29. DCE - Phase 1 - Binary and Image File Handling Strategy.md">
# Artifact A29: DCE - Phase 1 - Binary and Image File Handling Strategy
# Date Created: C46
# Author: AI Model
# Updated on: C47 (Richer metadata format and JSON output)

- **Key/Value for A0:**
- **Description:** Defines the strategy for handling binary files; they can be checked, but only their metadata (path, size) is included in the flattened output, not their content.
- **Tags:** feature plan, binary, image, metadata, flatten, phase 1

## 1. Overview & Goal

During beta testing, a use case emerged for including information about binary files (like images) in the flattened context without including their raw, unreadable content. The goal of this strategy is to allow users to select *any* file, but to intelligently handle non-text files during the flattening process to prevent corrupting the output while still capturing useful metadata.

## 2. Problem Statement

-   **Initial Problem:** Flattening a folder containing images (`.png`, `.gif`) resulted in binary gibberish being written to `flattened_repo.md`.
-   **Initial Solution (C43):** Prevent selection of binary files by disabling their checkboxes.
-   **Refined Requirement (C46):** The user realized they *do* want to capture the existence and properties of these files (e.g., path, size) as part of the context, just not their content.
-   **Refined Requirement (C47):** The metadata should be richer, including name, directory, dimensions, and file type, and be presented in a structured format.

## 3. The New Strategy

The extension will now adopt a "metadata-only" approach for a predefined list of binary and image file types.

### 3.1. User Experience

1.  **Selection is Always Allowed:** All files in the file tree, regardless of type, will have an enabled checkbox. The user is free to check any file or folder.
2.  **File Opening:** Clicking on any file in the tree view will open it using VS Code's default viewer for that file type (e.g., text editor for `.ts`, image preview for `.png`).
3.  **Flattening Behavior is Differentiated:**
    *   When a **text file** is checked and the "Flatten Context" button is pressed, its full content is read and included in `flattened_repo.md`.
    *   When a **binary or image file** is checked, its content is **not** read. Instead, the flattener service will gather its metadata and include a structured, human-readable entry for it in `flattened_repo.md`.

### 3.2. Output Format for Binary Files

When a binary file is included, its entry in the `<files content>` section of `flattened_repo.md` will contain a `<metadata>` tag with a JSON object. Dimensions will be included on a best-effort basis for common formats (PNG, JPG, GIF).

**Example (with dimensions):**
```xml
<file path="public/images/logo.png">
<metadata>
{
  "name": "logo.png",
  "directory": "public/images",
  "fileType": "PNG",
  "sizeInBytes": 12345,
  "dimensions": {
    "width": 256,
    "height": 256
  }
}
</metadata>
</file>
```

**Example (without dimensions):**
```xml
<file path="assets/archive.zip">
<metadata>
{
  "name": "archive.zip",
  "directory": "assets",
  "fileType": "ZIP",
  "sizeInBytes": 102400
}
</metadata>
</file>
```

## 4. Technical Implementation Plan

1.  **File Opening (`fs.service.ts`):**
    *   The `handleOpenFileRequest` method will be updated to use `vscode.commands.executeCommand('vscode.open', uri)`. This delegates opening to VS Code, which correctly selects the appropriate viewer for any file type.

2.  **Backend Flattener Logic (`flattener.service.ts`):**
    *   A constant set of binary/image extensions will be defined.
    *   A new private method, `_parseImageMetadata`, will be added. It will read a file's buffer and attempt to parse dimensions for PNG, JPG, and GIF files, adapting logic from `flattenv2.js`.
    *   The `getFileStatsAndContent` method will be updated. When it encounters a binary file, it will:
        *   Call `_parseImageMetadata`.
        *   Collect the name, directory, type, size, and (if available) dimensions.
        *   Construct the formatted JSON string.
        *   Return a `FileStats` object where `content` is this JSON string, and `tokens` is 0.
</file_artifact>

<file path="src/Artifacts/A30. DCE - Phase 1 - PDF Handling and Virtualization Strategy.md">
# Artifact A30: DCE - Phase 1 - PDF Handling and Virtualization Strategy
# Date Created: C49
# Author: AI Model

- **Key/Value for A0:**
- **Description:** Defines the strategy for handling PDF files. Text is extracted on-demand and cached in memory for flattening, creating a "virtual" markdown file without modifying the user's workspace.
- **Tags:** feature plan, pdf, text extraction, virtualization, cache, phase 1

## 1. Overview & Goal

Users need to include the textual content of PDF documents in their flattened context. However, creating physical `.md` files for each PDF in the user's workspace is undesirable as it clutters their project. The goal of this strategy is to implement a "virtual file" system for PDFs. The extension will extract text from PDF files on demand and hold it in an in-memory cache, using this virtual content during the flattening process without ever writing new files to the user's disk.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| PDF-01 | **Include PDF Text in Context** | As a user, when I check a `.pdf` file in the DCE view, I want its textual content to be included in the `flattened_repo.md` file, so I can use documents and papers as context. | - Checking a `.pdf` file is allowed. <br> - The token count displayed for the PDF reflects its extracted text content, not its binary size. <br> - When flattened, the text from the PDF is included within a `<file>` tag, just like a normal text file. <br> - No `.md` file is ever created in the user's workspace. |
| PDF-02 | **Drag-Drop PDF to Add** | As a user, I want to drag a PDF from my computer's file explorer and drop it into the DCE view, so I can quickly add it to my project and include it in my context. | - Dropping a PDF file into a folder in the DCE view copies the PDF into that workspace directory. <br> - The new PDF immediately appears in the file tree. <br> - The user can then check it to include its text content for flattening. |

## 3. Technical Implementation Plan

1.  **Dependency:**
    *   The `pdf-parse` library will be added as a dependency to `package.json` to handle text extraction from PDF buffers.

2.  **Backend (`fs.service.ts`):**
    *   **In-Memory Cache:** A new private cache will be added: `private pdfTextCache = new Map<string, { text: string; tokenCount: number }>();`. This will store the extracted text and calculated token count, keyed by the PDF's absolute path.
    *   **New IPC Handler (`RequestPdfToText`):**
        *   This handler will receive a file path for a PDF.
        *   It will first check the `pdfTextCache`. If the content is present, it will return the cached data.
        *   If not cached, it will read the PDF file into a buffer, use `pdf-parse` to extract the text, calculate the token count, store the result in the cache, and then return it.
        *   It will send a `UpdateNodeStats` message back to the client with the new token count.

3.  **Frontend (`view.tsx`):**
    *   **On-Demand Extraction:** The `updateCheckedFiles` function will be modified. When a path that ends in `.pdf` is being checked for the first time, it will send a `RequestPdfToText` message to the backend.
    *   **Dynamic Stats Update:** A new IPC listener for `UpdateNodeStats` will be added. When it receives a message, it will find the corresponding `FileNode` in the `files` state and update its `tokenCount` property, causing the UI to re-render with the correct information.

4.  **Backend (`flattener.service.ts`):**
    *   **Virtual Content Retrieval:** The `getFileStatsAndContent` method will be updated.
    *   If it encounters a file path ending in `.pdf`, it will **not** attempt to read the file from the disk.
    *   Instead, it will call a new method on the `FSService` (e.g., `getVirtualPdfContent(filePath)`) to retrieve the text from the `pdfTextCache`.
    *   It will then use this cached text to generate the `FileStats` object, effectively treating the PDF as if it were a markdown file. If the content is not in the cache (e.g., the file was never checked), it will be flattened with empty content.

5.  **External Drag-and-Drop:**
    *   This will be handled by the generic "External Drag-and-Drop" feature planned in `A23`. The implementation will read the file buffer and send it to the backend for creation, which works for PDFs just as it does for any other file type.
</file_artifact>

<file path="src/Artifacts/A31. DCE - Phase 2 - Multimodal Content Extraction (PDF Images).md">
# Artifact A31: DCE - Phase 2 - Multimodal Content Extraction (PDF Images)
# Date Created: C49
# Author: AI Model

- **Key/Value for A0:**
- **Description:** A plan for a future feature to extract images from PDF files and use a multimodal LLM to generate rich, textual descriptions for inclusion in the context.
- **Tags:** feature plan, multimodal, image to text, pdf, llm, phase 2

## 1. Overview & Goal

Building on the PDF text extraction in Phase 1, this plan outlines a powerful Phase 2 enhancement: making the visual information within PDFs accessible to language models. Many technical papers, reports, and documents rely on diagrams, charts, and images to convey critical information. The goal of this feature is to extract these images from a PDF and use a multimodal vision-language model (VLM) to generate rich, textual descriptions. These descriptions can then be included in the flattened context, allowing an LLM to "understand" the visual elements of the document.

## 2. User Story

| ID | User Story | Acceptance Criteria |
|---|---|---|
| MM-01 | **Understand PDF Images** | As a data curator, when I include a PDF containing charts and diagrams in my context, I want the extension to generate textual descriptions of those images, so the LLM I'm prompting can reason about the visual data. | - When a PDF is processed, the extension identifies and extracts embedded images. <br> - For each extracted image, the extension sends it to a configured multimodal LLM API (e.g., Gemini). <br> - The LLM API returns a detailed textual description of the image's content. <br> - These descriptions are inserted into the virtual markdown content of the PDF at the appropriate locations (e.g., `[Image: A bar chart showing user growth from 2022 to 2024...]`). <br> - This feature can be enabled/disabled in the extension's settings to manage API costs. |

## 3. Technical Implementation Plan (High-Level)

This is a complex feature that will require new services and dependencies, likely as part of the project's Phase 2.

1.  **PDF Image Extraction Library:**
    *   **Research:** The first step is to research and select a robust Node.js library capable of extracting raw image data (e.g., as buffers) from a PDF file. `pdf-lib` or native command-line tools like `pdfimages` (wrapped in a Node.js process) are potential candidates.
    *   **Implementation:** A new method in `fs.service.ts`, `_extractImagesFromPdf(buffer)`, will be created to handle this process.

2.  **New Service: `ImageDescriptionService`:**
    *   A new backend service, `ImageDescriptionService`, will be created.
    *   This service will be responsible for communicating with a multimodal LLM provider (e.g., Google's Gemini API).
    *   It will have a method like `describeImage(imageBuffer: Buffer): Promise<string>`.
    *   This method will handle the API request, sending the image data and receiving the text description.
    *   It will require API key management, likely extending the existing settings infrastructure.

3.  **Integration with PDF Processing:**
    *   The `RequestPdfToText` handler in `fs.service.ts` will be significantly enhanced.
    *   After parsing the text with `pdf-parse`, it would ideally also call the new image extraction method.
    *   It would then iterate through the extracted images, call the `ImageDescriptionService` for each, and intelligently weave the resulting descriptions back into the main text content to create a comprehensive markdown representation of the entire PDF.
    *   This process would be computationally expensive and time-consuming, requiring clear user feedback (e.g., progress indicators) in the UI.

4.  **Configuration:**
    *   New settings will be added to `package.json` and managed via a settings service to allow the user to:
        *   Enable/disable this feature.
        *   Configure their multimodal API provider and key.
        *   Potentially set a budget or limit on the number of images to process per document.
</file_artifact>

<file path="src/Artifacts/A32. DCE - Phase 1 - Excel and CSV Handling Strategy.md">
# Artifact A32: DCE - Phase 1 - Excel and CSV Handling Strategy
# Date Created: C62
# Author: AI Model
# Updated on: C67 (Revert to xlsx and custom Markdown converter for stability)

- **Key/Value for A0:**
- **Description:** Defines the strategy for handling tabular data files (.xlsx, .xls, .csv) by converting them to Markdown tables on-demand and caching them in memory for flattening.
- **Tags:** feature plan, excel, csv, text extraction, virtualization, cache, phase 1

## 1. Overview & Goal

Following the successful implementation of PDF virtualization, users now require a similar capability for tabular data files, specifically Microsoft Excel (`.xlsx`, `.xls`) and Comma-Separated Values (`.csv`). The goal is to extract the content from these files and represent it as clean, readable Markdown tables within the flattened context. This will be achieved using the same on-demand, in-memory caching strategy to avoid creating temporary files in the user's workspace.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| XLS-01 | **Include Tabular Data in Context** | As a user, when I check an Excel or CSV file, I want its data to be converted to Markdown tables and included in the `flattened_repo.md`, so I can use structured data as context for the LLM. | - Checking `.xlsx`, `.xls`, and `.csv` files is allowed. <br> - The token count displayed for the file reflects its Markdown table content. <br> - When flattened, the content is included within a `<file>` tag. <br> - For Excel files with multiple sheets, each sheet is converted to a separate named Markdown table. <br> - No temporary `.md` files are created in the user's workspace. |

## 3. Technical Implementation Plan (C67 Update)

1.  **Dependency:**
    *   After encountering critical parsing bugs and format limitations with `exceljs`, the project has reverted to using the more robust **`xlsx` (SheetJS)** library. This will be the sole dependency for parsing tabular data.
    *   **Vulnerability Note:** The `xlsx` package has a known high-severity vulnerability. While a direct fix from the library maintainers is not yet available, our implementation mitigates risk by using it only for its core data parsing and implementing our own logic for converting that data to Markdown, rather than using the library's more complex and less-audited utility functions.

2.  **Backend (`fs.service.ts`):**
    *   **In-Memory Cache:** A private cache will be maintained: `private excelMarkdownCache = new Map<string, { markdown: string; tokenCount: number }>();`.
    *   **IPC Handler (`RequestExcelToText`):**
        *   This handler will receive a file path. It will first check the cache.
        *   If not cached, it will read the file buffer.
        *   It will use `XLSX.read(buffer)` to parse the file into a workbook object. This works for `.xlsx`, `.xls`, and `.csv`.
        *   It will iterate through each sheet name in the `workbook.SheetNames`.
        *   For each sheet, it will call a **custom private helper method, `_sheetToMarkdown`**.
    *   **Custom Markdown Converter (`_sheetToMarkdown`):**
        *   This new function will take a worksheet object from `xlsx` as input.
        *   It will use `XLSX.utils.sheet_to_json(worksheet, { header: 1 })` to get an array-of-arrays representation of the sheet.
        *   It will then manually iterate over these arrays to construct a Markdown table string, creating the header row (`| Col1 | Col2 |`), the separator line (`|---|---|`), and all data rows.
        *   This custom implementation provides stability and avoids potential bundling issues with the library's own `sheet_to_markdown` utility.
        *   The final Markdown string (including headers for each sheet) will be concatenated, its token count calculated, and the result stored in the cache.
        *   It will then send an `UpdateNodeStats` message back to the client with the new token count.

3.  **Frontend & Flattener Integration:**
    *   The frontend (`view.tsx`) will continue to trigger the `RequestExcelToText` message on-demand.
    *   The backend (`flattener.service.ts`) will continue to retrieve the virtual Markdown content from the `FSService`'s cache. No changes are needed in these files.
</file_artifact>

<file path="src/Artifacts/A33. DCE - Phase 1 - Copy-Paste Feature Plan.md">
# Artifact A33: DCE - Phase 1 - Copy-Paste Feature Plan
# Date Created: C68
# Author: AI Model

- **Key/Value for A0:**
- **Description:** Details the requirements for implementing copy-paste functionality (Ctrl+C, Ctrl+V) for files and folders within the DCE view, including handling name collisions.
- **Tags:** feature plan, copy, paste, file operations, ux, phase 1

## 1. Overview & Goal

To achieve greater feature parity with the native VS Code Explorer and improve workflow efficiency, this plan outlines the implementation of standard copy-paste functionality for files and folders. Users expect to be able to use `Ctrl+C` and `Ctrl+V` to duplicate items within the file tree. The goal is to provide this intuitive and essential file management feature, complete with robust handling of name collisions to prevent accidental file overwrites.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| CP-01 | **Copy and Paste File/Folder** | As a user, I want to select a file or folder, press `Ctrl+C`, then select a destination folder and press `Ctrl+V` to create a duplicate, so I can quickly copy assets or boilerplate code within my project. | - `Ctrl+C` on a focused file/folder in the DCE view copies its path to an internal clipboard. <br> - `Ctrl+V` pastes the copied item into the currently focused folder. <br> - If a file is focused, the paste occurs in its parent directory. <br> - Pasting a folder also copies its entire contents recursively. |
| CP-02 | **Handle Name Collisions** | As a user, when I paste a file named `file.txt` into a folder that already contains a `file.txt`, I expect the new file to be automatically renamed to `file-copy.txt` (or similar), so I don't accidentally overwrite my work. | - If a file with the same name exists at the destination, the pasted file is renamed. <br> - The renaming scheme is `[original]-copy.[ext]`. <br> - If `[original]-copy.[ext]` also exists, the scheme becomes `[original]-copy-2.[ext]`, `[original]-copy-3.[ext]`, and so on, until a unique name is found. <br> - This applies to both files and folders. |

## 3. Technical Implementation Plan

1.  **IPC Channels (`channels.enum.ts`, `channels.type.ts`):**
    *   Create a new `ClientToServerChannel.RequestCopyFile` channel.
    *   The payload will be `{ sourcePath: string; destinationDir: string; }`.

2.  **Frontend State & Logic (`view.tsx`, `TreeView.tsx`):**
    *   **Clipboard State (`view.tsx`):** Add a new state variable to the main `App` component to act as the internal clipboard: `const [clipboard, setClipboard] = useState<{ path: string; type: 'copy' } | null>(null);`.
    *   **Keyboard Event Handler (`TreeView.tsx`):** Update the `handleKeyDown` function.
        *   It will now listen for `e.key === 'c'` and `e.key === 'v'` when `e.ctrlKey` (or `e.metaKey`) is true.
        *   **On `Ctrl+C`:** It will call a prop function (`onCopy`) passed down from `view.tsx`, which will update the `clipboard` state with the `focusedNodePath`.
        *   **On `Ctrl+V`:** It will check if the `clipboard` state is populated. If so, it will determine the destination directory from the `focusedNodePath` (if the focused node is a folder, use its path; if it's a file, use its parent's path). It will then send the `RequestCopyFile` message to the backend.

3.  **Backend File Operation (`fs.service.ts`):**
    *   **New Handler:** Create a new `async handleCopyFileRequest({ sourcePath, destinationDir })` method.
    *   **Name Collision Logic:**
        *   This handler will contain a private helper function, `private async _findAvailableCopyName(destinationPath: string): Promise<string>`.
        *   This helper will parse the `destinationPath` into its directory, base name, and extension.
        *   It will check if the original path exists using `vscode.workspace.fs.stat`.
        *   If it exists, it will enter a loop, checking for `...-copy.[ext]`, then `...-copy-2.[ext]`, `...-copy-3.[ext]`, etc., until `fs.stat` throws an `ENOENT` error, indicating a free name.
        *   It will return the first available unique path.
    *   **File Copy:** The main handler will call `_findAvailableCopyName` to get the final target path and then use `vscode.workspace.fs.copy(sourceUri, targetUri)` to perform the recursive copy.
    *   The existing file system watcher will automatically detect the new file/folder and trigger a UI refresh.
</file_artifact>

<file path="src/Artifacts/A34. DCE - Phase 2 - Parallel Co-Pilot Panel - Vision & Requirements.md">
# Artifact A34: DCE - Phase 2 - Parallel Co-Pilot Panel - Vision & Requirements
# Date Created: C69
# Author: AI Model
# Updated on: C133 (Add requirement for visual feedback on selection)

- **Key/Value for A0:**
- **Description:** Outlines the high-level vision and user stories for the Phase 2 multi-tabbed editor panel, designed for comparing and managing multiple AI-generated responses. Includes plans for response annotation and a "Cycles Context" field.
- **Tags:** feature plan, phase 2, co-pilot, multi-tab, ui, ux, requirements, annotation, persistence, diff, parsing

## 1. Vision & Goal

Phase 2 of the Data Curation Environment aims to solve the "single-threaded" nature of interacting with AI assistants. The current workflow for developers often involves sending the same prompt to multiple models or conversations, copying the results to separate text files, and then manually integrating them into their project to test. This is inefficient and cumbersome.

The goal of the **Parallel Co-Pilot Panel** is to create an integrated, **persistent** environment within VS Code specifically for managing, comparing, diffing, and testing multiple AI-generated code responses.

**Core Workflow (C91 Update):** The primary interaction model is now **parse-centric** and **globally controlled**. The user pastes raw AI responses into simple text areas in each tab. A single, global "Parse All" button then processes the raw text in all tabs simultaneously, transforming their UIs into a structured, read-only view. This view separates the AI's plan from its code artifacts and includes a new "Associated Files" list for at-a-glance validation.

## 2. Core Concepts

1.  **Dedicated View Container:** The panel has its own icon in the Activity Bar, providing a distinct, full-height space for its UI.
2.  **Stateful & Persistent:** The content of all tabs, context fields, the current cycle number, and the **selected response** are automatically saved. The state persists across sessions and when moving the panel to a new window.
3.  **Global Parse-on-Demand:** A single "Parse All Responses" button in the main header controls the view mode for all tabs.
4.  **Structured, Readable View:** After parsing, each tab's `textarea` is replaced by a static, read-only view that:
    *   Renders the AI's summary and plan as **formatted Markdown**.
    *   Uses **collapsible sections** for the main UI areas (Cycle Info, Summary, etc.) to manage screen real estate.
    *   Displays an **"Associated Files" list** with indicators (`✓`/`✗`) showing if the files exist in the workspace.
    *   Displays individual, **syntax-highlighted** code blocks for each file.
5.  **Live Testing via "Accept":** The core innovation is an "accept" feature. The user can, with a single click, overwrite the content of a workspace file with the AI-generated version.
6.  **Integrated Diffing:** Users can click on a file in the "Associated Files" list to see an immediate diff view comparing the AI's suggestion against the current workspace file.
7.  **Cycle Navigator:** A UI to navigate back and forth through the history of development cycles, loading the corresponding AI responses for each cycle.
8.  **Metadata Display:** Each response tab will display key metadata, such as token counts and similarity scores, to help the user quickly evaluate the AI's output.

## 3. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| P2-US-01 | **Manage Multiple Responses** | As a developer, I want a dedicated panel with multiple tabs where I can place different AI-generated code responses, so I can keep them organized. | - A new icon in the Activity Bar opens the Parallel Co-Pilot panel. <br> - The panel contains a slider or input to select the number of visible tabs. <br> - Each tab initially contains a large text input area. |
| P2-US-02 | **Parse All Responses** | As a developer, after pasting responses into multiple tabs, I want to click a single button to parse all of them into a structured view, so I can easily review them without repetitive clicking. | - A global "Parse All Responses" button exists in the panel's header. <br> - Clicking it processes the raw text in every tab. <br> - Each tab's UI transforms to show distinct sections for summary, action plan, and file blocks. <br> - A corresponding "Un-Parse All" button reverts all tabs to their raw text view. |
| P2-US-03 | **View Formatted Text** | As a developer, I want the AI's summary and plan to be rendered as formatted Markdown, so I can easily read lists, bolded text, and other formatting. | - The summary and course of action sections correctly render Markdown syntax. |
| P2-US-04 | **Manage UI Space** | As a developer, I want to be able to collapse the main sections of the UI, so I can focus on the code blocks without excessive scrolling. | - The Cycle Info, Summary, Course of Action, and Associated Files sections have collapsible headers. |
| P2-US-05 | **Verify Response Validity** | As a developer, I want to see a list of all files an AI response intends to modify, with a clear indicator of whether those files exist in my project, so I can immediately spot hallucinations or new file suggestions. | - After parsing, a list of "Associated Files" is displayed. <br> - A checkmark (`✓`) appears next to files that exist in the workspace. <br> - An 'x' (`✗`) appears next to files that do not exist. |
| P2-US-06 | **Persistent State** | As a developer, I want all the text I've entered and the response I've selected to be saved automatically, so I don't lose my work if I close the panel, move it, or restart VS Code. | - All raw text content and the ID of the selected response is saved to a history file (`.vscode/dce_history.json`). <br> - When the panel is reopened, it loads the state from the most recent cycle. |
| P2-US-07 | **Review Changes with Diff** | As a developer, I want to click on any file in the "Associated Files" list to see a diff, so I can review the exact changes before testing. | - Clicking a file path in the list opens a diff view comparing the workspace version with the AI's version. |
| P2-US-08 | **Navigate Cycle History** | As a developer, I want to navigate backward and forward through my project's development cycles, so I can review past AI suggestions. | - UI controls exist to move between cycles. <br> - Navigating to a past cycle loads its saved raw responses into the panel. |
| P2-US-09 | **Visual Feedback on Selection** | As a user, when I select a response that is ready to be used for the next cycle, I want clear visual feedback, so I know I can proceed with confidence. | - When a response is selected (and other conditions like having a cycle title are met), the current cycle's tab and the selected response's tab turn a distinct color (e.g., green). |
</file_artifact>

<file path="src/Artifacts/A35. DCE - Phase 2 - UI Mockups and Flow.md">
# Artifact A35: DCE - Phase 2 - UI Mockups and Flow
# Date Created: C69
# Author: AI Model
# Updated on: C158 (Add "Project Plan" button for navigation to Cycle 0)

## 1. Overview

This document describes the user interface (UI) and interaction flow for the Parallel Co-Pilot Panel. The design is centered around a two-stage workflow: **Input**, followed by a global **Parse** that transforms the entire panel into a **Review & Act** mode.

## 2. UI Mockup (Textual Description)

### 2.1. Main Header & Cycle Section
The main header contains global actions.

```
|-------------------------------------------------------------------------------------------------|
| [ Project Plan ] [ Generate prompt.md ] [ Log State ] [ Parse All ] [ Sort by Tokens ] [ Resp: [ 4 ] ] |
|-------------------------------------------------------------------------------------------------|
| [v] CYCLE & CONTEXT (C158: Review and Implement Feedback)                                       |
| |---------------------------------------------------------------------------------------------| |
| | Cycle: [ < ] [ C158 ] [ > ] [ + ] [ Title Input... ] [Delete] [Reset]                       | |
| | [ Cycle Context Text Area... ]                                                              | |
| | [ Ephemeral Context Text Area... ]                                                          | |
|-------------------------------------------------------------------------------------------------|
```
*   **`[ Project Plan ]` (New):** A new button in the main header. Clicking it navigates the user back to the Cycle 0 "Onboarding View," allowing them to view and edit their master project scope.

### 2.2. Response Tabs
The tabs now display metadata when in parsed mode.

```
|=================================================================================================|
| [ Resp 1 (5 files, 2.1K tk) ] [ Resp 2 (4 files, 1.8K tk) ] [ Resp 3 ] [ Resp 4 ]                |
|-------------------------------------------------------------------------------------------------|
```
*   **Tab Metadata:** When parsed, each tab will show the number of files detected in its response and the total token count of those files.

### 2.3. Parsed View (Non-Diff Mode)
(No changes from C134)

### 2.4. Diff View
(No changes from C133)

## 3. User Interaction Flow

1.  **Edit Project Scope:** The user is on Cycle 158 and realizes they need to update their high-level project plan.
    *   They click the new **`[ Project Plan ]`** button.
    *   The PCPP view changes to the "Onboarding View" (Cycle 0), displaying the large text area with their current project scope.
    *   A "Return to Cycles" button is now visible.
    *   The user edits their project scope and the changes are auto-saved.
    *   They click "Return to Cycles" and are taken back to their latest cycle (Cycle 158). The next time they click "Generate prompt.md," the updated scope will be used.
2.  **Paste & Parse:** User pastes responses and clicks "Parse All". The tabs update to show metadata (e.g., "Resp 1 (5 files, 2.1K tk)").
3.  **Sort Responses:** The user notices "Resp 2" has a higher token count than "Resp 1". They click the **"Sort by Tokens"** button. The order of the tabs in the tab bar immediately changes to `[ Resp 2 ] [ Resp 1 ] [ Resp 4 ] [ Resp 3 ]` (based on their respective token counts). The user can now review the longest, likely most detailed, response first.
4.  **Select & Accept:** The rest of the workflow for selecting and accepting files remains the same.
</file_artifact>

<file path="src/Artifacts/A36. DCE - Phase 2 - Technical Implementation Plan.md">
# Artifact A36: DCE - Phase 2 - Technical Implementation Plan
# Date Created: C69
# Author: AI Model
# Updated on: C137 (Add selectedFilesForReplacement to persisted state)

- **Key/Value for A0:**
- **Description:** Details the technical approach for building the Parallel Co-Pilot Panel, including the new webview provider, state management, IPC channels, and backend logic for file content swapping.
- **Tags:** feature plan, phase 2, technical plan, architecture, webview, ipc, parsing, markdown, diff

## 1. Overview

This document outlines the technical implementation strategy for the Parallel Co-Pilot Panel. The plan is updated to reflect several UI/UX fixes and new features from recent cycles.

## 2. Core Components

### 2.1. Frontend State Management (`view.tsx`)

The component state will be expanded to manage the new UI features.

```typescript
// State within the view.tsx component
interface PcppState {
  // ... existing state
  selectedFilesForReplacement: Set<string>; // This state must be persisted per-cycle
  fileExistenceMap: Map<string, boolean>;
}```
*   **`selectedFilesForReplacement`**: This state must be explicitly cleared when the user navigates to a new or different cycle to prevent "state bleeding." It must also be saved as part of the `PcppCycle` object.
*   **`fileExistenceMap`**: This state must be updated after a file is successfully created via the "Accept" functionality to provide immediate UI feedback.

### 2.2. Robust "New Cycle" Button Logic

*   **Goal:** The `[ + ]` (New Cycle) button must be disabled until all required precursor data from the *previous* cycle is present.
*   **Implementation (`view.tsx`):** The `isNewCycleButtonDisabled` memoized boolean will be updated. It must now check:
    1.  That the `cycleTitle` of the *current* cycle is non-default and not empty.
    2.  That the `cycleContext` of the *current* cycle is not empty.
    3.  That a `selectedResponseId` has been set for the *current* cycle.
    *   This ensures that a user cannot create an orphaned "Cycle 2" before they have finished providing all the necessary inputs for "Cycle 1".

### 2.3. Clearing Selection State on Navigation
*   **Goal:** Fix the bug where checked files from one cycle remain checked when viewing another cycle.
*   **Implementation (`view.tsx`):** The `handleCycleChange` and `handleNewCycle` functions will explicitly reset the `selectedFilesForReplacement` state to `new Set()` on every navigation.

### 2.4. IPC Channel Updates

*   **`ServerToClientChannel.FilesWritten`:** A channel to provide direct feedback from the backend to the PCPP frontend after a file write operation.
*   **`RequestLogState`:** A channel to facilitate the "Log State" feature.

### 2.5. Backend State Synchronization (`file-operation.service.ts`, `on-message.ts`)

*   **Goal:** Fix the UI desynchronization bug where a newly created file still shows a red `✗`.
*   **Implementation:** The `handleBatchFileWrite` method in `file-operation.service.ts` will return the paths of successfully written files. The `on-message.ts` handler will then send a `FilesWritten` message back to the frontend, which will update its `fileExistenceMap` state.

### 2.6. Backend State Logging (`prompt.service.ts`)

*   **Goal:** Implement the logic for the "Log State" button.
*   **Implementation:** A new method, `generateStateLog`, will be added to `PromptService`. It will receive the frontend state, construct a comprehensive log message including a JSON dump and the generated `<M6. Cycles>` block, and send it to the `LoggerService`.
</file_artifact>

<file path="src/Artifacts/A37. DCE - Phase 2 - Cycle Navigator & Knowledge Graph - Vision.md">
# Artifact A37: DCE - Phase 2 - Cycle Navigator & Knowledge Graph - Vision
# Date Created: C70
# Author: AI Model

- **Key/Value for A0:**
- **Description:** Outlines the vision for a cycle-based navigation system to browse the history of AI-generated responses and project states, creating a navigable knowledge graph.
- **Tags:** feature plan, phase 2, knowledge graph, history, cycle navigator, ui, ux

## 1. Vision & Goal

As the Data Curation Environment matures, the interaction history with the AI becomes a valuable asset in itself. Currently, this history is ephemeral, existing only within the context of a single session. The vision for the **Cycle Navigator & Knowledge Graph** is to capture this history and make it a persistent, navigable, and core feature of the development workflow.

The goal is to transform the series of AI interactions from a linear conversation into a structured, explorable history of the project's evolution. This creates a "knowledge graph" where each node is a development cycle, and the edges are the AI-generated solutions that led from one cycle to the next.

## 2. Core Concepts

1.  **Cycle-Based History:** The fundamental unit of history is the "Cycle." Every time the curator sends a prompt and receives responses, that entire transaction is associated with a unique Cycle ID (e.g., `C70`).
2.  **Persistent Response Storage:** All AI-generated responses (the content that would be pasted into the Parallel Co-Pilot tabs) are saved and tagged with their corresponding Cycle ID.
3.  **UI for Navigation:** A simple, non-intrusive UI will be added to the Parallel Co-Pilot panel, allowing the user to step backward and forward through the cycles.
4.  **Historical Context Loading:** As the user navigates to a past cycle (e.g., from `C70` to `C69`), the Parallel Co-Pilot panel will automatically load the set of AI responses that were generated during that cycle.

## 3. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| P2-US-06 | **Navigate Project History** | As a developer, I want to navigate backward and forward through my project's development cycles, so I can review past decisions and the AI suggestions that prompted them. | - A UI control (e.g., left/right arrows and a cycle number display) is present in the Parallel Co-Pilot panel. <br> - Clicking the arrows changes the currently viewed cycle. |
| P2-US-07 | **View Historical Responses** | As a developer, when I navigate to a previous cycle, I want the Parallel Co-Pilot tabs to automatically populate with the AI-generated responses from that specific cycle, so I can see exactly what options I was considering at that time. | - Navigating to a cycle loads the associated set of AI responses into the tabs. <br> - The metadata (token counts, etc.) for these historical responses is also displayed. |
| P2-US-08 | **Preserve Interaction Context** | As a developer, I want every AI response to be automatically saved and associated with the current cycle, so a complete and accurate history of the project is built over time. | - A mechanism exists to automatically persist all AI responses received. <br> - Each response is tagged with a Cycle ID and a unique response UUID. |
</file_artifact>

<file path="src/Artifacts/A38. DCE - Phase 2 - Cycle Navigator - UI Mockup.md">
# Artifact A38: DCE - Phase 2 - Cycle Navigator - UI Mockup
# Date Created: C70
# Author: AI Model

- **Key/Value for A0:**
- **Description:** Provides a textual mockup and interaction flow for the Cycle Navigator UI, including the cycle counter and navigation controls within the Parallel Co-Pilot Panel.
- **Tags:** feature plan, phase 2, ui, ux, mockup, workflow, cycle navigator

## 1. Overview

This document describes the proposed user interface (UI) for the Cycle Navigator. The design prioritizes simplicity and integration, placing the navigation controls directly within the Parallel Co-Pilot Panel, reinforcing the connection between the cycle history and the AI responses.

## 2. UI Mockup (Textual Description)

The Cycle Navigator will be a new UI element added to the top of the Parallel Co-Pilot Panel, positioned just below the main header and above the tab configuration slider.

```
+-----------------------------------------------------------------+
| [Parallel Co-Pilot] [Settings Icon]                             |
|-----------------------------------------------------------------|
| Cycle: [ < ] [ C70 ] [ > ]                                      |
|-----------------------------------------------------------------|
| Number of Tabs: [Slider: 1 to 8]  (Current: 4)                  |
|=================================================================|
| [ Tab 1 (active) ] [ Tab 2 ] [ Tab 3 ] [ Tab 4 ] [ + ]           |
|-----------------------------------------------------------------|
|                                                                 |
|   [Swap with Source]                                            |
|                                                                 |
|   Source: src/services/user.service.ts                          |
|   ------------------------------------------------------------  |
|   |          | Original Source      | This Tab (Response 1) |  |
|   | Lines    | 150                  | 165                   |  |
|   | Tokens   | 2.1K                 | 2.4K                  |  |
|   |----------|----------------------|-----------------------|  |
|   | Similarity Score: 85%                                   |  |
|   ------------------------------------------------------------  |
|                                                                 |
|   [Text editor area where user pastes AI-generated code...]     |
|   |                                                         |   |
|   | export class UserService {                              |   |
|   |   // ... AI generated code ...                           |   |
|   | }                                                       |   |
|   |                                                         |   |
|                                                                 |
+-----------------------------------------------------------------+
```

### 2.1. UI Components Breakdown

1.  **Cycle Navigator Bar:**
    *   A new horizontal bar containing the navigation controls.
    *   **Label:** "Cycle:".
    *   **Previous Button (`<`):** A button with a left-arrow icon. Clicking it navigates to the previous cycle (e.g., `C69`). The button is disabled if the user is at the very first recorded cycle.
    *   **Cycle Display (`C70`):** A read-only (or potentially editable) text field showing the ID of the currently viewed cycle.
    *   **Next Button (`>`):** A button with a right-arrow icon. Clicking it navigates to the next cycle (e.g., `C71`). The button is disabled if the user is at the most recent cycle.

## 3. User Interaction Flow

1.  **Initial State:** The user is working on Cycle 70. The Cycle Display shows `C70`. The `>` button is disabled. The Parallel Co-Pilot tabs show the AI responses generated for Cycle 70.
2.  **Navigate Back:**
    *   The user clicks the **`<`** button.
    *   **Action:** The extension's state updates to the previous cycle, `C69`.
    *   **UI Update:** The Cycle Display changes to `C69`.
    *   **Data Load:** The Parallel Co-Pilot panel fetches the historical data for Cycle 69. The tabs are cleared and re-populated with the AI responses that were generated during that cycle. The metadata and similarity scores all update to reflect this historical data. Both `<` and `>` buttons are now enabled.
3.  **Navigate Forward:**
    *   The user is viewing Cycle 69 and clicks the **`>`** button.
    *   **Action:** The state moves forward to `C70`.
    *   **UI Update & Data Load:** The UI returns to the state described in step 1. The `>` button becomes disabled again.
</file_artifact>

<file path="src/Artifacts/A39. DCE - Phase 2 - Cycle Navigator - Technical Plan.md">
# Artifact A39: DCE - Phase 2 - Cycle Navigator - Technical Plan
# Date Created: C70
# Author: AI Model
# Updated on: C92 (Revise initialization flow to fix persistence issues)

- **Key/Value for A0:**
- **Description:** Details the technical approach for implementing the Cycle Navigator, including data structures for storing cycle-specific responses and the state management for historical navigation.
- **Tags:** feature plan, phase 2, technical plan, architecture, state management, data model

## 1. Overview

This document outlines the technical strategy for implementing the Cycle Navigator and PCPP persistence. The implementation will require a structured data format for storing historical data, enhancements to the frontend state management, new IPC channels, and robust backend logic for data persistence. The key change in this revision is a new initialization flow to make the backend the single source of truth, resolving state loss on reload or window pop-out.

## 2. Data Structure and Persistence

A structured approach to storing the historical data is critical. A simple JSON file stored within the workspace's `.vscode` directory is a suitable starting point.

### 2.1. `dce_history.json` (Example)

```json
{
  "version": 1,
  "cycles": [
    {
      "cycleId": 91,
      "timestamp": "2025-08-20T12:30:00Z",
      "title": "Initial implementation",
      "cycleContext": "Long-term notes...",
      "ephemeralContext": "<console_log>...</console_log>",
      "responses": {
        "1": { "content": "<src/client/views/view.tsx>...</file>" },
        "2": { "content": "..." },
        "3": { "content": "" }
      }
    },
    {
      "cycleId": 92,
      "timestamp": "2025-08-21T10:00:00Z",
      "title": "Persistence fix",
      "cycleContext": "Focus on fixing state loss.",
      "ephemeralContext": "",
      "responses": {
        "1": { "content": "" }, "2": { "content": "" }, "3": { "content": "" }, "4": { "content": "" }
      }
    }
  ]
}
```

*   **Backend (`history.service.ts`):** This service will manage reading from and writing to `dce_history.json`. It will handle file locking to prevent race conditions and provide methods like `getCycle(cycleId)`, `saveCycle(cycleData)`, `getCycleList()`, and a new `getLatestCycle()`.

## 3. Frontend State Management & Initialization Flow (C92 Revision)

### 3.1. Initialization
1.  **Problem:** Previously, the frontend managed its own state and only requested pieces of data, leading to state loss when the webview was re-initialized (e.g., on reload or pop-out).
2.  **Solution:** The new flow makes the backend the single source of truth.
    *   On component mount, the frontend sends a single new IPC message: `RequestLatestCycleData`.
    *   The backend's `HistoryService` finds the cycle with the highest `cycleId` in `dce_history.json`. If the file is empty, it creates a default "Cycle 1" object.
    *   The backend sends this complete `PcppCycle` object back to the client via `SendLatestCycleData`.
    *   The frontend's message handler uses this single object to populate its *entire* initial state: `currentCycleId`, `maxCycleId`, `cycleTitle`, `cycleContext`, `ephemeralContext`, and all `tabs` content. This guarantees the UI always starts with the latest saved data.

### 3.2. State Management (`parallel-copilot.view.tsx`)
```typescript
interface PcppState {
  currentCycleId: number;
  maxCycleId: number;
  cycleTitle: string;
  // ... other state
}
```
*   The state remains largely the same, but it is now initialized from a single backend message.
*   A "New Cycle" button (`+`) will be added. Its handler will increment `maxCycleId`, set `currentCycleId = maxCycleId`, clear the UI fields, and trigger a `saveCycleData` call to create the new empty cycle record.

## 4. IPC Communication

*   **REMOVED:** `RequestCycleHistoryList`.
*   **NEW:** `ClientToServerChannel.RequestLatestCycleData`:
    *   **Payload:** `{}`
    *   **Action:** Frontend requests the full data object for the most recent cycle.
*   **NEW:** `ServerToClientChannel.SendLatestCycleData`:
    *   **Payload:** `{ cycleData: PcppCycle }`
    *   **Action:** Backend sends the complete, latest cycle data to the frontend for initialization.
*   `ClientToServerChannel.RequestCycleData`: Still used for navigating to *older* cycles.
*   `ClientToServerChannel.SaveCycleData`: Unchanged. It sends the entire state of the *current* cycle to the backend to be persisted. It's critical that the `cycleId` in the payload is correct.
</file_artifact>

<file path="src/Artifacts/A40. DCE - Phase 2 - Parallel Co-Pilot - Target File Structure.md">
# Artifact A40: DCE - Phase 2 - Parallel Co-Pilot - Target File Structure
# Date Created: C71
# Author: AI Model

- **Key/Value for A0:**
- **Description:** A text-based representation of the new files and components required to build the Phase 2 Parallel Co-Pilot and Cycle Navigator features.
- **Tags:** file structure, architecture, project layout, scaffolding, phase 2

## 1. Overview

This document outlines the new files and directories that will be created to support the development of the Phase 2 features: the Parallel Co-Pilot Panel and the Cycle Navigator. This structure is designed to be modular and integrate cleanly with our existing architecture. This artifact also serves as the "pre-computation" plan requested in C71, allowing for a script to be created to scaffold these files when development begins.

## 2. New File Tree for Phase 2

This tree shows only the **new** files and directories to be added. Existing directories will be modified to import and use these new components.

```
src/
├── backend/
│   └── services/
│       └── history.service.ts      # New: Manages reading/writing dce_history.json
│
└── client/
    ├── components/
    │   ├── DiffViewer.tsx          # New (for Phase 3, but can be stubbed): A component for side-by-side text diffing.
    │   ├── Slider.tsx              # New: A simple reusable slider component for the tab count.
    │   └── TabbedEditor.tsx        # New: The core multi-tab editor component.
    │
    ├── views/
    │   └── parallel-copilot.view/  # New View for Phase 2
    │       ├── index.ts
    │       ├── on-message.ts
    │       ├── view.scss
    │       └── view.tsx            # Main React component for the Parallel Co-Pilot panel
    │
    └── utils/
        └── string-similarity.ts    # New: A lightweight utility for calculating string similarity scores.

.vscode/
└── dce_history.json                # New (auto-generated): Stores the cycle history and AI responses.
```

## 3. Component & Service Descriptions

### Backend

-   **`src/backend/services/history.service.ts`:**
    -   **Responsibility:** Solely responsible for abstracting the file I/O for the `dce_history.json` file.
    -   **Methods:** `getCycleHistory()`, `getCycleData(cycleId)`, `saveResponseToCycle(...)`. This keeps the main `fs.service.ts` clean from business logic.

### Frontend Components

-   **`src/client/views/parallel-copilot.view/`:**
    -   This new directory will contain everything needed for the new panel, following the same structure as our existing `context-chooser.view`.
    -   `view.tsx` will be the main component, managing the state for all tabs, the current cycle, and orchestrating IPC communication.
-   **`src/client/components/TabbedEditor.tsx`:**
    -   A component that will manage the tab bar and the content of each tab editor, receiving the array of tab data as props.
-   **`src/client/components/Slider.tsx`:**
    -   A simple, reusable slider component to control the number of tabs. This extracts UI logic from the main view.
-   **`src/client/utils/string-similarity.ts`:**
    -   Will contain a function to calculate the similarity between two strings, likely implementing the Dice Coefficient or a similar algorithm. This keeps the calculation logic separate and testable.

### Root Directory

-   **`.vscode/dce_history.json`:**
    -   This file will be automatically created and managed by the `HistoryService`. Storing it in `.vscode` is standard practice for workspace-specific extension data that should not typically be checked into source control. It will be added to `.gitignore`.
</file_artifact>

<file path="src/Artifacts/A40.1. DCE - Phase 2 - Competitive Analysis & Feature Ideas.md">
# Artifact A40.1: DCE - Phase 2 - Competitive Analysis & Feature Ideas
# Date Created: C71
# Author: AI Model
# Updated on: C71 (Incorporate user feedback and consolidate ideas)

- **Key/Value for A0:**
- **Description:** An analysis of existing tools and extensions for managing multiple AI responses, with a list of potential features to incorporate into the Parallel Co-Pilot panel.
- **Tags:** feature plan, phase 2, research, competitive analysis, co-pilot

## 1. Overview

As requested in Cycle 71, this document summarizes research into existing tools that address the problem of managing and comparing multiple AI-generated code responses. The goal is to identify common features, discover innovative ideas, and ensure our Phase 2 "Parallel Co-Pilot Panel" is a best-in-class solution.

## 2. Research Summary

A search for "VS Code extensions for comparing AI responses" reveals that while many extensions integrate a single AI chat (like GitHub Copilot Chat), very few are designed for the specific workflow of managing *multiple, parallel* responses to the *same* prompt. [1, 3] This represents a significant opportunity for our project. The "AI Toolkit for Visual Studio Code" is a notable exception, offering features to run prompts against multiple models simultaneously and compare the results, validating our core concept. [1, 2]

Most developers still use a manual process involving external tools:
1.  Pasting responses into separate tabs in a text editor (Notepad++, Sublime Text).
2.  Using a dedicated diff tool (WinMerge, Beyond Compare, VS Code's native diff) to compare two responses at a time.

The key pain point is the friction of moving text between applications and the lack of an integrated testing loop, which our "swap" feature directly addresses.

## 3. Existing Tools & Inspirations

| Tool / Extension | Relevant Features | How It Inspires DCE |
| :--- | :--- | :--- |
| **AI Toolkit for VS Code** | - "Bulk Run" executes a prompt across multiple models simultaneously. [1] <br> - "Compare" view for side-by-side model responses. [2] <br> - Model evaluation with metrics like similarity and relevance. [2] | This extension is the closest conceptually to our goal. It validates the need for parallel prompting and comparison. Our "swap" feature for live testing remains a key differentiator. |
| **Cursor.sh (IDE)** | - A fork of VS Code built around an AI-first workflow. <br> - "Auto-debug" feature attempts to fix errors. <br> - Inline diffing for AI-suggested changes. | Cursor's deep integration is a long-term inspiration. An "Auto-fix TS Errors" button in our panel could be a powerful feature, where we send the code + errors back to the AI. |
| **Continue.dev** | - Open-source and customizable. <br> - Strong concept of "Context Providers," very similar to our Phase 1. | Their flexible context system is a good model. A future DCE feature could allow highlighting a specific function and sending *just that* to the Parallel Co-Pilot panel for iteration. |

## 4. New Feature Ideas for DCE Phase 2 (Refined with C71 Feedback)

Based on the analysis and our project goals, here are some new or refined feature ideas for the Parallel Co-Pilot Panel:

| Feature Idea | Description |
| :--- | :--- |
| **"Accept Response" Button** | As per user feedback, this is a more intuitive name than "Promote to Source". A button to overwrite the source file with the tab's content without swapping back. This signifies a permanent acceptance of the AI's suggestion for that cycle. |
| **One-Click Diff View** | A button that opens VS Code's native diff viewer, comparing the tab's content with the original source file. This is a great stepping stone to our fully integrated Phase 3 diff tool. |
| **AI-Powered Summary of Changes** | A button that sends the original code and the tab's code to an LLM with a prompt like "Summarize the key changes between these two code blocks." The summary would be displayed in the tab's metadata area. |
| **Response Annotation & Rating** | A feature the user liked: Allow adding thumbs up/down, tags (e.g., `refactor`, `bug-fix`), and comments to each response tab. This metadata would be saved with the cycle history, adding valuable context. |
| **Intent Buttons** | As per user feedback, instead of slash commands, provide clear buttons for common refinement tasks like "Add Documentation," "Find Bugs," or "Refactor for Readability." These would re-prompt the AI with the tab's content and the specific instruction. |
| **Ephemeral "Cycles Context" Field** | As per user feedback, add a separate text field for temporary context like error logs that are useful for the current cycle's prompt but should not be saved in the long-term cycle history to avoid token bloat. |
</file_artifact>

<file path="src/Artifacts/A41. DCE - Phase 2 - API Key Management - Feature Plan.md">
# Artifact A41: DCE - Phase 2 - API Key Management - Feature Plan
# Date Created: C71
# Author: AI Model

- **Key/Value for A0:**
- **Description:** Outlines the user stories and technical plan for a settings UI where users can securely input and manage their API keys for various LLM services or a local endpoint URL.
- **Tags:** feature plan, phase 2, settings, api key, configuration, security

## 1. Overview & Goal

As the DCE project moves into Phase 2, it will begin to make its own API calls to LLM providers. To do this securely and flexibly, the extension needs a dedicated interface for users to manage their API keys and specify a local LLM endpoint. The goal of this feature is to provide a simple, secure, and intuitive settings panel for managing these credentials.

This functionality is heavily inspired by the `ApiKeysManagement.tsx` module in the `The-Creator-AI-main` reference repository.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| P2-API-01 | **Configure API Key** | As a user, I want to add an API key for a specific cloud service (e.g., Gemini, OpenAI), so the extension can make API calls on my behalf. | - A UI is available to add a new API key. <br> - I can select the LLM provider from a dropdown list. <br> - I can paste my key into a text field. <br> - The key is stored securely using VS Code's `SecretStorage` API. |
| P2-API-02 | **Configure Local LLM Endpoint** | As a user with a local LLM (e.g., via LM Studio), I want to provide an API endpoint URL, so the extension can use my local model instead of a cloud service. | - The settings UI has a dedicated input field for a local LLM API URL. <br> - The URL is saved to the workspace settings. <br> - The extension prioritizes using this URL if it is set. |
| P2-API-03 | **View Saved Keys** | As a user, I want to see a list of my saved API keys (partially masked), so I can confirm which keys I have configured. | - The settings UI displays a list of all saved API keys. <br> - Keys are grouped by service. <br> - The key values are partially masked for security (e.g., `sk-xxxx...1234`). |
| P2-API-04 | **Delete an API Key** | As a user, I want to delete an API key that I no longer use, so I can manage my credentials. | - Each listed API key has a "Delete" button. <br> - Clicking "Delete" prompts for confirmation. <br> - Upon confirmation, the key is removed from the extension's secure storage. |
| P2-API-05 | **Secure Storage** | As a developer, I want API keys to be stored securely using VS Code's `SecretStorage` API, so sensitive user credentials are not exposed as plain text. | - API keys are not stored in plain text in `settings.json` or workspace state. <br> - The `SecretStorage` API is used to encrypt and store the keys, associating them with the extension. |

## 3. Technical Implementation Plan

1.  **New View / Command:**
    *   A new command, `dce.openApiSettings`, will be created. This command will open a new webview panel dedicated to API key management. This keeps the UI clean and separate from the main workflow panels.
    *   This can be triggered from a "Settings" icon within the Parallel Co-pilot view.

2.  **Backend (`settings.service.ts` - New):**
    *   A new `SettingsService` will be created to handle the logic for storing and retrieving secrets and settings.
    *   **API Key Storage:** It will use `vscode.ExtensionContext.secrets` (the `SecretStorage` API) for all API key operations.
    -   **Local URL Storage:** It will use the standard `vscode.workspace.getConfiguration` API to get/set the local LLM URL in the workspace `settings.json`.
    *   **Methods:** It will expose methods like `setApiKey(service: string, key: string)`, `getApiKeys()`, `deleteApiKey(service: string)`, `getLocalLlmUrl()`, and `setLocalLlmUrl(url: string)`. The `getApiKeys` method will return a structure with masked keys for the UI.

3.  **Frontend (New `api-settings.view.tsx`):**
    *   This new React view will render the UI for managing keys and the local endpoint URL.
    *   It will communicate with the backend `SettingsService` via new IPC channels.

4.  **IPC Channels:**
    *   `RequestApiKeys`: Frontend asks for the list of saved (masked) keys.
    *   `SendApiKeys`: Backend sends the list of keys.
    *   `SaveApiKey`: Frontend sends a new service and key to the backend.
    *   `DeleteApiKey`: Frontend requests the deletion of a specific key.
    *   `RequestLocalLlmUrl` / `SendLocalLlmUrl`
    *   `SaveLocalLlmUrl`
</file_artifact>

<file path="src/Artifacts/A41.1. DCE - Phase 2 - Advanced Features & Integrations Plan.md">
# Artifact A41.1: DCE - Phase 2 - Advanced Features & Integrations Plan
# Date Created: C71
# Author: AI Model

- **Key/Value for A0:**
- **Description:** Explores future enhancements for the Parallel Co-Pilot, such as applying AI responses as diff patches and integrating with Git for direct commits.
- **Tags:** feature plan, phase 2, ideation, diff, patch, git, workflow

## 1. Overview & Goal

This document explores potential high-impact features that could be built on top of the core Parallel Co-Pilot panel. The goal is to move beyond simple "swap" functionality and create a more powerful, integrated, and intelligent workflow for reviewing and applying AI-generated code. These ideas are intended for consideration and prioritization during Phase 2 development.

## 2. Proposed Advanced Features

### 2.1. Idea: Apply as Diff/Patch

-   **Problem:** The current "swap" feature is a blunt instrument. It replaces the entire file, which can be risky if the AI only intended to change a small part of it and made a mistake elsewhere. It also makes it hard to see exactly what changed.
-   **Proposed Solution:**
    1.  **Diff Generation:** When an AI response is pasted into a tab, the extension automatically generates a diff between the tab's content and the original source file.
    2.  **Inline Diff View:** The editor in the tab could be enhanced to show an inline diff view (similar to VS Code's source control view), highlighting added and removed lines.
    3.  **"Apply Patch" Button:** The "Swap" button is replaced with an "Apply Patch" button. Clicking it would attempt to apply only the identified changes to the source file, leaving the rest of the file untouched. This is a much safer and more precise way to integrate AI suggestions.
-   **Technical Notes:** This would require a diffing library (e.g., `diff-match-patch` or `jsdiff`) on the frontend or backend to generate and apply patches.

### 2.2. Idea: Integrated Git Workflow

-   **Problem:** After a developer tests and accepts an AI suggestion, the next step is almost always to commit the change. This requires leaving the co-pilot panel and using the source control view.
-   **Proposed Solution:**
    1.  **"Commit This Change" Button:** Add a new button to each tab in the Parallel Co-Pilot panel.
    2.  **Workflow:**
        *   The user swaps in the AI code and verifies it works.
        *   They click "Commit This Change".
        *   The extension automatically stages the modified file (`git add <file_path>`).
        *   The extension opens the Source Control commit input box.
        *   **Enhancement:** The commit message box could be pre-populated with a summary of the changes, potentially generated by another AI call based on the diff.
-   **Technical Notes:** This requires deeper integration with the `vscode.git` extension API to programmatically stage files and interact with the commit box.

### 2.3. Idea: Response Annotation and Rating

-   **Problem:** It's difficult to remember why a particular AI response was good or bad, especially when looking back at the history via the Cycle Navigator.
-   **Proposed Solution:**
    1.  **Rating/Annotation UI:** Add a small section to each tab allowing the user to give a thumbs up/down rating and add a short text note (e.g., "Works, but inefficient" or "Best solution, very clean"). This includes highlighting specific sections of code to associate with a comment.
    2.  **Persistence:** These annotations would be saved as part of the `dce_history.json` file, associated with that specific response.
    3.  **Benefit:** When navigating back through cycles, these notes would provide valuable context about the quality and outcome of each AI suggestion, enhancing the "knowledge graph" of the project.
-   **Technical Notes:** This requires extending the data model in `A39` and adding the corresponding UI elements and state management.
</file_artifact>

<file path="src/Artifacts/A41.2. DCE - Phase 2 - Feature Ideation & Competitive Analysis.md">
# Artifact A41.2: DCE - Phase 2 - Feature Ideation & Competitive Analysis
# Date Created: C71
# Author: AI Model
# Updated on: C71 (Incorporate user feedback from C71)

- **Key/Value for A0:**
- **Description:** An analysis of similar AI coding assistant tools (e.g., Cursor.sh, Copilot Chat) and a brainstorm of potential advanced features for the Parallel Co-Pilot panel.
- **Tags:** feature plan, phase 2, research, competitive analysis, ideation, roadmap

## 1. Overview & Goal

The core vision of the Parallel Co-Pilot panel is to solve the "single-threaded" limitation of current AI chat interfaces. As we plan its implementation, it's valuable to analyze existing tools to identify best-in-class features and brainstorm new ideas that could give our extension a unique advantage. The goal of this document is to explore this landscape and generate a backlog of potential enhancements for Phase 2 and beyond, incorporating feedback from Cycle 71.

## 2. Competitive Analysis (Incorporating Search Results [1, 2, 3, 4])

### 2.1. GitHub Copilot Chat & Similar Tools
-   **Strengths:** Deeply integrated, understands editor context, uses "slash commands" (`/fix`, `/doc`) for specific intents. [5]
-   **Weakness (Our Opportunity):** Fundamentally a linear, single-threaded chat. Comparing multiple responses to a single prompt is difficult and requires manual copy-pasting. Our parallel tabbed view is a direct solution to this.

### 2.2. Cursor.sh
-   **Strengths:** An "AI-first" fork of VS Code. Has an "AI-diff" feature that applies changes directly in the editor with an intuitive diff view.
-   **Weakness (Our Opportunity):** It's a separate application, not an extension. Users must leave their standard VS Code setup. Our tool integrates into the existing environment. The user has also specified a preference for a whole-file workflow over Cursor's chunk-based edits.

### 2.3. AI Toolkit for Visual Studio Code
-   **Strengths:** This is the most conceptually similar tool found. It explicitly supports a "Bulk Run" feature to execute prompts across multiple models simultaneously and a "Compare" view to see results side-by-side. [1, 2]
-   **Weakness (Our Opportunity):** While it excels at comparison, its workflow for *testing* the code within the user's live project is not as streamlined. Our "Swap" feature provides an immediate, integrated test loop that appears to be a unique advantage.

## 3. Brainstormed Feature Enhancements for DCE (Refined with C71 Feedback)

This is a backlog of potential features for the Parallel Co-Pilot panel, inspired by the analysis and our project's unique goals.

| Feature ID | Feature Name | Description | Priority |
| :--- | :--- | :--- | :--- |
| **P2-F01** | **Inline Diff View** | Instead of a blind "swap", clicking a button opens a diff view within the tab, comparing the AI response to the source file. The user can then accept the full change. | High |
| **P2-F02** | **AI Refinement Actions (Intent Buttons)** | Per user feedback, each tab will have a small toolbar with **buttons** like "Add Docs," "Find Bugs," or "Refactor." Clicking one sends the tab's content back to the LLM with that specific instruction, replacing the content with the refined response. | High |
| **P2-F03** | **Model Selection Per Tab** | Allow the user to select a different backend LLM (e.g., Gemini, Claude, Local URL) for each tab. This requires the API Key Management feature from `A41`. | Medium |
| **P2-F04** | **"Accept Response" Workflow** | Formalize the user's feedback. The "Swap" button is for temporary, iterative testing. A separate, explicit **"Accept Response"** button will permanently overwrite the source file, signifying the end of that iteration for that file. | High |
| **P2-F05** | **Response Annotation & Rating** | A feature the user liked: Add UI for thumbs up/down, short text notes, and tags (e.g., "works", "buggy"). This metadata is saved with the cycle history, enhancing the knowledge graph. | Medium |
| **P2-F06** | **Highlight-to-Context** | Allow a user to highlight a block of code in the main editor, right-click, and select "Send to Parallel Co-Pilot". This would open a new tab in the panel, pre-filled with the highlighted code. | Medium |
| **P2-F07** | **Ephemeral "Cycles Context" Field** | Per user feedback, add a separate text field for temporary context (e.g., error logs). This content is included in the prompt for the current cycle but is NOT saved to the permanent `dce_history.json` to prevent token bloat over time. | High |
</file_artifact>

<file path="src/Artifacts/A43. DCE - Phase 2 - Implementation Roadmap.md">
# Artifact A43: DCE - Phase 2 - Implementation Roadmap
# Date Created: C72
# Author: AI Model
# Updated on: C87 (Promote Persistence and Diffing, defer advanced UI)

- **Key/Value for A0:**
- **Description:** Provides a step-by-step implementation plan for building the Phase 2 features, including the Parallel Co-Pilot panel and the integrated Diff Tool.
- **Tags:** feature plan, phase 2, roadmap, project plan, diff tool

## 1. Overview & Goal

This document provides a clear, step-by-step roadmap for the implementation of Phase 2. The scope of Phase 2 is now defined as the **Parallel Co-Pilot Panel with state persistence and an integrated Diff Tool**. This roadmap breaks the large feature set into smaller, manageable, and testable steps. The goal is to build the functionality incrementally, ensuring a stable foundation at each stage.

## 2. Implementation Steps

### Step 1: Foundational UI & State Persistence (Highest Priority)

-   **Goal:** Create a functional UI for the PCPP where all user input is saved and restored reliably.
-   **Tasks:**
    1.  **Scaffolding & Config:** Ensure all files from `A42` are in place and correctly configured in `package.json`, `webpack.config.js`, etc.
    2.  **UI Development (`view.tsx`):**
        *   Build the static React components for the panel based on the updated mockup in `A35`.
        *   **Crucially, re-add the "Cycle Context" and "Ephemeral Context" text areas to fix the C87 regression.**
    3.  **Backend (`history.service.ts`):** Implement the core logic to read from and write to the `.vscode/dce_history.json` file.
    4.  **State Sync Loop:** Implement the full persistence loop. Changes in the frontend UI trigger a debounced `SaveCycleData` IPC message. The backend `HistoryService` updates the JSON file.
-   **Outcome:** A visible panel where any text typed into any field is saved and restored when the panel is closed and reopened or moved to a new window.

### Step 2: Cycle Navigator

-   **Goal:** Enable navigation through the persistent history created in Step 1.
-   **Tasks:**
    1.  **IPC:** Implement the `RequestCycleHistoryList` and `RequestCycleData` channels.
    2.  **Frontend (`view.tsx`):**
        *   On load, fetch the list of all cycle IDs to determine the valid range for navigation (`1` to `maxCycleId`).
        *   Wire the `<` and `>` buttons to change the `currentCycleId` state.
        *   Create a `useEffect` hook that listens for changes to `currentCycleId` and requests the corresponding data from the backend.
        *   The handler for `SendCycleData` will update the entire panel's state with the historical data.
-   **Outcome:** The user can click the back and forward buttons to load and view the complete state of the PCPP from previous cycles.

### Step 3: File Association and Diffing

-   **Goal:** Implement the ability to see a diff for any file mentioned in an AI response.
-   **Tasks:**
    1.  **Add Dependency:** Add the `diff` library to `package.json`.
    2.  **UI (`view.tsx`):**
        *   Implement the "Associated Files" list UI element. It will be populated by the `detectedFiles` state, which is already being parsed.
        *   Make each file in the list a clickable button.
    3.  **IPC:** Create a `RequestFileContent` channel.
    4.  **Backend (`fs.service.ts`):** Implement a handler that reads a file's content and sends it back.
    5.  **Component (`DiffViewer.tsx`):** Create a new component that takes two strings and renders a side-by-side or inline diff.
    6.  **Workflow:** Clicking a file in the list sends `RequestFileContent`. When the content arrives, the frontend shows the `DiffViewer` component (e.g., in a modal) with the original content and the content from the AI response.
-   **Outcome:** The user can paste a response and immediately get a clear, color-coded view of the changes being proposed for any file.

### Step 4: Core "Swap" Functionality

-   **Goal:** Implement the "Swap with Source" feature.
-   **Tasks:**
    1.  **IPC Channels:** Implement `RequestSwapFileContent`.
    2.  **Backend (`fs.service.ts`):** Implement the `handleSwapFileContentRequest` method.
    3.  **Frontend (`view.tsx`):** Wire up the "Swap" button to trigger the IPC message.
-   **Outcome:** The user can test AI-generated code in their workspace with a single click.

### Step 5: Advanced Features (Future Cycles)

-   **Goal:** Implement remaining features from the vision.
-   **Tasks:**
    *   Annotation and Rating (Comments, Thumbs Up/Down).
    *   Live API Integration (The new Phase 3).
    *   Advanced UI from `A50` (Resizable panes, inner editors).
</file_artifact>

<file path="src/Artifacts/A44. DCE - Phase 1 - Word Document Handling Strategy.md">
# Artifact A44: DCE - Phase 1 - Word Document Handling Strategy
# Date Created: C73
# Author: AI Model
# Updated on: C81 (Add handling for corrupted .docx files)

- **Key/Value for A0:**
- **Description:** Defines the strategy for handling Word document files (.docx) by converting them to text on-demand and caching them in memory for flattening.
- **Tags:** feature plan, docx, text extraction, virtualization, cache, phase 1

## 1. Overview & Goal

To further expand the data curation capabilities of the extension, users need to be able to include the content of Microsoft Word documents (`.docx`). Following the successful virtualization pattern used for PDFs and Excel files, the goal is to extract text from Word documents on-demand and hold it in an in-memory cache. This allows their content to be included in the flattened context without creating temporary files in the user's workspace.

## 2. Supported & Unsupported Formats

-   **Supported:** This strategy focuses exclusively on the modern, XML-based **`.docx`** format.
-   **Unsupported:** The legacy binary **`.doc`** format is significantly more complex to parse and is **not supported**. The extension will identify `.doc` files and insert a placeholder in the flattened output rather than attempting to process them.

## 3. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| DOCX-01 | **Include Word Document Text in Context** | As a user, when I check a `.docx` file, I want its text content to be extracted and included in the `flattened_repo.md`, so I can use reports and documents as context for the LLM. | - Checking `.docx` files is allowed. <br> - The token count displayed for the file reflects its extracted text content. <br> - When flattened, the text from the document is included within a `<file>` tag. <br> - No temporary files are created in the user's workspace. |
| DOCX-02 | **Handle Unsupported `.doc` format** | As a user, when I check a legacy `.doc` file, I want the system to acknowledge it but inform me in the output that its content could not be processed, so I am not confused by missing data or corrupted text. | - Checking `.doc` files is allowed. <br> - The token count for `.doc` files remains 0. <br> - When flattened, a clear placeholder comment is included for the `.doc` file, stating that the format is unsupported. |
| DOCX-03 | **Handle Corrupted `.docx` files** | As a user, if I check a `.docx` file that is corrupted or invalid, I want the extension to fail gracefully and show me an error in the UI, so I know the file has a problem. | - The extension attempts to parse the `.docx` file. <br> - If parsing fails due to file corruption (e.g., it's not a valid zip archive), the token count is set to 0. <br> - An error message (e.g., "File may be corrupted") is displayed in the file's tooltip in the UI. <br> - The flattened output includes a comment indicating the failure. |

## 4. Technical Implementation Plan

1.  **Dependency:**
    *   The `mammoth` library will be added to `package.json`. It is a popular and effective library for converting `.docx` files to HTML and raw text.

2.  **Backend (`fs.service.ts`):**
    *   **In-Memory Cache:** A new private cache will be added: `private wordTextCache = new Map<string, { text: string; tokenCount: number }>();`.
    *   **New IPC Handler (`RequestWordToText`):**
        *   This handler will receive a file path. It will first check the cache.
        *   **If `.doc`:** It will cache an "Unsupported Format" message and a token count of 0, then notify the client.
        *   **If `.docx`:** It will read the file buffer and attempt to parse it with `mammoth.extractRawText()`.
        *   **Success:** On success, it will calculate the token count, store the result in the cache, and send the stats to the client.
        *   **Failure:** The `try...catch` block will inspect the error. If the error message indicates a corrupted file (e.g., from `jszip`), it will create a specific, user-friendly error message and send that to the client with a token count of 0.

3.  **Frontend (`view.tsx`):**
    *   **On-Demand Extraction:** The logic for handling checked files and restored selections will be updated to send a `RequestWordToText` message to the backend for `.docx` and `.doc` files.

4.  **Backend (`flattener.service.ts`):**
    *   **Virtual Content Retrieval:** The flattener will retrieve the text from the `wordTextCache` in the `FSService` instead of reading the binary file. It will correctly handle the "Unsupported Format" and "Corrupted File" messages from the cache.
</file_artifact>

<file path="src/Artifacts/A45. DCE - Phase 2 - Pop-out Co-Pilot Window - Feature Plan.md">
# Artifact A45: DCE - Phase 2 - Pop-out Co-Pilot Window - Feature Plan
# Date Created: C76
# Author: AI Model
# Updated on: C78 (Reflect implementation of WebviewPanel)

- **Key/Value for A0:**
- **Description:** Outlines the technical strategy to allow the Parallel Co-Pilot panel to be "popped out" into a separate window by re-implementing it as a main editor WebviewPanel.
- **Tags:** feature plan, phase 2, pop-out, window, webview, ux

## 1. Overview & Goal

The Parallel Co-Pilot panel is designed for intensive, side-by-side comparison of code, a task that benefits greatly from maximum screen real estate. Many developers use multiple monitors and would prefer to move this panel to a secondary display. The goal of this feature is to enable the user to "pop out" the Parallel Co-Pilot panel into its own floating window.

## 2. Problem & Proposed Solution

A direct `popOut()` API for a sidebar webview does not exist in the VS Code extension API. The most robust and user-friendly way to achieve this is to leverage a native VS Code feature: users can drag any editor tab into its own floating window.

Therefore, the proposed solution is to **re-architect the Parallel Co-Pilot from a sidebar view (`WebviewViewProvider`) into a main editor view (`WebviewPanel`)**.

### 2.1. User Experience Flow

1.  The user runs the `DCE: Open Parallel Co-Pilot` command from the Command Palette or clicks the icon in the Activity Bar.
2.  Instead of opening in the sidebar, the Parallel Co-Pilot panel opens as a new tab in the main editor group.
3.  The user can then click and drag this tab out of the main VS Code window, and it will become its own floating window, which can be moved to another monitor.

## 3. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| P2-WIN-01 | **Open Co-Pilot in Main Editor**| As a developer, I want a command or button to open the Parallel Co-Pilot panel in a main editor tab, so I have more horizontal space to view and compare responses. | - A command `DCE: Open Parallel Co-Pilot` exists. <br> - An icon in the activity bar triggers this command. <br> - Executing the command opens a new editor tab containing the full Co-Pilot UI. <br> - If the panel is already open, the command brings it into focus. |
| P2-WIN-02 | **Move Co-Pilot to New Window** | As a developer with multiple monitors, after opening the Co-Pilot in an editor tab, I want to drag that tab out of my main VS Code window to turn it into a separate, floating window, so I can place it on my second monitor. | - The Co-Pilot editor tab behaves like any other editor tab. <br> - It can be dragged to create new editor groups or dragged outside the main window to create a new floating window. |

## 4. Technical Implementation Plan (C78)

This is a significant architectural change that has been implemented.

1.  **Remove Sidebar Contribution (`package.json`):**
    *   The `dce-parallel-copilot` entry in `contributes.viewsContainers.activitybar` still exists to provide an entry point icon, but the view is no longer directly registered under `contributes.views`.

2.  **Create a `WebviewPanel` (`extension.ts`):**
    *   A new command, `dce.openParallelCopilot`, is registered.
    *   A module-level variable (`private static parallelCopilotPanel: vscode.WebviewPanel | undefined;`) is used to track the panel's instance, ensuring only one can exist.
    *   When the command is executed, it checks if the panel already exists. If so, it calls `panel.reveal()`.
    *   If not, it calls `vscode.window.createWebviewPanel`. This creates the webview in an editor tab.
    *   The panel's `onDidDispose` event is used to clear the static instance variable.
    *   The logic for setting the webview's HTML, options, and message handlers is now managed within this command's callback.

3.  **State Management:**
    *   Because the panel is now created on-demand, its state (tab content, cycle number) must be managed in a backend service to be restored if the panel is closed and reopened. This is a future enhancement. For now, the state is ephemeral to the panel's lifecycle.
</file_artifact>

<file path="src/Artifacts/A46. DCE - Phase 2 - Paste and Parse Response - Feature Plan.md">
# Artifact A46: DCE - Phase 2 - Paste and Parse Response - Feature Plan
# Date Created: C76
# Author: AI Model

- **Key/Value for A0:**
- **Description:** Details the plan for allowing users to paste a full AI response into a tab, which the extension will then parse to identify file paths referenced within XML tags.
- **Tags:** feature plan, phase 2, paste, parse, workflow, automation

## 1. Overview & Goal

The manual workflow for using the Parallel Co-Pilot involves copying an entire AI response and pasting it into one of the response tabs. These responses often contain multiple file updates, each wrapped in XML-like tags (e.g., `<file path="...">...</file>`). The goal of this feature is to make the extension "intelligent" about this pasted content. It should automatically parse the text, identify the files being modified, and associate them with the response tab.

## 2. User Story

| ID | User Story | Acceptance Criteria |
|---|---|---|
| P2-PARSE-01 | **Parse Pasted Content** | As a developer, when I paste a full AI response into a tab, I want the extension to automatically detect the file paths mentioned in the `<file>` tags, so I can see a list of affected files and use them for "Swap" and "Diff" operations. | - Pasting text into a response tab's editor triggers a parsing event. <br> - The extension uses a regular expression to find all occurrences of `<file path="...">`. <br> - The extracted file paths are stored in the state for that tab. <br> - The UI for the tab is updated to display the list of detected files. |
| P2-PARSE-02 | **Set Primary Source File** | As a developer, after pasting a response with multiple files, I want the first file detected to be automatically set as the primary "source file" for the "Swap" and "Diff" actions, so I don't have to select it manually. | - After parsing, if the tab's `sourceFilePath` is not already set, it is automatically populated with the path of the first file found in the pasted content. <br> - The metadata table (comparing original vs. response) updates accordingly. |

## 3. Technical Implementation Plan

1.  **Frontend Logic (`parallel-copilot.view/view.tsx`):**
    *   **Event Handler:** An `onPaste` event handler will be added to the `<textarea>` or code editor component for each tab.
    *   **Parsing Function:** A new utility function, `parseFilePathsFromResponse(text: string): string[]`, will be created.
        *   It will use a regular expression: `/<file path="([^"]+)">/g`.
        *   It will execute this regex on the input text to extract all captured file paths.
    *   **State Update:**
        *   Inside the `onPaste` handler, it will call `event.clipboardData.getData('text')` to get the pasted content.
        *   It will pass this content to the `parseFilePathsFromResponse` function.
        *   The resulting array of paths will be stored in the state for the active tab (e.g., in a new `detectedFiles: string[]` property).
        *   If the tab's primary `sourceFilePath` is empty, it will be set to the first path in the array.

2.  **UI Update (`parallel-copilot.view/view.tsx`):**
    *   A new UI element will be added to each tab's content area.
    *   It will conditionally render if `detectedFiles` has items.
    *   It will display a list of the detected file paths, perhaps as clickable links that could set the active `sourceFilePath` for the tab.

3.  **No Backend Changes:** This feature is entirely a frontend concern, involving UI event handling, string parsing, and state management within the React component.
</file_artifact>

<file path="src/Artifacts/A47. DCE - Phase 2 - Prompt Amalgamation Feature Plan.md">
# Artifact A47: DCE - Phase 2 - Prompt Amalgamation Feature Plan
# Date Created: C82
# Author: AI Model

- **Key/Value for A0:**
- **Description:** Details the plan for a "Generate prompt.md" button that will assemble the static schemas, cycle history, and flattened code into a single, complete prompt file.
- **Tags:** feature plan, phase 2, prompt engineering, automation, workflow

## 1. Overview & Goal

The process of constructing the final `prompt.md` file is a core part of the curator's workflow. It involves manually assembling several distinct pieces of content: static schemas, the cycle history, and the dynamically generated `flattened_repo.md`. This is a repetitive and error-prone task. The goal of this feature is to automate this process with a single button click, generating a complete, perfectly formatted `prompt.md` file on demand.

## 2. User Story

| ID | User Story | Acceptance Criteria |
|---|---|---|
| P2-PROMPT-01 | **Generate Complete Prompt** | As a curator, I want to click a button to generate a complete `prompt.md` file that includes all my standard schemas, the project's cycle history, and the latest flattened code, so I can start my next development cycle with zero manual setup. | - A "Generate `prompt.md`" button is available in the Parallel Co-Pilot Panel UI. <br> - A "Cycle Title" input field is available next to the cycle navigator. <br> - Clicking the button creates or overwrites `prompt.md` in the workspace root. <br> - The generated file has the correct structure: static schemas, then the dynamic cycle overview, then the content of `flattened_repo.md`. <br> - The cycle overview is built from the `dce_history.json` file and includes the title from the new input field. |

## 3. Technical Implementation Plan

1.  **UI (`parallel-copilot.view/view.tsx`):**
    *   Add a "Generate `prompt.md`" button to the main header toolbar.
    *   Add a new state variable and a corresponding `<input type="text">` element for the "Cycle Title" next to the cycle navigator.
    *   The button's `onClick` handler will send a new IPC message to the backend.

2.  **IPC Channels:**
    *   `ClientToServerChannel.RequestCreatePromptFile`: Payload will be `{ cycleTitle: string, currentCycle: number }`.

3.  **Backend (New `prompt.service.ts`):**
    *   Create a new `PromptService` to encapsulate the logic.
    *   **Static Templates:** The service will contain private string constants holding the content for `<M1. artifact schema>`, `<M3. Interaction Schema>`, and `<M4. current project scope>`.
    *   **`generatePromptFile` Method:** This method will be the core of the service.
        1.  It will receive the `cycleTitle` and `currentCycle` from the IPC message.
        2.  It will read the `dce_history.json` file (using `HistoryService`) to build the `<M2. cycle overview>` section dynamically.
        3.  It will read the entire content of `flattened_repo.md`.
        4.  It will assemble these strings in the correct order into a single, large string.
        5.  It will write this final string to `prompt.md` in the workspace root using `vscode.workspace.fs.writeFile`.
        6.  It will show a `showInformationMessage` to confirm completion.

4.  **Integration:**
    *   The new `PromptService` will be instantiated in `services.ts`.
    *   A new handler for `RequestCreatePromptFile` will be added to the `on-message.ts` for the Parallel Co-Pilot view, which will call the `PromptService`.
</file_artifact>

<file path="src/Artifacts/A48. DCE - Phase 2 - Advanced Syntax Highlighting Plan.md">
# Artifact A48: DCE - Phase 2 - Advanced Syntax Highlighting Plan
# Date Created: C82
# Author: AI Model
# Updated on: C90 (Update plan to reflect implementation)

## 1. Overview & Goal

AI-generated responses are complex documents, containing both explanatory Markdown text and code blocks in various languages. A plain `<textarea>` element does not provide any syntax highlighting, making these responses difficult to read and analyze. The goal of this feature is to significantly enhance the readability of AI responses by replacing the textareas with a proper code editor component that can provide rich, language-aware syntax highlighting.

## 2. User Story

| ID | User Story | Acceptance Criteria |
|---|---|---|
| P2-SYNTAX-01 | **View Highlighted Responses** | As a developer, I want to see AI responses with full syntax highlighting inside the Parallel Co-Pilot tabs, so I can easily distinguish between comments, keywords, and code, just like in a real editor. | - The content area of each response tab renders with syntax highlighting. <br> - Standard Markdown elements (headers, lists, bold, italics, backticks) are formatted correctly. <br> - Code blocks (e.g., ` ```typescript ... ``` `) are highlighted with the correct grammar for the specified language. <br> - The highlighting should be theme-aware, matching the user's current VS Code theme. |

## 3. Technical Implementation Strategy (C90)

### 3.1. Chosen Library: `starry-night`

After research and consideration of alternatives like `refractor`, **`@wooorm/starry-night`** is the chosen library for syntax highlighting.

-   **Rationale (C85):**
    -   **High Fidelity:** It uses the same TextMate grammars as VS Code itself. This is the most important factor, as it ensures the highlighting in our panel will be a perfect visual match to the user's native editor experience.
    -   **Backend Architecture:** Our implementation performs highlighting on the backend (in the Node.js extension host) and sends pre-rendered HTML to the frontend webview. This means the primary drawback of `starry-night`—its large bundle size—is a non-issue for the client. The "heavy lifting" is done by the extension's server-side process, keeping the webview lightweight and performant.

### 3.2. Implementation Plan

1.  **Dependencies (`package.json`):**
    *   `@wooorm/starry-night` is the core backend dependency.
    *   `hast-util-to-html` is used to convert the abstract syntax tree to an HTML string.
    *   `react-markdown` is added as a frontend dependency to handle the rendering of non-code markdown content (lists, bold, etc.).

2.  **Backend (`fs.service.ts`):**
    *   The `handleSyntaxHighlightRequest({ code, lang, id })` method is implemented.
    *   It initializes `starry-night` with a set of common grammars.
    *   It uses `starryNight.highlight(code, scope)` where `scope` is determined from the language identifier (e.g., 'typescript' -> 'source.ts').
    *   It converts the resulting `hast` tree to an HTML string using `toHtml`.
    *   This HTML string is sent back to the client via the `SendSyntaxHighlight` IPC channel, including the `id` to match the request.

3.  **IPC Channels:**
    *   `ClientToServerChannel.RequestSyntaxHighlight`: Payload `{ code: string; lang: string, id: string }`.
    *   `ServerToClientChannel.SendSyntaxHighlight`: Payload `{ highlightedHtml: string, id: string }`.

4.  **Frontend (`parallel-copilot.view/view.tsx`):**
    *   After a response is parsed into `parsedContent`, the view iterates through `parsedContent.files`.
    *   For each file block, it sends a `RequestSyntaxHighlight` message to the backend.
    *   A state map (`highlightedCodeBlocks: Map<string, string>`) caches the HTML returned from the backend.
    *   The component that renders the file's code uses `dangerouslySetInnerHTML` to display the highlighted HTML.
    *   The `summary` and `courseOfAction` sections are rendered using the `<ReactMarkdown>` component to display formatted text.
</file_artifact>

<file path="src/Artifacts/A49. DCE - Phase 2 - File Association & Diffing Plan.md">
# Artifact A49: DCE - Phase 2 - File Association & Diffing Plan
# Date Created: C82
# Author: AI Model
# Updated on: C132 (Change workflow from 'swap' to 'accept/replace')

- **Key/Value for A0:**
- **Description:** Plans the UI and backend logic to visually link file blocks in an AI response to workspace files and sets the stage for an integrated diff tool.
- **Tags:** feature plan, phase 2, ui, ux, diff, file association

## 1. Overview & Goal

To make the Parallel Co-Pilot Panel's workflow trustworthy and intuitive, users need a clear visual confirmation of which local file an AI-generated code block is intended to modify. This feature introduces a "file association" mechanism that parses AI responses, verifies the existence of the mentioned files, and displays this status to the user.

The core workflow is now defined as **"accept/replace"**: a one-way copy of content from the AI response into the user's workspace files.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| P2-ASSOC-01 | **See Affected Files** | As a developer, when I parse an AI response, I want the extension to automatically show me a list of all the file paths it intends to modify, so I can understand the scope of the proposed changes. | - After parsing, a collapsible "Associated Files" section appears in the tab's UI. <br> - This section displays a list of all file paths found in the response. |
| P2-ASSOC-02 | **Verify File Existence** | As a developer, for each file listed, I want to see a visual indicator of whether that file already exists in my workspace, so I can spot potential errors or new files proposed by the AI. | - Next to each listed file path, an icon is displayed. <br> - A green checkmark (`✓`) indicates the file exists at that path. <br> - A red cross (`✗`) indicates the file does not exist. |
| P2-ASSOC-03 | **Preview AI Code** | As a developer, I want to click on a file in the "Associated Files" list to immediately see a syntax-highlighted view of the AI's proposed code, so I can review it. | - Clicking a file with a `✓` in the list opens a single-pane view in the right-hand panel. <br> - This view displays only the AI's proposed code, with full syntax highlighting. |
| P2-ASSOC-04 | **Preview Changes with Diff** | As a developer, I want a "View Diff" button to see a side-by-side comparison of the original file and the AI's proposed changes, so I can review the exact changes before accepting them. | - A "View Diff" button is available for the selected file. <br> - Clicking it replaces the single-pane view with a two-pane diff component. <br> - The diff view clearly shows added, removed, and common lines. |
| P2-ASSOC-05 | **Accept Changes** | As a developer, I want to be able to accept changes from the AI response into my workspace, either for a single file or for a batch of selected files. | - An "Accept this file" button replaces the content of the workspace file with the AI's version. <br> - A separate "Accept Selected Files" button performs a bulk replacement for all files checked in the "Associated Files" list. <br> - This is a one-way copy from the AI response to the workspace. |

## 3. Technical Implementation Plan

1.  **Frontend - Parsing (`response-parser.ts`):**
    *   **Status:** **Complete.**

2.  **Backend - Verification & Highlighting (`fs.service.ts`):**
    *   **Status:** **Complete.** The `handleFileExistenceRequest` and `handleSyntaxHighlightRequest` handlers are working.

3.  **Frontend - UI & State (`view.tsx`):**
    *   **Status:** **In Progress.**
    *   **File List & Diff View:** Implement the "Associated Files" list. Clicking a file fetches its content for diffing and displays the `DiffViewer` component.
    *   **Selection State:** Manage a `Set<string>` of `selectedFilesForReplacement` to track which files are checked.
    *   **Accept/Replace Logic:**
        *   The "Accept this file" button will trigger a new `RequestWriteFile` IPC message.
        *   The "Accept Selected Files" button will trigger a new `RequestBatchFileWrite` IPC message with an array of file paths and their new content.

4.  **Backend - File Writing (`file-operation.service.ts`):**
    *   **Status:** **To be implemented.**
    *   Implement `handleWriteFileRequest` and `handleBatchFileWrite` to receive new content and overwrite the corresponding files in the workspace using `vscode.workspace.fs.writeFile`.
</file_artifact>

<file path="src/Artifacts/A50. DCE - Phase 2 - UI Component Plan (Resizable Panes & Inner Editors).md">
# Artifact A50: DCE - Phase 2 - UI Component Plan (Resizable Panes & Inner Editors)
# Date Created: C87
# Author: AI Model
# Updated on: C112 (Prioritize resizable panes implementation)

- **Key/Value for A0:**
- **Description:** Documents the plan for advanced UI components like resizable panes and nested, scrollable editors within the Parallel Co-Pilot panel.
- **Tags:** feature plan, phase 2, ui, ux, resizable, scrollable, editor

## 1. Overview & Goal

As the Parallel Co-Pilot Panel (PCPP) becomes more feature-rich, its UI needs to be flexible and efficient. This document outlines the plan for two advanced UI components: a **resizable pane** for the summary/code view and a system of **nested, scrollable "inner editors"** for individual file blocks within a response. The goal is to create a highly readable and customizable interface that prevents "endless scrolling" and allows users to focus on the information that matters most to them.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| P2-UI-01 | **Resizable Panes** | As a developer, I want to be able to drag the vertical divider between the summary/file list pane and the code viewer pane, so I can give more space to the view that is most important for my current task. | - A draggable handle exists on the vertical divider between the two main panes in the parsed view. <br> - Clicking and dragging the handle adjusts the relative width of the two panes. <br> - The layout is responsive and does not break during resizing. <br> - The left pane should be collapsible. |
| P2-UI-02 | **Contained File Editors** | As a developer, when viewing a large AI response with multiple files, I want each file's code to be contained within its own fixed-height, scrollable text area, so I can quickly scroll past entire files without having to scroll through all of their content. | - The extension parses the AI response and identifies individual file blocks (e.g., content within `<file>` tags). <br> - Each file block is rendered inside its own container with a fixed `max-height` and `overflow-y: auto`. <br> - This allows the user to scroll through the list of files quickly, only scrolling within a specific file's content when needed. |
| P2-UI-03 | **File-Level Action Buttons** | As a developer, I want action buttons (like "Accept", "Diff", "Comment") to be associated with each individual file block within a response, so I can act on a single file at a time. | - In the "inner editor" view, each file container has its own set of action buttons. <br> - Clicking "Accept" on one file block only affects that specific file, not the entire response. |

## 3. Technical Implementation Plan

### 3.1. Resizable Panes (Priority for C112)

-   **Strategy:** Implement a custom, lightweight resizable pane component directly within `view.tsx`.
-   **Component Logic:**
    *   The main `.parsed-view-grid` will be the flex container.
    *   A new `div` element with a `.resizer` class will be added between the left and right panes to act as the draggable handle.
    *   **State:** A new state variable, `const [leftPaneWidth, setLeftPaneWidth] = useState(33);`, will manage the width of the left pane as a percentage.
    *   **Event Handling:**
        *   The resizer `div` will have an `onMouseDown` handler.
        *   This handler will attach `onMouseMove` and `onMouseUp` listeners to the `window`.
        *   The `onMouseMove` handler will calculate the new percentage width based on `event.clientX` and update the `leftPaneWidth` state, respecting min/max width constraints.
        *   The `onMouseUp` handler will remove the `mousemove` and `mouseup` listeners from the window.
-   **Integration:** The `style` attribute of the left pane will be bound to this state (e.g., `flex-basis: `${leftPaneWidth}%`).

### 3.2. Inner Editors / Contained File Blocks (Future Cycle)

-   **Strategy:** This requires a significant change to how the response content is rendered. Instead of treating the response as a single block of text to be rendered as Markdown, it must be parsed into a structured array of objects.
-   **Parsing Logic (`view.tsx`):**
    -   A new parsing function will take the raw response string and split it into an array of segments, e.g., `[{ type: 'markdown', content: '...' }, { type: 'file', path: '...', content: '...' }, ...]`.
-   **Rendering Logic (`view.tsx`):**
    -   The main render function will map over this array of segments.
    -   If `segment.type === 'markdown'`, it renders the content as before.
    -   If `segment.type === 'file'`, it renders a new component, e.g., `FileBlock.tsx`.
-   **`FileBlock.tsx` Component:**
    -   This component will be responsible for rendering a single file from the AI response.
    -   It will have a header displaying the file path and the file-specific action buttons (Accept, Diff, etc.).
    -   The main content area will be a `div` with CSS properties `max-height: 300px;` (or similar) and `overflow-y: auto;`.
    -   The code content within this `div` will be syntax-highlighted as before.
</file_artifact>

<file path="src/Artifacts/A51. DCE - A-B-C Testing Strategy for UI Bugs.md">
# Artifact A51: DCE - A-B-C Testing Strategy for UI Bugs
# Date Created: C102
# Author: AI Model & Curator
# Updated on: C103 (Refine to "Original-A-B-C" parallel testing model)

- **Key/Value for A0:**
- **Description:** Outlines a development pattern for creating parallel, isolated test components to diagnose and resolve persistent UI bugs, such as event handling or rendering issues.
- **Tags:** process, debugging, troubleshooting, ui, ux, react

## 1. Overview & Goal

When a user interface (UI) bug, particularly related to event handling (`onClick`, `onDrop`, etc.) or component rendering, proves resistant to conventional debugging, it often indicates a complex or non-obvious root cause. Continuously attempting small, incremental fixes on the main, complex component can be inefficient and can lead to regressions.

The goal of the **"Original-A-B-C" Testing Strategy** is to break this cycle by creating a test harness that runs the original, complex component in parallel with multiple, simplified, independent test components. Each test component attempts to solve the same basic problem using a slightly different technical approach, allowing for rapid diagnosis.

## 2. The Strategy

### 2.1. Core Principles
1.  **Preserve the Original:** Never gut or remove existing, working functionality to build a test case. The original component should remain available as the "control" in the experiment.
2.  **Isolate Variables:** Each test case should be as simple as possible, designed to test a single variable (e.g., raw event handling, local state updates, prop drilling).
3.  **Run in Parallel:** The original component and all test components should be accessible from the same UI, typically via a simple tab switcher, allowing for immediate comparison.

### 2.2. Steps
1.  **Identify the Core Problem:** Isolate the most fundamental action that is failing (e.g., "A click on a list item is not being registered").
2.  **Create Test Harness:** Refactor the main view to act as a "test harness."
    *   Introduce a top-level state to control which view is active (e.g., `activeView: 'Original' | 'TestA' | 'TestB'`).
    *   Create a simple tab bar UI to switch this state.
    *   Encapsulate the existing, complex component so it can be rendered when `activeView === 'Original'`.
3.  **Lift Necessary State:** Identify the minimum state required for the test components to function (e.g., `parsedContent`). Lift this state up to the test harness level. The "Original" component can then pass data up to the harness via a callback prop.
4.  **Implement Isolated Test Components:** Create new, simple components for each test case, which receive the shared state as props.
    *   **Test A (Barebones):** The simplest possible implementation. Use raw HTML elements with inline event handlers that only `logger.log()`.
    *   **Test B (Local State):** Introduce `useState` to test the component's ability to manage its own state and re-render on an event.
    *   **Test C (Prop-Driven):** Use a child component that calls a function passed down via props, testing the prop-drilling pattern.
5.  **Analyze Results:** Interact with each tab to see which implementation succeeds, thereby isolating the architectural pattern that is failing.

## 3. Cleanup Process

Once a working pattern is identified in a test component:
1.  **Codify Findings:** Document the successful pattern and the root cause of the failure in a relevant artifact (e.g., `A11. Regression Case Studies`).
2.  **Integrate Solution:** Refactor the "Original" component to use the successful pattern.
3.  **Remove Test Artifacts:**
    *   Remove the test harness tabs and view-switching logic from the main view component.
    *   Delete the temporary `TestPane*.tsx` component files.
    *   Remove any extra styling related to the test harness from the SCSS file.

## 4. Sample Test Data for Parser

To ensure consistent testing of the PCPP parser, use the following sample raw response. Paste this into a response tab in the "Original" view and click "Parse All".

```
I've analyzed the request and the provided context. The main goal is to add a new test harness to the Parallel Co-Pilot panel without removing the existing functionality. This involves refactoring `view.tsx` to support multiple, switchable views.

### Course of Action

1.  **Update Documentation:** I will first update `A51` to reflect the new "Original-A-B-C" parallel testing strategy.
2.  **Refactor `view.tsx`:** I will refactor the main component into a test harness that can switch between the original view and the new test panes.
3.  **Re-supply Test Panes:** I will provide the code for the three isolated test panes again.

### Files Updated This Cycle:
*   `A51. DCE - A-B-C Testing Strategy for UI Bugs.md` (Updated)
*   `src/client/views/parallel-copilot.view/view.tsx` (Updated)
*   `src/client/views/parallel-copilot.view/view.scss` (Updated)

<file path="src/client/views/parallel-copilot.view/view.tsx">
// This is a sample file content block.
// It will be parsed and displayed.
import * as React from 'react';

const TestComponent = () => {
    return <div>Hello, World!</div>;
};

export default TestComponent;
</file>
<file path="src/client/views/parallel-copilot.view/view.scss">
/* This is a sample SCSS file content block. */
.test-harness-tabs {
    display: flex;
    border-bottom: 1px solid var(--vscode-panel-border);
}
```
</file_artifact>

<file path="src/Artifacts/A52. DCE - Interaction Schema Refinement.md">
# Artifact A52: DCE - Interaction Schema Refinement
# Date Created: C110
# Author: AI Model & Curator
# Updated on: C154 (Switch to XML tags for summary and course of action)

- **Key/Value for A0:**
- **Description:** A set of refined rules and an explanation of the parsing logic for the AI's output format to improve the reliability and consistency of automated parsing within the Parallel Co-Pilot Panel.
- **Tags:** documentation, process, parsing, interaction schema, metainterpretability

## 1. Overview & Goal

The Parallel Co-Pilot Panel (PCPP) relies on parsing your output to provide features like file association, diffing, and syntax highlighting. To ensure this process is reliable, your responses must adhere to a strict and consistent format.

The goal of this document is to serve as a definitive guide for you, the AI, on how to structure your responses. It explains the "documentation first" principle we follow and details the exact logic the PCPP parser uses. By understanding how you are being interpreted, you can generate perfectly parsable output every time.

## 2. The "Documentation First" Principle

A core principle of this project is to **plan before coding**.
-   **Cycle 0 (Project Initialization):** Your first task for a new project is **always** to generate planning and documentation artifacts (e.g., A1 Project Vision, A2 Requirements), not code files. You should use the provided templates as a guide.
-   **Subsequent Cycles:** When a new feature is requested, your first step should be to update existing documentation or create new artifacts that describe the plan for that feature. You should only generate code *after* the plan has been documented.

## 3. How the PCPP Parser Works

The parser is designed to be simple and robust. It looks for specific tags to break your response into structured data.

### Step 1: Extract Summary / Plan
-   **Rule:** Your high-level summary, thoughts, or plan must be enclosed in `<summary>...</summary>` tags.
-   **Parser Logic:** The parser captures all text between the opening and closing `summary` tags.

### Step 2: Extract Course of Action
-   **Rule:** Your point-by-point plan must be enclosed in `<course_of_action>...</course_of_action>` tags.
-   **Parser Logic:** The parser captures all text between the opening and closing `course_of_action` tags.

### Step 3: Extract File Blocks
The parser's most important job is to find and extract all file blocks.
-   **Rule:** Every file you generate **must** be enclosed in `<file path="..."></file>` tags.
-   **Example:**
    ```xml
    <file path="src/main.ts">
    // ... content of main.ts
    </file>
    ```
-   **Parser Logic:** The parser looks for the literal string `<file path="` followed by a quoted path, then captures everything until it finds the literal closing string `</file>`. **Any other format will be ignored.**

## 4. Canonical Response Structure

To guarantee successful parsing, every response should follow this structure:

```
<summary>
[High-level summary and analysis of the request.]
</summary>

<course_of_action>
1.  [A detailed, point-by-point plan of the changes you are about to make.]
2.  [Another point in the plan.]
</course_of_action>

<file path="path/to/first/file.ts">
// Full content of the first file...
</file>

<file path="path/to/second/file.md">
# Full content of the second file...
</file>
```
</file_artifact>

<file path="src/Artifacts/A52.1 DCE - Parser Logic and AI Guidance.md">
# Artifact A52.1: DCE - Parser Logic and AI Guidance
# Date Created: C155
# Author: AI Model & Curator
# Updated on: C14 (Make file tag parsing more flexible)

- **Key/Value for A0:**
- **Description:** Provides the literal source code for the response parser and explicit instructions to the AI on how to format its output to ensure successful parsing.
- **Tags:** documentation, process, parsing, metainterpretability, source of truth

## 1. Overview & Goal (Metainterpretability)

This document is included in every prompt to provide you with direct insight into how your responses are parsed. By understanding the exact logic used to interpret your output, you can structure your responses to be perfectly machine-readable, ensuring a smooth and reliable workflow.

The goal is to eliminate parsing failures caused by unexpected formatting. Adhering to this guide is a critical part of the interaction schema.

## 2. The Parser's Source Code

The following TypeScript code is the complete and exact logic used by the Parallel Co-Pilot Panel to parse your responses. It looks for specific XML tags to separate the summary, course of action, and file blocks.

```typescript
// src/client/utils/response-parser.ts
import { ParsedResponse, ParsedFile } from '@/common/types/pcpp.types';

const SUMMARY_REGEX = /<summary>([\s\S]*?)<\/summary>/;
const COURSE_OF_ACTION_REGEX = /<course_of_action>([\s\S]*?)<\/course_of_action>/;
const CURATOR_ACTIVITY_REGEX = /<curator_activity>([\s\S]*?)<\/curator_activity>/;
// C14 Update: More flexible closing tag matching
const FILE_TAG_REGEX = /<file path="([^"]+)">([\s\S]*?)(?:<\/file_path>|<\/file>|<\/filepath>|<\/file_artifact>)/g;
const CODE_FENCE_START_REGEX = /^\s*```[a-zA-Z]*\n/;

export function parseResponse(rawText: string): ParsedResponse {
    const fileMap = new Map<string, ParsedFile>();
    let totalTokens = 0;

    let processedText = rawText.replace(/\\</g, '<').replace(/\\>/g, '>').replace(/\\_/g, '_');

    const tagMatches = [...processedText.matchAll(FILE_TAG_REGEX)];

    if (tagMatches.length === 0 && processedText.includes('<file path')) {
        const summary = `**PARSING FAILED:** Could not find valid \`<file path="...">...</file_artifact>\` (or similar) tags. The response may be malformed or incomplete. Displaying raw response below.\n\n---\n\n${processedText}`;
        return { summary, courseOfAction: '', filesUpdated: [], files: [], totalTokens: Math.ceil(processedText.length / 4) };
    }

    for (const match of tagMatches) {
        const path = (match?. ?? '').trim();
        let content = (match?. ?? '');

        if (path) {
            content = content.replace(CODE_FENCE_START_REGEX, '');
            // C14 Update: Add new tags to the removal list
            const patternsToRemove = [`</file_artifact>`, `</file_path>`, `</filepath>`, `</file>`, `</${path}>`, '```', '***'];
            let changed = true;
            while(changed) {
                const originalContent = content;
                for (const pattern of patternsToRemove) {
                    if (content.trim().endsWith(pattern)) {
                        content = content.trim().slice(0, -pattern.length);
                    }
                }
                if (content === originalContent) { changed = false; }
            }
            content = content.trim();
            const tokenCount = Math.ceil(content.length / 4);
            fileMap.set(path, { path, content, tokenCount });
        }
    }

    const finalFiles = Array.from(fileMap.values());
    totalTokens = finalFiles.reduce((sum, file) => sum + file.tokenCount, 0);

    const summaryMatch = processedText.match(SUMMARY_REGEX);
    const courseOfActionMatch = processedText.match(COURSE_OF_ACTION_REGEX);
    const curatorActivityMatch = processedText.match(CURATOR_ACTIVITY_REGEX);

    const summary = (summaryMatch?.[1] ?? 'Could not parse summary.').trim();
    const courseOfAction = (courseOfActionMatch?.[1] ?? 'Could not parse course of action.').trim();
    const curatorActivity = (curatorActivityMatch?.[1] ?? '').trim();
    
    const filesUpdatedList = finalFiles.map(f => f.path);

    if (finalFiles.length === 0 && !summaryMatch && !courseOfActionMatch && !curatorActivityMatch) {
        return { summary: processedText, courseOfAction: '', filesUpdated: [], files: [], totalTokens: Math.ceil(processedText.length / 4) };
    }

    return {
        summary,
        courseOfAction,
        curatorActivity,
        filesUpdated: [...new Set(filesUpdatedList)],
        files: finalFiles,
        totalTokens,
    };
}
```

## 3. Critical Instructions for Formatting Your Response

To guarantee successful parsing, every response **must** follow this structure:

1.  **Summary:** Your high-level analysis and plan must be enclosed in `<summary>...</summary>` tags.
2.  **Course of Action:** Your point-by-point plan must be enclosed in `<course_of_action>...</course_of_action>` tags.
3.  **File Blocks:** Every file you generate must be enclosed in `<file path="..."></file_artifact>` tags (or a similar valid closing tag). The parser uses a global regex (`/g`) to find all occurrences of this pattern. The closing tag can be `</file_artifact>`, `</file_path>`, `</filepath>`, or `</file>`.

### Canonical Example:

```
<summary>
I have analyzed the request. My course of action is to update the main component and its corresponding stylesheet.
</summary>

<course_of_action>
1.  **Update `view.tsx`:** Add a new state variable and a button.
2.  **Update `view.scss`:** Add styling for the new button.
</course_of_action>

<file path="src/client/views/my-view/view.tsx">
// (Canonical Example) Full content of the view.tsx file...
</file_artifact>

<file path="src/client/views/my-view/view.scss">
/* (Canonical Example) Full content of the view.scss file... */
</file_artifact>
```
</file_artifact>

<file path="src/Artifacts/A52.2 DCE - Interaction Schema Source.md">
# Artifact A52.2: DCE - Interaction Schema Source
# Date Created: C156
# Author: AI Model & Curator
# Updated on: C6 (Clarify closing tag and add curator activity section)

- **Key/Value for A0:**
- **Description:** The canonical source text for the M3. Interaction Schema, which is injected into all generated prompts.
- **Tags:** documentation, process, interaction schema, source of truth

## Interaction Schema Text

1.  Artifacts are complete, individual texts enclosed in `<xmltags>`. To ensure consistent parsing by the DCE extension, all file artifacts **must** be enclosed in `<file path="path/to/file.ts">...</file_artifact>` tags. The path must be relative to the workspace root. **The closing tag must be exactly `</file_artifact>`.** Do not use the file path in the closing tag (e.g., `</file path="...">` is incorrect). Do not write the closing tag as `</file>` or `</file_path>`. Only `</file_artifact>` will parse successfully.

2.  Our Document Artifacts serve as our `Source of Truth` throughout multiple cycles. As such, over time, as issues occur, or code repeatedly regresses in the same way, seek to align our `Source of Truth` such that the Root Cause of such occurances is codified so that it can be avoided on subsequent cycles visits to those Code artifacts.

3.  Please output entire Document or Code artifacts. Do not worry about Token length. If your length continues for too long, and you reach the 600 second timeout, I will simply incorporate the work you did complete, and we can simply continue from where you left off. Better to have half of a solution to get started with, than not to have it. **Preference is for larger, more complete updates over smaller, incremental ones to align with the human curator's parallel processing workflow.** The human curator often sends the same prompt to multiple AI instances simultaneously and selects the most comprehensive response as the primary base for the next cycle, using other responses as supplementary information. Providing more complete updates increases the likelihood of a response being selected as the primary base.

4.  Do not output artifacts that do not require updates in this cycle. (Eg. Do not do this: // Updated on: Cycle 1040 (No functional changes, only cycle header))

5.  **Critical: `flattened_repo_v2.txt` contains all project files. Output updated *individual* files that are part of it (like `<src/state/coreStore.ts>...`). However, do **NOT** output the surrounding Artifact container tags (`<flattened_repo_v2.txt>...</flattened_repo_v2.txt>`) or any auto-generated metadata sections within it (like the Total Files summary, Top 10 list, or the `<files list>` section) which are created by the `flatten.js` script.**
5.1. `flattened_repo_v2.txt` is a copy of the codebase, generated by a script; assume its an accurate representation of the existing codebase, but not necessarily a 'source of truth' like we treat our documents as, our codebase is a living artifact, documents, while we can update them, should be considered less transient.
5.2. **`.local` File Convention:** To manage token count, some large data files (e.g., `researchNodes.ts`) may be represented by a truncated `.local.ts` version in the context. This version contains the essential structure and a few examples. If the full content of a file is required for a task (e.g., a comprehensive data refactor or fixing a bug related to a specific entry), explicitly state this need in your summary of actions and request that the curator swap the `.local.ts` file with the full `.ts` version in the `files_list.txt` for the subsequent cycle.

6.  remember to output complete artifacts without placeholders, im taking your output, putting it in winmerge, and confirming we arent losing data in the update. when you provide placeholders, my cursory review turns into a meticulous file parsing, taking me from what is 5 seconds per artifact to upwards of 5 minutes, only to realize that the output is actually un-parseable, due to the nature of relativity, as the theory of relativity also applies to code. if you give me a code snippet, and do not give me the code surrounding that snippet, i do not know where that code should go. by providing the complete file, on the other hand, i can put it in a diff, see easily what was altered, and if anything was accidentally omitted or lost, i can be sure that it's retained.

7.  **Update documentation before writing code.** document artifacts are like our project readme files, our source of truth. they are our blueprints. they guide the code we write. when we realize we need to alter our approach or invent new game mechanics, we update the source of truth first, cause english is easy and flexible, then we codify that.

8.  this query is part of a larger software engineering project

9.  After you complete delivery on a code artifact, review it to make sure you did not miss any intermediary files. for instance, if we have a DevelopmentSystem.ts, using the componentData.ts, which is displaying on the ComponentProductionTab.tsx. But then theres also still a DevPanel.tsx file that is in-between that *could*, but shouldnt, get overlooked.

10. If you are deciding where to put a particular piece of code or function, and due to its nature, there are one or more candidate files that it could be placed in, choose the smaller file (in tokens).

11. Begin your response with a course of action and end with a review of your work, surface any self corrections in the summary of changes for the subsequent cycle.

12. do not underestimate how much you can accomplish in a given cycle; you'd only accomplish handicapping yourself. (Eg. you've authored this whole thing with just my guidance. good job, keep it up.)

13. Not as relevant for this project: **Log State Button:** The 'Log State' button in the `DevInfoOverlay` is a dynamic debugging tool. Modify the `triggerDebugLogs` action in `uiStore.ts` to output specific state information relevant to the current bug being investigated. **See A85 (Logging Guide) for usage details.**

14. Not as relevant for this project: **Regression Case Studies:** Use Artifact A106 to document persistent or complex bugs and their resolutions. Add entries *after* a fix is confirmed to codify the RCA and solution, preventing future regressions.

15. Include in your cycle summary, a short list of files you've updated. This makes it easy for my reviews.

16. if you seem to have spare time in a cycle, see if you can spot any particular file with excessive levels of comments or logging that seems extensive and for troubleshooting an error that has since been resolved, see to it to clean those files but preserve their functionalities. im just looking to shave off excess tokens wherever possible in the master_content.txt file.

17. if you see `(No change from C850)` such language, it's data loss. there was supposed to be actual language behind that placeholder, but in one iteration (C850, in this case) you had provided a placeholder, and i 'missed it' and did not capture the initial information. you either need to deliver the placeholder in such a way as i can easily press the left arrow instead of the rigth arrow in winmerge to not accept that part, but to also not have winmerge confuse it with the rest, otherwise i must manually parse the information. when the process is a single keystroke, i can manage it quickly enough. when we remove that ability because you provided me data in a format that has placeholders AND the placeholders do not parse within winmerge such that it removes the benefit winmerge is adding, then we have our problem. when you see this, try to correct it using whatever current relevant context you have.

18. basically, you should not worry about brevity, because when you go too long, your response gets interrupted by the system anyway. its better that the products you do deliver are all complete except for the last one, rather than you delivering all incomplete products, including the last one. does that make sense?

19. remember, do not stop outputting for the reason of preventing a potential artifact interruption mid-output. you actually end up stopping yourself from producting two or three additional files before you actually get interrupted. what i mean is, in the outputs where you do not do this, you produce for 500 seconds, producing 7-9 files, and only the last one is interrupted and unusable. compared to when you stop yourself prematurely, for the reason stated, and you produce for 180 seconds and provide maybe 3-4 files. even with the -1, producing as much as you can still outperforms the alternative.

20. This is a misaligned statement: `// (For full history, see master_content.txt)` because your changes get rolled into master_content.txt. therefore, if you remove the history, then when your updates are rolled in, they will remove the full history. understand? after a while, the history is not relevant and can be rolled out, for a while, it ought to stay. you can see what we're working on + the current cycle and make this determination.

21. Each time we create a new documentation artifact, lets also create the key/value pairs needed for me to add it into our Master Artifact List. they can simply be added into the new artifact itself and ill make the new entry in A0. this will solve for me manually generating a description and tag for each new documentation artifact. also, dont place `/` in the title/name of a documentation artifact. VSCode treats it as a folder separator.
21.1. when creating a new documentation artifact, also just update the master artifacts list itself.

22. **New: Curator Activity Section:** If you need the human curator to perform an action that you cannot (e.g., delete a file, run a specific command), include these instructions in a dedicated `<curator_activity>...</curator_activity>` section in your response.
</file_artifact>

<file path="src/Artifacts/A53. DCE - Phase 2 - Token Count and Similarity Analysis.md">
# Artifact A53: DCE - Phase 2 - Token Count and Similarity Analysis
# Date Created: C112
# Author: AI Model & Curator
# Updated on: C144 (Mark feature as implemented)

- **Key/Value for A0:**
- **Description:** Details the plan to implement token counting for raw and parsed responses, and to calculate a similarity score between AI-generated files and their workspace originals.
- **Tags:** feature plan, phase 2, token count, similarity, metrics, ui, ux

## 1. Overview & Goal

To enhance the curator's decision-making process, the Parallel Co-Pilot Panel (PCPP) must provide quantitative metrics about the AI's responses. The goal of this feature is to display token counts for various pieces of content and a similarity score to gauge the extent of changes proposed by the AI. This allows the user to quickly assess response verbosity, parser effectiveness, and the magnitude of code modifications.

**Status (C144):** This feature is now fully implemented.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| P2-MET-01 | **Raw Response Token Count** | As a user, I want to see the total token count of the raw AI response I've pasted, so I can understand the overall size of the output. | - A token count is displayed for the raw content in each response tab. <br> - This count updates in real-time as I type or paste content. |
| P2-MET-02 | **Parsed vs. Original Token Count** | As a user, when viewing a parsed file, I want to see a comparison of the token count between the original workspace file and the AI's new version, so I can quickly see if the code is growing or shrinking. | - In the header of the code viewer pane, the token counts for both the original and new versions of the selected file are displayed (e.g., "Original: 4.1K | New: 4.2K"). |
| P2-MET-03 | **File Similarity Score** | As a user, along with the token counts, I want to see a percentage-based similarity score, so I can gauge how substantially the AI has altered the file. | - A similarity score (e.g., "Sim: 98%") is displayed in the code viewer header. <br> - A score of 100% indicates identical files. <br> - A low score indicates a major rewrite. |

## 3. Technical Implementation Plan

1.  **IPC Channel:**
    *   `ClientToServerChannel.RequestFileComparison` was created.
    *   Payload: `{ filePath: string; modifiedContent: string; }`.
    *   Response channel: `ServerToClientChannel.SendFileComparison`.
    *   Payload: `{ originalTokens: number; modifiedTokens: number; similarity: number; }`.

2.  **Backend (`file-operation.service.ts`):**
    *   `handleFileComparisonRequest` was implemented.
    *   It reads the content of the original `filePath` from the workspace.
    *   It calculates the token count for the original content and the `modifiedContent` received in the payload using `content.length / 4`.
    *   It computes a similarity score using the Sørensen-Dice coefficient algorithm located in `src/common/utils/similarity.ts`.
    *   It sends the results back to the client via `SendFileComparison`.

3.  **Frontend (`parallel-copilot.view/view.tsx`):**
    *   When a file is selected for viewing (`setSelectedFilePath`), a `RequestFileComparison` message is sent.
    *   A state variable, `comparisonMetrics`, holds the returned results.
    *   The message handler for `SendFileComparison` updates this state.
    *   The UI in the code viewer header renders the live data from the `comparisonMetrics` state.
</file_artifact>

<file path="src/Artifacts/A55. DCE - FSService Refactoring Plan.md">
# Artifact A55: DCE - FSService Refactoring Plan
# Date Created: C113
# Author: AI Model & Curator
# Updated on: C114 (Mark refactor as complete)

- **Key/Value for A0:**
- **Description:** Outlines a strategic plan to refactor the monolithic `FSService` into smaller, more focused services to improve modularity, maintainability, and reduce token count.
- **Tags:** refactor, architecture, technical debt, services

## 1. Problem Statement

The `FSService` has become a "god object," handling a wide range of responsibilities beyond basic file system interactions and now violates the Single Responsibility Principle. Its large size (over 800 lines) makes it difficult to maintain, debug, and reason about. The service currently manages at least four distinct areas of concern:
1.  **Workspace State:** Building, caching, and watching the file tree.
2.  **File Operations:** Handling requests to create, move, delete, and modify files.
3.  **Content Virtualization:** Processing special file types like PDF, Word, and Excel into text.
4.  **Syntax Highlighting:** Managing the `starry-night` library and processing highlighting requests.

## 2. Refactoring Plan (Completed in C114)

The `FSService` has been successfully broken down into four new, more focused services. This has improved code organization, reduced the token count of individual files, and made the system more modular and maintainable.

### 2.1. New Service Structure

#### 1. `FileTreeService`
-   **Responsibility:** All "read" operations related to the workspace structure. This service is the source of truth for what the workspace looks like.
-   **Methods moved here:**
    -   `handleWorkspaceFilesRequest`
    -   `buildTreeFromTraversal`, `_traverseDirectory`, `_aggregateStats`
    -   `getFileStats`
    -   `getGitStatusMap`, `getProblemCountsMap`
    -   `initializeWatcher`, `triggerFullRefresh`, `triggerDiagnosticsUpdate`
    -   `fileTreeCache` property

#### 2. `FileOperationService`
-   **Responsibility:** All "write" or direct modification operations on the file system.
-   **Methods moved here:**
    -   `handleNewFileRequest`
    -   `handleNewFolderRequest`
    -   `handleFileRenameRequest`
    -   `handleMoveFileRequest`
    -   `handleFileDeleteRequest`, `handleBatchFileDeleteRequest`
    -   `handleCopyFileRequest`, `handleCopyFileFromUri`, `handleAddFileFromBuffer`
    -   `handleOpenFileRequest`
    -   `handleRevealInExplorerRequest`
    -   `handleCopyPathRequest`

#### 3. `ContentExtractionService`
-   **Responsibility:** Handling the on-demand parsing and virtualization of special, non-text file formats.
-   **Methods moved here:**
    -   `handlePdfToTextRequest`, `getVirtualPdfContent`, `pdfTextCache`
    -   `handleExcelToTextRequest`, `getVirtualExcelContent`, `excelMarkdownCache`
    -   `handleWordToTextRequest`, `getVirtualWordContent`, `wordTextCache`
    -   `_sheetToMarkdown` (private helper)

#### 4. `HighlightingService`
-   **Responsibility:** All logic related to syntax highlighting.
-   **Methods moved here:**
    -   `initializeStarryNight`
    -   `handleSyntaxHighlightRequest`
    -   `starryNight` property

### 2.2. Integration

-   The main `services.ts` container was updated to instantiate all four new services.
-   The `on-message.ts` handlers were updated to call the correct methods on the new, more specific services.
-   The original `fs.service.ts` file has been deleted.

## 3. Benefits Achieved

-   **Reduced Complexity:** Each service is now significantly smaller and easier to understand.
-   **Improved Maintainability:** Bugs or feature requests will be easier to implement in the correct, isolated service.
-   **Clear Separation of Concerns:** The architecture now follows best practices.
-   **Lower Token Count:** Splitting the large file into four smaller ones makes each file more manageable.

<Original fs.service.ts>
Removed after completing refactor.
</Original fs.service.ts>
</file_artifact>

<file path="src/Artifacts/A56. DCE - Phase 2 - Advanced Diff Viewer Plan.md">
# Artifact A56: DCE - Phase 2 - Advanced Diff Viewer Plan
# Date Created: C120
# Author: AI Model & Curator
# Updated on: C132 (Add keyboard navigation and clarify scrollbar behavior)

- **Key/Value for A0:**
- **Description:** Details the plan to enhance the integrated diff viewer with a side-by-side layout, scroll-locking, keyboard navigation, and a location pane.
- **Tags:** feature plan, phase 2, ui, ux, diff, navigation, side-by-side, scroll-lock, keyboard

## 1. Overview & Goal

The current diff view is functional but lacks key usability features found in mature diff tools like WinMerge. The goal of this plan is to enhance the diff viewer to provide a much clearer and more efficient user experience. This involves several key enhancements:
1.  **Side-by-Side Main Layout:** Displaying the original and modified files in two parallel, vertical panes.
2.  **Top-and-Bottom Detail Layout:** Displaying the character-level diff in two panes stacked vertically at the bottom.
3.  **Scroll-Locking:** Synchronizing the scroll position of the two main panes and the two detail panes, with all four panes having visible scrollbars.
4.  **Keyboard Navigation:** Allowing users to navigate between differences and accept changes using only the keyboard.
5.  **Location Pane (Future):** A visual overview of all changes in the file.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| P2-DIFF-01 | **Side-by-Side Diffs** | As a developer, I want to see a side-by-side view of the original and modified code with a colored background for changed lines, so I can immediately identify changes at a glance. | - The main diff view is split into two vertical panes: "Original Workspace File" on the right, "AI Response" on the left. <br> - Lines are colored appropriately for additions and removals. |
| P2-DIFF-02 | **Scroll-Locking** | As a developer, when I scroll one of the main diff panes vertically, I want the other main pane to scroll with it, so I can keep the corresponding code aligned. | - All four diff panes have their own scrollbars. <br> - The two main diff panes are scroll-locked vertically. <br> - The two bottom detail panes are scroll-locked horizontally. |
| P2-DIFF-03 | **Navigate Between Diffs** | As a developer reviewing a large file, I want "Next Difference" and "Previous Difference" buttons, so I can quickly jump between changed blocks. | - "Next Difference" (`↓`) and "Previous Difference" (`↑`) buttons are located in a stable toolbar. <br> - Clicking scrolls the view to the start of the next/previous block of changes and highlights it. |
| P2-DIFF-04 | **Keyboard Navigation & Acceptance** | As a developer, I want to use the up/down arrow keys to navigate between differences and the right arrow key to accept the change from the response, so I can review and merge code without using the mouse. | - Pressing `ArrowDown` selects the next difference block. <br> - Pressing `ArrowUp` selects the previous difference block. <br> - Pressing `ArrowRight` accepts the change from the left (AI) pane, visually updating the right (original) pane's content *in memory*. |
| P2-DIFF-05 | **Location Pane (Future)** | As a developer, I want to see a miniature, vertical map of all the changes in the file, so I can understand the overall scope of the diff and quickly jump to any section. | - A new "Location Pane" is displayed above the main diff view. <br> - It shows a compressed visual representation of the entire file, with colored blocks indicating added, removed, and changed lines. <br> - Clicking on a block in this pane scrolls the main diff view to that location. |
| P2-DIFF-06 | **Line Numbers in Detail Pane (Future)** | As a developer, I want to see line numbers in the bottom character-level diff panes, so I have context for where the detailed change is occurring. | - The bottom panes display the relevant line numbers next to the content. |

## 3. Technical Implementation Plan

### 3.1. Layout & Scroll-Locking (`DiffViewer.tsx`, `view.scss`)
-   **Layout:** The main container will use `flex-direction: row` (side-by-side) and the detail container will use `flex-direction: column` (top/bottom).
-   **Scroll-Locking:** `useRef` will be used for all four scrollable panes. `onScroll` event handlers will synchronize the `scrollTop` or `scrollLeft` properties of their counterparts. CSS will no longer hide any scrollbars.

### 3.2. Keyboard Navigation (`DiffViewer.tsx`)
-   **Event Listener:** A `useEffect` hook will add a `keydown` event listener to the component's main wrapper `div` (which must have a `tabIndex` to be focusable).
-   **State Management:**
    *   The existing `selectedDiffIndex` state will be used. The `ArrowUp` and `ArrowDown` handlers will simply increment or decrement this state.
    *   A new state will be added to manage the content of the original file: `const [originalLines, setOriginalLines] = useState(original.content.split('\n'));`.
    *   The diff generation logic in the `useMemo` hook will be updated to use `originalLines` as its source instead of the static `original.content` prop.
-   **Accept Logic (`ArrowRight`):**
    1.  Get the current difference block from `pairedLines` using `selectedDiffIndex`.
    2.  Identify the line numbers and content for this block from both the `left` (AI) and `right` (original) sides.
    3.  Create a new array based on `originalLines`.
    4.  Splice the new lines from the AI response into the correct position in the new array, replacing the old lines.
    5.  Call `setOriginalLines` with this new array. This will trigger a re-render, visually showing the change as "accepted".
</file_artifact>

<file path="src/Artifacts/A57. DCE - Phase 2 - Cycle Management Plan.md">
# Artifact A57: DCE - Phase 2 - Cycle Management Plan
# Date Created: C125
# Author: AI Model & Curator

- **Key/Value for A0:**
- **Description:** Outlines the user stories and technical implementation for deleting cycles and resetting the PCPP history.
- **Tags:** feature plan, phase 2, ui, ux, history, cycle management

## 1. Overview & Goal

As the number of development cycles increases, users need tools to manage their history within the Parallel Co-Pilot Panel (PCPP). The goal of this feature is to provide basic but essential management capabilities, allowing users to delete unwanted cycles and completely reset the history if needed. This keeps the history relevant and manageable.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| P2-CM-01 | **Delete a Cycle** | As a developer, I want to be able to delete a specific cycle from my history, so I can remove erroneous or irrelevant entries. | - A "Delete Cycle" button is available in the "Cycle & Context" section. <br> - Clicking it prompts for confirmation (e.g., "Are you sure you want to delete Cycle X?"). <br> - Upon confirmation, the specified cycle is removed from the `dce_history.json` file. <br> - The UI automatically navigates to the next available cycle (e.g., the previous one or the new latest one). |
| P2-CM-02 | **Reset All History** | As a developer, I want to be able to reset the entire PCPP history, so I can start a project fresh without old cycle data. | - A "Reset History" button is available. <br> - Clicking it shows a strong confirmation warning (e.g., "This will delete ALL cycles and cannot be undone."). <br> - Upon confirmation, the `dce_history.json` file is deleted. <br> - The UI reloads to a fresh "Cycle 1" state. |

## 3. Technical Implementation Plan

1.  **IPC Channels (`channels.enum.ts`, `channels.type.ts`):**
    *   Create `ClientToServerChannel.RequestDeleteCycle` with a payload of `{ cycleId: number }`.
    *   Create `ClientToServerChannel.RequestResetHistory` with an empty payload.

2.  **Backend (`history.service.ts`):**
    *   **`deleteCycle(cycleId: number)`:**
        *   Read the `dce_history.json` file.
        *   Filter the `cycles` array to remove the entry where `cycle.cycleId === cycleId`.
        *   If only one cycle remains, do not allow deletion, or handle it by resetting to a default state.
        *   Write the updated history file back to disk.
    *   **`resetHistory()`:**
        *   Use `vscode.workspace.fs.delete` to remove the `dce_history.json` file.
        *   The existing logic in `getLatestCycle` will automatically create a new, default "Cycle 1" the next time data is requested.

3.  **Frontend (`view.tsx`):**
    *   **UI Buttons:** Add "Delete Cycle" and "Reset History" icon buttons to the `cycle-navigator` div.
    *   **Event Handlers:**
        *   The `onClick` handler for "Delete Cycle" will call `vscode.window.showWarningMessage` to confirm. If the user confirms, it will send the `RequestDeleteCycle` IPC message with the `currentCycle` ID. After sending, it should trigger a request for the new latest cycle data to refresh the UI.
        *   The `onClick` handler for "Reset History" will do the same, but for the `RequestResetHistory` message.

4.  **Message Handling (`on-message.ts`):**
    *   Add handlers for the new IPC channels that call the corresponding methods in `HistoryService`.
    *   After a successful deletion or reset, the backend should send a message back to the client (e.g., a `ForceRefresh` or a new dedicated message) to trigger a full state reload.
</file_artifact>

<file path="src/Artifacts/A58. DCE - WinMerge Source Code Analysis.md">
# Artifact A58: DCE - WinMerge Source Code Analysis
# Date Created: C129
# Author: AI Model & Curator
# Updated on: C130 (Add Architectural and UX Insights)

- **Key/Value for A0:**
- **Description:** Documents the key files and concepts from the WinMerge source code that are relevant to building a high-quality diff viewer.
- **Tags:** research, analysis, diff, winmerge, source code

## 1. Overview

To significantly improve the quality of our integrated diff viewer, an analysis of the open-source WinMerge utility was conducted. This document codifies the key findings from that analysis, listing the most valuable files from the WinMerge source code. These files serve as a reference for implementing advanced diffing features such as a more accurate core algorithm, inline (intra-line) difference highlighting, and moved block detection, as well as architectural patterns for creating a robust and flexible tool.

## 2. Key Reference Files from WinMerge Source

The following files from the WinMerge repository contain the core concepts needed to elevate our diff viewer's quality.

### 2.1. Core Algorithm & Heuristics

These files detail the logic behind WinMerge's highly optimized and accurate line-level diffing, which is based on the GNU `diffutils` engine.

*   **`Winmerge-Src\Src\diffutils\src\analyze.c`**: The heart of the GNU diff algorithm. The `diag` function implements the core logic for finding the "shortest edit script." Studying this reveals the heuristics used to achieve high-quality and performant diffs.
*   **`Winmerge-Src\Src\DiffWrapper.cpp`**: This is a C++ wrapper around the `diffutils` engine. It demonstrates how the raw output from the C functions is processed into a more usable format for the application, serving as a model for processing diff results.

### 2.2. Inline (Intra-Line) Difference Highlighting

This file contains the logic for highlighting the specific characters that have changed *within* a line.

*   **`Winmerge-Src\Src\stringdiffs.cpp`**: Contains WinMerge's dedicated algorithm for performing intra-line diffs. Analyzing its approach can help improve our own character-level diff rendering.

### 2.3. Moved Block Detection

This is one of WinMerge's most powerful features, providing essential context for refactoring.

*   **`Winmerge-Src\Src\MovedBlocks.cpp`**: This file contains the complete algorithm WinMerge uses to analyze the diff list, find matching blocks of text that have been moved, and link them together. This is the primary reference for implementing this feature.

### 2.4. Data Structures & UI Rendering

These files show how the data is structured and rendered to the user in the side-by-side view.

*   **`Winmerge-Src\Src\MergeDoc.cpp`**: Acts as the data model for the application. It shows how the diff list is structured to accommodate advanced concepts like moved lines. Our `PairedLine` interface can be modeled on the data structures found here.
*   **`Winmerge-Src\Src\MergeEditView.cpp`**: This is the main rendering component. It contains the logic for taking the results of the line and intra-line diffs and drawing the text with the correct highlighting and layout.
*   **`Winmerge-Src\Src\DiffList.h`**: This header defines the core data structures for the list of differences and is an excellent reference for designing a more robust data model.
*   **`Winmerge-Src\Src\MainFrm.cpp`**: The main application window frame. This file is valuable for understanding how the different components (the document/model, the view, user options, etc.) are all integrated and managed at the application level.

## 3. Architectural and UX Insights (C130)

Beyond specific algorithms, the WinMerge source code reveals important architectural patterns for building a high-quality diffing tool.

*   **Configurability (`CompareOptions.h`, `OptionsMgr.h`):** WinMerge is extremely configurable. The code shows a clear separation between the core diffing logic and the user-configurable options (e.g., whitespace handling, case sensitivity, filtering). This is a strong pattern to emulate, ensuring our tool can be adapted to various user needs.
*   **Text Encoding (`unicoder.h`, `codepage_detect.cpp`):** The project has dedicated, robust code for detecting and handling different text encodings. This is a critical, non-trivial feature for a diff tool that must work with files from various sources. It highlights the importance of pre-processing file content into a consistent format *before* passing it to the diff algorithm.
*   **Pluggable Compare Engines (`CompareEngines` directory):** WinMerge uses a strategy pattern, allowing different comparison engines (e.g., `BinaryCompare`, `ImageCompare`, `TimeSizeCompare`) to be used. This is a powerful architectural concept that could allow our tool to be extended with new comparison methods in the future (e.g., semantic code diffing).

## 4. Path Forward

By studying the algorithms and architectural patterns in these key files, we can create a clear development plan to implement these advanced features in our TypeScript and React-based extension. The immediate priority is to refactor our UI to a vertical, fixed-pane layout, and then we can begin to incrementally incorporate the more advanced logic inspired by these files.
</file_artifact>

<file path="src/Artifacts/A59. DCE - Phase 2 - Debugging and State Logging.md">
# Artifact A59: DCE - Phase 2 - Debugging and State Logging
# Date Created: C134
# Author: AI Model & Curator
# Updated on: C3 (Focus log output on cycle management state and truncate large data)

- **Key/Value for A0:**
- **Description:** Documents the plan for a "Log State" button that outputs critical state information (cycle history, current inputs) to the debug channel to accelerate troubleshooting.
- **Tags:** feature plan, phase 2, ui, ux, debugging, logging, state management

## 1. Overview & Goal

Debugging complex state interactions in the Parallel Co-Pilot Panel can be challenging, as it often requires the curator to manually describe the state of multiple text fields and selections. To accelerate this process, a dedicated debugging feature is required.

The goal of this feature is to add a **"Log State"** button to the PCPP's main header. When clicked, this button will generate a comprehensive, formatted log of the panel's current state and send it to the "Data Curation Environment" output channel. This allows the curator to easily copy and paste the exact state of the application into their feedback, eliminating ambiguity and speeding up bug resolution.

## 2. User Story

| ID | User Story | Acceptance Criteria |
|---|---|---|
| P2-LOG-01 | **Log Current State for Debugging** | As a curator encountering a bug, I want to click a "Log State" button that outputs the current state of the entire PCPP to the debug logs, so I can easily copy and paste this information for you to reproduce the issue. | - A "Log State" button is present in the main header of the PCPP. <br> - Clicking the button generates a formatted message in the "Data Curation Environment" output channel. <br> - **(C3 Update)** The log output is now focused specifically on the state variables relevant to cycle management to diagnose bugs like data loss or being stuck on a cycle. It will include: <br> &nbsp;&nbsp;&nbsp; 1. A summary of the key frontend state variables (`currentCycle`, `maxCycle`, `isNewCycleButtonDisabled`). <br> &nbsp;&nbsp;&nbsp; 2. A **truncated** JSON dump of the entire `dce_history.json` file from the backend for comparison, with large code blocks shortened to prevent flooding the logs. |

## 3. Technical Implementation Plan

1.  **UI (`view.tsx`):**
    *   A "Log State" button will be added to the main header toolbar.
    *   Its `onClick` handler will gather the complete current state of the panel into a single `PcppCycle` object and send it to the backend via a new IPC message.

2.  **IPC Channels (`channels.enum.ts`, `channels.type.ts`):**
    *   Create a new `ClientToServerChannel.RequestLogState`.
    *   The payload will be `{ currentState: PcppCycle }`.

3.  **Backend Logic (`prompt.service.ts`):**
    *   A new public method, `public async generateStateLog(currentState: PcppCycle)`, will be created.
    *   **Step 1: Generate Formatted State Dump (C3 Revision):**
        *   It will fetch the full history from `history.service.ts`.
        *   It will construct a focused log string containing the most relevant frontend state variables for the current bug (`currentCycle`, `maxCycle`, `isNewCycleButtonDisabled`, `cycleTitle`, `cycleContext`, `selectedResponseId`).
        *   It will use the `truncateCodeForLogging` utility on the `content` of each response in the history before creating a `JSON.stringify` of the full history file content.
    *   **Step 2: Log to Output Channel:**
        *   It will combine these strings into a single, clearly labeled log message and send it to `Services.loggerService.log()`.
        *   It will then call `Services.loggerService.show()` to programmatically open the output channel for the user.
</file_artifact>

<file path="src/Artifacts/A60. DCE - Phase 2 - Cycle 0 Onboarding Experience.md">
# Artifact A60: DCE - Phase 2 - Cycle 0 Onboarding Experience
# Date Created: C139
# Author: AI Model & Curator
# Updated on: C187 (Rename README.md to DCE_README.md)

## 1. Vision & Goal

The Parallel Co-Pilot Panel (PCPP) is a powerful tool, but its effectiveness relies on a structured set of planning and documentation artifacts. For a new user, bootstrapping this structure is a major hurdle.

The goal of the "Cycle 0" onboarding experience is to automate this bootstrapping process. The extension will capture the user's high-level project scope and generate a prompt that instructs an AI to create a starter pack of essential **planning and documentation artifacts**. As part of this process, it will also create a `DCE_README.md` file within the `src/Artifacts` directory that explains the artifact-driven workflow itself, providing meta-context to both the user and the AI.

## 2. User Flow

1.  **Detection:** The extension detects a "fresh workspace" by confirming the absence of any `A0.*Master Artifact List.md` file in the `src/Artifacts/` directory.
2.  **Cycle 0 UI:** The PCPP loads into a special "Cycle 0" view. It presents the user with an introduction and a single large text area for their "Project Scope".
3.  **User Input:** The user describes their project's vision and goals.
4.  **Generate Prompt & Artifacts:** The user clicks "Generate Initial Artifacts Prompt".
5.  **Backend Process:**
    *   The backend `PromptService` constructs a unique `prompt.md` file. The prompt's static context will contain the content of all template artifacts (files prefixed with `T` in the extension's artifacts).
    *   **Prompt Instruction Refinement (C179):** The instructions within the generated prompt will be updated to strongly encourage the AI to generate a comprehensive set of initial artifacts. It will explicitly prioritize foundational documents like **`T14. Template - GitHub Repository Setup Guide.md`** and **`T7. Template - Development and Testing Guide.md`** to ensure the user receives critical operational guidance from the very beginning, addressing potential setup hurdles like Git initialization proactively.
    *   It creates `src/Artifacts/DCE_README.md`, populated with the content from the extension's internal `A72. DCE - README for Artifacts.md`.
    *   It saves the user's "Project Scope" to a persistent field in `dce_history.json`.
6.  **Transition to Cycle 1:** The frontend reloads its state. Since an `A0` file does not yet exist, the user is presented with a "Continue to Cycle 1" button. Clicking this transitions them to the main PCPP interface.
7.  **User Action:** The user takes the generated `prompt.md` and uses it with their preferred LLM.
8.  **First Iteration:** The user pastes the AI's response (which should contain the new, correctly formatted documentation artifacts, including a project-specific `A0` file) back into the PCPP's "Cycle 1" tab. The standard iterative workflow begins.
9.  **Return to Cycle 0:** The user can click the "Project Plan" button to navigate back to Cycle 0 to view and edit their master project scope. A "Return to Cycles" button will take them back to their latest cycle.

## 3. Meta-Context Injection Process

To ensure the AI can always generate perfectly parsable responses, the DCE injects "meta-context" into the prompts for all cycles *after* Cycle 0. This process is automatic and transparent to the user.

-   **Cycle 0 (Bootstrapping):** Uses the curated `T` (template) artifacts as static context to guide the AI in creating initial *planning* documents for the user's project. The goal is to establish the project's structure.
-   **Cycle 1+ (Iterative Development):** The `prompt.service.ts` automatically reads and injects the following critical artifacts into the `<M3. Interaction Schema>` section of every generated `prompt.md`:
    -   **`A52.1 DCE - Parser Logic and AI Guidance.md`**: Contains the literal source code of the response parser, showing the AI exactly how its output will be interpreted.
    -   **`A52.2 DCE - Interaction Schema Source.md`**: Contains the canonical rules of interaction, ensuring the AI always has the latest formatting guidelines.
</file_artifact>

<file path="src/Artifacts/A61. DCE - Phase 2 - Cycle History Management Plan.md">
# Artifact A61: DCE - Phase 2 - Cycle History Management Plan
# Date Created: C152
# Author: AI Model & Curator
# Updated on: C163 (Flesh out plan and user stories for Import/Export)

- **Key/Value for A0:**
- **Description:** Outlines the plan to allow users to save and load their entire cycle history (`dce_history.json`), enabling them to manage multiple development threads or back up their work.
- **Tags:** feature plan, phase 2, history, import, export, cycle management

## 1. Overview & Goal

The `dce_history.json` file is a valuable asset that captures the entire iterative development process for a project, including the project scope, cycle notes, and all AI-generated responses. Users may want to work on different feature branches or experiments, each with its own cycle history.

The goal of this feature is to provide commands and UI controls to **export** the current cycle history to a file and **import** a history file, effectively allowing users to save and load different "cycle chains."

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| P2-CHM-01 | **Export Cycle History** | As a developer, I want to export the entire cycle history to a named JSON file, so I can create a backup or save the history for a specific feature branch before starting a new one. | - A "Save History..." button is available in the cycle navigator toolbar. <br> - Clicking it opens a native "Save As..." dialog. <br> - The current content of `.vscode/dce_history.json` is written to the user-specified file. <br> - A success notification is shown. |
| P2-CHM-02 | **Import Cycle History** | As a developer, I want to import a cycle history from a JSON file, so I can switch between different development threads or restore a backup. | - A "Load History..." button is available in the cycle navigator toolbar. <br> - Clicking it opens a native "Open..." dialog to select a JSON file. <br> - The content of the selected file overwrites the current `.vscode/dce_history.json`. <br> - The PCPP UI automatically refreshes to show the new, imported history. |

## 3. Technical Implementation Plan

1.  **IPC Channels:**
    *   `ClientToServerChannel.RequestExportHistory`: No payload.
    *   `ClientToServerChannel.RequestImportHistory`: No payload.

2.  **Backend (`history.service.ts`):**
    *   **`handleExportHistory()`:**
        *   Read the current `.vscode/dce_history.json` file.
        *   Use `vscode.window.showSaveDialog` to get a destination URI from the user.
        *   If a URI is provided, write the history content to that file.
        *   Show a `showInformationMessage` on success.
    *   **`handleImportHistory()`:**
        *   Use `vscode.window.showOpenDialog` to get a source URI from the user.
        *   If a URI is provided, read its content.
        *   Perform basic validation to ensure it looks like a history file (e.g., has `version` and `cycles` properties).
        *   Overwrite the workspace's `.vscode/dce_history.json` with the new content.
        *   Trigger a `ForceRefresh` message with `reason: 'history'` to the PCPP frontend to force a full state reload.

3.  **Frontend (`view.tsx`):**
    *   The "Save History" (`VscCloudUpload`) and "Load History" (`VscCloudDownload`) buttons in the cycle navigator toolbar will be enabled.
    *   Their `onClick` handlers will trigger the corresponding IPC messages.
    *   The existing handler for the `ForceRefresh` message will automatically handle the UI update after a successful import.
</file_artifact>

<file path="src/Artifacts/A65. DCE - Universal Task Checklist.md">
# Artifact A65: DCE - Universal Task Checklist
# Date Created: C165
# Author: AI Model & Curator
# Updated on: C167 (Encourage cyclic updates)

- **Key/Value for A0:**
- **Description:** A universal checklist for organizing development tasks by file, focusing on complexity in terms of token count and estimated cycles for completion.
- **Tags:** process, checklist, task management, planning, workflow

## 1. Purpose

This artifact provides a structured, universal format for tracking development tasks, feedback, and bugs. Unlike cycle-specific trackers, this checklist organizes work by the group of files involved in a given task. It also introduces a simple complexity metric based on the total token count of the affected files and an estimation of whether the task will require more than one development cycle to complete.

This file-centric approach helps in planning and prioritizing work, especially in an AI-assisted development workflow where context size (token count) is a primary constraint.

## 2. How to Use

-   **Group by File Packages:** Create a new `##` section for each logical task or feature. List all the files that are expected to be modified for this task.
-   **Assign an ID:** Give each task package a unique, simple ID (e.g., `T-1`, `T-2`) for easy reference in feedback.
-   **Estimate Complexity:**
    -   Calculate the **Total Tokens** for all files in the package. This gives a quantitative measure of the context size.
    -   Estimate if the task is likely to take **More than one cycle?**. This is a qualitative judgment based on the complexity of the changes required.
-   **List Action Items:** Under each file package, create a checklist of specific actions, bugs to fix, or features to implement.
-   **Add Verification Steps:** After the action items, add a section describing how the curator should test the feature to confirm it is working as expected.
-   **Note on Output Length:** Remember that the maximum output length for a single response is approximately 65,000 tokens. Do not prematurely stop generating files; attempt to complete as many full files as possible within this limit.
-   **Keep it Current:** At the beginning of each new cycle, review and update this checklist. Move completed tasks to a "Completed" section, add new tasks based on feedback, and re-prioritize as needed. This ensures the checklist remains a living, accurate reflection of the project's status.

---

## Task List

## T-1: PCPP - No Workspace View
- **Files Involved:**
    - `src/backend/services/history.service.ts`
    - `src/client/views/parallel-copilot.view/view.tsx`
    - `src/common/ipc/channels.enum.ts`
    - `src/common/ipc/channels.type.ts`
    - `src/backend/services/file-operation.service.ts`
    - `src/client/views/parallel-copilot.view/on-message.ts`
    - `src/client/views/context-chooser.view/view.tsx`
- **Total Tokens:** ~25,000
- **More than one cycle?** No

- [ ] **Task (T-ID: 1.1):** Clicking the "Open Folder" button should trigger the native VS Code open folder dialog.
- [ ] **Task (T-ID: 1.2):** Add the same "No Folder Opened" UI to the Context Chooser panel.
- [ ] **Task (T-ID: 1.3):** Ensure the "Open Folder" buttons in both views use the same primary button style as "Flatten Context".

### Verification Steps
1.  Close any open workspace in the VS Code Extension Development Host (`File > Close Folder`).
2.  Open the Parallel Co-Pilot Panel.
3.  **Expected:** The panel should display a "No Folder Opened" message and an "Open Folder" button.
4.  Click the "Open Folder" button.
5.  **Expected:** The native VS Code "Open Folder" dialog should appear.
6.  Close the dialog and open the Data Curation (Context Chooser) panel.
7.  **Expected:** This panel should also display the "No Folder Opened" message and button.
8.  Click the button and open a folder.
9.  **Expected:** Both panels should now load their respective UIs for the opened workspace.

## T-2: Prompt Generation
- **Files Involved:**
    - `src/backend/services/prompt.service.ts`
- **Total Tokens:** ~4,000
- **More than one cycle?** No

- [ ] **Bug Fix (T-ID: 2.1):** The `<M5. organized artifacts list>` section should be populated from the user's workspace `A0*.md` file, not the extension's internal one.
- [ ] **Bug Fix (T-ID: 2.2):** The `<M6. Cycles>` block must be generated with cycles in descending order (newest first).

### Verification Steps
1.  In a test project with a custom-named A0 file (e.g., `MyProject-A0-Master-List.md`), navigate to the latest cycle in the PCPP.
2.  Click "Generate prompt.md".
3.  **Expected:** Open the `prompt.md` file. The `<M5>` section should contain the content of `MyProject-A0-Master-List.md`. The `<M6>` section should show the highest cycle number first.

## T-3: File Flattening
- **Files Involved:**
    - `src/backend/services/file-tree.service.ts`
    - `src/backend/services/flattener.service.ts`
- **Total Tokens:** ~6,500
- **More than one cycle?** No

- [ ] **Bug Fix (T-ID: 3.1):** `package-lock.json` must be excluded from the flattened output, even if its parent directory is checked.

### Verification Steps
1.  Open the Context Chooser panel.
2.  **Expected:** The `package-lock.json` file should have a disabled checkbox.
3.  Check the root directory of the project.
4.  Click "Flatten Context".
5.  **Expected:** Open the `flattened_repo.md` file. The `package-lock.json` file and its content should NOT be present.
</file_artifact>

<file path="src/Artifacts/A67. DCE - PCPP View Refactoring Plan.md">
# Artifact A67. DCE - PCPP View Refactoring Plan
# Date Created: C167
# Author: AI Model & Curator

- **Key/Value for A0:**
- **Description:** A plan to refactor the large `parallel-copilot.view.tsx` into smaller, more manageable components to improve maintainability.
- **Tags:** refactor, architecture, technical debt, pcpp

## 1. Problem Statement

The `parallel-copilot.view/view.tsx` component has become a "god component," currently exceeding 8,000 tokens. It manages the state and rendering for the entire Parallel Co-Pilot Panel, including:
-   The main view and the onboarding view.
-   The cycle navigator.
-   The context input text areas.
-   The response tab bar.
-   The raw text view for each tab.
-   The complex, multi-pane parsed view.
-   The diff viewer.
-   All associated state management (`useState`, `useMemo`, `useEffect`).
-   All IPC message handling.

This monolithic structure makes the component difficult to read, debug, and maintain. A single change can have unintended consequences, and the high token count makes it a challenging file to work with.

## 2. Refactoring Plan

The goal is to break down `view.tsx` into a series of smaller, single-responsibility components. The main `view.tsx` file will be refactored into a "container" component that manages the core state and orchestrates the new, smaller "presentational" components.

### 2.1. Proposed Component Structure

-   **`view.tsx` (Container):**
    -   **Responsibility:** Manages all primary state (`currentCycle`, `tabs`, `isParsedMode`, etc.) and all IPC message handlers. It will render the appropriate child components and pass down state and callbacks as props.

-   **`src/client/views/parallel-copilot.view/components/` (New Directory):**
    -   **`CycleNavigator.tsx`:** Renders the cycle navigation bar, including the cycle number, title input, and navigation buttons. Receives the current cycle state and `onCycleChange` callbacks as props.
    -   **`ContextInputs.tsx`:** Renders the "Cycle Context" and "Ephemeral Context" text areas, including their new line number and token count displays. Receives content and `onChange` handlers as props.
    -   **`ResponseTabs.tsx`:** Renders the main tab bar. Receives the list of tabs, the active tab, and the `onTabSelect` handler as props.
    -   **`ResponsePane.tsx`:** A larger component responsible for rendering the content of a single, active tab. It will contain the logic to display either the raw `textarea` or the parsed view.
    -   **`ParsedView.tsx`:** Renders the multi-pane parsed view, including the "Associated Files" list, summary, and course of action. It will contain the logic for selecting a file to view.
    -   **`CodeViewer.tsx`:** Renders the syntax-highlighted code or the `DiffViewer`. Receives the file content and diff data as props.
    -   **`NumberedTextarea.tsx`:** The new reusable component for text areas with line numbers and resizing.

## 3. Benefits of Refactoring

-   **Improved Readability:** Each component will be smaller and focused on a single part of the UI, making the code easier to understand.
-   **Improved Maintainability:** Bugs and feature requests can be addressed in isolated components, reducing the risk of unintended side effects.
-   **Reduced Token Count:** Splitting the large file into many smaller ones makes each file more manageable for both human and AI developers.
-   **Better Performance:** Memoization (`React.memo`) can be applied more effectively to smaller components, preventing unnecessary re-renders.
</file_artifact>

<file path="src/Artifacts/A68. DCE - PCPP Context Pane UX Plan.md">
# Artifact A68: DCE - PCPP Context Pane UX Plan
# Date Created: C167
# Author: AI Model & Curator

- **Key/Value for A0:**
- **Description:** A plan to enhance the UX of the cycle context and ephemeral context text areas with features like token counts and line numbers.
- **Tags:** feature plan, ui, ux, pcpp, context

## 1. Overview & Goal

The "Cycle Context" and "Ephemeral Context" text areas in the Parallel Co-Pilot Panel are crucial for prompt engineering, but their current implementation as basic `<textarea>` elements lacks key features. The goal of this plan is to significantly enhance their usability by adding token counts, line numbers, and persistent resizing.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| P2-CTX-01 | **See Context Token Count** | As a developer, I want to see a live token count for the Cycle Context and Ephemeral Context fields, so I can manage the size of my prompt effectively. | - Below each text area, a label displays the approximate token count of its content. <br> - The count updates in real-time as the user types. |
| P2-CTX-02 | **See Line Numbers** | As a developer, I want to see line numbers in the context text areas, so I can easily reference specific parts of a long context or error log. | - A line number gutter is displayed to the left of the text input area. <br> - The line numbers scroll in sync with the text content. |
| P2-CTX-03 | **Persistent Resizing** | As a developer, when I resize the height of a context text area, I want it to remain that size when I navigate between cycles, so I don't lose my layout preferences. | - The `height` of each text area is stored as part of the `PcppCycle` state. <br> - When the user resizes a text area, its new height is saved. <br> - When the panel re-renders or a cycle is loaded, the text areas are restored to their saved heights. |

## 3. Technical Implementation Plan

### 3.1. Token Counts
-   **State:** Add new state variables to `view.tsx`: `cycleContextTokens` and `ephemeralContextTokens`.
-   **UI:** Add `<span>` elements below each text area to display these state values.
-   **Logic:** The `onChange` handlers for the text areas will be updated to calculate the token count (`e.target.value.length / 4`) and update the corresponding token count state.

### 3.2. Line Numbers & Resizing
-   **New Component (`NumberedTextarea.tsx`):**
    -   Create a new reusable component that renders a `textarea` alongside a synchronized `div` for line numbers.
    -   This component will manage its own internal state for line count based on the `value` prop.
    -   It will include a draggable handle at the bottom. `onMouseDown`, `onMouseMove`, and `onMouseUp` handlers will be used to track the drag gesture.
    -   It will call an `onHeightChange` prop function with the new height, allowing the parent to manage the state.
-   **Integration (`view.tsx`):**
    -   Replace the existing `<textarea>` elements with the new `<NumberedTextarea>` component.
    -   **State:** Add `cycleContextHeight` and `ephemeralContextHeight` to the component's state and to the `PcppCycle` type definition.
    -   The `onHeightChange` prop of the new component will be wired to update these state variables, which will be persisted via the existing debounced save mechanism.
</file_artifact>

<file path="src/Artifacts/A69. DCE - Animated UI Workflow Guide.md">
# Artifact A69: DCE - Animated UI Workflow Guide
# Date Created: C169
# Author: AI Model & Curator
# Updated on: C187 (Correct final workflow steps)

## 1. Overview & Goal

The Parallel Co-Pilot Panel (PCPP) has a powerful, multi-step workflow that may not be immediately obvious to new users. The goal of this feature is to implement a guided experience using subtle UI animations. These animations will highlight the next logical action the user should take, gently guiding them through the process from project creation to generating the next cycle's prompt.

## 2. User Story

| ID | User Story | Acceptance Criteria |
|---|---|---|
| P2-WF-01 | **Guided Workflow** | As a new user, I want the UI to visually guide me through the steps of a development cycle, so I can learn the workflow intuitively. | - After a specific action is completed, the UI element for the next logical action is highlighted with a subtle animation (e.g., a pulsing blue glow). |

## 3. The Animated Workflow Sequence (The Perfect Loop)

The highlighting will follow this specific sequence of user actions:

### Onboarding / Cycle 0
1.  **Start (New Workspace):** User opens a new, empty folder in VS Code.
    *   **Auto-Action:** The **DCE Parallel Co-Pilot Panel** automatically opens.

2.  **Open PCPP (Welcome View):** The PCPP is open to the "Welcome" / "Onboarding" view.
    *   **Highlight:** The **Project Scope `textarea`** pulses.

3.  **Input Project Scope:** User types their project plan into the `textarea`.
    *   **Highlight:** The **`Generate Initial Artifacts Prompt`** button pulses.

4.  **Generate `prompt.md`:** User clicks the button. `prompt.md` and `DCE_README.md` are created. The view transitions to Cycle 1.
    *   **Auto-Action:** `prompt.md` and `src/Artifacts/DCE_README.md` are automatically opened in the editor.
    *   **Highlight:** The **`Resp 1`** tab in the PCPP pulses.

### Main Loop (Cycle 1+)
5.  **Paste Responses:** The user gets responses from an LLM and pastes them into the response tabs.
    *   **Highlight:** The highlight moves sequentially from **`Resp 1`** to **`Resp 2`**, etc., as each `textarea` is filled.
    *   **Trigger:** Once content is present in all tabs, the highlight moves to the next step.

6.  **Parse Responses:**
    *   **Highlight:** The **`Parse All`** button pulses.

7.  **Sort Responses:** User clicks `Parse All`.
    *   **Highlight:** The **`Sort`** button pulses. (Skips if already sorted).

8.  **Select a Response:** User reviews the responses.
    *   **Highlight:** The **`Select This Response`** button on each tab pulses.

9.  **Create Baseline:** User clicks `Select This Response`.
    *   **Highlight:** The **`Baseline (Commit)`** button pulses.
    *   **State-Aware Skip:** This step is skipped if the backend reports that the Git working tree is already clean.

10. **Select Files for Acceptance:** A successful baseline is created.
    *   **Highlight:** The "Associated Files" list panel and the **`Select All`** button within it pulse.

11. **Accept Changes:** User checks one or more files in the "Associated Files" list.
    *   **Highlight:** The **`Accept Selected`** button pulses.

12. **Write Context:** User clicks `Accept Selected`.
    *   **Highlight:** The **"Cycle Context"** `textarea` pulses.

13. **Write Title:** User types into the "Cycle Context" `textarea`.
    *   **Highlight:** The **"Cycle Title"** input field pulses.

14. **Generate Next Prompt:** User types a bespoke "Cycle Title".
    *   **Highlight:** The **`Generate prompt.md`** button pulses.

15. **Create New Cycle:** User clicks `Generate prompt.md`.
    *   **Highlight:** The **`[ + ]` (New Cycle)** button pulses, completing the loop and preparing for the next iteration which starts back at Step 5.
</file_artifact>

<file path="src/Artifacts/A72. DCE - README for Artifacts.md">
# Artifact A72: DCE - README for Artifacts
# Date Created: C158
# Author: AI Model & Curator
# Updated on: C183 (Strengthen Git initialization and `.gitignore` guidance)

- **Key/Value for A0:**
- **Description:** The content for the `README.md` file that is automatically created in a new project's `src/Artifacts` directory, explaining the purpose of the extension and the artifact-driven workflow.
- **Tags:** documentation, onboarding, readme, source of truth

## 1. Welcome to the Data Curation Environment (DCE)

This directory (`src/Artifacts/`) is the heart of your project's planning and documentation. It's managed by the **Data Curation Environment (DCE)**, a VS Code extension designed to streamline AI-assisted development.

This `README.md` file was automatically generated to provide context for you (the developer) and for the AI assistants you will be working with.

## 2. What is an "Artifact"?

In the context of this workflow, an **Artifact** is a formal, written document that serves as a "source of truth" for a specific part of your project. Think of these files as the official blueprints, plans, and records.

The core principle of the DCE workflow is **"Documentation First."** Before writing code, you and your AI partner should first create or update an artifact that describes the plan.

## 3. The Iterative Cycle Workflow

Development in the DCE is organized into **Cycles**. You have just completed the initial setup.

### Your Next Steps

1.  **Initialize Your Git Repository (CRITICAL):**
    To take full advantage of the DCE's testing workflow (creating baselines and restoring changes), you **must** initialize a Git repository.
    
    Open a terminal in your project's root directory (you can use the integrated terminal in VS Code: `Terminal > New Terminal`) and run the following commands:
    ```bash
    git init
    # Create or update your .gitignore file with the line below
    echo ".vscode/" >> .gitignore
    git add .
    git commit -m "Initial commit"
    ```
    **Why `.gitignore`?** The DCE saves its state in a `.vscode/dce_history.json` file. Adding `.vscode/` to your `.gitignore` is crucial to prevent the extension's UI from flashing every time it auto-saves. For a complete guide, refer to the `GitHub Repository Setup Guide.md` artifact.

2.  **Submit Your First Prompt:** The `prompt.md` file has been automatically opened for you. This file contains your project plan and instructions for the AI. Copy its entire contents and paste it into your preferred AI chat interface (like Google's AI Studio, ChatGPT, etc.).

3.  **Review and Accept Responses:** Paste the AI's responses back into the "Resp 1", "Resp 2", etc. tabs in the Parallel Co-Pilot panel. The UI will guide you through parsing the responses, selecting the best one, and accepting its changes into your workspace.

4.  **Repeat:** This completes a cycle. You then start the next cycle, building upon the newly accepted code and documentation.

This structured, iterative process helps maintain project quality and ensures that both human and AI developers are always aligned with the project's goals.
</file_artifact>

<file path="src/Artifacts/A73. DCE - GitService Plan.md">
# Artifact A73: DCE - GitService Plan
# Date Created: C175
# Author: AI Model & Curator

- **Key/Value for A0:**
- **Description:** A plan for a dedicated backend service to encapsulate all interactions with the Git command line for features like baselining and restoring.
- **Tags:** plan, architecture, backend, git, service

## 1. Overview & Goal

To implement the Git-integrated testing workflow (`A70`), we need a dedicated backend component to handle the execution of Git commands. The goal is to create a new, single-responsibility `GitService` that encapsulates all interactions with the Git CLI. This improves modularity and makes the code easier to maintain and test.

## 2. Service Responsibilities

The `GitService` will be responsible for:
-   Executing `git` commands in the user's workspace directory using Node.js's `child_process`.
-   Parsing the output (stdout and stderr) of Git commands.
-   Handling errors gracefully and providing clear feedback to the user.

## 3. Technical Implementation Plan

1.  **New File (`src/backend/services/git.service.ts`):**
    *   Create the new service file.
    *   It will import `exec` from `child_process` and `vscode`.

2.  **Core `execGitCommand` Method:**
    *   A private helper method will be the foundation of the service: `private execGitCommand(command: string): Promise<{ stdout: string; stderr: string }>`.
    *   This method will wrap the `exec` call in a `Promise`, making it easy to use with `async/await`.
    *   It will get the workspace root path from `vscode.workspace.workspaceFolders`.
    *   It will execute the command within that workspace directory.

3.  **Public Handler Methods:**
    *   **`handleGitBaselineRequest(commitMessage: string)`:**
        *   Calls `await this.execGitCommand('git add .')`.
        *   On success, calls `await this.execGitCommand(\`git commit -m "${commitMessage}"\`)`.
        *   Will show a `vscode.window.showInformationMessage` on success or `showErrorMessage` on failure.
    *   **`handleGitRestoreRequest()`:**
        *   Constructs the command: `git restore -- . ':(exclude).vscode/dce_history.json'`.
        *   Calls `await this.execGitCommand(...)`.
        *   Shows appropriate success or error messages to the user.

4.  **Integration:**
    *   The new `GitService` will be instantiated in `src/backend/services/services.ts`.
    *   The `parallel-copilot.view/on-message.ts` file will be updated to call the new service's methods when it receives the `RequestGitBaseline` and `RequestGitRestore` IPC messages.
</file_artifact>

<file path="src/Artifacts/A74. DCE - Per-Input Undo-Redo Feature Plan.md">
# Artifact A74: DCE - Per-Input Undo-Redo Feature Plan
# Date Created: C178
# Author: AI Model & Curator

- **Key/Value for A0:**
- **Description:** A plan to implement a separate undo/redo history for each major text input in the PCPP to provide a more intuitive editing experience.
- **Tags:** feature plan, ui, ux, undo, redo, state management

## 1. Overview & Goal

Currently, all text inputs in the Parallel Co-Pilot Panel (e.g., Cycle Title, Cycle Context, Ephemeral Context) share a single, global undo/redo history stack, which is the default behavior for a webview. This leads to a confusing and non-standard user experience. For example, typing in the "Cycle Context" and then pressing `Ctrl+Z` in the "Cycle Title" input will undo the change made in the context field, not the title field.

The goal of this feature is to implement a separate, independent undo/redo history for each major text input, aligning the panel's behavior with standard application design.

## 2. User Story

| ID | User Story | Acceptance Criteria |
|---|---|---|
| P2-UNDO-01 | **Per-Input Undo/Redo** | As a developer, when I am editing multiple text fields, I want `Ctrl+Z` (Undo) and `Ctrl+Y` (Redo) to apply only to the text field I am currently focused on, so I can manage my edits for each field independently. | - Changes made to the "Cycle Title" input can be undone/redone without affecting the other text areas. <br> - Changes made to the "Cycle Context" text area can be undone/redone independently. <br> - Changes made to the "Ephemeral Context" text area can be undone/redone independently. |

## 3. Technical Implementation Plan

This is a complex feature that requires overriding the browser's default undo/redo behavior and implementing a custom state management solution.

1.  **Create a Custom `useHistoryState` Hook:**
    *   A new React hook, `useHistoryState`, will be created to manage the state history for a single value (e.g., a string).
    *   This hook will manage a state object: `{ past: string[], present: string, future: string[] }`.
    *   It will return an array: `[state, setState, undo, redo, canUndo, canRedo]`.
    *   The `setState` function will update the `present` value and push the old `present` value onto the `past` stack.
    *   The `undo` and `redo` functions will move values between the `past`, `present`, and `future` stacks.

2.  **Integrate the Hook in `view.tsx`:**
    *   The main `view.tsx` component will use this custom hook for each of the relevant state variables:
        ```typescript
        const [cycleTitle, setCycleTitle, undoTitle, redoTitle] = useHistoryState('');
        const [cycleContext, setCycleContext, undoContext, redoContext] = useHistoryState('');
        const [ephemeralContext, setEphemeralContext, undoContext, redoContext] = useHistoryState('');
        ```

3.  **Implement Custom `onKeyDown` Handlers:**
    *   A new `onKeyDown` handler will be created and attached to each of the relevant input/textarea components.
    *   This handler will check for `Ctrl+Z` and `Ctrl+Y` (and their platform-specific variants).
    *   When an undo/redo shortcut is detected, it will call `event.preventDefault()` to stop the default browser action.
    *   It will then call the corresponding `undo` or `redo` function from the `useHistoryState` hook for that specific input.

4.  **Refactor `NumberedTextarea.tsx`:**
    *   The `NumberedTextarea` component will need to be updated to accept the new, more complex `onKeyDown` handler.

This approach will provide the robust, per-input undo/redo functionality required for a professional user experience.
</file_artifact>

<file path="src/Artifacts/A75. DCE - Text Area Component A-B-C Test Plan.md">
# Artifact A75: DCE - Text Area Component A-B-C Test Plan
# Date Created: C179
# Author: AI Model & Curator
# Updated on: C180 (Acknowledge word-wrap limitation)

- **Key/Value for A0:**
- **Description:** A plan to create a test harness for the `NumberedTextarea` component to diagnose and fix persistent scrolling and alignment bugs.
- **Tags:** plan, process, debugging, troubleshooting, ui, ux, react

## 1. Overview & Goal

The `NumberedTextarea` component, used for the "Cycle Context" and "Ephemeral Context" fields in the Parallel Co-Pilot Panel, has been a persistent source of UI bugs across multiple cycles (C1, C2, C3, C167, C174). The primary issues are a lack of synchronized scrolling between the line numbers and the text content, and a misalignment of the cursor and text selection, making the component difficult to use.

The goal of this plan is to apply the "Original-A-B-C" testing strategy, as defined in `A51`, to definitively diagnose and resolve these issues. We will create a test harness within the PCPP that allows for parallel testing of the original component and three new, isolated test components, each attempting a different solution.

## 2. Known Limitation: Word-Wrap Line Numbering

As of Cycle 4, it has been observed that the current architecture of the `NumberedTextarea` (and all proposed test variants) does not correctly handle line numbering for word-wrapped text. The component counts lines based on newline characters (`\n`), not on how the text visually wraps in the view. This means a single line of text that wraps into three visual lines will only get one line number.

**This is a known limitation.** A true fix for this requires a significantly more complex architecture, likely involving rendering text into a hidden element and measuring the resulting line boxes. For the current development phase, the priority is to fix the blocking usability bugs (scrolling, focus, performance). The word-wrap numbering issue will be deferred to a future cycle dedicated to advanced component architecture.

## 3. The Strategy

### 3.1. Test Harness Implementation
The main `parallel-copilot.view/view.tsx` component will be refactored to include a new "Test Harness" mode.
-   A new state, `activeTestView`, will control which view is active: `'Original'`, `'TestA'`, `'TestB'`, or `'TestC'`.
-   A simple tab bar UI will be added to switch between these views.
-   The "Original" view will render the current, fully-featured PCPP layout.
-   The other views will render the isolated test components.

### 3.2. Isolated Test Components
Three new test components will be created to isolate and test specific variables.

-   **Test A (`TestPane1.tsx`): Synchronized Scrolling**
    -   **Hypothesis:** The scrolling is failing because the `onScroll` event is not being correctly used to synchronize the `scrollTop` of the line number gutter and the text area.
    -   **Implementation:** This component will feature a barebones `textarea` next to a `div` for line numbers. It will implement a robust `onScroll` handler that programmatically sets the `scrollTop` of the line number gutter, with extensive logging to confirm the event is firing and the values are changing.

-   **Test B (`TestPane2.tsx`): Pixel-Perfect Alignment**
    -   **Hypothesis:** The cursor and selection are misaligned due to subtle differences in CSS properties (`font-family`, `font-size`, `line-height`, `padding`, `box-sizing`) between the transparent `textarea` and the underlying `div` that displays the highlighted text.
    -   **Implementation:** This component will implement the overlay approach. It will meticulously ensure that every single font and box-model CSS property is identical across both elements. It will contain no complex logic, only the minimal structure needed to test for visual alignment.

-   **Test C (`TestPane3.tsx`): Combined & Cleaned Solution**
    -   **Hypothesis:** A clean implementation combining the lessons from Test A and Test B will provide a fully functional component.
    -   **Implementation:** This component will integrate the synchronized scrolling from Test A with the pixel-perfect styling from Test B into a new, clean version of the `NumberedTextarea` component, free from any other complex logic from the main view.

## 4. Cleanup Process
Once a working pattern is identified in a test component:
1.  **Codify Findings:** The successful pattern and the root cause of the failure will be documented in `A11. DCE - Regression Case Studies`.
2.  **Integrate Solution:** The original `NumberedTextarea.tsx` component will be refactored to use the successful pattern.
3.  **Remove Test Artifacts:** The test harness UI and the `TestPane*.tsx` component files will be removed from the project.
</file_artifact>

<file path="src/Artifacts/A77. DCE - Monaco Editor Replacement Plan.md">
# Artifact A77: DCE - Monaco Editor Replacement Plan
# Date Created: C182
# Author: AI Model & Curator
# Updated on: C183 (Reflect correct implementation with prism-react-renderer)

- **Key/Value for A0:**
- **Description:** Documents the failure of the Monaco Editor integration and the new plan to switch to a lighter-weight, non-worker-based editor component.
- **Tags:** plan, refactor, ui, ux, monaco, codemirror, technical debt, react-simple-code-editor, prism-react-renderer

## 1. Problem Statement

The attempt to integrate the Monaco Editor (`@monaco-editor/react`) into the Parallel Co-Pilot Panel's context panes (Cycles C179-C182) was a failure. Despite multiple attempts to configure the Webpack plugin and adjust the Content Security Policy (CSP), the editor component remained stuck in a perpetual "Loading..." state.

-   **Symptom:** The "Cycle Context" and "Ephemeral Context" panes displayed a "Loading..." message and were completely non-functional.
-   **Root Cause Analysis (RCA):** The Monaco Editor is a complex component that relies heavily on web workers for its performance and features. The VS Code webview environment has a strict security model (CSP) that makes the setup and bundling of these web workers exceptionally difficult. The "Loading..." state was a direct result of the webview blocking the editor's worker scripts from loading, even with a relaxed CSP. This indicates a fundamental incompatibility between the editor's architecture and the webview's security constraints.

## 2. The Pivot: Prioritizing Stability and Simplicity

A feature-rich but non-functional editor is useless. The new strategy is to pivot away from complex, worker-based editors like Monaco (and likely CodeMirror, which would face similar issues) and adopt a more lightweight and reliable solution that is known to work well within restricted environments.

The new chosen stack is:
1.  **`react-simple-code-editor`**: A very lightweight library that provides the core functionality of a code editor (maintaining indentation, etc.) using a simple `<textarea>` and a `<pre>` overlay. It does not use web workers, completely avoiding the CSP issues.
2.  **`prism-react-renderer`**: A popular, React-focused wrapper around `prismjs`. It provides high-quality syntax highlighting and is designed to be integrated with components like `react-simple-code-editor`.

## 3. Technical Implementation Plan (C183)

1.  **Dependencies (`package.json`):**
    *   **Remove:** `@monaco-editor/react`, `monaco-editor-webpack-plugin`.
    *   **Add:** `react-simple-code-editor`, `prism-react-renderer`, `prismjs`, and `@types/prismjs`.

2.  **Build Configuration (`webpack.config.js`):**
    *   Remove the `MonacoWebpackPlugin` entirely.

3.  **CSP Reversion (`common/utils/view-html.ts`):**
    *   Revert the Content Security Policy to a stricter version, as `worker-src 'blob:'` is no longer needed.

4.  **Component Implementation (`ContextInputs.tsx`):**
    *   The `<Editor>` component from `@monaco-editor/react` will be replaced with the `<Editor>` component from `react-simple-code-editor`.
    *   The `highlight` prop of the new editor will be wired to a function that uses the `<Highlight>` component from `prism-react-renderer`. This is the correct pattern for combining these two libraries.
    *   The component will be configured to use a standard theme (e.g., `themes.vsDark`) and the `markdown` language grammar.

This approach provides the desired Markdown syntax highlighting in a stable, performant, and lightweight component that is compatible with the VS Code webview's security model.
</file_artifact>

<file path="src/Artifacts/A78. DCE - VSIX Packaging and FTV Flashing Bug.md">
# Artifact A78: DCE - VSIX Packaging and FTV Flashing Bug
# Date Created: C183
# Author: AI Model & Curator

- **Key/Value for A0:**
- **Description:** Documents the root cause and solution for the bloated VSIX package and the persistent File Tree View flashing bug in the packaged extension.
- **Tags:** bug fix, packaging, vsix, vscodeignore, file watcher, git

## 1. Overview

This document addresses two critical issues identified during the packaging and testing of the DCE extension in Cycle 183:
1.  The final `.vsix` extension file is excessively large due to the inclusion of unnecessary development files.
2.  The File Tree View (FTV) exhibits a rapid "flashing" or refresh storm in the packaged version, which does not occur in the Extension Development Host.

## 2. Problem 1: Bloated VSIX Package

-   **Symptom:** The generated `.vsix` file is over 80MB and contains numerous files and directories that are not required for the extension to run, such as `prompt.md`, `flattened_repo.md`, the `The-Creator-AI-main/` reference directory, and the project's own `.vscode/` settings.
-   **Root Cause Analysis (RCA):** The `.vscodeignore` file, which instructs the `vsce` packaging tool which files to exclude, was incomplete. By default, `vsce` includes all files not explicitly ignored or listed in `.gitignore`.
-   **Codified Solution:** The `.vscodeignore` file must be updated to include patterns for all development-time artifacts, large output files, and source code that is not needed at runtime. This ensures a lean, efficient package.

### Proposed `.vscodeignore` additions:
```
# Development and output files
prompt.md
flattened_repo.md
log-state-logs.md
bootstrap-flattener.js

# Reference directories
The-Creator-AI-main/

# Project-specific VSCode settings
.vscode/

# Source maps and source code (already compiled to dist/)
**/*.map
**/*.ts
**/*.tsx
```

## 3. Problem 2: FTV Flashing in Packaged Extension

-   **Symptom:** The FTV continuously refreshes, making it unusable. Console logs show a storm of `[triggerFullRefresh] Called because: git state change` events.
-   **Root Cause Analysis (RCA):** The refresh storm is caused by an overly sensitive event listener combined with file system activity. The listener for `repo.state.onDidChange` in `file-tree.service.ts` is the primary culprit. This event fires for almost any change detected by the Git extension, including changes to build artifacts in the `dist/` directory or internal Git state files. In the packaged extension, the file layout and timing differ from the dev host, likely exposing this sensitivity more acutely. The file system watcher may also be contributing by picking up changes that slip past the exclusion patterns.
-   **Codified Solution & Best Practice:**
    1.  **Diagnose with Aggressive Logging:** The immediate solution is to inject high-visibility logging into `file-tree.service.ts` to pinpoint the exact trigger.
        *   Add a log inside the `repo.state.onDidChange` listener to confirm its firing frequency.
        *   Add a log at the very beginning of the `onFileChange` handler to see every single file path the watcher detects, before any exclusion logic is applied.
    2.  **Strengthen Exclusions:** The exclusion logic in `file-tree.service.ts` must be made more robust to explicitly ignore build artifacts and internal state files under all conditions.
    3.  **Dampen Event Listener:** The `repo.state.onDidChange` listener should be heavily debounced via the `triggerFullRefresh` function to prevent a storm of events from causing a storm of UI updates. A longer-term solution would be to find a more specific Git API event to listen to, if one exists.
</file_artifact>

<file path="src/Artifacts/A78. DCE - Whitepaper - Process as Asset.md">
# Artifact A78: DCE - Whitepaper - Process as Asset

# Date Created: C182

# Author: AI Model & Curator

  - **Key/Value for A0:**
  - **Description:** A whitepaper targeted at high-level stakeholders (NSA, UKILRN) explaining the strategic value of the DCE by focusing on how it transforms the human-AI interaction process into a persistent, shareable asset that accelerates specialized content creation.
  - **Tags:** whitepaper, documentation, strategy, process, acceleration, human-ai collaboration

-----

# Process as Asset: Accelerating Specialized Content Creation through Structured Human-AI Collaboration

**A Whitepaper on the Data Curation Environment (DCE)**

**Date:** September 4, 2025
**Audience:** High-Level Stakeholders (NSA, UKILRN, Naval Operations)

-----

## 1\. Executive Summary

Organizations tasked with developing highly specialized content—such as technical training materials, intelligence reports, or complex software documentation—face a constant bottleneck: the time and expertise required to curate accurate data, collaborate effectively, and rapidly iterate on feedback. Traditional workflows, even those augmented by Artificial Intelligence (AI), are often ad-hoc, opaque, and inefficient.

This whitepaper introduces the Data Curation Environment (DCE), a framework and toolset integrated into the standard developer environment (Visual Studio Code) that transforms the content creation process itself into a valuable organizational asset. The DCE provides a structured, human-in-the-loop methodology that enables rapid dataset curation, seamless sharing of curated contexts between colleagues, and instant iteration on feedback.

By capturing the entire workflow as a persistent, auditable knowledge graph, the DCE doesn't just help teams build content faster; it provides the infrastructure necessary to scale expertise, ensure quality, and accelerate the entire organizational mission.

## 2\. The Challenge: The Bottleneck of Ad-Hoc AI Interaction

The integration of Large Language Models (LLMs) into organizational workflows promises significant acceleration. However, the way most organizations interact with these models remains unstructured and inefficient, creating several critical bottlenecks:

1.  **The Context Problem:** The quality of an LLM's output is entirely dependent on the quality of its input context. Manually selecting, copying, and pasting relevant data (code, documents, reports) into a chat interface is time-consuming, error-prone, and often results in incomplete or bloated context.
2.  **The Collaboration Gap:** When a task is handed off, the context is lost. A colleague must manually reconstruct the previous operator's dataset and understand their intent, leading to significant delays and duplication of effort.
3.  **The Iteration Overhead:** When feedback requires changes to a complex dataset, operators often resort to manual edits because re-prompting the AI requires reconstructing the entire context again. This negates the efficiency gains of using AI in the first place.
4.  **The Auditability Vacuum:** The iterative process of human-AI interaction—the prompts, the AI's suggestions, and the human's decisions—is a valuable record of the work, yet it is rarely captured in a structured, reusable format.

These challenges prevent organizations from fully realizing the potential of AI. They are forced to choose between the speed of AI and the rigor of a structured process.

## 3\. The Solution: The Data Curation Environment (DCE)

The Data Curation Environment (DCE) is designed to eliminate these bottlenecks by providing a structured framework for human-AI collaboration directly within the operator's working environment. It moves beyond the limitations of simple chat interfaces by introducing three core capabilities:

### 3.1. Precision Context Curation

The DCE replaces manual copy-pasting with an intuitive, integrated file management interface. Operators can precisely select the exact files, folders, or documents required for a task with simple checkboxes. The DCE intelligently handles various file types—including code, PDFs, Word documents, and Excel spreadsheets—extracting the relevant textual content automatically.

This ensures that the AI receives the highest fidelity context possible, maximizing the quality of its output while minimizing operator effort.

### 3.2. Parallel AI Scrutiny and Integrated Testing

The DCE recognizes that relying on a single AI response is risky. The "Parallel Co-Pilot Panel" allows operators to manage, compare, and test multiple AI-generated solutions simultaneously.

Integrated diffing tools provide immediate visualization of proposed changes. Crucially, the DCE offers a one-click "Accept" mechanism, integrated with Git version control, allowing operators to instantly apply an AI's suggestion to the live workspace, test it, and revert it if necessary. This creates a rapid, low-risk loop for evaluating multiple AI approaches.

### 3.3. The Cycle Navigator and Persistent Knowledge Graph

Every interaction within the DCE is captured as a "Cycle." A cycle includes the curated context, the operator's instructions, all AI-generated responses, and the operator's final decision. This history is saved as a structured, persistent Knowledge Graph.

The "Cycle Navigator" allows operators to step back through the history, review past decisions, and understand the evolution of the project.

## 4\. Transforming the Process into an Asset

The true power of the DCE lies in how these capabilities combine to transform the workflow itself into a persistent organizational asset.

### 4.1. The Curated Context as a Shareable Asset

In the DCE workflow, the curated context (the "Selection Set") is not ephemeral; it is a saved, versioned asset. When a task is handed off, the new operator doesn't just receive the files; they receive the exact context and the complete history of the previous operator's interactions.

This seamless handoff eliminates the "collaboration gap," allowing teams to work asynchronously and efficiently on complex datasets without duplication of effort.

### 4.2. Accelerating Iteration and Maintenance

The DCE dramatically reduces the overhead associated with feedback and maintenance. Because the context is already curated and saved, operators can rapidly iterate on complex datasets without manual reconstruction.

If feedback requires changes, the operator simply loads the curated context and issues a targeted instruction to the AI. The AI performs the edits against the precise context, completing the update in a single, efficient cycle. This enables organizations to maintain complex systems and content with unprecedented speed.

### 4.3. Scaling Expertise and Ensuring Auditability

The Knowledge Graph generated by the DCE serves as a detailed, auditable record of the entire development process. This is invaluable for:

  * **Training and Onboarding:** New personnel can review the cycle history to understand complex decision-making processes and best practices.
  * **After-Action Reviews:** The graph provides a precise record of what was known, what was instructed, and how the AI responded, enabling rigorous analysis.
  * **Accountability:** In mission-critical environments, the DCE provides a transparent and traceable record of human-AI interaction.

## 5\. Use Case Spotlight: Rapid Development of Training Materials

A government agency needs to rapidly update a specialized technical training lab based on new operational feedback. The feedback indicates that in the existing exam questions, "the correct answer is too often the longest answer choice," creating a pattern that undermines the assessment's validity.

### The Traditional Workflow (Weeks)

1.  **Identify Affected Files:** An analyst manually searches the repository to find all relevant question files (days).
2.  **Manual Editing:** The analyst manually edits each file, attempting to rewrite the "distractor" answers to be longer and more plausible without changing the technical meaning (weeks).
3.  **Review and Rework:** The changes are reviewed, often leading to further manual edits (days).

### The DCE Workflow (Hours)

1.  **Curate Context (Minutes):** The analyst uses the DCE interface to quickly select the folder containing all exam questions. This creates a precise, curated dataset.
2.  **Instruct the AI (Minutes):** The analyst loads the curated context into the Parallel Co-Pilot Panel and provides a targeted instruction: "Review the following exam questions. For any question where the correct answer is significantly longer than the distractors, rewrite the distractors to include more meaningful but ultimately fluffy language to camouflage the length difference, without changing the technical accuracy."
3.  **Review and Accept (Hours):** The AI generates several proposed solutions. The analyst uses the integrated diff viewer to compare the options. They select the best solution and "Accept" the changes with a single click.
4.  **Verification:** The updated lab is immediately ready for final verification.

## 6\. Conclusion

The Data Curation Environment is more than just a developer tool; it is a strategic framework for operationalizing AI in complex environments. By addressing the critical bottlenecks of context curation, collaboration, and iteration, the DCE transforms the human-AI interaction workflow into a structured, persistent, and valuable organizational asset.

For organizations facing an ever-increasing list of priorities and a need to accelerate the development of specialized content, the DCE provides the necessary infrastructure to scale expertise, ensure quality, and achieve the mission faster.
</file_artifact>

<file path="src/Artifacts/A79. DCE - Autosave and Navigation Locking Plan.md">
# Artifact A79: DCE - Autosave and Navigation Locking Plan
# Date Created: C7
# Author: AI Model & Curator

- **Key/Value for A0:**
- **Description:** Outlines the plan to fix the cycle data loss bug by implementing a UI-driven autosave status indicator and locking navigation controls while there are unsaved changes.
- **Tags:** bug fix, data integrity, race condition, autosave, ui, ux

## 1. Overview & Goal

A critical data loss bug has been observed where navigating between cycles in the Parallel Co-Pilot Panel can cause data from one cycle to overwrite another. This is caused by a race condition between the debounced auto-save of the departing cycle and the loading of the new cycle's state.

The goal is to implement a definitive fix by creating a clear and robust user experience that prevents this race condition from occurring. This will be achieved by making the user aware of the save state and preventing navigation until all changes are safely persisted.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| BUG-01 | **Prevent Data Loss** | As a user, when I quickly navigate between cycles, I want to be confident that my data from the previous cycle is saved before the new cycle loads, so no data is ever lost or corrupted. | - Navigating away from a cycle with unsaved changes is prevented until the save operation is complete. |
| UX-01 | **See Save Status** | As a user, I want to see a clear visual indicator of the current save status (e.g., "Unsaved changes," "Saving...," "Saved"), so I understand the state of my work. | - An icon or text is displayed near the cycle navigator. <br> - It updates in real-time to reflect the save status. |
| UX-02 | **Locked Navigation** | As a user, when I have unsaved changes, I want the cycle navigation buttons to be temporarily disabled, so I have a clear visual cue that I cannot change cycles until my work is saved. | - The "Next" (`>`), "Previous" (`<`), and "New" (`+`) cycle buttons are disabled when the save status is "unsaved" or "saving." <br> - The buttons become enabled once the status returns to "saved." |

## 3. Technical Implementation Plan

1.  **New State Management (`view.tsx`):**
    *   Introduce a new state variable to track the save status: `const [saveStatus, setSaveStatus] = useState<'saved' | 'saving' | 'unsaved'>('saved');`
    *   All `onChange` handlers for data that is persisted per-cycle (title, contexts, response tabs) will be updated to immediately call `setSaveStatus('unsaved')`.

2.  **Refactor Autosave Logic:**
    *   **IPC:** A new `ServerToClientChannel.NotifySaveComplete` channel will be created. The payload will be `{ cycleId: number }`.
    *   **Backend (`history.service.ts`):** The `saveCycleData` method will, after successfully writing the file, send the `NotifySaveComplete` message back to the client with the ID of the cycle that was just saved.
    *   **Frontend (`view.tsx`):**
        *   The existing debounced `saveCurrentCycleState` function will be modified.
        *   When triggered, it will first call `setSaveStatus('saving')`.
        *   It will then send the `SaveCycleData` message to the backend as it does now.
        *   A new message handler will be added to listen for `NotifySaveComplete`. When it receives confirmation for the *currently viewed cycle*, it will call `setSaveStatus('saved')`.

3.  **Update UI Components:**
    *   **`CycleNavigator.tsx`:**
        *   This component will receive `saveStatus` as a prop.
        *   The `disabled` attribute of the `<`, `>`, and `+` buttons will be set to `saveStatus !== 'saved'`.
    *   **`view.tsx` & `view.scss`:**
        *   A new component or set of icons will be rendered near the cycle navigator to display the current `saveStatus`. For example:
            *   `'unsaved'`: A yellow dot with the tooltip "Unsaved changes".
            *   `'saving'`: A spinning icon with the tooltip "Saving...".
            *   `'saved'`: A green checkmark with the tooltip "Saved".

4.  **Update Navigation Logic (`view.tsx`):**
    *   The `handleCycleChange` function will be simplified. Since the navigation buttons are disabled when there are unsaved changes, it no longer needs to trigger a save itself. Its only job is to request the data for the new cycle.
</file_artifact>

<file path="src/Artifacts/A80. DCE - Settings Panel Plan.md">
# Artifact A80: DCE - Settings Panel Plan
# Date Created: C6
# Author: AI Model & Curator
# Updated on: C17 (Reflect removal of Context Chooser icon)

- **Key/Value for A0:**
- **Description:** A plan for a new settings panel, accessible via a command, to house changelogs, settings, and other informational content.
- **Tags:** feature plan, settings, ui, ux, changelog

## 1. Overview & Goal

As the Data Curation Environment (DCE) grows in features, users will need a centralized location to manage settings, view changelogs, and access help documentation. The goal of this feature is to create a dedicated "Settings & Help" panel that serves as this central hub.

**Status (C17):** Implemented. The panel is now functional and opens as a `WebviewPanel` in the main editor area. The entry point icon from the Context Chooser view has been removed, and the panel is now accessed via the `DCE: Open Settings & Help` command.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| P2-SET-01 | **Access Help and Settings** | As a user, I want to execute a command to open a dedicated panel, so I can access settings and information about the extension. | - A command `DCE: Open Settings & Help` is available in the command palette. <br> - Executing it opens a new `WebviewPanel` in the main editor area, titled "DCE Settings & Help". |
| P2-SET-02 | **View Changelog** | As a user, I want to view a changelog within the settings panel, so I can see what has changed in the latest version of the extension. | - The settings panel has a "Changelog" tab or collapsible section. <br> - This section displays the content of a `CHANGELOG.md` file from the workspace root, rendered as formatted Markdown. |
| P2-SET-03 | **View About/README** | As a user, I want to view an "About" page that explains the purpose and workflow of the DCE, so I can get help on how to use it. | - The settings panel has an "About" tab or collapsible section. <br> - This section displays the content of the `README.md` file from the workspace root. |
| P2-SET-04 | **Manage Settings** | As a user, I want to manage extension settings from this panel, so I can configure features to my preference. | - The settings panel has a "Settings" section. <br> - It provides UI controls for managing settings, such as a field for a local API URL and a toggle for "Free Mode" vs. "Local Mode". |

## 3. Technical Implementation Plan

1.  **Command Registration:**
    *   **`package.json`:** The `view/title` menu contribution for the `viewType.sidebar.contextChooser` has been removed. A new command `dce.openSettingsPanel` is registered for the command palette.
    *   **`commands.ts`:** The command executes an internal `dce.showSettingsPanel` command.
    *   **`extension.ts`:** The handler for `dce.showSettingsPanel` creates and manages a singleton `WebviewPanel`.

2.  **New Settings Webview (`settings.view/`):**
    *   `view.tsx` renders a UI with collapsible sections for "Changelog", "About", and "Settings".
    *   On mount, it sends IPC messages to the backend to request the content for the `CHANGELOG.md` and `README.md` files.
    *   The "Settings" section contains placeholder UI elements for future functionality.

3.  **Backend Logic (`file-operation.service.ts`):**
    *   The `handleChangelogContentRequest` and `handleReadmeContentRequest` methods read the respective files from the workspace root and send their content back to the settings webview.
    *   **IPC:** The existing channels (`RequestChangelogContent`, `SendChangelogContent`, etc.) facilitate this communication.
</file_artifact>

<file path="src/Artifacts/A81. DCE - Curator Activity Plan.md">
# Artifact A81: DCE - Curator Activity Plan
# Date Created: C6
# Author: AI Model & Curator

- **Key/Value for A0:**
- **Description:** A plan to introduce a new `<curator_activity>` section to the AI response format, allowing for explicit instructions to the human curator.
- **Tags:** documentation, process, interaction schema, workflow

## 1. Overview & Goal

Currently, if the AI needs the human curator to perform an action it cannot (e.g., delete a file, install a dependency), it must embed this instruction within the "Course of Action" or summary. This can be missed and is not machine-parsable.

The goal of this feature is to create a formal, dedicated channel for these instructions. A new `<curator_activity>...</curator_activity>` section will be added to the interaction schema. The extension will parse this section and display it in a distinct, highly visible area of the UI, ensuring the curator sees and can act upon these critical instructions.

## 2. User Story

| ID | User Story | Acceptance Criteria |
|---|---|---|
| P2-CA-01 | **Receive Curator Instructions** | As a curator, when an AI response includes actions I need to perform manually, I want to see them clearly separated from the AI's own course of action, so I don't miss them. | - The AI can include a `<curator_activity>` block in its response. <br> - The PCPP parser extracts the content of this block. <br> - The UI displays this content in a new, clearly labeled "Curator Activity" collapsible section. |

## 3. Technical Implementation Plan

1.  **Update Interaction Schema:**
    *   **`A52.2 DCE - Interaction Schema Source.md`:** A new rule will be added, defining the `<curator_activity>...</curator_activity>` section and explaining its purpose to the AI.

2.  **Update Parser (`response-parser.ts`):**
    *   A new `CURATOR_ACTIVITY_REGEX` will be added to extract the content from the new tags.
    *   The `ParsedResponse` interface in `pcpp.types.ts` will be updated with a new optional property, `curatorActivity?: string`.

3.  **Update UI (`ParsedView.tsx`):**
    *   A new `CollapsibleSection` will be added to the parsed view.
    *   It will be titled "Curator Activity".
    *   It will be conditionally rendered only if `parsedContent.curatorActivity` exists and is not empty.
    *   The content will be rendered as formatted Markdown.
</file_artifact>

<file path="src/Artifacts/A82. DCE - Advanced Exclusion Management Plan.md">
# Artifact A82: DCE - Advanced Exclusion Management Plan
# Date Created: C6
# Author: AI Model & Curator

- **Key/Value for A0:**
- **Description:** A plan for a feature allowing users to right-click files or folders and add them to a persistent exclusion list, preventing them from being automatically selected or flattened.
- **Tags:** feature plan, context menu, exclusion, ignore, ux

## 1. Overview & Goal

Users need a simple, intuitive way to manage which files are included in the Data Curation Environment's view and processes. While some files are excluded by default (e.g., `.git`), users may have project-specific directories (like `dist`, `build`, or custom log folders) that they want to permanently ignore.

The goal of this feature is to allow users to right-click any file or folder in the main file tree and add it to a persistent exclusion list, which will be stored in the workspace's settings.

## 2. User Story

| ID | User Story | Acceptance Criteria |
|---|---|---|
| P1-EX-01 | **Exclude from View** | As a developer, I want to right-click a build output directory (e.g., `dist`) and select "Add to DCE Exclusions", so it no longer appears in the Data Curation file tree and is never included in flattened contexts. | - A new "Add to DCE Exclusions" option is available in the file tree's right-click context menu. <br> - Selecting this option adds the file or folder's path to a custom setting in `.vscode/settings.json`. <br> - The file tree immediately refreshes and the excluded item (and its children) is no longer visible. |

## 3. Technical Implementation Plan

1.  **Configuration (`package.json`):**
    *   A new configuration point will be defined in the `contributes.configuration` section.
    *   This will create a new setting, `dce.files.exclude`, which will be an object similar to the native `files.exclude`.

2.  **Backend (`file-tree.service.ts`):**
    *   The file traversal logic will be updated to read this new `dce.files.exclude` setting from the workspace configuration.
    *   It will merge these user-defined patterns with the default exclusion patterns before scanning the file system.

3.  **UI & IPC:**
    *   **`ContextMenu.tsx`:** A new menu item, "Add to DCE Exclusions," will be added.
    *   **IPC:** A new IPC channel, `RequestAddToExclusions`, will be created.
    *   **Backend Handler (`settings.service.ts` - new or existing):** A new handler will receive the path to exclude. It will:
        1.  Get the current exclusion configuration object using `vscode.workspace.getConfiguration('dce')`.
        2.  Add the new path to the object (`newExclusion[path] = true`).
        3.  Update the configuration using `config.update('files.exclude', newExclusion, vscode.ConfigurationTarget.Workspace)`.
        4.  This will automatically trigger a refresh of the file tree as the configuration has changed.

This approach leverages VS Code's built-in settings infrastructure, making the exclusions persistent and easily manageable for the user.
</file_artifact>

<file path="src/Artifacts/A83. DCE - Universal Task Checklist for Cycle 6.md">
# Artifact A83: DCE - Universal Task Checklist for Cycle 6
# Date Created: C6
# Author: AI Model & Curator
# Updated on: C9 (Finalize T-3 and add T-4)

- **Key/Value for A0:**
- **Description:** A structured checklist for organizing the development tasks, feedback, and bugs from the "laundry list" provided in Cycle 6.
- **Tags:** process, checklist, task management, planning, workflow

## 1. Purpose

This artifact provides a structured, universal format for tracking the development tasks derived from the "laundry list" of feedback in Cycle 6. It organizes work by logical feature areas and the group of files involved.

---

## Task List

## T-1: Parsing & Interaction Schema
- **Files Involved:**
    - `src/Artifacts/A52.2 DCE - Interaction Schema Source.md`
    - `src/Artifacts/A81. DCE - Curator Activity Plan.md`
    - `src/client/utils/response-parser.ts`
    - `src/common/types/pcpp.types.ts`
    - `src/client/views/parallel-copilot.view/components/ParsedView.tsx`
- **Total Tokens:** ~6,000
- **More than one cycle?** No
- **Status:** Completed in C7

- [X] **Task (T-ID: 1.1):** Create `A81` to plan the new `<curator_activity>` section.
- [X] **Task (T-ID: 1.2):** Update `A52.2` to be more explicit about the `</file_artifact>` closing tag and to include the new `curator_activity` section.
- [X] **Task (T-ID: 1.3):** Update the parser to extract the `<curator_activity>` section and to de-duplicate the `files` array, keeping the last occurrence of a path.
- [X] **Task (T-ID: 1.4):** Update the UI to render the new `curatorActivity` content in its own collapsible section.

### Verification Steps
1.  Provide a response with duplicate file paths and a `<curator_activity>` section.
2.  Click "Parse All".
3.  **Expected:** The file counter on the response tab should reflect the unique file count. The "Curator Activity" section should appear with the correct content.

## T-2: Data Integrity & Core UX
- **Files Involved:**
    - `src/Artifacts/A79. DCE - Autosave and Navigation Locking Plan.md`
    - `src/client/views/parallel-copilot.view/view.tsx`
    - `src/client/views/parallel-copilot.view/components/CycleNavigator.tsx`
    - `src/backend/services/history.service.ts`
    - `src/common/ipc/channels.enum.ts`
    - `src/common/ipc/channels.type.ts`
- **Total Tokens:** ~12,000
- **More than one cycle?** No
- **Status:** Completed in C8

- [X] **Task (T-ID: 2.1):** Implement the autosave locking feature from `A79`. Add `saveStatus` state to `view.tsx`.
- [X] **Task (T-ID: 2.2):** Add `NotifySaveComplete` IPC channel and have `history.service.ts` send it after a successful write.
- [X] **Task (T-ID: 2.3):** Disable navigation buttons in `CycleNavigator.tsx` when `saveStatus` is not `'saved'`.
- [X] **Task (T-ID: 2.4):** Implement auto-tabbing on paste in `view.tsx`.
- [X] **Task (T-ID: 2.5):** Add `tsconfig.tsbuildinfo` and `dist` to `NON_SELECTABLE_PATTERNS` in `file-tree.service.ts`.

### Verification Steps
1.  Type text into the Cycle Context.
2.  **Expected:** The save status indicator should show "unsaved" and the cycle navigation buttons should be disabled.
3.  Wait for the autosave to complete.
4.  **Expected:** The status should become "saved" and the buttons should be re-enabled.
5.  Paste content into `Resp 1` textarea.
6.  **Expected:** The UI should automatically switch focus to the `Resp 2` tab.

## T-3: Advanced UX Features
- **Files Involved:**
    - `src/client/views/parallel-copilot.view/components/ParsedView.tsx`
    - `src/client/views/parallel-copilot.view/view.scss`
    - `src/common/utils/formatting.ts`
- **Total Tokens:** ~5,000
- **More than one cycle?** No
- **Status:** Completed in C9

- [X] **Task (T-ID: 3.1):** Implement a color gradient on "Associated Files" list items based on similarity score.
- [X] **Task (T-ID: 3.2):** Display the similarity score as a percentage and truncate long file paths.
- [X] **Task (T-ID: 3.3):** Add a right-click context menu to "Associated Files" list items to copy the relative path.

### Verification Steps
1.  Parse a response with varying similarity scores and a very long file path.
2.  **Expected:** The file list items should have background colors ranging from green (high similarity) to red (low similarity). A percentage value (e.g., "98%") should be visible. The long file path should be truncated in the middle. Hovering over it shows the full path.
3.  Right-click a file in the list.
4.  **Expected:** A context menu should appear with a "Copy Relative Path" option. Clicking it should copy the path to the clipboard.

## T-4: Plan Next Development Phase
- **Files Involved:**
    - `src/Artifacts/A84. DCE - Universal Task Checklist for Cycle 10+.md`
- **Total Tokens:** ~1,500
- **More than one cycle?** Yes (Implementation is deferred)
- **Status:** In Progress

- [X] **Task (T-ID: 4.1):** Create `A84` to plan the next phase of development, focusing on high-priority features from the existing backlog to achieve feature parity with the native VS Code explorer.

### Verification Steps
1.  Check the master artifacts list.
2.  **Expected:** The new `A84` artifact should be present and contain the feature plans for the next cycle.
</file_artifact>

<file path="src/Artifacts/A84. DCE - Universal Task Checklist for Cycle 10+.md">
# Artifact A84: DCE - Universal Task Checklist for Cycle 10+
# Date Created: C9
# Author: AI Model & Curator

- **Key/Value for A0:**
- **Description:** A structured checklist for organizing the next phase of development tasks, focusing on feature parity with the native VS Code explorer.
- **Tags:** process, checklist, task management, planning, workflow

## 1. Purpose

This artifact provides a structured, universal format for tracking the next phase of development tasks, feedback, and bugs. The primary goal of this phase is to achieve greater feature parity with the native VS Code Explorer, focusing on core file operations and interactions that users expect.

---

## Task List

## T-1: Undo/Redo File Operations
- **Files Involved:**
    - `src/Artifacts/A27. DCE - Phase 1 - Undo-Redo Feature Plan.md`
    - `src/backend/services/action.service.ts`
    - `src/backend/services/file-operation.service.ts`
    - `src/client/components/tree-view/TreeView.tsx`
- **Total Tokens:** ~8,000
- **More than one cycle?** No

- [X] **Task (T-ID: 1.1):** Implement the `ActionService` to manage undo/redo stacks.
- [X] **Task (T-ID: 1.2):** Integrate `ActionService` with `FileOperationService` to push move/delete actions onto the stack.
- [-] **Task (T-ID: 1.3):** Implement `Ctrl+Z` / `Ctrl+Y` keyboard shortcuts in `TreeView.tsx` to trigger undo/redo.

### Verification Steps
1.  Drag and drop a file to move it.
2.  Press `Ctrl+Z`.
3.  **Expected:** The file moves back to its original location.
4.  Press `Ctrl+Y`.
5.  **Expected:** The file moves back to the new location.

## T-2: Copy/Paste File Operations
- **Files Involved:**
    - `src/Artifacts/A33. DCE - Phase 1 - Copy-Paste Feature Plan.md`
    - `src/backend/services/file-operation.service.ts`
    - `src/client/components/tree-view/TreeView.tsx`
    - `src/client/views/context-chooser.view/view.tsx`
- **Total Tokens:** ~10,000
- **More than one cycle?** No

- [X] **Task (T-ID: 2.1):** Implement internal clipboard state in `view.tsx`.
- [X] **Task (T-ID: 2.2):** Implement `Ctrl+C` / `Ctrl+V` handlers in `TreeView.tsx`.
- [X] **Task (T-ID: 2.3):** Implement backend `handleCopyFileRequest` logic in `file-operation.service.ts`, including robust name collision handling.

### Verification Steps
1.  Focus a file and press `Ctrl+C`.
2.  Focus a directory and press `Ctrl+V`.
3.  **Expected:** A copy of the file appears in the directory.
4.  Press `Ctrl+V` again in the same directory.
5.  **Expected:** A second copy appears with a modified name (e.g., `file-copy.ts`).
</file_artifact>

<file path="src/Artifacts/A85. DCE - Model Card Feature Plan.md">
# Artifact A85: DCE - Model Card Feature Plan
# Date Created: C17
# Author: AI Model & Curator

- **Key/Value for A0:**
- **Description:** A plan for a feature that allows users to create and manage 'model cards' for different LLMs, containing settings like context window size and display name.
- **Tags:** feature plan, settings, llm, model management, configuration

## 1. Overview & Goal

As the DCE project evolves to support direct API integration with various Large Language Models (LLMs), users will need a way to manage the configurations for these different models. The current settings panel is designed for a single local API URL.

The goal of this feature is to expand the settings panel to support "Model Cards." A model card will be a saved configuration profile for a specific LLM, containing all the necessary information for the extension to interact with it and for the user to select it for a given task.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| P2-MC-01 | **Create a Model Card** | As a user, I want to create a new model card in the settings panel, so I can configure a new local or cloud-based LLM for the extension to use. | - The settings panel has a "Create New Model Card" button. <br> - Clicking it opens a form with fields for all required model information. |
| P2-MC-02 | **Configure Model Parameters** | As a user creating a model card, I want to specify key parameters like the model's display name, its API endpoint, and its context window size, so the extension can use it correctly. | - The model card form includes input fields for: <br> &nbsp;&nbsp;&nbsp; - Display Name (e.g., "My Local Llama3") <br> &nbsp;&nbsp;&nbsp; - API Endpoint URL <br> &nbsp;&nbsp;&nbsp; - Context Window Size (in tokens) <br> &nbsp;&nbsp;&nbsp; - (Future) API Key, if applicable. |
| P2-MC-03 | **Default "AI Studio" Model** | As a user, I want a default, pre-configured model card labeled "AI Studio" that represents the free, manual copy/paste workflow, so I can easily switch back to it. | - The extension comes with a non-editable, default model card for "AI Studio". <br> - This card has no API endpoint and signifies the manual workflow. |
| P2-MC-04 | **Select Active Model** | As a user, I want to be able to select one of my configured model cards as the "active" model, so the extension knows which LLM to interact with. | - The settings panel displays a list of all saved model cards. <br> - A mechanism (e.g., radio buttons) allows me to select one as the active model. |

## 3. High-Level Technical Plan

-   **Data Storage:** Model card configurations will be stored in the global `settings.json` file under a new `dce.modelCards` configuration key.
-   **UI:** The `settings.view.tsx` component will be significantly refactored to include a list view for existing model cards and a form for creating/editing them.
-   **Backend:** A new `SettingsService` (or an expanded existing service) will manage reading and writing these configurations using the `vscode.workspace.getConfiguration` API.
</file_artifact>

<file path="src/Artifacts/A85. DCE - Model Card Management Plan.md">
# Artifact A85: DCE - Model Card Management Plan
# Date Created: C18
# Author: AI Model & Curator

- **Key/Value for A0:**
- **Description:** A plan for an enhanced settings panel where users can create and manage "model cards" to easily switch between different LLM providers and configurations.
- **Tags:** feature plan, settings, ui, ux, llm, configuration, model management

## 1. Overview & Goal

As the DCE project moves towards direct API integration (Phase 3), users will need a flexible way to manage configurations for different Large Language Models (LLMs). The current placeholder for a single local API URL is insufficient.

The goal is to design an enhanced settings panel where users can create and manage "model cards." Each card will represent a specific LLM configuration, containing all the necessary information to interact with that model. This will allow users to easily switch between different models, such as a local model, various cloud providers, or different versions of the same model.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| P3-MC-01 | **Create a New Model Card** | As a user, I want to create a new "model card" in the settings panel, so I can configure the extension to use a new LLM. | - A "New Model Card" button exists in the settings panel. <br> - Clicking it opens a form with fields for Display Name, API Endpoint URL, API Key, Context Window Size, and other relevant parameters. <br> - The default "AI Studio" (Free) mode is presented as a non-editable, built-in card. |
| P3-MC-02 | **Save and Manage Cards** | As a user, I want to save my model cards and see a list of all my configured models, so I can manage my connections. | - Saved model cards are displayed in a list in the settings panel. <br> - I can select a card to view or edit its details. <br> - I can delete a card I no longer need. |
| P3-MC-03 | **Select Active Model** | As a user, I want to select one of my model cards as the "active" model, so the extension knows which LLM to use for its API calls. | - A mechanism (e.g., a radio button or a "Set as Active" button) allows me to designate one model card as the active one. <br> - The extension's backend uses the configuration from the active model card for all subsequent API calls. |

## 3. Proposed UI/UX

The "Settings" section of the settings panel will be redesigned.

1.  **Model Card List:**
    *   A list or grid on the left will display all saved model cards.
    *   The first item will be the default, non-editable "AI Studio (Free/Manual)" card.
    *   A "+" button will allow users to create a new card.
2.  **Configuration Form:**
    *   Selecting a card from the list (or creating a new one) will display its configuration form on the right.
    *   **Fields:**
        *   **Display Name:** (e.g., "My Local Llama3", "Claude Sonnet 3.5")
        *   **Provider Type:** (Dropdown: "Local URL", "OpenAI-Compatible", "Google Gemini", etc.)
        *   **API Endpoint URL:** The URL for the model's API.
        *   **API Key:** A field to securely input the API key.
        *   **Context Window Size (Tokens):** A number input, as some calculations may depend on this.
        *   **Other Parameters:** (Optional) Fields for temperature, top_p, etc.
3.  **Actions:**
    *   "Save" and "Delete" buttons will be present in the form view.
    *   A visual indicator (e.g., a star icon or a "✓ Active" badge) will show which card is currently active.
</file_artifact>

<file path="src/Artifacts/A85. DCE - Phase 2 - Model Card Management Plan.md">
# Artifact A85: DCE - Phase 2 - Model Card Management Plan
# Date Created: C17
# Author: AI Model & Curator

- **Key/Value for A0:**
- **Description:** A plan for a feature allowing users to create, manage, and select from multiple "model cards," each defining the configuration for a different LLM (e.g., local endpoint, context size).
- **Tags:** feature plan, phase 2, settings, llm, configuration, model management

## 1. Overview & Goal

As the DCE project moves towards direct API integration, users will need a flexible way to manage connections to different Large Language Models (LLMs). The current settings plan only accounts for a single local API URL. The goal of this feature is to replace that with a more robust "Model Card" system. This will allow users to create, save, and switch between multiple configurations for different models, whether they are hosted locally or are cloud-based APIs.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| P2-MC-01 | **Create a Model Card** | As a user, I want to create a new "Model Card" in the settings panel to define the configuration for an LLM I want to use. | - A "Create New Model Card" button exists in the settings panel. <br> - Clicking it opens a form with fields for: Display Name, API Endpoint URL, Context Window Size (in tokens), and potentially other model-specific parameters. <br> - Saving the form creates and persists a new model card. |
| P2-MC-02 | **Select Active Model** | As a user, I want to select one of my saved model cards as the active model for the extension, so that API calls are sent to the correct endpoint. | - The settings panel displays a list or dropdown of all saved model cards. <br> - I can select one model card as the "active" one. <br> - A default, non-deletable "AI Studio (Manual)" card will always be present. |
| P2-MC-03 | **Edit a Model Card** | As a user, I want to edit the details of a model card I previously created, so I can update an API endpoint or change its parameters. | - Each saved model card has an "Edit" button. <br> - Clicking it opens the same form used for creation, pre-filled with the card's current data. |
| P2-MC-04 | **Delete a Model Card** | As a user, I want to delete a model card I no longer need, so I can keep my configuration clean. | - Each saved model card has a "Delete" button. <br> - Deleting a card prompts for confirmation. |

## 3. Technical Implementation Plan

1.  **Data Structure (`pcpp.types.ts` or a new `settings.types.ts`):**
    *   Define a `ModelCard` interface:
        ```typescript
        interface ModelCard {
          id: string; // UUID
          displayName: string;
          apiEndpoint: string;
          contextWindowSize: number;
          // ... other potential fields like apiKeySecretName
        }
        ```
2.  **Backend (`settings.service.ts` - New or expanded):**
    *   A new service or an expansion of the existing history/selection service will be needed to manage model cards.
    *   It will use the VS Code `workspaceState` to store an array of `ModelCard` objects.
    *   It will expose methods for `getModelCards()`, `saveModelCard(card: ModelCard)`, `deleteModelCard(id: string)`, `getActiveModel()`, and `setActiveModel(id: string)`.

3.  **UI (`settings.view.tsx`):**
    *   The existing settings view will be overhauled.
    *   It will fetch and display a list of all saved model cards.
    *   It will include UI for selecting the active model (e.g., with radio buttons).
    *   It will have "Create New", "Edit", and "Delete" buttons that open a modal or a separate form view to manage the details of a `ModelCard`.

4.  **Integration with API-calling services:**
    *   Services that will eventually make API calls (like a future `LlmService`) will be designed to first query the `SettingsService` to get the active `ModelCard`.
    *   They will use the `apiEndpoint` and other parameters from the active card to construct their API requests. This decouples the calling logic from the specific model configuration.
</file_artifact>

<file path="src/Artifacts/A85. DCE - Phase 3 - Model Cards Feature Plan.md">
# Artifact A85: DCE - Phase 3 - Model Cards Feature Plan
# Date Created: C17
# Author: AI Model & Curator

- **Key/Value for A0:**
- **Description:** A plan for a feature allowing users to create and manage "model cards" to easily switch between different local or remote LLM configurations.
- **Tags:** feature plan, settings, ui, ux, llm, configuration, phase 3

## 1. Overview & Goal

As the DCE project moves towards deeper AI integration (Phase 3), users will need a flexible way to manage connections to different Large Language Models (LLMs). A single text field for a local API is insufficient for users who may want to switch between different local models (e.g., a coding model vs. a writing model) or connect to various remote APIs.

The goal of this feature is to create a "Model Card" system within the DCE Settings Panel. This will allow users to create, save, and select from multiple configurations, making it easy to switch between different AI backends.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| P3-MC-01 | **Create a Model Card** | As a user, I want to create a new "model card" where I can input all the necessary information to connect to an LLM, so I can configure different models for different tasks. | - A "New Model Card" button exists in the Settings Panel. <br> - Clicking it opens a form with fields for: Display Name, API Endpoint URL, API Key (optional), and Context Window Size (tokens). <br> - A "Save" button persists this card. |
| P3-MC-02 | **Manage Model Cards** | As a user, I want to see a list of my saved model cards and be able to edit or delete them, so I can manage my configurations. | - The Settings Panel displays a list of all saved model cards. <br> - Each card in the list has "Edit" and "Delete" buttons. |
| P3-MC-03 | **Select Active Model** | As a user, I want to select one of my model cards as the "active" model, so the extension knows which LLM to use for its API calls. | - Each model card in the list has a "Select" or "Activate" button (or a radio button). <br> - A default, non-deletable "AI Studio" (manual mode) card is always present. <br> - The currently active model is visually highlighted. |

## 3. Proposed UI/UX

The "Settings" section of the existing Settings Panel will be redesigned to accommodate this feature.

1.  **Main View:**
    *   A list of existing model cards will be displayed. Each entry will show the `Display Name` and part of the `Endpoint URL`.
    *   Each entry will have `Edit`, `Delete`, and `Select` buttons.
    *   A prominent "Add New Model Card" button will be at the bottom of the list.

2.  **Creation/Editing View:**
    *   Clicking "Add New" or "Edit" will either show a modal or navigate to a separate view within the panel.
    *   This view will contain a form with the following fields:
        *   **Display Name:** (e.g., "Local Llama3-70B", "OpenAI GPT-4o")
        *   **API Endpoint URL:** The full URL for the API.
        *   **API Key:** (Optional) A password field for the API key.
        *   **Context Window Size:** A number input for the model's context window in tokens. This is crucial for future calculations and prompt management.
    *   "Save" and "Cancel" buttons will be present.

## 4. Technical Implementation Plan (High-Level)

1.  **Data Storage:**
    *   Model card configurations will be stored in the VS Code `workspaceState` or global state under a dedicated key (e.g., `dce.modelCards`).
    *   API keys will be stored securely using the `SecretStorage` API, keyed by a unique ID associated with each model card.

2.  **Backend (`settings.service.ts` - New or Existing):**
    *   A new service, or an expansion of an existing one, will be needed to manage the CRUD (Create, Read, Update, Delete) operations for model cards.
    *   It will handle the logic for reading/writing from `workspaceState` and `SecretStorage`.

3.  **Frontend (`settings.view.tsx`):**
    *   The settings view will be refactored into a more complex React component that manages the state for the list of cards and the editing form.
    *   It will use new IPC channels to communicate with the backend service to perform the CRUD operations.
</file_artifact>

<file path="src/Artifacts/README.md">
# Artifact A72: DCE - README for Artifacts
# Date Created: C158
# Author: AI Model & Curator

- **Key/Value for A0:**
- **Description:** The content for the `README.md` file that is automatically created in a new project's `src/Artifacts` directory, explaining the purpose of the extension and the artifact-driven workflow.
- **Tags:** documentation, onboarding, readme, source of truth

## 1. Welcome to the Data Curation Environment (DCE)

This directory (`src/Artifacts/`) is the heart of your project's planning and documentation. It's managed by the **Data Curation Environment (DCE)**, a VS Code extension designed to streamline AI-assisted development.

This `README.md` file was automatically generated to provide context for you (the developer) and for the AI assistants you will be working with.

## 2. What is an "Artifact"?

In the context of this workflow, an **Artifact** is a formal, written document that serves as a "source of truth" for a specific part of your project. Think of these files as the official blueprints, plans, and records.

The core principle of the DCE workflow is **"Documentation First."** Before writing code, you and your AI partner should first create or update an artifact that describes the plan.

-   **Why?** This ensures clarity, reduces misunderstandings, and creates a persistent record of design decisions. It's much easier to iterate on a plan in plain English than it is to refactor code.

## 3. The Iterative Cycle Workflow

Development in the DCE is organized into **Cycles**. You are currently in the early stages of your project.

1.  **Curate Context:** Using the "Data Curation" panel in the VS Code Activity Bar, you select (by checking the boxes) which artifacts and code files are relevant for your current task.
2.  **Generate a Prompt:** Using the "Parallel Co-Pilot" panel, you will write instructions for your AI assistant for the current cycle. The panel will help you generate a `prompt.md` file that includes your instructions, the project's history, and the content of the files you curated.
3.  **Get AI Responses:** You use this `prompt.md` with your preferred AI model (e.g., Gemini, Claude) to get one or more proposed solutions.
4.  **Review and Accept:** You paste the AI's responses back into the Parallel Co-Pilot panel. The panel allows you to compare the responses, see the proposed changes (diffs), and accept the best solution into your workspace with a single click.
5.  **Repeat:** This completes a cycle. You then start the next cycle, building upon the newly accepted code and documentation.

This structured, iterative process helps maintain project quality and ensures that both human and AI developers are always aligned with the project's goals.
</file_artifact>

