import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs/promises';
import { Services } from './services';
import { parseResponse } from '@/client/utils/response-parser';
import { PcppCycle } from '@/common/types/pcpp.types';
import { truncateCodeForLogging } from '@/common/utils/formatting';
import { ServerPostMessageManager } from '@/common/ipc/server-ipc';
import { ServerToClientChannel } from '@/common/ipc/channels.enum';

export class PromptService {
    private extensionUri: vscode.Uri;

    constructor(extensionUri: vscode.Uri) {
        this.extensionUri = extensionUri;
    }

    private artifactSchemaTemplate = `<M1. artifact schema>
M1. artifact schema
M2. cycle overview
M3. interaction schema
M4. current project scope
M5. organized artifacts list
M6. cycles
M7. Flattened Repo
</M1. artifact schema>`;

    private interactionSchemaTemplate = `<M3. Interaction Schema>
1.  Artifacts are complete, individual texts enclosed in \`<xmltags>\`. To ensure consistent parsing by the DCE extension, all file artifacts **must** be enclosed in \`<file path="path/to/file.ts">...</file>\` tags. The path must be relative to the workspace root. The closing tag must be a simple \`</file>\`. Do not use the file path in the closing tag.
2.  Our Document Artifacts serve as our \`Source of Truth\` throughout multiple cycles. As such, over time, as issues occur, or code repeatedly regresses in the same way, seek to align our \`Source of Truth\` such that the Root Cause of such occurances is codified so that it can be avoided on subsequent cycles visits to those Code artifacts.
3.  Please output entire Document or Code artifacts. Do not worry about Token length. If your length continues for too long, and you reach the 600 second timeout, I will simply incorporate the work you did complete, and we can simply continue from where you left off. Better to have half of a solution to get started with, than not to have it. **Preference is for larger, more complete updates over smaller, incremental ones to align with the human curator's parallel processing workflow.** The human curator often sends the same prompt to multiple AI instances simultaneously and selects the most comprehensive response as the primary base for the next cycle, using other responses as supplementary information. Providing more complete updates increases the likelihood of a response being selected as the primary base.
4.  Do not output artifacts that do not require updates in this cycle. (Eg. Do not do this: // Updated on: Cycle 1040 (No functional changes, only cycle header))
5.  **Critical: \`flattened_repo_v2.txt\` contains all project files. Output updated *individual* files that are part of it (like \`<src/state/coreStore.ts>...\`). However, do **NOT** output the surrounding Artifact container tags (\`<flattened_repo_v2.txt>...</flattened_repo_v2.txt>\`) or any auto-generated metadata sections within it (like the Total Files summary, Top 10 list, or the \`<files list>\` section) which are created by the \`flatten.js\` script.**
5.1. \`flattened_repo_v2.txt\` is a copy of the codebase, generated by a script; assume its an accurate representation of the existing codebase, but not necessarily a 'source of truth' like we treat our documents as, our codebase is a living artifact, documents, while we can update them, should be considered less transient.
5.2. **\`.local\` File Convention:** To manage token count, some large data files (e.g., \`researchNodes.ts\`) may be represented by a truncated \`.local.ts\` version in the context. This version contains the essential structure and a few examples. If the full content of a file is required for a task (e.g., a comprehensive data refactor or fixing a bug related to a specific entry), explicitly state this need in your summary of actions and request that the curator swap the \`.local.ts\` file with the full \`.ts\` version in the \`files_list.txt\` for the subsequent cycle.
6.  remember to output complete artifacts without placeholders, im taking your output, putting it in winmerge, and confirming we arent losing data in the update. when you provide placeholders, my cursory review turns into a meticulous file parsing, taking me from what is 5 seconds per artifact to upwards of 5 minutes, only to realize that the output is actually un-parseable, due to the nature of relativity, as the theory of relativity also applies to code. if you give me a code snippet, and do not give me the code surrounding that snippet, i do not know where that code should go. by providing the complete file, on the other hand, i can put it in a diff, see easily what was altered, and if anything was accidentally omitted or lost, i can be sure that it's retained.
7.  **Update documentation before writing code.** document artifacts are like our project readme files, our source of truth. they are our blueprints. they guide the code we write. when we realize we need to alter our approach or invent new game mechanics, we update the source of truth first, cause english is easy and flexible, then we codify that.
8.  this query is part of a larger software engineering project
9.  After you complete delivery on a code artifact, review it to make sure you did not miss any intermediary files. for instance, if we have a DevelopmentSystem.ts, using the componentData.ts, which is displaying on the ComponentProductionTab.tsx. But then theres also still a DevPanel.tsx file that is in-between that *could*, but shouldnt, get overlooked.
10. If you are deciding where to put a particular piece of code or function, and due to its nature, there are one or more candidate files that it could be placed in, choose the smaller file (in tokens).
11. Begin your response with a course of action and end with a review of your work, surface any self corrections in the summary of changes for the subsequent cycle.
12. do not underestimate how much you can accomplish in a given cycle; you'd only accomplish handicapping yourself. (Eg. you've authored this whole thing with just my guidance. good job, keep it up.)
13. Not as relevant for this project: **Log State Button:** The 'Log State' button in the \`DevInfoOverlay\` is a dynamic debugging tool. Modify the \`triggerDebugLogs\` action in \`uiStore.ts\` to output specific state information relevant to the current bug being investigated. **See A85 (Logging Guide) for usage details.**
14. Not as relevant for this project: **Regression Case Studies:** Use Artifact A106 to document persistent or complex bugs and their resolutions. Add entries *after* a fix is confirmed to codify the RCA and solution, preventing future regressions.
15. Include in your cycle summary, a short list of files you've updated. This makes it easy for my reviews.
16. if you seem to have spare time in a cycle, see if you can spot any particular file with excessive levels of comments or logging that seems extensive and for troubleshooting an error that has since been resolved, see to it to clean those files but preserve their functionalities. im just looking to shave off excess tokens wherever possible in the master_content.txt file.
17. if you see \`(No change from C850)\` such language, it's data loss. there was supposed to be actual language behind that placeholder, but in one iteration (C850, in this case) you had provided a placeholder, and i 'missed it' and did not capture the initial information. you either need to deliver the placeholder in such a way as i can easily press the left arrow instead of the rigth arrow in winmerge to not accept that part, but to also not have winmerge confuse it with the rest, otherwise i must manually parse the information. when the process is a single keystroke, i can manage it quickly enough. when we remove that ability because you provided me data in a format that has placeholders AND the placeholders do not parse within winmerge such that it removes the benefit winmerge is adding, then we have our problem. when you see this, try to correct it using whatever current relevant context you have.
18. basically, you should not worry about brevity, because when you go too long, your response gets interrupted by the system anyway. its better that the products you do deliver are all complete except for the last one, rather than you delivering all incomplete products, including the last one. does that make sense?
19. remember, do not stop outputting for the reason of preventing a potential artifact interruption mid-output. you actually end up stopping yourself from producting two or three additional files before you actually get interrupted. what i mean is, in the outputs where you do not do this, you produce for 500 seconds, producing 7-9 files, and only the last one is interrupted and unusable. compared to when you stop yourself prematurely, for the reason stated, and you produce for 180 seconds and provide maybe 3-4 files. even with the -1, producing as much as you can still outperforms the alternative.
20. This is a misaligned statement: \`// (For full history, see master_content.txt)\` because your changes get rolled into master_content.txt. therefore, if you remove the history, then when your updates are rolled in, they will remove the full history. understand? after a while, the history is not relevant and can be rolled out, for a while, it ought to stay. you can see what we're working on + the current cycle and make this determination.
21. Each time we create a new documentation artifact, lets also create the key/value pairs needed for me to add it into our Master Artifact List. they can simply be added into the new artifact itself and ill make the new entry in A0. this will solve for me manually generating a description and tag for each new documentation artifact. also, dont place \`/\` in the title/name of a documentation artifact. VSCode treats it as a folder separator.
21.1. when creating a new documentation artifact, also just update the master artifacts list itself.
</M3. Interaction Schema>`;

    private getPreviousCycleSummary(cycle: PcppCycle | undefined): string {
        if (!cycle) return '';
        
        const selectedResponseId = cycle.selectedResponseId;
        if (!selectedResponseId || !cycle.responses[selectedResponseId]) {
            Services.loggerService.warn(`Could not find selected response content for cycle ${cycle.cycleId}`);
            return `<!-- No response was selected for cycle ${cycle.cycleId} -->`;
        }

        const previousResponseContent = cycle.responses[selectedResponseId].content;
        if (!previousResponseContent.trim()) {
            return `<!-- Selected response for cycle ${cycle.cycleId} was empty -->`;
        }

        const parsed = parseResponse(previousResponseContent);
        
        let summary = `${parsed.summary}\n\n${parsed.courseOfAction}`;

        if (parsed.filesUpdated.length > 0) {
            summary += `\n\n### Files Updated This Cycle:\n* ${parsed.filesUpdated.join('\n* ')}`;
        }

        return summary;
    }

    private async _generateCyclesContent(currentCycleData: PcppCycle, fullHistory: PcppCycle[]): Promise<string> {
        const allCycles = [...fullHistory];
        const cycleMap = new Map(allCycles.map(c => [c.cycleId, c]));
        cycleMap.set(currentCycleData.cycleId, currentCycleData);

        const sortedHistory = [...cycleMap.values()].sort((a, b) => b.cycleId - a.cycleId);
    
        let cyclesContent = '<M6. Cycles>';
    
        for (const cycle of sortedHistory) {
            cyclesContent += `\n\n<Cycle ${cycle.cycleId}>\n`;
    
            if (cycle.cycleContext && cycle.cycleContext.trim()) {
                cyclesContent += `<Cycle Context>\n${cycle.cycleContext}\n</Cycle Context>\n`;
            }
    
            if (cycle.cycleId === currentCycleData.cycleId && cycle.ephemeralContext && cycle.ephemeralContext.trim()) {
                cyclesContent += `<Ephemeral Context>\n${cycle.ephemeralContext}\n</Ephemeral Context>\n`;
            }
    
            const previousCycleId = cycle.cycleId - 1;
            const previousCycle = cycleMap.get(previousCycleId);
            if (previousCycle) {
                const summary = this.getPreviousCycleSummary(previousCycle);
                if (summary.trim()) {
                    cyclesContent += `<Previous Cycle ${previousCycleId} Summary of Actions>\n${summary}\n</Previous Cycle ${previousCycleId} Summary of Actions>\n`;
                }
            }
            cyclesContent += `</Cycle ${cycle.cycleId}>`;
        }
        cyclesContent += '\n\n</M6. Cycles>';
        return cyclesContent;
    }

    public async generateStateLog(currentState: PcppCycle) {
        Services.loggerService.log("--- GENERATING STATE LOG ---");
        try {
            const fullHistory = await Services.historyService.getFullHistory();
            
            const truncatedHistory = JSON.parse(JSON.stringify(fullHistory));
            const truncatedCurrentState = JSON.parse(JSON.stringify(currentState));

            const truncateCycleResponses = (cycle: PcppCycle) => {
                Object.values(cycle.responses).forEach(response => {
                    response.content = truncateCodeForLogging(response.content);
                });
            };

            truncatedHistory.forEach(truncateCycleResponses);
            truncateCycleResponses(truncatedCurrentState);
            
            const cyclesContent = await this._generateCyclesContent(currentState, fullHistory);
            
            const stateDump = {
                "CURRENT_FRONTEND_STATE": truncatedCurrentState,
                "FULL_HISTORY_FROM_BACKEND": truncatedHistory
            };

            const logMessage = `
========================= CURRENT STATE DUMP =========================
${JSON.stringify(stateDump, null, 2)}
======================================================================

==================== GENERATED <M6. Cycles> BLOCK ====================
${cyclesContent}
======================================================================
`;
            Services.loggerService.log(logMessage);
            Services.loggerService.show();
            vscode.window.showInformationMessage("State logged to 'Data Curation Environment' output channel.");
        } catch (error: any) {
            Services.loggerService.error(`Failed to generate state log: ${error.message}`);
        }
    }

    public async generatePromptFile(cycleTitle: string, currentCycle: number) {
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (!workspaceFolders || workspaceFolders.length === 0) {
            vscode.window.showErrorMessage("Cannot generate prompt: No workspace folder is open.");
            return;
        }
        const rootPath = workspaceFolders[0].uri.fsPath;
        const flattenedRepoPath = path.join(rootPath, 'flattened_repo.md');
        const promptMdPath = path.join(rootPath, 'prompt.md');

        try {
            Services.loggerService.log("Generating prompt.md file...");

            const flattenedContent = await fs.readFile(flattenedRepoPath, 'utf-8');
            const fullHistory: PcppCycle[] = await Services.historyService.getFullHistory();
            
            const currentCycleDataFromHistory = fullHistory.find(c => c.cycleId === currentCycle);
            if (!currentCycleDataFromHistory) {
                throw new Error(`Could not find data for current cycle (${currentCycle}) in history.`);
            }
            const currentCycleData = { ...currentCycleDataFromHistory, title: cycleTitle };

            const allCycles = [...fullHistory.filter(c => c.cycleId !== currentCycle), currentCycleData];
            const sortedHistory = allCycles.sort((a, b) => b.cycleId - a.cycleId);

            let cycleOverview = '<M2. cycle overview>\n';
            cycleOverview += `Current Cycle ${currentCycle} - ${cycleTitle}\n`;
            for (const cycle of sortedHistory) {
                if (cycle.cycleId !== currentCycle) {
                     cycleOverview += `Cycle ${cycle.cycleId} - ${cycle.title}\n`;
                }
            }
            cycleOverview += '</M2. cycle overview>';
            
            const cyclesContent = await this._generateCyclesContent(currentCycleData, fullHistory);

            let masterArtifactListContent = '<!-- Master Artifact List (A0) not found -->';
            try {
                const a0Path = path.join(rootPath, 'src', 'Artifacts', 'A0. DCE Master Artifact List.md');
                masterArtifactListContent = await fs.readFile(a0Path, 'utf-8');
            } catch (e) {
                Services.loggerService.warn("Could not read A0. DCE Master Artifact List.md");
            }

            const projectScope = `<M4. current project scope>\n${currentCycleData.cycleContext || 'No project scope defined for this cycle.'}\n</M4. current project scope>`;

            const promptParts = [
                `<prompt.md>`,
                this.artifactSchemaTemplate,
                cycleOverview,
                this.interactionSchemaTemplate,
                projectScope,
                `<M5. organized artifacts list>\n${masterArtifactListContent}\n</M5. organized artifacts list>`,
                cyclesContent,
                `<M7. Flattened Repo>\n${flattenedContent}\n</M7. Flattened Repo>`,
                `</prompt.md>`
            ];

            const finalPrompt = promptParts.join('\n\n');

            await fs.writeFile(promptMdPath, finalPrompt, 'utf-8');
            vscode.window.showInformationMessage(`Successfully generated prompt.md.`);
            Services.loggerService.log("Successfully generated prompt.md file.");

        } catch (error: any) {
            let errorMessage = `Failed to generate prompt.md: ${error.message}`;
            if (error.code === 'ENOENT' && error.path?.includes('flattened_repo.md')) {
                errorMessage = "Failed to generate prompt.md: 'flattened_repo.md' not found. Please flatten context first.";
            }
            vscode.window.showErrorMessage(errorMessage);
            Services.loggerService.error(errorMessage);
        }
    }

    public async generateCycle0Prompt(projectScope: string, serverIpc: ServerPostMessageManager) {
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (!workspaceFolders || workspaceFolders.length === 0) {
            vscode.window.showErrorMessage("Cannot generate prompt: No workspace folder is open.");
            return;
        }
        const rootPath = workspaceFolders[0].uri.fsPath;
        const promptMdPath = path.join(rootPath, 'prompt.md');
        const artifactsDirInWorkspace = path.join(rootPath, 'src', 'Artifacts');
        const artifactsDirInExtension = vscode.Uri.joinPath(this.extensionUri, 'src', 'Artifacts');

        try {
            Services.loggerService.log("Generating Cycle 0 prompt.md file...");

            const templateIds = ['T1', 'T2', 'T3', 'T4', 'T5', 'T7', 'T8', 'T9', 'T10', 'A52'];
            const artifactFilenameMap: { [key: string]: string } = {
                'T1': 'T1. Template - Master Artifact List.md', 'T2': 'T2. Template - Project Vision and Goals.md', 'T3': 'T3. Template - Phase 1 Requirements & Design.md', 'T4': 'T4. Template - Technical Scaffolding Plan.md', 'T5': 'T5. Template - Target File Structure.md', 'T7': 'T7. Template - Development and Testing Guide.md', 'T8': 'T8. Template - Regression Case Studies.md', 'T9': 'T9. Template - Logging and Debugging Guide.md', 'T10': 'T10. Template - Feature Plan Example.md', 'A52': 'A52. DCE - Interaction Schema Refinement.md'
            };

            let staticContext = '';
            for (const artifactId of templateIds) {
                const filename = artifactFilenameMap[artifactId];
                const artifactUri = vscode.Uri.joinPath(artifactsDirInExtension, filename);
                try {
                    const contentBuffer = await vscode.workspace.fs.readFile(artifactUri);
                    const content = Buffer.from(contentBuffer).toString('utf-8');
                    staticContext += `<${filename}>\n${content}\n</${filename}>\n\n`;
                } catch (e) {
                    Services.loggerService.warn(`Could not read template artifact from extension files: ${artifactUri.fsPath}`);
                }
            }

            const cycle0Context = `<Cycle 0>
<Cycle Context>
You are a senior project architect. Your task is to establish the necessary documentation to achieve the user's goals, which are outlined in M4.

**CRITICAL INSTRUCTIONS:**
1.  Your primary goal is to generate **planning and documentation artifacts** (e.g., Project Vision, Requirements).
2.  You **MUST NOT** generate code files (e.g., \`package.json\`, \`src/main.ts\`) in this initial cycle. The "documentation first" principle is paramount.
3.  Every artifact you generate **MUST** be enclosed in the strict XML format explained in the provided "Interaction Schema Refinement" document: \`<file path="path/to/artifact.md">...</file>\`.
</Cycle Context>
<Static Context>
${staticContext.trim()}
</Static Context>
</Cycle 0>`;

            const projectScopeContent = `<M4. current project scope>\n${projectScope}\n</M4. current project scope>`;

            const promptParts = [
                `<prompt.md>`, this.artifactSchemaTemplate, `<M2. cycle overview>\nCurrent Cycle 0 - Project Initialization\n</M2. cycle overview>`, this.interactionSchemaTemplate, projectScopeContent, `<M5. organized artifacts list>\n# No artifacts exist yet.\n</M5. organized artifacts list>`, `<M6. Cycles>\n${cycle0Context}\n</M6. Cycles>`, `<M7. Flattened Repo>\n<!-- No files selected for initial prompt -->\n</M7. Flattened Repo>`, `</prompt.md>`
            ];

            const finalPrompt = promptParts.join('\n\n');
            await vscode.workspace.fs.writeFile(vscode.Uri.file(promptMdPath), Buffer.from(finalPrompt, 'utf-8'));
            Services.loggerService.log("Successfully generated Cycle 0 prompt.md file.");

            // Create empty A0 artifact
            await vscode.workspace.fs.createDirectory(vscode.Uri.file(artifactsDirInWorkspace));
            const a0Uri = vscode.Uri.file(path.join(artifactsDirInWorkspace, 'A0. DCE Master Artifact List.md'));
            const a0InitialContent = `# Artifact A0: [Your Project Name] Master Artifact List\n# Date Created: C0\n\n## 1. Purpose\n\n# This file serves as the definitive, parseable list of all documentation artifacts for your project.`;
            await vscode.workspace.fs.writeFile(a0Uri, Buffer.from(a0InitialContent, 'utf-8'));
            Services.loggerService.log("Created empty A0 Master Artifact List.");
            
            vscode.window.showInformationMessage(`Successfully generated initial prompt.md and created src/Artifacts/A0...`);

            const cycle1Data: PcppCycle = {
                cycleId: 1,
                timestamp: new Date().toISOString(),
                title: 'New Cycle',
                cycleContext: '',
                ephemeralContext: '',
                responses: { "1": { content: "" } },
                isParsedMode: false,
                leftPaneWidth: 33,
                selectedResponseId: null,
                selectedFilesForReplacement: [],
                tabCount: 4
            };

            await Services.historyService.saveCycleData(cycle1Data);
            serverIpc.sendToClient(ServerToClientChannel.SendLatestCycleData, { cycleData: cycle1Data });

        } catch (error: any) {
            vscode.window.showErrorMessage(`Failed to generate Cycle 0 prompt: ${error.message}`);
            Services.loggerService.error(`Failed to generate Cycle 0 prompt: ${error.message}`);
        }
    }
}