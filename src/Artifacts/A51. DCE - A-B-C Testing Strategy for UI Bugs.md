# Artifact A51: DCE - A-B-C Testing Strategy for UI Bugs
# Date Created: C102
# Author: AI Model & Curator

- **Key/Value for A0:**
- **Description:** Outlines a development pattern for creating parallel, isolated test components to diagnose and resolve persistent UI bugs, such as event handling or rendering issues.
- **Tags:** process, debugging, troubleshooting, ui, ux, react

## 1. Overview & Goal

When a user interface (UI) bug, particularly related to event handling (`onClick`, `onDrop`, etc.) or component rendering, proves resistant to conventional debugging, it often indicates a complex or non-obvious root cause. This can be due to silent rendering errors in React, improper event propagation, conflicting CSS properties, or subtle issues with component lifecycle and state.

Continuously attempting small, incremental fixes on the main, complex component can be inefficient and frustrating. The goal of the **A/B/C Testing Strategy** is to break this cycle by stripping away all complexity and testing the core functionality in parallel, isolated environments.

## 2. The Strategy

The core idea is to replace the single, complex, and failing UI component with multiple, simplified, independent test components. Each test component attempts to solve the same basic problem using a slightly different technical approach.

### 2.1. Steps

1.  **Identify the Core Problem:** Isolate the most fundamental action that is failing. For example: "A click on a list item is not being registered."
2.  **Pause Feature Development:** Temporarily halt all work on the complex feature (e.g., diffing, syntax highlighting) that surrounds the bug.
3.  **Create Test Harness:** Refactor the main view to act as a "test harness." Replace the primary UI with a simple tabbed interface where each tab corresponds to a different test case (e.g., "Test 1", "Test 2", "Test 3").
4.  **Implement Isolated Test Components:** Create a new, simple component for each test case. These components should be self-contained and have minimal dependencies.
    *   **Test A (The "Barebones" Test):** The simplest possible implementation. Use raw HTML elements (`div`, `ul`, `li`) with inline event handlers that only contain a single `logger.log()` statement. No state, no props, no complex styling. This tests the absolute baseline of event capturing.
    *   **Test B (The "Local State" Test):** Introduce basic React `useState`. The event handler now calls a state setter function. The component renders something based on that state. This tests the component's ability to manage its own state and re-render correctly.
    *   **Test C (The "Prop-Driven" Test):** Re-introduce the concept of passing data and callbacks via props. A parent component holds the state, and the child component (the list) calls a function prop (`onClickItem`) when an event occurs. This tests for issues related to prop drilling and component composition.
5.  **Analyze Results:** By running the extension and interacting with each test tab, the developer can quickly determine which architectural pattern works and which fails.
    *   If Test A fails, the problem is likely fundamental (e.g., a CSS overlay, an environmental issue with the webview).
    *   If Test A works but Test B fails, the issue is with React's state or re-rendering loop.
    *   If Test B works but Test C fails, the issue is with how props are being passed between components.

## 3. Case Study: The Unclickable "Associated Files" List (Cycle 102)

-   **Problem:** For over 10 cycles, the `onClick` handler for files in the "Associated Files" list in the PCPP would not fire. No logs were generated.
-   **Application of Strategy:**
    1.  The main PCPP view was refactored to show three tabs: "Test Pane 1", "Test Pane 2", "Test Pane 3".
    2.  `TestPane1.tsx` was created with a raw `<ul>` and a simple `onClick={() => logger.log(...) }`.
    3.  `TestPane2.tsx` was created with its own `useState` to manage the selected file.
    4.  `TestPane3.tsx` was created with a parent/child structure to test prop drilling.
-   **Outcome:** This strategy will isolate the point of failure, allowing a working pattern to be identified and then used to rebuild the original, more complex feature on a solid foundation.