# Artifact A11: DCE - Regression Case Studies
# Date Created: C16
# Author: AI Model & Curator
# Updated on: C11 (Add command registration case study)

## 1. Purpose

This document serves as a living record of persistent or complex bugs that have recurred during development. By documenting the root cause analysis (RCA) and the confirmed solution for each issue, we create a "source of truth" that can be referenced to prevent the same mistakes from being reintroduced into the codebase.

**This artifact is the primary log for new and recent case studies.** Older, resolved issues are archived in `A11.1 DCE - New Regression Case Studies.md` to keep this document concise and focused on currently relevant issues.

## 2. Case Studies

---

### Case Study 026: "Command Already Exists" Activation Error

-   **Artifacts Affected:** `src/extension.ts`, `src/backend/commands/commands.ts`
-   **Cycles Observed:** C11
-   **Symptom:** The extension fails to activate with a critical error: `Error during activation: command 'dce.openSettingsPanel' already exists`.
-   **Root Cause Analysis (RCA):** The command ID `dce.openSettingsPanel` was being registered in two different places. It was registered once via the loop in `registerCommands` (which reads from the `commands.ts` array) and then registered a second time explicitly with `vscode.commands.registerCommand` in `extension.ts`. VS Code's command registry requires all command IDs to be unique, and this duplication caused a fatal activation error.
-   **Codified Solution & Best Practice:** The established pattern in the project is to use an internal command alias for commands that need access to the `ExtensionContext`.
    1.  The command defined in `commands.ts` (e.g., `dce.openSettingsPanel`) should be the "public" command triggered by the UI. Its callback should do nothing more than execute a different, "internal" command (e.g., `vscode.commands.executeCommand('dce.showSettingsPanel')`).
    2.  The "internal" command (e.g., `dce.showSettingsPanel`) is the one registered explicitly in `extension.ts`. This is where the logic that requires the `context` (like creating a webview panel) resides. This pattern ensures each command ID is registered only once, preventing conflicts.

---

### Case Study 025: Runtime vs. Build-time Syntax Errors

-   **Artifacts Affected:** `src/client/utils/response-parser.ts`
-   **Cycles Observed:** C188
-   **Symptom:** The Parallel Co-Pilot Panel appears as a completely blank white screen. No errors are visible in the extension host logs, but the webview fails to render any content.
-   **Root Cause Analysis (RCA):** The webview's JavaScript bundle contained a subtle but fatal syntax error that was not caught by the TypeScript/Babel build process. The code attempted to use an invalid form of optional chaining and nullish coalescing (`match?. ?? ''`) when trying to access properties of a regex match object. While the build completed successfully, the browser's JavaScript engine encountered this invalid syntax upon loading the script and immediately threw an `Uncaught SyntaxError`, halting all further execution and preventing React from rendering. The lack of build-time errors made this difficult to diagnose without inspecting the webview's own developer console.
-   **Codified Solution & Best Practice:**
    1.  **Correct Syntax:** The only way to access an element from an array-like object (such as a regex match) using optional chaining is with bracket notation: `match?.[1]`. The invalid `match?.` syntax must be corrected.
    2.  **Best Practice:** When debugging a "blank screen" webview with no backend errors, the first step is always to open the Webview Developer Tools (`Developer: Open Webview Developer Tools` from the Command Palette). This provides access to the client-side console, which will immediately reveal any runtime JavaScript errors that are preventing the application from loading.

---

### Case Study 024: PCPP Context/Title Data Loss or Corruption on Navigation

-   **Artifacts Affected:** `src/client/views/parallel-copilot.view/view.tsx`, `src/backend/services/history.service.ts`
-   **Cycles Observed:** C185, C189, C190, C2, C3, C4, C5
-   **Symptom:** Text entered into the "Cycle Context," "Ephemeral Context," or "Cycle Title" fields is lost or, more critically, data from one cycle is saved over another. This occurs when the user performs an action that reloads the view's state from disk, such as creating a new cycle or switching to a different cycle, especially when done quickly.
-   **Root Cause Analysis (RCA):** This is a critical data integrity bug caused by a race condition between a debounced (delayed) auto-save and the state loading event. When the user navigates to a new cycle, the state is reloaded from `dce_history.json` *before* the debounced save for the departing cycle has executed. This causes the UI's current state (with the old cycle's data) to be saved over the newly loaded cycle's data, corrupting the history file.
-   **Codified Solution & Best Practice:** The definitive solution is to prevent the user from initiating the race condition by making the save state explicit in the UI.
    1.  **Stateful Save Status:** The UI must maintain a `saveStatus` state (`'unsaved'`, `'saving'`, `'saved'`). Any change to persisted data immediately sets the status to `'unsaved'`.
    2.  **Navigation Locking:** All UI controls that trigger a cycle change (e.g., "Next," "Previous," "New Cycle" buttons) **must** be disabled whenever the `saveStatus` is not `'saved'`.
    3.  **Asynchronous Save with Acknowledgement:** The debounced auto-save function, when it fires, must set the status to `'saving'`. The backend, upon successfully writing the data to disk, must send an explicit acknowledgement message back to the frontend.
    4.  **UI Unlock:** The frontend, upon receiving the save acknowledgement for the current cycle, sets the status to `'saved'`, which re-enables the navigation controls. This creates a clear, safe, and transparent workflow for the user, making data loss impossible.

---