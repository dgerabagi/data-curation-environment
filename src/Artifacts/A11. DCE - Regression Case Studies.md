# Artifact A11: DCE - Regression Case Studies
# Date Created: C16
# Author: AI Model & Curator
# Updated on: C79 (Add case for cycle navigation state corruption)

## 1. Purpose

This document serves as a living record of persistent or complex bugs that have recurred during development. By documenting the root cause analysis (RCA) and the confirmed solution for each issue, we create a "source of truth" that can be referenced to prevent the same mistakes from being reintroduced into the codebase.

## 2. Case Studies

---

### Case Study 043: State Corruption on Cycle Navigation

-   **Artifacts Affected:** `src/backend/services/llm.service.ts`, `src/backend/services/history.service.ts`
-   **Cycles Observed:** C79
-   **Symptom:** After a batch of responses finishes generating for Cycle `N`, if the user navigates to a different cycle (e.g., `N-1`) and then navigates back to Cycle `N`, the UI for Cycle `N` is stuck in the "generating responses" view for all tabs, and the data is inaccessible. Manually inspecting `dce_history.json` reveals that the `status` for Cycle `N` is still `'generating'`.
-   **Root Cause Analysis (RCA):** The backend process correctly updates the status of individual responses to `'complete'` as they finish, but it fails to perform a final update on the parent *cycle* object. When the last response stream ends, the `status` of the `PcppCycle` object in `dce_history.json` is never transitioned from `'generating'` to `'complete'`. When the user navigates away and back, the UI re-reads this stale, incorrect status and incorrectly re-mounts the generation progress view.
-   **Codified Solution & Best Practice:**
    1.  The service responsible for consuming the LLM stream (`llm.service.ts`) must track the completion of the *entire batch*.
    2.  When the final response in the batch is marked as complete, the stream consumer must explicitly call a dedicated method (e.g., `historyService.finalizeCycleStatus(cycleId)`) to update the parent cycle's status in the persistent storage.
    3.  This ensures that the persisted state is always consistent and prevents the UI from loading into a corrupted or invalid state on reload or navigation.

---

### Case Study 042: UI Fails to Advance to New Cycle on Subsequent Generations

-   **Artifacts Affected:** `src/client/views/parallel-copilot.view/view.tsx`, `src/backend/services/history.service.ts`, `src/common/ipc/channels.type.ts`
-   **Cycles Observed:** C74
-   **Symptom:** After successfully completing an initial cycle (e.g., Cycle 1), clicking "Generate responses" correctly creates a `prompt.md` and sends requests to the LLM, but the DCE panel UI remains on Cycle 1. It does not navigate to the new cycle (e.g., Cycle 2) and does not show the generation progress UI.
-   **Root Cause Analysis (RCA):** The backend successfully creates a placeholder for the new cycle, but the frontend's state is stale. The `maxCycle` state variable on the client is not updated after the new cycle is created. When the frontend receives the `StartGenerationUI` message with the `newCycleId`, its internal navigation logic (`handleCycleChange`) prevents the navigation because `newCycleId` is greater than its known `maxCycle`.
-   **Codified Solution & Best Practice:**
    1.  When a new cycle placeholder is created on the backend, the service must return both the `newCycleId` and the new `newMaxCycle` count.
    2.  The IPC message that tells the client to start the generation UI (`StartGenerationUI`) must include both `newCycleId` and `newMaxCycle` in its payload.
    3.  The frontend message handler for `StartGenerationUI` **must** update its `maxCycle` state with the new value *before* it attempts to call the navigation function. This ensures the UI's state is synchronized with the backend's state before any navigation is attempted.

---

### Case Study 041: PCPP View State Lost on Tab Switch

-   **Artifacts Affected:** `src/client/views/parallel-copilot.view/view.tsx`, `src/common/types/vscode-webview.d.ts`
-   **Cycles Observed:** C67, C72
-   **Symptom:** When the user is viewing a specific UI state within the Parallel Co-Pilot Panel (e.g., the "Generation Progress" view), and they switch to another VS Code tab and then return, the panel's view resets to its default state (the main response pane). The user's intended view is lost.
-   **Root Cause Analysis (RCA):** VS Code webviews can be destroyed when they become hidden to conserve resources. When the user returns, the webview is completely re-initialized. Any UI state managed solely within React's `useState` is therefore lost. The correct way to persist UI-specific state for a webview is to use the `acquireVsCodeApi()`'s `getState()` and `setState()` methods, which are managed by the VS Code host and survive the webview's destruction.
-   **Codified Solution & Best Practice:**
    1.  Identify any transient UI state that needs to be persisted (e.g., `activeView: 'main' | 'progress'`).
    2.  Add this state to the `ViewState` interface in `vscode-webview.d.ts`.
    3.  On component mount, use a `useEffect` hook to call `vscode.getState()` to retrieve and restore the persisted UI state.
    4.  Use another `useEffect` hook that listens for changes to that state variable and calls `vscode.setState()` to save it whenever it changes. This ensures the view state is always preserved by the VS Code host.

---

### Case Study 040: Stale Prompt Context in Automated Generation Workflow

-   **Artifacts Affected:** `src/backend/services/prompt.service.ts`, `src/client/views/parallel-copilot.view/on-message.ts`, `src/client/views/parallel-copilot.view/view.tsx`
-   **Cycles Observed:** C67, C71
-   **Symptom:** When using the "Generate responses" button for a new cycle (e.g., Cycle 2), the responses received from the LLM are based on the context of a much older cycle (e.g., Cycle 0), completely ignoring the new information provided by the user in the current cycle (e.g., Cycle 1). Additionally, the UI fails to automatically navigate to the new cycle after generation is complete.
-   **Root Cause Analysis (RCA):** This is a critical workflow failure with two main causes:
    1.  **Stale Data:** The `prompt.service.ts` was not correctly combining the fresh, in-memory `cycleData` (for Cycle `N`) sent from the frontend with the full history read from disk. A logic error caused it to ignore the new `cycleContext` and build the prompt using only the older, persisted data for Cycle `N`.
    2.  **Navigation Failure:** The frontend's message handler for `SendBatchGenerationComplete` was not reliably triggering the navigation to the new cycle (`N+1`), leaving the user on the old cycle view.
-   **Codified Solution & Best Practice:**
    1.  The backend handler for `RequestNewCycleAndGenerate` must use the `cycleData` from the client as the absolute source of truth for the current cycle.
    2.  The `prompt.service.ts` must ensure its logic correctly overwrites any stale data from the history file with the fresh data from the client before assembling the prompt.
    3.  As a best practice for transparency, the generated prompt string should be written to `prompt.md` in the workspace before being sent to the LLM.
    4.  The frontend's `SendBatchGenerationComplete` handler must reliably call the navigation logic to switch the view to the `newCycleId`.