# Artifact A11: DCE - Regression Case Studies
# Date Created: C16
# Author: AI Model & Curator
# Updated on: C44 (Add vLLM Truncation case)

## 1. Purpose

This document serves as a living record of persistent or complex bugs that have recurred during development. By documenting the root cause analysis (RCA) and the confirmed solution for each issue, we create a "source of truth" that can be referenced to prevent the same mistakes from being reintroduced into the codebase.

**This artifact is the primary log for new and recent case studies.** Older, resolved issues are archived in `A11.1 DCE - New Regression Case Studies.md` to keep this document concise and focused on currently relevant issues.

## 2. Case Studies

---

### Case Study 039: vLLM Responses Truncated at Stop Token

-   **Artifacts Affected:** `A90. AI Ascent - server.ts (Reference).md`, `src/backend/services/llm.service.ts`
-   **Cycles Observed:** C44
-   **Symptom:** When generating batch responses from the vLLM server, the AI-generated text is cut off prematurely, often right before it would have written `

---



### Case Study 001: PCPP Context Textarea Instability

-   **Artifacts Affected:** `src/client/views/parallel-copilot.view/components/NumberedTextarea.tsx`, `src/client/views/parallel-copilot.view/components/ContextInputs.tsx`
-   **Cycles Observed:** C1, C2, C3, C167, C174, C1, C5
-   **Symptom:** The "Cycle Context" and "Ephemeral Context" text fields in the PCPP become unusable when a large amount of text is entered, especially when scrolling or word-wrapping is involved. The cursor's visual position desynchronizes from the actual text insertion point. The cursor may appear on the correct wrapped line, but typed characters will continue to render on a previous line, off-screen. This makes editing content impossible.
-   **Root Cause Analysis (RCA):** This bug has recurred with multiple implementations (`NumberedTextarea`, `react-simple-code-editor`). The root cause is the architectural choice of using an overlay approach to render line numbers or syntax highlighting. This involves rendering a `div` or `<pre>` block with the styled content behind a transparent `<textarea>`. The instability is caused by a synchronization failure:
    1.  **Performance:** Re-calculating syntax highlighting and re-rendering the DOM on every single keystroke is computationally expensive for large blocks of text, causing severe input lag.
    2.  **Synchronization Failure:** Subtle differences in CSS (`font`, `padding`, `line-height`, `word-spacing`, etc.) and the browser's rendering engine between the overlay `div` and the transparent `textarea` cause a "drift" in alignment as content grows and wraps. This leads to the cursor and text selection bugs.
-   **Codified Solution & Best Practice:**
    1.  **Prioritize Stability:** For critical user inputs, stability and performance are more important than advanced features like line numbers or real-time syntax highlighting.
    2.  **Simplify:** The complex overlay-based editor component in `ContextInputs.tsx` must be replaced with a standard, native `<textarea>` element.
    3.  **Conclusion:** This change guarantees a reliable and performant text input experience. While it represents a temporary removal of a feature, it fixes a critical usability bug. A more robust implementation of a custom code editor (e.g., using Monaco or CodeMirror) can be planned for a future cycle, but the default should always be a stable, native component.

---

### Case Study 002: FTV Flashing on PCPP Auto-Save

-   **Artifacts Affected:** `src/backend/services/file-tree.service.ts`
-   **Cycles Observed:** C1, C4, C1
-   **Symptom:** The entire Data Curation file tree view (FTV) flashes or completely reloads whenever the user stops typing in one of the Parallel Co-Pilot Panel's text areas.
-   **Root Cause Analysis (RCA):** The PCPP automatically saves its state to `dce_history.json` (located in the `.vscode` directory) after a brief period of inactivity. The backend `FileSystemWatcher` in `file-tree.service.ts` was configured to monitor the entire workspace for changes to trigger a refresh of the FTV. It was incorrectly reacting to the legitimate writes to the history file, treating it as a workspace change that required a full UI refresh. The initial fix was to add `.vscode` to a general exclusion pattern, but this was not specific enough.
-   **Codified Solution & Best Practice:**
    1.  **Be Specific in Watcher Exclusions:** The file watcher logic must be highly specific about what it ignores. The fix was to add an explicit check at the beginning of the `onDidCreate` and `onDidChange` handlers to immediately ignore any event related to the exact path of the history file (`.vscode/dce_history.json`).
    2.  **Example:** `if (normalizedPath.endsWith('.vscode/dce_history.json')) { return; }`. This prevents the watcher from reacting to the extension's own internal state changes while still correctly monitoring user-made changes to the workspace.
    
---

### Case Study 023: FTV Flashing on PCPP Auto-Save

-   **Artifacts Affected:** `src/backend/services/file-tree.service.ts`, `src/client/views/context-chooser.view/view.tsx`
-   **Cycles Observed:** C1, C4, C1, C179, C182, C183, C184
-   **Symptom:** The entire Data Curation file tree view (FTV) flashes or completely reloads, especially in the packaged version of the extension. Logs show a storm of `git state change` events.
-   **Root Cause Analysis (RCA):** The definitive root cause is the `repo.state.onDidChange` event listener in `file-tree.service.ts`. This listener is extremely sensitive and fires for almost any change in the repository, including internal state changes and writes to files listed in `.gitignore` (like `.vscode/dce_history.json`). The original implementation treated this event as a structural change, triggering a full, expensive rebuild of the entire file tree. This created a refresh storm that made the UI unusable.
-   **Codified Solution & Best Practice:** The architectural solution is to **decouple structural refreshes from decoration refreshes**.
    1.  **Structural Changes:** The `FileSystemWatcher` is the source of truth for structural changes (files created, deleted, renamed). It should be the only trigger for a full tree rebuild (`triggerFullRefresh`).
    2.  **Decoration Changes:** The `repo.state.onDidChange` event should only trigger a lightweight update. This involves creating a new `triggerDecorationsUpdate` method that solely re-calculates the Git status and problem maps and sends them to the frontend via a dedicated IPC channel.
    3.  **Frontend State:** The frontend no longer receives Git status as part of the `FileNode` tree structure. Instead, it maintains a separate state map for Git statuses. When it receives a decoration update, it updates this map, causing a cheap re-render that applies the new styles without rebuilding the entire tree. This approach eliminates the flashing by making the most frequent update operation lightweight and non-disruptive.

---

### Case Study 021: Stuck `Baseline` Highlight in Animated Workflow

-   **Artifacts Affected:** `src/client/views/parallel-copilot.view/view.tsx`, `src/backend/services/git.service.ts`
-   **Cycles Observed:** C8, C9, C10, C11, C12
-   **Symptom:** In the animated workflow, after the user selects a response, the `Baseline (Commit)` button is correctly highlighted. After the user clicks it and the baseline is successfully created (confirmed via logs and Git status), the highlight remains on the `Baseline` button and does not advance to the next step (`Select All`).
-   **Root Cause Analysis (RCA):** The frontend UI, which manages the `workflowStep` state, had no reliable way of knowing when the backend Git operation was successfully completed. After an IPC message (`NotifyGitOperationResult`) was implemented, the frontend handler was still failing. The most likely cause is a **stale closure**. The `useEffect` hook that registers the message listener captures the `workflowStep` state at the time it's created. When the message arrives later, the handler's logic checks against this old, stale state (`'awaitingResponseSelect'`), not the current state (`'awaitingBaseline'`), causing the condition to fail and the state transition to be missed.
-   **Codified Solution & Best Practice:**
    1.  **Backend (`git.service.ts`):** The `handleGitBaselineRequest` method must send a specific IPC message (`NotifyGitOperationResult`) back to the PCPP frontend upon completion with a `{ success, message }` payload.
    2.  **Frontend (`view.tsx`):** The message listener for `NotifyGitOperationResult` must be made resilient to stale closures. The state update logic should use the **functional update form** of the state setter (e.g., `setWorkflowStep(prevStep => { ... })`). This guarantees the logic inside the setter is executed with the most recent state, allowing the condition `if (prevStep === 'awaitingBaseline')` to pass correctly and reliably transition the workflow to the next step (`'awaitingFileSelect'`).
    3.  **Workflow Progression:** The rest of the workflow steps (`Select All` -> `Accept Selected` -> `Generate prompt.md` -> `+`) must be driven by subsequent user actions or state changes, each correctly transitioning the `workflowStep` state as defined in `A69`.

---
