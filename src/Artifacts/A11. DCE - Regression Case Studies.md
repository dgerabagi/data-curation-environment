# Artifact A11: DCE - Regression Case Studies
# Date Created: C16
# Author: AI Model & Curator
# Updated on: C92 (Add Cycle 0 bugs)

## 1. Purpose

This document serves as a living record of persistent or complex bugs that have recurred during development. By documenting the root cause analysis (RCA) and the confirmed solution for each issue, we create a "source of truth" that can be referenced to prevent the same mistakes from being reintroduced into the codebase.

## 2. Case Studies

---

### Case Study 046: Prompt Generation Fails for Cycle 0

-   **Artifacts Affected:** `src/backend/services/prompt.service.ts`
-   **Cycles Observed:** C92
-   **Symptom:** In a new workspace, clicking "Generate Initial Artifacts Prompt" fails with the error `Failed to generate prompt.md: Could not find data for current cycle (0) in history.`
-   **Root Cause Analysis (RCA):** The prompt generation logic was designed to fetch a cycle object from the `cycles` array in `dce_history.json`. For a new project, this array is empty. The logic did not account for the special case of Cycle 0, which doesn't exist as a formal cycle entry but whose context is derived from the top-level `projectScope` property in the history file. The service tried to find `cycles[0]`, failed, and threw an error.
-   **Codified Solution & Best Practice:**
    1.  Services handling cycle data must treat Cycle 0 as a special case.
    2.  When a prompt is requested for Cycle 0, the service must not query the `cycles` array. Instead, it should read the `projectScope` from the history file and construct a temporary, in-memory `PcppCycle` object with `cycleId: 0` and `cycleContext: projectScope`.
    3.  This temporary object can then be passed to the downstream prompt-building functions, which can then operate on a consistent data structure.

---

### Case Study 045: Onboarding View State Is Not Persistent

-   **Artifacts Affected:** `src/backend/services/history.service.ts`, `src/client/views/parallel-copilot.view/hooks/useCycleManagement.ts`
-   **Cycles Observed:** C92
-   **Symptom:** In the onboarding view (Cycle 0), typing in the "Project Scope" text area causes the auto-save indicator to spin indefinitely. If the user navigates to another VS Code tab and returns, the text they entered has disappeared.
-   **Root Cause Analysis (RCA):** This was a two-part failure.
    1.  **Backend:** The `saveCycleData` method in `history.service.ts` had a specific branch for `cycleId === 0` that would save the `projectScope` but would then `return` before sending the `NotifySaveComplete` message back to the client. This left the frontend UI stuck in a "saving" state.
    2.  **Frontend:** The `loadCycleData` function in the `useCycleManagement` hook was designed to populate its state from a full `PcppCycle` object. For Cycle 0, the initial object from the backend has an empty `cycleContext`. When the view re-initializes (on tab switch), it doesn't correctly re-load the `projectScope` from the backend into the `cycleContext` state, causing the UI to display an empty string.
-   **Codified Solution & Best Practice:**
    1.  Backend services must provide consistent acknowledgment. The `saveCycleData` function must always send the `NotifySaveComplete` message, regardless of the `cycleId`.
    2.  Frontend state initialization must be robust. The `loadCycleData` function must explicitly handle the Cycle 0 case, ensuring that `cycleContext` is populated from the `projectScope` property received from the backend, not just from the initial `PcppCycle` object.

---

### Case Study 044: Auto-Save Fails After Refactor to Custom Hooks

-   **Artifacts Affected:** `src/client/views/parallel-copilot.view/view.tsx`, `src/client/views/parallel-copilot.view/hooks/useCycleManagement.ts`
-   **Cycles Observed:** C90
-   **Symptom:** After the major refactor of `view.tsx` into a container/hooks architecture, the auto-save functionality stopped working. Typing in any persisted field (e.g., Project Scope, Cycle Context) correctly updates the UI and sets the save status indicator to "unsaved" (caution icon), but the save operation is never triggered, and the indicator never changes to "saving" or "saved".
-   **Root Cause Analysis (RCA):** The refactor successfully moved state management into custom hooks (like `useCycleManagement`). However, the core logic for the debounced save operation, which gathers state from all hooks and sends it to the backend, was lost from the main `view.tsx` container. The `useCycleManagement` hook was correctly detecting state changes and attempting to call a `saveState` function, but the function being passed to it from the container was an empty placeholder, resulting in no action being taken.
-   **Codified Solution & Best Practice:**
    1.  The container component (`view.tsx`) is responsible for orchestrating state from all its child hooks. Therefore, it is also responsible for implementing the master `saveCurrentCycleState` function that aggregates this data.
    2.  This master save function should be wrapped in a `useDebounce` hook within the container to create a stable, debounced version.
    3.  The debounced save function must then be passed down as a prop to any custom hook that needs to trigger a save (e.g., `useCycleManagement`).
    4.  The custom hook's `useEffect` should then call this function prop when its local state becomes "dirty." This pattern correctly separates the concerns of state management (in the hook) from the concern of state persistence orchestration (in the container).

---

### Case Study 043: State Corruption on Cycle Navigation

-   **Artifacts Affected:** `src/backend/services/llm.service.ts`, `src/backend/services/history.service.ts`
-   **Cycles Observed:** C79
-   **Symptom:** After a batch of responses finishes generating for Cycle `N`, if the user navigates to a different cycle (e.g., `N-1`) and then navigates back to Cycle `N`, the UI for Cycle `N` is stuck in the "generating responses" view for all tabs, and the data is inaccessible. Manually inspecting `dce_history.json` reveals that the `status` for Cycle `N` is still `'generating'`.
-   **Root Cause Analysis (RCA):** The backend process correctly updates the status of individual responses to `'complete'` as they finish, but it fails to perform a final update on the parent *cycle* object. When the last response stream ends, the `status` of the `PcppCycle` object in `dce_history.json` is never transitioned from `'generating'` to `'complete'`. When the user navigates away and back, the UI re-reads this stale, incorrect status and incorrectly re-mounts the generation progress view.
-   **Codified Solution & Best Practice:**
    1.  The service responsible for consuming the LLM stream (`llm.service.ts`) must track the completion of the *entire batch*.
    2.  When the final response in the batch is marked as complete, the stream consumer must explicitly call a dedicated method (e.g., `historyService.finalizeCycleStatus(cycleId)`) to update the parent cycle's status in the persistent storage.
    3.  This ensures that the persisted state is always consistent and prevents the UI from loading into a corrupted or invalid state on reload or navigation.

---

### Case Study 042: UI Fails to Advance to New Cycle on Subsequent Generations

-   **Artifacts Affected:** `src/client/views/parallel-copilot.view/view.tsx`, `src/backend/services/history.service.ts`, `src/common/ipc/channels.type.ts`
-   **Cycles Observed:** C74
-   **Symptom:** After successfully completing an initial cycle (e.g., Cycle 1), clicking "Generate responses" correctly creates a `prompt.md` and sends requests to the LLM, but the DCE panel UI remains on Cycle 1. It does not navigate to the new cycle (e.g., Cycle 2) and does not show the generation progress UI.
-   **Root Cause Analysis (RCA):** The backend successfully creates a placeholder for the new cycle, but the frontend's state is stale. The `maxCycle` state variable on the client is not updated after the new cycle is created. When the frontend receives the `StartGenerationUI` message with the `newCycleId`, its internal navigation logic (`handleCycleChange`) prevents the navigation because `newCycleId` is greater than its known `maxCycle`.
-   **Codified Solution & Best Practice:**
    1.  When a new cycle placeholder is created on the backend, the service must return both the `newCycleId` and the new `newMaxCycle` count.
    2.  The IPC message that tells the client to start the generation UI (`StartGenerationUI`) must include both `newCycleId` and `newMaxCycle` in its payload.
    3.  The frontend message handler for `StartGenerationUI` **must** update its `maxCycle` state with the new value *before* it attempts to call the navigation function. This ensures the UI's state is synchronized with the backend's state before any navigation is attempted.

---

### Case Study 041: PCPP View State Lost on Tab Switch

-   **Artifacts Affected:** `src/client/views/parallel-copilot.view/view.tsx`, `src/common/types/vscode-webview.d.ts`
-   **Cycles Observed:** C67, C72
-   **Symptom:** When the user is viewing a specific UI state within the Parallel Co-Pilot Panel (e.g., the "Generation Progress" view), and they switch to another VS Code tab and then return, the panel's view resets to its default state (the main response pane). The user's intended view is lost.
-   **Root Cause Analysis (RCA):** VS Code webviews can be destroyed when they become hidden to conserve resources. When the user returns, the webview is completely re-initialized. Any UI state managed solely within React's `useState` is therefore lost. The correct way to persist UI-specific state for a webview is to use the `acquireVsCodeApi()`'s `getState()` and `setState()` methods, which are managed by the VS Code host and survive the webview's destruction.
-   **Codified Solution & Best Practice:**
    1.  Identify any transient UI state that needs to be persisted (e.g., `activeView: 'main' | 'progress'`).
    2.  Add this state to the `ViewState` interface in `vscode-webview.d.ts`.
    3.  On component mount, use a `useEffect` hook to call `vscode.getState()` to retrieve and restore the persisted UI state.
    4.  Use another `useEffect` hook that listens for changes to that state variable and calls `vscode.setState()` to save it whenever it changes. This ensures the view state is always preserved by the VS Code host.

---

### Case Study 040: Stale Prompt Context in Automated Generation Workflow

-   **Artifacts Affected:** `src/backend/services/prompt.service.ts`, `src/client/views/parallel-copilot.view/on-message.ts`, `src/client/views/parallel-copilot.view/view.tsx`
-   **Cycles Observed:** C67, C71
-   **Symptom:** When using the "Generate responses" button for a new cycle (e.g., Cycle 2), the responses received from the LLM are based on the context of a much older cycle (e.g., Cycle 0), completely ignoring the new information provided by the user in the current cycle (e.g., Cycle 1). Additionally, the UI fails to automatically navigate to the new cycle after generation is complete.
-   **Root Cause Analysis (RCA):** This is a critical workflow failure with two main causes:
    1.  **Stale Data:** The `prompt.service.ts` was not correctly combining the fresh, in-memory `cycleData` (for Cycle `N`) sent from the frontend with the full history read from disk. A logic error caused it to ignore the new `cycleContext` and build the prompt using only the older, persisted data for Cycle `N`.
    2.  **Navigation Failure:** The frontend's message handler for `SendBatchGenerationComplete` was not reliably triggering the navigation to the new cycle (`N+1`), leaving the user on the old cycle view.
-   **Codified Solution & Best Practice:**
    1.  The backend handler for `RequestNewCycleAndGenerate` must use the `cycleData` from the client as the absolute source of truth for the current cycle.
    2.  The `prompt.service.ts` must ensure its logic correctly overwrites any stale data from the history file with the fresh data from the client before assembling the prompt.
    3.  As a best practice for transparency, the generated prompt string should be written to `prompt.md` in the workspace before being sent to the LLM.
    4.  The frontend's `SendBatchGenerationComplete` handler must reliably call the navigation logic to switch the view to the `newCycleId`.