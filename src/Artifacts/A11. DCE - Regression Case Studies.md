# Artifact A11: DCE - Regression Case Studies
# Date Created: C16
# Author: AI Model & Curator
# Updated on: C190 (Expand data loss case study for new cycle creation and navigation)

## 1. Purpose

This document serves as a living record of persistent or complex bugs that have recurred during development. By documenting the root cause analysis (RCA) and the confirmed solution for each issue, we create a "source of truth" that can be referenced to prevent the same mistakes from being reintroduced into the codebase.

**This artifact is the primary log for new and recent case studies.** Older, resolved issues are archived in `A11.1 DCE - New Regression Case Studies.md` to keep this document concise and focused on currently relevant issues.

## 2. Case Studies

---

### Case Study 025: Runtime vs. Build-time Syntax Errors

-   **Artifacts Affected:** `src/client/utils/response-parser.ts`
-   **Cycles Observed:** C188
-   **Symptom:** The Parallel Co-Pilot Panel appears as a completely blank white screen. No errors are visible in the extension host logs, but the webview fails to render any content.
-   **Root Cause Analysis (RCA):** The webview's JavaScript bundle contained a subtle but fatal syntax error that was not caught by the TypeScript/Babel build process. The code attempted to use an invalid form of optional chaining and nullish coalescing (`match?. ?? ''`) when trying to access properties of a regex match object. While the build completed successfully, the browser's JavaScript engine encountered this invalid syntax upon loading the script and immediately threw an `Uncaught SyntaxError`, halting all further execution and preventing React from rendering. The lack of build-time errors made this difficult to diagnose without inspecting the webview's own developer console.
-   **Codified Solution & Best Practice:**
    1.  **Correct Syntax:** The only way to access an element from an array-like object (such as a regex match) using optional chaining is with bracket notation: `match?.[1]`. The invalid `match?.` syntax must be corrected.
    2.  **Best Practice:** When debugging a "blank screen" webview with no backend errors, the first step is always to open the Webview Developer Tools (`Developer: Open Webview Developer Tools` from the Command Palette). This provides access to the client-side console, which will immediately reveal any runtime JavaScript errors that are preventing the application from loading.

---

### Case Study 024: PCPP Context/Title Data Loss or Corruption on Navigation

-   **Artifacts Affected:** `src/client/views/parallel-copilot.view/view.tsx`, `src/backend/services/history.service.ts`
-   **Cycles Observed:** C185, C189, C190, C2, C3
-   **Symptom:** Text entered into the "Cycle Context," "Ephemeral Context," or "Cycle Title" fields is lost or, more critically, data from one cycle is saved over another. This occurs when the user performs an action that reloads the view's state from disk, such as creating a new cycle, switching to a different cycle, or importing a history file. The data is not persisted to `dce_history.json` in time, or the wrong cycle's data is saved, corrupting the history.
-   **Root Cause Analysis (RCA):** This is a critical data integrity bug caused by two related race conditions:
    1.  **Debounced Save vs. State Load:** The application waits for a pause in user input before saving changes to disk (debouncing). When the user navigates to a new cycle, the state is reloaded from `dce_history.json` *before* the debounced save has executed. This causes the UI's current state (with the old cycle's data) to be saved over the newly loaded cycle's data, corrupting the history file.
    2.  **Stale `lastViewedCycleId`:** The application persists the ID of the last cycle the user was viewing. However, this ID was not being updated immediately upon navigation. When the panel re-initialized (e.g., tabbing away and back), the backend would serve the data for the *old, stale* `lastViewedCycleId`, causing the UI to revert to a previous cycle and making the new cycle's content inaccessible.
-   **Codified Solution & Best Practice:**
    1.  **Save Before Navigate:** The event handler for any action that causes a state reload (e.g., `handleCycleChange`, `handleNewCycle`) **must** trigger an immediate, non-debounced save of the current component's state *before* dispatching the request to load the new state.
    2.  **Synchronize `lastViewedCycleId`:** The event handlers for creating a new cycle (`handleNewCycle`) and changing the current cycle (`handleCycleChange`) **must** send an immediate, synchronous IPC message (`SaveLastViewedCycle`) to the backend. The handler for importing history must clear this value. This ensures the backend's record of the last viewed cycle is never stale.
    3.  **Self-Healing Initial Load:** The backend's `getInitialCycle` logic must be self-healing. If a `lastViewedCycleId` is found, it must first verify that a cycle with that ID actually exists in the history file. If it doesn't, the service must ignore the stale ID and fall back to loading the cycle with the highest ID number, ensuring the user always sees valid, accessible data.
    4.  **Save on New Cycle Creation:** The `handleNewCycle` function must perform two synchronous saves: first, it saves the state of the cycle being departed. Second, after setting the state for the new, empty cycle, it must immediately construct the new cycle object and save it to disk. This ensures the new cycle is persisted before any other user action can occur.

---