# Artifact A11: DCE - Regression Case Studies
# Date Created: Cycle 16
# Author: AI Model & Curator
# Updated on: C81 (Add case for corrupted/unsupported document files)

- **Key/Value for A0:**
- **Description:** Documents recurring bugs, their root causes, and codified solutions to prevent future regressions during development.
- **Tags:** bugs, regression, troubleshooting, development, best practices

## 1. Purpose

This document serves as a living record of persistent or complex bugs that have recurred across multiple development cycles. By documenting the root cause analysis (RCA) and the confirmed solution for each issue, we create a "source of truth" that can be referenced to prevent the same mistakes from being reintroduced into the codebase.

## 2. Case Studies

---

### Case Study 007: Corrupted or Unsupported Document Files

-   **Artifacts Affected:** `src/backend/services/fs.service.ts`, `A44. DCE - Phase 1 - Word Document Handling Strategy.md`
-   **Cycles Observed:** 81
-   **Symptom:** Some `.docx` files fail to process with a `Can't find end of central directory` error in the logs, while legacy `.doc` files show an "Unsupported format" message in the UI.
-   **Root Cause Analysis (RCA):** This is not a bug, but rather the system correctly handling invalid inputs.
    1.  **Corrupted `.docx`:** The `.docx` format is a standard zip archive. The parsing library (`mammoth`, which uses `jszip`) throws the "central directory" error when a file is not a valid zip archive. This indicates the source file itself is corrupted or was saved incorrectly.
    2.  **Legacy `.doc`:** The `mammoth` library does not support the old binary `.doc` format. Our documented strategy in `A44` is to explicitly reject these files.
-   **Codified Solution & Best Practice:**
    1.  The error handling in `fs.service.ts` is working as intended.
    2.  The `catch` block in `handleWordToTextRequest` should be enhanced to check for the specific "central directory" error message.
    3.  When this specific error is caught, a more user-friendly message like "File appears to be corrupted or is not a valid .docx format" should be sent to the frontend.
    4.  The system should continue to correctly identify `.doc` files and send the "Legacy .doc format not supported" message. This confirms the system is robust against invalid user inputs.

---

### Case Study 006: Special File Type Caching Fails on Initialization

-   **Artifacts Affected:** `src/client/views/context-chooser.view/view.tsx`, `src/backend/services/fs.service.ts`
-   **Cycles Observed:** 65, 66, 75, 76, 78, 79
-   **Symptom:** When the extension loads and restores the previous selection, special file types (`.pdf`, `.xlsx`, `.docx`) have a token count of 0. When "Flatten Context" is clicked, the output shows `<!-- content not processed or cached -->`. The caching only works if the user manually un-checks and re-checks the file.
-   **Root Cause Analysis (RCA):** The frontend was experiencing a **race condition**. The `ApplySelectionSet` message (containing the paths to restore) was being received and processed *before* the `SendWorkspaceFiles` message (containing the file tree data). The pre-warming logic would attempt to find the file nodes for the restored paths in the frontend's `files` state, but this state was still empty. This failure was confirmed by the log `[WebView] [CACHE-FIX] File tree not loaded yet, cannot pre-warm cache.` The initial fix attempt in C79 was also flawed because it relied on a `useEffect` with a stale closure over the empty `files` state.
-   **Codified Solution & Best Practice:**
    1.  **Decouple and Defer Pre-warming:** The logic must be architected to handle asynchronous data arrival gracefully.
    2.  **Use a Trigger State:** In `view.tsx`, the `ApplySelectionSet` message handler should do nothing more than set two state variables: one for the `checkedFiles` (for the UI) and a separate "trigger" state (e.g., `selectionToPrewarm: string[]`).
    3.  **Use a Multi-Dependency `useEffect`:** A dedicated `useEffect` hook must be created to perform the pre-warming logic. Its dependency array **must** include both the trigger state and the file tree state (e.g., `[selectionToPrewarm, files]`).
    4.  This ensures the pre-warming code only executes when both the selection and the file tree data are guaranteed to be present, eliminating the race condition. After executing, the trigger state should be reset to `null` to prevent re-runs.
    5.  **Logging is critical:** The backend handlers in `fs.service.ts` must have detailed `[CACHE] HIT/MISS/SUCCESS/FAIL` logs to confirm that the pre-warming requests from the frontend are being received and processed correctly.

---

### Case Study 005: Spacebar De-selects Wrong Parent Folder
-   **Artifacts Affected:** `src/client/components/file-tree/FileTree.utils.ts`
-   **Cycles Observed:** 61, 68
-   **Symptom:** When a parent folder (e.g., `src`) is checked, focusing on a deeply nested descendant file (e.g., `src/components/menus/file.ts`) and pressing the spacebar causes a mid-level parent folder (e.g., `src/components`) to be de-selected instead of just the single focused file.
-   **Root Cause Analysis (RCA):** The logic for a "subtractive uncheck" in `addRemovePathInSelectedFiles` was flawed. It correctly identified the selected ancestor (e.g., `src`) but then attempted to re-add only its *direct children*, failing to handle nested structures. It would incorrectly identify which direct child to exclude based on the deep file path, leading to the removal of an entire subdirectory from the selection.
-   **Codified Solution & Best Practice:**
    1.  The `addRemovePathInSelectedFiles` function was refactored for the "subtractive uncheck" case.
    2.  The new logic is more explicit and reliable:
        *   Remove the high-level ancestor path (e.g., `src`) from the selection set.
        *   Get a list of **all descendant files** of that ancestor.
        *   Add all of these descendant files to the selection set, **except for the specific file that was the target of the uncheck action**.
    3.  This correctly translates the selection from a single high-level path (`src`) into many individual low-level file paths, minus the one the user explicitly removed, preserving their intent perfectly.

---

### Case Study 004: Spacebar De-selects Parent Folder Instead of File

-   **Artifacts Affected:** `src/client/components/file-tree/FileTree.utils.ts`
-   **Cycles Observed:** 61
-   **Symptom:** When a parent folder (e.g., `src`) is checked, focusing on a descendant file (e.g., `src/components/file.ts`) and pressing the spacebar causes the entire sub-folder (`src/components`) to be removed from the selection, rather than just the single file.
-   **Root Cause Analysis (RCA):** The logic for a "subtractive uncheck" was flawed. When attempting to uncheck a child of an already-selected parent, the utility function would correctly remove the parent from the selection set but would then re-add the parent's *direct children* except for the one containing the target file. This was too aggressive and did not correctly represent the user's intent to remove only a single file.
-   **Codified Solution & Best Practice:**
    1.  The `addRemovePathInSelectedFiles` function was refactored for the "subtractive uncheck" case.
    2.  The new logic is more explicit:
        *   Remove the ancestor path (e.g., `src`) from the selection.
        *   Get a list of **all descendant files** of that ancestor.
        *   Add all descendant files to the selection, **except for the specific file that was unchecked**.
    3.  This correctly translates the selection from a single high-level path (`src`) into many individual low-level paths, minus the one the user removed, preserving their intent.

---

### Case Study 003: Incorrect File Count in Flatten Success Message

-   **Artifacts Affected:** `src/backend/services/flattener.service.ts`
-   **Cycles Observed:** 61
-   **Symptom:** The success message after flattening (e.g., "Successfully flattened X files...") shows an incorrect count of files, often higher than what was actually selected and written.
-   **Root Cause Analysis (RCA):** The `flattener.service` was using the count of all unique file paths it was *initially given* for the success message. This list could include paths that were later filtered out (e.g., binary files before metadata handling was implemented) or files that failed to be read. The message did not reflect the final count of files successfully processed and written to the output file.
-   **Codified Solution & Best Practice:**
    1.  The `generateOutputContent` function is responsible for creating the final string to be written to disk. It already has access to the array of successfully processed file results.
    2.  The `vscode.window.showInformationMessage` call inside the `flatten` method was modified to use the `length` of this final, validated list of results (`validResults.length`) instead of the initial input list. This ensures the user is always shown the exact number of files included in the output.

---

### Case Study 002: Checkbox State Management in File Tree

-   **Artifacts Affected:** `src/client/components/file-tree/FileTree.utils.ts`, `src/client/components/file-tree/FileTree.tsx`
-   **Cycles Observed:** 14, 15, 16
-   **Symptom:** Checkbox functionality in the file tree is erratic. Only the root checkbox works as expected, but individual files or sub-folders cannot be checked or unchecked correctly. Clicking a checkbox on a child of an already-selected folder fails to deselect it.
-   **Root Cause Analysis (RCA):**
    The core issue was overly complex and flawed state management logic within the `addRemovePathInSelectedFiles` utility function. The logic attempted to handle the "unchecking a child of a selected parent" case by removing the parent and re-adding all of its other children (the "siblings"). This approach was brittle and failed to correctly calculate the new state, leading to a UI that did not update correctly. The complexity made the function difficult to debug and maintain.

-   **Codified Solution & Best Practice:**
    1.  **Simplify State Logic:** The state management logic was rewritten to be more direct and declarative, using a `Set` for efficient manipulation of selected paths.
    2.  **Handle Cases Explicitly:** The new function explicitly handles the three primary user actions:
        *   **CHECK:** When a node is checked, any of its descendants that are already in the selection are removed, and the node's own path is added. This ensures the most senior selected path is always the one stored in state.
        *   **UNCHECK (Direct):** When a node that is explicitly in the selection list is unchecked, its path and the paths of all its descendants are removed.
        *   **UNCHECK (Subtractive):** When a node is unchecked because its parent was checked, the parent is removed from the selection. Then, all of the parent's direct children *except for the one that was clicked* are added to the selection. This correctly "subtracts" the item from the parent's group selection without complex traversals.
    3.  **Robust Event Handling:** Ensure the checkbox `onChange` handler in the React component uses `event.stopPropagation()` to prevent the click event from bubbling up and triggering other actions, such as folder expansion.

-   **Example of Flawed Logic (Conceptual):**
    ```typescript
    // OLD LOGIC
    if (unchecking a child of a selected parent) {
      // 1. Remove parent from selected list.
      // 2. Traverse the entire tree from the parent.
      // 3. Add every descendant of the parent back, EXCEPT the clicked child.
      // This was inefficient and error-prone.
    }
    ```

-   **Example of Correct Logic (Conceptual):**
    ```typescript
    // NEW LOGIC
    if (unchecking a child of a selected parent) {
      // 1. Remove the parent from the selection set.
      const parentNode = findParentNode(clickedPath);
      // 2. Add all of the parent's *direct children* to the selection set,
      //    except for the clicked child itself.
      parentNode.children.forEach(child => {
        if (child.path !== clickedPath) {
          selectionSet.add(child.path);
        }
      });
    }
    ```

---

### Case Study 001: `path.sep` Usage in Frontend Components

-   **Artifacts Affected:** `src/client/components/file-tree/FileTree.tsx`
-   **Cycles Observed:** 13, 14, 16
-   **Symptom:** The webpack build process fails with TypeScript errors similar to `TS2339: Property 'sep' does not exist on type 'string'`.
-   **Root Cause Analysis (RCA):**
    The error occurs when frontend code (React components running in a webview) attempts to use `path.sep`. The `path` module is a core part of the Node.js runtime, but it does not exist in the browser-like context of a webview.
-   **Codified Solution & Best Practice:**
    1.  **Strict Environment Separation:** All file system path manipulation **must** occur in the backend (`src/backend/`).
    2.  **Normalized Paths:** The backend must normalize all paths to use forward slashes (`/`) before sending them to the frontend.
    3.  **Frontend Simplicity:** The frontend code must treat all file paths as simple strings and should never attempt to parse or join them using path-specific separators.