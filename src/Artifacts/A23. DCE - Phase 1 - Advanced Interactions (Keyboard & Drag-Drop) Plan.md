# Artifact A23: DCE - Phase 1 - Advanced Interactions (Keyboard & Drag-Drop) Plan
# Date Created: C29
# Author: AI Model
# Updated on: C34 (Revised Drag-and-Drop strategy to use HTML5 API in Webview)

- **Key/Value for A0:**
- **Description:** Details the requirements for implementing full keyboard navigation and drag-and-drop file/folder operations within the main file tree view.
- **Tags:** feature plan, keyboard navigation, drag and drop, file operations, accessibility, ux, phase 1

## 1. Overview & Goal

To achieve true feature parity with the native VS Code Explorer and cater to power users, the Data Curation Environment must support advanced interactions. This plan outlines the requirements for two major features: full keyboard navigation for accessibility and speed, and drag-and-drop functionality for intuitive file system manipulation.

## 2. User Stories

| ID | User Story | Acceptance Criteria |
|---|---|---|
| AI-01 | **Keyboard Navigation** | As a power user, I want to navigate the file tree using only my keyboard, so I can find, select, and manage files without taking my hands off the keyboard. | - Arrow Up/Down keys move the focus between visible nodes. <br> - Arrow Right on a collapsed folder expands it. <br> - Arrow Right on an open folder or file moves focus to the first child. <br> - Arrow Left on an open folder collapses it. <br> - Arrow Left on a child node moves focus to its parent. <br> - `Enter` key opens the focused file or toggles expansion for a focused folder. <br> - `Spacebar` toggles the checkbox of the focused node. |
| AI-02 | **Drag-and-Drop File Operations** | As a user, I want to be able to drag a file or folder and drop it into another folder to move it, so I can reorganize my project intuitively. | - Clicking and dragging a file or folder in the tree initiates a drag operation. <br> - Dragging over a folder highlights it as a potential drop target. <br> - Dropping a file/folder onto another folder moves the dragged item into the target folder. <br> - The backend file system is updated, and the tree view refreshes to reflect the new structure. <br> - The "checked" status of the moved file/folder is preserved. |

## 3. Technical Implementation Plan

### Keyboard Navigation (Future Cycle)

1.  **Focus Management (Frontend):**
    *   A new state variable, `focusedNodePath: string | null`, will be added to `view.tsx` to track the currently focused node.
    *   The `TreeView.tsx` component will need a wrapper `div` with a `tabIndex={0}` to make it focusable.
    *   An `onKeyDown` event handler will be attached to this wrapper.
2.  **Event Handling (`TreeView.tsx`):**
    *   The `onKeyDown` handler will contain a `switch` statement for `event.key`.
    *   It will calculate the next node to focus based on the current `focusedNodePath` and the tree structure. This requires creating a flattened, ordered list of visible nodes.
    *   It will call state update functions to change `focusedNodePath`, `expandedNodes`, or `checkedPaths` accordingly.
    *   It will call `event.preventDefault()` to stop the default browser behavior for arrow keys (scrolling).

### Drag and Drop (Current Cycle - Webview Implementation)

This feature will be implemented using the standard HTML5 Drag and Drop API within the React webview, bypassing the need for a native `TreeDataProvider`.

1.  **Frontend - Event Handling (`TreeView.tsx` & `view.scss`):**
    *   Make file/folder list items draggable by adding `draggable="true"` to the `<li>` element.
    *   **`onDragStart`:** When a drag begins, store the `absolutePath` of the dragged node in a state variable or a ref.
    *   **`onDragEnter` / `onDragOver` / `onDragLeave`:** These events will be used for visual feedback. When dragging over a folder, add a `.drop-target` CSS class to highlight it. The `onDragOver` handler must call `event.preventDefault()` to allow a drop.
    *   **`onDrop`:** When the user drops the item:
        *   Identify the drop target node (the folder).
        *   Get the source path (from `onDragStart`) and the destination folder path.
        *   Construct the `newPath` for the moved file/folder.
        *   Send a new `ClientToServerChannel.RequestMoveFile` IPC message to the backend with `{ oldPath, newPath }`.
        *   Remove any drop-target highlighting.

2.  **IPC Channels (`channels.enum.ts` & `channels.type.ts`):**
    *   Create a new `ClientToServerChannel.RequestMoveFile` channel.
    *   The body will be `{ oldPath: string, newPath: string }`.

3.  **Backend - File Operation (`fs.service.ts`):**
    *   Create a new `handleMoveFileRequest` method.
    *   This method will receive the `oldPath` and `newPath`.
    *   It will convert these string paths to `vscode.Uri` objects.
    *   It will perform the move using `vscode.workspace.fs.rename(oldUri, newUri)`.
    *   After a successful rename, it will call the `SelectionService` to update the persisted state.

4.  **Backend - Preserve Selection State (`selection.service.ts`):**
    *   Create a new method `updatePathInSelections(oldPath, newPath)`.
    *   This method will:
        *   Fetch the last active selection and all named selection sets from `workspaceState`.
        *   Iterate through each list of paths.
        *   If a path in a list exactly matches `oldPath`, it will be replaced with `newPath`.
        *   If a path in a list is a descendant of `oldPath` (i.e., a file inside a moved folder), its path will be reconstructed based on the `newPath`.
        *   Save the updated selection lists back to `workspaceState`.
    *   This ensures that if `diff1.tsx` was checked, after moving it to `test1/`, the new path `.../test1/diff1.tsx` will be in the selection list. The file watcher will then trigger a UI refresh, and the frontend will load the updated selection.