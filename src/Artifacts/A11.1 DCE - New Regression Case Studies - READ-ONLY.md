# Artifact A11.1: DCE - New Regression Case Studies
# Date Created: C1
# Author: AI Model & Curator
# Updated on: C65 (Add Malformed JSON Array case study)

- **Key/Value for A0:**
- **Description:** A separate log for new regression case studies to avoid bloating the original A11 artifact.
- **Tags:** bugs, regression, troubleshooting, development, best practices

## 1. Purpose

This document serves as a living record of persistent or complex bugs that have recurred during development. By documenting the root cause analysis (RCA) and the confirmed solution for each issue, we create a "source of truth" that can be referenced to prevent the same mistakes from being reintroduced into the codebase.

Add new Case Studies to A11, not to this artifact. Thats the point of splitting in the first place.

**This artifact is the historical archive for older case studies.** New, active issues should be logged in `A11. DCE - Regression Case Studies.md`. This separation keeps the primary document focused and manageable in size.

## 2. Case Studies

---

### Case Study 041: Malformed JSON Array in LLM Responses

-   **Artifacts Affected:** `src/client/utils/response-parser.ts`
-   **Cycles Observed:** C65
-   **Symptom:** When using "Demo Mode" with a local vLLM, many responses fail to parse. The parser reports a generic failure, even though the response appears to be mostly correct JSON.
-   **Root Cause Analysis (RCA):** The LLM, while correctly generating the `summary` and `course_of_action` fields, was frequently failing to generate a valid JSON array for the `files` property. Instead of a comma-separated list of objects within `[]`, it would often output a series of concatenated, independent JSON objects, sometimes with extra closing braces. This malformed structure caused the standard `JSON.parse()` call to fail.
-   **Codified Solution & Best Practice:**
    1.  **Implement a Hybrid Parser:** A single parsing strategy is too brittle for inconsistent LLM output. The parser was refactored into a multi-stage process.
    2.  **Stage 1 (Strict JSON):** Attempt to parse the entire string with `JSON.parse()`. This handles the "perfect" cases.
    3.  **Stage 2 (Hybrid Regex Fallback):** If Stage 1 fails, enter a hybrid mode. Use targeted, less-strict regular expressions to find and extract the JSON-like content of the `summary`, `course_of_action`, and `curator_activity` fields. Then, use a global regex to find all occurrences of the file object pattern (e.g., `{"path": "...", "content": "..."}`). These individually extracted, valid parts are then assembled into a valid `ParsedResponse` object.
    4.  **Stage 3 (XML Fallback):** If both JSON-based methods fail, fall back to the original regex parser that looks for XML-style tags.
    5.  **Best Practice:** When parsing LLM output that is intended to be structured, do not assume the structure will always be perfect. Implement a layered parsing strategy that can gracefully degrade from strict parsing (e.g., `JSON.parse`) to more flexible methods (like targeted regex) to maximize the success rate and recover as much data as possible from partially correct responses.

---

### Case Study 040: SSE Stream Parsing Fails with `invalid index: undefined`

-   **Artifacts Affected:** `src/backend/services/llm.service.ts`
-   **Cycles Observed:** C58
-   **Symptom:** When receiving a streamed batch response from the vLLM server, the DCE logs are spammed with `[WARN] Received chunk with invalid index: undefined`. No response content is displayed in the UI.
-   **Root Cause Analysis (RCA):** The stream parser in `llm.service.ts` was incorrectly attempting to access `chunk.index` at the top level of the JSON payload arriving in each Server-Sent Event (SSE) chunk. The OpenAI-compatible streaming protocol, which vLLM implements, nests this value at `chunk.choices[0].index`. The parser was therefore getting `undefined` for the index and could not correctly assign the content delta to its corresponding response buffer.
-   **Codified Solution & Best Practice:**
    1.  The SSE stream parser must correctly destructure the nested `choices` array to access the `index` and `delta` properties for each chunk. The correct access pattern is `parsedJson.choices[0].index`.
    2.  The parser must also be robust enough to handle multiple `data:` lines arriving in a single stream buffer. The incoming buffer should be split by newline characters (`\n`), and each resulting line should be processed individually to check if it starts with `data:`.

---