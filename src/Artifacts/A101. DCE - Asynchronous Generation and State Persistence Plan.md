# Artifact A101: DCE - Asynchronous Generation and State Persistence Plan
# Date Created: C67
# Author: AI Model & Curator
# Updated on: C78 (Add per-response status field)

- **Key/Value for A0:**
- **Description:** Documents the new, more robust workflow for generating responses. This involves creating a new cycle with a "generating" status first, which provides a persistent state container for the asynchronous LLM call, making the UI state recoverable on reload.
- **Tags:** plan, architecture, workflow, persistence, asynchronous, state management

## 1. Problem Statement

The "Generate responses" feature currently suffers from two critical flaws:
1.  **Stale Prompts:** The backend sometimes generates the `prompt.md` using a stale version of the cycle data from the `dce_history.json` file, ignoring the user's most recent (unsaved) changes in the UI.
2.  **Lack of UI Persistence:** If the user switches away from the PCPP tab while responses are streaming in, the response generation UI disappears. When they return, the UI does not reappear, even though the generation process continues in the background. This is because the webview is re-initialized and loses its transient `isGenerating` state.

## 2. The New Workflow: Create-Then-Generate

To solve both issues, the workflow will be re-architected to be stateful and persistent.

1.  **Initiate:** The user, on Cycle `N`, clicks "Generate responses".
2.  **Create Placeholder:** The frontend sends a `RequestNewCycleAndGenerate` message to the backend. The backend's first action is to immediately create and save a new **Cycle `N+1`** in `dce_history.json`. This new cycle has a special status, e.g., `status: 'generating'`, and each of its `PcppResponse` objects also has its status set to `'generating'`.
3.  **Start UI:** The backend immediately responds to the frontend with a `StartGenerationUI` message, containing the ID of the new cycle (`N+1`).
4.  **Navigate & Display:** The frontend navigates to Cycle `N+1` and, seeing the `generating` status, displays the `GenerationProgressDisplay` component.
5.  **Asynchronous Generation:** *In parallel*, the backend uses the data from the original Cycle `N` (which was sent with the initial request) to generate the prompt and start the LLM call.
6.  **Save Progress:** As response chunks stream in, the backend saves them directly into the placeholder Cycle `N+1` in `dce_history.json`.
7.  **Completion:** When generation is complete, the backend updates the status of Cycle `N+1` from `generating` to `complete`, and also updates the status of each individual response.

## 3. Benefits of this Architecture

-   **Fixes Stale Prompts:** The prompt for Cycle `N+1` is generated using the fresh, in-memory data from Cycle `N` that was sent directly from the client, guaranteeing it's up-to-date.
-   **Fixes UI Persistence:** The `isGenerating` state is no longer a transient boolean in the UI. It's now a persistent `status` field in the cycle data itself. If the user navigates away and back, the extension will load the latest cycle (N+1), see its status is `generating`, and automatically re-display the progress UI, which will be populated with the latest progress saved in the history file.
-   **Enables Granular Control:** Storing the status on each individual response allows for single-tab regeneration without disrupting the state of other tabs.

## 4. Technical Implementation Plan

1.  **Data Model (`pcpp.types.ts`):**
    *   Add a `status?: 'complete' | 'generating'` property to the `PcppCycle` interface.
    *   Add a `status?: 'pending' | 'generating' | 'complete' | 'error'` property to the `PcppResponse` interface.
2.  **IPC Channels:** Add `RequestNewCycleAndGenerate` and `StartGenerationUI`.
3.  **Backend (`history.service.ts`):** Create a `createNewCyclePlaceholder` method to create the new cycle with `status: 'generating'`. Update `saveCycleData` to handle partial progress updates for a generating cycle.
4.  **Backend (`on-message.ts`):** Implement the new handler for `RequestNewCycleAndGenerate` to orchestrate this workflow.
5.  **Frontend (`view.tsx`):**
    *   Update the "Generate responses" button to use the new IPC channel.
    *   Add a handler for `StartGenerationUI`.
    *   Update the main rendering logic: if the currently loaded cycle has `status === 'generating'`, render the `GenerationProgressDisplay` component. The logic will be further refined to check the status of the *active tab* for single-response regeneration.