# Artifact A11.1: DCE - New Regression Case Studies
# Date Created: C1
# Author: AI Model & Curator
# Updated on: C47 (Add case study for useCallback dependency loop)

- **Key/Value for A0:**
- **Description:** A separate log for new regression case studies to avoid bloating the original A11 artifact.
- **Tags:** bugs, regression, troubleshooting, development, best practices

## 1. Purpose

This document serves as a living record of persistent or complex bugs that have recurred during development. By documenting the root cause analysis (RCA) and the confirmed solution for each issue, we create a "source of truth" that can be referenced to prevent the same mistakes from being reintroduced into the codebase.

**This artifact is the historical archive for older case studies.** New, active issues should be logged in `A11. DCE - Regression Case Studies.md`. This separation keeps the primary document focused and manageable in size.

## 2. Case Studies

---

### Case Study 041: UI Input Wiped Due to `useCallback` Dependency Loop

-   **Artifacts Affected:** `src/client/views/parallel-copilot.view/view.tsx`
-   **Cycles Observed:** C47
-   **Symptom:** In the Cycle 0 onboarding view, any character typed into the "Project Scope" `textarea` is immediately deleted. The debug console shows a flood of `RequestInitialCycleData` messages.
-   **Root Cause Analysis (RCA):** A subtle but critical infinite re-render loop was created by a chain of dependencies between React hooks.
    1.  Typing in the `textarea` called a handler that updated the `saveStatus` state to `'unsaved'`.
    2.  A `useCallback` hook for the `handleCycleChange` function had `saveStatus` in its dependency array. When `saveStatus` changed, `handleCycleChange` received a new function reference.
    3.  A main, top-level `useEffect` hook, responsible for initialization and message listeners, had `handleCycleChange` in its dependency array.
    4.  Because `handleCycleChange`'s reference changed, the entire `useEffect` hook was re-executed.
    5.  This re-execution would call `RequestInitialCycleData`, which reloaded all state from the backend, wiping out the user's input and starting the cycle over again.
-   **Codified Solution & Best Practice:** `useCallback` dependency arrays must be minimal to prevent unintended re-creations of memoized functions. The check for `saveStatus` inside the `handleCycleChange` callback was redundant, as the UI buttons that call it are already disabled based on `saveStatus`. Removing the check and the dependency from the `useCallback` array broke the infinite loop and fixed the bug. Always ensure that state updates do not inadvertently cause cascading re-creations of memoized functions that are dependencies of top-level effects.

---

### Case Study 040: UI State Instability Caused by Overactive useEffect Dependencies
-   **Artifacts Affected:** `src/client/views/parallel-copilot.view/view.tsx`
-   **Cycles Observed:** C46
-   **Symptom:** Multiple, severe UI bugs occurring simultaneously:
    1.  Text deleted from a `<textarea>` immediately reappears.
    2.  A toggle button (`Parse All`) visually reverts its state immediately after being clicked.
    3.  The debug console is flooded with logs from an expensive operation (e.g., cost calculation) on every single keystroke.
-   **Root Cause Analysis (RCA):** This cascade of failures was caused by a single flawed `useEffect` hook. An expensive, debounced operation (`requestCostEstimation`) had a dependency on a large, frequently-changing state object (the `tabs` object, which contained the raw content of all response text areas). Because this dependency was not specific, any change to the text in any tab would trigger the effect. This initiated a constant cycle of re-renders which, in turn, reverted any UI state changes (like text deletion or a toggle button's state) back to the last-known state *before* the user's action was fully processed and persisted.
-   **Codified Solution & Best Practice:** `useEffect` hooks for expensive or derived computations must have a minimal and precise dependency array.
    1.  **Be Specific:** The dependency array should only include the specific primitive values that the effect's logic actually depends on.
    2.  **Avoid Large Objects:** Do not list large, complex state objects (like `tabs`) in a dependency array if the effect only cares about a small piece of data within that object. Instead, derive the specific data point with `useMemo` and list that in the dependency array, or pass it directly.
    3.  **The Fix:** The dependency array for the cost calculation was changed from `[..., tabs]` to `[..., cycleContext, ephemeralContext, selectedResponseId]`. This ensures the expensive calculation only runs when the actual inputs to the prompt change, not on every keystroke in an unrelated `textarea`. This stabilized the component and fixed all three downstream bugs.

---

### Case Study 001: PCPP Context Textarea Instability
(No change from C187)

---

### Case Study 002: FTV Flashing on PCPP Auto-Save
(No change from C187)

---
... (rest of the file remains the same) ...