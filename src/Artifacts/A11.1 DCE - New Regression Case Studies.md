# Artifact A11.1: DCE - New Regression Case Studies
# Date Created: C1
# Author: AI Model & Curator
# Updated on: C46 (Add case study for overactive useEffect)

- **Key/Value for A0:**
- **Description:** A separate log for new regression case studies to avoid bloating the original A11 artifact.
- **Tags:** bugs, regression, troubleshooting, development, best practices

## 1. Purpose

This document serves as a living record of persistent or complex bugs that have recurred during development. By documenting the root cause analysis (RCA) and the confirmed solution for each issue, we create a "source of truth" that can be referenced to prevent the same mistakes from being reintroduced into the codebase.

**This artifact is the historical archive for older case studies.** New, active issues should be logged in `A11. DCE - Regression Case Studies.md`. This separation keeps the primary document focused and manageable in size.

## 2. Case Studies

---

### Case Study 040: UI State Instability Caused by Overactive useEffect Dependencies

-   **Artifacts Affected:** `src/client/views/parallel-copilot.view/view.tsx`
-   **Cycles Observed:** C46
-   **Symptom:** Multiple, severe UI bugs occurring simultaneously:
    1.  Text deleted from a `<textarea>` immediately reappears.
    2.  A toggle button (`Parse All`) visually reverts its state immediately after being clicked.
    3.  The debug console is flooded with logs from an expensive operation (e.g., cost calculation) on every single keystroke.
-   **Root Cause Analysis (RCA):** This cascade of failures was caused by a single flawed `useEffect` hook. An expensive, debounced operation (`requestCostEstimation`) had a dependency on a large, frequently-changing state object (the `tabs` object, which contained the raw content of all response text areas). Because this dependency was not specific, any change to the text in any tab would trigger the effect. This initiated a constant cycle of re-renders which, in turn, reverted any UI state changes (like text deletion or a toggle button's state) back to the last-known state *before* the user's action was fully processed and persisted.
-   **Codified Solution & Best Practice:** `useEffect` hooks for expensive or derived computations must have a minimal and precise dependency array.
    1.  **Be Specific:** The dependency array should only include the specific primitive values that the effect's logic actually depends on.
    2.  **Avoid Large Objects:** Do not list large, complex state objects (like `tabs`) in a dependency array if the effect only cares about a small piece of data within that object. Instead, derive the specific data point with `useMemo` and list that in the dependency array, or pass it directly.
    3.  **The Fix:** The dependency array for the cost calculation was changed from `[..., tabs]` to `[..., cycleContext, ephemeralContext, selectedResponseId]`. This ensures the expensive calculation only runs when the actual inputs to the prompt change, not on every keystroke in an unrelated `textarea`. This stabilized the component and fixed all three downstream bugs.

---

### Case Study 001: PCPP Context Textarea Instability
(No change from C187)

---

### Case Study 002: FTV Flashing on PCPP Auto-Save
(No change from C187)

---
... (rest of the file remains the same) ...