# Artifact A39: DCE - Phase 2 - Cycle Navigator - Technical Plan
# Date Created: C70
# Author: AI Model

- **Key/Value for A0:**
- **Description:** Details the technical approach for implementing the Cycle Navigator, including data structures for storing cycle-specific responses and the state management for historical navigation.
- **Tags:** feature plan, phase 2, technical plan, architecture, state management, data model

## 1. Overview

This document outlines the technical strategy for implementing the Cycle Navigator feature. The implementation will require new data structures for storing historical responses, enhancements to the frontend state management, new IPC channels, and backend logic for data persistence.

## 2. Data Structure and Persistence

A structured approach to storing the historical data is critical. A simple JSON file stored within the workspace's `.vscode` directory is a suitable starting point.

### 2.1. `dce_history.json` (Example)

```json
{
  "version": 1,
  "cycles": [
    {
      "cycleId": "C69",
      "timestamp": "2025-08-19T10:00:00Z",
      "prompt": "The full prompt text for cycle 69...",
      "responses": [
        {
          "responseId": "uuid-v4-for-response-1",
          "model": "gemini-pro",
          "content": "<src/file1.ts>...</src/file1.ts>"
        },
        {
          "responseId": "uuid-v4-for-response-2",
          "model": "claude-3-opus",
          "content": "<src/file1.ts>...</src/file1.ts>"
        }
      ]
    },
    {
      "cycleId": "C70",
      "timestamp": "2025-08-20T12:30:00Z",
      "prompt": "The prompt for cycle 70...",
      "responses": [
        {
          "responseId": "uuid-v4-for-response-3",
          "model": "gemini-pro",
          "content": "<src/client/views/view.tsx>...</src/client/views/view.tsx>"
        }
      ]
    }
  ]
}
```

*   **Backend (`history.service.ts` - New):** A new service will be created to manage reading from and writing to `dce_history.json`. It will handle file locking to prevent race conditions and provide methods like `getCycle(cycleId)` and `addResponse(cycleId, response)`.

## 3. Frontend State Management (`parallel-copilot.view.tsx`)

The main view's state will be expanded to manage the historical context.

```typescript
interface CoPilotState {
  // ... existing state for tabs ...
  currentCycleId: string;
  cycleHistory: string[]; // An ordered list of all known cycle IDs, e.g., ["C69", "C70"]
}
```

*   `currentCycleId` will drive the UI display and data fetching.
*   The navigation buttons will simply increment or decrement the index within the `cycleHistory` array to determine the next `currentCycleId`.
*   Changing `currentCycleId` will trigger a `useEffect` hook to request the data for that cycle from the backend.

## 4. IPC Communication

New channels will be needed to orchestrate the data flow.

*   `ClientToServerChannel.RequestCycleData`:
    *   **Payload:** `{ cycleId: string }`
    *   **Action:** Frontend requests the full data object for a specific cycle from the backend.
*   `ClientToServerChannel.RequestCycleHistory`:
    *   **Payload:** `{}`
    *   **Action:** Frontend requests the ordered list of all available cycle IDs to populate its navigation state.
*   `ClientToServerChannel.SaveResponse`:
    *   **Payload:** `{ cycleId: string, response: { responseId: string, model: string, content: string } }`
    *   **Action:** Frontend sends a new AI response to the backend to be persisted in the history file.
*   `ServerToClientChannel.SendCycleData`:
    *   **Payload:** `{ cycleData: Cycle }` // Where Cycle is the object from the JSON file
    *   **Action:** Backend sends the requested cycle data to the frontend.
*   `ServerToClientChannel.SendCycleHistory`:
    *   **Payload:** `{ history: string[] }`
    *   **Action:** Backend sends the list of all cycle IDs.

## 5. Workflow Integration

1.  **On Load:** The Parallel Co-Pilot view requests the full cycle history. It defaults `currentCycleId` to the last item in the received list.
2.  **On Navigate:** Clicking `<` or `>` changes `currentCycleId`. A `useEffect` hook detects this change and sends `RequestCycleData` to the backend. The backend's `SendCycleData` response triggers a state update that re-renders the tabs with the historical content.
3.  **On New Response:** When a new AI response is received (in the future, via API), it will be displayed in a tab and simultaneously sent to the backend via `SaveResponse` to be added to the `dce_history.json` file for the current cycle.