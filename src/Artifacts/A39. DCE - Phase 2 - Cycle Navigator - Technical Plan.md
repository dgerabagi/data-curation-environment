# Artifact A39: DCE - Phase 2 - Cycle Navigator - Technical Plan
# Date Created: C70
# Author: AI Model
# Updated on: C92 (Revise initialization flow to fix persistence issues)

- **Key/Value for A0:**
- **Description:** Details the technical approach for implementing the Cycle Navigator, including data structures for storing cycle-specific responses and the state management for historical navigation.
- **Tags:** feature plan, phase 2, technical plan, architecture, state management, data model

## 1. Overview

This document outlines the technical strategy for implementing the Cycle Navigator and PCPP persistence. The implementation will require a structured data format for storing historical data, enhancements to the frontend state management, new IPC channels, and robust backend logic for data persistence. The key change in this revision is a new initialization flow to make the backend the single source of truth, resolving state loss on reload or window pop-out.

## 2. Data Structure and Persistence

A structured approach to storing the historical data is critical. A simple JSON file stored within the workspace's `.vscode` directory is a suitable starting point.

### 2.1. `dce_history.json` (Example)

```json
{
  "version": 1,
  "cycles": [
    {
      "cycleId": 91,
      "timestamp": "2025-08-20T12:30:00Z",
      "title": "Initial implementation",
      "cycleContext": "Long-term notes...",
      "ephemeralContext": "<console_log>...</console_log>",
      "responses": {
        "1": { "content": "<src/client/views/view.tsx>...</file>" },
        "2": { "content": "..." },
        "3": { "content": "" }
      }
    },
    {
      "cycleId": 92,
      "timestamp": "2025-08-21T10:00:00Z",
      "title": "Persistence fix",
      "cycleContext": "Focus on fixing state loss.",
      "ephemeralContext": "",
      "responses": {
        "1": { "content": "" }, "2": { "content": "" }, "3": { "content": "" }, "4": { "content": "" }
      }
    }
  ]
}
```

*   **Backend (`history.service.ts`):** This service will manage reading from and writing to `dce_history.json`. It will handle file locking to prevent race conditions and provide methods like `getCycle(cycleId)`, `saveCycle(cycleData)`, `getCycleList()`, and a new `getLatestCycle()`.

## 3. Frontend State Management & Initialization Flow (C92 Revision)

### 3.1. Initialization
1.  **Problem:** Previously, the frontend managed its own state and only requested pieces of data, leading to state loss when the webview was re-initialized (e.g., on reload or pop-out).
2.  **Solution:** The new flow makes the backend the single source of truth.
    *   On component mount, the frontend sends a single new IPC message: `RequestLatestCycleData`.
    *   The backend's `HistoryService` finds the cycle with the highest `cycleId` in `dce_history.json`. If the file is empty, it creates a default "Cycle 1" object.
    *   The backend sends this complete `PcppCycle` object back to the client via `SendLatestCycleData`.
    *   The frontend's message handler uses this single object to populate its *entire* initial state: `currentCycleId`, `maxCycleId`, `cycleTitle`, `cycleContext`, `ephemeralContext`, and all `tabs` content. This guarantees the UI always starts with the latest saved data.

### 3.2. State Management (`parallel-copilot.view.tsx`)
```typescript
interface PcppState {
  currentCycleId: number;
  maxCycleId: number;
  cycleTitle: string;
  // ... other state
}
```
*   The state remains largely the same, but it is now initialized from a single backend message.
*   A "New Cycle" button (`+`) will be added. Its handler will increment `maxCycleId`, set `currentCycleId = maxCycleId`, clear the UI fields, and trigger a `saveCycleData` call to create the new empty cycle record.

## 4. IPC Communication

*   **REMOVED:** `RequestCycleHistoryList`.
*   **NEW:** `ClientToServerChannel.RequestLatestCycleData`:
    *   **Payload:** `{}`
    *   **Action:** Frontend requests the full data object for the most recent cycle.
*   **NEW:** `ServerToClientChannel.SendLatestCycleData`:
    *   **Payload:** `{ cycleData: PcppCycle }`
    *   **Action:** Backend sends the complete, latest cycle data to the frontend for initialization.
*   `ClientToServerChannel.RequestCycleData`: Still used for navigating to *older* cycles.
*   `ClientToServerChannel.SaveCycleData`: Unchanged. It sends the entire state of the *current* cycle to the backend to be persisted. It's critical that the `cycleId` in the payload is correct.