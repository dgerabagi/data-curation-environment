# Artifact A36: DCE - Phase 2 - Technical Implementation Plan
# Date Created: C69
# Author: AI Model
# Updated on: C75 (Update `package.json` contribution points for standalone view)

- **Key/Value for A0:**
- **Description:** Details the technical approach for building the Parallel Co-Pilot Panel, including the new webview provider, state management, IPC channels, and backend logic for file content swapping.
- **Tags:** feature plan, phase 2, technical plan, architecture, webview, ipc

## 1. Overview

This document outlines the technical implementation strategy for the Parallel Co-Pilot Panel. It involves creating a new, dedicated webview in its own activity bar container and the associated backend services to manage its state and perform file operations.

## 2. Core Components

### 2.1. New View Container & Webview Provider (`package.json`)

*   The `contributes` section of `package.json` will be modified to create a new, independent panel.
*   A new entry will be added to `contributes.viewsContainers.activitybar` to define the container for the Parallel Co-Pilot.
    ```json
    "viewsContainers": {
        "activitybar": [
            {
                "id": "data-curation-environment",
                "title": "Data Curation",
                "icon": "public/spiral.svg"
            },
            {
                "id": "dce-parallel-copilot",
                "title": "DCE Parallel Co-Pilot",
                "icon": "public/some-new-icon.svg"
            }
        ]
    }
    ```
*   A new entry will be added to `contributes.views` to place the webview inside the new container.
    ```json
    "views": {
        "data-curation-environment": [
            {
                "type": "webview",
                "id": "viewType.sidebar.contextChooser",
                "name": "Data Curation"
            }
        ],
        "dce-parallel-copilot": [
            {
                "type": "webview",
                "id": "viewType.sidebar.parallelCopilot",
                "name": "Parallel Co-Pilot"
            }
        ]
    }
    ```
*   The existing `parallel-copilot.view` provider will be used, but it will now render in this new, dedicated space.

### 2.2. Frontend State Management (`view.tsx`)

The main state for the webview will be an array of objects, where each object represents a tab.

```typescript
interface TabState {
  id: number;
  content: string;
  sourceFilePath: string | null;
  originalSourceContent: string | null; // Stores the original file content after the first swap
  metadata: {
    lines: number;
    tokens: number;
    similarity: number;
  };
}

const [tabs, setTabs] = useState<TabState[]>([]);
```

*   The number of items in the `tabs` array will be controlled by the UI slider.
*   The `sourceFilePath` will need to be set by the user, perhaps via a text input or a "Use Active File" button.

### 2.3. IPC Communication

New channels will be required to handle the core functionality.

*   `ClientToServerChannel.RequestFileContent`:
    *   **Payload:** `{ path: string }`
    *   **Action:** Frontend requests the content of a source file from the backend to calculate original metadata.
*   `ClientToServerChannel.RequestSwapFileContent`:
    *   **Payload:** `{ path: string, newContent: string }`
    *   **Action:** Frontend requests the backend to perform the "swap" operation.
*   `ServerToClientChannel.SendFileContent`:
    *   **Payload:** `{ path: string, content: string }`
    *   **Action:** Backend sends the requested file content back to the frontend.

### 2.4. Backend Logic (`fs.service.ts`)

New handlers will be added to `FSService` to support the webview's needs.

1.  **`handleRequestFileContent`:**
    *   Receives a file path.
    *   Reads the file using `vscode.workspace.fs.readFile`.
    *   Returns the content via the `SendFileContent` IPC channel.

2.  **`handleSwapFileContentRequest`:**
    *   This is the core of the "swap" feature.
    *   **Input:** `{ path: string, newContent: string }`.
    *   **Steps:**
        1.  Reads the current content of the file at `path` into a variable (`originalContent`).
        2.  Writes `newContent` to the file at `path` using `vscode.workspace.fs.writeFile`.
        3.  Returns `originalContent` to the frontend via the `SendFileContent` channel.
    *   This single, atomic operation ensures the swap is clean and the original content is immediately sent back to be stored in the tab.

### 2.5. Similarity Scoring

*   A lightweight string similarity library will be needed on the frontend.
*   **Recommendation:** `string-similarity` (uses Dice's Coefficient) or a similar small library.
*   A utility function will be created: `calculateSimilarity(stringA, stringB): number`.
*   This calculation will be performed in the frontend whenever the content of a tab or the original source file changes. The result will be stored in the tab's state.