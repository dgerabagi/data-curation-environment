# Artifact A36: DCE - Phase 2 - Technical Implementation Plan
# Date Created: C69
# Author: AI Model
# Updated on: C90 (Add plan for collapsible sections and markdown rendering)

- **Key/Value for A0:**
- **Description:** Details the technical approach for building the Parallel Co-Pilot Panel, including the new webview provider, state management, IPC channels, and backend logic for file content swapping.
- **Tags:** feature plan, phase 2, technical plan, architecture, webview, ipc, parsing, markdown

## 1. Overview

This document outlines the technical implementation strategy for the Parallel Co-Pilot Panel. It involves creating a new, dedicated webview and the associated backend services to manage its state and perform file operations. The core of this plan is the new parse-centric workflow, with a rich UI featuring collapsible sections and full markdown/syntax highlighting.

## 2. Core Components

### 2.1. Frontend State Management (`view.tsx`)

The main component state will be expanded to manage the UI's collapsible sections.

```typescript
// State within the view.tsx component
interface PcppState {
  // ... state for cycle nav, context fields, tabs, etc.
  isCycleSectionCollapsed: boolean;
  isSummaryCollapsed: boolean;
  isCourseOfActionCollapsed: boolean;
  highlightedCodeBlocks: Map<string, string>; // Maps file content to highlighted HTML
}
```
*   **Collapsible State:** Three new boolean state variables will control the visibility of the main UI sections. `onClick` handlers on the section headers will toggle these states.
*   **Conditional Rendering:** The content divs for these sections will be conditionally rendered based on these state flags.
*   **Highlighted Code Cache:** A new `Map` will be added to the state to cache the syntax-highlighted HTML for code blocks, preventing redundant IPC calls.

### 2.2. Frontend Rendering (`view.tsx`)

1.  **Markdown Rendering:**
    *   **Dependency:** The `react-markdown` library will be added to `package.json`.
    *   **Implementation:** The `summary` and `courseOfAction` strings from the `parsedContent` object will be rendered using the `<ReactMarkdown>` component. This will handle all standard markdown formatting (lists, bold, etc.) automatically.

2.  **Syntax Highlighting:**
    *   **IPC:** The `RequestSyntaxHighlight` and `SendSyntaxHighlight` channels will be used.
    *   **Workflow:**
        1.  After parsing a response, the frontend will iterate through `parsedContent.files`.
        2.  For each file, it will generate a unique key (e.g., the file path + content hash) and check if the highlighted HTML already exists in the `highlightedCodeBlocks` map.
        3.  If not, it will send a `RequestSyntaxHighlight` message to the backend with the code content, language, and the unique key.
        4.  An IPC listener for `SendSyntaxHighlight` will update the `highlightedCodeBlocks` map with the returned HTML.
    *   **Rendering:** The component that renders a file block will look up its content in the map and use `dangerouslySetInnerHTML` to display the highlighted code.

### 2.3. Backend Syntax Highlighting (`fs.service.ts`)

*   A new handler, `handleSyntaxHighlightRequest`, will be implemented.
*   **Library:** It will use the `@wooorm/starry-night` library.
*   **Logic:**
    1.  It will receive the code string, language identifier (e.g., "typescript"), and the unique key.
    2.  It will map the language identifier to a `starry-night` scope (e.g., "typescript" -> "source.ts").
    3.  It will call `starryNight.highlight(code, scope)`.
    4.  It will convert the resulting HAST (HTML Abstract Syntax Tree) to an HTML string using `hast-util-to-html`.
    5.  It will send the HTML string and the unique key back to the client via `SendSyntaxHighlight`.