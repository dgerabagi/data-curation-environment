# Artifact A48: DCE - Phase 2 - Advanced Syntax Highlighting Plan
# Date Created: C82
# Author: AI Model
# Updated on: C85 (Codify rationale for using starry-night)

## 1. Overview & Goal

AI-generated responses are complex documents, containing both explanatory Markdown text and code blocks in various languages. A plain `<textarea>` element does not provide any syntax highlighting, making these responses difficult to read and analyze. The goal of this feature is to significantly enhance the readability of AI responses by replacing the textareas with a proper code editor component that can provide rich, language-aware syntax highlighting.

## 2. User Story

| ID | User Story | Acceptance Criteria |
|---|---|---|
| P2-SYNTAX-01 | **View Highlighted Responses** | As a developer, I want to see AI responses with full syntax highlighting inside the Parallel Co-Pilot tabs, so I can easily distinguish between comments, keywords, and code, just like in a real editor. | - The content area of each response tab renders with syntax highlighting. <br> - Standard Markdown elements (headers, lists, bold, italics, backticks) are formatted correctly. <br> - Code blocks (e.g., ` ```typescript ... ``` `) are highlighted with the correct grammar for the specified language. <br> - The highlighting should be theme-aware, matching the user's current VS Code theme. |

## 3. Technical Implementation Strategy (C83 & C85)

### 3.1. Chosen Library: `starry-night`

After research and consideration of alternatives like `refractor`, **`@wooorm/starry-night`** remains the chosen library for syntax highlighting.

-   **Rationale (C85):**
    -   **High Fidelity:** It uses the same TextMate grammars as VS Code itself. This is the most important factor, as it ensures the highlighting in our panel will be a perfect visual match to the user's native editor experience.
    -   **Backend Architecture:** Our implementation performs highlighting on the backend (in the Node.js extension host) and sends pre-rendered HTML to the frontend webview. This means the primary drawback of `starry-night`—its large bundle size and WASM dependency—is a non-issue for the client. The "heavy lifting" is done by the extension's server-side process, keeping the webview lightweight and performant.
    -   **AST Output:** It produces a HAST (HTML Abstract Syntax Tree), which provides flexibility, though our current implementation serializes it directly to an HTML string.

### 3.2. Implementation Plan

1.  **Dependencies (`package.json`):**
    *   Add `@wooorm/starry-night` as the core dependency.
    *   Add `hast-util-to-html` to convert the abstract syntax tree to HTML.
    *   The grammars are now dynamically imported by `starry-night` itself, removing the need to add individual language packages.

2.  **Backend (`fs.service.ts`):**
    *   Create a new `async handleSyntaxHighlightRequest({ code, lang, id })` method.
    *   This method will initialize `starry-night` with all common grammars.
    *   It will use `starryNight.highlight(code, scope)` where `scope` is determined from the language identifier (e.g., 'typescript' -> 'source.ts').
    *   It will convert the resulting `hast` tree to an HTML string using `toHtml`.
    *   This HTML string will be sent back to the client via a new IPC channel, including the `id` to match the request.

3.  **IPC Channels:**
    *   `ClientToServerChannel.RequestSyntaxHighlight`: Payload `{ code: string, lang: string, id: string }`.
    *   `ServerToClientChannel.SendSyntaxHighlight`: Payload `{ highlightedHtml: string, id: string }`.

4.  **Frontend (`parallel-copilot.view/view.tsx`):**
    *   The view will be split into two panes: an editable `<textarea>` on the left and a read-only preview `<div>` on the right.
    *   The `onPaste` and `onChange` handlers for the textarea will be updated. They will parse the content to find code blocks (e.g., ` ```typescript ... ``` `).
    *   For each code block found, it will generate a unique ID (the full block content itself) and send a `RequestSyntaxHighlight` message to the backend with the block's content, language, and the ID.
    *   A new state variable, e.g., `highlightedBlocks: Map<string, string>`, will store the HTML returned from the backend, keyed by the unique ID.
    *   The right-hand preview pane will render the full response. When it encounters a code block, it will look up the highlighted HTML in the state and render it using `dangerouslySetInnerHTML`. This provides a live, highlighted preview as the user edits or pastes content.