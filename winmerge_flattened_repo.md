<!--
  File: flattened_repo.md
  Source Directory: c:\Projects\DCE - Copy
  Date Generated: 2025-08-24T23:24:42.370Z
  ---
  Total Files: 510
  Approx. Tokens: 970699
-->

<!-- Top 10 Text Files by Token Count -->
1. Winmerge-Src\Src\DirView.cpp (37703 tokens)
2. Winmerge-Src\Src\MainFrm.cpp (33452 tokens)
3. Winmerge-Src\Src\MergeEditView.cpp (32038 tokens)
4. Winmerge-Src\Src\MergeDoc.cpp (27369 tokens)
5. Winmerge-Src\Src\FilterEngine\FilterParser.out (19913 tokens)
6. Winmerge-Src\Src\ImgMergeFrm.cpp (18677 tokens)
7. Winmerge-Src\Src\DirViewColItems.cpp (17961 tokens)
8. Winmerge-Src\Src\Common\BCMenu.cpp (14645 tokens)
9. Winmerge-Src\Src\Merge.cpp (14304 tokens)
10. Winmerge-Src\Src\DiffWrapper.cpp (13769 tokens)

<!-- Full File List -->
1. Winmerge-Src\Src\CompareEngines\BinaryCompare.cpp - Lines: 130 - Chars: 3391 - Tokens: 848
2. Winmerge-Src\Src\CompareEngines\BinaryCompare.h - Lines: 31 - Chars: 562 - Tokens: 141
3. Winmerge-Src\Src\CompareEngines\ByteComparator.cpp - Lines: 565 - Chars: 12578 - Tokens: 3145
4. Winmerge-Src\Src\CompareEngines\ByteComparator.h - Lines: 68 - Chars: 2364 - Tokens: 591
5. Winmerge-Src\Src\CompareEngines\ByteCompare.cpp - Lines: 291 - Chars: 7877 - Tokens: 1970
6. Winmerge-Src\Src\CompareEngines\ByteCompare.h - Lines: 42 - Chars: 871 - Tokens: 218
7. Winmerge-Src\Src\CompareEngines\CompareEngines.vcxitems - Lines: 56 - Chars: 2979 - Tokens: 745
8. Winmerge-Src\Src\CompareEngines\CompareEngines.vcxitems.filters - Lines: 51 - Chars: 1968 - Tokens: 492
9. Winmerge-Src\Src\CompareEngines\ImageCompare.cpp - Lines: 112 - Chars: 3267 - Tokens: 817
10. Winmerge-Src\Src\CompareEngines\ImageCompare.h - Lines: 39 - Chars: 924 - Tokens: 231
11. Winmerge-Src\Src\CompareEngines\TimeSizeCompare.cpp - Lines: 131 - Chars: 3863 - Tokens: 966
12. Winmerge-Src\Src\CompareEngines\TimeSizeCompare.h - Lines: 35 - Chars: 631 - Tokens: 158
13. Winmerge-Src\Src\CompareEngines\Wrap_DiffUtils.cpp - Lines: 255 - Chars: 6647 - Tokens: 1662
14. Winmerge-Src\Src\CompareEngines\Wrap_DiffUtils.h - Lines: 55 - Chars: 1350 - Tokens: 338
15. Winmerge-Src\Src\diffutils\config.h - Lines: 19 - Chars: 373 - Tokens: 94
16. Winmerge-Src\Src\diffutils\diffutils.vcxitems - Lines: 65 - Chars: 3013 - Tokens: 754
17. Winmerge-Src\Src\diffutils\diffutils.vcxitems.filters - Lines: 59 - Chars: 2133 - Tokens: 534
18. Winmerge-Src\Src\diffutils\GnuVersion.c - Lines: 6 - Chars: 94 - Tokens: 24
19. Winmerge-Src\Src\diffutils\lib\cmpbuf.c - Lines: 40 - Chars: 1181 - Tokens: 296
20. Winmerge-Src\Src\diffutils\lib\cmpbuf.h - Lines: 30 - Chars: 907 - Tokens: 227
21. Winmerge-Src\Src\diffutils\src\analyze.c - Lines: 1139 - Chars: 33114 - Tokens: 8279
22. Winmerge-Src\Src\diffutils\src\context.c - Lines: 405 - Chars: 11606 - Tokens: 2902
23. Winmerge-Src\Src\diffutils\src\Diff.cpp - Lines: 40 - Chars: 1333 - Tokens: 334
24. Winmerge-Src\Src\diffutils\src\diff.h - Lines: 401 - Chars: 12919 - Tokens: 3230
25. Winmerge-Src\Src\diffutils\src\ed.c - Lines: 195 - Chars: 5213 - Tokens: 1304
26. Winmerge-Src\Src\diffutils\src\ifdef.c - Lines: 415 - Chars: 9878 - Tokens: 2470
27. Winmerge-Src\Src\diffutils\src\io.c - Lines: 1138 - Chars: 37179 - Tokens: 9295
28. Winmerge-Src\Src\diffutils\src\mystat.cpp - Lines: 94 - Chars: 2569 - Tokens: 643
29. Winmerge-Src\Src\diffutils\src\normal.c - Lines: 76 - Chars: 2454 - Tokens: 614
30. Winmerge-Src\Src\diffutils\src\side.c - Lines: 276 - Chars: 6894 - Tokens: 1724
31. Winmerge-Src\Src\diffutils\src\system.h - Lines: 216 - Chars: 4356 - Tokens: 1089
32. Winmerge-Src\Src\diffutils\src\util.c - Lines: 967 - Chars: 23608 - Tokens: 5902
33. Winmerge-Src\Src\FilterEngine\FileContentRef.cpp - Lines: 192 - Chars: 4630 - Tokens: 1158
34. Winmerge-Src\Src\FilterEngine\FileContentRef.h - Lines: 18 - Chars: 415 - Tokens: 104
35. Winmerge-Src\Src\FilterEngine\FilterEngine.vcxitems - Lines: 67 - Chars: 3377 - Tokens: 845
36. Winmerge-Src\Src\FilterEngine\FilterEngine.vcxitems.filters - Lines: 59 - Chars: 2258 - Tokens: 565
37. Winmerge-Src\Src\FilterEngine\FilterError.h - Lines: 23 - Chars: 669 - Tokens: 168
38. Winmerge-Src\Src\FilterEngine\FilterExpression.cpp - Lines: 166 - Chars: 3995 - Tokens: 999
39. Winmerge-Src\Src\FilterEngine\FilterExpression.h - Lines: 42 - Chars: 1178 - Tokens: 295
40. Winmerge-Src\Src\FilterEngine\FilterExpressionNodes.h - Lines: 181 - Chars: 4650 - Tokens: 1163
41. Winmerge-Src\Src\FilterEngine\FilterLexer.cpp - Lines: 1685 - Chars: 27869 - Tokens: 6968
42. Winmerge-Src\Src\FilterEngine\FilterLexer.h - Lines: 57 - Chars: 1018 - Tokens: 255
43. Winmerge-Src\Src\FilterEngine\FilterLexer.re - Lines: 146 - Chars: 3674 - Tokens: 919
44. Winmerge-Src\Src\FilterEngine\FilterParser.cpp - Lines: 3 - Chars: 43 - Tokens: 11
45. Winmerge-Src\Src\FilterEngine\FilterParser.h - Lines: 31 - Chars: 1380 - Tokens: 345
46. Winmerge-Src\Src\FilterEngine\FilterParser.out - Lines: 1633 - Chars: 79650 - Tokens: 19913
47. Winmerge-Src\Src\FilterEngine\FilterParser.y - Lines: 180 - Chars: 6213 - Tokens: 1554
48. Winmerge-Src\Src\Common\AccentColor.cpp - Lines: 40 - Chars: 955 - Tokens: 239
49. Winmerge-Src\Src\Common\AccentColor.h - Lines: 25 - Chars: 559 - Tokens: 140
50. Winmerge-Src\Src\Common\BCMenu.cpp - Lines: 1997 - Chars: 58579 - Tokens: 14645
51. Winmerge-Src\Src\Common\BCMenu.h - Lines: 213 - Chars: 8083 - Tokens: 2021
52. Winmerge-Src\Src\Common\Bitmap.cpp - Lines: 267 - Chars: 9474 - Tokens: 2369
53. Winmerge-Src\Src\Common\Bitmap.h - Lines: 20 - Chars: 501 - Tokens: 126
54. Winmerge-Src\Src\Common\cio.cpp - Lines: 65 - Chars: 1395 - Tokens: 349
55. Winmerge-Src\Src\Common\cio.h - Lines: 44 - Chars: 1294 - Tokens: 324
56. Winmerge-Src\Src\Common\ClipBoard.cpp - Lines: 130 - Chars: 3452 - Tokens: 863
57. Winmerge-Src\Src\Common\ClipBoard.h - Lines: 41 - Chars: 1127 - Tokens: 282
58. Winmerge-Src\Src\Common\CMoveConstraint.cpp - Lines: 770 - Chars: 20316 - Tokens: 5079
59. Winmerge-Src\Src\Common\CMoveConstraint.h - Lines: 250 - Chars: 9134 - Tokens: 2284
60. Winmerge-Src\Src\Common\ColorButton.cpp - Lines: 51 - Chars: 967 - Tokens: 242
61. Winmerge-Src\Src\Common\ColorButton.h - Lines: 27 - Chars: 646 - Tokens: 162
62. Winmerge-Src\Src\Common\coretools.cpp - Lines: 25 - Chars: 344 - Tokens: 86
63. Winmerge-Src\Src\Common\coretools.h - Lines: 9 - Chars: 143 - Tokens: 36
64. Winmerge-Src\Src\Common\DebugNew.h - Lines: 9 - Chars: 337 - Tokens: 85
65. Winmerge-Src\Src\Common\ExConverter.cpp - Lines: 333 - Chars: 9587 - Tokens: 2397
66. Winmerge-Src\Src\Common\ExConverter.h - Lines: 35 - Chars: 1229 - Tokens: 308
67. Winmerge-Src\Src\Common\IatHook.h - Lines: 117 - Chars: 4072 - Tokens: 1018
68. Winmerge-Src\Src\Common\IMDITab.h - Lines: 10 - Chars: 103 - Tokens: 26
69. Winmerge-Src\Src\Common\IniOptionsMgr.cpp - Lines: 412 - Chars: 10749 - Tokens: 2688
70. Winmerge-Src\Src\Common\IniOptionsMgr.h - Lines: 55 - Chars: 1939 - Tokens: 485
71. Winmerge-Src\Src\Common\LanguageSelect.cpp - Lines: 1062 - Chars: 24635 - Tokens: 6159
72. Winmerge-Src\Src\Common\LanguageSelect.h - Lines: 52 - Chars: 1444 - Tokens: 361
73. Winmerge-Src\Src\Common\lwdisp.c - Lines: 832 - Chars: 21988 - Tokens: 5497
74. Winmerge-Src\Src\Common\lwdisp.h - Lines: 270 - Chars: 8067 - Tokens: 2017
75. Winmerge-Src\Src\Common\MDITabBar.cpp - Lines: 924 - Chars: 25180 - Tokens: 6295
76. Winmerge-Src\Src\Common\MDITabBar.h - Lines: 139 - Chars: 3980 - Tokens: 995
77. Winmerge-Src\Src\Common\memdc.h - Lines: 108 - Chars: 2781 - Tokens: 696
78. Winmerge-Src\Src\Common\MessageBoxDialog.h - Lines: 293 - Chars: 9963 - Tokens: 2491
79. Winmerge-Src\Src\Common\multiformatText.cpp - Lines: 655 - Chars: 16466 - Tokens: 4117
80. Winmerge-Src\Src\Common\multiformatText.h - Lines: 152 - Chars: 4661 - Tokens: 1166
81. Winmerge-Src\Src\Common\OptionsMgr.cpp - Lines: 870 - Chars: 21412 - Tokens: 5353
82. Winmerge-Src\Src\Common\OptionsMgr.h - Lines: 168 - Chars: 6011 - Tokens: 1503
83. Winmerge-Src\Src\Common\PidlContainer.cpp - Lines: 42 - Chars: 1197 - Tokens: 300
84. Winmerge-Src\Src\Common\PidlContainer.h - Lines: 61 - Chars: 1551 - Tokens: 388
85. Winmerge-Src\Src\Common\PreferencesDlg.cpp - Lines: 440 - Chars: 13603 - Tokens: 3401
86. Winmerge-Src\Src\Common\PreferencesDlg.h - Lines: 129 - Chars: 3720 - Tokens: 930
87. Winmerge-Src\Src\Common\PropertyPageHost.cpp - Lines: 388 - Chars: 8447 - Tokens: 2112
88. Winmerge-Src\Src\Common\PropertyPageHost.h - Lines: 78 - Chars: 2058 - Tokens: 515
89. Winmerge-Src\Src\Common\RegKey.cpp - Lines: 348 - Chars: 9220 - Tokens: 2305
90. Winmerge-Src\Src\Common\RegKey.h - Lines: 51 - Chars: 1582 - Tokens: 396
91. Winmerge-Src\Src\Common\RegOptionsMgr.cpp - Lines: 723 - Chars: 18445 - Tokens: 4612
92. Winmerge-Src\Src\Common\RegOptionsMgr.h - Lines: 56 - Chars: 1918 - Tokens: 480
93. Winmerge-Src\Src\Common\RoundedRectWithShadow.cpp - Lines: 215 - Chars: 7790 - Tokens: 1948
94. Winmerge-Src\Src\Common\RoundedRectWithShadow.h - Lines: 15 - Chars: 614 - Tokens: 154
95. Winmerge-Src\Src\Common\scbarcf.cpp - Lines: 175 - Chars: 5529 - Tokens: 1383
96. Winmerge-Src\Src\Common\scbarcf.h - Lines: 68 - Chars: 2056 - Tokens: 514
97. Winmerge-Src\Src\Common\scbarg.cpp - Lines: 244 - Chars: 7411 - Tokens: 1853
98. Winmerge-Src\Src\Common\scbarg.h - Lines: 101 - Chars: 2742 - Tokens: 686
99. Winmerge-Src\Src\Common\Shell.cpp - Lines: 52 - Chars: 1422 - Tokens: 356
100. Winmerge-Src\Src\Common\Shell.h - Lines: 13 - Chars: 290 - Tokens: 73
101. Winmerge-Src\Src\Common\ShellContextMenu.cpp - Lines: 258 - Chars: 6962 - Tokens: 1741
102. Winmerge-Src\Src\Common\ShellContextMenu.h - Lines: 173 - Chars: 6712 - Tokens: 1678
103. Winmerge-Src\Src\Common\ShellFileOperations.cpp - Lines: 284 - Chars: 7309 - Tokens: 1828
104. Winmerge-Src\Src\Common\ShellFileOperations.h - Lines: 55 - Chars: 1583 - Tokens: 396
105. Winmerge-Src\Src\Common\sizecbar.h - Lines: 228 - Chars: 7590 - Tokens: 1898
106. Winmerge-Src\Src\Common\SortHeaderCtrl.cpp - Lines: 174 - Chars: 4352 - Tokens: 1088
107. Winmerge-Src\Src\Common\SortHeaderCtrl.h - Lines: 52 - Chars: 937 - Tokens: 235
108. Winmerge-Src\Src\Common\SplitterWndEx.cpp - Lines: 480 - Chars: 12631 - Tokens: 3158
109. Winmerge-Src\Src\Common\SplitterWndEx.h - Lines: 57 - Chars: 1535 - Tokens: 384
110. Winmerge-Src\Src\Common\SuperComboBox.cpp - Lines: 606 - Chars: 15268 - Tokens: 3817
111. Winmerge-Src\Src\Common\SuperComboBox.h - Lines: 93 - Chars: 2058 - Tokens: 515
112. Winmerge-Src\Src\Common\SysColorHook.cpp - Lines: 176 - Chars: 5665 - Tokens: 1417
113. Winmerge-Src\Src\Common\SysColorHook.h - Lines: 21 - Chars: 475 - Tokens: 119
114. Winmerge-Src\Src\Common\unicoder.cpp - Lines: 1282 - Chars: 31007 - Tokens: 7752
115. Winmerge-Src\Src\Common\unicoder.h - Lines: 135 - Chars: 4058 - Tokens: 1015
116. Winmerge-Src\Src\Common\UnicodeString.cpp - Lines: 348 - Chars: 8621 - Tokens: 2156
117. Winmerge-Src\Src\Common\UnicodeString.h - Lines: 125 - Chars: 3817 - Tokens: 955
118. Winmerge-Src\Src\Common\UniFile.cpp - Lines: 906 - Chars: 20787 - Tokens: 5197
119. Winmerge-Src\Src\Common\UniFile.h - Lines: 315 - Chars: 7843 - Tokens: 1961
120. Winmerge-Src\Src\Common\ValidatingEdit.cpp - Lines: 161 - Chars: 3294 - Tokens: 824
121. Winmerge-Src\Src\Common\ValidatingEdit.h - Lines: 36 - Chars: 731 - Tokens: 183
122. Winmerge-Src\Src\Common\varprop.cpp - Lines: 185 - Chars: 3038 - Tokens: 760
123. Winmerge-Src\Src\Common\varprop.h - Lines: 72 - Chars: 1806 - Tokens: 452
124. Winmerge-Src\Src\Common\VersionInfo.cpp - Lines: 364 - Chars: 9972 - Tokens: 2493
125. Winmerge-Src\Src\Common\VersionInfo.h - Lines: 177 - Chars: 4401 - Tokens: 1101
126. Winmerge-Src\Src\res\Merge.rc2 - Lines: 15 - Chars: 462 - Tokens: 116
127. Winmerge-Src\Src\res\mg_cur.cur - Lines: 1 - Chars: 326 - Tokens: 82
128. Winmerge-Src\Src\res\WinMerge.exe.manifest - Lines: 50 - Chars: 1513 - Tokens: 379
129. Winmerge-Src\Src\res\WinMergeU.VisualElementsManifest.xml - Lines: 4 - Chars: 340 - Tokens: 85
130. Winmerge-Src\Src\7zCommon.cpp - Lines: 741 - Chars: 22544 - Tokens: 5636
131. Winmerge-Src\Src\7zCommon.h - Lines: 109 - Chars: 2521 - Tokens: 631
132. Winmerge-Src\Src\AboutDlg.cpp - Lines: 199 - Chars: 5116 - Tokens: 1279
133. Winmerge-Src\Src\AboutDlg.h - Lines: 33 - Chars: 550 - Tokens: 138
134. Winmerge-Src\Src\BasicFlatStatusBar.cpp - Lines: 169 - Chars: 4333 - Tokens: 1084
135. Winmerge-Src\Src\BasicFlatStatusBar.h - Lines: 34 - Chars: 772 - Tokens: 193
136. Winmerge-Src\Src\charsets.h - Lines: 30 - Chars: 975 - Tokens: 244
137. Winmerge-Src\Src\ClipboardHistory.cpp - Lines: 159 - Chars: 4398 - Tokens: 1100
138. Winmerge-Src\Src\ClipboardHistory.h - Lines: 23 - Chars: 396 - Tokens: 99
139. Winmerge-Src\Src\codepage_detect.cpp - Lines: 251 - Chars: 6851 - Tokens: 1713
140. Winmerge-Src\Src\codepage_detect.h - Lines: 19 - Chars: 476 - Tokens: 119
141. Winmerge-Src\Src\ColorSchemes.cpp - Lines: 56 - Chars: 1389 - Tokens: 348
142. Winmerge-Src\Src\ColorSchemes.h - Lines: 13 - Chars: 248 - Tokens: 62
143. Winmerge-Src\Src\CompareOptions.cpp - Lines: 216 - Chars: 5565 - Tokens: 1392
144. Winmerge-Src\Src\CompareOptions.h - Lines: 148 - Chars: 5142 - Tokens: 1286
145. Winmerge-Src\Src\CompareStatisticsDlg.cpp - Lines: 129 - Chars: 4421 - Tokens: 1106
146. Winmerge-Src\Src\CompareStatisticsDlg.h - Lines: 41 - Chars: 985 - Tokens: 247
147. Winmerge-Src\Src\CompareStats.cpp - Lines: 184 - Chars: 4334 - Tokens: 1084
148. Winmerge-Src\Src\CompareStats.h - Lines: 166 - Chars: 4507 - Tokens: 1127
149. Winmerge-Src\Src\Concurrent.cpp - Lines: 11 - Chars: 266 - Tokens: 67
150. Winmerge-Src\Src\Concurrent.h - Lines: 107 - Chars: 2072 - Tokens: 518
151. Winmerge-Src\Src\ConfigLog.cpp - Lines: 585 - Chars: 16324 - Tokens: 4081
152. Winmerge-Src\Src\ConfigLog.h - Lines: 58 - Chars: 1282 - Tokens: 321
153. Winmerge-Src\Src\ConfirmFolderCopyDlg.cpp - Lines: 115 - Chars: 3299 - Tokens: 825
154. Winmerge-Src\Src\ConfirmFolderCopyDlg.h - Lines: 48 - Chars: 1059 - Tokens: 265
155. Winmerge-Src\Src\ConflictFileParser.cpp - Lines: 340 - Chars: 8101 - Tokens: 2026
156. Winmerge-Src\Src\ConflictFileParser.h - Lines: 24 - Chars: 704 - Tokens: 176
157. Winmerge-Src\Src\Constants.h - Lines: 84 - Chars: 3261 - Tokens: 816
158. Winmerge-Src\Src\COPYING - Lines: 343 - Chars: 18011 - Tokens: 4503
159. Winmerge-Src\Src\DDXHelper.h - Lines: 41 - Chars: 973 - Tokens: 244
160. Winmerge-Src\Src\Diff3.h - Lines: 224 - Chars: 4840 - Tokens: 1210
161. Winmerge-Src\Src\DiffContext.cpp - Lines: 331 - Chars: 10084 - Tokens: 2521
162. Winmerge-Src\Src\DiffContext.h - Lines: 233 - Chars: 7928 - Tokens: 1982
163. Winmerge-Src\Src\DiffFileData.cpp - Lines: 154 - Chars: 4445 - Tokens: 1112
164. Winmerge-Src\Src\DiffFileData.h - Lines: 50 - Chars: 1169 - Tokens: 293
165. Winmerge-Src\Src\DiffFileInfo.cpp - Lines: 22 - Chars: 365 - Tokens: 92
166. Winmerge-Src\Src\DiffFileInfo.h - Lines: 47 - Chars: 1151 - Tokens: 288
167. Winmerge-Src\Src\DiffItem.cpp - Lines: 252 - Chars: 5718 - Tokens: 1430
168. Winmerge-Src\Src\DiffItem.h - Lines: 306 - Chars: 13601 - Tokens: 3401
169. Winmerge-Src\Src\DiffItemList.cpp - Lines: 214 - Chars: 5502 - Tokens: 1376
170. Winmerge-Src\Src\DiffItemList.h - Lines: 66 - Chars: 1992 - Tokens: 498
171. Winmerge-Src\Src\DiffList.cpp - Lines: 892 - Chars: 23229 - Tokens: 5808
172. Winmerge-Src\Src\DiffList.h - Lines: 231 - Chars: 6979 - Tokens: 1745
173. Winmerge-Src\Src\DiffTextBuffer.cpp - Lines: 583 - Chars: 16544 - Tokens: 4136
174. Winmerge-Src\Src\DiffTextBuffer.h - Lines: 100 - Chars: 3451 - Tokens: 863
175. Winmerge-Src\Src\DiffThread.cpp - Lines: 152 - Chars: 4132 - Tokens: 1033
176. Winmerge-Src\Src\DiffThread.h - Lines: 167 - Chars: 4752 - Tokens: 1188
177. Winmerge-Src\Src\DiffViewBar.cpp - Lines: 122 - Chars: 2547 - Tokens: 637
178. Winmerge-Src\Src\DiffViewBar.h - Lines: 48 - Chars: 1019 - Tokens: 255
179. Winmerge-Src\Src\DiffWrapper.cpp - Lines: 1871 - Chars: 55074 - Tokens: 13769
180. Winmerge-Src\Src\DiffWrapper.h - Lines: 286 - Chars: 10591 - Tokens: 2648
181. Winmerge-Src\Src\DirActions.cpp - Lines: 1639 - Chars: 51416 - Tokens: 12854
182. Winmerge-Src\Src\DirActions.h - Lines: 863 - Chars: 27314 - Tokens: 6829
183. Winmerge-Src\Src\DirAdditionalPropertiesDlg.cpp - Lines: 229 - Chars: 6319 - Tokens: 1580
184. Winmerge-Src\Src\DirAdditionalPropertiesDlg.h - Lines: 82 - Chars: 2412 - Tokens: 603
185. Winmerge-Src\Src\DirCmpReport.cpp - Lines: 588 - Chars: 16766 - Tokens: 4192
186. Winmerge-Src\Src\DirCmpReport.h - Lines: 85 - Chars: 3096 - Tokens: 774
187. Winmerge-Src\Src\DirCmpReportDlg.cpp - Lines: 197 - Chars: 5440 - Tokens: 1360
188. Winmerge-Src\Src\DirCmpReportDlg.h - Lines: 54 - Chars: 1466 - Tokens: 367
189. Winmerge-Src\Src\DirColsDlg.cpp - Lines: 331 - Chars: 7837 - Tokens: 1960
190. Winmerge-Src\Src\DirColsDlg.h - Lines: 101 - Chars: 3036 - Tokens: 759
191. Winmerge-Src\Src\DirCompProgressBar.cpp - Lines: 223 - Chars: 6396 - Tokens: 1599
192. Winmerge-Src\Src\DirCompProgressBar.h - Lines: 84 - Chars: 2478 - Tokens: 620
193. Winmerge-Src\Src\DirDoc.cpp - Lines: 1066 - Chars: 30293 - Tokens: 7574
194. Winmerge-Src\Src\DirDoc.h - Lines: 191 - Chars: 6497 - Tokens: 1625
195. Winmerge-Src\Src\DirFilterDlg.cpp - Lines: 169 - Chars: 4031 - Tokens: 1008
196. Winmerge-Src\Src\DirFilterDlg.h - Lines: 44 - Chars: 1112 - Tokens: 278
197. Winmerge-Src\Src\DirFrame.cpp - Lines: 199 - Chars: 4880 - Tokens: 1220
198. Winmerge-Src\Src\DirFrame.h - Lines: 72 - Chars: 1751 - Tokens: 438
199. Winmerge-Src\Src\DirItem.cpp - Lines: 136 - Chars: 2803 - Tokens: 701
200. Winmerge-Src\Src\DirItem.h - Lines: 45 - Chars: 1450 - Tokens: 363
201. Winmerge-Src\Src\DirItemIterator.h - Lines: 204 - Chars: 4453 - Tokens: 1114
202. Winmerge-Src\Src\DirReportTypes.h - Lines: 13 - Chars: 294 - Tokens: 74
203. Winmerge-Src\Src\DirScan.cpp - Lines: 1063 - Chars: 34899 - Tokens: 8725
204. Winmerge-Src\Src\DirScan.h - Lines: 23 - Chars: 648 - Tokens: 162
205. Winmerge-Src\Src\DirSelectFilesDlg.cpp - Lines: 131 - Chars: 3365 - Tokens: 842
206. Winmerge-Src\Src\DirSelectFilesDlg.h - Lines: 31 - Chars: 587 - Tokens: 147
207. Winmerge-Src\Src\DirTravel.cpp - Lines: 164 - Chars: 4774 - Tokens: 1194
208. Winmerge-Src\Src\DirTravel.h - Lines: 18 - Chars: 397 - Tokens: 100
209. Winmerge-Src\Src\DirView.cpp - Lines: 4951 - Chars: 150811 - Tokens: 37703
210. Winmerge-Src\Src\DirView.h - Lines: 462 - Chars: 19099 - Tokens: 4775
211. Winmerge-Src\Src\DirViewColItems.cpp - Lines: 2120 - Chars: 71844 - Tokens: 17961
212. Winmerge-Src\Src\DirViewColItems.h - Lines: 135 - Chars: 4245 - Tokens: 1062
213. Winmerge-Src\Src\DirWatcher.cpp - Lines: 365 - Chars: 8382 - Tokens: 2096
214. Winmerge-Src\Src\DirWatcher.h - Lines: 25 - Chars: 526 - Tokens: 132
215. Winmerge-Src\Src\dllpstub.cpp - Lines: 140 - Chars: 4066 - Tokens: 1017
216. Winmerge-Src\Src\dllpstub.h - Lines: 43 - Chars: 1145 - Tokens: 287
217. Winmerge-Src\Src\DropHandler.cpp - Lines: 368 - Chars: 12541 - Tokens: 3136
218. Winmerge-Src\Src\DropHandler.h - Lines: 29 - Chars: 950 - Tokens: 238
219. Winmerge-Src\Src\EditorFilepathBar.cpp - Lines: 321 - Chars: 9215 - Tokens: 2304
220. Winmerge-Src\Src\EditorFilepathBar.h - Lines: 123 - Chars: 4300 - Tokens: 1075
221. Winmerge-Src\Src\EditPluginDlg.cpp - Lines: 587 - Chars: 21226 - Tokens: 5307
222. Winmerge-Src\Src\EditPluginDlg.h - Lines: 101 - Chars: 2950 - Tokens: 738
223. Winmerge-Src\Src\EncodingErrorBar.cpp - Lines: 63 - Chars: 1579 - Tokens: 395
224. Winmerge-Src\Src\EncodingErrorBar.h - Lines: 47 - Chars: 917 - Tokens: 230
225. Winmerge-Src\Src\Environment.cpp - Lines: 220 - Chars: 5476 - Tokens: 1369
226. Winmerge-Src\Src\Environment.h - Lines: 33 - Chars: 748 - Tokens: 187
227. Winmerge-Src\Src\Exceptions.h - Lines: 116 - Chars: 3326 - Tokens: 832
228. Winmerge-Src\Src\FileActionScript.cpp - Lines: 275 - Chars: 6679 - Tokens: 1670
229. Winmerge-Src\Src\FileActionScript.h - Lines: 181 - Chars: 5301 - Tokens: 1326
230. Winmerge-Src\Src\FileFilter.cpp - Lines: 379 - Chars: 11134 - Tokens: 2784
231. Winmerge-Src\Src\FileFilter.h - Lines: 108 - Chars: 5071 - Tokens: 1268
232. Winmerge-Src\Src\FileFilterHelper.cpp - Lines: 780 - Chars: 25305 - Tokens: 6327
233. Winmerge-Src\Src\FileFilterHelper.h - Lines: 173 - Chars: 5830 - Tokens: 1458
234. Winmerge-Src\Src\FileFilterHelperMenu.cpp - Lines: 277 - Chars: 13236 - Tokens: 3309
235. Winmerge-Src\Src\FileFilterHelperMenu.h - Lines: 18 - Chars: 442 - Tokens: 111
236. Winmerge-Src\Src\FileFilterMgr.cpp - Lines: 391 - Chars: 11187 - Tokens: 2797
237. Winmerge-Src\Src\FileFilterMgr.h - Lines: 140 - Chars: 3803 - Tokens: 951
238. Winmerge-Src\Src\FileFiltersDlg.cpp - Lines: 713 - Chars: 21171 - Tokens: 5293
239. Winmerge-Src\Src\FileFiltersDlg.h - Lines: 91 - Chars: 2547 - Tokens: 637
240. Winmerge-Src\Src\FileFlags.cpp - Lines: 34 - Chars: 757 - Tokens: 190
241. Winmerge-Src\Src\FileFlags.h - Lines: 22 - Chars: 396 - Tokens: 99
242. Winmerge-Src\Src\FileLoadResult.h - Lines: 113 - Chars: 3289 - Tokens: 823
243. Winmerge-Src\Src\FileLocation.h - Lines: 42 - Chars: 829 - Tokens: 208
244. Winmerge-Src\Src\FileOpenFlags.h - Lines: 20 - Chars: 635 - Tokens: 159
245. Winmerge-Src\Src\FileOrFolderSelect.cpp - Lines: 297 - Chars: 9530 - Tokens: 2383
246. Winmerge-Src\Src\FileOrFolderSelect.h - Lines: 25 - Chars: 925 - Tokens: 232
247. Winmerge-Src\Src\FilepathEdit.cpp - Lines: 583 - Chars: 15292 - Tokens: 3823
248. Winmerge-Src\Src\FilepathEdit.h - Lines: 87 - Chars: 2921 - Tokens: 731
249. Winmerge-Src\Src\FileTextEncoding.cpp - Lines: 123 - Chars: 2224 - Tokens: 556
250. Winmerge-Src\Src\FileTextEncoding.h - Lines: 29 - Chars: 797 - Tokens: 200
251. Winmerge-Src\Src\FileTextStats.h - Lines: 23 - Chars: 650 - Tokens: 163
252. Winmerge-Src\Src\FileTransform.cpp - Lines: 1083 - Chars: 32372 - Tokens: 8093
253. Winmerge-Src\Src\FileTransform.h - Lines: 217 - Chars: 7039 - Tokens: 1760
254. Winmerge-Src\Src\FileVersion.cpp - Lines: 54 - Chars: 1346 - Tokens: 337
255. Winmerge-Src\Src\FileVersion.h - Lines: 66 - Chars: 1625 - Tokens: 407
256. Winmerge-Src\Src\FilterConditionDlg.cpp - Lines: 259 - Chars: 7913 - Tokens: 1979
257. Winmerge-Src\Src\FilterConditionDlg.h - Lines: 61 - Chars: 1544 - Tokens: 386
258. Winmerge-Src\Src\FilterErrorMessages.cpp - Lines: 53 - Chars: 1662 - Tokens: 416
259. Winmerge-Src\Src\FilterErrorMessages.h - Lines: 9 - Chars: 225 - Tokens: 57
260. Winmerge-Src\Src\FilterList.cpp - Lines: 116 - Chars: 2840 - Tokens: 710
261. Winmerge-Src\Src\FilterList.h - Lines: 68 - Chars: 1902 - Tokens: 476
262. Winmerge-Src\Src\FiltersPropertySheet.cpp - Lines: 61 - Chars: 1538 - Tokens: 385
263. Winmerge-Src\Src\FiltersPropertySheet.h - Lines: 26 - Chars: 681 - Tokens: 171
264. Winmerge-Src\Src\FolderCmp.cpp - Lines: 494 - Chars: 18438 - Tokens: 4610
265. Winmerge-Src\Src\FolderCmp.h - Lines: 62 - Chars: 1545 - Tokens: 387
266. Winmerge-Src\Src\FrameWndHelper.cpp - Lines: 51 - Chars: 1315 - Tokens: 329
267. Winmerge-Src\Src\FrameWndHelper.h - Lines: 7 - Chars: 154 - Tokens: 39
268. Winmerge-Src\Src\GhostTextBuffer.cpp - Lines: 902 - Chars: 28984 - Tokens: 7246
269. Winmerge-Src\Src\GhostTextBuffer.h - Lines: 140 - Chars: 4927 - Tokens: 1232
270. Winmerge-Src\Src\GhostTextView.cpp - Lines: 296 - Chars: 8376 - Tokens: 2094
271. Winmerge-Src\Src\GhostTextView.h - Lines: 123 - Chars: 4279 - Tokens: 1070
272. Winmerge-Src\Src\HashCalc.cpp - Lines: 69 - Chars: 1851 - Tokens: 463
273. Winmerge-Src\Src\HashCalc.h - Lines: 12 - Chars: 222 - Tokens: 56
274. Winmerge-Src\Src\heksedit.h - Lines: 146 - Chars: 5505 - Tokens: 1377
275. Winmerge-Src\Src\HexMergeDoc.cpp - Lines: 1012 - Chars: 27000 - Tokens: 6750
276. Winmerge-Src\Src\HexMergeDoc.h - Lines: 163 - Chars: 5707 - Tokens: 1427
277. Winmerge-Src\Src\HexMergeFrm.cpp - Lines: 450 - Chars: 12562 - Tokens: 3141
278. Winmerge-Src\Src\HexMergeFrm.h - Lines: 89 - Chars: 2278 - Tokens: 570
279. Winmerge-Src\Src\HexMergeView.cpp - Lines: 614 - Chars: 14166 - Tokens: 3542
280. Winmerge-Src\Src\HexMergeView.h - Lines: 95 - Chars: 2839 - Tokens: 710
281. Winmerge-Src\Src\IAbortable.h - Lines: 9 - Chars: 141 - Tokens: 36
282. Winmerge-Src\Src\IDirDoc.h - Lines: 39 - Chars: 1548 - Tokens: 387
283. Winmerge-Src\Src\IListCtrl.h - Lines: 24 - Chars: 867 - Tokens: 217
284. Winmerge-Src\Src\IListCtrlImpl.h - Lines: 191 - Chars: 5624 - Tokens: 1406
285. Winmerge-Src\Src\IMergeDoc.h - Lines: 37 - Chars: 1020 - Tokens: 255
286. Winmerge-Src\Src\ImgMergeFrm.cpp - Lines: 2409 - Chars: 74705 - Tokens: 18677
287. Winmerge-Src\Src\ImgMergeFrm.h - Lines: 259 - Chars: 9760 - Tokens: 2440
288. Winmerge-Src\Src\InternalPlugins.cpp - Lines: 1006 - Chars: 33887 - Tokens: 8472
289. Winmerge-Src\Src\InternalPlugins.h - Lines: 84 - Chars: 2554 - Tokens: 639
290. Winmerge-Src\Src\IntToIntMap.h - Lines: 39 - Chars: 594 - Tokens: 149
291. Winmerge-Src\Src\IOptionsPanel.h - Lines: 22 - Chars: 434 - Tokens: 109
292. Winmerge-Src\Src\JumpList.cpp - Lines: 268 - Chars: 7820 - Tokens: 1955
293. Winmerge-Src\Src\JumpList.h - Lines: 30 - Chars: 936 - Tokens: 234
294. Winmerge-Src\Src\LineFiltersDlg.cpp - Lines: 280 - Chars: 6937 - Tokens: 1735
295. Winmerge-Src\Src\LineFiltersDlg.h - Lines: 70 - Chars: 1806 - Tokens: 452
296. Winmerge-Src\Src\LineFiltersList.cpp - Lines: 203 - Chars: 5160 - Tokens: 1290
297. Winmerge-Src\Src\LineFiltersList.h - Lines: 69 - Chars: 1380 - Tokens: 345
298. Winmerge-Src\Src\LoadSaveCodepageDlg.cpp - Lines: 238 - Chars: 6854 - Tokens: 1714
299. Winmerge-Src\Src\LoadSaveCodepageDlg.h - Lines: 89 - Chars: 2842 - Tokens: 711
300. Winmerge-Src\Src\locality.cpp - Lines: 144 - Chars: 4315 - Tokens: 1079
301. Winmerge-Src\Src\locality.h - Lines: 18 - Chars: 328 - Tokens: 82
302. Winmerge-Src\Src\LocationBar.cpp - Lines: 126 - Chars: 2553 - Tokens: 639
303. Winmerge-Src\Src\LocationBar.h - Lines: 55 - Chars: 1245 - Tokens: 312
304. Winmerge-Src\Src\LocationView.cpp - Lines: 1114 - Chars: 33723 - Tokens: 8431
305. Winmerge-Src\Src\LocationView.h - Lines: 143 - Chars: 4930 - Tokens: 1233
306. Winmerge-Src\Src\Logger.cpp - Lines: 42 - Chars: 1168 - Tokens: 292
307. Winmerge-Src\Src\Logger.h - Lines: 48 - Chars: 1751 - Tokens: 438
308. Winmerge-Src\Src\MainFrm.cpp - Lines: 3974 - Chars: 133806 - Tokens: 33452
309. Winmerge-Src\Src\MainFrm.h - Lines: 490 - Chars: 18260 - Tokens: 4565
310. Winmerge-Src\Src\markdown.cpp - Lines: 901 - Chars: 20334 - Tokens: 5084
311. Winmerge-Src\Src\markdown.h - Lines: 80 - Chars: 2506 - Tokens: 627
312. Winmerge-Src\Src\MenuBar.cpp - Lines: 475 - Chars: 12966 - Tokens: 3242
313. Winmerge-Src\Src\MenuBar.h - Lines: 67 - Chars: 1887 - Tokens: 472
314. Winmerge-Src\Src\Merge.cpp - Lines: 1847 - Chars: 57215 - Tokens: 14304
315. Winmerge-Src\Src\Merge.h - Lines: 213 - Chars: 7548 - Tokens: 1887
316. Winmerge-Src\Src\Merge2.rc - Lines: 258 - Chars: 11868 - Tokens: 2967
317. Winmerge-Src\Src\Merge7zFormatMergePluginImpl.cpp - Lines: 153 - Chars: 5226 - Tokens: 1307
318. Winmerge-Src\Src\Merge7zFormatMergePluginImpl.h - Lines: 58 - Chars: 1871 - Tokens: 468
319. Winmerge-Src\Src\Merge7zFormatRegister.h - Lines: 32 - Chars: 777 - Tokens: 195
320. Winmerge-Src\Src\Merge7zFormatShellImpl.cpp - Lines: 122 - Chars: 4034 - Tokens: 1009
321. Winmerge-Src\Src\Merge7zFormatShellImpl.h - Lines: 35 - Chars: 1124 - Tokens: 281
322. Winmerge-Src\Src\MergeApp.cpp - Lines: 206 - Chars: 4351 - Tokens: 1088
323. Winmerge-Src\Src\MergeApp.h - Lines: 51 - Chars: 1125 - Tokens: 282
324. Winmerge-Src\Src\MergeAppCOMClass.cpp - Lines: 215 - Chars: 5498 - Tokens: 1375
325. Winmerge-Src\Src\MergeAppCOMClass.h - Lines: 117 - Chars: 3099 - Tokens: 775
326. Winmerge-Src\Src\MergeAppLib.h - Lines: 334 - Chars: 11298 - Tokens: 2825
327. Winmerge-Src\Src\MergeAppLib.idl - Lines: 35 - Chars: 1264 - Tokens: 316
328. Winmerge-Src\Src\MergeCmdLineInfo.cpp - Lines: 611 - Chars: 15345 - Tokens: 3837
329. Winmerge-Src\Src\MergeCmdLineInfo.h - Lines: 147 - Chars: 4562 - Tokens: 1141
330. Winmerge-Src\Src\MergeDarkMode.cpp - Lines: 287 - Chars: 6578 - Tokens: 1645
331. Winmerge-Src\Src\MergeDarkMode.h - Lines: 110 - Chars: 3847 - Tokens: 962
332. Winmerge-Src\Src\MergeDoc.cpp - Lines: 3599 - Chars: 109474 - Tokens: 27369
333. Winmerge-Src\Src\MergeDoc.h - Lines: 487 - Chars: 18626 - Tokens: 4657
334. Winmerge-Src\Src\MergeDocDiffCopy.cpp - Lines: 1070 - Chars: 33615 - Tokens: 8404
335. Winmerge-Src\Src\MergeDocDiffSync.cpp - Lines: 872 - Chars: 27980 - Tokens: 6995
336. Winmerge-Src\Src\MergeDocEncoding.cpp - Lines: 131 - Chars: 3314 - Tokens: 829
337. Winmerge-Src\Src\MergeDocLineDiffs.cpp - Lines: 501 - Chars: 14200 - Tokens: 3550
338. Winmerge-Src\Src\MergeEditFrm.cpp - Lines: 473 - Chars: 13662 - Tokens: 3416
339. Winmerge-Src\Src\MergeEditFrm.h - Lines: 95 - Chars: 2756 - Tokens: 689
340. Winmerge-Src\Src\MergeEditSplitterView.cpp - Lines: 135 - Chars: 3910 - Tokens: 978
341. Winmerge-Src\Src\MergeEditSplitterView.h - Lines: 59 - Chars: 1514 - Tokens: 379
342. Winmerge-Src\Src\MergeEditStatus.h - Lines: 18 - Chars: 432 - Tokens: 108
343. Winmerge-Src\Src\MergeEditView.cpp - Lines: 4597 - Chars: 128149 - Tokens: 32038
344. Winmerge-Src\Src\MergeEditView.h - Lines: 366 - Chars: 14416 - Tokens: 3604
345. Winmerge-Src\Src\MergeFrameCommon.cpp - Lines: 542 - Chars: 16990 - Tokens: 4248
346. Winmerge-Src\Src\MergeFrameCommon.h - Lines: 71 - Chars: 2966 - Tokens: 742
347. Winmerge-Src\Src\MergeLang.vcxproj - Lines: 342 - Chars: 20106 - Tokens: 5027
348. Winmerge-Src\Src\MergeLang.vcxproj.filters - Lines: 290 - Chars: 11571 - Tokens: 2893
349. Winmerge-Src\Src\MergeLineFlags.h - Lines: 31 - Chars: 853 - Tokens: 214
350. Winmerge-Src\Src\MergeStatusBar.cpp - Lines: 357 - Chars: 10673 - Tokens: 2669
351. Winmerge-Src\Src\MergeStatusBar.h - Lines: 74 - Chars: 2031 - Tokens: 508
352. Winmerge-Src\Src\MouseHook.cpp - Lines: 195 - Chars: 4401 - Tokens: 1101
353. Winmerge-Src\Src\MouseHook.h - Lines: 20 - Chars: 838 - Tokens: 210
354. Winmerge-Src\Src\MovedBlocks.cpp - Lines: 359 - Chars: 9461 - Tokens: 2366
355. Winmerge-Src\Src\MovedLines.cpp - Lines: 74 - Chars: 1529 - Tokens: 383
356. Winmerge-Src\Src\MovedLines.h - Lines: 38 - Chars: 797 - Tokens: 200
357. Winmerge-Src\Src\MyColorDialog.cpp - Lines: 18 - Chars: 453 - Tokens: 114
358. Winmerge-Src\Src\MyColorDialog.h - Lines: 10 - Chars: 193 - Tokens: 49
359. Winmerge-Src\Src\MyFontDialog.cpp - Lines: 34 - Chars: 1009 - Tokens: 253
360. Winmerge-Src\Src\MyFontDialog.h - Lines: 16 - Chars: 481 - Tokens: 121
361. Winmerge-Src\Src\MyReBar.cpp - Lines: 80 - Chars: 2079 - Tokens: 520
362. Winmerge-Src\Src\MyReBar.h - Lines: 16 - Chars: 265 - Tokens: 67
363. Winmerge-Src\Src\OpenDoc.cpp - Lines: 59 - Chars: 1301 - Tokens: 326
364. Winmerge-Src\Src\OpenDoc.h - Lines: 40 - Chars: 714 - Tokens: 179
365. Winmerge-Src\Src\OpenFrm.cpp - Lines: 128 - Chars: 2698 - Tokens: 675
366. Winmerge-Src\Src\OpenFrm.h - Lines: 43 - Chars: 830 - Tokens: 208
367. Winmerge-Src\Src\OpenTableDlg.cpp - Lines: 79 - Chars: 2204 - Tokens: 551
368. Winmerge-Src\Src\OpenTableDlg.h - Lines: 48 - Chars: 1067 - Tokens: 267
369. Winmerge-Src\Src\OpenView.h - Lines: 189 - Chars: 6739 - Tokens: 1685
370. Winmerge-Src\Src\OptionsCustomColors.cpp - Lines: 38 - Chars: 874 - Tokens: 219
371. Winmerge-Src\Src\OptionsCustomColors.h - Lines: 14 - Chars: 261 - Tokens: 66
372. Winmerge-Src\Src\OptionsDef.h - Lines: 346 - Chars: 20491 - Tokens: 5123
373. Winmerge-Src\Src\OptionsDiffColors.cpp - Lines: 108 - Chars: 6572 - Tokens: 1643
374. Winmerge-Src\Src\OptionsDiffColors.h - Lines: 48 - Chars: 1967 - Tokens: 492
375. Winmerge-Src\Src\OptionsDiffOptions.cpp - Lines: 61 - Chars: 2742 - Tokens: 686
376. Winmerge-Src\Src\OptionsDiffOptions.h - Lines: 13 - Chars: 282 - Tokens: 71
377. Winmerge-Src\Src\OptionsDirColors.cpp - Lines: 57 - Chars: 2731 - Tokens: 683
378. Winmerge-Src\Src\OptionsDirColors.h - Lines: 30 - Chars: 934 - Tokens: 234
379. Winmerge-Src\Src\OptionsEditorSyntax.cpp - Lines: 108 - Chars: 3348 - Tokens: 837
380. Winmerge-Src\Src\OptionsEditorSyntax.h - Lines: 15 - Chars: 339 - Tokens: 85
381. Winmerge-Src\Src\OptionsFont.cpp - Lines: 190 - Chars: 8691 - Tokens: 2173
382. Winmerge-Src\Src\OptionsFont.h - Lines: 18 - Chars: 518 - Tokens: 130
383. Winmerge-Src\Src\OptionsInit.cpp - Lines: 374 - Chars: 14950 - Tokens: 3738
384. Winmerge-Src\Src\OptionsInit.h - Lines: 11 - Chars: 125 - Tokens: 32
385. Winmerge-Src\Src\OptionsPanel.cpp - Lines: 19 - Chars: 325 - Tokens: 82
386. Winmerge-Src\Src\OptionsPanel.h - Lines: 28 - Chars: 525 - Tokens: 132
387. Winmerge-Src\Src\OptionsProject.cpp - Lines: 103 - Chars: 3041 - Tokens: 761
388. Winmerge-Src\Src\OptionsProject.h - Lines: 35 - Chars: 831 - Tokens: 208
389. Winmerge-Src\Src\OptionsSyntaxColors.cpp - Lines: 101 - Chars: 3046 - Tokens: 762
390. Winmerge-Src\Src\OptionsSyntaxColors.h - Lines: 18 - Chars: 416 - Tokens: 104
391. Winmerge-Src\Src\OutputBar.cpp - Lines: 126 - Chars: 2520 - Tokens: 630
392. Winmerge-Src\Src\OutputBar.h - Lines: 55 - Chars: 1229 - Tokens: 308
393. Winmerge-Src\Src\OutputDoc.cpp - Lines: 125 - Chars: 3013 - Tokens: 754
394. Winmerge-Src\Src\OutputDoc.h - Lines: 58 - Chars: 1296 - Tokens: 324
395. Winmerge-Src\Src\OutputView.cpp - Lines: 131 - Chars: 3063 - Tokens: 766
396. Winmerge-Src\Src\OutputView.h - Lines: 70 - Chars: 1589 - Tokens: 398
397. Winmerge-Src\Src\PatchDlg.cpp - Lines: 467 - Chars: 12055 - Tokens: 3014
398. Winmerge-Src\Src\PatchDlg.h - Lines: 127 - Chars: 3054 - Tokens: 764
399. Winmerge-Src\Src\PatchHTML.cpp - Lines: 465 - Chars: 12225 - Tokens: 3057
400. Winmerge-Src\Src\PatchHTML.h - Lines: 11 - Chars: 244 - Tokens: 61
401. Winmerge-Src\Src\PatchTool.cpp - Lines: 413 - Chars: 11746 - Tokens: 2937
402. Winmerge-Src\Src\PatchTool.h - Lines: 71 - Chars: 2082 - Tokens: 521
403. Winmerge-Src\Src\PathContext.cpp - Lines: 204 - Chars: 4105 - Tokens: 1027
404. Winmerge-Src\Src\PathContext.h - Lines: 169 - Chars: 3706 - Tokens: 927
405. Winmerge-Src\Src\paths.cpp - Lines: 830 - Chars: 22203 - Tokens: 5551
406. Winmerge-Src\Src\paths.h - Lines: 63 - Chars: 2137 - Tokens: 535
407. Winmerge-Src\Src\pch.cpp - Lines: 1 - Chars: 16 - Tokens: 4
408. Winmerge-Src\Src\pch.h - Lines: 23 - Chars: 416 - Tokens: 104
409. Winmerge-Src\Src\PluginManager.cpp - Lines: 59 - Chars: 1815 - Tokens: 454
410. Winmerge-Src\Src\PluginManager.h - Lines: 45 - Chars: 1161 - Tokens: 291
411. Winmerge-Src\Src\Plugins.h - Lines: 279 - Chars: 9527 - Tokens: 2382
412. Winmerge-Src\Src\PluginsListDlg.cpp - Lines: 472 - Chars: 12734 - Tokens: 3184
413. Winmerge-Src\Src\PluginsListDlg.h - Lines: 69 - Chars: 2034 - Tokens: 509
414. Winmerge-Src\Src\ProjectFile.cpp - Lines: 455 - Chars: 15871 - Tokens: 3968
415. Winmerge-Src\Src\ProjectFile.h - Lines: 929 - Chars: 26520 - Tokens: 6630
416. Winmerge-Src\Src\PropArchive.cpp - Lines: 86 - Chars: 1911 - Tokens: 478
417. Winmerge-Src\Src\PropArchive.h - Lines: 40 - Chars: 721 - Tokens: 181
418. Winmerge-Src\Src\PropBackups.cpp - Lines: 107 - Chars: 3235 - Tokens: 809
419. Winmerge-Src\Src\PropBackups.h - Lines: 50 - Chars: 927 - Tokens: 232
420. Winmerge-Src\Src\PropCodepage.cpp - Lines: 246 - Chars: 7959 - Tokens: 1990
421. Winmerge-Src\Src\PropCodepage.h - Lines: 63 - Chars: 1459 - Tokens: 365
422. Winmerge-Src\Src\PropColorSchemes.cpp - Lines: 216 - Chars: 6922 - Tokens: 1731
423. Winmerge-Src\Src\PropColorSchemes.h - Lines: 59 - Chars: 1362 - Tokens: 341
424. Winmerge-Src\Src\PropCompare.cpp - Lines: 156 - Chars: 6198 - Tokens: 1550
425. Winmerge-Src\Src\PropCompare.h - Lines: 68 - Chars: 1562 - Tokens: 391
426. Winmerge-Src\Src\PropCompareBinary.cpp - Lines: 164 - Chars: 4034 - Tokens: 1009
427. Winmerge-Src\Src\PropCompareBinary.h - Lines: 54 - Chars: 1189 - Tokens: 298
428. Winmerge-Src\Src\PropCompareFolder.cpp - Lines: 178 - Chars: 7183 - Tokens: 1796
429. Winmerge-Src\Src\PropCompareFolder.h - Lines: 71 - Chars: 1702 - Tokens: 426
430. Winmerge-Src\Src\PropCompareImage.cpp - Lines: 118 - Chars: 3394 - Tokens: 849
431. Winmerge-Src\Src\PropCompareImage.h - Lines: 54 - Chars: 1179 - Tokens: 295
432. Winmerge-Src\Src\PropCompareTable.cpp - Lines: 161 - Chars: 5633 - Tokens: 1409
433. Winmerge-Src\Src\PropCompareTable.h - Lines: 63 - Chars: 1483 - Tokens: 371
434. Winmerge-Src\Src\PropCompareWebPage.cpp - Lines: 96 - Chars: 3133 - Tokens: 784
435. Winmerge-Src\Src\PropCompareWebPage.h - Lines: 52 - Chars: 1143 - Tokens: 286
436. Winmerge-Src\Src\PropDirColors.cpp - Lines: 198 - Chars: 5366 - Tokens: 1342
437. Winmerge-Src\Src\PropDirColors.h - Lines: 77 - Chars: 2042 - Tokens: 511
438. Winmerge-Src\Src\PropEditor.cpp - Lines: 142 - Chars: 4082 - Tokens: 1021
439. Winmerge-Src\Src\PropEditor.h - Lines: 64 - Chars: 1358 - Tokens: 340
440. Winmerge-Src\Src\PropEditorCompareMerge.cpp - Lines: 146 - Chars: 4638 - Tokens: 1160
441. Winmerge-Src\Src\PropEditorCompareMerge.h - Lines: 66 - Chars: 1530 - Tokens: 383
442. Winmerge-Src\Src\PropEditorSyntax.cpp - Lines: 131 - Chars: 3347 - Tokens: 837
443. Winmerge-Src\Src\PropEditorSyntax.h - Lines: 59 - Chars: 1199 - Tokens: 300
444. Winmerge-Src\Src\PropertySystem.cpp - Lines: 385 - Chars: 9422 - Tokens: 2356
445. Winmerge-Src\Src\PropertySystem.h - Lines: 60 - Chars: 1730 - Tokens: 433
446. Winmerge-Src\Src\PropGeneral.cpp - Lines: 195 - Chars: 7516 - Tokens: 1879
447. Winmerge-Src\Src\PropGeneral.h - Lines: 67 - Chars: 1498 - Tokens: 375
448. Winmerge-Src\Src\PropMarkerColors.cpp - Lines: 134 - Chars: 3934 - Tokens: 984
449. Winmerge-Src\Src\PropMarkerColors.h - Lines: 62 - Chars: 1434 - Tokens: 359
450. Winmerge-Src\Src\PropMergeColors.cpp - Lines: 406 - Chars: 12659 - Tokens: 3165
451. Winmerge-Src\Src\PropMergeColors.h - Lines: 117 - Chars: 3441 - Tokens: 861
452. Winmerge-Src\Src\PropMessageBoxes.cpp - Lines: 236 - Chars: 8346 - Tokens: 2087
453. Winmerge-Src\Src\PropMessageBoxes.h - Lines: 57 - Chars: 1186 - Tokens: 297
454. Winmerge-Src\Src\PropProject.cpp - Lines: 148 - Chars: 3700 - Tokens: 925
455. Winmerge-Src\Src\PropProject.h - Lines: 57 - Chars: 1104 - Tokens: 276
456. Winmerge-Src\Src\PropRegistry.cpp - Lines: 154 - Chars: 4574 - Tokens: 1144
457. Winmerge-Src\Src\PropRegistry.h - Lines: 62 - Chars: 1519 - Tokens: 380
458. Winmerge-Src\Src\PropShell.cpp - Lines: 461 - Chars: 13736 - Tokens: 3434
459. Winmerge-Src\Src\PropShell.h - Lines: 58 - Chars: 1323 - Tokens: 331
460. Winmerge-Src\Src\PropSyntaxColors.cpp - Lines: 144 - Chars: 5851 - Tokens: 1463
461. Winmerge-Src\Src\PropSyntaxColors.h - Lines: 51 - Chars: 1244 - Tokens: 311
462. Winmerge-Src\Src\PropSysColors.cpp - Lines: 191 - Chars: 5913 - Tokens: 1479
463. Winmerge-Src\Src\PropSysColors.h - Lines: 63 - Chars: 1462 - Tokens: 366
464. Winmerge-Src\Src\PropTextColors.cpp - Lines: 223 - Chars: 6799 - Tokens: 1700
465. Winmerge-Src\Src\PropTextColors.h - Lines: 75 - Chars: 1941 - Tokens: 486
466. Winmerge-Src\Src\SaveClosingDlg.cpp - Lines: 138 - Chars: 3750 - Tokens: 938
467. Winmerge-Src\Src\SaveClosingDlg.h - Lines: 69 - Chars: 2087 - Tokens: 522
468. Winmerge-Src\Src\SelectPluginDlg.cpp - Lines: 452 - Chars: 13903 - Tokens: 3476
469. Winmerge-Src\Src\SelectPluginDlg.h - Lines: 96 - Chars: 2717 - Tokens: 680
470. Winmerge-Src\Src\SharedFilterDlg.cpp - Lines: 40 - Chars: 833 - Tokens: 209
471. Winmerge-Src\Src\SharedFilterDlg.h - Lines: 53 - Chars: 1254 - Tokens: 314
472. Winmerge-Src\Src\StdAfx.cpp - Lines: 36 - Chars: 1077 - Tokens: 270
473. Winmerge-Src\Src\StdAfx.h - Lines: 154 - Chars: 4021 - Tokens: 1006
474. Winmerge-Src\Src\stringdiffs.cpp - Lines: 1080 - Chars: 27443 - Tokens: 6861
475. Winmerge-Src\Src\stringdiffs.h - Lines: 46 - Chars: 1198 - Tokens: 300
476. Winmerge-Src\Src\stringdiffsi.h - Lines: 126 - Chars: 2783 - Tokens: 696
477. Winmerge-Src\Src\SubeditList.cpp - Lines: 742 - Chars: 19805 - Tokens: 4952
478. Winmerge-Src\Src\SubeditList.h - Lines: 166 - Chars: 4765 - Tokens: 1192
479. Winmerge-Src\Src\SubstitutionFiltersDlg.cpp - Lines: 256 - Chars: 7561 - Tokens: 1891
480. Winmerge-Src\Src\SubstitutionFiltersDlg.h - Lines: 61 - Chars: 1358 - Tokens: 340
481. Winmerge-Src\Src\SubstitutionFiltersList.cpp - Lines: 288 - Chars: 10028 - Tokens: 2507
482. Winmerge-Src\Src\SubstitutionFiltersList.h - Lines: 73 - Chars: 1662 - Tokens: 416
483. Winmerge-Src\Src\SubstitutionList.cpp - Lines: 169 - Chars: 3502 - Tokens: 876
484. Winmerge-Src\Src\SubstitutionList.h - Lines: 43 - Chars: 1173 - Tokens: 294
485. Winmerge-Src\Src\TempFile.cpp - Lines: 198 - Chars: 3922 - Tokens: 981
486. Winmerge-Src\Src\TempFile.h - Lines: 59 - Chars: 1352 - Tokens: 338
487. Winmerge-Src\Src\Test.cpp - Lines: 830 - Chars: 31031 - Tokens: 7758
488. Winmerge-Src\Src\TestFilterDlg.cpp - Lines: 112 - Chars: 2590 - Tokens: 648
489. Winmerge-Src\Src\TestFilterDlg.h - Lines: 54 - Chars: 1189 - Tokens: 298
490. Winmerge-Src\Src\TestMain.cpp - Lines: 23 - Chars: 471 - Tokens: 118
491. Winmerge-Src\Src\TestMain.h - Lines: 3 - Chars: 58 - Tokens: 15
492. Winmerge-Src\Src\TFile.h - Lines: 17 - Chars: 473 - Tokens: 119
493. Winmerge-Src\Src\TitleBarHelper.cpp - Lines: 425 - Chars: 13425 - Tokens: 3357
494. Winmerge-Src\Src\TitleBarHelper.h - Lines: 60 - Chars: 1782 - Tokens: 446
495. Winmerge-Src\Src\TrDialogs.cpp - Lines: 94 - Chars: 2169 - Tokens: 543
496. Winmerge-Src\Src\TrDialogs.h - Lines: 128 - Chars: 2909 - Tokens: 728
497. Winmerge-Src\Src\WebPageDiffFrm.cpp - Lines: 1734 - Chars: 52886 - Tokens: 13222
498. Winmerge-Src\Src\WebPageDiffFrm.h - Lines: 205 - Chars: 6977 - Tokens: 1745
499. Winmerge-Src\Src\WildcardDropList.cpp - Lines: 276 - Chars: 9161 - Tokens: 2291
500. Winmerge-Src\Src\WildcardDropList.h - Lines: 16 - Chars: 563 - Tokens: 141
501. Winmerge-Src\Src\Win_VersionHelper.h - Lines: 55 - Chars: 1334 - Tokens: 334
502. Winmerge-Src\Src\WindowsManagerDialog.cpp - Lines: 294 - Chars: 7497 - Tokens: 1875
503. Winmerge-Src\Src\WindowsManagerDialog.h - Lines: 86 - Chars: 2406 - Tokens: 602
504. Winmerge-Src\Src\WinIMergeLib.h - Lines: 210 - Chars: 9384 - Tokens: 2346
505. Winmerge-Src\Src\WinMergePluginBase.h - Lines: 640 - Chars: 26099 - Tokens: 6525
506. Winmerge-Src\Src\WinWebDiffLib.h - Lines: 220 - Chars: 9235 - Tokens: 2309
507. Winmerge-Src\Src\WMGotoDlg.cpp - Lines: 192 - Chars: 4698 - Tokens: 1175
508. Winmerge-Src\Src\WMGotoDlg.h - Lines: 34 - Chars: 744 - Tokens: 186
509. Winmerge-Src\Src\xdiff_gnudiff_compat.cpp - Lines: 199 - Chars: 5476 - Tokens: 1369
510. Winmerge-Src\Src\xdiff_gnudiff_compat.h - Lines: 8 - Chars: 370 - Tokens: 93

<file path="Winmerge-Src/Src/CompareEngines/BinaryCompare.cpp">
/**
 * @file  BinaryCompare.cpp
 *
 * @brief Implementation file for BinaryCompare
 */

#include "pch.h"
#include "BinaryCompare.h"
#include "DiffItem.h"
#include "PathContext.h"
#include "IAbortable.h"
#include "cio.h"

namespace CompareEngines
{

BinaryCompare::BinaryCompare() : m_piAbortable(nullptr)
{
}

BinaryCompare::~BinaryCompare() = default;

/**
 * @brief Set Abortable-interface.
 * @param [in] piAbortable Pointer to abortable interface.
 */
void BinaryCompare::SetAbortable(const IAbortable * piAbortable)
{
	m_piAbortable = const_cast<IAbortable*>(piAbortable);
}

static int compare_files(const String& file1, const String& file2, IAbortable *piAbortable)
{
	const size_t bufsize = 1024 * 256;
	int code;
	int fd1 = -1, fd2 = -1;
	
	cio::tsopen_s(&fd1, file1, O_BINARY | O_RDONLY, _SH_DENYNO, _S_IREAD);
	cio::tsopen_s(&fd2, file2, O_BINARY | O_RDONLY, _SH_DENYNO, _S_IREAD);
	if (fd1 != -1 && fd2 != -1)
	{
		for (;;)
		{
			if (piAbortable && piAbortable->ShouldAbort())
			{
				code = DIFFCODE::CMPABORT;
				break;
			}
			char buf1[bufsize];
			char buf2[bufsize];
			int size1 = cio::read_i(fd1, buf1, sizeof(buf1));
			int size2 = cio::read_i(fd2, buf2, sizeof(buf2));
			if (size1 <= 0 || size2 <= 0)
			{
				if (size1 < 0 || size2 < 0)
					code = DIFFCODE::CMPERR;
				else if (size1 == size2)
					code = DIFFCODE::SAME;
				else
					code = DIFFCODE::DIFF;
				break;
			}
			if (size1 != size2 || memcmp(buf1, buf2, size1) != 0)
			{
				code = DIFFCODE::DIFF;
				break;
			}
		}
	}
	else
	{
		code = DIFFCODE::CMPERR;
	}
	if (fd1 != -1)
		cio::close(fd1);
	if (fd2 != -1)
		cio::close(fd2);

	return code;
}

/**
 * @brief Compare two specified files, byte-by-byte
 * @param [in] di Diffitem info.
 * @return DIFFCODE
 */
int BinaryCompare::CompareFiles(const PathContext& files, const DIFFITEM &di) const
{
	auto cmp = [&](int p1, int p2) -> unsigned
	{
		if (di.diffFileInfo[p1].size == DirItem::FILE_SIZE_NONE &&
			di.diffFileInfo[p2].size == DirItem::FILE_SIZE_NONE)
			return DIFFCODE::SAME;
		// If the file size is 0, don't immediately assume that there is a difference even if the files have different sizes, because of possible symlinks.
		if (di.diffFileInfo[p1].size == DirItem::FILE_SIZE_NONE ||
			di.diffFileInfo[p2].size == DirItem::FILE_SIZE_NONE ||
			(di.diffFileInfo[p1].size != di.diffFileInfo[p2].size &&
			 di.diffFileInfo[p1].size != 0 && di.diffFileInfo[p2].size != 0))
			return DIFFCODE::DIFF;
		return compare_files(files[p1], files[p2], m_piAbortable);
	};
	switch (files.GetSize())
	{
	case 2:
		return cmp(0, 1);
	case 3:
		unsigned code10 = cmp(1, 0);
		unsigned code12 = cmp(1, 2);
		unsigned code02 = DIFFCODE::SAME;
		if (code10 == DIFFCODE::SAME && code12 == DIFFCODE::SAME)
			return DIFFCODE::SAME;
		else if (code10 == DIFFCODE::SAME && code12 == DIFFCODE::DIFF)
			return DIFFCODE::DIFF | DIFFCODE::DIFF3RDONLY;
		else if (code10 == DIFFCODE::DIFF && code12 == DIFFCODE::SAME)
			return DIFFCODE::DIFF | DIFFCODE::DIFF1STONLY;
		else if (code10 == DIFFCODE::DIFF && code12 == DIFFCODE::DIFF)
		{
			code02 = cmp(0, 2);
			if (code02 == DIFFCODE::SAME)
				return DIFFCODE::DIFF | DIFFCODE::DIFF2NDONLY;
		}
		if (code10 == DIFFCODE::CMPERR || code12 == DIFFCODE::CMPERR || code02 == DIFFCODE::CMPERR)
			return DIFFCODE::CMPERR;
		return DIFFCODE::DIFF;
	}
	return DIFFCODE::CMPERR;
}

} // namespace CompareEngines
</file>

<file path="Winmerge-Src/Src/CompareEngines/BinaryCompare.h">
/**
 * @file  BinaryCompare.h
 *
 * @brief Declaration file for BinaryCompare compare engine.
 */
#pragma once

class DIFFITEM;
class PathContext;
class IAbortable;

namespace CompareEngines
{

/**
 * @brief A binary compare class.
 * This compare method compares files by their binary contents.
 */
class BinaryCompare
{
public:
	BinaryCompare();
	~BinaryCompare();
	void SetAbortable(const IAbortable * piAbortable);
	int CompareFiles(const PathContext& files, const DIFFITEM &di) const;
private:
	IAbortable * m_piAbortable;
};

} // namespace CompareEngines
</file>

<file path="Winmerge-Src/Src/CompareEngines/ByteComparator.cpp">
/**
 * @file  ByteComparator.cpp
 *
 * @brief Implements ByteComparator class.
 */

#include "pch.h"
#include "ByteComparator.h"
#include <cassert>
#include "UnicodeString.h"
#include "FileTextStats.h"
#include "CompareOptions.h"

/**
 * @brief Returns if given char is EOL byte.
 * @param [in] ch Char to test.
 * @return true if char is EOL byte, false otherwise.
 */
static inline bool iseolch(tchar_t ch)
{
	return ch == '\n' || ch == '\r';
}

/**
 * @brief Returns if given char is whitespace char.
 * @param [in] ch Char to test.
 * @return true if char is whitespace char, false otherwise.
 * @todo What about nbsp or various Unicode spacing codes?
 */
static inline bool iswsch(tchar_t ch)
{
	return ch == ' ' || ch == '\t';
}

/**
 * @brief Calculates statistics from given buffer.
 * This function calculates EOL byte and zero-byte statistics from given
 * buffer.
 * @param [in,out] stats Structure holding statistics.
 * @param [in] ptr Pointer to begin of the buffer.
 * @param [in] end Pointer to end of buffer.
 * @param [in] eof Is buffer end also end of file?
 * @param [in] crflag Did previous scan end to CR?
 * @param [in] offset Byte offset in whole file (among several buffers).
 */
static void TextScan(FileTextStats & stats, const char *ptr, const char *end, bool eof,
		bool crflag, int64_t offset)
{
	// Handle any crs left from last buffer
	if (crflag)
	{
		if (ptr < end && *ptr == '\n')
		{
			++stats.ncrlfs;
			++ptr;
		}
		else
		{
			++stats.ncrs;
		}
	}
	for (; ptr < end; ++ptr)
	{
		char ch = *ptr;
		if (ch == 0)
		{
			++stats.nzeros;
		}
		else if (ch == '\r')
		{
			if (ptr + 1 < end)
			{
				if (ptr[1] == '\n')
				{
					++stats.ncrlfs;
					++ptr;
				}
				else
				{
					++stats.ncrs;
				}
			}
			else if (eof)
			{
				++stats.ncrs;
			}
			else
			{
				// else last byte of buffer
				// leave alone, the CompareBuffers loop will set the appropriate m_cr flag
				// and we'll handle it next time we're called
			}
		}
		else if (ch == '\n')
		{
			++stats.nlfs;
		}
	}
}

namespace CompareEngines
{

/**
 * @brief Constructor taking compare options as parameters.
 * @param [in] options Compare options.
 */
ByteComparator::ByteComparator(const QuickCompareOptions * options)
// settings
		: m_ignore_case(options->m_bIgnoreCase)
		, m_ignore_eol_diff(options->m_bIgnoreEOLDifference)
		, m_ignore_blank_lines(options->m_bIgnoreBlankLines)
		, m_ignore_numbers(options->m_bIgnoreNumbers)
// state
		, m_wsflag(false)
		, m_eol0(false)
		, m_eol1(false)
		, m_cr0(false)
		, m_cr1(false)
		, m_bol0(true)
		, m_bol1(true)
{
	if (options->m_ignoreWhitespace == WHITESPACE_IGNORE_CHANGE)
		m_ignore_space_change = true;
	else
		m_ignore_space_change = false;

	if (options->m_ignoreWhitespace == WHITESPACE_IGNORE_ALL)
		m_ignore_all_space = true;
	else
		m_ignore_all_space = false;
}

static const char* SkipBlankLines(const char* p, const char* end)
{
	for (;;)
	{
		const char* tmp = p;
		while (tmp < end && iswsch(*tmp))
			++tmp;
		while (tmp < end && iseolch(*tmp))
			++tmp;
		if (tmp == p || !iseolch(*(tmp - 1)))
			break;
		p = tmp;
	}
	return p;
};

/**
 * @brief Compare two buffers byte per byte.
 *
 * This function compares two buffers pointed to by @p ptr0 and @p ptr1.
 * Comparing takes account diffutils options flags given to constructor.
 * Buffer pointers are advanced while comparing so they point to current
 * compare position. End of buffers are given by @p end0 and @p end1, which
 * may point past last valid byte in file. Offset-params tell is how far this
 * buffer is into the file (ie, 0 the first time called).
 * @param [in,out] stats0 Statistics for first side.
 * @param [in,out] stats1 Statistics for second side.
 * @param [in,out] ptr0 Pointer to begin of the first buffer.
 * @param [in,out] ptr1 Pointer to begin of the second buffer.
 * @param [in] end0 Pointer to end of the first buffer.
 * @param [in] end1 Pointer to end of the second buffer.
 * @param [in] eof0 Is first buffers end also end of the file?
 * @param [in] eof1 Is second buffers end also end of the file?
 * @param [in] offset0 Offset of the buffer begin in the first file.
 * @param [in] offset1 Offset of the buffer begin in the second file.
 * @return COMP_RESULT telling result of the compare.
 */
ByteComparator::COMP_RESULT ByteComparator::CompareBuffers(
	FileTextStats & stats0, FileTextStats & stats1, const char* &ptr0, const char* &ptr1,
	const char* end0, const char* end1, bool eof0, bool eof1, int64_t offset0, int64_t offset1)
{
	ByteComparator::COMP_RESULT result = RESULT_SAME;

	// First, update file text statistics by doing a full scan
	// for 0s and all types of line delimiters
	TextScan(stats0, ptr0, end0, eof0, m_cr0, offset0);
	TextScan(stats1, ptr1, end1, eof1, m_cr1, offset1);

	const char *orig0 = ptr0;
	const char *orig1 = ptr1;

	// cycle through buffer data performing actual comparison
	while (true)
	{
		if (m_ignore_all_space)
		{
			// Skip over any whitespace on either side
			// skip over all whitespace
			while (ptr0 < end0 && iswsch(*ptr0))
			{
				m_bol0 = false;
				++ptr0;
			}
			// skip over all whitespace
			while (ptr1 < end1 && iswsch(*ptr1))
			{
				m_bol1 = false;
				++ptr1;
			}
			if ((ptr0 == end0 && !eof0) || (ptr1 == end1 && !eof1))
			{
				goto need_more;
			}
		}
		if (m_ignore_space_change)
		{
			// Skip over whitespace change
			// Also skip whitespace on one side if
			//  either end of line or end of file on other

			// Handle case of whitespace on side0
			// (First four cases)
			if (ptr0 < end0 && iswsch(*ptr0))
			{
				// Whitespace on side0

				if (ptr1 < end1)
				{
					if (iswsch(*ptr1))
					{
						// whitespace on both sides
						m_wsflag = true;
						m_bol0 = false;
						++ptr0;
						m_bol1 = false;
						++ptr1;
					}
					else if (iseolch(*ptr1))
					{
						// whitespace on side 0 (end of line on side 1)
						m_wsflag = true;
						m_bol0 = false;
						++ptr0;
					}
				}
				else // ptr1 == end1
				{
					if (!eof1)
					{
						// Whitespace on side0, don't know what is on side1
						// Cannot tell if matching whitespace yet
						goto need_more;
					}
					else // eof1
					{
						// Whitespace on side0, eof on side1
						m_wsflag = true;
						m_bol0 = false;
						++ptr0;
					}
				}
			}
			else
			{
				// Handle case of whitespace on side1
				// but not whitespace on side0 (that was handled above)
				// (Remaining three cases)
				if (ptr1 < end1 && iswsch(*ptr1))
				{
					// Whitespace on side1

					if (ptr0 < end0)
					{
						// "whitespace on both sides"
						// should not come here, it should have been
						// handled above
						assert(!iswsch(*ptr0));

						if (iseolch(*ptr0))
						{
							// whitespace on side 1 (eol on side 0)
							m_wsflag = true;
							m_bol1 = false;
							++ptr1;
						}
					}
					else // ptr0 == end0
					{
						if (!eof0)
						{
							// Whitespace on side1, don't know what is on side0
							// Cannot tell if matching whitespace yet
							goto need_more;
						}
						else // eof0
						{
							// Whitespace on side1, eof on side0
							m_wsflag = true;
							m_bol1 = false;
							++ptr1;
						}
					}
				}
			}

			if (m_wsflag)
			{
				// skip over consecutive whitespace
				while (ptr0 < end0 && iswsch(*ptr0))
				{
					m_bol0 = false;
					++ptr0;
				}
				// skip over consecutive whitespace
				while (ptr1 < end1 && iswsch(*ptr1))
				{
					m_bol1 = false;
					++ptr1;
				}
				if ((ptr0 == end0 && !eof0) || (ptr1 == end1 && !eof1))
				{
					// if run out of buffer on either side
					// must fetch more, to continue skipping whitespace
					m_wsflag = true;
					goto need_more;
				}
			}
			m_wsflag = false;
		}
		if (m_ignore_eol_diff)
		{
			if (m_ignore_blank_lines)
			{
				// skip over any line delimiters on either side
				while (ptr0 < end0 && iseolch(*ptr0))
					m_bol0 = true, ++ptr0;
				while (ptr1 < end1 && iseolch(*ptr1))
					m_bol1 = true, ++ptr1;
				if (m_bol0)
					ptr0 = SkipBlankLines(ptr0, end0);
				if (m_bol1)
					ptr1 = SkipBlankLines(ptr1, end1);
				if ((ptr0 == end0 && !eof0) || (ptr1 == end1 && !eof1))
				{
					goto need_more;
				}
			}
			else // don't skip blank lines, but still ignore eol difference
			{
				const char* ptr0b = ptr0;
				const char* ptr1b = ptr1;
				HandleSide0Eol((char **) &ptr0, end0, eof0);
				HandleSide1Eol((char **) &ptr1, end1, eof1);

				if (m_cr0 || m_cr1)
				{
					// these flags mean possible split CR/LF
					goto need_more;
				}
				if (m_eol0 || m_eol1)
				{
					if ((!m_eol0 || !m_eol1) && (orig0 == end0 || orig1 == end1))
					{
						// one side had an end-of-line, but the other didn't
						ptr0 = ptr0b;
						ptr1 = ptr1b;
						result = RESULT_DIFF;
						goto exit;
					}
					if (ptr0 != end0 && ptr1 != end1)
						// This continue statement is needed to handle blank lines
						continue;
				}
			}
		}
		else
		{ // do not ignore eol differences
			if (m_ignore_blank_lines)
			{
				if (m_bol0)
					ptr0 = SkipBlankLines(ptr0, end0);
				if (m_bol1)
					ptr1 = SkipBlankLines(ptr1, end1);
				if ((ptr0 == end0 && !eof0) || (ptr1 == end1 && !eof1))
				{
					goto need_more;
				}
			}
		}

		if (ptr0 == end0 || ptr1 == end1)
		{
			if (ptr0 == end0 && ptr1 == end1)
			{
				if (!eof0 || !eof1)
					goto need_more;
				else
				{
					result = (m_eol0 == m_eol1) ? RESULT_SAME : RESULT_DIFF;
					goto exit;
				}
			}
			else
			{
				// we are at the end on one side?
				if ((!(ptr0 == end0 && eof0) && !(ptr1 == end1 && eof1)) && (orig0 != end0 && orig1 != end1))
				{
					goto need_more;
				}
				else
				{
					result = RESULT_DIFF;
					goto exit;
				}
			}
		}

		tchar_t c0 = *ptr0, c1 = *ptr1;
		if (m_ignore_case)
		{
			c0 = tc::istupper(c0) ? tc::totlower(c0) : c0;
			c1 = tc::istupper(c1) ? tc::totlower(c1) : c1;
		}
		if (c0 != c1)
		{
			result = RESULT_DIFF; // buffers are different
			goto exit;
		}
		if (ptr0 < end0 && ptr1 < end1)
		{
			m_bol0 = iseolch(c0);
			m_bol1 = iseolch(c1);
			++ptr0;
			++ptr1;
			continue;
		}
		goto need_more;
	}

need_more:
	m_cr0 = (ptr0 - 1 >= orig0 && *(ptr0 - 1) == '\r');
	m_cr1 = (ptr1 - 1 >= orig1 && *(ptr1 - 1) == '\r');
	if (ptr0 == end0 && !eof0)
	{
		if (ptr1 == end1 && !eof1)
			return NEED_MORE_BOTH;
		else
			return NEED_MORE_0;
	}
	else if (ptr1 == end1 && !eof1)
	{
		return NEED_MORE_1;
	}
	else
	{
		return result;
	}

exit:
	m_cr0 = (end0 > orig0) && *(end0 - 1) == '\r';
	m_cr1 = (end1 > orig1) && *(end1 - 1) == '\r';
	return result;
}

/**
 * Brief Handle EOL bytes and differences in them.
 * @param [in, out] ptr Pointer to the buffer begin.
 * @param [in] end Pointer to the buffer end.
 * @param [in] eof Are we at end of the buffer?
 */
inline void ByteComparator::HandleSide0Eol(char **ptr, const char *end, bool eof)
{
	char * pbuf = *ptr;
	if (m_cr0)
	{
		// finish split CR/LF pair on 0-side
		if (pbuf < end && *pbuf == '\n')
		{
			// m_bol0 not used because m_ignore_eol_diff and m_ignore_blank_lines
			++pbuf;
		}
		m_eol0 = true;
		m_cr0 = false;
	}
	if (pbuf < end)
	{
		if (*pbuf == '\n')
		{
			// m_bol0 not used because m_ignore_eol_diff and m_ignore_blank_lines
			++pbuf;
			m_eol0 = true;
		}
		else if (*pbuf == '\r')
		{
			// m_bol0 not used because m_ignore_eol_diff and m_ignore_blank_lines
			++pbuf;
			m_eol0 = true;
			if (pbuf == end && !eof)
			{
				// can't tell if a CR/LF pair yet
				m_cr0 = true;
				m_eol0 = true;
			}
			else if (pbuf < end && *pbuf == '\n')
			{
				++pbuf;
			}
		}
		else
		{
			m_eol0 = false;
		}
	}
	*ptr = pbuf;
}

/**
 * Brief Handle EOL bytes and differences in them.
 * @param [in, out] ptr Pointer to the buffer begin.
 * @param [in] end Pointer to the buffer end.
 * @param [in] eof Are we at end of the buffer?
 */
inline void ByteComparator::HandleSide1Eol(char **ptr, const char *end, bool eof)
{
	char * pbuf = *ptr;

	if (m_cr1)
	{
		// finish split CR/LF pair on 1-side
		if (pbuf < end && *pbuf == '\n')
		{
			// m_bol1 not used because m_ignore_eol_diff
			++pbuf;
		}
		m_eol1 = true;
		m_cr1 = false;
	}
	if (pbuf < end)
	{
		if (*pbuf == '\n')
		{
			// m_bol1 not used because m_ignore_eol_diff
			++pbuf;
			m_eol1 = true;
		}
		else if (*pbuf == '\r')
		{
			// m_bol1 not used because m_ignore_eol_diff
			++pbuf;
			m_eol1 = true;
			if (pbuf == end && !eof)
			{
				// can't tell if a CR/LF pair yet
				m_cr1 = true;
				m_eol1 = true;
			}
			else if (pbuf < end && *pbuf == '\n')
			{
				++pbuf;
			}
		}
		else
		{
			m_eol1 = false;
		}
	}
	*ptr = pbuf;
}

} //namespace CompareEngines

</file>

<file path="Winmerge-Src/Src/CompareEngines/ByteComparator.h">
/**
 * @file ByteComparator.h
 *
 * @brief Declaration file for ByteComparator class.
 */
#pragma once

#include <cstdint>

class QuickCompareOptions;
struct FileTextStats;

namespace CompareEngines
{

/**
 * @brief Byte per byte compare class implementing Quick Compare.
 *
 * This class implements WinMerge's Quick Compare -compare method. Basically it
 * compares two buffers byte per byte. But it also respects WinMerge compare
 * options for whitespace ignore etc. Which makes it more complex than just
 * simple byte per byte compare. Also counts EOL / 0-byte statistics from
 * buffers so we can detect binary files and EOL types.
 */
class ByteComparator
{
public:
	explicit ByteComparator(const QuickCompareOptions * options);

public:
	/** @brief Return values for CompareBuffers method. */
	typedef enum
	{
		RESULT_DIFF, /**< Buffers are different */
		RESULT_SAME, /**< Buffers are identical */
		NEED_MORE_0, /**< First buffer needs more data */
		NEED_MORE_1, /**< Second buffer needs more data */
		NEED_MORE_BOTH, /**< Both buffers need more data */
	} COMP_RESULT;

	COMP_RESULT CompareBuffers(FileTextStats & stats0, FileTextStats & stats1,
			const char* &ptr0, const char* &ptr1, const char* end0, const char* end1,
			bool eof0, bool eof1, int64_t offset0, int64_t offset1);

protected:
	void HandleSide0Eol(char **ptr, const char *end, bool eof);
	void HandleSide1Eol(char **ptr, const char *end, bool eof);

private:
	// settings
	bool m_ignore_case; /**< Ignore character case */
	bool m_ignore_numbers; /**< Ignore character case */
	bool m_ignore_space_change; /**< Ignore change in whitespace char count */
	bool m_ignore_all_space; /**< Ignore all whitespace changes */
	bool m_ignore_eol_diff; /**< Ignore differences in EOL bytes */
	bool m_ignore_blank_lines; /**< Ignore blank lines */
	// state
	bool m_wsflag; /**< ignore_space_change & in a whitespace area */
	bool m_eol0; /**< 0-side has an eol */
	bool m_eol1; /**< 1-side has an eol */
	bool m_cr0; /**< 0-side has a CR at end of buffer (might be split CR/LF) */
	bool m_cr1; /**< 1-side has a CR at end of buffer (might be split CR/LF) */
	bool m_bol0; /**< 0-side is at beginning of line (!ignore_eol_differences & ignore_blank_lines) */
	bool m_bol1; /**< 1-side is at beginning of line (!ignore_eol_differences & ignore_blank_lines) */
};

} // namespace CompareEngines
</file>

<file path="Winmerge-Src/Src/CompareEngines/ByteCompare.cpp">
/**
 * @file  ByteCompare.cpp
 *
 * @brief Implementation file for ByteCompare
 */

#include "pch.h"
#include "ByteCompare.h"
#include <cassert>
#include "cio.h"
#include "FileLocation.h"
#include "UnicodeString.h"
#include "IAbortable.h"
#include "CompareOptions.h"
#include "DiffContext.h"
#include "diff.h"
#include "ByteComparator.h"
#include "DiffFileData.h"

namespace CompareEngines
{

static const int KILO = 1024; // Kilo(byte)

/** @brief Quick contents compare's file buffer size. */
static const int WMCMPBUFF = 32 * KILO;

/**
 * @brief Default constructor.
 */
ByteCompare::ByteCompare()
		: m_pOptions(nullptr)
		, m_piAbortable(nullptr)
{
}

/**
 * @brief Default destructor.
 */
ByteCompare::~ByteCompare() = default;

/**
 * @brief Set compare options from general compare options.
 * @param [in ]options General compare options.
 */
void ByteCompare::SetCompareOptions(const CompareOptions & options)
{
	m_pOptions.reset(new QuickCompareOptions(options));
}

/**
 * @brief Set compare-type specific options.
 * @param [in] stopAfterFirstDiff Do we stop compare after first found diff.
 */
void ByteCompare::SetAdditionalOptions(bool stopAfterFirstDiff)
{
	m_pOptions->m_bStopAfterFirstDiff = stopAfterFirstDiff;
}

/**
 * @brief Set Abortable-interface.
 * @param [in] piAbortable Pointer to abortable interface.
 */
void ByteCompare::SetAbortable(const IAbortable * piAbortable)
{
	m_piAbortable = const_cast<IAbortable*>(piAbortable);
}

/**
 * @brief Compare two specified files, byte-by-byte
 * @return DIFFCODE
 */
int ByteCompare::CompareFiles(DiffFileData* diffData)
{
	diffData->m_textStats[0].clear();
	diffData->m_textStats[1].clear();

	// TODO
	// Right now, we assume files are in 8-bit encoding
	// because transform code converted any UCS-2 files to UTF-8
	// We could compare directly in UCS-2LE here, as an optimization, in that case
	char buff[2][WMCMPBUFF]; // buffered access to files
	std::string lasteol[2];
	int i;
	unsigned diffcode = 0;

	// area of buffer currently holding data
	int64_t bfstart[2]; // offset into buff[i] where current data resides
	int64_t bfend[2]; // past-the-end pointer into buff[i], giving end of current data
	// buff[0] has bytes to process from buff[0][bfstart[0]] to buff[0][bfend[0]-1]

	bool eof[2]; // if we've finished file

	// initialize our buffer pointers and end of file flags
	for (i = 0; i < 2; ++i)
	{
		bfstart[i] = bfend[i] = 0;
		eof[i] = false;
	}

	ByteComparator comparator(m_pOptions.get());

	// Begin loop
	// we handle the files in WMCMPBUFF sized buffers (variable buff[][])
	// That is, we do one buffer full at a time
	// or even less, as we process until one side buffer is empty, then reload that one
	// and continue
	while (!eof[0] || !eof[1])
	{
		if (m_piAbortable != nullptr && m_piAbortable->ShouldAbort())
			return DIFFCODE::CMPABORT;

		// load or update buffers as appropriate
		for (i = 0; i < 2; ++i)
		{
			if (!eof[i] && bfstart[i] == sizeof(buff[i])/sizeof(buff[i][0]))
			{
				bfstart[i] = bfend[i] = 0;
			}
			if (!eof[i] && bfend[i] < sizeof(buff[i])/sizeof(buff[i][0]) - 1)
			{
				// Assume our blocks are in range of int
				int space = sizeof(buff[i])/sizeof(buff[i][0]) - (int) bfend[i];
				int rtn = cio::read_i(diffData->m_inf[i].desc, &buff[i][bfend[i]], space);
				if (rtn == -1)
					return DIFFCODE::CMPERR;
				if (rtn < space)
					eof[i] = true;
				bfend[i] += rtn;
				if (m_pOptions->m_bIgnoreMissingTrailingEol)
				{
					for (int64_t j = (std::max)(bfstart[i], bfend[i] - 4); j < bfend[i]; ++j)
					{
						const char c = buff[i][j];
						if (c == '\r' || c == '\n')
							lasteol[i].push_back(c);
						else
							lasteol[i].clear();
					}
				}
				if (diffData->m_inf[0].desc == diffData->m_inf[1].desc)
				{
					bfstart[1] = bfstart[0];
					bfend[1] = bfend[0];
					eof[1] = eof[0];
					lasteol[1] = lasteol[0];
					diffData->m_FileLocation[1] = diffData->m_FileLocation[0];
					memcpy(&buff[1][bfend[1] - rtn], &buff[0][bfend[0] - rtn], rtn);
					break;
				}
			}
		}
		// where to start comparing right now
		const char* ptr0 = &buff[0][bfstart[0]];
		const char* ptr1 = &buff[1][bfstart[1]];

		// remember where we started
		const char* orig0 = ptr0;
		const char* orig1 = ptr1;

		// how far can we go right now?
		const char* end0 = &buff[0][bfend[0]];
		const char* end1 = &buff[1][bfend[1]];

		int64_t offset0 = (ptr0 - &buff[0][0]);
		int64_t offset1 = (ptr1 - &buff[1][0]);

		// are these two buffers the same?
		int result = comparator.CompareBuffers(diffData->m_textStats[0], diffData->m_textStats[1],
				ptr0, ptr1, end0, end1, eof[0], eof[1], offset0, offset1);
		if (result == ByteComparator::RESULT_DIFF)
		{
			if (m_pOptions->m_bStopAfterFirstDiff)
			{
				// By bailing out here
				// we leave our text statistics incomplete
				return diffcode | DIFFCODE::DIFF;
			}
			else
			{
				if (m_pOptions->m_bIgnoreMissingTrailingEol)
				{
					if ((eof[0] || eof[1]) &&
						((end0 - ptr0 <= 1 && (lasteol[0] == "\r" || lasteol[0] == "\n" || lasteol[0] == "\r\n") && (end1 == ptr1))) ||
						((end0 - ptr0 == 2 && (lasteol[0] == "\r\n") && (end1 == ptr1))) ||
						((end1 - ptr1 <= 1 && (lasteol[1] == "\r" || lasteol[1] == "\n" || lasteol[1] == "\r\n") && (end0 == ptr0))) ||
						((end1 - ptr1 == 2 && (lasteol[1] == "\r\n") && (end0 == ptr0))))
						;
					else
						diffcode |= DIFFCODE::DIFF;
				}
				else
				{
					diffcode |= DIFFCODE::DIFF;
				}
				ptr0 = end0;
				ptr1 = end1;
				// move our current pointers over what we just compared
				assert(ptr0 >= orig0);
				assert(ptr1 >= orig1);
				bfstart[0] += ptr0 - orig0;
				bfstart[1] += ptr1 - orig1;
			}
		}
		else if (result == ByteComparator::NEED_MORE_0)
		{
			const int m = (int)(ptr0 - &buff[0][0]);
			const int l = (int)(end0 - ptr0);
			//move uncompared data to begin of buff0
			memcpy(&buff[0][0], &buff[0][m], l);
			bfstart[0] = 0;
			bfstart[1] += ptr1 - orig1;
			bfend[0] = l;
		}
		else if (result == ByteComparator::NEED_MORE_1)
		{
			const int m = (int)(ptr1 - &buff[1][0]);
			const int l = (int)(end1 - ptr1);
			//move uncompared data to begin of buff1
			memcpy(&buff[1][0], &buff[1][m], l);
			bfstart[1] = 0;
			bfstart[0] += ptr0 - orig0;
			bfend[1] = l;
		}
		else if (result == ByteComparator::NEED_MORE_BOTH)
		{
			if ((end0 == ptr0) && (end1 == ptr1))
			{
				bfstart[0] += ptr0 - orig0;
				bfend[0] = 0;
				bfstart[1] += ptr1 - orig1;
				bfend[1] = 0;
			}
			else
			{
				if (ptr0 < end0)
				{
					const int m = (int)(ptr0 - orig0);
					const int l = (int)(end0 - ptr0);
					//move uncompared data to begin of buff0
					memcpy(&buff[0][0], &buff[0][m], l);
					bfstart[0] = 0;
					bfend[0] += l;
				}
				if (ptr1 < end1)
				{
					const int m = (int)(ptr1 - orig1);
					const int l = (int)(end1 - ptr1);
					//move uncompared data to begin of buff1
					memcpy(&buff[1][0], &buff[1][ m], l);
					bfstart[1] = 0;
					bfend[1] += l;
				}
			}
		}
		else
		{
			assert(result == ByteComparator::RESULT_SAME);
		}

		// Did we finish both files?
		// We set the text/binary status only for fully compared files. Only
		// then the result is reliable.
		if (eof[0] && eof[1])
		{
			bool bBin0 = (diffData->m_textStats[0].nzeros > 0);
			bool bBin1 = (diffData->m_textStats[1].nzeros > 0);

			if (bBin0 && bBin1)
				diffcode |= DIFFCODE::BIN | DIFFCODE::BINSIDE1 | DIFFCODE::BINSIDE2;
			else if (bBin0)
				diffcode |= DIFFCODE::BIN | DIFFCODE::BINSIDE1;
			else if (bBin1)
				diffcode |= DIFFCODE::BIN | DIFFCODE::BINSIDE2;
			else
				diffcode |= DIFFCODE::TEXT;

			// If either unfinished, they differ
			if (ptr0 != end0 || ptr1 != end1)
				diffcode = (diffcode & DIFFCODE::DIFF);
			if (diffcode & DIFFCODE::DIFF)
				return diffcode | DIFFCODE::DIFF;
			else
				return diffcode | DIFFCODE::SAME;
		}
	}
	return diffcode;
}

} // namespace CompareEngines
</file>

<file path="Winmerge-Src/Src/CompareEngines/ByteCompare.h">
/**
 * @file  ByteCompare.h
 *
 * @brief Declaration file for ByteCompare
 */
#pragma once

#include <memory>
#include "FileTextStats.h"

class CompareOptions;
class QuickCompareOptions;
class IAbortable;
struct DiffFileData;

namespace CompareEngines
{

/**
 * @brief A quick compare -compare method implementation class.
 * This compare method compares files in small blocks. Code assumes block size
 * is in range of 32-bit int-type.
 */
class ByteCompare
{
public:
	ByteCompare();
	~ByteCompare();

	void SetCompareOptions(const CompareOptions & options);
	void SetAdditionalOptions(bool stopAfterFirstDiff);
	void SetAbortable(const IAbortable * piAbortable);

	int CompareFiles(DiffFileData* diffData);

private:
	std::unique_ptr<QuickCompareOptions> m_pOptions; /**< Compare options for diffutils. */
	IAbortable * m_piAbortable;
};

} // namespace CompareEngines
</file>

<file path="Winmerge-Src/Src/CompareEngines/CompareEngines.vcxitems">
<?xml version="1.0" encoding="utf-8"?>
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Label="Globals">
    <MSBuildAllProjects Condition="'$(MSBuildVersion)' == '' Or '$(MSBuildVersion)' &lt; '16.0'">$(MSBuildAllProjects);$(MSBuildThisFileFullPath)</MSBuildAllProjects>
    <HasSharedItems>true</HasSharedItems>
    <ItemsProjectGuid>{0f686afa-d587-43c0-bada-2beddc3fa758}</ItemsProjectGuid>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <ClCompile>
      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(MSBuildThisFileDirectory)</AdditionalIncludeDirectories>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ProjectCapability Include="SourceItemsFromImports" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="$(MSBuildThisFileDirectory)BinaryCompare.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)ByteComparator.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)ByteCompare.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)ImageCompare.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)TimeSizeCompare.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)Wrap_DiffUtils.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="$(MSBuildThisFileDirectory)BinaryCompare.cpp">
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)ByteComparator.cpp">
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)ByteCompare.cpp">
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)ImageCompare.cpp">
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)TimeSizeCompare.cpp">
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)Wrap_DiffUtils.cpp">
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
    </ClCompile>
  </ItemGroup>
</Project>
</file>

<file path="Winmerge-Src/Src/CompareEngines/CompareEngines.vcxitems.filters">
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Header Files">
      <UniqueIdentifier>{7f9981c6-13e4-4fef-8497-a98f859c5c06}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files">
      <UniqueIdentifier>{df4406af-26e4-46f4-9e0c-9e6a254753b9}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="$(MSBuildThisFileDirectory)ImageCompare.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="$(MSBuildThisFileDirectory)BinaryCompare.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="$(MSBuildThisFileDirectory)ByteComparator.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="$(MSBuildThisFileDirectory)ByteCompare.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="$(MSBuildThisFileDirectory)Wrap_DiffUtils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="$(MSBuildThisFileDirectory)TimeSizeCompare.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="$(MSBuildThisFileDirectory)ImageCompare.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)BinaryCompare.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)ByteComparator.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)ByteCompare.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)Wrap_DiffUtils.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)TimeSizeCompare.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
</file>

<file path="Winmerge-Src/Src/CompareEngines/ImageCompare.cpp">
/**
 * @file  ImageCompare.cpp
 *
 * @brief Implementation file for ImageCompare
 */

#include "pch.h"
#include "ImageCompare.h"
#include "DiffItem.h"
#include "PathContext.h"
#include "WinIMergeLib.h"
#include <windows.h>

namespace CompareEngines
{

ImageCompare::ImageCompare()
	: m_colorDistanceThreshold(0.0)
	, m_pImgMergeWindow(nullptr)
	, m_hModule(nullptr)
{
	m_hModule = LoadLibraryW(L"WinIMerge\\WinIMergeLib.dll");
	if (m_hModule == nullptr)
		return;
	IImgMergeWindow* (*pfnWinIMerge_CreateWindowless)() =
		(IImgMergeWindow * (*)())GetProcAddress(m_hModule, "WinIMerge_CreateWindowless");
	if (pfnWinIMerge_CreateWindowless == nullptr)
		return;
	m_pImgMergeWindow = pfnWinIMerge_CreateWindowless();
}

ImageCompare::~ImageCompare()
{
	if (m_pImgMergeWindow)
	{
		bool(*pfnWinIMerge_DestroyWindow)(IImgMergeWindow *) =
			(bool(*)(IImgMergeWindow *))GetProcAddress(m_hModule, "WinIMerge_DestroyWindow");
		if (pfnWinIMerge_DestroyWindow != nullptr)
			pfnWinIMerge_DestroyWindow(m_pImgMergeWindow);
	}
	if (m_hModule)
		FreeLibrary(m_hModule);
}

int ImageCompare::compare_files(const String& file1, const String& file2) const
{
	if (!m_pImgMergeWindow)
		return DIFFCODE::CMPERR;
	int code = DIFFCODE::CMPERR;
	m_pImgMergeWindow->SetColorDistanceThreshold(m_colorDistanceThreshold);
	if (m_pImgMergeWindow->OpenImages(file1.c_str(), file2.c_str()))
	{
		bool bImgDiff = false;
		if (m_pImgMergeWindow->GetPageCount(0) == m_pImgMergeWindow->GetPageCount(1))
		{
			for (int page = 0; page < m_pImgMergeWindow->GetPageCount(0); ++page)
			{
				m_pImgMergeWindow->SetCurrentPageAll(page);
				if (m_pImgMergeWindow->GetDiffCount() > 0)
					bImgDiff = true;
			}
		}
		else
		{
			bImgDiff = true;
		}
		code = bImgDiff ? DIFFCODE::DIFF : DIFFCODE::SAME;
		m_pImgMergeWindow->CloseImages();
	}
	return code;
}

/**
 * @brief Compare two specified files
 * @param [in] di Diffitem info.
 * @return DIFFCODE
 */
int ImageCompare::CompareFiles(const PathContext& files, const DIFFITEM &di) const
{
	switch (files.GetSize())
	{
	case 2:
		return (!di.diffcode.exists(0) || !di.diffcode.exists(1)) ?
			DIFFCODE::DIFF : compare_files(files[0], files[1]);
	case 3:
		unsigned code10 = (!di.diffcode.exists(1) || !di.diffcode.exists(0)) ?
			DIFFCODE::DIFF : compare_files(files[1], files[0]);
		unsigned code12 = (!di.diffcode.exists(1) || !di.diffcode.exists(2)) ?
			DIFFCODE::DIFF : compare_files(files[1], files[2]);
		unsigned code02 = DIFFCODE::SAME;
		if (code10 == DIFFCODE::SAME && code12 == DIFFCODE::SAME)
			return DIFFCODE::SAME;
		else if (code10 == DIFFCODE::SAME && code12 == DIFFCODE::DIFF)
			return DIFFCODE::DIFF | DIFFCODE::DIFF3RDONLY;
		else if (code10 == DIFFCODE::DIFF && code12 == DIFFCODE::SAME)
			return DIFFCODE::DIFF | DIFFCODE::DIFF1STONLY;
		else if (code10 == DIFFCODE::DIFF && code12 == DIFFCODE::DIFF)
		{
			code02 = (!di.diffcode.exists(0) || !di.diffcode.exists(2)) ?
				DIFFCODE::DIFF : compare_files(files[0], files[2]);
			if (code02 == DIFFCODE::SAME)
				return DIFFCODE::DIFF | DIFFCODE::DIFF2NDONLY;
		}
		if (code10 == DIFFCODE::CMPERR || code12 == DIFFCODE::CMPERR || code02 == DIFFCODE::CMPERR)
			return DIFFCODE::CMPERR;
		return DIFFCODE::DIFF;
	}
	return DIFFCODE::CMPERR;
}

} // namespace CompareEngines
</file>

<file path="Winmerge-Src/Src/CompareEngines/ImageCompare.h">
/**
 * @file  ImageCompare.h
 *
 * @brief Declaration file for ImageCompare compare engine.
 */
#pragma once

#include "UnicodeString.h"

class DIFFITEM;
class PathContext;
struct IImgMergeWindow;
struct HINSTANCE__;

namespace CompareEngines
{

/**
 * @brief A image compare class.
 * This compare method compares files by their image contents.
 */
class ImageCompare
{
public:
	ImageCompare();
	~ImageCompare();
	int CompareFiles(const PathContext& files, const DIFFITEM &di) const;

    double GetColorDistanceThreshold() const { return m_colorDistanceThreshold; }
    void SetColorDistanceThreshold(double colorDistanceThreshold) { m_colorDistanceThreshold = colorDistanceThreshold; };
private:
    int compare_files(const String& file1, const String& file2) const;
    mutable IImgMergeWindow *m_pImgMergeWindow;
    double m_colorDistanceThreshold;
    struct HINSTANCE__* m_hModule;
};

} // namespace CompareEngines
</file>

<file path="Winmerge-Src/Src/CompareEngines/TimeSizeCompare.cpp">
/**
 * @file  TimeSizeCompare.cpp
 *
 * @brief Implementation file for TimeSizeCompare
 */

#include "pch.h"
#include "TimeSizeCompare.h"
#include <Poco/Timestamp.h>
#include "DiffItem.h"
#include "DiffWrapper.h"

using Poco::Timestamp;

namespace CompareEngines
{

TimeSizeCompare::TimeSizeCompare()
		: m_ignoreSmallDiff(false)
{
}

TimeSizeCompare::~TimeSizeCompare() = default;

/**
 * @brief Set compare-type specific options.
 * @param [in] ignoreSmallDiff Ignore small time differences?
 */
void TimeSizeCompare::SetAdditionalOptions(bool ignoreSmallDiff)
{
	m_ignoreSmallDiff = ignoreSmallDiff;
}

/**
 * @brief Compare two specified files, byte-by-byte
 * @param [in] compMethod Compare method used.
 * @param [in] di Diffitem info.
 * @return DIFFCODE
 */
int TimeSizeCompare::CompareFiles(int compMethod, int nfiles, const DIFFITEM &di) const
{
	unsigned code = DIFFCODE::SAME;
	int64_t nTimeDiff = 0;
	int64_t nTimeDiff12 = 0;
	int64_t nTimeDiff02 = 0;
	if ((compMethod == CMP_DATE) || (compMethod == CMP_DATE_SIZE))
	{
		// Compare by modified date
		// Check that we have both filetimes
		nTimeDiff   = di.diffFileInfo[0].mtime - di.diffFileInfo[1].mtime;
		if (nTimeDiff   < 0) nTimeDiff   *= -1;
		nTimeDiff = nTimeDiff / Timestamp::resolution() * Timestamp::resolution();
		if (nfiles > 2)
		{
			nTimeDiff12 = di.diffFileInfo[1].mtime - di.diffFileInfo[2].mtime;
			nTimeDiff02 = di.diffFileInfo[0].mtime - di.diffFileInfo[2].mtime;
			if (nTimeDiff12 < 0) nTimeDiff12 *= -1;
			if (nTimeDiff02 < 0) nTimeDiff02 *= -1;
			nTimeDiff12 = nTimeDiff12 / Timestamp::resolution() * Timestamp::resolution();
			nTimeDiff02 = nTimeDiff02 / Timestamp::resolution() * Timestamp::resolution();
		}
		if (m_ignoreSmallDiff)
		{
			// If option to ignore small timediffs (couple of seconds)
			// is set, decrease absolute difference by allowed diff
			nTimeDiff   -= SmallTimeDiff * Timestamp::resolution();
			nTimeDiff12 -= SmallTimeDiff * Timestamp::resolution();
			nTimeDiff02 -= SmallTimeDiff * Timestamp::resolution();
		}
		if (nTimeDiff <= 0 && nTimeDiff12 <= 0)
			code = DIFFCODE::SAME;
		else
			code = DIFFCODE::DIFF;

		for (int i = 0; i < nfiles; ++i)
		{
			if (di.diffFileInfo[i].mtime == Poco::Timestamp::TIMEVAL_MIN && di.diffcode.exists(i))
				code = DIFFCODE::CMPERR;
		}
	}
	// This is actual CMP_SIZE method..
	// If file sizes differ mark them different
	if ((compMethod == CMP_DATE_SIZE) || (compMethod == CMP_SIZE))
	{
		if (di.diffFileInfo[0].size != di.diffFileInfo[1].size || 
		    (nfiles > 2 && di.diffFileInfo[1].size != di.diffFileInfo[2].size))
		{
			code = DIFFCODE::DIFF;
		}

		for (int i = 0; i < nfiles; ++i)
		{
			if (di.diffFileInfo[i].size == DirItem::FILE_SIZE_NONE && di.diffcode.exists(i))
				code = DIFFCODE::CMPERR;
		}
	}
	if (nfiles > 2 && (code & DIFFCODE::COMPAREFLAGS) == DIFFCODE::DIFF)
	{
		if (compMethod == CMP_DATE)
		{
			if (nTimeDiff12 <= 0)
				code |= DIFFCODE::DIFF1STONLY;
			else if (nTimeDiff02 <= 0)
				code |= DIFFCODE::DIFF2NDONLY;
			else if (nTimeDiff <= 0)
				code |= DIFFCODE::DIFF3RDONLY;
		}
		else if (compMethod == CMP_DATE_SIZE)
		{
			if (nTimeDiff12 <= 0 && di.diffFileInfo[1].size == di.diffFileInfo[2].size)
				code |= DIFFCODE::DIFF1STONLY;
			else if (nTimeDiff02 <= 0 && di.diffFileInfo[0].size == di.diffFileInfo[2].size)
				code |= DIFFCODE::DIFF2NDONLY;
			else if (nTimeDiff <= 0 && di.diffFileInfo[0].size == di.diffFileInfo[1].size)
				code |= DIFFCODE::DIFF3RDONLY;
		}
		else if (compMethod == CMP_SIZE)
		{
			if (di.diffFileInfo[1].size == di.diffFileInfo[2].size)
				code |= DIFFCODE::DIFF1STONLY;
			else if (di.diffFileInfo[0].size == di.diffFileInfo[2].size)
				code |= DIFFCODE::DIFF2NDONLY;
			else if (di.diffFileInfo[0].size == di.diffFileInfo[1].size)
				code |= DIFFCODE::DIFF3RDONLY;
		}
	}
	return code;
}

} // namespace CompareEngines
</file>

<file path="Winmerge-Src/Src/CompareEngines/TimeSizeCompare.h">
/**
 * @file  TimeSizeCompare.h
 *
 * @brief Declaration file for TimeSizeCompare compare engine.
 */
#pragma once

class DIFFITEM;

namespace CompareEngines
{

/**
 * @brief A time/size compare class.
 * This compare method compares files by their times and sizes.
 */
class TimeSizeCompare
{
public:
	/// Seconds ignored in filetime differences if option enabled
	enum {
		SmallTimeDiff = 2
	};

	TimeSizeCompare();
	~TimeSizeCompare();
	void SetAdditionalOptions(bool ignoreSmallDiff);
	int CompareFiles(int compMethod, int nfiles, const DIFFITEM &di) const;

private:
	bool m_ignoreSmallDiff;
};

} // namespace CompareEngines
</file>

<file path="Winmerge-Src/Src/CompareEngines/Wrap_DiffUtils.cpp">
/**
 * @file  Wrap_DiffUtils.cpp
 *
 * @brief Implementation file for Wrap_DiffUtils class.
 */

#include "pch.h"
#include "diff.h"
#include "Wrap_DiffUtils.h"
#include <map>
#include <algorithm>
#include <cassert>
#include <sstream>
#include <vector>
#include "DiffContext.h"
#include "Exceptions.h"
#include "FilterList.h"
#include "CompareOptions.h"
#include "coretools.h"
#include "DiffList.h"
#include "DiffWrapper.h"
#include "xdiff_gnudiff_compat.h"
#include "unicoder.h"
#include "DiffFileData.h"

namespace CompareEngines
{

/**
 * @brief Default constructor.
 */
DiffUtils::DiffUtils()
		:  m_pDiffWrapper(new ::CDiffWrapper)
		, m_ndiffs(0)
		, m_ntrivialdiffs(0)
{
}

/**
 * @brief Default destructor.
 */
DiffUtils::~DiffUtils()
{
}

/**
 * @brief Set compare options from general compare options.
 * @param [in ]options General compare options.
 */
void DiffUtils::SetCompareOptions(const CompareOptions& options)
{
	DIFFOPTIONS doptions;
	static_cast<const DiffutilsOptions&>(options).GetAsDiffOptions(doptions);
	m_pDiffWrapper->SetOptions(&doptions, true);
}

/**
 * @brief Clear current filters list.
 * Don't delete the list as it points to external list.
 */
void DiffUtils::ClearFilterList()
{
	m_pDiffWrapper->SetFilterList(static_cast<std::shared_ptr<FilterList>>(nullptr));
}

/**
 * @brief Set line filters list to use.
 * @param [in] list List of line filters.
 */
void DiffUtils::SetFilterList(std::shared_ptr<FilterList> list)
{
	m_pDiffWrapper->SetFilterList(list);
}

void DiffUtils::SetSubstitutionList(std::shared_ptr<SubstitutionList> list)
{
	m_pDiffWrapper->SetSubstitutionList(list);
}

void DiffUtils::ClearSubstitutionList()
{
	m_pDiffWrapper->SetSubstitutionList(nullptr);
}

void DiffUtils::SetCodepage(int codepage)
{
	m_pDiffWrapper->SetCodepage(codepage);
}

/**
 * @brief Compare two files (as earlier specified).
 * @return DIFFCODE as a result of compare.
 */
int DiffUtils::CompareFiles(DiffFileData* diffData)
{
	int bin_flag = 0;
	int bin_file = 0; // bitmap for binary files

	// Do the actual comparison (generating a change script)
	struct change *script = nullptr;
	bool success = m_pDiffWrapper->Diff2Files(&script, diffData, & bin_flag, & bin_file);
	if (!success)
	{
		return DIFFCODE::FILE | DIFFCODE::TEXT | DIFFCODE::CMPERR;
	}
	unsigned code = DIFFCODE::FILE | DIFFCODE::TEXT | DIFFCODE::SAME;

	// make sure to start counting diffs at 0
	// (usually it is -1 at this point, for unknown)
	m_ndiffs = 0;
	m_ntrivialdiffs = 0;

	if (script != nullptr)
	{
		const bool usefilters = m_pDiffWrapper->GetOptions().m_filterCommentsLines ||
			m_pDiffWrapper->GetOptions().m_bIgnoreMissingTrailingEol ||
			(m_pDiffWrapper->GetFilterList() && m_pDiffWrapper->GetFilterList()->HasRegExps()) ||
			(m_pDiffWrapper->GetSubstitutionList() && m_pDiffWrapper->GetSubstitutionList()->HasRegExps());
	
		PostFilterContext ctxt{};
		String Ext = ucr::toTString(diffData->m_inf[0].name);
		size_t PosOfDot = Ext.rfind('.');
		if (PosOfDot != String::npos)
			Ext.erase(0, PosOfDot + 1);

		m_pDiffWrapper->SetFilterCommentsSourceDef(Ext);

		struct change *next = script;

		while (next != nullptr)
		{
			/* Find a set of changes that belong together.  */
			struct change *thisob = next;
			struct change *end = find_change(next);

			/* Disconnect them from the rest of the changes,
			making them a hunk, and remember the rest for next iteration.  */
			next = end->link;
			end->link = nullptr;
#ifdef _DEBUG
			debug_script(thisob);
#endif

			{
				/* Determine range of line numbers involved in each file.  */
				int first0 = 0, last0 = 0, first1 = 0, last1 = 0, deletes = 0, inserts = 0;
				analyze_hunk (thisob, &first0, &last0, &first1, &last1, &deletes, &inserts, diffData->m_inf);

				/* Reconnect the script so it will all be freed properly.  */
				end->link = next;

				if (deletes!=0 || inserts!=0 || thisob->trivial!=0)
				{
					OP_TYPE op = (deletes == 0 && inserts == 0) ? OP_TRIVIAL : OP_DIFF;

					if (op != OP_TRIVIAL && usefilters)
					{
						m_pDiffWrapper->PostFilter(ctxt, thisob, diffData->m_inf);
					}
				}
			}
		}
	}


	// Free change script (which we don't want)
	if (script != nullptr)
	{
		struct change *p, *e;
		for (e = script; e; e = p)
		{
			if (!e->trivial)
				++m_ndiffs;
			else
				++m_ntrivialdiffs;
			p = e->link;
			free(e);
		}
		if (m_ndiffs > 0)
			code = code & ~DIFFCODE::SAME | DIFFCODE::DIFF;
	}

	// diff_2_files set bin_flag to -1 if different binary
	// diff_2_files set bin_flag to +1 if same binary

	if (bin_flag != 0)
	{
		// Clear text-flag, set binary flag
		// We don't know diff counts for binary files
		code = code & ~DIFFCODE::TEXT;
		switch (bin_file)
		{
		case BINFILE_SIDE1:
			code |= DIFFCODE::BIN | DIFFCODE::BINSIDE1;
			break;
		case BINFILE_SIDE2:
			code |= DIFFCODE::BIN | DIFFCODE::BINSIDE2;
			break;
		case BINFILE_SIDE1 | BINFILE_SIDE2:
			code |= DIFFCODE::BIN | DIFFCODE::BINSIDE1 | DIFFCODE::BINSIDE2;
			break;
		default:
			std::ostringstream ss;
			ss << "Invalid bin_file value: " << bin_file;
			throw ss.str();
			break;
		}
		m_ndiffs = CDiffContext::DIFFS_UNKNOWN;
	}

	if (bin_flag < 0)
	{
		// Clear same-flag, set diff-flag
		code = code & ~DIFFCODE::SAME | DIFFCODE::DIFF;
	}

	return code;
}

/**
 * @brief Compare two files using diffutils.
 *
 * Compare two files (in DiffFileData param) using diffutils. Run diffutils
 * inside SEH so we can trap possible error and exceptions. If error or
 * execption is trapped, return compare failure.
 * @param [out] diffs Pointer to list of change structs where diffdata is stored.
 * @param [in] depth Depth in folder compare (we use 0).
 * @param [out] bin_status used to return binary status from compare.
 * @param [in] bMovedBlocks If `true` moved blocks are analyzed.
 * @param [out] bin_file Returns which file was binary file as bitmap.
    So if first file is binary, first bit is set etc. Can be `nullptr` if binary file
    info is not needed (faster compare since diffutils don't bother checking
    second file if first is binary).
 * @return `true` when compare succeeds, `false` if error happened during compare.
 */
bool DiffUtils::Diff2Files(struct change ** diffs, DiffFileData *diffData,
		int * bin_status, int * bin_file) const
{
	return m_pDiffWrapper->Diff2Files(diffs, diffData, bin_status, bin_file);
}

/**
 * @brief Return diff counts for last compare.
 * @param [out] diffs Count of real differences.
 * @param [out] trivialDiffs Count of ignored differences.
 */
void DiffUtils::GetDiffCounts(int & diffs, int & trivialDiffs) const
{
	diffs = m_ndiffs;
	trivialDiffs = m_ntrivialdiffs;
}


} // namespace CompareEngines
</file>

<file path="Winmerge-Src/Src/CompareEngines/Wrap_DiffUtils.h">
/**
 * @file  Wrap_DiffUtils.h
 *
 * @brief Declaration of Wrap_DiffUtils class.
 */
#pragma once

#include <memory>

class FilterList;
class SubstitutionList;
class CompareOptions;
struct FileTextStats;
class CDiffWrapper;
struct DiffFileData;

namespace CompareEngines
{

/**
 * @brief A class wrapping GNU diffutils as compare engine.
 *
 * This class needs to have all its data as local copies, not as pointers
 * outside. Lifetime can vary certainly be different from unrelated classes.
 * Filters list being an exception - pcre structs are too complex to easily
 * copy so we'll only keep a pointer to external list.
 */
class DiffUtils
{
public:
	DiffUtils();
	~DiffUtils();

	void SetCodepage(int codepage);
	void SetCompareOptions(const CompareOptions& options);
	void SetFilterList(std::shared_ptr<FilterList> plist);
	void ClearFilterList();
	void SetSubstitutionList(std::shared_ptr<SubstitutionList> plist);
	void ClearSubstitutionList();

	int CompareFiles(DiffFileData* diffData);
	bool Diff2Files(struct change ** diffs, DiffFileData *diffData,
			int * bin_status, int * bin_file) const;

	void GetDiffCounts(int & diffs, int & trivialDiffs) const;

private:
	int m_ndiffs; /**< Real diffs found. */
	int m_ntrivialdiffs; /**< Ignored diffs found. */
	std::unique_ptr<CDiffWrapper> m_pDiffWrapper;
};


} // namespace CompareEngines
</file>

<file path="Winmerge-Src/Src/diffutils/config.h">
/*
 *	config.h - pre-built version for MSDOS and NT.
 */
#pragma once
 
#define HAVE_VPRINTF 1
#define RETSIGTYPE void
#define STDC_HEADERS 1
#define HAVE_DUP2 1
#define HAVE_MEMCHR 1
#define HAVE_SIGACTION 1
#define HAVE_STRERROR 1
#define HAVE_WAITPID 1
#define HAVE_FCNTL_H 1
#define HAVE_LIMITS_H 1
#define HAVE_STDLIB_H 1
#define HAVE_STRING_H 1
#define HAVE_TIME_H 1
</file>

<file path="Winmerge-Src/Src/diffutils/diffutils.vcxitems">
<?xml version="1.0" encoding="utf-8"?>
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Label="Globals">
    <MSBuildAllProjects Condition="'$(MSBuildVersion)' == '' Or '$(MSBuildVersion)' &lt; '16.0'">$(MSBuildAllProjects);$(MSBuildThisFileFullPath)</MSBuildAllProjects>
    <HasSharedItems>true</HasSharedItems>
    <ItemsProjectGuid>{fc3b9df3-2854-4264-ab4b-ee8c43982513}</ItemsProjectGuid>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <ClCompile>
      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(MSBuildThisFileDirectory)</AdditionalIncludeDirectories>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ProjectCapability Include="SourceItemsFromImports" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="$(MSBuildThisFileDirectory)GnuVersion.c">
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)lib\cmpbuf.c">
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)src\analyze.c">
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)src\context.c">
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)src\Diff.cpp">
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)src\ed.c">
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)src\ifdef.c">
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)src\io.c">
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)src\mystat.cpp">
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)src\normal.c">
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)src\side.c">
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)src\util.c">
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="$(MSBuildThisFileDirectory)config.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)lib\cmpbuf.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)src\diff.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)src\system.h" />
  </ItemGroup>
</Project>
</file>

<file path="Winmerge-Src/Src/diffutils/diffutils.vcxitems.filters">
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="$(MSBuildThisFileDirectory)src\analyze.c">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)lib\cmpbuf.c">
      <Filter>lib</Filter>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)src\context.c">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)src\Diff.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)src\ed.c">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)src\ifdef.c">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)src\io.c">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)src\mystat.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)src\normal.c">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)src\side.c">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)src\util.c">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)GnuVersion.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="$(MSBuildThisFileDirectory)lib\cmpbuf.h">
      <Filter>lib</Filter>
    </ClInclude>
    <ClInclude Include="$(MSBuildThisFileDirectory)src\diff.h">
      <Filter>src</Filter>
    </ClInclude>
    <ClInclude Include="$(MSBuildThisFileDirectory)src\system.h">
      <Filter>src</Filter>
    </ClInclude>
    <ClInclude Include="$(MSBuildThisFileDirectory)config.h" />
  </ItemGroup>
  <ItemGroup>
    <Filter Include="src">
      <UniqueIdentifier>{3883a169-0d29-4a08-acc5-e8c424c6263d}</UniqueIdentifier>
    </Filter>
    <Filter Include="lib">
      <UniqueIdentifier>{fd3263c0-0d17-415c-a1b2-3ccf43386a9a}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
</Project>
</file>

<file path="Winmerge-Src/Src/diffutils/GnuVersion.c">
/* Version number of GNU diff.  */

#include "config.h"

char const version_string[] = "2.5";
</file>

<file path="Winmerge-Src/Src/diffutils/lib/cmpbuf.c">
/* Buffer primitives for comparison operations.
   Copyright (C) 1993 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

#include "system.h"
#include "cmpbuf.h"

/* Least common multiple of two buffer sizes A and B.  */

size_t
buffer_lcm (size_t a, size_t b)
{
  size_t m, n, r;

  /* Yield reasonable values if buffer sizes are zero.  */
  if (!a)
    return b ? b : 8 * 1024;
  if (!b)
    return a;

  /* n = gcd (a, b) */
  for (m = a, n = b;  (r = m % n) != 0;  m = n, n = r)
    continue;

  return a/n * b;
}
</file>

<file path="Winmerge-Src/Src/diffutils/lib/cmpbuf.h">
/* Buffer primitives for comparison operations.
   Copyright (C) 1993 Free Software Foundation, Inc.

This file is part of GNU DIFF.

GNU DIFF is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GNU DIFF is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU DIFF; see the file COPYING.  If not, write to
the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

size_t buffer_lcm (size_t, size_t);

#ifdef __cplusplus
}
#endif
</file>

<file path="Winmerge-Src/Src/diffutils/src/analyze.c">
/* Analyze file differences for GNU DIFF.
   Copyright (C) 1988, 1989, 1992, 1993 Free Software Foundation, Inc.

This file is part of GNU DIFF.

GNU DIFF is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GNU DIFF is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU DIFF; see the file COPYING.  If not, write to
the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* The basic algorithm is described in:
   "An O(ND) Difference Algorithm and its Variations", Eugene Myers,
   Algorithmica Vol. 1 No. 2, 1986, pp. 251-266;
   see especially section 4.2, which describes the variation used below.

   Unless the --minimal option is specified, this code uses the TOO_EXPENSIVE
   heuristic, by Paul Eggert, to limit the cost to O(N**1.5 log N)
   at the price of producing suboptimal output for large inputs with
   many differences.  Related algorithms are surveyed by Alfred V. Aho in
   section 6.3 of 'Algorithms for Finding Patterns in Strings',
   Handbook of Theoretical Computer Science (Jan Van Leeuwen,
   ed.), Vol. A, Algorithms and Complexity, Elsevier/MIT Press,
   1990, pp. 255--300.

   The basic algorithm was independently discovered as described in:
   "Algorithms for Approximate String Matching", Esko Ukkonen,
   Information and Control Vol. 64, 1985, pp. 100-118.  
*/

#include "diff.h"
#include "cmpbuf.h"
#include <assert.h>
#ifdef _WIN32
#  include <io.h>
#endif

DECL_TLS int no_discards;
DECL_TLS int need_free_buffers=0;

static DECL_TLS int *xvec, *yvec;	/* Vectors being compared. */
static DECL_TLS int *fdiag;		/* Vector, indexed by diagonal, containing
				   1 + the X coordinate of the point furthest
				   along the given diagonal in the forward
				   search of the edit matrix. */
static DECL_TLS int *bdiag;		/* Vector, indexed by diagonal, containing
				   the X coordinate of the point furthest
				   along the given diagonal in the backward
				   search of the edit matrix. */
static DECL_TLS int too_expensive;	/* Edit scripts longer than this are too
				   expensive to compute.  */

#define SNAKE_LIMIT 20	/* Snakes bigger than this are considered `big'.  */

struct partition
{
  int xmid, ymid;	/* Midpoints of this partition.  */
  int lo_minimal;	/* Nonzero if low half will be analyzed minimally.  */
  int hi_minimal;	/* Likewise for high half.  */
};

static int diag (int, int, int, int, int, struct partition *);
static struct change *add_change (int, int, int, int, struct change *);
static struct change *build_reverse_script (struct file_data const[]);
static struct change *build_script (struct file_data const[]);
static void briefly_report (int, struct file_data const[]);
static void compareseq (int, int, int, int, int);
static void discard_confusing_lines (struct file_data[]);
static void shift_boundaries (struct file_data[]);

/* Find the midpoint of the shortest edit script for a specified
   portion of the two files.

   Scan from the beginnings of the files, and simultaneously from the ends,
   doing a breadth-first search through the space of edit-sequence.
   When the two searches meet, we have found the midpoint of the shortest
   edit sequence.

   If MINIMAL is nonzero, find the minimal edit script regardless
   of expense.  Otherwise, if the search is too expensive, use
   heuristics to stop the search and report a suboptimal answer.

   Set PART->(XMID,YMID) to the midpoint (XMID,YMID).  The diagonal number
   XMID - YMID equals the number of inserted lines minus the number
   of deleted lines (counting only lines before the midpoint).
   Return the approximate edit cost; this is the total number of
   lines inserted or deleted (counting only lines before the midpoint),
   unless a heuristic is used to terminate the search prematurely.

   Set PART->LEFT_MINIMAL to nonzero iff the minimal edit script for the
   left half of the partition is known; similarly for PART->RIGHT_MINIMAL.

   This function assumes that the first lines of the specified portions
   of the two files do not match, and likewise that the last lines do not
   match.  The caller must trim matching lines from the beginning and end
   of the portions it is going to specify.

   If we return the "wrong" partitions,
   the worst this can do is cause suboptimal diff output.
   It cannot cause incorrect diff output.  */

static int
diag (int xoff, int xlim, int yoff, int ylim, int minimal, struct partition *part)
{
  int *const fd = fdiag;	/* Give the compiler a chance. */
  int *const bd = bdiag;	/* Additional help for the compiler. */
  int const *const xv = xvec;	/* Still more help for the compiler. */
  int const *const yv = yvec;	/* And more and more . . . */
  int const dmin = xoff - ylim;	/* Minimum valid diagonal. */
  int const dmax = xlim - yoff;	/* Maximum valid diagonal. */
  int const fmid = xoff - yoff;	/* Center diagonal of top-down search. */
  int const bmid = xlim - ylim;	/* Center diagonal of bottom-up search. */
  int fmin = fmid, fmax = fmid;	/* Limits of top-down search. */
  int bmin = bmid, bmax = bmid;	/* Limits of bottom-up search. */
  int c;			/* Cost. */
  int odd = (fmid - bmid) & 1;	/* True if southeast corner is on an odd
				   diagonal with respect to the northwest. */

  fd[fmid] = xoff;
  bd[bmid] = xlim;

  for (c = 1;; ++c)
    {
      int d;			/* Active diagonal. */
      int big_snake = 0;

      /* Extend the top-down search by an edit step in each diagonal. */
      fmin > dmin ? fd[--fmin - 1] = -1 : ++fmin;
      fmax < dmax ? fd[++fmax + 1] = -1 : --fmax;
      for (d = fmax; d >= fmin; d -= 2)
	{
	  int x, y, oldx, tlo = fd[d - 1], thi = fd[d + 1];

	  if (tlo >= thi)
	    x = tlo + 1;
	  else
	    x = thi;
	  oldx = x;
	  y = x - d;
	  while (x < xlim && y < ylim && xv[x] == yv[y])
	    ++x, ++y;
	  if (x - oldx > SNAKE_LIMIT)
	    big_snake = 1;
	  fd[d] = x;
	  if (odd && bmin <= d && d <= bmax && bd[d] <= x)
	    {
	      part->xmid = x;
	      part->ymid = y;
	      part->lo_minimal = part->hi_minimal = 1;
	      return 2 * c - 1;
	    }
	}

      /* Similarly extend the bottom-up search.  */
      bmin > dmin ? bd[--bmin - 1] = INT_MAX : ++bmin;
      bmax < dmax ? bd[++bmax + 1] = INT_MAX : --bmax;
      for (d = bmax; d >= bmin; d -= 2)
	{
	  int x, y, oldx, tlo = bd[d - 1], thi = bd[d + 1];

	  if (tlo < thi)
	    x = tlo;
	  else
	    x = thi - 1;
	  oldx = x;
	  y = x - d;
	  while (x > xoff && y > yoff && xv[x - 1] == yv[y - 1])
	    --x, --y;
	  if (oldx - x > SNAKE_LIMIT)
	    big_snake = 1;
	  bd[d] = x;
	  if (!odd && fmin <= d && d <= fmax && x <= fd[d])
	    {
	      part->xmid = x;
	      part->ymid = y;
	      part->lo_minimal = part->hi_minimal = 1;
	      return 2 * c;
	    }
	}

      if (minimal)
	continue;

      /* Heuristic: check occasionally for a diagonal that has made
	 lots of progress compared with the edit distance.
	 If we have any such, find the one that has made the most
	 progress and return it as if it had succeeded.

	 With this heuristic, for files with a constant small density
	 of changes, the algorithm is linear in the file size.  */

      if (c > 200 && big_snake && heuristic)
	{
	  int best;

	  best = 0;
	  for (d = fmax; d >= fmin; d -= 2)
	    {
	      int dd = d - fmid;
	      int x = fd[d];
	      int y = x - d;
	      int v = (x - xoff) * 2 - dd;
	      if (v > 12 * (c + (dd < 0 ? -dd : dd)))
		{
		  if (v > best
		      && xoff + SNAKE_LIMIT <= x && x < xlim
		      && yoff + SNAKE_LIMIT <= y && y < ylim)
		{
		      /* We have a good enough best diagonal;
			 now insist that it end with a significant snake.  */
		      int k;

		      for (k = 1; xv[x - k] == yv[y - k]; k++)
			if (k == SNAKE_LIMIT)
			{
			    best = v;
			    part->xmid = x;
			    part->ymid = y;
			    break;
			}
		    }
		}
	    }
	  if (best > 0)
	    {
	      part->lo_minimal = 1;
	      part->hi_minimal = 0;
	      return 2 * c - 1;
	    }

	  best = 0;
	  for (d = bmax; d >= bmin; d -= 2)
	    {
	      int dd = d - bmid;
	      int x = bd[d];
	      int y = x - d;
	      int v = (xlim - x) * 2 + dd;
	      if (v > 12 * (c + (dd < 0 ? -dd : dd)))
		{
		  if (v > best
		      && xoff < x && x <= xlim - SNAKE_LIMIT
		      && yoff < y && y <= ylim - SNAKE_LIMIT)
		{
		      /* We have a good enough best diagonal;
			 now insist that it end with a significant snake.  */
		      int k;

		      for (k = 0; xv[x + k] == yv[y + k]; k++)
			if (k == SNAKE_LIMIT - 1)
			  {
			    best = v;
			    part->xmid = x;
			    part->ymid = y;
			  break;
			  }
		    }
		}
	    }
	  if (best > 0)
	    {
	      part->lo_minimal = 0;
	      part->hi_minimal = 1;
	      return 2 * c - 1;
	    }
	}

      /* Heuristic: if we've gone well beyond the call of duty,
	 give up and report halfway between our best results so far.  */
      if (c >= too_expensive)
	{
	  int fxybest, fxbest;
	  int bxybest, bxbest;

	  fxbest = bxbest = 0;  /* Pacify `gcc -Wall'.  */

	  /* Find forward diagonal that maximizes X + Y.  */
	  fxybest = -1;
	  for (d = fmax; d >= fmin; d -= 2)
	    {
	      int x = min (fd[d], xlim);
	      int y = x - d;
	      if (ylim < y)
		x = ylim + d, y = ylim;
	      if (fxybest < x + y)
			{
		  fxybest = x + y;
		  fxbest = x;
			}
		    }

	  /* Find backward diagonal that minimizes X + Y.  */
	  bxybest = INT_MAX;
	  for (d = bmax; d >= bmin; d -= 2)
	    {
	      int x = max (xoff, bd[d]);
	      int y = x - d;
	      if (y < yoff)
		x = yoff + d, y = yoff;
	      if (x + y < bxybest)
		{
		  bxybest = x + y;
		  bxbest = x;
		}
		}

	  /* Use the better of the two diagonals.  */
	  if ((xlim + ylim) - bxybest < fxybest - (xoff + yoff))
	    {
	      part->xmid = fxbest;
	      part->ymid = fxybest - fxbest;
	      part->lo_minimal = 1;
	      part->hi_minimal = 0;
	    }
	  else
	    {
	      part->xmid = bxbest;
	      part->ymid = bxybest - bxbest;
	      part->lo_minimal = 0;
	      part->hi_minimal = 1;
	    }
	  return 2 * c - 1;
	}
    }
}

/* Compare in detail contiguous subsequences of the two files
   which are known, as a whole, to match each other.

   The results are recorded in the vectors files[N].changed_flag, by
   storing a 1 in the element for each line that is an insertion or deletion.

   The subsequence of file 0 is [XOFF, XLIM) and likewise for file 1.

   Note that XLIM, YLIM are exclusive bounds.
   All line numbers are origin-0 and discarded lines are not counted.

   If MINIMAL is nonzero, find a minimal difference no matter how
   expensive it is.  */

static void
compareseq (int xoff, int xlim, int yoff, int ylim, int minimal)
{
  int * const xv = xvec; /* Help the compiler.  */
  int * const yv = yvec;

  /* Slide down the bottom initial diagonal. */
  while (xoff < xlim && yoff < ylim && xv[xoff] == yv[yoff])
    ++xoff, ++yoff;
  /* Slide up the top initial diagonal. */
  while (xlim > xoff && ylim > yoff && xv[xlim - 1] == yv[ylim - 1])
    --xlim, --ylim;

  /* Handle simple cases. */
  if (xoff == xlim)
    while (yoff < ylim)
      files[1].changed_flag[files[1].realindexes[yoff++]] = 1;
  else if (yoff == ylim)
    while (xoff < xlim)
      files[0].changed_flag[files[0].realindexes[xoff++]] = 1;
  else
    {
      int c;
      struct partition part;

      /* Find a point of correspondence in the middle of the files.  */

      c = diag (xoff, xlim, yoff, ylim, minimal, &part);

      if (c == 1)
	{
	  /* This should be impossible, because it implies that
	     one of the two subsequences is empty,
	     and that case was handled above without calling `diag'.
	     Let's verify that this is true.  */
	  abort ();
#if 0
	  /* The two subsequences differ by a single insert or delete;
	     record it and we are done.  */
	  if (part.xmid - part.ymid < xoff - yoff)
	    files[1].changed_flag[files[1].realindexes[part.ymid - 1]] = 1;
	  else
	    files[0].changed_flag[files[0].realindexes[part.xmid]] = 1;
#endif
	}
      else
	{
	  /* Use the partitions to split this problem into subproblems.  */
	  compareseq (xoff, part.xmid, yoff, part.ymid, part.lo_minimal);
	  compareseq (part.xmid, xlim, part.ymid, ylim, part.hi_minimal);
	}
    }
}

/* Discard lines from one file that have no matches in the other file.

   A line which is discarded will not be considered by the actual
   comparison algorithm; it will be as if that line were not in the file.
   The file's `realindexes' table maps virtual line numbers
   (which don't count the discarded lines) into real line numbers;
   this is how the actual comparison algorithm produces results
   that are comprehensible when the discarded lines are counted.

   When we discard a line, we also mark it as a deletion or insertion
   so that it will be printed in the output.  */

static void
discard_confusing_lines (struct file_data filevec[])
{
  unsigned int f, i;
  char *discarded[2];
  int *equiv_count[2];
  int *p;

  /* Allocate our results.  */
  p = (int *) xmalloc ((filevec[0].buffered_lines + filevec[1].buffered_lines)
		       * (2 * sizeof (int)));
  for (f = 0; f < 2; f++)
    {
      filevec[f].undiscarded = p;  p += filevec[f].buffered_lines;
      filevec[f].realindexes = p;  p += filevec[f].buffered_lines;
    }

  /* Set up equiv_count[F][I] as the number of lines in file F
     that fall in equivalence class I.  */

  p = (int *) xmalloc (filevec[0].equiv_max * (2 * sizeof (int)));
  equiv_count[0] = p;
  equiv_count[1] = p + filevec[0].equiv_max;
  bzero (p, filevec[0].equiv_max * (2 * sizeof (int)));

  for (i = 0; i < (unsigned int)filevec[0].buffered_lines; ++i)
    ++equiv_count[0][filevec[0].equivs[i]];
  for (i = 0; i < (unsigned int)filevec[1].buffered_lines; ++i)
    ++equiv_count[1][filevec[1].equivs[i]];

  /* Set up tables of which lines are going to be discarded.  */

  discarded[0] = xmalloc (sizeof (char)
			  * (filevec[0].buffered_lines
			     + filevec[1].buffered_lines));
  discarded[1] = discarded[0] + filevec[0].buffered_lines;
  bzero (discarded[0], sizeof (char) * (filevec[0].buffered_lines
					+ filevec[1].buffered_lines));

  /* Mark to be discarded each line that matches no line of the other file.
     If a line matches many lines, mark it as provisionally discardable.  */

  for (f = 0; f < 2; f++)
    {
      unsigned int end = filevec[f].buffered_lines;
      char *discards = discarded[f];
      int *counts = equiv_count[1 - f];
      int *equivs = filevec[f].equivs;
      unsigned int many = 5;
      unsigned int tem = end / 64;

      /* Multiply MANY by approximate square root of number of lines.
	 That is the threshold for provisionally discardable lines.  */
      while ((tem = tem >> 2) > 0)
	many *= 2;

      for (i = 0; i < end; i++)
	{
	  int nmatch;
	  if (equivs[i] == 0)
	    continue;
	  nmatch = counts[equivs[i]];
	  if (nmatch == 0)
	    discards[i] = 1;
	  else if (nmatch > (int)many)
	    discards[i] = 2;
	}
    }

  /* Don't really discard the provisional lines except when they occur
     in a run of discardables, with nonprovisionals at the beginning
     and end.  */

  for (f = 0; f < 2; f++)
    {
      unsigned int end = filevec[f].buffered_lines;
      register char *discards = discarded[f];

      for (i = 0; i < end; i++)
	{
	  /* Cancel provisional discards not in middle of run of discards.  */
	  if (discards[i] == 2)
	    discards[i] = 0;
	  else if (discards[i] != 0)
	    {
	      /* We have found a nonprovisional discard.  */
	      register int j;
	      unsigned int length;
	      unsigned int provisional = 0;

	      /* Find end of this run of discardable lines.
		 Count how many are provisionally discardable.  */
	      for (j = (int)i; (unsigned int)j < end; j++)
		{
		  if (discards[j] == 0)
		    break;
		  if (discards[j] == 2)
		    ++provisional;
		}

	      /* Cancel provisional discards at end, and shrink the run.  */
	      while (j > (int)i && discards[j - 1] == 2)
		discards[--j] = 0, --provisional;

	      /* Now we have the length of a run of discardable lines
		 whose first and last are not provisional.  */
	      length = j - i;

	      /* If 1/4 of the lines in the run are provisional,
		 cancel discarding of all provisional lines in the run.  */
	      if (provisional * 4 > length)
		{
		  while (j > (int)i)
		    if (discards[--j] == 2)
		      discards[j] = 0;
		}
	      else
		{
		  register unsigned int consec;
		  unsigned int minimum = 1;
		  unsigned int tem = length / 4;

		  /* MINIMUM is approximate square root of LENGTH/4.
		     A subrun of two or more provisionals can stand
		     when LENGTH is at least 16.
		     A subrun of 4 or more can stand when LENGTH >= 64.  */
		  while ((tem = tem >> 2) > 0)
		    minimum *= 2;
		  minimum++;

		  /* Cancel any subrun of MINIMUM or more provisionals
		     within the larger run.  */
		  for (j = 0, consec = 0; (unsigned int)j < length; j++)
		    if (discards[i + j] != 2)
		      consec = 0;
		    else if (minimum == ++consec)
		      /* Back up to start of subrun, to cancel it all.  */
		      j -= consec;
		    else if (minimum < consec)
		      discards[i + j] = 0;

		  /* Scan from beginning of run
		     until we find 3 or more nonprovisionals in a row
		     or until the first nonprovisional at least 8 lines in.
		     Until that point, cancel any provisionals.  */
		  for (j = 0, consec = 0; (unsigned int)j < length; j++)
		    {
		      if (j >= 8 && discards[i + j] == 1)
			break;
		      if (discards[i + j] == 2)
			consec = 0, discards[i + j] = 0;
		      else if (discards[i + j] == 0)
			consec = 0;
		      else
			consec++;
		      if (consec == 3)
			break;
		    }

		  /* I advances to the last line of the run.  */
		  i += length - 1;

		  /* Same thing, from end.  */
		  for (j = 0, consec = 0; (unsigned int)j < length; j++)
		    {
		      if (j >= 8 && discards[i - j] == 1)
			break;
		      if (discards[i - j] == 2)
			consec = 0, discards[i - j] = 0;
		      else if (discards[i - j] == 0)
			consec = 0;
		      else
			consec++;
		      if (consec == 3)
			break;
		    }
		}
	    }
	}
    }

  /* Actually discard the lines. */
  for (f = 0; f < 2; f++)
    {
      char *discards = discarded[f];
      unsigned int end = filevec[f].buffered_lines;
      unsigned int j = 0;
      for (i = 0; i < end; ++i)
	if (no_discards || discards[i] == 0)
	  {
	    filevec[f].undiscarded[j] = filevec[f].equivs[i];
	    filevec[f].realindexes[j++] = i;
	  }
	else
	  filevec[f].changed_flag[i] = 1;
      filevec[f].nondiscarded_lines = j;
    }

  free (discarded[0]);
  free (equiv_count[0]);
}

/* Adjust inserts/deletes of identical lines to join changes
   as much as possible.

   We do something when a run of changed lines include a
   line at one end and have an excluded, identical line at the other.
   We are free to choose which identical line is included.
   `compareseq' usually chooses the one at the beginning,
   but usually it is cleaner to consider the following identical line
   to be the "change".  */

DECL_TLS int inhibit;

static void
shift_boundaries (struct file_data filevec[])
{
  int f;

  if (inhibit)
    return;

  for (f = 0; f < 2; f++)
    {
      char *changed = filevec[f].changed_flag;
      char const *other_changed = filevec[1-f].changed_flag;
      int const *equivs = filevec[f].equivs;
      int i = 0;
      int j = 0;
      int i_end = filevec[f].buffered_lines;

      while (1)
	{
	  int runlength, start, corresponding;

	  /* Scan forwards to find beginning of another run of changes.
	     Also keep track of the corresponding point in the other file.  */

	  while (i < i_end && changed[i] == 0)
	    {
	      while (other_changed[j++])
		continue;
	      i++;
	    }

	  if (i == i_end)
	    break;

	  start = i;

	  /* Find the end of this run of changes.  */

	  while (changed[++i])
	    continue;
	  while (other_changed[j])
	    j++;

	  do
	    {
	      /* Record the length of this run of changes, so that
		 we can later determine whether the run has grown.  */
	      runlength = i - start;

	      /* Move the changed region back, so long as the
		 previous unchanged line matches the last changed one.
		 This merges with previous changed regions.  */

	      while (start && equivs[start - 1] == equivs[i - 1])
		{
		  changed[--start] = 1;
		  changed[--i] = 0;
		  while (changed[start - 1])
		    start--;
		  while (other_changed[--j])
		    continue;
		}

	      /* Set CORRESPONDING to the end of the changed run, at the last
		 point where it corresponds to a changed run in the other file.
		 CORRESPONDING == I_END means no such point has been found.  */
	      corresponding = other_changed[j - 1] ? i : i_end;

	      /* Move the changed region forward, so long as the
		 first changed line matches the following unchanged one.
		 This merges with following changed regions.
		 Do this second, so that if there are no merges,
		 the changed region is moved forward as far as possible.  */

	      while (i != i_end && equivs[start] == equivs[i])
		{
		  changed[start++] = 0;
		  changed[i++] = 1;
		  while (changed[i])
		    i++;
		  while (other_changed[++j])
		    corresponding = i;
		}
	    }
	  while (runlength != i - start);

	  /* If possible, move the fully-merged run of changes
	     back to a corresponding run in the other file.  */

	  while (corresponding < i)
	    {
	      changed[--start] = 1;
	      changed[--i] = 0;
	      while (other_changed[--j])
		continue;
	}
    }
}
}

/* Cons an additional entry onto the front of an edit script OLD.
   LINE0 and LINE1 are the first affected lines in the two files (origin 0).
   DELETED is the number of lines deleted here from file 0.
   INSERTED is the number of lines inserted here in file 1.

   If DELETED is 0 then LINE0 is the number of the line before
   which the insertion was done; vice versa for INSERTED and LINE1.  */

static struct change *
add_change (int line0, int line1, int deleted, int inserted, struct change *old)
{
  struct change *newob = (struct change *) xmalloc (sizeof (struct change));
  memset(newob, 0, sizeof(*newob));

  newob->line0 = line0;
  newob->line1 = line1;
  newob->inserted = inserted;
  newob->deleted = deleted;
  newob->link = old;
  newob->match0 = -1; /* WinMerge moved block code */
  newob->match1 = -1; /* WinMerge moved block code */
  return newob;
}

/* Scan the tables of which lines are inserted and deleted,
   producing an edit script in reverse order.  */

static struct change *
build_reverse_script (struct file_data const filevec[])
{
  struct change *script = NULL;
  char *changed0 = filevec[0].changed_flag;
  char *changed1 = filevec[1].changed_flag;
  int len0 = filevec[0].buffered_lines;
  int len1 = filevec[1].buffered_lines;

  /* Note that changedN[len0] does exist, and contains 0.  */

  int i0 = 0, i1 = 0;

  while (i0 < len0 || i1 < len1)
    {
      if (changed0[i0] || changed1[i1])
	{
	  int line0 = i0, line1 = i1;

	  /* Find # lines changed here in each file.  */
	  while (changed0[i0]) ++i0;
	  while (changed1[i1]) ++i1;

	  /* Record this change.  */
	  script = add_change (line0, line1, i0 - line0, i1 - line1, script);
	}

      /* We have reached lines in the two files that match each other.  */
      i0++, i1++;
    }

  return script;
}

/* Scan the tables of which lines are inserted and deleted,
   producing an edit script in forward order.  */

static struct change *
build_script (struct file_data const filevec[])
{
  struct change *script = NULL;
  char *changed0 = filevec[0].changed_flag;
  char *changed1 = filevec[1].changed_flag;
  int i0 = filevec[0].buffered_lines, i1 = filevec[1].buffered_lines;

  /* Note that changedN[-1] does exist, and contains 0.  */

  while (i0 >= 0 || i1 >= 0)
    {
      if (changed0[i0 - 1] || changed1[i1 - 1])
	{
	  int line0 = i0, line1 = i1;

	  /* Find # lines changed here in each file.  */
	  while (changed0[i0 - 1]) --i0;
	  while (changed1[i1 - 1]) --i1;

	  /* Record this change.  */
	  script = add_change (i0, i1, line0 - i0, line1 - i1, script);
	}

      /* We have reached lines in the two files that match each other.  */
      i0--, i1--;
    }

  return script;
}

/* If CHANGES, briefly report that two files differed.  */
static void
briefly_report (int changes, struct file_data const filevec[])
{
  if (changes)
    message (no_details_flag ? "Files %s and %s differ\n"
	     : "Binary files %s and %s differ\n",
	     filevec[0].name, filevec[1].name);
}

//  Report the differences of two files.  DEPTH is the current directory
// depth. 
// WinMerge: add bMoved_blocks_flag for detecting moved blocks and
// bin_file for getting info which file is binary file (can be NULL)
// Winmerge: assume S_ISREG() files, not pipes, directories or devices
struct change * diff_2_files (struct file_data filevec[], int depth, int * bin_status,
	int bMoved_blocks_flag, int * bin_file)
{
	int diags;
	int i;
	struct change *script=NULL;
	int changes;
	
	
	//  If we have detected that either file is binary,
	// compare the two files as binary.  This can happen
	// only when the first chunk is read.
	// Also, --brief without any --ignore-* options means
	// we can speed things up by treating the files as binary.  
	if (read_files (filevec, no_details_flag & ~ignore_some_changes, bin_file))
	{
		//  We can now safely assume to have a pair of Binary files.

		// Are both files Open and Regular (no Pipes, Directories, Devices (e.g. NUL))
		if (filevec[0].desc < 0 || filevec[1].desc < 0 ||
			!(S_ISREG (filevec[0].stat.st_mode)) || !(S_ISREG (filevec[1].stat.st_mode))   )
			changes = 1;
		else
		//  Files with different lengths must be different.  
		if (filevec[0].stat.st_size != filevec[1].stat.st_size)
			changes = 1;
		else
		//  Identical descriptor implies identical files
		if (filevec[0].desc == filevec[1].desc)
			changes = 0;
		//  Scan both files, a buffer at a time, looking for a difference.  
		else
		{
			//  Same-sized buffers for both files were allocated in read_files().  
			size_t buffer_size = filevec[0].bufsize;
			
			for (;;)
			{
				//  Read a buffer's worth from both files.  
				for (i = 0; i < 2; i++)
					while (filevec[i].buffered_chars < buffer_size)
					  {
						int r = _read (filevec[i].desc,
									   filevec[i].buffer	+ filevec[i].buffered_chars,
									   (int)(buffer_size - filevec[i].buffered_chars));
						if (r == 0)
							break;
						if (r < 0)
							pfatal_with_name (filevec[i].name);
						filevec[i].buffered_chars += r;
					  }
						
				//  If the buffers have different number of chars, the files differ.  
				if (filevec[0].buffered_chars != filevec[1].buffered_chars)
				{
					changes = 1;
					break;
				}

				//  If we reach end-of-file, the files are the same.  
				if (filevec[0].buffered_chars==0) // therefore: filevec[1].buffered_chars==0
				{
					changes = 0;
					break;
				}	

				//	If buffers have different contents, the files are different.
				if (memcmp (filevec[0].buffer,
							filevec[1].buffer,
							filevec[0].buffered_chars) != 0)
				{
					changes = 1;
					break;
				}

				//	Files appear identical so far...
				//	Prepare to loop again for the next pair of buffers.
				filevec[0].buffered_chars = filevec[1].buffered_chars = 0;
			}
		}
		
		briefly_report (changes, filevec);

		if (bin_status != NULL)
			*bin_status = (changes != 0 ? -1 : 1);
	}
	else
	{
		//  Allocate vectors for the results of comparison:
		// a flag for each line of each file, saying whether that line
		// is an insertion or deletion.
		// Allocate an extra element, always zero, at each end of each vector.  
		
		size_t s = filevec[0].buffered_lines + filevec[1].buffered_lines + 4;
		filevec[0].changed_flag = (char *)xmalloc (s);
		bzero (filevec[0].changed_flag, s);
		filevec[0].changed_flag++;
		filevec[1].changed_flag = filevec[0].changed_flag
			+ filevec[0].buffered_lines + 2;
		
		//  Some lines are obviously insertions or deletions
		// because they don't match anything.  Detect them now, and
		// avoid even thinking about them in the main comparison algorithm.  
		
		discard_confusing_lines (filevec);
		
		//  Now do the main comparison algorithm, considering just the
		// undiscarded lines.  
		
		xvec = filevec[0].undiscarded;
		yvec = filevec[1].undiscarded;
		diags = filevec[0].nondiscarded_lines + filevec[1].nondiscarded_lines + 3;
		fdiag = (int *) xmalloc (diags * (2 * sizeof (int)));
		bdiag = fdiag + diags;
		fdiag += filevec[1].nondiscarded_lines + 1;
		bdiag += filevec[1].nondiscarded_lines + 1;
		
      /* Set TOO_EXPENSIVE to be approximate square root of input size,
	     bounded below by 4096.  4096 seems to be good for circa-2016 CPUs 
	  */
        too_expensive = 1;
        for (i = filevec[0].nondiscarded_lines + filevec[1].nondiscarded_lines;
	         i != 0; i >>= 2)
		  too_expensive <<= 1;
        too_expensive = max (4096, too_expensive);

		files[0] = filevec[0];
		files[1] = filevec[1];
		
		compareseq (0, filevec[0].nondiscarded_lines,
		  0, filevec[1].nondiscarded_lines, no_discards);
		
		free (fdiag - (filevec[1].nondiscarded_lines + 1));
		
		//  Modify the results slightly to make them prettier
		// in cases where that can validly be done.  
		
		shift_boundaries (filevec);
		
		//  Get the results of comparison in the form of a chain
		// of `struct change's -- an edit script.  
		
#if 0
		if (output_style == OUTPUT_ED)
			script = build_reverse_script (filevec);
		else
#endif
			script = build_script (filevec);
		
		//  Set CHANGES if we had any diffs.
		// If some changes are ignored, we must scan the script to decide.  
		if (ignore_blank_lines_flag)
		{
			struct change *next = script;
			changes = 0;
			
			while (next)
			{
				struct change *thisob, *end;
				int first0, last0, first1, last1, deletes, inserts;
				
				//  Find a set of changes that belong together.  
				thisob = next;
				end = find_change (next);
				
				//  Disconnect them from the rest of the changes, making them
				// a hunk, and remember the rest for next iteration.  
				next = end->link;
				end->link = NULL;
				
				//  Determine whether thisob hunk is really a difference.  
				analyze_hunk (thisob, &first0, &last0, &first1, &last1,
					&deletes, &inserts, files);
				
				//  Reconnect the script so it will all be freed properly.  
				end->link = next;
				
				if (deletes || inserts)
					changes = 1;

			}
		}
		else
		{
			changes = (script != NULL);
		}

		/* WinMerge moved block support */
		if (bMoved_blocks_flag)
		{
			moved_block_analysis(&script, filevec);
		}
		
		if (no_details_flag)
			briefly_report (changes, filevec);
		else
		{
			if (changes==0 && ignore_blank_lines_flag)
			{
				// determined that there were no nontrivial changes after considering flags
			}
			else if (changes == 0)
			{
				// determined that there were no nontrivial changes after considering flags
			}
			else if (changes || ! no_diff_means_no_output)
			{
				//  Record info for starting up output,
				// to be used if and when we have some output to print.  
				setup_output (files[0].name, files[1].name, depth);
				
				/*switch (output_style)
				{
				case OUTPUT_CONTEXT:
					print_context_script (script, 0);
					break;
					
				case OUTPUT_UNIFIED:
					print_context_script (script, 1);
					break;
					
				case OUTPUT_ED:
					print_ed_script (script);
					break;
					
				case OUTPUT_FORWARD_ED:
					pr_forward_ed_script (script);
					break;
					
				case OUTPUT_RCS:
					print_rcs_script (script);
					break;
					
				case OUTPUT_NORMAL:
					print_normal_script (script);
					break;
					
				case OUTPUT_IFDEF:
					print_ifdef_script (script);
					break;
					
				case OUTPUT_SDIFF:
					print_sdiff_script (script);
				}
				
				finish_output ();*/
			}
		}
		
		//free (filevec[0].undiscarded);
		
		//free (filevec[0].changed_flag - 1);
		
		//for (i = 1; i >= 0; --i)
		//	free (filevec[i].equivs);
		
		//for (i = 0; i < 2; ++i)
		//	free (filevec[i].linbuf + filevec[i].linbuf_base);
		
		
		/*cleanup the script
		for (e = script; e; e = p)
		{
			p = e->link;
			free (e);
		}*/
		
		if (! ROBUST_OUTPUT_STYLE (output_style))
			for (i = 0; i < 2; ++i)
				if (filevec[i].missing_newline)
				{
					error ("No newline at end of file %s", filevec[i].name, "");
					changes = 2;
				}
    }
	
	//if (filevec[0].buffer != filevec[1].buffer)
	//	free (filevec[0].buffer);
	//free (filevec[1].buffer);
	
	return script;
}

void cleanup_file_buffers(struct file_data fd[])
{
	int i;
	free (fd[0].undiscarded);
	
	if (fd[0].changed_flag != NULL)
		free (fd[0].changed_flag - 1);
	
	for (i = 1; i >= 0; --i)
		free (fd[i].equivs);
	
	for (i = 0; i < 2; ++i)
		free ((void *)(fd[i].linbuf + fd[i].linbuf_base));

	if (fd[0].buffer != fd[1].buffer)
		free (fd[0].buffer);
	free (fd[1].buffer);
}
</file>

<file path="Winmerge-Src/Src/diffutils/src/context.c">
/* Context-format output routines for GNU DIFF.
   Copyright (C) 1988, 89, 91, 92, 93 Free Software Foundation, Inc.

This file is part of GNU DIFF.

GNU DIFF is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GNU DIFF is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU DIFF; see the file COPYING.  If not, write to
the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */

#include "diff.h"

static struct change *find_hunk (struct change *);
static void find_function (struct file_data const *, int, char const HUGE **, size_t *);
static void mark_ignorable (struct change *);
static void pr_context_hunk (struct change *);
static void pr_unidiff_hunk (struct change *);
static void print_context_label (char const *, struct file_data *, char const *);
static void print_context_number_range (struct file_data const *, int, int);
static void print_unidiff_number_range (struct file_data const *, int, int);

/* Last place find_function started searching from.  */
static DECL_TLS int find_function_last_search;

/* The value find_function returned when it started searching there.  */
static DECL_TLS int find_function_last_match;

/* Print a label for a context diff, with a file name and date or a label.  */

static void
print_context_label(char const *mark, struct file_data *inf, char const *label)
{
  if (label)
    fprintf (outfile, "%s %s\n", mark, label);
  else
	{
    /* See Posix.2 section 4.17.6.1.4 for this format.  */
	char ctimeBuffer[26];
	ctime_s(ctimeBuffer, sizeof(ctimeBuffer), &inf->stat.st_mtime);
    fprintf (outfile, "%s %s\t%s", mark, inf->name, ctimeBuffer);
	}
}

/* Print a header for a context diff, with the file names and dates.  */

void
print_context_header(struct file_data inf[], int unidiff_flag)
{
  if (unidiff_flag)
    {
      print_context_label ("---", &inf[0], file_label[0]);
      print_context_label ("+++", &inf[1], file_label[1]);
    }
  else
    {
      print_context_label ("***", &inf[0], file_label[0]);
      print_context_label ("---", &inf[1], file_label[1]);
    }
}

/* Print an edit script in context format.  */

void
print_context_script (struct change *script, int unidiff_flag)
{
  if (ignore_blank_lines_flag)
    mark_ignorable (script);
  else
    {
      struct change *e;
      for (e = script; e != NULL; e = e->link)
	e->ignore = 0;
    }

  find_function_last_search = - files[0].prefix_lines;
  find_function_last_match = find_function_last_search - 1;

  if (unidiff_flag)
    print_script (script, find_hunk, pr_unidiff_hunk);
  else
    print_script (script, find_hunk, pr_context_hunk);
}

/* Print a pair of line numbers with a comma, translated for file FILE.
   If the second number is not greater, use the first in place of it.

   Args A and B are internal line numbers.
   We print the translated (real) line numbers.  */

static void
print_context_number_range (struct file_data const *file, int a, int b)
{
  int trans_a, trans_b;
  translate_range (file, a, b, &trans_a, &trans_b);

  /* Note: we can have B < A in the case of a range of no lines.
     In this case, we should print the line number before the range,
     which is B.  */
  if (trans_b > trans_a)
    fprintf (outfile, "%d,%d", trans_a, trans_b);
  else
    fprintf (outfile, "%d", trans_b);
}

/* Print a portion of an edit script in context format.
   HUNK is the beginning of the portion to be printed.
   The end is marked by a `link' that has been nulled out.

   Prints out lines from both files, and precedes each
   line with the appropriate flag-character.  */

static void
pr_context_hunk (struct change *hunk)
{
  int first0, last0, first1, last1, show_from, show_to, i;
  struct change *next;
  char const *prefix;
  char const HUGE *function;
  size_t function_length=0;
  FILE *out;

  /* Determine range of line numbers involved in each file.  */

  analyze_hunk (hunk, &first0, &last0, &first1, &last1, &show_from, &show_to, files);

  if (!show_from && !show_to)
    return;

  /* Include a context's width before and after.  */

  i = - files[0].prefix_lines;
  first0 = max (first0 - context, i);
  first1 = max (first1 - context, i);
  last0 = min (last0 + context, files[0].valid_lines - 1);
  last1 = min (last1 + context, files[1].valid_lines - 1);

  /* If desired, find the preceding function definition line in file 0.  */
  function = NULL;

  begin_output ();
  out = outfile;

  /* If we looked for and found a function this is part of,
     include its name in the header of the diff section.  */
  fprintf (out, "***************");

  if (function != NULL)
    {
      fprintf (out, " ");
      fwrite (function, 1, min (function_length - 1, 40), out);
    }

  fprintf (out, "\n*** ");
  print_context_number_range (&files[0], first0, last0);
  fprintf (out, " ****\n");

  if (show_from)
    {
      next = hunk;

      for (i = first0; i <= last0; i++)
	{
	  /* Skip past changes that apply (in file 0)
	     only to lines before line I.  */

	  while (next && next->line0 + next->deleted <= i)
	    next = next->link;

	  /* Compute the marking for line I.  */

	  prefix = " ";
	  if (next && next->line0 <= i)
	    /* The change NEXT covers this line.
	       If lines were inserted here in file 1, this is "changed".
	       Otherwise it is "deleted".  */
	    prefix = (next->inserted > 0 ? "!" : "-");

	  print_1_line (prefix, &files[0].linbuf[i]);
	}
    }

  fprintf (out, "--- ");
  print_context_number_range (&files[1], first1, last1);
  fprintf (out, " ----\n");

  if (show_to)
    {
      next = hunk;

      for (i = first1; i <= last1; i++)
	{
	  /* Skip past changes that apply (in file 1)
	     only to lines before line I.  */

	  while (next && next->line1 + next->inserted <= i)
	    next = next->link;

	  /* Compute the marking for line I.  */

	  prefix = " ";
	  if (next && next->line1 <= i)
	    /* The change NEXT covers this line.
	       If lines were deleted here in file 0, this is "changed".
	       Otherwise it is "inserted".  */
	    prefix = (next->deleted > 0 ? "!" : "+");

	  print_1_line (prefix, &files[1].linbuf[i]);
	}
    }
}

/* Print a pair of line numbers with a comma, translated for file FILE.
   If the second number is smaller, use the first in place of it.
   If the numbers are equal, print just one number.

   Args A and B are internal line numbers.
   We print the translated (real) line numbers.  */

static void
print_unidiff_number_range (struct file_data const *file, int a, int b)
{
  int trans_a, trans_b;
  translate_range (file, a, b, &trans_a, &trans_b);

  /* Note: we can have B < A in the case of a range of no lines.
     In this case, we should print the line number before the range,
     which is B.  */
  if (trans_b <= trans_a)
    fprintf (outfile, trans_b == trans_a ? "%d" : "%d,0", trans_b);
  else
    fprintf (outfile, "%d,%d", trans_a, trans_b - trans_a + 1);
}

/* Print a portion of an edit script in unidiff format.
   HUNK is the beginning of the portion to be printed.
   The end is marked by a `link' that has been nulled out.

   Prints out lines from both files, and precedes each
   line with the appropriate flag-character.  */

static void
pr_unidiff_hunk (struct change *hunk)
{
  int first0, last0, first1, last1, show_from, show_to, i, j, k;
  struct change *next;
  char const HUGE *function;
  size_t function_length=0;
  FILE *out;

  /* Determine range of line numbers involved in each file.  */

  analyze_hunk (hunk, &first0, &last0, &first1, &last1, &show_from, &show_to, files);

  if (!show_from && !show_to)
    return;

  /* Include a context's width before and after.  */

  i = - files[0].prefix_lines;
  first0 = max (first0 - context, i);
  first1 = max (first1 - context, i);
  last0 = min (last0 + context, files[0].valid_lines - 1);
  last1 = min (last1 + context, files[1].valid_lines - 1);

  /* If desired, find the preceding function definition line in file 0.  */
  function = NULL;

  begin_output ();
  out = outfile;

  fprintf (out, "@@ -");
  print_unidiff_number_range (&files[0], first0, last0);
  fprintf (out, " +");
  print_unidiff_number_range (&files[1], first1, last1);
  fprintf (out, " @@");

  /* If we looked for and found a function this is part of,
     include its name in the header of the diff section.  */

  if (function != NULL)
    {
      putc (' ', out);
      fwrite (function, 1, min (function_length - 1, 40), out);
    }
  putc ('\n', out);

  next = hunk;
  i = first0;
  j = first1;

  while (i <= last0 || j <= last1)
    {

      /* If the line isn't a difference, output the context from file 0. */

      if (!next || i < next->line0)
	{
	  putc (tab_align_flag ? '\t' : ' ', out);
	  print_1_line (0, &files[0].linbuf[i++]);
	  j++;
	}
      else
	{
	  /* For each difference, first output the deleted part. */

	  k = next->deleted;
	  while (k--)
	    {
	      putc ('-', out);
	      if (tab_align_flag)
		putc ('\t', out);
	      print_1_line (0, &files[0].linbuf[i++]);
	    }

	  /* Then output the inserted part. */

	  k = next->inserted;
	  while (k--)
	    {
	      putc ('+', out);
	      if (tab_align_flag)
		putc ('\t', out);
	      print_1_line (0, &files[1].linbuf[j++]);
	    }

	  /* We're done with this hunk, so on to the next! */

	  next = next->link;
	}
    }
}

/* Scan a (forward-ordered) edit script for the first place that more than
   2*CONTEXT unchanged lines appear, and return a pointer
   to the `struct change' for the last change before those lines.  */

static struct change *
find_hunk (struct change *start)
{
  struct change *prev;
  int top0, top1;
  int thresh;

  do
    {
      /* Compute number of first line in each file beyond this changed.  */
      top0 = start->line0 + start->deleted;
      top1 = start->line1 + start->inserted;
      prev = start;
      start = start->link;
      /* Threshold distance is 2*CONTEXT between two non-ignorable changes,
	 but only CONTEXT if one is ignorable.  */
      thresh = ((prev->ignore || (start && start->ignore))
		? context
		: 2 * context + 1);
      /* It is not supposed to matter which file we check in the end-test.
	 If it would matter, crash.  */
      if (start && start->line0 - top0 != start->line1 - top1)
	abort ();
    } while (start
	     /* Keep going if less than THRESH lines
		elapse before the affected line.  */
	     && start->line0 < top0 + thresh);

  return prev;
}

/* Set the `ignore' flag properly in each change in SCRIPT.
   It should be 1 if all the lines inserted or deleted in that change
   are ignorable lines.  */

static void
mark_ignorable (struct change *script)
{
  while (script)
    {
      struct change *next = script->link;
      int first0, last0, first1, last1, deletes, inserts;

      /* Turn this change into a hunk: detach it from the others.  */
      script->link = NULL;

      /* Determine whether this change is ignorable.  */
      analyze_hunk (script, &first0, &last0, &first1, &last1, &deletes, &inserts, files);
      /* Reconnect the chain as before.  */
      script->link = next;

      /* If the change is ignorable, mark it.  */
      script->ignore = (char)(!deletes && !inserts);

      /* Advance to the following change.  */
      script = next;
    }
}

</file>

<file path="Winmerge-Src/Src/diffutils/src/Diff.cpp">
/////////////////////////////////////////////////////////////////////////////
//    WinMerge:  an interactive diff/merge utility
//    Copyright (C) 1997-2000  Thingamahoochie Software
//    Author: Dean Grimm

/* GNU DIFF main routine.
   Copyright (C) 1988, 1989, 1992, 1993 Free Software Foundation, Inc.

This file is part of GNU DIFF.

GNU DIFF is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GNU DIFF is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU DIFF; see the file COPYING.  If not, write to
the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* GNU DIFF was written by Mike Haertel, David Hayes,
   Richard Stallman, Len Tower, and Paul Eggert.  */

#include "pch.h"
#define GDIFF_MAIN
#include "diff.h" 
#include "io.h"
#include "diffwrapper.h"


/* Nonzero for -r: if comparing two directories,
   compare their common subdirectories recursively.  */

DECL_TLS int recursive;

</file>

<file path="Winmerge-Src/Src/diffutils/src/diff.h">
/* Shared definitions for GNU DIFF
   Copyright (C) 1988, 89, 91, 92, 93 Free Software Foundation, Inc.

This file is part of GNU DIFF.

GNU DIFF is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GNU DIFF is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU DIFF; see the file COPYING.  If not, write to
the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */

#pragma once

#include "system.h"
#include <ctype.h>
#include <stdio.h>

#ifdef NOMINMAX
#undef min
#undef max
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifndef PR_FILE_NAME
#if defined(__MSDOS__) || defined(__NT__) || defined(WIN32)
#define PR_FILE_NAME "pr"
#else
#define PR_FILE_NAME "/bin/pr"
#endif
#endif

#ifdef _MSC_VER
#define DECL_TLS __declspec(thread)
#else
#define DECL_TLS __thread
#endif

#define TAB_WIDTH 8

/* Variables for command line options */

#ifndef GDIFF_MAIN
#define EXTERN extern DECL_TLS 
#else
#define EXTERN DECL_TLS
#endif

enum output_style {
	
  // NOTE: these values are stored in the user's Registry - don't change their value !!
  //   (see enum DiffOutputType in Src/CompareOptions.h)
  /* Default output style.  */
  OUTPUT_NORMAL = 0,
  /* Output the differences with lines of context before and after (-c).  */
  OUTPUT_CONTEXT = 1,
  /* Output the differences in a unified context diff format (-u). */
  OUTPUT_UNIFIED = 2,
  /* Output the differences as commands suitable for `ed' (-e).  */
#if 0
  OUTPUT_ED = 3,
  /* Output the diff as a forward ed script (-f).  */
  OUTPUT_FORWARD_ED = 4,
  /* Like -f, but output a count of changed lines in each "command" (-n). */
  OUTPUT_RCS = 5,
  /* Output merged #ifdef'd file (-D).  */
  OUTPUT_IFDEF = 6,
  /* Output sdiff style (-y).  */
  OUTPUT_SDIFF = 7,
#endif
  /* Output html style.  */
  OUTPUT_HTML = 8
};

/* True for output styles that are robust,
   i.e. can handle a file that ends in a non-newline.  */
#define ROBUST_OUTPUT_STYLE(S) ((S)>=0) // ((S) != OUTPUT_ED && (S) != OUTPUT_FORWARD_ED)

EXTERN int output_style;

/* Nonzero if output cannot be generated for identical files.  */
EXTERN int no_diff_means_no_output;

/* Number of lines of context to show in each set of diffs.
   This is zero when context is not to be shown.  */
EXTERN int      context;

/* Consider all files as text files (-a).
   Don't interpret codes over 0177 as implying a "binary file".  */
EXTERN int	always_text_flag;

/* Number of lines to keep in identical prefix and suffix.  */
EXTERN int      horizon_lines;

/* Ignore changes in horizontal white space (-b).  */
EXTERN int      ignore_space_change_flag;

/* Ignore end of line differences (at least between UNIX & DOS */
EXTERN int      ignore_eol_diff;

/* Ignore all horizontal white space (-w).  */
EXTERN int      ignore_all_space_flag;

/* Ignore changes that affect only blank lines (-B).  */
EXTERN int      ignore_blank_lines_flag;

/* WinMerge moved block code */
EXTERN int moved_blocks_flag;

/* 1 if lines may match even if their lengths are different.
   This depends on various options.  */
EXTERN int      length_varies;

/* 1 if files may match even if their contents are not byte-for-byte identical.
   This depends on various options.  */
EXTERN int      ignore_some_changes;

/* Ignore differences in case of letters (-i).  */
EXTERN int      ignore_case_flag;

/* Ignore differences in case of numbers.  */
EXTERN int      ignore_numbers_flag;

/* File labels for `-c' output headers (-L).  */
EXTERN char *file_label[2];

/* Say only whether files differ, not how (-q).  */
EXTERN int 	no_details_flag;

/* Report files compared that match (-s).
   Normally nothing is output when that happens.  */
EXTERN int      print_file_same_flag;

/* character that ends a line.  Currently this is always `\n'.  */
EXTERN char     line_end_char;

/* Output the differences with exactly 8 columns added to each line
   so that any tabs in the text line up properly (-T).  */
EXTERN int	tab_align_flag;

/* Expand tabs in the output so the text lines up properly
   despite the characters added to the front of each line (-t).  */
EXTERN int	tab_expand_flag;

/* In directory comparison, specify file to start with (-S).
   All file names less than this name are ignored.  */
EXTERN char	*dir_start_file;

/* If a file is new (appears in only one dir)
   include its entire contents (-N).
   Then `patch' would create the file with appropriate contents.  */
EXTERN int	entire_new_file_flag;

/* If a file is new (appears in only the second dir)
   include its entire contents (-P).
   Then `patch' would create the file with appropriate contents.  */
EXTERN int	unidirectional_new_file_flag;

/* Pipe each file's output through pr (-l).  */
EXTERN int	paginate_flag;

enum line_class {
  /* Lines taken from just the first file.  */
  OLD,
  /* Lines taken from just the second file.  */
  NEW,
  /* Lines common to both files.  */
  UNCHANGED,
  /* A hunk containing both old and new lines (line groups only).  */
  CHANGED
};

/* Line group formats for old, new, unchanged, and changed groups.  */
EXTERN char *group_format[CHANGED + 1];

/* Line formats for old, new, and unchanged lines.  */
EXTERN char *line_format[UNCHANGED + 1];

/* If using OUTPUT_SDIFF print extra information to help the sdiff filter. */
EXTERN int sdiff_help_sdiff;

/* Tell OUTPUT_SDIFF to show only the left version of common lines. */
EXTERN int sdiff_left_only;

/* Tell OUTPUT_SDIFF to not show common lines. */
EXTERN int sdiff_skip_common_lines;

/* The half line width and column 2 offset for OUTPUT_SDIFF.  */
EXTERN unsigned sdiff_half_width;
EXTERN unsigned sdiff_column2_offset;

/* String containing all the command options diff received,
   with spaces between and at the beginning but none at the end.
   If there were no options given, this string is empty.  */
EXTERN char *	switch_string;

/* Nonzero means use heuristics for better speed.  */
EXTERN int	heuristic;

/* Name of program the user invoked (for error messages).  */
EXTERN char *	program;

/* The result of comparison is an "edit script": a chain of `struct change'.
   Each `struct change' represents one place where some lines are deleted
   and some are inserted.

   LINE0 and LINE1 are the first affected lines in the two files (origin 0).
   DELETED is the number of lines deleted here from file 0.
   INSERTED is the number of lines inserted here in file 1.

   If DELETED is 0 then LINE0 is the number of the line before
   which the insertion was done; vice versa for INSERTED and LINE1.  */

struct change
{
  struct change *link;		/* Previous or next edit command  */
  int inserted;			/* # lines of file 1 changed here.  */
  int deleted;			/* # lines of file 0 changed here.  */
  int line0;			/* Line number of 1st deleted line.  */
  int line1;			/* Line number of 1st inserted line.  */
  char ignore;			/* Flag used in context.c */
  char trivial;                 /* Flag if change is trivial (ignored blanks or filtered regexps) */
  int match0;                   /* side0 matching line for line 1 */ /* WinMerge moved block code */
  int match1;                   /* side1 matching line for line 0 */ /* WinMerge moved block code */
};

/* Structures that describe the input files.  */

/* Data on one input file being compared.  */

struct file_data {
    int             desc;	/* File descriptor  */
    char const      *name;	/* File name  */
#ifdef _WIN32
    struct _stat64  stat;	/* File status from fstat()  */
#else
    struct stat     stat;	/* File status from fstat()  */
#endif
    int             dir_p;	/* nonzero if file is a directory  */

    /* Buffer in which text of file is read.  */
    char HUGE *	    buffer;
    /* Allocated size of buffer.  */
    FSIZE	    bufsize;
    /* Number of valid characters now in the buffer. */
    FSIZE	    buffered_chars;

    /* Array of pointers to lines in the file.  */
    char const HUGE **linbuf;

    /* linbuf_base <= buffered_lines <= valid_lines <= alloc_lines.
       linebuf[linbuf_base ... buffered_lines - 1] are possibly differing.
       linebuf[linbuf_base ... valid_lines - 1] contain valid data.
       linebuf[linbuf_base ... alloc_lines - 1] are allocated.  */
    int linbuf_base, buffered_lines, valid_lines, alloc_lines;

    /* Pointer to end of prefix of this file to ignore when hashing. */
    char const HUGE *prefix_end;

    /* Count of lines in the prefix.
       There are this many lines in the file before linbuf[0].  */
    int prefix_lines;

    /* Pointer to start of suffix of this file to ignore when hashing. */
    char const HUGE *suffix_begin;

    /* Vector, indexed by line number, containing an equivalence code for
       each line.  It is this vector that is actually compared with that
       of another file to generate differences. */
    int		   *equivs;

    /* Vector, like the previous one except that
       the elements for discarded lines have been squeezed out.  */
    int		   *undiscarded;

    /* Vector mapping virtual line numbers (not counting discarded lines)
       to real ones (counting those lines).  Both are origin-0.  */
    int		   *realindexes;

    /* Total number of nondiscarded lines. */
    int		    nondiscarded_lines;

    /* Vector, indexed by real origin-0 line number,
       containing 1 for a line that is an insertion or a deletion.
       The results of comparison are stored here.  */
    char	   *changed_flag;

    /* 1 if file ends in a line with no final newline. */
    int		    missing_newline;

    /* 1 more than the maximum equivalence value used for this or its
       sibling file. */
    int equiv_max;

    /* text stats for WinMerge */
    int count_crlfs, count_crs, count_lfs, count_zeros;
};

/* Describe the two files currently being compared.  */

EXTERN struct file_data files[2];

/* Stdio stream to output diffs to.  */

EXTERN FILE *outfile;

/* Declare various functions.  */

/* analyze.c */
/* WinMerge: add last two params */
struct change * diff_2_files (struct file_data[], int, int *, int, int*);
void moved_block_analysis(struct change ** pscript, struct file_data fd[]);

/* context.c */
void print_context_header (struct file_data[], int);
void print_context_script (struct change *, int);

/* diff.c */
int excluded_filename (char const *);

/* dir.c */
//int diff_dirs (CDiffContext*);

/* ed.c */
void print_ed_script (struct change *);
void pr_forward_ed_script (struct change *);

/* ifdef.c */
void print_ifdef_script (struct change *);

/* io.c */
/* WinMerge: add last pointer param */
int read_files (struct file_data[], int, int *);
int sip (struct file_data *, int);
void slurp (struct file_data *);

/* normal.c */
void print_normal_script (struct change *);

/* rcs.c */
void print_rcs_script (struct change *);

/* side.c */
void print_sdiff_script (struct change *);

/* util.c */
void *xmalloc (size_t);
void *xrealloc (void *, size_t);
char *concat (char const *, char const *, char const *);
char *dir_file_pathname (char const *, char const *);
int change_letter (int, int);
int line_cmp (char const HUGE *, size_t, char const HUGE *, size_t);
int translate_line_number (struct file_data const *, int);
struct change *find_change (struct change *);
struct change *find_reverse_change (struct change *);
void analyze_hunk (struct change *, int *, int *, int *, int *, int *, int *, const struct file_data fd[]);
void begin_output (void);
void debug_script (struct change *);
void error (char const *, char const *, char const *);
void fatal (char const *);
void finish_output (void);
void message (char const *, char const *, char const *);
void message5 (char const *, char const *, char const *, char const *, char const *);
void output_1_line (char const HUGE *, char const HUGE *, char const *, char const *);
void perror_with_name (char const *);
void pfatal_with_name (char const *);
void print_1_line (char const *, char const HUGE * const *);
void print_message_queue (void);
void print_number_range (int, struct file_data *, int, int);
void print_script (struct change *, struct change * (*) (struct change *), void (*) (struct change *));
void setup_output (char const *, char const *, int);
void translate_range (struct file_data const *, int, int, int *, int *);
void cleanup_file_buffers(struct file_data fd[]);

/* version.c */
extern char const version_string[];

#ifdef _WIN32
/* mystat.cpp */
int myfstat(int fd, struct _stat64 *buf);
int mywstat(const wchar_t *filename, struct _stat64 *buf);
#else
#define myfstat fstat
#endif

#ifdef __cplusplus
#undef HUGE
}
#endif

</file>

<file path="Winmerge-Src/Src/diffutils/src/ed.c">
/* Output routines for ed-script format.
   Copyright (C) 1988, 89, 91, 92, 93 Free Software Foundation, Inc.

This file is part of GNU DIFF.

GNU DIFF is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GNU DIFF is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU DIFF; see the file COPYING.  If not, write to
the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */

#include "diff.h"

static void print_ed_hunk (struct change *);
static void print_rcs_hunk (struct change *);
static void pr_forward_ed_hunk (struct change *);

/* Print our script as ed commands.  */

void
print_ed_script (struct change *script)
{
  print_script (script, find_reverse_change, print_ed_hunk);
}

/* Print a hunk of an ed diff */

static void
print_ed_hunk (struct change *hunk)
{
  int f0, l0, f1, l1;
  int deletes, inserts;

#if 0
  hunk = flip_script (hunk);
#endif
#ifdef DEBUG
  debug_script (hunk);
#endif

  /* Determine range of line numbers involved in each file.  */
  analyze_hunk (hunk, &f0, &l0, &f1, &l1, &deletes, &inserts, files);
  if (!deletes && !inserts)
    return;

  begin_output ();

  /* Print out the line number header for this hunk */
  print_number_range (',', &files[0], f0, l0);
  fprintf (outfile, "%c\n", change_letter (inserts, deletes));

  /* Print new/changed lines from second file, if needed */
  if (inserts)
    {
      int i;
      int inserting = 1;
      for (i = f1; i <= l1; i++)
	{
	  /* Resume the insert, if we stopped.  */
	  if (! inserting)
	    fprintf (outfile, "%da\n",
		     i - f1 + translate_line_number (&files[0], f0) - 1);
	  inserting = 1;

	  /* If the file's line is just a dot, it would confuse `ed'.
	     So output it with a double dot, and set the flag LEADING_DOT
	     so that we will output another ed-command later
	     to change the double dot into a single dot.  */

	  if (files[1].linbuf[i][0] == '.'
	      && files[1].linbuf[i][1] == '\n')
	    {
	      fprintf (outfile, "..\n");
	      fprintf (outfile, ".\n");
	      /* Now change that double dot to the desired single dot.  */
	      fprintf (outfile, "%ds/^\\.\\././\n",
		       i - f1 + translate_line_number (&files[0], f0));
	      inserting = 0;
	    }
	  else
	    /* Line is not `.', so output it unmodified.  */
	    print_1_line ("", &files[1].linbuf[i]);
	}

      /* End insert mode, if we are still in it.  */
      if (inserting)
	fprintf (outfile, ".\n");
    }
}

/* Print change script in the style of ed commands,
   but print the changes in the order they appear in the input files,
   which means that the commands are not truly useful with ed.  */

void
pr_forward_ed_script (struct change *script)
{
  print_script (script, find_change, pr_forward_ed_hunk);
}

static void
pr_forward_ed_hunk (struct change *hunk)
{
  int i;
  int f0, l0, f1, l1;
  int deletes, inserts;

  /* Determine range of line numbers involved in each file.  */
  analyze_hunk (hunk, &f0, &l0, &f1, &l1, &deletes, &inserts, files);
  if (!deletes && !inserts)
    return;

  begin_output ();

  fprintf (outfile, "%c", change_letter (inserts, deletes));
  print_number_range (' ', files, f0, l0);
  fprintf (outfile, "\n");

  /* If deletion only, print just the number range.  */

  if (!inserts)
    return;

  /* For insertion (with or without deletion), print the number range
     and the lines from file 2.  */

  for (i = f1; i <= l1; i++)
    print_1_line ("", &files[1].linbuf[i]);

  fprintf (outfile, ".\n");
}

/* Print in a format somewhat like ed commands
   except that each insert command states the number of lines it inserts.
   This format is used for RCS.  */

void
print_rcs_script (struct change *script)
{
  print_script (script, find_change, print_rcs_hunk);
}

/* Print a hunk of an RCS diff */

static void
print_rcs_hunk (struct change *hunk)
{
  int i;
  int f0, l0, f1, l1;
  int deletes, inserts;
  int tf0, tl0, tf1, tl1;

  /* Determine range of line numbers involved in each file.  */
  analyze_hunk (hunk, &f0, &l0, &f1, &l1, &deletes, &inserts, files);
  if (!deletes && !inserts)
    return;

  begin_output ();

  translate_range (&files[0], f0, l0, &tf0, &tl0);

  if (deletes)
    {
      fprintf (outfile, "d");
      /* For deletion, print just the starting line number from file 0
	 and the number of lines deleted.  */
      fprintf (outfile, "%d %d\n",
	       tf0,
	       (tl0 >= tf0 ? tl0 - tf0 + 1 : 1));	     
    }

  if (inserts)
    {
      fprintf (outfile, "a");

      /* Take last-line-number from file 0 and # lines from file 1.  */
      translate_range (&files[1], f1, l1, &tf1, &tl1);
      fprintf (outfile, "%d %d\n",
	       tl0,
	       (tl1 >= tf1 ? tl1 - tf1 + 1 : 1));	     

      /* Print the inserted lines.  */
      for (i = f1; i <= l1; i++)
	print_1_line ("", &files[1].linbuf[i]);
    }
}
</file>

<file path="Winmerge-Src/Src/diffutils/src/ifdef.c">
/* #ifdef-format output routines for GNU DIFF.
   Copyright (C) 1989, 91, 92, 93 Free Software Foundation, Inc.

This file is part of GNU DIFF.

GNU DIFF is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY.  No author or distributor
accepts responsibility to anyone for the consequences of using it
or for whether it serves any particular purpose or works at all,
unless he says so in writing.  Refer to the GNU General Public
License for full details.

Everyone is granted permission to copy, modify and redistribute
GNU DIFF, but only under the conditions described in the
GNU General Public License.   A copy of this license is
supposed to have been given to you along with GNU DIFF so you
can know your rights and responsibilities.  It should be in a
file named COPYING.  Among other things, the copyright notice
and this notice must be preserved on all copies.  */


#include "diff.h"
#include <assert.h>

struct group
{
  struct file_data const *file;
  int from, upto; /* start and limit lines for this group of lines */
};

static char *format_group (FILE *, char *, int, struct group const[]);
static char *scan_char_literal (char *, int *);
static char *scan_printf_spec (char *);
static int groups_letter_value (struct group const[], int);
static void format_ifdef (char *, int, int, int, int);
static void print_ifdef_hunk (struct change *);
static void print_ifdef_lines (FILE *, char *, struct group const *);

static DECL_TLS int next_line;

/* Print the edit-script SCRIPT as a merged #ifdef file.  */

void
print_ifdef_script (struct change *script)
{
  next_line = - files[0].prefix_lines;
  print_script (script, find_change, print_ifdef_hunk);
  if (next_line < files[0].valid_lines)
    {
      begin_output ();
      format_ifdef (group_format[UNCHANGED], next_line, files[0].valid_lines,
		    next_line - files[0].valid_lines + files[1].valid_lines,
		    files[1].valid_lines);
    }
}

/* Print a hunk of an ifdef diff.
   This is a contiguous portion of a complete edit script,
   describing changes in consecutive lines.  */

static void
print_ifdef_hunk (struct change *hunk)
{
  int first0, last0, first1, last1, deletes, inserts;
  char *format;

  /* Determine range of line numbers involved in each file.  */
  analyze_hunk (hunk, &first0, &last0, &first1, &last1, &deletes, &inserts, files);
  if (inserts)
    format = deletes ? group_format[CHANGED] : group_format[NEW];
  else if (deletes)
    format = group_format[OLD];
  else
    return;

  begin_output ();

  /* Print lines up to this change.  */
  if (next_line < first0)
    format_ifdef (group_format[UNCHANGED], next_line, first0,
		  next_line - first0 + first1, first1);

  /* Print this change.  */
  next_line = last0 + 1;
  format_ifdef (format, first0, next_line, first1, last1 + 1);
}

/* Print a set of lines according to FORMAT.
   Lines BEG0 up to END0 are from the first file;
   lines BEG1 up to END1 are from the second file.  */

static void
format_ifdef (char *format, int beg0, int end0, int beg1, int end1)
{
  struct group groups[2];

  groups[0].file = &files[0];
  groups[0].from = beg0;
  groups[0].upto = end0;
  groups[1].file = &files[1];
  groups[1].from = beg1;
  groups[1].upto = end1;
  format_group (outfile, format, '\0', groups);
}

/* Print to file OUT a set of lines according to FORMAT.
   The format ends at the first free instance of ENDCHAR.
   Yield the address of the terminating character.
   GROUPS specifies which lines to print.
   If OUT is zero, do not actually print anything; just scan the format.  */

static char *
format_group (register FILE *out, char *format, int endchar, struct group const groups[])
{
  register char c;
  register char *f = format;

  while ((c = *f) != endchar && c != 0)
    {
      f++;
      if (c == '%')
	{
	  char *spec = f;
	  switch ((c = *f++))
	    {
	    case '%':
	      break;

	    case '(':
	      /* Print if-then-else format e.g. `%(n=1?thenpart:elsepart)'.  */
	      {
		int i, value[2];
		FILE *thenout, *elseout;

		for (i = 0; i < 2; i++)
		  {
		    unsigned char f0 = f[0];
		    if (isdigit (f0))
		      {
			value[i] = atoi (f);
			while (isdigit ((unsigned char) *++f))
			  continue;
		      }
		    else
		      {
			value[i] = groups_letter_value (groups, f0);
			if (value[i] < 0)
			  goto bad_format;
			f++;
		      }
		    if (*f++ != "=?"[i])
		      goto bad_format;
		  }
		if (value[0] == value[1])
		  thenout = out, elseout = 0;
		else
		  thenout = 0, elseout = out;
		f = format_group (thenout, f, ':', groups);
		if (*f)
		  {
		    f = format_group (elseout, f + 1, ')', groups);
		    if (*f)
		      f++;
		  }
	      }
	      continue;

	    case '<':
	      /* Print lines deleted from first file.  */
	      print_ifdef_lines (out, line_format[OLD], &groups[0]);
	      continue;

	    case '=':
	      /* Print common lines.  */
	      print_ifdef_lines (out, line_format[UNCHANGED], &groups[0]);
	      continue;

	    case '>':
	      /* Print lines inserted from second file.  */
	      print_ifdef_lines (out, line_format[NEW], &groups[1]);
	      continue;

	    default:
	      {
		int value;
		char *speclim;

		f = scan_printf_spec (spec);
		if (!f)
		  goto bad_format;
		speclim = f;
		c = *f++;
		switch (c)
		  {
		    case '\'':
		      f = scan_char_literal (f, &value);
		      if (!f)
			goto bad_format;
		      break;

		    default:
		      value = groups_letter_value (groups, c);
		      if (value < 0)
			goto bad_format;
		      break;
		  }
		if (out)
		  {
		    /* Temporarily replace e.g. "%3dnx" with "%3d\0x".  */
		    *speclim = 0;
		    fprintf (out, spec - 1, value);
		    /* Undo the temporary replacement.  */
		    *speclim = c;
		  }
	      }
	      continue;

	    bad_format:
	      c = '%';
	      f = spec;
	      break;
	    }
	}
      if (out)
	putc (c, out);
    }
  return f;
}

/* For the line group pair G, return the number corresponding to LETTER.
   Return -1 if LETTER is not a group format letter.  */
static int
groups_letter_value (struct group const g[], int letter)
{
  if (isupper (letter))
    {
      g++;
      letter = tolower (letter);
    }
  switch (letter)
    {
      case 'e': return translate_line_number (g->file, g->from) - 1;
      case 'f': return translate_line_number (g->file, g->from);
      case 'l': return translate_line_number (g->file, g->upto) - 1;
      case 'm': return translate_line_number (g->file, g->upto);
      case 'n': return g->upto - g->from;
      default: return -1;
    }
}

/* Print to file OUT, using FORMAT to print the line group GROUP.
   But do nothing if OUT is zero.  */
static void
print_ifdef_lines (register FILE *out, char *format, struct group const *group)
{
  struct file_data const *file = group->file;
  char const HUGE * const *linbuf = file->linbuf;
  int from = group->from, upto = group->upto;

  if (!out)
    return;

  /* If possible, use a single fwrite; it's faster.  */
  if (!tab_expand_flag && format[0] == '%')
    {
      if (format[1] == 'l' && format[2] == '\n' && !format[3])
	{
	  fwrite (linbuf[from], sizeof (char),
		  linbuf[upto] + (linbuf[upto][-1] != '\n') -  linbuf[from],
		  out);
	  return;
	}
      if (format[1] == 'L' && !format[2])
	{
	  fwrite (linbuf[from], sizeof (char),
		  linbuf[upto] -  linbuf[from], out);
	  return;
	}
    }

  for (;  from < upto;  from++)
    {
      register char c;
      register char *f = format;

      while ((c = *f++) != 0)
	{
	  if (c == '%')
	    {
	      char *spec = f;
	      switch ((c = *f++))
		{
		case '%':
		  break;

		case 'l':
		  output_1_line (linbuf[from],
				 linbuf[from + 1]
				   - (linbuf[from + 1][-1] == '\n'), 0, 0);
		  continue;

		case 'L':
		  output_1_line (linbuf[from], linbuf[from + 1], 0, 0);
		  continue;

		default:
		  {
		    int value;
		    char *speclim;

		    f = scan_printf_spec (spec);
		    if (!f)
		      goto bad_format;
		    speclim = f;
		    c = *f++;
		    switch (c)
		      {
			case '\'':
			  f = scan_char_literal (f, &value);
			  if (!f)
			    goto bad_format;
			  break;

		        case 'n':
			  value = translate_line_number (file, from);
			  break;
			
			default:
			  goto bad_format;
		      }
		    /* Temporarily replace e.g. "%3dnx" with "%3d\0x".  */
		    *speclim = 0;
		    fprintf (out, spec - 1, value);
		    /* Undo the temporary replacement.  */
		    *speclim = c;
		  }
		  continue;

		bad_format:
		  c = '%';
		  f = spec;
		  break;
		}
	    }
	  putc (c, out);
	}
    }
}

/* Scan the character literal represented in the string LIT; LIT points just
   after the initial apostrophe.  Put the literal's value into *INTPTR.
   Yield the address of the first character after the closing apostrophe,
   or zero if the literal is ill-formed.  */
static char *
scan_char_literal (char *lit, int *intptr)
{
  register char *p = lit;
  int value, digits;
  char c = *p++;

  switch (c)
    {
      case 0:
      case '\'':
	return NULL;

      case '\\':
	value = 0;
	while ((c = *p++) != '\'')
	  {
	    unsigned digit = c - '0';
	    if (8 <= digit)
	      return NULL;
	    value = 8 * value + digit;
	  }
	assert((p - lit - 2) < INT_MAX);
	digits = (int)(p - lit - 2);
	if (! (1 <= digits && digits <= 3))
	  return NULL;
	break;

      default:
	value = c;
	if (*p++ != '\'')
	  return NULL;
	break;
    }
  *intptr = value;
  return p;
}

/* Scan optional printf-style SPEC of the form `-*[0-9]*(.[0-9]*)?[cdoxX]'.
   Return the address of the character following SPEC, or NULL if failure.  */
static char *
scan_printf_spec (register char *spec)
{
  register unsigned char c;

  while ((c = *spec++) == '-')
    continue;
  while (isdigit (c))
    c = *spec++;
  if (c == '.')
    while (isdigit (c = *spec++))
      continue;
  switch (c)
    {
      case 'c': case 'd': case 'o': case 'x': case 'X':
	return spec;

      default:
	return NULL;
    }
}
</file>

<file path="Winmerge-Src/Src/diffutils/src/io.c">
/* File I/O for GNU DIFF.
   Copyright (C) 1988, 1989, 1992, 1993 Free Software Foundation, Inc.

This file is part of GNU DIFF.

GNU DIFF is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GNU DIFF is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU DIFF; see the file COPYING.  If not, write to
the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */

#include "diff.h"
#include <io.h>
#include <assert.h>

/* Rotate a value n bits to the left. */
#define UINT_BIT (sizeof (unsigned) * CHAR_BIT)
#define ROL(v, n) ((v) << (n) | (v) >> (UINT_BIT - (n)))

/* Given a hash value and a new character, return a new hash value. */
#define HASH(h, c) ((c) + ROL (h, 7))

/* Guess remaining number of lines from number N of lines so far,
   size S so far, and total size T.  */
#define GUESS_LINES(n,s,t) (((t) - (s)) / ((n) < 10 ? 32 : (s) / ((n)-1)) + 5)

/* Type used for fast prefix comparison in find_identical_ends.  */
typedef unsigned word;

/** @brief Known Unicode encodings. */
enum UNICODESET
{
  NONE = 0,  /**< No unicode. */
  UCS2LE,    /**< UCS-2 / UTF-16 little endian. */
  UCS2BE,    /**< UCS-2 / UTF-16 big endian. */
  UTF8,      /**< UTF-8. */
  UCS4LE,    /**< UTF-32 little endian */
  UCS4BE,    /**< UTF-32 big-endian */
};

/* Lines are put into equivalence classes (of lines that match in line_cmp).
   Each equivalence class is represented by one of these structures,
   but only while the classes are being computed.
   Afterward, each class is represented by a number.  */
struct equivclass
{
  int next;	/* Next item in this bucket. */
  unsigned hash;	/* Hash of lines in this class.  */
  char const HUGE *line;	/* A line that fits this class. */
  size_t length;	/* The length of that line.  */
};

/* Hash-table: array of buckets, each being a chain of equivalence classes.  */
static DECL_TLS int *buckets;
  
/* Number of buckets in the hash table array. */
static DECL_TLS int nbuckets;

/* Array in which the equivalence classes are allocated.
   The bucket-chains go through the elements in this array.
   The number of an equivalence class is its index in this array.  */
static DECL_TLS struct equivclass HUGE *equivs;

/* Index of first free element in the array `equivs'.  */
static DECL_TLS int equivs_index;

/* Number of elements allocated in the array `equivs'.  */
static DECL_TLS int equivs_alloc;

static void find_and_hash_each_line (struct file_data *);
static void find_identical_ends (struct file_data[]);
static char *prepare_text_end (struct file_data *, short);
static enum UNICODESET get_unicode_signature(struct file_data *, int *pBomsize);

/* Check for binary files and compare them for exact identity.  */

/* Return 1 if BUF contains a non text character.
   SIZE is the number of characters in BUF.  */

#define binary_file_p(buf, size) (size != 0 && memchr (buf, '\0', size) != 0)

/** @brief Get unicode signature from file_data. */
static enum UNICODESET get_unicode_signature(struct file_data *current, int *pBomsize)
{
  // initialize to a pattern that differs everywhere from all possible unicode signatures
  unsigned long sig = 0x3F3F3F3F;
  // copy at most 4 bytes from buffer
  memcpy(&sig, current->buffer, min(current->buffered_chars, 4));
  // check for the two possible 4 bytes signatures
  int tmp;
  int *bomsize = pBomsize ? pBomsize : &tmp;
  
  if (sig == 0x0000FEFF)
    {
      *bomsize = 4;
      return UCS4LE;
    }
  if (sig == 0xFFFE0000)
    {
      *bomsize = 4;
      return UCS4BE;
    }
  // check for the only possible 3 bytes signature
  sig &= 0xFFFFFF;
  if (sig == 0xBFBBEF)
    {
      *bomsize = 3;
      return UTF8;
    }
  // check for the two possible 2 bytes signatures
  sig &= 0xFFFF;
  if (sig == 0xFEFF)
    {
      *bomsize = 2;
      return UCS2LE;
    }
  if (sig == 0xFFFE)
    {
      *bomsize = 2;
      return UCS2BE;
    }
  // none of the above checks has passed, so probably no unicode
  *bomsize = 0;
  return NONE;
}

/* Get ready to read the current file.
   Return nonzero if SKIP_TEST is zero,
   and if it appears to be a binary file.  */

int
sip (struct file_data *current, int skip_test)
{
  int isbinary = 0;
  /* If we have a nonexistent file (or NUL: device) at this stage, treat it as empty.  */
  if (current->desc < 0 || !(S_ISREG (current->stat.st_mode)))
    {
      /* Leave room for a sentinel.  */
      current->buffer = xmalloc (sizeof (word));
      current->bufsize = sizeof (word);
      current->buffered_chars = 0;
    }
  else
    {
      current->bufsize = current->buffered_chars
        = STAT_BLOCKSIZE (current->stat);
#ifdef __MSDOS__
      if ((current->buffer = (char HUGE *) farmalloc (current->bufsize)) == NULL)
         fatal ("far memory exhausted");
#else
      current->buffer = xmalloc (current->bufsize);
#endif /*__MSDOS__*/

      if (skip_test)
        current->buffered_chars = 0;
      else
        {
          /* Check first part of file to see if it's a binary file.  */
          current->buffered_chars = _read (current->desc,
            current->buffer,
            (unsigned int)current->buffered_chars);
          if (current->buffered_chars == -1)
            pfatal_with_name (current->name);
          if (!get_unicode_signature(current, NULL))
            isbinary = binary_file_p(current->buffer, current->buffered_chars);
        }
    }
  
  return isbinary;
}

/* Slurp the rest of the current file completely into memory.  */

void
slurp (struct file_data *current)
{
  size_t cc;

  if (current->desc < 0)
    /* The file is nonexistent.  */
    ;
  else if (always_text_flag || current->buffered_chars != 0)
    {
      enum UNICODESET sig = get_unicode_signature(current, NULL);
      size_t alloc_extra
        = (1 << sig) & ((1 << UCS2LE) | (1 << UCS2BE) | (1 << UCS4LE) | (1 << UCS4BE))
          // some flavor of non octet encoded unicode?
          ? ~0U	// yes, allocate extra room for transcoding
          : 0U;	// no, allocate no extra room for transcoding

      for (;;)
        {
          if (current->buffered_chars == current->bufsize)
            {
              if (S_ISREG (current->stat.st_mode))
                {
              /* Get the size out of the stat block.
                 Allocate 50% extra room for a necessary transcoding to UTF-8.
                 Allocate enough room for appended newline and sentinel.
                 Allocate at least one block, to prevent overrunning the buffer
                 when comparing growing binary files. */
                  current->bufsize = max (current->bufsize,
                    (size_t)current->stat.st_size + (alloc_extra & (size_t)current->stat.st_size / 2) + sizeof (word) + 1);
                }
              else
                {
#ifdef __MSDOS__
                  current->bufsize += 4096;
#else
                  current->bufsize = current->bufsize * 2;
#endif /*__MSDOS__*/
                }
#ifdef __MSDOS__
              current->buffer = (char HUGE *) farrealloc (current->buffer, current->bufsize);
#else
              current->buffer = xrealloc (current->buffer, current->bufsize);
#endif /*__MSDOS__*/
            }
          unsigned int bytes_to_read = min((unsigned int)(current->bufsize - current->buffered_chars), INT_MAX);
          if (bytes_to_read == 0)
            break;
          cc = _read (current->desc,
                      current->buffer + current->buffered_chars,
                      bytes_to_read);
          if (cc == 0)
            break;
          if (cc == -1)
            pfatal_with_name (current->name);
          current->buffered_chars += cc;
        }
#ifndef __MSDOS__
      /* Allocate 50% extra room for a necessary transcoding to UTF-8.
         Allocate enough room for appended newline and sentinel. 
		 But don't reallocate if the buffer is already big enough */
	  FSIZE tmp_bufsize = current->buffered_chars + (alloc_extra & current->buffered_chars / 2) + sizeof (word) + 1;
	  if (tmp_bufsize > current->bufsize) 
	    { 
		  current->buffer = xrealloc (current->buffer, tmp_bufsize);
		  current->bufsize = tmp_bufsize;
	    }
#endif /*!__MSDOS__*/
    }
}

static int
ISWSPACE (char ch)
{
  return ch==' ' || ch=='\t';
}

/* Split the file into lines, simultaneously computing the equivalence class for
   each line. */
static void
find_and_hash_each_line (struct file_data *current)
{
  unsigned h;
  unsigned char const HUGE *p = (unsigned char const HUGE *) current->prefix_end;
  unsigned char c;
  int i, *bucket;
  size_t length;

  /* Cache often-used quantities in local variables to help the compiler.  */
  char const HUGE **linbuf = current->linbuf;
  int alloc_lines = current->alloc_lines;
  int line = 0;
  int linbuf_base = current->linbuf_base;
  int *cureqs = (int *) xmalloc (alloc_lines * sizeof (int));
  struct equivclass HUGE *eqs = equivs;
  int eqs_index = equivs_index;
  int eqs_alloc = equivs_alloc;
  char const HUGE *suffix_begin = current->suffix_begin;
  char const HUGE *bufend = current->buffer + current->buffered_chars;
  char const HUGE *incomplete_tail
    = current->missing_newline && ROBUST_OUTPUT_STYLE (output_style)
      ? bufend : (char const HUGE *) NULL;
  int varies = length_varies;

  /* prepare_text_end put a zero word at the end of the buffer, 
  so we're not in danger of overrunning the end of the file */

  while ((char const HUGE *) p < suffix_begin)
    {
      char const HUGE *ip = (char const HUGE *) p;

      /* Compute the equivalence class (hash) for this line.  */

      h = 0;


      /* loops advance pointer to eol (end of line)
         respecting UNIX (\r), MS-DOS/Windows (\r\n), and MAC (\r) eols */

      /* Hash this line until we find a newline. */
      if (ignore_case_flag)
        {
          if (ignore_all_space_flag)
            while ((c = *p++) != '\n' && (c != '\r' || *p == '\n'))
              {
                if (ignore_numbers_flag && isdigit(c))
                    continue;
                if (! ISWSPACE (c))
                  h = HASH (h, isupper (c) ? tolower (c) : c);
              }
          else if (ignore_space_change_flag)
            /* Note that \r must be hashed (if !ignore_eol_diff) */
            while ((c = *p++) != '\n' && (c != '\r' || *p == '\n'))
              {
                if (ISWSPACE (c))
                  {
                    /* skip whitespace after whitespace */
                    while (ISWSPACE (c = *p++))
                      ;
                    if (c == '\n')
                      {
                        goto hashing_done; /* never hash trailing \n */
                      }
                    else if (c != '\r')
                      {
                  /* runs of whitespace not ending line hashed as one space */
                        h = HASH (h, ' ');
                      }
                  }

                /* c is now the first non-space.  */

                if (ignore_numbers_flag && isdigit(c))
                    continue;

                /* c can be a \r (CR) if !ignore_eol_diff */
                h = HASH (h, isupper (c) ? tolower (c) : c);
                if (c == '\r' && *p != '\n')
                  goto hashing_done;
              }
          else
            while ((c = *p++) != '\n' && (c != '\r' || *p == '\n'))
              {
                if (ignore_numbers_flag && isdigit(c))
                    continue;

                h = HASH (h, isupper (c) ? tolower (c) : c);
              }
        }
      else
        {
          if (ignore_all_space_flag)
            while ((c = *p++) != '\n' && (c != '\r' || *p == '\n'))
              {
                if (ignore_numbers_flag && isdigit(c))
                    continue;

                if (! ISWSPACE (c))
                  h = HASH (h, c);
              }
          else if (ignore_space_change_flag)
            /* Note that \r must be hashed (if !ignore_eol_diff) */
            while ((c = *p++) != '\n' && (c != '\r' || *p == '\n'))
              {
                if (ISWSPACE (c))
                  {
                    /* skip whitespace after whitespace */
                    while (ISWSPACE (c = *p++))
                      ;
                    if (c == '\n')
                      {
                        goto hashing_done; /* never hash trailing \n */
                      }
                    else if (c != '\r')
                      {
                  /* runs of whitespace not ending line hashed as one space */
                        h = HASH (h, ' ');
                      }
                  }
                /* c is now the first non-space.  */
                if (ignore_numbers_flag && isdigit(c))
                    continue;

                /* c can be a \r (CR) if !ignore_eol_diff */
                h = HASH (h, c);
                if (c == '\r' && *p != '\n')
                  goto hashing_done;
              }
          else
            while ((c = *p++) != '\n' && (c != '\r' || *p == '\n'))
              {
                if (ignore_numbers_flag && isdigit(c))
                    continue;

                h = HASH (h, c);
              }
        }
hashing_done:;

      bucket = &buckets[h % nbuckets];
      length = (char const HUGE *) p - ip - ((char const HUGE *) p == incomplete_tail);
      for (i = *bucket;  ;  i = eqs[i].next)
        if (!i)
          {
            /* Create a new equivalence class in this bucket. */
            i = eqs_index++;
            if (i == eqs_alloc)
#ifdef __MSDOS__
              if ((eqs = (struct equivclass HUGE *) farrealloc (eqs, (long) (eqs_alloc*=2) * sizeof(*eqs))) == NULL)
                fatal ("far memory exhausted");
#else
              eqs = (struct equivclass *)
                xrealloc (eqs, (eqs_alloc*=2) * sizeof(*eqs));
#endif /*__MSDOS__*/
            eqs[i].next = *bucket;
            eqs[i].hash = h;
            eqs[i].line = ip;
            eqs[i].length = length;
            *bucket = i;
            break;
          }
        /* "line_cmp" changed to "lines_differ" by diffutils 2.8.1 */
        else if (eqs[i].hash == h
           && (eqs[i].length == length || varies)
           && ! line_cmp (eqs[i].line, eqs[i].length, ip, length))
          /* Reuse existing equivalence class.  */
            break;

      /* Maybe increase the size of the line table. */
      if (line == alloc_lines)
        {
          /* Double (alloc_lines - linbuf_base) by adding to alloc_lines.  */
          alloc_lines = 2 * alloc_lines - linbuf_base;
          cureqs = (int *) xrealloc (cureqs, alloc_lines * sizeof (*cureqs));
          linbuf = (char const HUGE **) xrealloc ((void *)(linbuf + linbuf_base),
                     (alloc_lines - linbuf_base)
                     * sizeof (*linbuf))
             - linbuf_base;
        }
      linbuf[line] = ip;
      cureqs[line] = i;
      ++line;
    }

  current->buffered_lines = line;

  for (i = 0;  ;  i++)
    {
      /* Record the line start for lines in the suffix that we care about.
         Record one more line start than lines,
         so that we can compute the length of any buffered line.  */
      if (line == alloc_lines)
        {
          /* Double (alloc_lines - linbuf_base) by adding to alloc_lines.  */
          alloc_lines = 2 * alloc_lines - linbuf_base;
          linbuf = (char const HUGE **) xrealloc ((void *)(linbuf + linbuf_base),
                     (alloc_lines - linbuf_base)
                     * sizeof (*linbuf))
             - linbuf_base;
        }
      linbuf[line] = (char const HUGE *) p;
    
     if ((char const HUGE *) p == bufend)
        {
          linbuf[line]  -=  (char const HUGE *) p == incomplete_tail;
          break;
        }

      if (context <= i && no_diff_means_no_output)
        break;

      line++;

      while (p[0] != '\n' && (p[0] != '\r' || p[1] == '\n'))
         p++;
      p++;
    }

  /* Done with cache in local variables.  */
  current->linbuf = linbuf;
  current->valid_lines = line;
  current->alloc_lines = alloc_lines;
  current->equivs = cureqs;
  equivs = eqs;
  equivs_alloc = eqs_alloc;
  equivs_index = eqs_index;
}

/* Convert any non octet encoded unicode text to UTF-8.
   Prepare the end of the text. Make sure it's initialized.
   Make sure text ends in a newline,
   but remember that we had to add one unless -B is in effect.
   Return effective start of text to be compared. */

# pragma warning(push)          // Saves the current warning state.
# pragma warning(disable:4244)  // Temporarily disables warning 4244: "conversion from 'int' to 'char', possible loss of data"
static char *
prepare_text_end (struct file_data *current, short side)
{
  FSIZE buffered_chars = current->buffered_chars;
  char *const p = current->buffer;
  char *r = p; // receives the return value
  char *q0, *t;
  int bomsize = 0;
  enum UNICODESET sig = get_unicode_signature(current, &bomsize);
  char *const u0 = p + bomsize;

  if (sig == UCS4LE)
    {
      FSIZE buffered_words = buffered_chars / 2;
      unsigned long *q1 = (unsigned long *)p + buffered_words / 2;
      buffered_chars += buffered_words;
      r = p + buffered_chars;
      while (--q1 >= (unsigned long *)u0) // exclude the BOM
        {
          unsigned long u = *q1;
          if (u >= 0x80000000)
            {
              *--r = '?';
            }
          else if (u >= 0x4000000)
            {
              *--r = 0x80 + (u & 0x3F);
              *--r = 0x80 + ((u >> 6) & 0x3F);
              *--r = 0x80 + ((u >> 12) & 0x3F);
              *--r = 0x80 + ((u >> 18) & 0x3F);
              *--r = 0x80 + ((u >> 24) & 0x3F);
              *--r = 0xFC + (u >> 30);
            }
            else if (u >= 0x200000)
            {
              *--r = 0x80 + (u & 0x3F);
              *--r = 0x80 + ((u >> 6) & 0x3F);
              *--r = 0x80 + ((u >> 12) & 0x3F);
              *--r = 0x80 + ((u >> 18) & 0x3F);
              *--r = 0xF8 + (u >> 24);
            }
            else if (u >= 0x10000)
            {
              *--r = 0x80 + (u & 0x3F);
              *--r = 0x80 + ((u >> 6) & 0x3F);
              *--r = 0x80 + ((u >> 12) & 0x3F);
              *--r = 0xF0 + (char)(u >> 18);
            }
            else if (u >= 0x800)
            {
              *--r = 0x80 + (u & 0x3F);
              *--r = 0x80 + ((u >> 6) & 0x3F);
              *--r = 0xE0 + (char)(u >> 12);
            }
            else if (u >= 0x80 || u == 0) // map NUL to 2 byte sequence so as to prevent it from confusing diff algorithm
            {
              *--r = 0x80 + (u & 0x3F);
              *--r = 0xC0 + (char)(u >> 6);
            }
            else
            {
              *--r = (char)u;
            }
        }
    }
  else if (sig == UCS4BE)
    {
      FSIZE buffered_words = buffered_chars / 2;
      unsigned long *q = (unsigned long *)p + buffered_words / 2;
      buffered_chars += buffered_words;
      r = p + buffered_chars;
      while (--q >= (unsigned long *)u0) // exclude the BOM
        {
          unsigned long u =
          ((*q & 0x000000FF) << 24) |
          ((*q & 0x0000FF00) << 8) |
          ((*q & 0x00FF0000) >> 8) |
          ((*q & 0xFF000000) >> 24); // fix byte order
          if (u >= 0x80000000)
            {
              *--r = '?';
            }
          else if (u >= 0x4000000)
            {
              *--r = 0x80 + (u & 0x3F);
              *--r = 0x80 + ((u >> 6) & 0x3F);
              *--r = 0x80 + ((u >> 12) & 0x3F);
              *--r = 0x80 + ((u >> 18) & 0x3F);
              *--r = 0x80 + ((u >> 24) & 0x3F);
              *--r = 0xFC + (u >> 30);
            }
          else if (u >= 0x200000)
            {
              *--r = 0x80 + (u & 0x3F);
              *--r = 0x80 + ((u >> 6) & 0x3F);
              *--r = 0x80 + ((u >> 12) & 0x3F);
              *--r = 0x80 + ((u >> 18) & 0x3F);
              *--r = 0xF8 + (u >> 24);
            }
          else if (u >= 0x10000)
            {
              *--r = 0x80 + (u & 0x3F);
              *--r = 0x80 + ((u >> 6) & 0x3F);
              *--r = 0x80 + ((u >> 12) & 0x3F);
              *--r = 0xF0 + (char)(u >> 18);
            }
          else if (u >= 0x800)
            {
              *--r = 0x80 + (u & 0x3F);
              *--r = 0x80 + ((u >> 6) & 0x3F);
              *--r = 0xE0 + (char)(u >> 12);
            }
          else if (u >= 0x80 || u == 0) // map NUL to 2 byte sequence so as to prevent it from confusing diff algorithm
            {
              *--r = 0x80 + (u & 0x3F);
              *--r = 0xC0 + (char)(u >> 6);
            }
          else
            {
              *--r = (char)u;
            }
        }
    }
  else if (sig == UCS2LE)
    {
      FSIZE buffered_words = buffered_chars / 2;
      unsigned short *q = (unsigned short *)p + buffered_words;
      buffered_chars += buffered_words;
      r = p + buffered_chars;
      while (--q >= (unsigned short *)u0) // exclude the BOM
        {
          unsigned short u = *q;
          if (u >= 0x800)
            {
              *--r = 0x80 + (u & 0x3F);
              *--r = 0x80 + ((u >> 6) & 0x3F);
              *--r = 0xE0 + (u >> 12);
            }
          else if (u >= 0x80 || u == 0) // map NUL to 2 byte sequence so as to prevent it from confusing diff algorithm
            {
              *--r = 0x80 + (u & 0x3F);
              *--r = 0xC0 + (u >> 6);
            }
          else
            {
              *--r = (char)u;
            }
        }
    }
  else if (sig == UCS2BE)
    {
      FSIZE buffered_words = buffered_chars / 2;
      unsigned short *q = (unsigned short *)p + buffered_words;
      buffered_chars += buffered_words;
      r = p + buffered_chars;
      while (--q >= (unsigned short *)u0) // exclude the BOM
        {
          unsigned short u = (*q << 8) | (*q >> 8); // fix byte order
          if (u >= 0x800)
            {
              *--r = 0x80 + (u & 0x3F);
              *--r = 0x80 + ((u >> 6) & 0x3F);
              *--r = 0xE0 + (u >> 12);
            }
          else if (u >= 0x80 || u == 0) // map NUL to 2 byte sequence so as to prevent it from confusing diff algorithm
            {
              *--r = 0x80 + (u & 0x3F);
              *--r = 0xC0 + (u >> 6);
            }
          else
            {
              *--r = (char)u;
            }
        }
    }
  else if (sig == UTF8)
    {
      r = u0; // skip the BOM
    }

  if (buffered_chars - bomsize == 0 || p[buffered_chars - 1] == '\n' || p[buffered_chars - 1] == '\r')
    current->missing_newline = 0;
  else
    {
      p[buffered_chars++] = '\n';
      current->missing_newline = 1;
      --current->count_lfs; // compensate for extra newline
    }

	current->buffered_chars = buffered_chars;

	/* Count line endings and map them to '\n' if ignore_eol_diff is set. */
	t = q0 = p + buffered_chars;
	while (q0 > r)
	{
		switch (*--t = *--q0)
		{
		case '\r':
			++current->count_crs;
			if (ignore_eol_diff)
				*t = '\n';
			break;
		case '\n':
			if (q0 > r && q0[-1] == '\r')
			{
				++current->count_crlfs;
				--current->count_crs; // compensate for bogus increment
				if (ignore_eol_diff)
					++t;
			}
			else
			{
				++current->count_lfs;
			}
			break;
		case '\0':
			++current->count_zeros;
			break;
		}
	}

  /* Don't use uninitialized storage when planting or using sentinels.  */
  bzero (p + buffered_chars, sizeof (word));
  return t;
}
# pragma warning(pop)           // Restores the warning state.

/* Given a vector of two file_data objects, find the identical
   prefixes and suffixes of each object. */

static void
find_identical_ends (struct file_data filevec[])
{
  word HUGE *w0, HUGE *w1;
  char HUGE *p0, HUGE *p1, HUGE *buffer0, HUGE *buffer1;
  char const HUGE *end0, HUGE *beg0;
  char const HUGE **linbuf0, HUGE **linbuf1;
  int i, lines;
  FSIZE n0, n1;
  FSIZE tem;
  FSIZE alloc_lines0, alloc_lines1;
  int buffered_prefix, prefix_count, prefix_mask;
  int ttt;

  if (filevec[0].desc != filevec[1].desc)
    {
      slurp (&filevec[0]);
      buffer0 = prepare_text_end (&filevec[0], 0);
      slurp (&filevec[1]);
      buffer1 = prepare_text_end (&filevec[1], 1);
    }
  else
    {
      slurp (&filevec[0]);
      buffer0 = prepare_text_end (&filevec[0], -1);
      filevec[1].buffer = filevec[0].buffer;
      filevec[1].bufsize = filevec[0].bufsize;
      filevec[1].buffered_chars = filevec[0].buffered_chars;
      buffer1 = buffer0;
    }

  /* Find identical prefix.  */

  p0 = buffer0;
  p1 = buffer1;

  n0 = filevec[0].buffered_chars - (buffer0 - filevec[0].buffer);
  n1 = filevec[1].buffered_chars - (buffer1 - filevec[1].buffer);

  if (p0 == p1)
    /* The buffers are the same; sentinels won't work.  */
    p0 = p1 += n1;
  else
    {
      /* Insert end sentinels, in this case characters that are guaranteed
         to make the equality test false, and thus terminate the loop.  */

      if (n0 < n1)
        p0[n0] = (char)(~p1[n0]);
      else
        p1[n1] = (char)(~p0[n1]);

      /* Loop until first mismatch, or to the sentinel characters.  */

      /* Compare a word at a time for speed.  */
      w0 = (word *) p0;
      w1 = (word *) p1;
      while (*w0++ == *w1++)
        ;
      --w0, --w1;

      /* Do the last few bytes of comparison a byte at a time.  */
      p0 = (char *) w0;
      p1 = (char *) w1;
      while (*p0++ == *p1++)
        ;
      --p0, --p1;

      /* Don't mistakenly count missing newline as part of prefix. */
      if (ROBUST_OUTPUT_STYLE (output_style)
        && (buffer0 + n0 - filevec[0].missing_newline < p0)
        !=
        (buffer1 + n1 - filevec[1].missing_newline < p1))
        --p0, --p1;
    }

  /* Now P0 and P1 point at the first nonmatching characters.  */

  /* Skip back to last line-beginning in the prefix,
     and then discard up to HORIZON_LINES lines from the prefix.  */
  i = horizon_lines;
  /* This loop can be done in one line, but isn't not easy to read, so unrolled into simple statements */
  while (p0 != buffer0)
    {
      /* we know p0[-1] == p1[-1], but maybe p0[0] != p1[0] */
      int linestart=0;
      if (p0[-1] == '\n')
        linestart=1;
      /* only count \r if not followed by a \n on either side */
      if (p0[-1] == '\r' && p0[0] != '\n' && p1[0] != '\n')
        linestart=1;
      if (linestart && !(i--))
        break;
    --p0, --p1;
    }

  /* Record the prefix.  */
  filevec[0].prefix_end = p0;
  filevec[1].prefix_end = p1;

  /* Find identical suffix.  */

  /* P0 and P1 point beyond the last chars not yet compared.  */
  p0 = buffer0 + n0;
  p1 = buffer1 + n1;

  if (! ROBUST_OUTPUT_STYLE (output_style)
      || filevec[0].missing_newline == filevec[1].missing_newline)
    {
      end0 = p0;  /* Addr of last char in file 0.  */

      /* Get value of P0 at which we should stop scanning backward:
         this is when either P0 or P1 points just past the last char
         of the identical prefix.  */
      beg0 = filevec[0].prefix_end + (n0 < n1 ? 0 : n0 - n1);

      /* Scan back until chars don't match or we reach that point.  */
      while (p0 != beg0)
        if (*--p0 != *--p1)
          {
            /* Point at the first char of the matching suffix.  */
            ++p0, ++p1;
            beg0 = p0;
            break;
          }

      /* Are we at a line-beginning in both files?  If not, add the rest of
         this line to the main body.  Discard up to HORIZON_LINES lines from
         the identical suffix.  Also, discard one extra line,
         because shift_boundaries may need it.  */
      i = horizon_lines + !((buffer0 == p0 || p0[-1] == '\n' || (p0[-1] == '\r' && p0[0] != '\n'))
          &&
          (buffer1 == p1 || p1[-1] == '\n' || (p1[-1] == '\r' && p1[0] != '\n')));
      while (i-- && p0 != end0)
        while (*p0++ != '\n' && (p0[-1] != '\r' || p0[0] == '\n'))
          ;

      p1 += p0 - (char HUGE *)beg0;
    }

  /* Record the suffix.  */
  filevec[0].suffix_begin = p0;
  filevec[1].suffix_begin = p1;

  /* Calculate number of lines of prefix to save.

     prefix_count == 0 means save the whole prefix;
     we need this with for options like -D that output the whole file.
     We also need it for options like -F that output some preceding line;
     at least we will need to find the last few lines,
     but since we don't know how many, it's easiest to find them all.

     Otherwise, prefix_count != 0.  Save just prefix_count lines at start
     of the line buffer; they'll be moved to the proper location later.
     Handle 1 more line than the context says (because we count 1 too many),
     rounded up to the next power of 2 to speed index computation.  */

  if (no_diff_means_no_output)
    {
      for (prefix_count = 1;  prefix_count < context + 1;  prefix_count *= 2)
        ;
      prefix_mask = prefix_count - 1;
	  assert((p0 - (char HUGE *)filevec[0].prefix_end) < INT_MAX);
      ttt = (int)(p0 - (char HUGE *)filevec[0].prefix_end);
      alloc_lines0
        = prefix_count
        + GUESS_LINES (0, 0, ttt)
        + context;
    }
  else
    {
      prefix_count = 0;
      prefix_mask = ~0;
      alloc_lines0 = GUESS_LINES (0, 0, n0);
    }

  lines = 0;
  linbuf0 = (char const HUGE **) xmalloc (alloc_lines0 * sizeof (*linbuf0));

  /* If the prefix is needed, find the prefix lines.  */
  if (! (no_diff_means_no_output
   && filevec[0].prefix_end == p0
   && filevec[1].prefix_end == p1))
    {
      p0 = buffer0;
      end0 = filevec[0].prefix_end;
      while (p0 != end0)
        {
          int l = lines++ & prefix_mask;
          if ((FSIZE)l == alloc_lines0)
            linbuf0 = (char const HUGE **) xrealloc ((void *)linbuf0, (alloc_lines0 *= 2)
               * sizeof(*linbuf0));
          linbuf0[l] = p0;
          /* Perry/WinMerge (2004-01-05) altered original diffutils loop "while (*p0++ != '\n') ;" for other EOLs */
          while (1)
            {
              char ch = *p0++;
              /* stop at any eol, \n or \r or \r\n */
              if (ch == '\n') break;
              if (ch == '\r' && (p0==end0 || *p0!='\n')) break;
            }
        }
    }
  buffered_prefix = prefix_count && context < lines ? context : lines;

  /* Allocate line buffer 1.  */
  tem = prefix_count ? filevec[1].suffix_begin - buffer1 : n1;
  ttt = (int)(filevec[1].prefix_end - buffer1);
  alloc_lines1
    = (buffered_prefix
       + GUESS_LINES (lines, ttt, tem)
       + context);
  linbuf1 = (char const HUGE **) xmalloc (alloc_lines1 * sizeof (*linbuf1));

  if (buffered_prefix != lines)
    {
      /* Rotate prefix lines to proper location.  */
      for (i = 0;  i < buffered_prefix;  i++)
        linbuf1[i] = linbuf0[(lines - context + i) & prefix_mask];
      for (i = 0;  i < buffered_prefix;  i++)
        linbuf0[i] = linbuf1[i];
    }

  /* Initialize line buffer 1 from line buffer 0.  */
  for (i = 0; i < buffered_prefix; i++)
    linbuf1[i] = linbuf0[i] - buffer0 + buffer1;

  /* Record the line buffer, adjusted so that
     linbuf*[0] points at the first differing line.  */
  filevec[0].linbuf = linbuf0 + buffered_prefix;
  filevec[1].linbuf = linbuf1 + buffered_prefix;
  filevec[0].linbuf_base = filevec[1].linbuf_base = - buffered_prefix;
  assert((alloc_lines0 - buffered_prefix) < INT_MAX);
  assert((alloc_lines1 - buffered_prefix) < INT_MAX);
  filevec[0].alloc_lines = (int)(alloc_lines0 - buffered_prefix);
  filevec[1].alloc_lines = (int)(alloc_lines1 - buffered_prefix);
  filevec[0].prefix_lines = filevec[1].prefix_lines = lines;
}

/* Largest primes less than some power of two, for nbuckets.  Values range
   from useful to preposterous.  If one of these numbers isn't prime
   after all, don't blame it on me, blame it on primes (6) . . . */
static int const primes[] =
{
  509,
  1021,
  2039,
  4093,
  8191,
  16381,
  32749,
#if 32767 < INT_MAX
  65521,
  131071,
  262139,
  524287,
  1048573,
  2097143,
  4194301,
  8388593,
  16777213,
  33554393,
  67108859,     /* Preposterously large . . . */
  134217689,
  268435399,
  536870909,
  1073741789,
  2147483647,
#endif
  0
};

static int isnulldev(const char* filename)
{
    return (_stricmp(filename, "NUL") == 0 || _stricmp(filename, "\\\\.\\NUL") == 0);
}

/* Given a vector of two file_data objects, read the file associated
   with each one, and build the table of equivalence classes.
   Return 1 if either file appears to be a binary file.
   If PRETEND_BINARY is nonzero, pretend they are binary regardless.  */
/* WinMerge: Add int * bin_file param for getting actual binary file
   If bin_file is given, then check both files for binary files,
   otherwise check second file only if first wasn't binary */
int
read_files (struct file_data filevec[], int pretend_binary, int *bin_file)
{
  int i;
  int skip_test = always_text_flag | pretend_binary;
  int appears_binary = 0;

  if (bin_file != NULL)
    *bin_file = 0;
  appears_binary = pretend_binary | sip (&filevec[0], skip_test);
  if (bin_file!=NULL && appears_binary)
    {
      *bin_file = 1;
    }

  if (filevec[0].desc != filevec[1].desc)
    {
      if (bin_file!=NULL)
        {
          appears_binary = pretend_binary | sip (&filevec[1], skip_test);
          if (appears_binary)
            *bin_file |= 0x2; // set second bit for second file
        }
      else
        appears_binary |= sip (&filevec[1], skip_test | appears_binary);
    }
	
	// Are both files Open and Regular (no Pipes, Directories, Devices (except NUL))
	if (filevec[0].desc < 0 || filevec[1].desc < 0 ||
        (!(S_ISREG (filevec[0].stat.st_mode)) && !isnulldev(filevec[0].name)) ||
		(!(S_ISREG (filevec[1].stat.st_mode)) && !isnulldev(filevec[1].name)))
      {
		assert(!S_ISCHR(filevec[0].stat.st_mode));
		assert(!S_ISCHR(filevec[1].stat.st_mode));
		return appears_binary;
      }

  if (appears_binary)
	{
		// Because of the way 3-way binary comparison works, both buffers need
		// to be exactly the same size.  It also makes sense if the buffers are
		// large enough to hold a large chunk of the file with each read(); 
		// within reason of course.  Note: if the buffers are too big, the 
		// multi-processor performance is degraded.
		
		// Note that one or both buffers already have some amount of data.

		const FSIZE tmax_reasonable = (1 << 19) -1;		// 2**19 bytes, about 524KB

		FSIZE tmax_bufsize = max ((size_t)filevec[0].stat.st_size, 
								  (size_t)filevec[1].stat.st_size);
		tmax_bufsize = min (tmax_bufsize, tmax_reasonable);
		
		FSIZE tmin_bufsize = max(filevec[0].buffered_chars, filevec[1].buffered_chars);
		tmax_bufsize = max (tmax_bufsize, tmin_bufsize);

		if (tmax_bufsize > filevec[0].bufsize)
		  {
			filevec[0].buffer = xrealloc (filevec[0].buffer, tmax_bufsize);
			filevec[0].bufsize = tmax_bufsize;
		  }
		if (filevec[0].desc != filevec[1].desc && tmax_bufsize > filevec[1].bufsize)
		  {
			filevec[1].buffer = xrealloc (filevec[1].buffer, tmax_bufsize);
			filevec[1].bufsize = tmax_bufsize;
		  }
	}
	  
  if (filevec[0].desc == filevec[1].desc)
	{
		// The files may be exactly the same file.  Give them the same buffer, etc.
		assert( filevec[1].buffer == NULL );

		filevec[1].buffer = filevec[0].buffer;
		filevec[1].bufsize = filevec[0].bufsize;
		filevec[1].buffered_chars = filevec[0].buffered_chars;
	}
	
  // Binary comparisons *must not* go past here;  line-break sentinel markers may 
  // be put into the buffers.  Since read_files() only gets called for filevec[0], 
  // this causes a false mis-compare of all binary files (because filevec[1] would 
  // never get these non-necessary changes).
  if (appears_binary)
		return 1;
		
  find_identical_ends (filevec);

  /* Don't slurp rest of file when comparing file to itself. */
  if (filevec[0].desc == filevec[1].desc)
    {
	  filevec[1].count_crs = filevec[0].count_crs;
	  filevec[1].count_lfs = filevec[0].count_lfs;
	  filevec[1].count_crlfs = filevec[0].count_crlfs;
	  filevec[1].count_zeros = filevec[0].count_zeros;
      return 0;
    }

  equivs_alloc = filevec[0].alloc_lines + filevec[1].alloc_lines + 1;
#ifdef __MSDOS__
  if ((equivs = (struct equivclass HUGE *) farmalloc ((long) equivs_alloc * sizeof(struct equivclass))) == NULL)
    fatal ("far memory exhausted");
#else
  equivs = (struct equivclass *) xmalloc (equivs_alloc * sizeof (struct equivclass));
#endif /*__MSDOS__*/
  /* Equivalence class 0 is permanently safe for lines that were not
     hashed.  Real equivalence classes start at 1. */
  equivs_index = 1;

  for (i = 0;  primes[i] < equivs_alloc / 3;  i++)
    if (! primes[i])
      abort ();
  nbuckets = primes[i];

  buckets = (int *) xmalloc (nbuckets * sizeof (*buckets));
  bzero (buckets, nbuckets * sizeof (*buckets));

  for (i = 0; i < 2; ++i)
    find_and_hash_each_line (&filevec[i]);

  filevec[0].equiv_max = filevec[1].equiv_max = equivs_index;

  free (equivs);
  free (buckets);

  return 0;
}
</file>

<file path="Winmerge-Src/Src/diffutils/src/mystat.cpp">
// my own _fstat() and _wstat() implementation for the bug https://connect.microsoft.com/VisualStudio/feedback/details/1600505/stat-not-working-on-windows-xp-using-v14-xp-platform-toolset-vs2015
#include "pch.h"
#include <sys/stat.h>
#include <io.h>
#include <cerrno>
#include <windows.h>

inline time_t filetime_to_time_t(const FILETIME& ft)
{
	if (ft.dwHighDateTime == 0 && ft.dwLowDateTime == 0)
		return 0;
	else
		return ((static_cast<time_t>(ft.dwHighDateTime) << 32) + ft.dwLowDateTime) / 10000000ULL - 11644473600ULL;
}

template<typename FileInfo>
inline void set_statbuf(const FileInfo& hfi, struct _stat64& buf)
{
	buf.st_size = (static_cast<__int64>(hfi.nFileSizeHigh) << 32) | hfi.nFileSizeLow;
	buf.st_atime = filetime_to_time_t(hfi.ftLastAccessTime);
	buf.st_mtime = filetime_to_time_t(hfi.ftLastWriteTime);
	buf.st_ctime = filetime_to_time_t(hfi.ftCreationTime);
	buf.st_mode = 
		((hfi.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? _S_IFDIR : _S_IFREG) |
		((hfi.dwFileAttributes & FILE_ATTRIBUTE_READONLY ) ? 
			 (_S_IREAD              | ( _S_IREAD              >> 3) | ( _S_IREAD              >> 6)) : 
			((_S_IREAD | _S_IWRITE) | ((_S_IREAD | _S_IWRITE) >> 3) | ((_S_IREAD | _S_IWRITE) >> 6)));
}

extern "C" int myfstat(int fd, struct _stat64 *buf)
{
	if (buf == nullptr)
	{
		errno = EINVAL;
		return -1;
	}
	HANDLE hFile = reinterpret_cast<HANDLE>(_get_osfhandle(fd));
	if (hFile == INVALID_HANDLE_VALUE)
	{
		errno = EBADF;
		return -1;
	}
	memset(buf, 0, sizeof(*buf));
	switch (GetFileType(hFile) & ~FILE_TYPE_REMOTE)
	{
	case FILE_TYPE_CHAR:
		buf->st_mode = _S_IFCHR;
		return 0;
	case FILE_TYPE_PIPE:
		buf->st_mode = _S_IFIFO;
		DWORD nBufferSize;
		if (PeekNamedPipe(hFile, nullptr, 0, nullptr, &nBufferSize, nullptr))
			buf->st_size = nBufferSize;
		return 0;
	case FILE_TYPE_DISK:
		BY_HANDLE_FILE_INFORMATION hfi;
		if (!GetFileInformationByHandle(hFile, &hfi))
		{
			errno = EBADF;
			return -1;
		}
		set_statbuf(hfi, *buf);
		return 0;
	default:
		errno = EBADF;
		return -1;
	}
}

extern "C" int mywstat(const wchar_t *filename, struct _stat64 *buf)
{
	if (buf == nullptr)
	{
		errno = EINVAL;
		return -1;
	}
	if (wcspbrk(filename, L"*?") != nullptr)
	{
		errno = ENOENT;
		return -1;
	}
	WIN32_FIND_DATAW ffd;
	HANDLE hFindFile = FindFirstFileW(filename, &ffd);
	if (hFindFile == INVALID_HANDLE_VALUE)
	{
		errno = ENOENT;
		return -1;
	}
	FindClose(hFindFile);
	memset(buf, 0, sizeof(*buf));
	set_statbuf(ffd, *buf);
	return 0;
}
</file>

<file path="Winmerge-Src/Src/diffutils/src/normal.c">
/* Normal-format output routines for GNU DIFF.
   Copyright (C) 1988, 1989, 1993 Free Software Foundation, Inc.

This file is part of GNU DIFF.

GNU DIFF is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GNU DIFF is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU DIFF; see the file COPYING.  If not, write to
the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */


#include "diff.h"

static void print_normal_hunk (struct change *);

/* Print the edit-script SCRIPT as a normal diff.
   INF points to an array of descriptions of the two files.  */

void
print_normal_script (struct change *script)
{
  print_script (script, find_change, print_normal_hunk);
}

/* Print a hunk of a normal diff.
   This is a contiguous portion of a complete edit script,
   describing changes in consecutive lines.  */

static void
print_normal_hunk (struct change *hunk)
{
  int first0, last0, first1, last1, deletes, inserts;
  register int i;
  //int trans_a, trans_b;
  //int trans_c, trans_d;

  /* Determine range of line numbers involved in each file.  */
  analyze_hunk (hunk, &first0, &last0, &first1, &last1, &deletes, &inserts, files);
  if (!deletes && !inserts)
    return;

  begin_output ();

  /* Print out the line number header for this hunk */
  print_number_range (',', &files[0], first0, last0);
  fprintf (outfile, "%c", change_letter (inserts, deletes));
  print_number_range (',', &files[1], first1, last1);
  fprintf (outfile, "\n");

  //translate_range (&files[0], first0, last0, &trans_a, &trans_b);
  //translate_range (&files[1], first1, last1, &trans_c, &trans_d);
  //printf("left=%d,%d   right=%d,%d\n", trans_a, trans_b, trans_c, trans_d);

  /* Print the lines that the first file has. */ 
  if (deletes)
    for (i = first0; i <= last0; i++)
      print_1_line ("<", &files[0].linbuf[i]);

  if (inserts && deletes)
    fprintf (outfile, "---\n");

  // Print the lines that the second file has.  
  if (inserts)
    for (i = first1; i <= last1; i++)
      print_1_line (">", &files[1].linbuf[i]);
}
</file>

<file path="Winmerge-Src/Src/diffutils/src/side.c">
/* sdiff-format output routines for GNU DIFF.
   Copyright (C) 1991, 1992, 1993 Free Software Foundation, Inc.

This file is part of GNU DIFF.

GNU DIFF is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY.  No author or distributor
accepts responsibility to anyone for the consequences of using it
or for whether it serves any particular purpose or works at all,
unless he says so in writing.  Refer to the GNU General Public
License for full details.

Everyone is granted permission to copy, modify and redistribute
GNU DIFF, but only under the conditions described in the
GNU General Public License.   A copy of this license is
supposed to have been given to you along with GNU DIFF so you
can know your rights and responsibilities.  It should be in a
file named COPYING.  Among other things, the copyright notice
and this notice must be preserved on all copies.  */


#include "diff.h"

static unsigned print_half_line (char const * const *, unsigned, unsigned);
static unsigned tab_from_to (unsigned, unsigned);
static void print_1sdiff_line (char const * const *, int, char const * const *);
static void print_sdiff_common_lines (int, int);
static void print_sdiff_hunk (struct change *);

/* Next line number to be printed in the two input files.  */
static DECL_TLS int next0, next1;

/* Print the edit-script SCRIPT as a sdiff style output.  */

void
print_sdiff_script (struct change *script)
{
  begin_output ();

  next0 = next1 = - files[0].prefix_lines;
  print_script (script, find_change, print_sdiff_hunk);

  print_sdiff_common_lines (files[0].valid_lines, files[1].valid_lines);
}

/* Tab from column FROM to column TO, where FROM <= TO.  Yield TO.  */

static unsigned
tab_from_to (unsigned from, unsigned to)
{
  FILE *out = outfile;
  unsigned tab;

  if (! tab_expand_flag)
    for (tab = from + TAB_WIDTH - from % TAB_WIDTH;  tab <= to;  tab += TAB_WIDTH)
      {
	putc ('\t', out);
	from = tab;
      }
  while (from++ < to)
    putc (' ', out);
  return to;
}

/*
 * Print the text for half an sdiff line.  This means truncate to width
 * observing tabs, and trim a trailing newline.  Returns the last column
 * written (not the number of chars).
 */
static unsigned
print_half_line (char const * const *line, unsigned indent, unsigned out_bound)
{
  FILE *out = outfile;
  register unsigned in_position = 0, out_position = 0;
  register char const
	HUGE *text_pointer = line[0],
	HUGE *text_limit = line[1];

  while (text_pointer < text_limit)
    {
      register unsigned char c = *text_pointer++;

      switch (c)
	{
	case '\t':
	  {
	    unsigned spaces = TAB_WIDTH - in_position % TAB_WIDTH;
	    if (in_position == out_position)
	      {
		unsigned tabstop = out_position + spaces;
		if (tab_expand_flag)
		  {
		    if (out_bound < tabstop)
		      tabstop = out_bound;
		    for (;  out_position < tabstop;  out_position++)
		      putc (' ', out);
		  }
		else
		  if (tabstop < out_bound)
		    {
		      out_position = tabstop;
		      putc (c, out);
		    }
	      }
	    in_position += spaces;
	  }
	  break;

	case '\r':
	  {
	    putc (c, out);
	    tab_from_to (0, indent);
	    in_position = out_position = 0;
	  }
	  break;

	case '\b':
	  if (in_position != 0 && --in_position < out_bound)
	    if (out_position <= in_position)
	      /* Add spaces to make up for suppressed tab past out_bound.  */
	      for (;  out_position < in_position;  out_position++)
		putc (' ', out);
	    else
	      {
		out_position = in_position;
		putc (c, out);
	      }
	  break;

	case '\f':
	case '\v':
	control_char:
	  if (in_position < out_bound)
	    putc (c, out);
	  break;

	default:
	  if (! isprint (c))
	    goto control_char;
	  /* falls through */
	case ' ':
	  if (in_position++ < out_bound)
	    {
	      out_position = in_position;
	      putc (c, out);
	    }
	  break;

	case '\n':
	  return out_position;
	}
    }

  return out_position;
}

/*
 * Print side by side lines with a separator in the middle.
 * 0 parameters are taken to indicate white space text.
 * Blank lines that can easily be caught are reduced to a single newline.
 */

static void
print_1sdiff_line (char const HUGE * const *left, int sep, char const HUGE * const *right)
{
  FILE *out = outfile;
  unsigned hw = sdiff_half_width, c2o = sdiff_column2_offset;
  unsigned col = 0;
  int put_newline = 0;
  
  if (left)
    {
      if (left[1][-1] == '\n')
	put_newline = 1;
      col = print_half_line (left, 0, hw);
    }

  if (sep != ' ')
    {
      col = tab_from_to (col, (hw + c2o - 1) / 2) + 1;
      if (sep == '|' && put_newline != (right[1][-1] == '\n'))
	sep = put_newline ? '/' : '\\';
      putc (sep, out);
    }

  if (right)
    {
      if (right[1][-1] == '\n')
	put_newline = 1;
      if (**right != '\n')
	{
	  col = tab_from_to (col, c2o);
	  print_half_line (right, col, hw);
	}
    }

  if (put_newline)
    putc ('\n', out);
}

/* Print lines common to both files in side-by-side format.  */
static void
print_sdiff_common_lines (int limit0, int limit1)
{
  int i0 = next0, i1 = next1;

  if (! sdiff_skip_common_lines  &&  (i0 != limit0 || i1 != limit1))
    {
      if (sdiff_help_sdiff)
	fprintf (outfile, "i%d,%d\n", limit0 - i0, limit1 - i1);

      if (! sdiff_left_only)
	{
	  while (i0 != limit0 && i1 != limit1)
	    print_1sdiff_line (&files[0].linbuf[i0++], ' ', &files[1].linbuf[i1++]);
	  while (i1 != limit1)
	    print_1sdiff_line (0, ')', &files[1].linbuf[i1++]);
	}
      while (i0 != limit0)
	print_1sdiff_line (&files[0].linbuf[i0++], '(', 0);
    }

  next0 = limit0;
  next1 = limit1;
}

/* Print a hunk of an sdiff diff.
   This is a contiguous portion of a complete edit script,
   describing changes in consecutive lines.  */

static void
print_sdiff_hunk (struct change *hunk)
{
  int first0, last0, first1, last1, deletes, inserts;
  register int i, j;

  /* Determine range of line numbers involved in each file.  */
  analyze_hunk (hunk, &first0, &last0, &first1, &last1, &deletes, &inserts, files);
  if (!deletes && !inserts)
    return;

  /* Print out lines up to this change.  */
  print_sdiff_common_lines (first0, first1);

  if (sdiff_help_sdiff)
    fprintf (outfile, "c%d,%d\n", last0 - first0 + 1, last1 - first1 + 1);

  /* Print ``xxx  |  xxx '' lines */
  if (inserts && deletes)
    {
      for (i = first0, j = first1;  i <= last0 && j <= last1; ++i, ++j)
	print_1sdiff_line (&files[0].linbuf[i], '|', &files[1].linbuf[j]);
      deletes = i <= last0;
      inserts = j <= last1;
      next0 = first0 = i;
      next1 = first1 = j;
    }


  /* Print ``     >  xxx '' lines */
  if (inserts)
    {
      for (j = first1; j <= last1; ++j)
	print_1sdiff_line (0, '>', &files[1].linbuf[j]);
      next1 = j;
    }

  /* Print ``xxx  <     '' lines */
  if (deletes)
    {
      for (i = first0; i <= last0; ++i)
	print_1sdiff_line (&files[0].linbuf[i], '<', 0);
      next0 = i;
    }
}
</file>

<file path="Winmerge-Src/Src/diffutils/src/system.h">
/* System dependent declarations.
   Copyright (C) 1988, 1989, 1992, 1993 Free Software Foundation, Inc.

This file is part of GNU DIFF.

GNU DIFF is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GNU DIFF is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU DIFF; see the file COPYING.  If not, write to
the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */

#pragma once

/* We must define `volatile' and `const' first (the latter inside config.h),
   so that they're used consistently in all system includes.  */
#if !defined(__STDC__) && !defined(_MSC_VER)
#ifndef volatile
#define volatile
#endif
#endif
#include <config.h>

#include <sys/types.h>
#include <sys/stat.h>

#if STAT_MACROS_BROKEN
#undef S_ISBLK
#undef S_ISCHR
#undef S_ISDIR
#undef S_ISFIFO
#undef S_ISREG
#undef S_ISSOCK
#endif
#ifndef S_ISDIR
#define S_ISDIR(mode) (((mode) & S_IFMT) == S_IFDIR)
#endif
#ifndef S_ISREG
#define S_ISREG(mode) (((mode) & S_IFMT) == S_IFREG)
#endif
#if !defined(S_ISBLK) && defined(S_IFBLK)
#define S_ISBLK(mode) (((mode) & S_IFMT) == S_IFBLK)
#endif
#if !defined(S_ISCHR) && defined(S_IFCHR)
#define S_ISCHR(mode) (((mode) & S_IFMT) == S_IFCHR)
#endif
#if !defined(S_ISFIFO) && defined(S_IFFIFO)
#define S_ISFIFO(mode) (((mode) & S_IFMT) == S_IFFIFO)
#endif
#if !defined(S_ISSOCK) && defined(S_IFSOCK)
#define S_ISSOCK(mode) (((mode) & S_IFMT) == S_IFSOCK)
#endif

#ifndef S_IXOTH
#define S_IXOTH 1
#endif
#ifndef S_IXGRP
#define S_IXGRP (S_IXOTH << 3)
#endif
#ifndef S_IXUSR
#define S_IXUSR (S_IXGRP << 3)
#endif

#if HAVE_UNISTD_H
#include <unistd.h>
#endif

#ifndef SEEK_SET
#define SEEK_SET 0
#endif
#ifndef SEEK_CUR
#define SEEK_CUR 1
#endif

#ifndef STDIN_FILENO
#define STDIN_FILENO 0
#endif
#ifndef STDOUT_FILENO
#define STDOUT_FILENO 1
#endif
#ifndef STDERR_FILENO
#define STDERR_FILENO 2
#endif

#if HAVE_TIME_H
#include <time.h>
#else
#include <sys/time.h>
#endif

#if HAVE_FCNTL_H
#include <fcntl.h>
#else
#include <sys/file.h>
#endif

#if !HAVE_DUP2
#define dup2(f,t)	(close (t),  fcntl (f,F_DUPFD,t))
#endif

#ifndef O_RDONLY
#define O_RDONLY 0
#endif

#if HAVE_SYS_WAIT_H
#ifndef _POSIX_VERSION
/* Prevent the NeXT prototype using union wait from causing problems.  */
#define wait system_wait
#endif
#include <sys/wait.h>
#ifndef _POSIX_VERSION
#undef wait
#endif
#endif /* HAVE_SYS_WAIT_H */

#ifndef WEXITSTATUS
#define WEXITSTATUS(stat_val) ((unsigned)(stat_val) >> 8)
#undef WIFEXITED		/* Avoid 4.3BSD incompatibility with Posix.  */
#endif
#ifndef WIFEXITED
#define WIFEXITED(stat_val) (((stat_val) & 255) == 0)
#endif

#if HAVE_ST_BLKSIZE
#define STAT_BLOCKSIZE(s) (s).st_blksize
#else
#define STAT_BLOCKSIZE(s) (8 * 1024)
#endif

#if HAVE_VFORK_H
#include <vfork.h>
#endif

#if HAVE_STDLIB_H
#include <stdlib.h>
#else
void *malloc ();
void *realloc ();
#endif
//#ifndef getenv
//extern char *getenv ();
//#endif

#if HAVE_LIMITS_H
#include <limits.h>
#endif
#ifndef INT_MAX
#define INT_MAX 2147483647
#endif
#ifndef CHAR_BIT
#define CHAR_BIT 8
#endif

#if HAVE_STRING_H
#include <string.h>
#ifndef bzero
#define bzero(s,n) memset (s,0,n)
#endif
#else /* !HAVE_STRING_H */
#include <strings.h>
#ifndef strchr
#define strchr index
#endif
#ifndef strrchr
#define strrchr rindex
#endif
#ifndef memcpy
#define memcpy(d,s,n) bcopy (s,d,n)
#endif
#ifndef memcmp
#define memcmp(s1,s2,n) bcmp (s1,s2,n)
#endif
#endif /* !HAVE_STRING_H */
#if !HAVE_MEMCHR
char *memchr ();
#endif

#include <errno.h>
#if !STDC_HEADERS
extern int errno;
#endif

#ifndef min
#define min(a,b) ((a) <= (b) ? (a) : (b))
#define max(a,b) ((a) >= (b) ? (a) : (b))
#endif

#ifdef __MSDOS__
typedef int pid_t;
typedef long off_t;
#include <stdio.h>
#include <malloc.h>
FILE *popen(char *, char *);
int pclose(FILE *);
#define HUGE huge
#define FSIZE long
#else
#define HUGE
#define FSIZE size_t
#endif

#if defined(__NT__) || defined(WIN32)
#ifndef _PID_T_
typedef int pid_t;
#endif
#define popen	_popen
#define pclose	_pclose
#endif
</file>

<file path="Winmerge-Src/Src/diffutils/src/util.c">
/* Support routines for GNU DIFF.
   Copyright (C) 1988, 1989, 1992, 1993 Free Software Foundation, Inc.

This file is part of GNU DIFF.

GNU DIFF is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GNU DIFF is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU DIFF; see the file COPYING.  If not, write to
the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */

#include <windows.h>
#include "diff.h"

/* Queue up one-line messages to be printed at the end,
   when -l is specified.  Each message is recorded with a `struct msg'.  */

struct msg
{
  struct msg *next;
  char const *format;
  char const *arg1;
  char const *arg2;
  char const *arg3;
  char const *arg4;
};

/* Head of the chain of queues messages.  */

static struct msg *msg_chain;

/* Tail of the chain of queues messages.  */

static struct msg **msg_chain_end = &msg_chain;

/* Use when a system call returns non-zero status.
   TEXT should normally be the file name.  */

void
perror_with_name (char const *text)
{
  int e = errno;
  fprintf (stderr, "%s: ", program);
  errno = e;
  perror (text);
}

/* Use when a system call returns non-zero status and that is fatal.  */

void
pfatal_with_name (char const *text)
{
  int e = errno;
  print_message_queue ();
  fprintf (stderr, "%s: ", program);
  errno = e;
  perror (text);
  //exit (2);
  RaiseException(STATUS_ACCESS_VIOLATION, 0, 0, NULL);
}

/* Print an error message from the format-string FORMAT
   with args ARG1 and ARG2.  */

void
error (char const *format, char const *arg, char const *arg1)
{
  fprintf (stderr, "%s: ", program);
  fprintf (stderr, format, arg, arg1);
  fprintf (stderr, "\n");
}

/* Print an error message containing the string TEXT, then exit.  */

void
fatal (char const *m)
{
  print_message_queue ();
  error ("%s", m, 0);
  //exit (2);
  RaiseException(STATUS_ACCESS_VIOLATION, 0, 0, NULL);
}

/* Like printf, except if -l in effect then save the message and print later.
   This is used for things like "binary files differ" and "Only in ...".  */

void
message (char const *format, char const *arg1, char const *arg2)
{
  message5 (format, arg1, arg2, 0, 0);
}

void
message5 (char const *format, char const *arg1, char const *arg2, char const *arg3, char const *arg4)
{
  if (paginate_flag)
    {
      struct msg *new = (struct msg *) xmalloc (sizeof (struct msg));
      new->format = format;
      new->arg1 = concat (arg1, "", "");
      new->arg2 = concat (arg2, "", "");
      new->arg3 = arg3 ? concat (arg3, "", "") : 0;
      new->arg4 = arg4 ? concat (arg4, "", "") : 0;
      new->next = NULL;
      *msg_chain_end = new;
      msg_chain_end = &new->next;
    }
  else
    {
      if (sdiff_help_sdiff)
	putchar (' ');
      printf (format, arg1, arg2, arg3, arg4);
    }
}

/* Output all the messages that were saved up by calls to `message'.  */

void
print_message_queue ()
{
  struct msg *m;

  for (m = msg_chain; m; m = m->next)
    printf (m->format, m->arg1, m->arg2, m->arg3, m->arg4);
}

/* Call before outputting the results of comparing files NAME0 and NAME1
   to set up OUTFILE, the stdio stream for the output to go to.

   Usually, OUTFILE is just stdout.  But when -l was specified
   we fork off a `pr' and make OUTFILE a pipe to it.
   `pr' then outputs to our stdout.  */

static char const *current_name0;
static char const *current_name1;
static int current_depth;

void
setup_output (char const *name0, char const *name1, int depth)
{
  current_name0 = name0;
  current_name1 = name1;
  current_depth = depth;
  outfile = NULL;
}

static pid_t pr_pid;

void
begin_output ()
{
  char *name;

  if (outfile != NULL)
    return;

  char *mySwitch = (switch_string != NULL ? switch_string : "");

  /* Construct the header of this piece of diff.  */
  const size_t nameSiz = strlen(current_name0) + strlen(current_name1)
	  + strlen(mySwitch) + 7;
  name = xmalloc (nameSiz);
  /* Posix.2 section 4.17.6.1.1 specifies this format.  But there are some
     bugs in the first printing (IEEE Std 1003.2-1992 p 251 l 3304):
     it says that we must print only the last component of the pathnames,
     and it requires two spaces after "diff" if there are no options.
     These requirements are silly and do not match historical practice.  */
  sprintf_s (name, nameSiz, "diff%s %s %s", mySwitch, current_name0, current_name1);

  if (paginate_flag)
    {
#if defined(__MSDOS__) || defined(__NT__) || defined(WIN32)
      char command[120];

      sprintf_s(command, sizeof(command), "%s -f -h \"%s\"", PR_FILE_NAME, name);
      if ((outfile = popen(command, "w")) == NULL)
        pfatal_with_name ("popen");
#else
      int pipes[2];

      /* Fork a `pr' and make OUTFILE a pipe to it.  */
      if (pipe (pipes) < 0)
	pfatal_with_name ("pipe");

      fflush (stdout);

      pr_pid = vfork ();
      if (pr_pid < 0)
	pfatal_with_name ("vfork");

      if (pr_pid == 0)
	{
	  close (pipes[1]);
	  if (pipes[0] != STDIN_FILENO)
	    {
	      if (dup2 (pipes[0], STDIN_FILENO) < 0)
		pfatal_with_name ("dup2");
	      close (pipes[0]);
	    }

	  execl (PR_FILE_NAME, PR_FILE_NAME, "-f", "-h", name, 0);
	  pfatal_with_name (PR_FILE_NAME);
	}
      else
	{
	  close (pipes[0]);
	  outfile = fdopen (pipes[1], "w");
	}
#endif /*__MSDOS__||__NT__*/
    }
  else
    {

      /* If -l was not specified, output the diff straight to `stdout'.  */

      outfile = stdout;

      /* If handling multiple files (because scanning a directory),
	 print which files the following output is about.  */
      if (current_depth > 0)
	printf ("%s\n", name);
    }

  free (name);

  /* A special header is needed at the beginning of context output.  */
  switch (output_style)
    {
    case OUTPUT_CONTEXT:
      print_context_header (files, 0);
      break;

    case OUTPUT_UNIFIED:
      print_context_header (files, 1);
      break;

    default:
      break;
    }
}

/* Call after the end of output of diffs for one file.
   Close OUTFILE and get rid of the `pr' subfork.  */

void
finish_output ()
{
  if (outfile != NULL && outfile != stdout)
    {
#if defined(__MSDOS__) || defined(__NT__) || defined(WIN32)
      if (pclose (outfile))
	pfatal_with_name ("write error");
#else
      int wstatus;
      if (ferror (outfile))
	fatal ("write error");
      if (fclose (outfile) != 0)
	pfatal_with_name ("write error");
#if HAVE_WAITPID
      if (waitpid (pr_pid, &wstatus, 0) < 0)
	pfatal_with_name ("waitpid");
#else
      for (;;) {
	pid_t w = wait (&wstatus);
	if (w < 0)
	  pfatal_with_name ("wait");
	if (w == pr_pid)
	  break;
      }
#endif
      if (! WIFEXITED (wstatus) || WEXITSTATUS (wstatus) != 0)
	fatal ("subsidiary pr failed");
#endif /*__MSDOS__||__NT__*/
    }

  outfile = NULL;
}


static int
ISWSPACE (char ch)
{
	return ch==' ' || ch=='\t';
}

/* Compare two lines (typically one from each input file)
   according to the command line options.
   Return 1 if the lines differ, like `memcmp'.  */

int
line_cmp (char const *s1, size_t len1, char const *s2, size_t len2)
{
  register unsigned char const *t1, *t2;
  register unsigned char end_char = line_end_char;

  /* Check first for exact identity.
     If that is true, return 0 immediately.
     This detects the common case of exact identity
     faster than complete comparison would.  */

  if (len1 == len2 && memcmp (s1, s2, len1) == 0)
    return 0;

  /* Not exactly identical, but perhaps they match anyway
     when case or white space is ignored.  */
  /* c1 is the current character value for the line s1, it is set to 0
     when the line has been entirely scanned.
     c2 is the equivalent of c1 for the line s2 */

  if (ignore_case_flag | ignore_space_change_flag | ignore_all_space_flag | ignore_eol_diff | ignore_numbers_flag)
    {
      t1 = (unsigned char const *) s1;
      t2 = (unsigned char const *) s2;

      while (1)
	{
	  register unsigned char c1;
	  register unsigned char c2;
	  if (t1-(unsigned char *)s1<(int)len1)
	    c1 = *t1++;
	  else
	    c1 = 0;
	  if (t2-(unsigned char *)s2<(int)len2)
	    c2 = *t2++;
	  else
	    c2 = 0;

      /* Test for exact char equality first, since it's a common case.  */
      if (c1 != c2)
	{
	  /* Ignore horizontal white space if -b or -w is specified.  */

	  if (ignore_all_space_flag)
	    {
	      /* For -w, just skip past any white space.  */
	      while (ISWSPACE (c1))
		{
		  if (t1-(unsigned char *)s1<(int)len1)
		    {
		      c1 = *t1++;
		    }
		  else
		    {
		      c1 = 0;
		      break;
		    }
		}
	      while (ISWSPACE (c2))
		{
		  if (t2-(unsigned char *)s2<(int)len2)
		    {
		      c2 = *t2++;
		    }
		  else
		    {
		      c2 = 0;
		      break;
		    }
		}
	    }
	  else if (ignore_space_change_flag)
	    {
	      /* For -b, advance past any sequence of white space in line 1
		 and consider it just one Space, or nothing at all
		 if it is at the end of the line.  */
	      if (ISWSPACE (c1))
		{
		  /* Any whitespace sequence counts as one space */
		  c1 = ' ';
		  /* Skip to end of whitespace sequence */
		  while (t1-(unsigned char *)s1<(int)len1 && ISWSPACE(*t1))
		    ++t1;
		  /* if c1 is whitespace and c2 is end of line
		  we must advance c1 to next char, because c1
		  whitespace matches the nothing in c2 */
		  if (c2=='\r' || c2=='\n')
		    {
		      if (t1-(unsigned char *)s1<(int)len1)
			c1 = *t1++;
		      else
			c1 = 0;
		    }
		}

	      /* Likewise for line 2.  */
	      if (ISWSPACE (c2))
		{
		  /* Any whitespace sequence counts as one space */
		  c2 = ' ';
		  /* Skip to end of whitespace sequence */
		  while (t2-(unsigned char *)s2<(int)len2 && ISWSPACE(*t2))
		    ++t2;
		  /* if c2 is whitespace and c1 is end of line
		  we must advance c1 to next char, because c2
		  whitespace matches the nothing in c1 */
		  if (c1=='\r' || c1=='\n')
		    {
		      if (t2-(unsigned char *)s2<(int)len2)
			c2 = *t2++;
		      else
			c2 = 0;
		    }
		}

	      /*
	      Whitespace at end of line matches end of file
	      make them both say ' ' so they match, and the one
	      not at end will get advanced
	      */
	      if (c1 != c2)
	        {
		  if (c1==' ' && !c2)
		    c2 = ' ';
		  else if (c2==' ' && !c1)
		    c1 = ' ';
	        }

	      if (c1 != c2)
		{
		  /* backtracking necessary when matching "cat and" against "cat  and"
		     because the spaces got matched with equality, so now "a" and " "
		     are mismatches */

		  /* If we went too far when doing the simple test
		     for equality, go back to the first non-white-space
		     character in both sides and try again.  */
		  if (c2 == ' ' && c1 && c1 != '\n' && c1 != '\r'
		      && (unsigned char const *) s1 + 1 < t1
		      && isspace(t1[-2]))
		    {
		      --t1;
		      continue;
		    }
		  if (c1 == ' ' && c2 && c2 != '\n' && c2 != '\r'
		      && (unsigned char const *) s2 + 1 < t2
		      && isspace(t2[-2]))
		    {
		      --t2;
		      continue;
		    }
		}
	    }

		if (ignore_numbers_flag)
		{
			/* For ..., just skip past any numbers.  */
			while (isdigit(c1))
			{
				if (t1 - (unsigned char*)s1 < (int)len1)
				{
					c1 = *t1++;
				}
				else
				{
					c1 = 0;
					break;
				}
			}
			while (isdigit(c2))
			{
				if (t2 - (unsigned char*)s2 < (int)len2)
				{
					c2 = *t2++;
				}
				else
				{
					c2 = 0;
					break;
				}
			}
		}

	  /* Upcase all letters if -i is specified.  */

	  if (ignore_case_flag)
	    {
	      if (isupper (c1))
	        c1 = (unsigned char)tolower (c1);
	      if (isupper(c2))
	        c2 = (unsigned char)tolower (c2);
	    }

	  if (ignore_eol_diff)
	    {
	      if (c1 == '\r')
		c1 = 0;
	      else if (c2 == '\r')
		c2 = 0;
	    }

	  if (c1 != c2)
	    break;
	  }

	  /* If we got here, c1 == c2 */

	  if (!c1)
	    return 0;
	}
    }

  return 1;
}

/* Find the consecutive changes at the start of the script START.
   Return the last link before the first gap.  */

struct change *
find_change (struct change *start)
{
  return start;
}

struct change *
find_reverse_change (struct change *start)
{
  return start;
}

/* Divide SCRIPT into pieces by calling HUNKFUN and
   print each piece with PRINTFUN.
   Both functions take one arg, an edit script.

   HUNKFUN is called with the tail of the script
   and returns the last link that belongs together with the start
   of the tail.

   PRINTFUN takes a subscript which belongs together (with a null
   link at the end) and prints it.  */

void
print_script (struct change *script, 
				struct change *(*hunkfun) (struct change *), 
				void (*printfun) (struct change *) )
{
  struct change *next = script;

  while (next)
    {
      struct change *this, *end;

      /* Find a set of changes that belong together.  */
      this = next;
      end = (*hunkfun) (next);

      /* Disconnect them from the rest of the changes,
	 making them a hunk, and remember the rest for next iteration.  */
      next = end->link;
      end->link = NULL;
#ifdef DEBUG
      debug_script (this);
#endif

      /* Print this hunk.  */
      (*printfun) (this);

      /* Reconnect the script so it will all be freed properly.  */
      end->link = next;
    }
}

/* Print the text of a single line LINE,
   flagging it with the characters in LINE_FLAG (which say whether
   the line is inserted, deleted, changed, etc.).  */

void
print_1_line (char const *line_flag, char const * const *line)
{
  char const HUGE *text = line[0], HUGE *limit = line[1]; /* Help the compiler.  */
  FILE *out = outfile; /* Help the compiler some more.  */
  char const *flag_format = NULL;

  /* If -T was specified, use a Tab between the line-flag and the text.
     Otherwise use a Space (as Unix diff does).
     Print neither space nor tab if line-flags are empty.  */

  if (line_flag != NULL && *line_flag != 0)
    {
      flag_format = tab_align_flag ? "%s\t" : "%s ";
      fprintf (out, flag_format, line_flag);
    }

  output_1_line (text, limit, flag_format, line_flag);

  if ((line_flag == NULL || line_flag[0]) && limit[-1] != '\n' && limit[-1] != '\r'
      && line_end_char == '\n')
    fprintf (out, "\n\\ No newline at end of file\n");
}

/*
A version of fwrite which converts any embedded \r or \n or \r\n to \n
before passing it to fwrite. This is meant to be used with mixed eol mode input
being written to a text mode stream.
*/
static size_t
fwrite_textify( const void *buffer, size_t size, size_t count, FILE *stream )
{
	/*
	\r = carriage return
	\n = line feed
	We have to handle the carriage returns (\r) specially
	because some of them may be the first half of a \r\n pair
	We output \r\n for any solo \r or solo \n, but also for any \r\n pair
	so the tricky part is just avoiding outputing \r\n\r\n for the \r\n pair.
	*/

	size_t bytes=0;
	unsigned int i;
	const char * text = buffer;
	int cr = 0;
	char ch;
	i = 0;
	while (1)
	{
		// first handle any pending carriage returns
		// before even checking if we've finished file
		if (cr)
		{
			// currently handling a carriage return
			// we always finish the line for carriage returns
			bytes += fwrite("\n", 1, 1, stream);
			if (i==size*count)
			{
				// we're done
				return bytes;
			}
			// now check to see if we need to swallow the trailing line feed
			// of a carriage return/line feed pair (\r\n)
			if (text[i] == '\n')
				++i;
			// finished the pending carriage return
			cr = 0;
		}
		// check if we finished
		if (i==size*count)
			return bytes;
		ch = text[i];
		// first check if new character is a carriage return
		if (ch == '\r')
		{
			// activate our special mode flag, and go to next character
			cr = 1;
			++i;
			continue;
		}
		// (any bare \n characters are ok, stream will convert them)
		bytes += fwrite(&text[i], 1, 1, stream);
		++i;
	}
}


/* Output a line from TEXT up to LIMIT.  Without -t, output verbatim.
   With -t, expand white space characters to spaces, and if FLAG_FORMAT
   is nonzero, output it with argument LINE_FLAG after every
   internal carriage return, so that tab stops continue to line up.  */

void
output_1_line (char const *text, char const *limit, char const *flag_format, char const *line_flag)
{
  char * pos = NULL;
  if (!tab_expand_flag)
    fwrite_textify (text, sizeof (char), limit - text, outfile);
  else
    {
      register FILE *out = outfile;
      register unsigned char c;
      register char const HUGE *t = text;
      register unsigned column = 0;

      while (t < limit)
	switch ((c = *t++))
	  {
	  case '\t':
	    {
	      unsigned spaces = TAB_WIDTH - column % TAB_WIDTH;
	      column += spaces;
	      do
		putc (' ', out);
	      while (--spaces);
	    }
	    break;

	  case '\r':
	    putc (c, out);
	    if (flag_format && t < limit && *t != '\n')
	      fprintf (out, flag_format, line_flag);
	    column = 0;
	    break;

	  case '\b':
	    if (column == 0)
	      continue;
	    column--;
	    putc (c, out);
	    break;

	  default:
	    if (isprint (c))
	      column++;
	    putc (c, out);
	    break;
	  }
    }
}

int
change_letter (int inserts, int deletes)
{
  if (!inserts)
    return 'd';
  else if (!deletes)
    return 'a';
  else
    return 'c';
}

/* Translate an internal line number (an index into diff's table of lines)
   into an actual line number in the input file.
   The internal line number is LNUM.  FILE points to the data on the file.

   Internal line numbers count from 0 starting after the prefix.
   Actual line numbers count from 1 within the entire file.  */

int
translate_line_number (struct file_data const *file, int lnum)
{
  return lnum + file->prefix_lines + 1;
}

void
translate_range (struct file_data const *file, int a, int b, int *aptr, int *bptr)
{
  *aptr = translate_line_number (file, a - 1) + 1;
  *bptr = translate_line_number (file, b + 1) - 1;
}

/* Print a pair of line numbers with SEPCHAR, translated for file FILE.
   If the two numbers are identical, print just one number.

   Args A and B are internal line numbers.
   We print the translated (real) line numbers.  */

void
print_number_range (int sepchar, struct file_data *file, int a, int b)
{
  int trans_a, trans_b;
  translate_range (file, a, b, &trans_a, &trans_b);

  /* Note: we can have B < A in the case of a range of no lines.
     In this case, we should print the line number before the range,
     which is B.  */
  if (trans_b > trans_a)
    fprintf (outfile, "%d%c%d", trans_a, sepchar, trans_b);
  else
    fprintf (outfile, "%d", trans_b);
}

int iseolch (char ch)
{
  return ch=='\n' || ch=='\r';
}

int is_blank_line (char const *pch, char const *limit)
{
  while (pch < limit)
    {
      if ((*pch) == '\n' || (*pch) == '\r')
        break;
      if ((*pch) != ' ' && (*pch) != '\t')
        return 0;
      pch++;
    }
  return 1;
}

/* Look at a hunk of edit script and report the range of lines in each file
   that it applies to.  HUNK is the start of the hunk, which is a chain
   of `struct change'.  The first and last line numbers of file 0 are stored in
   *FIRST0 and *LAST0, and likewise for file 1 in *FIRST1 and *LAST1.
   Note that these are internal line numbers that count from 0.

   If no lines from file 0 are deleted, then FIRST0 is LAST0+1.

   Also set *DELETES nonzero if any lines of file 0 are deleted
   and set *INSERTS nonzero if any lines of file 1 are inserted.
   If only ignorable lines are inserted or deleted, both are
   set to 0.  */

void
analyze_hunk (struct change *hunk, 
    int *first0, int *last0, 
    int *first1, int *last1, 
    int *deletes, int *inserts, const struct file_data fd[])
{
  int l0, l1, show_from, show_to;
  int i;
  int trivial = ignore_blank_lines_flag;
  struct change *next;

  show_from = show_to = 0;

  *first0 = hunk->line0;
  *first1 = hunk->line1;

  next = hunk;
  do
    {
      l0 = next->line0 + next->deleted - 1;
      l1 = next->line1 + next->inserted - 1;
      show_from += next->deleted;
      show_to += next->inserted;

      for (i = next->line0; i <= l0 && trivial; i++)
        {
          if (!ignore_blank_lines_flag)
            {
              trivial = 0;
            }
          else if (ignore_all_space_flag | ignore_space_change_flag)
            {
              if (!is_blank_line(fd[0].linbuf[i], fd[0].linbuf[i + 1]))
                trivial = 0;
            }
          else if (!iseolch(fd[0].linbuf[i][0]) && fd[0].linbuf[i][0] != 0)
            {
              trivial = 0;
            }
        }
      for (i = next->line1; i <= l1 && trivial; i++)
        {
          if (!ignore_blank_lines_flag)
            {
              trivial = 0;
            }
          else if (ignore_all_space_flag | ignore_space_change_flag)
            {
              if (!is_blank_line(fd[1].linbuf[i], fd[1].linbuf[i + 1]))
                trivial = 0;
            }
          else if (!iseolch(fd[1].linbuf[i][0]) && fd[1].linbuf[i][0] != 0)
            {
              trivial = 0;
            }
        }
    }
  while ((next = next->link) != NULL);

  *last0 = l0;
  *last1 = l1;

  /* If all inserted or deleted lines are ignorable,
     tell the caller to ignore this hunk.  */
  if (trivial)
    show_from = show_to = 0;

  /* WinMerge editor needs to know if there were trivial changes though,
     so stash that off in the trivial field */
  if (trivial)
    hunk->trivial = 1;
  else
    hunk->trivial = 0;

  *deletes = show_from;
  *inserts = show_to;
}

/* malloc a block of memory, with fatal error message if we can't do it. */

VOID *
xmalloc (size_t size)
{
  register VOID *value;

  if (size == 0)
    size = 1;

  value = (VOID *) malloc (size);

  if (!value)
#ifdef __MSDOS__
    fatal ("real memory exhausted");
#else
    fatal ("virtual memory exhausted");
#endif
  return value;
}

/* realloc a block of memory, with fatal error message if we can't do it. */

VOID *
xrealloc (VOID *old, size_t size)
{
  register VOID *value;

  if (size == 0)
    size = 1;

  value = (VOID *) realloc (old, size);

  if (!value)
#ifdef __MSDOS__
    fatal ("real memory exhausted");
#else
    fatal ("virtual memory exhausted");
#endif
  return value;
}

/* Concatenate three strings, returning a newly malloc'd string.  */

char *
concat (char const *s1, char const *s2, char const *s3)
{
  size_t len = strlen (s1) + strlen (s2) + strlen (s3);
  char *new = xmalloc (len + 1);
  sprintf_s (new, len+1, "%s%s%s", s1, s2, s3);
  return new;
}

/* Yield the newly malloc'd pathname
   of the file in DIR whose filename is FILE.  */

char *
dir_file_pathname (char const *dir, char const *file)
{
#if defined(__MSDOS__) || defined(__NT__) || defined(WIN32)
  char sep = dir[strlen(dir) - 1];
  return concat (dir, "\\" + (*dir && ((sep == '/') || (sep == '\\'))), file);
#else
  return concat (dir, "/" + (*dir && dir[strlen (dir) - 1] == '/'), file);
#endif /*__MSDOS__||__NT__*/
}

void
debug_script (struct change *sp)
{
  fflush (stdout);
  for (; sp!=NULL; sp = sp->link)
    fprintf (stderr, "%3d %3d delete %d insert %d\n",
	     sp->line0, sp->line1, sp->deleted, sp->inserted);
  fflush (stderr);
}

#if !HAVE_MEMCHR
char *
memchr (s, c, n)
     char const *s;
     int c;
     size_t n;
{
  unsigned char const *p = (unsigned char const *) s, *lim = p + n;
  for (;  p < lim;  p++)
    if (*p == c)
      return (char *) p;
  return NULL;
}
#endif
</file>

<file path="Winmerge-Src/Src/FilterEngine/FileContentRef.cpp">
#include "pch.h"
#include "FileContentRef.h"
#include "UnicodeString.h"
#include "OptionsMgr.h"
#include "OptionsDef.h"
#include "UniFile.h"
#include "codepage_detect.h"
#include "paths.h"
#include "MergeApp.h"
#include <algorithm>
#include <functional>
#include <Poco/RegularExpression.h>
#include <Poco/FileStream.h>
#include <Poco/Exception.h>

static void GuessEncoding(UniMemFile& file, const String& path)
{
	file.ReadBom();
	if (!file.HasBom())
	{
		int iGuessEncodingType = GetOptionsMgr()->GetInt(OPT_CP_DETECT);
		int64_t fileSize = file.GetFileSize();
		FileTextEncoding encoding = codepage_detect::Guess(
			paths::FindExtension(path), file.GetBase(), static_cast<size_t>(
				fileSize < static_cast<int64_t>(codepage_detect::BufSize) ?
				fileSize : static_cast<int64_t>(codepage_detect::BufSize)),
			iGuessEncodingType);
		file.SetCodepage(encoding.m_codepage);
	}
}

bool FileContentRef::operator==(const FileContentRef& other) const
{
	try {
		Poco::FileInputStream fs1(ucr::toUTF8(path), std::ios::binary);
		Poco::FileInputStream fs2(ucr::toUTF8(other.path), std::ios::binary);

		if (!fs1.good() || !fs2.good()) return false;

		const size_t bufferSize = 4096;
		char buffer1[bufferSize];
		char buffer2[bufferSize];

		while (true) {
			fs1.read(buffer1, bufferSize);
			fs2.read(buffer2, bufferSize);

			std::streamsize count1 = fs1.gcount();
			std::streamsize count2 = fs2.gcount();

			if (count1 != count2) return false;
			if (count1 == 0) return true; // end of both

			if (std::memcmp(buffer1, buffer2, static_cast<size_t>(count1)) != 0)
				return false;
		}
	}
	catch (const Poco::Exception&)
	{
		return false;
	}
}

bool FileContentRef::Contains(const std::string& str) const
{
	UniMemFile file;
	if (!file.OpenReadOnly(path))
		return false;
	GuessEncoding(file, path);
	String searchStr = ucr::toTString(str);
	strutils::makelower(searchStr);
	std::boyer_moore_horspool_searcher<String::const_iterator> searcher(searchStr.begin(), searchStr.end());
	bool linesToRead = true;
	bool found = false;
	do
	{
		bool lossy;
		String line, eol;
		linesToRead = file.ReadString(line, eol, &lossy);
		strutils::makelower(line);
		using iterator = String::const_iterator;
		std::pair<iterator, iterator> result = searcher(line.begin(), line.end());
		if (result.first != result.second)
		{
			found = true;
			break;
		}
	} while (linesToRead);
	file.Close();
	return found;
}

bool FileContentRef::REContains(const Poco::RegularExpression& regexp) const
{
	UniMemFile file;
	if (!file.OpenReadOnly(path))
		return false;
	GuessEncoding(file, path);
	bool linesToRead = true;
	bool found = false;
	try
	{
		do
		{
			bool lossy;
			String line, eol;
			linesToRead = file.ReadString(line, eol, &lossy);
			Poco::RegularExpression::Match match;
			if (regexp.match(ucr::toUTF8(line), match) > 0)
			{
				found = true;
				break;
			}
		} while (linesToRead);
	}
	catch (const Poco::RegularExpressionException&)
	{
	}
	file.Close();
	return found;
}

std::string FileContentRef::Sublines(ptrdiff_t start, ptrdiff_t len) const
{
	UniMemFile file;
	if (!file.OpenReadOnly(path))
		return "";
	GuessEncoding(file, path);
	bool linesToRead = true;
	std::vector<String> lines;
	if (start >= 0 && len >= 0)
	{
		size_t count = 0;
		do
		{
			bool lossy;
			String line, eol;
			linesToRead = file.ReadString(line, eol, &lossy);
			if (count >= start && count < start + len && (!line.empty() || !eol.empty()))
				lines.push_back(line + eol);
			if (lines.size() >= static_cast<size_t>(len))
				break;
			++count;
		} while (linesToRead);
		file.Close();
		return ucr::toUTF8(strutils::join(lines.begin(), lines.end(), _T("")));
	}
	do
	{
		bool lossy;
		String line, eol;
		linesToRead = file.ReadString(line, eol, &lossy);
		if (!line.empty() || !eol.empty())
			lines.push_back(line + eol);
	} while (linesToRead);
	if (start < 0)
	{
		start = static_cast<ptrdiff_t>(lines.size()) + start;
		if (start < 0)
			start = 0;
	}
	if (start >= static_cast<ptrdiff_t>(lines.size()))
		return "";
	if (len < 0)
		len = static_cast<ptrdiff_t>(lines.size()) - start + len + 1;
	if (len < 0)
		return "";
	file.Close();
	return ucr::toUTF8(strutils::join(lines.begin() + start, lines.begin() + start + len, _T("")));
}

size_t FileContentRef::LineCount() const
{
	UniMemFile file;
	if (!file.OpenReadOnly(path))
		return static_cast<size_t>(-1);
	GuessEncoding(file, path);
	bool linesToRead = true;
	size_t count = 0;
	do
	{
		bool lossy;
		String line, eol;
		linesToRead = file.ReadString(line, eol, &lossy);
		if (!line.empty() || !eol.empty())
			++count;
	} while (linesToRead);
	file.Close();
	return count;
}

</file>

<file path="Winmerge-Src/Src/FilterEngine/FileContentRef.h">
#pragma once

#include "DiffFileInfo.h"
#include <string>

namespace Poco { class RegularExpression; }

struct FileContentRef
{
	String path;
	DiffFileInfo item;
	bool operator==(const FileContentRef& other) const;
	bool Contains(const std::string& str) const;
	bool REContains(const Poco::RegularExpression& regexp) const;
	std::string Sublines(ptrdiff_t start, ptrdiff_t len) const;
	size_t LineCount() const;
};
</file>

<file path="Winmerge-Src/Src/FilterEngine/FilterEngine.vcxitems">
<?xml version="1.0" encoding="utf-8"?>
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Label="Globals">
    <MSBuildAllProjects Condition="'$(MSBuildVersion)' == '' Or '$(MSBuildVersion)' &lt; '16.0'">$(MSBuildAllProjects);$(MSBuildThisFileFullPath)</MSBuildAllProjects>
    <HasSharedItems>true</HasSharedItems>
    <ItemsProjectGuid>{9c37e5d8-1dc0-4eac-aadb-5fc8be4fb1bc}</ItemsProjectGuid>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <ClCompile>
      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(MSBuildThisFileDirectory)</AdditionalIncludeDirectories>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ProjectCapability Include="SourceItemsFromImports" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="$(MSBuildThisFileDirectory)FileContentRef.cpp">
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)FilterExpression.cpp">
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)FilterExpressionNodes.cpp">
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)FilterLexer.cpp">
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)FilterParser.c">
      <ExcludedFromBuild>true</ExcludedFromBuild>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)FilterParser.cpp">
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <CustomBuild Include="$(MSBuildThisFileDirectory)FilterLexer.re">
      <ExcludedFromBuild>
      </ExcludedFromBuild>
      <FileType>Document</FileType>
      <Command>"$(SolutionDir)\Build\msys2\usr\bin\re2c.exe" "%(FullPath)" -o "%(RelativeDir)\FilterLexer.cpp"</Command>
      <Outputs>%(RelativeDir)\FilterLexer.cpp</Outputs>
    </CustomBuild>
  </ItemGroup>
  <ItemGroup>
    <CustomBuild Include="$(MSBuildThisFileDirectory)FilterParser.y">
      <ExcludedFromBuild>false</ExcludedFromBuild>
      <FileType>Document</FileType>
      <Command>"$(SolutionDir)\Build\msys2\usr\bin\lemon" "%(FullPath)" "-T$(SolutionDir)\Build\msys2\usr\share\lemon\lempar.c"</Command>
      <Outputs>%(RelativeDir)\FilterParser.c</Outputs>
    </CustomBuild>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="$(MSBuildThisFileDirectory)FileContentRef.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)FilterError.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)FilterExpression.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)FilterExpressionNodes.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)FilterLexer.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)FilterParser.h" />
  </ItemGroup>
</Project>
</file>

<file path="Winmerge-Src/Src/FilterEngine/FilterEngine.vcxitems.filters">
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Header Files">
      <UniqueIdentifier>{cbb36660-3f8a-46ba-855a-fa8f32b99d72}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files">
      <UniqueIdentifier>{7e65cd72-3165-42cc-b722-0dcf1593ffdd}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="$(MSBuildThisFileDirectory)FilterExpression.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)FilterExpressionNodes.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)FilterLexer.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)FilterParser.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)FilterParser.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="$(MSBuildThisFileDirectory)FileContentRef.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <CustomBuild Include="$(MSBuildThisFileDirectory)FilterLexer.re">
      <Filter>Source Files</Filter>
    </CustomBuild>
    <CustomBuild Include="$(MSBuildThisFileDirectory)FilterParser.y">
      <Filter>Source Files</Filter>
    </CustomBuild>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="$(MSBuildThisFileDirectory)FilterExpression.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="$(MSBuildThisFileDirectory)FilterExpressionNodes.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="$(MSBuildThisFileDirectory)FilterLexer.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="$(MSBuildThisFileDirectory)FilterParser.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="$(MSBuildThisFileDirectory)FilterError.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="$(MSBuildThisFileDirectory)FileContentRef.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
</file>

<file path="Winmerge-Src/Src/FilterEngine/FilterError.h">
/**
 * @file FilterError.h
 * @brief Defines error codes for the filter engine.
 */
#pragma once

enum FilterErrorCode
{
	FILTER_ERROR_NO_ERROR = 0,
	FILTER_ERROR_UNKNOWN_CHAR = 1, // LEXER_ERR_UNKNOWN_CHAR(-1)
	FILTER_ERROR_UNTERMINATED_STRING = 2, // LEXER_ERR_UNTERMINATED_STRING(-2)
	FILTER_ERROR_EMPTY_EXPRESSION = 3,
	FILTER_ERROR_SYNTAX_ERROR = 4,
	FILTER_ERROR_PARSE_FAILURE = 5,
	FILTER_ERROR_INVALID_LITERAL = 6,
	FILTER_ERROR_INVALID_ARGUMENT_COUNT = 7,
	FILTER_ERROR_INVALID_REGULAR_EXPRESSION = 8,
	FILTER_ERROR_UNDEFINED_IDENTIFIER = 9,
	FILTER_ERROR_FILTER_NAME_NOT_FOUND = 10,
	FILTER_ERROR_EVALUATION_FAILED = 11,
	FILTER_ERROR_DIVIDE_BY_ZERO = 12,
};
</file>

<file path="Winmerge-Src/Src/FilterEngine/FilterExpression.cpp">
/**
 * @file  FilterExpression.cpp
 *
 * @brief Filter engine implementation.
 */
#include "pch.h"
#include "FilterExpression.h"
#include "FilterExpressionNodes.h"
#include "FilterLexer.h"
#include "DiffContext.h"
#include "DiffItem.h"
#include <Poco/LocalDateTime.h>

extern void Parse(void* yyp, int yymajor, YYSTYPE yyminor, FilterExpression* pCtx);
extern void* ParseAlloc(void* (*mallocProc)(size_t));
extern void ParseFree(void* yyp, void (*freeProc)(void*));

void YYSTYPEDestructor(YYSTYPE& yystype)
{
	if (yystype.nodeList)
	{
		for (auto& node : *yystype.nodeList)
			delete node;
		delete yystype.nodeList;
	}
	delete yystype.node;
	yystype.node = nullptr;
	yystype.nodeList = nullptr;
}

FilterExpression::FilterExpression()
{
}

FilterExpression::FilterExpression(const FilterExpression& other)
	: optimize(other.optimize)
	, ctxt(other.ctxt)
	, now(other.now ? new Poco::Timestamp(*other.now) : nullptr)
	, today(other.today ? new Poco::Timestamp(*other.today) : nullptr)
	, expression(other.expression)
{
	Parse(expression);
}

FilterExpression::FilterExpression(const std::string& expression)
{
	Parse(expression);
}

FilterExpression::~FilterExpression()
{
	Clear();
}

void FilterExpression::Clear()
{
	now.reset();
	today.reset();
	rootNode.reset();
	errorCode = FILTER_ERROR_NO_ERROR;
	errorPosition = -1;
}

void FilterExpression::UpdateTimestamp()
{
	now.reset(new Poco::Timestamp());
	Poco::LocalDateTime ldt(*now);
	Poco::LocalDateTime midnight(ldt.year(), ldt.month(), ldt.day(), 0, 0, 0, 0, 0);
	today.reset(new Poco::Timestamp(midnight.utc().timestamp()));
}

static int getErrorPosition(const FilterExpression* pCtx, const FilterLexer& lexer)
{
	if (pCtx->errorCode == FILTER_ERROR_UNDEFINED_IDENTIFIER)
	{
		return static_cast<int>(lexer.yycursor - strlen(lexer.yylval.string) - pCtx->expression.c_str());
	}
	return static_cast<int>(lexer.yycursor - pCtx->expression.c_str());
}

bool FilterExpression::Parse()
{
	Clear();
	UpdateTimestamp();
	if (expression.empty())
	{
		errorCode = FILTER_ERROR_EMPTY_EXPRESSION;
		errorPosition = 0;
		return false;
	}
	FilterLexer lexer(expression);
	void* prs = ParseAlloc(malloc);
	int token;
	FilterErrorCode firstError = FILTER_ERROR_NO_ERROR;
	while ((token = lexer.yylex()) != 0)
	{
		if (token < 0)
		{
			firstError = static_cast<FilterErrorCode>(-token);
			errorPosition = getErrorPosition(this, lexer);
			break;
		}
		::Parse(prs, token, lexer.yylval, this);
		if (errorCode != 0)
		{
			firstError = errorCode;
			errorPosition = getErrorPosition(this, lexer);
			break;
		}
		lexer.yycursor = lexer.YYCURSOR;
	}
	::Parse(prs, 0, lexer.yylval, this);
	if (firstError == 0 && errorCode != 0)
	{
		firstError = errorCode;
		errorPosition = getErrorPosition(this, lexer);
	}
	::ParseFree(prs, free);
	if (firstError != 0)
		errorCode = firstError;
	return (errorCode == 0 && rootNode != nullptr);
}

bool FilterExpression::Parse(const std::string& expressionStr)
{
	expression = expressionStr;
	return Parse();
}

bool FilterExpression::Evaluate(const DIFFITEM& di)
{
	try
	{
		const auto result = rootNode->Evaluate(di);
		if (const auto boolVal = std::get_if<bool>(&result))
			return *boolVal;
		if (const auto arrayVal = std::get_if<std::shared_ptr<std::vector<ValueType2>>>(&result))
		{
			const auto& vec = *arrayVal->get();
			return std::any_of(vec.begin(), vec.end(), [](const ValueType2& item) {
				const auto boolVal = std::get_if<bool>(&item.value);
				return boolVal && *boolVal;
				});
		}
		return false;
	}
	catch (const Poco::RegularExpressionException& e)
	{
		errorCode = FILTER_ERROR_INVALID_REGULAR_EXPRESSION;
		errorPosition = -1;
		errorMessage = e.message();
		if (logger)
			logger("FilterExpression evaluation error: " + errorMessage);
		return false;
	}
	catch (const std::exception& e)
	{
		errorCode = FILTER_ERROR_EVALUATION_FAILED;
		errorPosition = -1;
		errorMessage = e.what();
		if (logger)
			logger("FilterExpression evaluation error: " + errorMessage);
		return false;
	}
}
</file>

<file path="Winmerge-Src/Src/FilterEngine/FilterExpression.h">
/**
 * @file  FilterExpression.h
 *
 * @brief Header file for the FilterExpression class, which provides functionality to parse and evaluate filter expressions.
 */
#pragma once

#include <string>
#include <memory>
#include "FilterError.h"

class CDiffContext;
class DIFFITEM;
struct ExprNode;
struct YYSTYPE;
namespace Poco { class Timestamp; }

struct FilterExpression
{
	FilterExpression();
	FilterExpression(const FilterExpression& other);
	FilterExpression(const std::string& expression);
	~FilterExpression();
	bool Parse(const std::string& expression);
	bool Parse();
	void SetDiffContext(const CDiffContext* pCtxt) { ctxt = pCtxt; }
	bool Evaluate(const DIFFITEM& di);
	void UpdateTimestamp();
	void Clear();
	static void SetLogger(std::function<void(const std::string&)> func) { logger = func; };
	bool optimize = true;
	const CDiffContext* ctxt = nullptr;
	std::unique_ptr<Poco::Timestamp> now;
	std::unique_ptr<Poco::Timestamp> today;
	std::unique_ptr<ExprNode> rootNode;
	std::string expression;
	FilterErrorCode errorCode = FILTER_ERROR_NO_ERROR;
	int errorPosition = -1;
	std::string errorMessage;
	inline static std::function<void(const std::string&)> logger;
};
</file>

<file path="Winmerge-Src/Src/FilterEngine/FilterExpressionNodes.h">
/**
 * @file  FilterExpressionNodes.h
 *
 * @brief Filter expression evaluation classes.
 */
#pragma once

#include "FilterParser.h"
#include <string>
#include <map>
#include <variant>
#include <vector>
#include <Poco/Timestamp.h>

namespace Poco { class RegularExpression; }
struct FilterExpression;
struct FileContentRef;
class DIFFITEM;
struct ValueType2;
using ValueType = std::variant<std::monostate, bool, int64_t, Poco::Timestamp, std::shared_ptr<Poco::RegularExpression>, std::string, std::shared_ptr<FileContentRef>, std::shared_ptr<std::vector<ValueType2>>>;
struct ValueType2 { ValueType value; };

struct ExprNode
{
	virtual ~ExprNode() { }
	virtual ExprNode* Optimize() { return this; }
	virtual ValueType Evaluate(const DIFFITEM& di) const = 0;
};

struct OrNode : public ExprNode
{
	OrNode(ExprNode* l, ExprNode* r) : left(l), right(r) { }
	virtual ~OrNode()
	{
		delete left;
		delete right;
	}
	ExprNode* Optimize() override;
	ValueType Evaluate(const DIFFITEM& di) const override;
	ExprNode* left;
	ExprNode* right;
};

struct AndNode : public ExprNode
{
	AndNode(ExprNode* l, ExprNode* r) : left(l), right(r) { }
	virtual ~AndNode()
	{
		delete left;
		delete right;
	}
	ExprNode* Optimize() override;
	ValueType Evaluate(const DIFFITEM& di) const override;
	ExprNode* left;
	ExprNode* right;
};

struct NotNode : public ExprNode
{
	NotNode(ExprNode* e) : expr(e) { }
	virtual ~NotNode()
	{
		delete expr;
	}
	ExprNode* Optimize() override;
	ValueType Evaluate(const DIFFITEM& di) const override;
	ExprNode* expr;
};

struct BinaryOpNode : public ExprNode
{
	BinaryOpNode(ExprNode* l, int o, ExprNode* r) : left(l), right(r), op(o) { }
	virtual ~BinaryOpNode()
	{
		delete left;
		delete right;
	}
	ExprNode* Optimize() override;
	ValueType Evaluate(const DIFFITEM& di) const override;
	int op;
	ExprNode* left;
	ExprNode* right;
};

struct NegateNode : public ExprNode
{
	NegateNode(ExprNode* r) : right(r) { }
	virtual ~NegateNode()
	{
		delete right;
	}
	ExprNode* Optimize() override;
	ValueType Evaluate(const DIFFITEM& di) const override;
	ExprNode* right;
};

struct FieldNode : public ExprNode
{
	FieldNode(const FilterExpression* ctxt, const std::string& v);
	ValueType Evaluate(const DIFFITEM& di) const override;
	const FilterExpression* ctxt;
	std::string field;
	std::function<ValueType(const FilterExpression* ctxt, const DIFFITEM& di)> func;
};

struct FunctionNode : public ExprNode
{
	FunctionNode(const FilterExpression* ctxt, const std::string& name, std::vector<ExprNode*>* args);
	virtual ~FunctionNode();
	ExprNode* Optimize() override;
	ValueType Evaluate(const DIFFITEM& di) const override;
	const FilterExpression* ctxt;
	std::string functionName;
	std::vector<ExprNode*>* args;
	std::function<ValueType(const FilterExpression* ctxt, const DIFFITEM& di, std::vector<ExprNode*>* args)> func;
};

struct BoolLiteral : public ExprNode
{
	BoolLiteral(bool v) : value(v) { }
	inline ValueType Evaluate(const DIFFITEM& di) const override { return value; }
	bool value;
};

struct IntLiteral : public ExprNode
{
	IntLiteral(int64_t v) : value(v) { }
	inline ValueType Evaluate(const DIFFITEM& di) const override { return value; }
	int64_t value;
};

struct StringLiteral : public ExprNode
{
	StringLiteral(const std::string& v) : value(v) { }
	inline ValueType Evaluate(const DIFFITEM& di) const override { return value; }
	std::string value;
};

struct SizeLiteral : public ExprNode
{
	SizeLiteral(const std::string& v);
	inline ValueType Evaluate(const DIFFITEM& di) const override { return value; }
	int64_t value;
};

struct DateTimeLiteral : public ExprNode
{
	DateTimeLiteral(const std::string& v);
	DateTimeLiteral(const Poco::Timestamp& v) : value(v) { }
	inline ValueType Evaluate(const DIFFITEM& di) const override { return value; }
	Poco::Timestamp value;
};

struct DurationLiteral : public ExprNode
{
	DurationLiteral(const std::string& v);
	inline ValueType Evaluate(const DIFFITEM& di) const override { return value; }
	int64_t value;
};

struct VersionLiteral : public ExprNode
{
	VersionLiteral(const std::string& v);
	inline ValueType Evaluate(const DIFFITEM& di) const override { return value; }
	int64_t value;
};

struct RegularExpressionLiteral : public ExprNode
{
	RegularExpressionLiteral(const std::string& v);
	inline ValueType Evaluate(const DIFFITEM& di) const override { return value; }
	std::shared_ptr<Poco::RegularExpression> value;
};

struct ArrayLiteral : public ExprNode
{
	ArrayLiteral(std::shared_ptr<std::vector<ValueType2>> v) : value(v) {}
	inline ValueType Evaluate(const DIFFITEM& di) const override { return value; }
	std::shared_ptr<std::vector<ValueType2>> value;
};
</file>

<file path="Winmerge-Src/Src/FilterEngine/FilterLexer.cpp">
/* Generated by re2c 3.1 on Sun Aug 24 15:01:07 2025 */
#line 1 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
/**
 * @file  FilterLexer.re
 *
 * @brief Lexer for the filter parser.
 */
#line 11 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"


#include "pch.h"
#include "FilterParser.h"
#include "FilterLexer.h"
#include <string>

int FilterLexer::yylex()
{
begin:
	
#line 21 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
{
	char yych;
	unsigned int yyaccept = 0;
	yych = *YYCURSOR;
	switch (yych) {
		case '\t':
		case '\n':
		case '\r':
		case ' ': goto yy3;
		case '!': goto yy5;
		case '"': goto yy6;
		case '%': goto yy7;
		case '(': goto yy8;
		case ')': goto yy9;
		case '*': goto yy10;
		case '+': goto yy11;
		case ',': goto yy12;
		case '-': goto yy13;
		case '/': goto yy14;
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9': goto yy15;
		case '<': goto yy17;
		case '=': goto yy19;
		case '>': goto yy21;
		case 'A':
		case 'a': goto yy23;
		case 'B':
		case 'E':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'P':
		case 'Q':
		case 'S':
		case 'U':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'b':
		case 'e':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'p':
		case 'q':
		case 's':
		case 'u':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy25;
		case 'C':
		case 'c': goto yy27;
		case 'D':
		case 'd': goto yy28;
		case 'F':
		case 'f': goto yy29;
		case 'L':
		case 'l': goto yy30;
		case 'M':
		case 'm': goto yy31;
		case 'N':
		case 'n': goto yy32;
		case 'O':
		case 'o': goto yy33;
		case 'R':
		case 'r': goto yy34;
		case 'T':
		case 't': goto yy35;
		case 'V':
		case 'v': goto yy36;
		default:
			if (YYLIMIT <= YYCURSOR) goto yy123;
			goto yy1;
	}
yy1:
	++YYCURSOR;
yy2:
#line 100 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ return LEXER_ERR_UNKNOWN_CHAR; }
#line 116 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy3:
	yych = *++YYCURSOR;
	switch (yych) {
		case '\t':
		case '\n':
		case '\r':
		case ' ': goto yy3;
		default: goto yy4;
	}
yy4:
#line 22 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ goto begin; }
#line 129 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy5:
	yych = *++YYCURSOR;
	switch (yych) {
		case '=': goto yy37;
		default: goto yy2;
	}
yy6:
	++YYCURSOR;
#line 76 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{
		int errorCode = 0;
		std::string str = UnescapeQuotes(YYCURSOR, errorCode);
		if (errorCode != 0)
			return errorCode;
		yylval.string = DupString(str.c_str());
		return TK_STRING_LITERAL;
	}
#line 147 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy7:
	++YYCURSOR;
#line 97 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ return TK_MOD; }
#line 152 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy8:
	++YYCURSOR;
#line 91 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ return TK_LPAREN; }
#line 157 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy9:
	++YYCURSOR;
#line 92 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ return TK_RPAREN; }
#line 162 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy10:
	++YYCURSOR;
#line 95 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ return TK_STAR; }
#line 167 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy11:
	++YYCURSOR;
#line 93 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ return TK_PLUS; }
#line 172 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy12:
	++YYCURSOR;
#line 99 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ return TK_COMMA; }
#line 177 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy13:
	++YYCURSOR;
#line 94 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ return TK_MINUS; }
#line 182 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy14:
	++YYCURSOR;
#line 96 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ return TK_SLASH; }
#line 187 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy15:
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case '.': goto yy38;
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9': goto yy15;
		case 'B':
		case 'b': goto yy40;
		case 'D':
		case 'd': goto yy41;
		case 'G':
		case 'K':
		case 'T':
		case 'g':
		case 'k':
		case 't': goto yy43;
		case 'H':
		case 'h': goto yy44;
		case 'M':
		case 'm': goto yy45;
		case 'S':
		case 's': goto yy46;
		case 'W':
		case 'w': goto yy47;
		default: goto yy16;
	}
yy16:
#line 64 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{
		yylval.integer = std::stoi(std::string((const char*)yycursor, YYCURSOR - yycursor));
		return TK_INTEGER_LITERAL;
	}
#line 229 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy17:
	yych = *++YYCURSOR;
	switch (yych) {
		case '=': goto yy48;
		default: goto yy18;
	}
yy18:
#line 87 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ return TK_LT; }
#line 239 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy19:
	yych = *++YYCURSOR;
	switch (yych) {
		case '=': goto yy49;
		default: goto yy20;
	}
yy20:
#line 85 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ return TK_EQ; }
#line 249 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy21:
	yych = *++YYCURSOR;
	switch (yych) {
		case '=': goto yy50;
		default: goto yy22;
	}
yy22:
#line 89 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ return TK_GT; }
#line 259 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy23:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'N':
		case 'n': goto yy51;
		default: goto yy26;
	}
yy24:
#line 68 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{
		const char* p = yycursor;
		while (*p == ' ' || *p == '\t' || *p == '\r' || *p == '\n')
			p++;
		std::string tmp = std::string(p, YYCURSOR - p);
		yylval.string = DupString(tmp.c_str());
		return TK_IDENTIFIER;
	}
#line 278 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy25:
	yych = *++YYCURSOR;
yy26:
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy25;
		default: goto yy24;
	}
yy27:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'O':
		case 'o': goto yy52;
		default: goto yy26;
	}
yy28:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case '"': goto yy53;
		default: goto yy26;
	}
yy29:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'A':
		case 'a': goto yy54;
		default: goto yy26;
	}
yy30:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'I':
		case 'i': goto yy55;
		default: goto yy26;
	}
yy31:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'A':
		case 'a': goto yy56;
		default: goto yy26;
	}
yy32:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'O':
		case 'o': goto yy57;
		default: goto yy26;
	}
yy33:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'R':
		case 'r': goto yy58;
		default: goto yy26;
	}
yy34:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'E':
		case 'e': goto yy60;
		default: goto yy26;
	}
yy35:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'R':
		case 'r': goto yy61;
		default: goto yy26;
	}
yy36:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case '"': goto yy62;
		default: goto yy26;
	}
yy37:
	++YYCURSOR;
#line 86 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ return TK_NE; }
#line 430 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy38:
	yych = *++YYCURSOR;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9': goto yy63;
		default: goto yy39;
	}
yy39:
	YYCURSOR = YYMARKER;
	if (yyaccept == 0) {
		goto yy16;
	} else {
		goto yy42;
	}
yy40:
	++YYCURSOR;
#line 32 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{
		const char* p = yycursor;
		while (*p == ' ' || *p == '\t' || *p == '\r' || *p == '\n')
			p++;
		std::string lit(p, YYCURSOR - p);
		yylval.string = DupString(lit.c_str());
		return TK_SIZE_LITERAL;
	}
#line 464 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy41:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case 'A':
		case 'a': goto yy64;
		default: goto yy42;
	}
yy42:
#line 40 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{
		const char* p = yycursor;
		while (*p == ' ' || *p == '\t' || *p == '\r' || *p == '\n')
			p++;
		std::string lit(p, YYCURSOR - p);
		yylval.string = DupString(lit.c_str());
		return TK_DURATION_LITERAL;
	}
#line 483 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy43:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'B':
		case 'b': goto yy40;
		default: goto yy39;
	}
yy44:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case 'O':
		case 'o': goto yy65;
		case 'R':
		case 'r': goto yy66;
		default: goto yy42;
	}
yy45:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case 'B':
		case 'b': goto yy40;
		case 'I':
		case 'i': goto yy67;
		case 'S':
		case 's': goto yy68;
		default: goto yy42;
	}
yy46:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case 'E':
		case 'e': goto yy69;
		default: goto yy42;
	}
yy47:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case 'E':
		case 'e': goto yy70;
		default: goto yy42;
	}
yy48:
	++YYCURSOR;
#line 88 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ return TK_LE; }
#line 533 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy49:
	++YYCURSOR;
#line 84 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ return TK_EQ; }
#line 538 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy50:
	++YYCURSOR;
#line 90 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ return TK_GE; }
#line 543 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy51:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'D':
		case 'd': goto yy71;
		default: goto yy26;
	}
yy52:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'N':
		case 'n': goto yy73;
		default: goto yy26;
	}
yy53:
	++YYCURSOR;
#line 48 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{
		int errorCode = 0;
		std::string str = UnescapeQuotes(YYCURSOR, errorCode);
		if (errorCode != 0)
			return errorCode;
		yylval.string = DupString(str.c_str());
		return TK_DATETIME_LITERAL;
	}
#line 571 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy54:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'L':
		case 'l': goto yy74;
		default: goto yy26;
	}
yy55:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'K':
		case 'k': goto yy75;
		default: goto yy26;
	}
yy56:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'T':
		case 't': goto yy76;
		default: goto yy26;
	}
yy57:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'T':
		case 't': goto yy77;
		default: goto yy26;
	}
yy58:
	yych = *++YYCURSOR;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy25;
		default: goto yy59;
	}
yy59:
#line 24 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ return TK_OR; }
#line 675 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy60:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'C':
		case 'c': goto yy79;
		default: goto yy26;
	}
yy61:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'U':
		case 'u': goto yy80;
		default: goto yy26;
	}
yy62:
	++YYCURSOR;
#line 56 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{
		int errorCode = 0;
		std::string str = UnescapeQuotes(YYCURSOR, errorCode);
		if (errorCode != 0)
			return errorCode;
		yylval.string = DupString(str.c_str());
		return TK_VERSION_LITERAL;
	}
#line 703 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy63:
	yych = *++YYCURSOR;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9': goto yy63;
		case 'B':
		case 'b': goto yy40;
		case 'D':
		case 'd': goto yy41;
		case 'G':
		case 'K':
		case 'T':
		case 'g':
		case 'k':
		case 't': goto yy43;
		case 'H':
		case 'h': goto yy44;
		case 'M':
		case 'm': goto yy45;
		case 'S':
		case 's': goto yy46;
		case 'W':
		case 'w': goto yy47;
		default: goto yy39;
	}
yy64:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'Y':
		case 'y': goto yy81;
		default: goto yy39;
	}
yy65:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'U':
		case 'u': goto yy82;
		default: goto yy39;
	}
yy66:
	++YYCURSOR;
	goto yy42;
yy67:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'L':
		case 'l': goto yy83;
		case 'N':
		case 'n': goto yy84;
		default: goto yy39;
	}
yy68:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case 'E':
		case 'e': goto yy85;
		default: goto yy42;
	}
yy69:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'C':
		case 'c': goto yy86;
		default: goto yy39;
	}
yy70:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'E':
		case 'e': goto yy87;
		default: goto yy39;
	}
yy71:
	yych = *++YYCURSOR;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy25;
		default: goto yy72;
	}
yy72:
#line 23 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ return TK_AND; }
#line 856 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy73:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'T':
		case 't': goto yy88;
		default: goto yy26;
	}
yy74:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'S':
		case 's': goto yy89;
		default: goto yy26;
	}
yy75:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'E':
		case 'e': goto yy90;
		default: goto yy26;
	}
yy76:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'C':
		case 'c': goto yy92;
		default: goto yy26;
	}
yy77:
	yych = *++YYCURSOR;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy25;
		default: goto yy78;
	}
yy78:
#line 25 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ return TK_NOT; }
#line 960 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy79:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'O':
		case 'o': goto yy93;
		default: goto yy26;
	}
yy80:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'E':
		case 'e': goto yy94;
		default: goto yy26;
	}
yy81:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'S':
		case 's': goto yy66;
		default: goto yy42;
	}
yy82:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'R':
		case 'r': goto yy81;
		default: goto yy39;
	}
yy83:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'L':
		case 'l': goto yy96;
		default: goto yy39;
	}
yy84:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case 'U':
		case 'u': goto yy97;
		default: goto yy42;
	}
yy85:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'C':
		case 'c': goto yy66;
		default: goto yy39;
	}
yy86:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case 'O':
		case 'o': goto yy98;
		default: goto yy42;
	}
yy87:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'K':
		case 'k': goto yy81;
		default: goto yy39;
	}
yy88:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'A':
		case 'a': goto yy99;
		default: goto yy26;
	}
yy89:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'E':
		case 'e': goto yy100;
		default: goto yy26;
	}
yy90:
	yych = *++YYCURSOR;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy25;
		default: goto yy91;
	}
yy91:
#line 30 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ return TK_LIKE; }
#line 1115 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy92:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'H':
		case 'h': goto yy102;
		default: goto yy26;
	}
yy93:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'N':
		case 'n': goto yy103;
		default: goto yy26;
	}
yy94:
	yych = *++YYCURSOR;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy25;
		default: goto yy95;
	}
yy95:
#line 26 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ yylval.boolean = true; return TK_TRUE_LITERAL; }
#line 1203 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy96:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'I':
		case 'i': goto yy104;
		default: goto yy39;
	}
yy97:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'T':
		case 't': goto yy105;
		default: goto yy39;
	}
yy98:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'N':
		case 'n': goto yy106;
		default: goto yy39;
	}
yy99:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'I':
		case 'i': goto yy107;
		default: goto yy26;
	}
yy100:
	yych = *++YYCURSOR;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy25;
		default: goto yy101;
	}
yy101:
#line 27 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ yylval.boolean = false; return TK_FALSE_LITERAL; }
#line 1304 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy102:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'E':
		case 'e': goto yy108;
		default: goto yy26;
	}
yy103:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'T':
		case 't': goto yy109;
		default: goto yy26;
	}
yy104:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'S':
		case 's': goto yy110;
		default: goto yy39;
	}
yy105:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'E':
		case 'e': goto yy81;
		default: goto yy39;
	}
yy106:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'D':
		case 'd': goto yy81;
		default: goto yy39;
	}
yy107:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'N':
		case 'n': goto yy111;
		default: goto yy26;
	}
yy108:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'S':
		case 's': goto yy112;
		default: goto yy26;
	}
yy109:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'A':
		case 'a': goto yy114;
		default: goto yy26;
	}
yy110:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'E':
		case 'e': goto yy115;
		default: goto yy39;
	}
yy111:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'S':
		case 's': goto yy116;
		default: goto yy26;
	}
yy112:
	yych = *++YYCURSOR;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy25;
		default: goto yy113;
	}
yy113:
#line 31 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ return TK_MATCHES; }
#line 1452 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy114:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'I':
		case 'i': goto yy118;
		default: goto yy26;
	}
yy115:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'C':
		case 'c': goto yy119;
		default: goto yy39;
	}
yy116:
	yych = *++YYCURSOR;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy25;
		default: goto yy117;
	}
yy117:
#line 28 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ return TK_CONTAINS; }
#line 1539 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy118:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'N':
		case 'n': goto yy120;
		default: goto yy26;
	}
yy119:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'O':
		case 'o': goto yy98;
		default: goto yy39;
	}
yy120:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy24;
		case 'S':
		case 's': goto yy121;
		default: goto yy26;
	}
yy121:
	yych = *++YYCURSOR;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy25;
		default: goto yy122;
	}
yy122:
#line 29 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ return TK_RECONTAINS; }
#line 1634 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
yy123:
#line 98 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"
	{ return 0; }
#line 1638 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.cpp"
}
#line 101 "E:\\dev\\winmerge\\Src\\FilterEngine\\FilterLexer.re"

}

std::string FilterLexer::UnescapeQuotes(char*& str, int& errorCode)
{
	errorCode = LEXER_ERR_UNTERMINATED_STRING;
	std::string result;
	while (*str != '\0')
	{
		if (*str == '"')
		{
			if (*(str + 1) == '"')
			{
				result += '"';
				str += 2;
			}
			else
			{
				str++;
				errorCode = 0;
				break;
			}
		}
		else
		{
			result += *str++;
		}
	}
	return result;
}

const char* FilterLexer::DupString(const char* str)
{
	char* newStr = _strdup(str);
	strings.push_back(newStr);
	return newStr;
}

void FilterLexer::FreeStrings()
{
	for (auto str : strings)
		free(str);
	strings.clear();
}

</file>

<file path="Winmerge-Src/Src/FilterEngine/FilterLexer.h">
/**
 * @file  FilterLexer.h
 *
 * @brief Header file for the FilterLexer class, which is responsible for tokenizing filter expressions.
 */
#pragma once

#include <string>
#include <variant>
#include <vector>

struct ExprNode;

struct YYSTYPE
{
	ExprNode* node;
	std::vector<ExprNode*> *nodeList;
	const char* string;
	int64_t integer;
	bool boolean;
};

extern void YYSTYPEDestructor(YYSTYPE& yystype);

struct FilterLexer
{
	enum ErrorCode {
		LEXER_ERR_UNKNOWN_CHAR = -1,
		LEXER_ERR_UNTERMINATED_STRING = -2,
	};

	FilterLexer(const std::string& input)
		: yycursor((char*)input.c_str())
		, YYCURSOR((char*)input.c_str())
		, YYLIMIT((char*)input.c_str() + input.length())
	{
	}

	~FilterLexer()
	{
		FreeStrings();
	}

	int yylex();

	std::string UnescapeQuotes(char*& str, int& errorCode);
	const char* DupString(const char* str);
	void FreeStrings();

	YYSTYPE yylval{};
	char* yycursor = nullptr;
	char* YYMARKER = nullptr;
	char* YYCURSOR = nullptr;
	char* YYLIMIT = nullptr;
	std::vector<char*> strings;
};
</file>

<file path="Winmerge-Src/Src/FilterEngine/FilterLexer.re">
/**
 * @file  FilterLexer.re
 *
 * @brief Lexer for the filter parser.
 */
/*!re2c
re2c:define:YYCTYPE = char;
re2c:yyfill:enable = 0;
re2c:flags:case-insensitive = 1;
re2c:eof = 0;
*/

#include "pch.h"
#include "FilterParser.h"
#include "FilterLexer.h"
#include <string>

int FilterLexer::yylex()
{
begin:
	/*!re2c
	[ \t\r\n]+        { goto begin; }
	"AND"             { return TK_AND; }
	"OR"              { return TK_OR; }
	"NOT"             { return TK_NOT; }
	"TRUE"            { yylval.boolean = true; return TK_TRUE_LITERAL; }
	"FALSE"           { yylval.boolean = false; return TK_FALSE_LITERAL; }
	"CONTAINS"        { return TK_CONTAINS; }
	"RECONTAINS"      { return TK_RECONTAINS; }
	"LIKE"            { return TK_LIKE; }
	"MATCHES"         { return TK_MATCHES; }
	([0-9]+([.][0-9]+)?)("B"|"KB"|"MB"|"GB"|"TB") {
		const char* p = yycursor;
		while (*p == ' ' || *p == '\t' || *p == '\r' || *p == '\n')
			p++;
		std::string lit(p, YYCURSOR - p);
		yylval.string = DupString(lit.c_str());
		return TK_SIZE_LITERAL;
	}
	([0-9]+([.][0-9]+)?)("weeks"|"week"|"w"|"days"|"day"|"d"|"hours"|"hour"|"hr"|"h"|"minutes"|"minute"|"min"|"m"|"seconds"|"second"|"sec"|"s"|"milliseconds"|"millisecond"|"msec"|"ms") {
		const char* p = yycursor;
		while (*p == ' ' || *p == '\t' || *p == '\r' || *p == '\n')
			p++;
		std::string lit(p, YYCURSOR - p);
		yylval.string = DupString(lit.c_str());
		return TK_DURATION_LITERAL;
	}
	"d\"" {
		int errorCode = 0;
		std::string str = UnescapeQuotes(YYCURSOR, errorCode);
		if (errorCode != 0)
			return errorCode;
		yylval.string = DupString(str.c_str());
		return TK_DATETIME_LITERAL;
	}
	"v\"" {
		int errorCode = 0;
		std::string str = UnescapeQuotes(YYCURSOR, errorCode);
		if (errorCode != 0)
			return errorCode;
		yylval.string = DupString(str.c_str());
		return TK_VERSION_LITERAL;
	}
	[0-9]+ {
		yylval.integer = std::stoi(std::string((const char*)yycursor, YYCURSOR - yycursor));
		return TK_INTEGER_LITERAL;
	}
	[a-zA-Z_][a-zA-Z0-9_]* {
		const char* p = yycursor;
		while (*p == ' ' || *p == '\t' || *p == '\r' || *p == '\n')
			p++;
		std::string tmp = std::string(p, YYCURSOR - p);
		yylval.string = DupString(tmp.c_str());
		return TK_IDENTIFIER;
	}
	"\"" {
		int errorCode = 0;
		std::string str = UnescapeQuotes(YYCURSOR, errorCode);
		if (errorCode != 0)
			return errorCode;
		yylval.string = DupString(str.c_str());
		return TK_STRING_LITERAL;
	}
	"=="              { return TK_EQ; }
	"="               { return TK_EQ; }
	"!="              { return TK_NE; }
	"<"               { return TK_LT; }
	"<="              { return TK_LE; }
	">"               { return TK_GT; }
	">="              { return TK_GE; }
	"("               { return TK_LPAREN; }
	")"               { return TK_RPAREN; }
	"+"               { return TK_PLUS; }
	"-"               { return TK_MINUS; }
	"*"               { return TK_STAR; }
	"/"               { return TK_SLASH; }
	"%"               { return TK_MOD; }
	$                 { return 0; }
	","               { return TK_COMMA; }
	.                 { return LEXER_ERR_UNKNOWN_CHAR; }
	*/
}

std::string FilterLexer::UnescapeQuotes(char*& str, int& errorCode)
{
	errorCode = LEXER_ERR_UNTERMINATED_STRING;
	std::string result;
	while (*str != '\0')
	{
		if (*str == '"')
		{
			if (*(str + 1) == '"')
			{
				result += '"';
				str += 2;
			}
			else
			{
				str++;
				errorCode = 0;
				break;
			}
		}
		else
		{
			result += *str++;
		}
	}
	return result;
}

const char* FilterLexer::DupString(const char* str)
{
	char* newStr = _strdup(str);
	strings.push_back(newStr);
	return newStr;
}

void FilterLexer::FreeStrings()
{
	for (auto str : strings)
		free(str);
	strings.clear();
}

</file>

<file path="Winmerge-Src/Src/FilterEngine/FilterParser.cpp">
#include "pch.h"
#include "FilterParser.c"
</file>

<file path="Winmerge-Src/Src/FilterEngine/FilterParser.h">
#define TK_AND                              1
#define TK_OR                               2
#define TK_NOT                              3
#define TK_TRUE_LITERAL                     4
#define TK_FALSE_LITERAL                    5
#define TK_INTEGER_LITERAL                  6
#define TK_STRING_LITERAL                   7
#define TK_SIZE_LITERAL                     8
#define TK_DATETIME_LITERAL                 9
#define TK_DURATION_LITERAL                10
#define TK_VERSION_LITERAL                 11
#define TK_IDENTIFIER                      12
#define TK_EQ                              13
#define TK_NE                              14
#define TK_LT                              15
#define TK_LE                              16
#define TK_GT                              17
#define TK_GE                              18
#define TK_CONTAINS                        19
#define TK_RECONTAINS                      20
#define TK_LIKE                            21
#define TK_MATCHES                         22
#define TK_LPAREN                          23
#define TK_RPAREN                          24
#define TK_PLUS                            25
#define TK_MINUS                           26
#define TK_STAR                            27
#define TK_SLASH                           28
#define TK_MOD                             29
#define TK_COMMA                           30
</file>

<file path="Winmerge-Src/Src/FilterEngine/FilterParser.out">
State 0:
          filter_expr ::= * or_expr
          or_expr ::= * or_expr OR and_expr
          or_expr ::= * and_expr
          and_expr ::= * and_expr AND not_expr
          and_expr ::= * not_expr
          not_expr ::= * NOT not_expr
          not_expr ::= * cmp_expr
          cmp_expr ::= * arithmetic EQ arithmetic
          cmp_expr ::= * arithmetic NE arithmetic
          cmp_expr ::= * arithmetic LT arithmetic
          cmp_expr ::= * arithmetic LE arithmetic
          cmp_expr ::= * arithmetic GT arithmetic
          cmp_expr ::= * arithmetic GE arithmetic
          cmp_expr ::= * arithmetic CONTAINS arithmetic
          cmp_expr ::= * arithmetic NOT CONTAINS arithmetic
          cmp_expr ::= * arithmetic RECONTAINS arithmetic
          cmp_expr ::= * arithmetic NOT RECONTAINS arithmetic
          cmp_expr ::= * arithmetic LIKE arithmetic
          cmp_expr ::= * arithmetic NOT LIKE arithmetic
          cmp_expr ::= * arithmetic MATCHES arithmetic
          cmp_expr ::= * arithmetic NOT MATCHES arithmetic
          cmp_expr ::= * arithmetic
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= * unary
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN

                           NOT shift        5      
                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                   filter_expr accept
                       or_expr shift        46     
                      and_expr shift        48     
                      not_expr shift        48       /* because not_expr==and_expr */
                      cmp_expr shift        48       /* because cmp_expr==not_expr */
                    arithmetic shift        27     
                         unary shift        27       /* because unary==arithmetic */
                          term shift        27       /* because term==unary */

State 1:
          or_expr ::= * or_expr OR and_expr
          or_expr ::= * and_expr
          and_expr ::= * and_expr AND not_expr
          and_expr ::= * not_expr
          not_expr ::= * NOT not_expr
          not_expr ::= * cmp_expr
          cmp_expr ::= * arithmetic EQ arithmetic
          cmp_expr ::= * arithmetic NE arithmetic
          cmp_expr ::= * arithmetic LT arithmetic
          cmp_expr ::= * arithmetic LE arithmetic
          cmp_expr ::= * arithmetic GT arithmetic
          cmp_expr ::= * arithmetic GE arithmetic
          cmp_expr ::= * arithmetic CONTAINS arithmetic
          cmp_expr ::= * arithmetic NOT CONTAINS arithmetic
          cmp_expr ::= * arithmetic RECONTAINS arithmetic
          cmp_expr ::= * arithmetic NOT RECONTAINS arithmetic
          cmp_expr ::= * arithmetic LIKE arithmetic
          cmp_expr ::= * arithmetic NOT LIKE arithmetic
          cmp_expr ::= * arithmetic MATCHES arithmetic
          cmp_expr ::= * arithmetic NOT MATCHES arithmetic
          cmp_expr ::= * arithmetic
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= * unary
          expr ::= * or_expr
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= IDENTIFIER LPAREN * RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= IDENTIFIER LPAREN * expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN
          expr_list ::= * expr
          expr_list ::= * expr_list COMMA expr

                           NOT shift        5      
                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                        RPAREN shift-reduce 32     term ::= IDENTIFIER LPAREN RPAREN
                         MINUS shift        26     
                       or_expr shift        49     
                      and_expr shift        48     
                      not_expr shift        48       /* because not_expr==and_expr */
                      cmp_expr shift        48       /* because cmp_expr==not_expr */
                    arithmetic shift        27     
                         unary shift        27       /* because unary==arithmetic */
                          expr shift-reduce 36     expr_list ::= expr
                          term shift        27       /* because term==unary */
                     expr_list shift        45     

State 2:
          or_expr ::= * or_expr OR and_expr
          or_expr ::= * and_expr
          and_expr ::= * and_expr AND not_expr
          and_expr ::= * not_expr
          not_expr ::= * NOT not_expr
          not_expr ::= * cmp_expr
          cmp_expr ::= * arithmetic EQ arithmetic
          cmp_expr ::= * arithmetic NE arithmetic
          cmp_expr ::= * arithmetic LT arithmetic
          cmp_expr ::= * arithmetic LE arithmetic
          cmp_expr ::= * arithmetic GT arithmetic
          cmp_expr ::= * arithmetic GE arithmetic
          cmp_expr ::= * arithmetic CONTAINS arithmetic
          cmp_expr ::= * arithmetic NOT CONTAINS arithmetic
          cmp_expr ::= * arithmetic RECONTAINS arithmetic
          cmp_expr ::= * arithmetic NOT RECONTAINS arithmetic
          cmp_expr ::= * arithmetic LIKE arithmetic
          cmp_expr ::= * arithmetic NOT LIKE arithmetic
          cmp_expr ::= * arithmetic MATCHES arithmetic
          cmp_expr ::= * arithmetic NOT MATCHES arithmetic
          cmp_expr ::= * arithmetic
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= * unary
          expr ::= * or_expr
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN
          term ::= LPAREN * expr RPAREN

                           NOT shift        5      
                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                       or_expr shift        49     
                      and_expr shift        48     
                      not_expr shift        48       /* because not_expr==and_expr */
                      cmp_expr shift        48       /* because cmp_expr==not_expr */
                    arithmetic shift        27     
                         unary shift        27       /* because unary==arithmetic */
                          expr shift        47     
                          term shift        27       /* because term==unary */

State 3:
          or_expr ::= * or_expr OR and_expr
          or_expr ::= * and_expr
          and_expr ::= * and_expr AND not_expr
          and_expr ::= * not_expr
          not_expr ::= * NOT not_expr
          not_expr ::= * cmp_expr
          cmp_expr ::= * arithmetic EQ arithmetic
          cmp_expr ::= * arithmetic NE arithmetic
          cmp_expr ::= * arithmetic LT arithmetic
          cmp_expr ::= * arithmetic LE arithmetic
          cmp_expr ::= * arithmetic GT arithmetic
          cmp_expr ::= * arithmetic GE arithmetic
          cmp_expr ::= * arithmetic CONTAINS arithmetic
          cmp_expr ::= * arithmetic NOT CONTAINS arithmetic
          cmp_expr ::= * arithmetic RECONTAINS arithmetic
          cmp_expr ::= * arithmetic NOT RECONTAINS arithmetic
          cmp_expr ::= * arithmetic LIKE arithmetic
          cmp_expr ::= * arithmetic NOT LIKE arithmetic
          cmp_expr ::= * arithmetic MATCHES arithmetic
          cmp_expr ::= * arithmetic NOT MATCHES arithmetic
          cmp_expr ::= * arithmetic
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= * unary
          expr ::= * or_expr
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN
          expr_list ::= expr_list COMMA * expr

                           NOT shift        5      
                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                       or_expr shift        49     
                      and_expr shift        48     
                      not_expr shift        48       /* because not_expr==and_expr */
                      cmp_expr shift        48       /* because cmp_expr==not_expr */
                    arithmetic shift        27     
                         unary shift        27       /* because unary==arithmetic */
                          expr shift-reduce 37     expr_list ::= expr_list COMMA expr
                          term shift        27       /* because term==unary */

State 4:
          or_expr ::= or_expr OR * and_expr
          and_expr ::= * and_expr AND not_expr
          and_expr ::= * not_expr
          not_expr ::= * NOT not_expr
          not_expr ::= * cmp_expr
          cmp_expr ::= * arithmetic EQ arithmetic
          cmp_expr ::= * arithmetic NE arithmetic
          cmp_expr ::= * arithmetic LT arithmetic
          cmp_expr ::= * arithmetic LE arithmetic
          cmp_expr ::= * arithmetic GT arithmetic
          cmp_expr ::= * arithmetic GE arithmetic
          cmp_expr ::= * arithmetic CONTAINS arithmetic
          cmp_expr ::= * arithmetic NOT CONTAINS arithmetic
          cmp_expr ::= * arithmetic RECONTAINS arithmetic
          cmp_expr ::= * arithmetic NOT RECONTAINS arithmetic
          cmp_expr ::= * arithmetic LIKE arithmetic
          cmp_expr ::= * arithmetic NOT LIKE arithmetic
          cmp_expr ::= * arithmetic MATCHES arithmetic
          cmp_expr ::= * arithmetic NOT MATCHES arithmetic
          cmp_expr ::= * arithmetic
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= * unary
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN

                           NOT shift        5      
                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                      and_expr shift        51     
                      not_expr shift        51       /* because not_expr==and_expr */
                      cmp_expr shift        51       /* because cmp_expr==not_expr */
                    arithmetic shift        27     
                         unary shift        27       /* because unary==arithmetic */
                          term shift        27       /* because term==unary */

State 5:
          not_expr ::= * NOT not_expr
          not_expr ::= NOT * not_expr
          not_expr ::= * cmp_expr
          cmp_expr ::= * arithmetic EQ arithmetic
          cmp_expr ::= * arithmetic NE arithmetic
          cmp_expr ::= * arithmetic LT arithmetic
          cmp_expr ::= * arithmetic LE arithmetic
          cmp_expr ::= * arithmetic GT arithmetic
          cmp_expr ::= * arithmetic GE arithmetic
          cmp_expr ::= * arithmetic CONTAINS arithmetic
          cmp_expr ::= * arithmetic NOT CONTAINS arithmetic
          cmp_expr ::= * arithmetic RECONTAINS arithmetic
          cmp_expr ::= * arithmetic NOT RECONTAINS arithmetic
          cmp_expr ::= * arithmetic LIKE arithmetic
          cmp_expr ::= * arithmetic NOT LIKE arithmetic
          cmp_expr ::= * arithmetic MATCHES arithmetic
          cmp_expr ::= * arithmetic NOT MATCHES arithmetic
          cmp_expr ::= * arithmetic
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= * unary
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN

                           NOT shift        5      
                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                      not_expr shift-reduce 3      not_expr ::= NOT not_expr
                      cmp_expr shift-reduce 3      not_expr ::= NOT not_expr  /* because cmp_expr==not_expr */
                    arithmetic shift        27     
                         unary shift        27       /* because unary==arithmetic */
                          term shift        27       /* because term==unary */

State 6:
          and_expr ::= and_expr AND * not_expr
          not_expr ::= * NOT not_expr
          not_expr ::= * cmp_expr
          cmp_expr ::= * arithmetic EQ arithmetic
          cmp_expr ::= * arithmetic NE arithmetic
          cmp_expr ::= * arithmetic LT arithmetic
          cmp_expr ::= * arithmetic LE arithmetic
          cmp_expr ::= * arithmetic GT arithmetic
          cmp_expr ::= * arithmetic GE arithmetic
          cmp_expr ::= * arithmetic CONTAINS arithmetic
          cmp_expr ::= * arithmetic NOT CONTAINS arithmetic
          cmp_expr ::= * arithmetic RECONTAINS arithmetic
          cmp_expr ::= * arithmetic NOT RECONTAINS arithmetic
          cmp_expr ::= * arithmetic LIKE arithmetic
          cmp_expr ::= * arithmetic NOT LIKE arithmetic
          cmp_expr ::= * arithmetic MATCHES arithmetic
          cmp_expr ::= * arithmetic NOT MATCHES arithmetic
          cmp_expr ::= * arithmetic
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= * unary
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN

                           NOT shift        5      
                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                      not_expr shift-reduce 2      and_expr ::= and_expr AND not_expr
                      cmp_expr shift-reduce 2      and_expr ::= and_expr AND not_expr  /* because cmp_expr==not_expr */
                    arithmetic shift        27     
                         unary shift        27       /* because unary==arithmetic */
                          term shift        27       /* because term==unary */

State 7:
          cmp_expr ::= arithmetic MATCHES * arithmetic
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= * unary
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN

                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                    arithmetic shift        28     
                         unary shift        28       /* because unary==arithmetic */
                          term shift        28       /* because term==unary */

State 8:
          cmp_expr ::= arithmetic LIKE * arithmetic
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= * unary
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN

                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                    arithmetic shift        29     
                         unary shift        29       /* because unary==arithmetic */
                          term shift        29       /* because term==unary */

State 9:
          cmp_expr ::= arithmetic RECONTAINS * arithmetic
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= * unary
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN

                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                    arithmetic shift        30     
                         unary shift        30       /* because unary==arithmetic */
                          term shift        30       /* because term==unary */

State 10:
          cmp_expr ::= arithmetic NOT MATCHES * arithmetic
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= * unary
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN

                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                    arithmetic shift        31     
                         unary shift        31       /* because unary==arithmetic */
                          term shift        31       /* because term==unary */

State 11:
          cmp_expr ::= arithmetic NOT LIKE * arithmetic
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= * unary
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN

                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                    arithmetic shift        32     
                         unary shift        32       /* because unary==arithmetic */
                          term shift        32       /* because term==unary */

State 12:
          cmp_expr ::= arithmetic NOT RECONTAINS * arithmetic
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= * unary
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN

                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                    arithmetic shift        33     
                         unary shift        33       /* because unary==arithmetic */
                          term shift        33       /* because term==unary */

State 13:
          cmp_expr ::= arithmetic NOT CONTAINS * arithmetic
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= * unary
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN

                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                    arithmetic shift        34     
                         unary shift        34       /* because unary==arithmetic */
                          term shift        34       /* because term==unary */

State 14:
          cmp_expr ::= arithmetic CONTAINS * arithmetic
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= * unary
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN

                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                    arithmetic shift        35     
                         unary shift        35       /* because unary==arithmetic */
                          term shift        35       /* because term==unary */

State 15:
          cmp_expr ::= arithmetic GE * arithmetic
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= * unary
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN

                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                    arithmetic shift        36     
                         unary shift        36       /* because unary==arithmetic */
                          term shift        36       /* because term==unary */

State 16:
          cmp_expr ::= arithmetic GT * arithmetic
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= * unary
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN

                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                    arithmetic shift        37     
                         unary shift        37       /* because unary==arithmetic */
                          term shift        37       /* because term==unary */

State 17:
          cmp_expr ::= arithmetic LE * arithmetic
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= * unary
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN

                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                    arithmetic shift        38     
                         unary shift        38       /* because unary==arithmetic */
                          term shift        38       /* because term==unary */

State 18:
          cmp_expr ::= arithmetic LT * arithmetic
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= * unary
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN

                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                    arithmetic shift        39     
                         unary shift        39       /* because unary==arithmetic */
                          term shift        39       /* because term==unary */

State 19:
          cmp_expr ::= arithmetic NE * arithmetic
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= * unary
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN

                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                    arithmetic shift        40     
                         unary shift        40       /* because unary==arithmetic */
                          term shift        40       /* because term==unary */

State 20:
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= arithmetic MOD * arithmetic
          arithmetic ::= * unary
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN

                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                    arithmetic shift-reduce 22     arithmetic ::= arithmetic MOD arithmetic
                         unary shift-reduce 22     arithmetic ::= arithmetic MOD arithmetic  /* because unary==arithmetic */
                          term shift-reduce 22     arithmetic ::= arithmetic MOD arithmetic  /* because term==unary */

State 21:
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= arithmetic SLASH * arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= * unary
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN

                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                    arithmetic shift-reduce 21     arithmetic ::= arithmetic SLASH arithmetic
                         unary shift-reduce 21     arithmetic ::= arithmetic SLASH arithmetic  /* because unary==arithmetic */
                          term shift-reduce 21     arithmetic ::= arithmetic SLASH arithmetic  /* because term==unary */

State 22:
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= arithmetic STAR * arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= * unary
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN

                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                    arithmetic shift-reduce 20     arithmetic ::= arithmetic STAR arithmetic
                         unary shift-reduce 20     arithmetic ::= arithmetic STAR arithmetic  /* because unary==arithmetic */
                          term shift-reduce 20     arithmetic ::= arithmetic STAR arithmetic  /* because term==unary */

State 23:
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= arithmetic MINUS * arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= * unary
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN

                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                    arithmetic shift        43     
                         unary shift        43       /* because unary==arithmetic */
                          term shift        43       /* because term==unary */

State 24:
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= arithmetic PLUS * arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= * unary
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN

                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                    arithmetic shift        44     
                         unary shift        44       /* because unary==arithmetic */
                          term shift        44       /* because term==unary */

State 25:
          cmp_expr ::= arithmetic EQ * arithmetic
          arithmetic ::= * arithmetic PLUS arithmetic
          arithmetic ::= * arithmetic MINUS arithmetic
          arithmetic ::= * arithmetic STAR arithmetic
          arithmetic ::= * arithmetic SLASH arithmetic
          arithmetic ::= * arithmetic MOD arithmetic
          arithmetic ::= * unary
          unary ::= * MINUS unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN

                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                    arithmetic shift        41     
                         unary shift        41       /* because unary==arithmetic */
                          term shift        41       /* because term==unary */

State 26:
          unary ::= * MINUS unary
          unary ::= MINUS * unary
          unary ::= * term
          term ::= * TRUE_LITERAL
          term ::= * FALSE_LITERAL
          term ::= * INTEGER_LITERAL
          term ::= * STRING_LITERAL
          term ::= * SIZE_LITERAL
          term ::= * DATETIME_LITERAL
          term ::= * DURATION_LITERAL
          term ::= * VERSION_LITERAL
          term ::= * IDENTIFIER LPAREN RPAREN
          term ::= * IDENTIFIER LPAREN expr_list RPAREN
          term ::= * IDENTIFIER
          term ::= * LPAREN expr RPAREN

                  TRUE_LITERAL shift-reduce 24     term ::= TRUE_LITERAL
                 FALSE_LITERAL shift-reduce 25     term ::= FALSE_LITERAL
               INTEGER_LITERAL shift-reduce 26     term ::= INTEGER_LITERAL
                STRING_LITERAL shift-reduce 27     term ::= STRING_LITERAL
                  SIZE_LITERAL shift-reduce 28     term ::= SIZE_LITERAL
              DATETIME_LITERAL shift-reduce 29     term ::= DATETIME_LITERAL
              DURATION_LITERAL shift-reduce 30     term ::= DURATION_LITERAL
               VERSION_LITERAL shift-reduce 31     term ::= VERSION_LITERAL
                    IDENTIFIER shift        50     
                        LPAREN shift        2      
                         MINUS shift        26     
                         unary shift-reduce 23     unary ::= MINUS unary
                          term shift-reduce 23     unary ::= MINUS unary  /* because term==unary */

State 27:
          cmp_expr ::= arithmetic * EQ arithmetic
          cmp_expr ::= arithmetic * NE arithmetic
          cmp_expr ::= arithmetic * LT arithmetic
          cmp_expr ::= arithmetic * LE arithmetic
          cmp_expr ::= arithmetic * GT arithmetic
          cmp_expr ::= arithmetic * GE arithmetic
          cmp_expr ::= arithmetic * CONTAINS arithmetic
          cmp_expr ::= arithmetic * NOT CONTAINS arithmetic
          cmp_expr ::= arithmetic * RECONTAINS arithmetic
          cmp_expr ::= arithmetic * NOT RECONTAINS arithmetic
          cmp_expr ::= arithmetic * LIKE arithmetic
          cmp_expr ::= arithmetic * NOT LIKE arithmetic
          cmp_expr ::= arithmetic * MATCHES arithmetic
          cmp_expr ::= arithmetic * NOT MATCHES arithmetic
     (41) cmp_expr ::= arithmetic *
          arithmetic ::= arithmetic * PLUS arithmetic
          arithmetic ::= arithmetic * MINUS arithmetic
          arithmetic ::= arithmetic * STAR arithmetic
          arithmetic ::= arithmetic * SLASH arithmetic
          arithmetic ::= arithmetic * MOD arithmetic

                           NOT shift        42     
                            EQ shift        25     
                            NE shift        19     
                            LT shift        18     
                            LE shift        17     
                            GT shift        16     
                            GE shift        15     
                      CONTAINS shift        14     
                    RECONTAINS shift        9      
                          LIKE shift        8      
                       MATCHES shift        7      
                          PLUS shift        24     
                         MINUS shift        23     
                          STAR shift        22     
                         SLASH shift        21     
                           MOD shift        20     
                     {default} reduce       41     cmp_expr ::= arithmetic

State 28:
     (16) cmp_expr ::= arithmetic MATCHES arithmetic *
          arithmetic ::= arithmetic * PLUS arithmetic
          arithmetic ::= arithmetic * MINUS arithmetic
          arithmetic ::= arithmetic * STAR arithmetic
          arithmetic ::= arithmetic * SLASH arithmetic
          arithmetic ::= arithmetic * MOD arithmetic

                          PLUS shift        24     
                         MINUS shift        23     
                          STAR shift        22     
                         SLASH shift        21     
                           MOD shift        20     
                     {default} reduce       16     cmp_expr ::= arithmetic MATCHES arithmetic

State 29:
     (14) cmp_expr ::= arithmetic LIKE arithmetic *
          arithmetic ::= arithmetic * PLUS arithmetic
          arithmetic ::= arithmetic * MINUS arithmetic
          arithmetic ::= arithmetic * STAR arithmetic
          arithmetic ::= arithmetic * SLASH arithmetic
          arithmetic ::= arithmetic * MOD arithmetic

                          PLUS shift        24     
                         MINUS shift        23     
                          STAR shift        22     
                         SLASH shift        21     
                           MOD shift        20     
                     {default} reduce       14     cmp_expr ::= arithmetic LIKE arithmetic

State 30:
     (12) cmp_expr ::= arithmetic RECONTAINS arithmetic *
          arithmetic ::= arithmetic * PLUS arithmetic
          arithmetic ::= arithmetic * MINUS arithmetic
          arithmetic ::= arithmetic * STAR arithmetic
          arithmetic ::= arithmetic * SLASH arithmetic
          arithmetic ::= arithmetic * MOD arithmetic

                          PLUS shift        24     
                         MINUS shift        23     
                          STAR shift        22     
                         SLASH shift        21     
                           MOD shift        20     
                     {default} reduce       12     cmp_expr ::= arithmetic RECONTAINS arithmetic

State 31:
     (17) cmp_expr ::= arithmetic NOT MATCHES arithmetic *
          arithmetic ::= arithmetic * PLUS arithmetic
          arithmetic ::= arithmetic * MINUS arithmetic
          arithmetic ::= arithmetic * STAR arithmetic
          arithmetic ::= arithmetic * SLASH arithmetic
          arithmetic ::= arithmetic * MOD arithmetic

                          PLUS shift        24     
                         MINUS shift        23     
                          STAR shift        22     
                         SLASH shift        21     
                           MOD shift        20     
                     {default} reduce       17     cmp_expr ::= arithmetic NOT MATCHES arithmetic

State 32:
     (15) cmp_expr ::= arithmetic NOT LIKE arithmetic *
          arithmetic ::= arithmetic * PLUS arithmetic
          arithmetic ::= arithmetic * MINUS arithmetic
          arithmetic ::= arithmetic * STAR arithmetic
          arithmetic ::= arithmetic * SLASH arithmetic
          arithmetic ::= arithmetic * MOD arithmetic

                          PLUS shift        24     
                         MINUS shift        23     
                          STAR shift        22     
                         SLASH shift        21     
                           MOD shift        20     
                     {default} reduce       15     cmp_expr ::= arithmetic NOT LIKE arithmetic

State 33:
     (13) cmp_expr ::= arithmetic NOT RECONTAINS arithmetic *
          arithmetic ::= arithmetic * PLUS arithmetic
          arithmetic ::= arithmetic * MINUS arithmetic
          arithmetic ::= arithmetic * STAR arithmetic
          arithmetic ::= arithmetic * SLASH arithmetic
          arithmetic ::= arithmetic * MOD arithmetic

                          PLUS shift        24     
                         MINUS shift        23     
                          STAR shift        22     
                         SLASH shift        21     
                           MOD shift        20     
                     {default} reduce       13     cmp_expr ::= arithmetic NOT RECONTAINS arithmetic

State 34:
     (11) cmp_expr ::= arithmetic NOT CONTAINS arithmetic *
          arithmetic ::= arithmetic * PLUS arithmetic
          arithmetic ::= arithmetic * MINUS arithmetic
          arithmetic ::= arithmetic * STAR arithmetic
          arithmetic ::= arithmetic * SLASH arithmetic
          arithmetic ::= arithmetic * MOD arithmetic

                          PLUS shift        24     
                         MINUS shift        23     
                          STAR shift        22     
                         SLASH shift        21     
                           MOD shift        20     
                     {default} reduce       11     cmp_expr ::= arithmetic NOT CONTAINS arithmetic

State 35:
     (10) cmp_expr ::= arithmetic CONTAINS arithmetic *
          arithmetic ::= arithmetic * PLUS arithmetic
          arithmetic ::= arithmetic * MINUS arithmetic
          arithmetic ::= arithmetic * STAR arithmetic
          arithmetic ::= arithmetic * SLASH arithmetic
          arithmetic ::= arithmetic * MOD arithmetic

                          PLUS shift        24     
                         MINUS shift        23     
                          STAR shift        22     
                         SLASH shift        21     
                           MOD shift        20     
                     {default} reduce       10     cmp_expr ::= arithmetic CONTAINS arithmetic

State 36:
      (9) cmp_expr ::= arithmetic GE arithmetic *
          arithmetic ::= arithmetic * PLUS arithmetic
          arithmetic ::= arithmetic * MINUS arithmetic
          arithmetic ::= arithmetic * STAR arithmetic
          arithmetic ::= arithmetic * SLASH arithmetic
          arithmetic ::= arithmetic * MOD arithmetic

                          PLUS shift        24     
                         MINUS shift        23     
                          STAR shift        22     
                         SLASH shift        21     
                           MOD shift        20     
                     {default} reduce       9      cmp_expr ::= arithmetic GE arithmetic

State 37:
      (8) cmp_expr ::= arithmetic GT arithmetic *
          arithmetic ::= arithmetic * PLUS arithmetic
          arithmetic ::= arithmetic * MINUS arithmetic
          arithmetic ::= arithmetic * STAR arithmetic
          arithmetic ::= arithmetic * SLASH arithmetic
          arithmetic ::= arithmetic * MOD arithmetic

                          PLUS shift        24     
                         MINUS shift        23     
                          STAR shift        22     
                         SLASH shift        21     
                           MOD shift        20     
                     {default} reduce       8      cmp_expr ::= arithmetic GT arithmetic

State 38:
      (7) cmp_expr ::= arithmetic LE arithmetic *
          arithmetic ::= arithmetic * PLUS arithmetic
          arithmetic ::= arithmetic * MINUS arithmetic
          arithmetic ::= arithmetic * STAR arithmetic
          arithmetic ::= arithmetic * SLASH arithmetic
          arithmetic ::= arithmetic * MOD arithmetic

                          PLUS shift        24     
                         MINUS shift        23     
                          STAR shift        22     
                         SLASH shift        21     
                           MOD shift        20     
                     {default} reduce       7      cmp_expr ::= arithmetic LE arithmetic

State 39:
      (6) cmp_expr ::= arithmetic LT arithmetic *
          arithmetic ::= arithmetic * PLUS arithmetic
          arithmetic ::= arithmetic * MINUS arithmetic
          arithmetic ::= arithmetic * STAR arithmetic
          arithmetic ::= arithmetic * SLASH arithmetic
          arithmetic ::= arithmetic * MOD arithmetic

                          PLUS shift        24     
                         MINUS shift        23     
                          STAR shift        22     
                         SLASH shift        21     
                           MOD shift        20     
                     {default} reduce       6      cmp_expr ::= arithmetic LT arithmetic

State 40:
      (5) cmp_expr ::= arithmetic NE arithmetic *
          arithmetic ::= arithmetic * PLUS arithmetic
          arithmetic ::= arithmetic * MINUS arithmetic
          arithmetic ::= arithmetic * STAR arithmetic
          arithmetic ::= arithmetic * SLASH arithmetic
          arithmetic ::= arithmetic * MOD arithmetic

                          PLUS shift        24     
                         MINUS shift        23     
                          STAR shift        22     
                         SLASH shift        21     
                           MOD shift        20     
                     {default} reduce       5      cmp_expr ::= arithmetic NE arithmetic

State 41:
      (4) cmp_expr ::= arithmetic EQ arithmetic *
          arithmetic ::= arithmetic * PLUS arithmetic
          arithmetic ::= arithmetic * MINUS arithmetic
          arithmetic ::= arithmetic * STAR arithmetic
          arithmetic ::= arithmetic * SLASH arithmetic
          arithmetic ::= arithmetic * MOD arithmetic

                          PLUS shift        24     
                         MINUS shift        23     
                          STAR shift        22     
                         SLASH shift        21     
                           MOD shift        20     
                     {default} reduce       4      cmp_expr ::= arithmetic EQ arithmetic

State 42:
          cmp_expr ::= arithmetic NOT * CONTAINS arithmetic
          cmp_expr ::= arithmetic NOT * RECONTAINS arithmetic
          cmp_expr ::= arithmetic NOT * LIKE arithmetic
          cmp_expr ::= arithmetic NOT * MATCHES arithmetic

                      CONTAINS shift        13     
                    RECONTAINS shift        12     
                          LIKE shift        11     
                       MATCHES shift        10     

State 43:
          arithmetic ::= arithmetic * PLUS arithmetic
          arithmetic ::= arithmetic * MINUS arithmetic
     (19) arithmetic ::= arithmetic MINUS arithmetic *
          arithmetic ::= arithmetic * STAR arithmetic
          arithmetic ::= arithmetic * SLASH arithmetic
          arithmetic ::= arithmetic * MOD arithmetic

                          STAR shift        22     
                         SLASH shift        21     
                           MOD shift        20     
                     {default} reduce       19     arithmetic ::= arithmetic MINUS arithmetic

State 44:
          arithmetic ::= arithmetic * PLUS arithmetic
     (18) arithmetic ::= arithmetic PLUS arithmetic *
          arithmetic ::= arithmetic * MINUS arithmetic
          arithmetic ::= arithmetic * STAR arithmetic
          arithmetic ::= arithmetic * SLASH arithmetic
          arithmetic ::= arithmetic * MOD arithmetic

                          STAR shift        22     
                         SLASH shift        21     
                           MOD shift        20     
                     {default} reduce       18     arithmetic ::= arithmetic PLUS arithmetic

State 45:
          term ::= IDENTIFIER LPAREN expr_list * RPAREN
          expr_list ::= expr_list * COMMA expr

                        RPAREN shift-reduce 33     term ::= IDENTIFIER LPAREN expr_list RPAREN
                         COMMA shift        3      

State 46:
      (0) filter_expr ::= or_expr *
          or_expr ::= or_expr * OR and_expr

                             $ reduce       0      filter_expr ::= or_expr
                            OR shift        4      

State 47:
          term ::= LPAREN expr * RPAREN

                        RPAREN shift-reduce 35     term ::= LPAREN expr RPAREN

State 48:
     (38) or_expr ::= and_expr *
          and_expr ::= and_expr * AND not_expr

                           AND shift        6      
                     {default} reduce       38     or_expr ::= and_expr

State 49:
          or_expr ::= or_expr * OR and_expr
     (43) expr ::= or_expr *

                            OR shift        4      
                     {default} reduce       43     expr ::= or_expr

State 50:
          term ::= IDENTIFIER * LPAREN RPAREN
          term ::= IDENTIFIER * LPAREN expr_list RPAREN
     (34) term ::= IDENTIFIER *

                        LPAREN shift        1      
                     {default} reduce       34     term ::= IDENTIFIER

State 51:
      (1) or_expr ::= or_expr OR and_expr *
          and_expr ::= and_expr * AND not_expr

                           AND shift        6      
                     {default} reduce       1      or_expr ::= or_expr OR and_expr

----------------------------------------------------
Symbols:
The first-set of non-terminals is shown after the name.

    0: $:
    1: AND (precedence=2)
    2: OR (precedence=1)
    3: NOT (precedence=4)
    4: TRUE_LITERAL
    5: FALSE_LITERAL
    6: INTEGER_LITERAL
    7: STRING_LITERAL
    8: SIZE_LITERAL
    9: DATETIME_LITERAL
   10: DURATION_LITERAL
   11: VERSION_LITERAL
   12: IDENTIFIER
   13: EQ (precedence=3)
   14: NE (precedence=3)
   15: LT (precedence=3)
   16: LE (precedence=3)
   17: GT (precedence=3)
   18: GE (precedence=3)
   19: CONTAINS (precedence=3)
   20: RECONTAINS (precedence=3)
   21: LIKE (precedence=3)
   22: MATCHES (precedence=3)
   23: LPAREN
   24: RPAREN
   25: PLUS (precedence=5)
   26: MINUS (precedence=5)
   27: STAR (precedence=6)
   28: SLASH (precedence=6)
   29: MOD (precedence=6)
   30: COMMA
   31: filter_expr: NOT TRUE_LITERAL FALSE_LITERAL INTEGER_LITERAL STRING_LITERAL SIZE_LITERAL DATETIME_LITERAL DURATION_LITERAL VERSION_LITERAL IDENTIFIER LPAREN MINUS
   32: or_expr: NOT TRUE_LITERAL FALSE_LITERAL INTEGER_LITERAL STRING_LITERAL SIZE_LITERAL DATETIME_LITERAL DURATION_LITERAL VERSION_LITERAL IDENTIFIER LPAREN MINUS
   33: and_expr: NOT TRUE_LITERAL FALSE_LITERAL INTEGER_LITERAL STRING_LITERAL SIZE_LITERAL DATETIME_LITERAL DURATION_LITERAL VERSION_LITERAL IDENTIFIER LPAREN MINUS
   34: not_expr: NOT TRUE_LITERAL FALSE_LITERAL INTEGER_LITERAL STRING_LITERAL SIZE_LITERAL DATETIME_LITERAL DURATION_LITERAL VERSION_LITERAL IDENTIFIER LPAREN MINUS
   35: cmp_expr: TRUE_LITERAL FALSE_LITERAL INTEGER_LITERAL STRING_LITERAL SIZE_LITERAL DATETIME_LITERAL DURATION_LITERAL VERSION_LITERAL IDENTIFIER LPAREN MINUS
   36: arithmetic: TRUE_LITERAL FALSE_LITERAL INTEGER_LITERAL STRING_LITERAL SIZE_LITERAL DATETIME_LITERAL DURATION_LITERAL VERSION_LITERAL IDENTIFIER LPAREN MINUS
   37: unary: TRUE_LITERAL FALSE_LITERAL INTEGER_LITERAL STRING_LITERAL SIZE_LITERAL DATETIME_LITERAL DURATION_LITERAL VERSION_LITERAL IDENTIFIER LPAREN MINUS
   38: expr: NOT TRUE_LITERAL FALSE_LITERAL INTEGER_LITERAL STRING_LITERAL SIZE_LITERAL DATETIME_LITERAL DURATION_LITERAL VERSION_LITERAL IDENTIFIER LPAREN MINUS
   39: term: TRUE_LITERAL FALSE_LITERAL INTEGER_LITERAL STRING_LITERAL SIZE_LITERAL DATETIME_LITERAL DURATION_LITERAL VERSION_LITERAL IDENTIFIER LPAREN
   40: expr_list: NOT TRUE_LITERAL FALSE_LITERAL INTEGER_LITERAL STRING_LITERAL SIZE_LITERAL DATETIME_LITERAL DURATION_LITERAL VERSION_LITERAL IDENTIFIER LPAREN MINUS
----------------------------------------------------
Syntax-only Symbols:
The following symbols never carry semantic content.

$ AND OR NOT TRUE_LITERAL FALSE_LITERAL EQ NE LT LE GT GE CONTAINS
RECONTAINS LIKE MATCHES LPAREN RPAREN PLUS MINUS STAR SLASH MOD COMMA
filter_expr
----------------------------------------------------
Rules:
   0: filter_expr ::= or_expr.
   1: or_expr ::= or_expr OR and_expr. [OR precedence=1]
   2: and_expr ::= and_expr AND not_expr. [AND precedence=2]
   3: not_expr ::= NOT not_expr. [NOT precedence=4]
   4: cmp_expr ::= arithmetic EQ arithmetic. [EQ precedence=3]
   5: cmp_expr ::= arithmetic NE arithmetic. [NE precedence=3]
   6: cmp_expr ::= arithmetic LT arithmetic. [LT precedence=3]
   7: cmp_expr ::= arithmetic LE arithmetic. [LE precedence=3]
   8: cmp_expr ::= arithmetic GT arithmetic. [GT precedence=3]
   9: cmp_expr ::= arithmetic GE arithmetic. [GE precedence=3]
  10: cmp_expr ::= arithmetic CONTAINS arithmetic. [CONTAINS precedence=3]
  11: cmp_expr ::= arithmetic NOT CONTAINS arithmetic. [NOT precedence=4]
  12: cmp_expr ::= arithmetic RECONTAINS arithmetic. [RECONTAINS precedence=3]
  13: cmp_expr ::= arithmetic NOT RECONTAINS arithmetic. [NOT precedence=4]
  14: cmp_expr ::= arithmetic LIKE arithmetic. [LIKE precedence=3]
  15: cmp_expr ::= arithmetic NOT LIKE arithmetic. [NOT precedence=4]
  16: cmp_expr ::= arithmetic MATCHES arithmetic. [MATCHES precedence=3]
  17: cmp_expr ::= arithmetic NOT MATCHES arithmetic. [NOT precedence=4]
  18: arithmetic ::= arithmetic PLUS arithmetic. [PLUS precedence=5]
  19: arithmetic ::= arithmetic MINUS arithmetic. [MINUS precedence=5]
  20: arithmetic ::= arithmetic STAR arithmetic. [STAR precedence=6]
  21: arithmetic ::= arithmetic SLASH arithmetic. [SLASH precedence=6]
  22: arithmetic ::= arithmetic MOD arithmetic. [MOD precedence=6]
  23: unary ::= MINUS unary. [MINUS precedence=5]
  24: term ::= TRUE_LITERAL.
  25: term ::= FALSE_LITERAL.
  26: term ::= INTEGER_LITERAL.
  27: term ::= STRING_LITERAL.
  28: term ::= SIZE_LITERAL.
  29: term ::= DATETIME_LITERAL.
  30: term ::= DURATION_LITERAL.
  31: term ::= VERSION_LITERAL.
  32: term ::= IDENTIFIER LPAREN RPAREN.
  33: term ::= IDENTIFIER LPAREN expr_list RPAREN.
  34: term ::= IDENTIFIER.
  35: term ::= LPAREN expr RPAREN.
  36: expr_list ::= expr.
  37: expr_list ::= expr_list COMMA expr.
  38: or_expr ::= and_expr.
  39: and_expr ::= not_expr.
  40: not_expr ::= cmp_expr.
  41: cmp_expr ::= arithmetic.
  42: arithmetic ::= unary.
  43: expr ::= or_expr.
  44: unary ::= term.
</file>

<file path="Winmerge-Src/Src/FilterEngine/FilterParser.y">
/**
 * @file  FilterParser.y
 *
 * @brief Parser for filter expressions.
 */
%token AND OR NOT TRUE_LITERAL FALSE_LITERAL INTEGER_LITERAL STRING_LITERAL SIZE_LITERAL DATETIME_LITERAL DURATION_LITERAL VERSION_LITERAL IDENTIFIER EQ NE LT LE GT GE CONTAINS RECONTAINS LIKE MATCHES LPAREN RPAREN PLUS MINUS STAR SLASH MOD COMMA.

%left OR.
%left AND.
%left EQ NE LT LE GT GE CONTAINS RECONTAINS LIKE MATCHES.
%right NOT.
%left PLUS MINUS.
%left STAR SLASH MOD.

%token_type {YYSTYPE}
%token_prefix TK_
%extra_argument { FilterExpression* pCtx }

%include {
#include "FilterLexer.h"
#include "FilterExpressionNodes.h"
#include "FilterExpression.h"
#include <Poco/Exception.h>
}

%syntax_error {
	pCtx->errorCode = FILTER_ERROR_SYNTAX_ERROR;
}
%parse_failure {
	pCtx->errorCode = FILTER_ERROR_PARSE_FAILURE;
}
%default_destructor {
	YYSTYPEDestructor($$);
}

filter_expr ::= or_expr(A). {
	if (pCtx->errorCode == 0 && pCtx->optimize)
	{
		try
		{
			pCtx->rootNode.reset(A.node->Optimize());
		}
		catch (Poco::RegularExpressionException& e)
		{
			pCtx->errorCode = FILTER_ERROR_INVALID_REGULAR_EXPRESSION;
			pCtx->rootNode.reset(A.node);
			pCtx->errorMessage = e.message();
		}
		catch (const std::invalid_argument& e)
		{
			pCtx->errorCode = FILTER_ERROR_DIVIDE_BY_ZERO;
			pCtx->rootNode.reset(A.node);
			pCtx->errorMessage = e.what();
		}
		catch (const std::exception&)
		{
			pCtx->rootNode.reset(A.node);
		}
	}
	else
	{
		pCtx->rootNode.reset(A.node);
	}
}

or_expr(A) ::= or_expr(B) OR and_expr(C).             { A = { new OrNode(B.node, C.node) }; }
or_expr(A) ::= and_expr(A).

and_expr(A) ::= and_expr(B) AND not_expr(C).          { A = { new AndNode(B.node, C.node) }; }
and_expr(A) ::= not_expr(A).

not_expr(A) ::= NOT not_expr(B).                      { A = { new NotNode(B.node) }; }
not_expr(A) ::= cmp_expr(A).

cmp_expr(A) ::= arithmetic(B) EQ arithmetic(C).       { A = { new BinaryOpNode(B.node, TK_EQ, C.node) }; }
cmp_expr(A) ::= arithmetic(B) NE arithmetic(C).       { A = { new BinaryOpNode(B.node, TK_NE, C.node) }; }
cmp_expr(A) ::= arithmetic(B) LT arithmetic(C).       { A = { new BinaryOpNode(B.node, TK_LT,  C.node) }; }
cmp_expr(A) ::= arithmetic(B) LE arithmetic(C).       { A = { new BinaryOpNode(B.node, TK_LE, C.node) }; }
cmp_expr(A) ::= arithmetic(B) GT arithmetic(C).       { A = { new BinaryOpNode(B.node, TK_GT,  C.node) }; }
cmp_expr(A) ::= arithmetic(B) GE arithmetic(C).       { A = { new BinaryOpNode(B.node, TK_GE, C.node) }; }
cmp_expr(A) ::= arithmetic(B) CONTAINS arithmetic(C). { A = { new BinaryOpNode(B.node, TK_CONTAINS, C.node) }; }
cmp_expr(A) ::= arithmetic(B) NOT CONTAINS arithmetic(C). { A = { new NotNode(new BinaryOpNode(B.node, TK_CONTAINS, C.node)) }; }
cmp_expr(A) ::= arithmetic(B) RECONTAINS arithmetic(C). { A = { new BinaryOpNode(B.node, TK_RECONTAINS, C.node) }; }
cmp_expr(A) ::= arithmetic(B) NOT RECONTAINS arithmetic(C). { A = { new NotNode(new BinaryOpNode(B.node, TK_RECONTAINS, C.node)) }; }
cmp_expr(A) ::= arithmetic(B) LIKE arithmetic(C).     { A = { new BinaryOpNode(B.node, TK_LIKE, C.node) }; }
cmp_expr(A) ::= arithmetic(B) NOT LIKE arithmetic(C).     { A = { new NotNode(new BinaryOpNode(B.node, TK_LIKE, C.node)) }; }
cmp_expr(A) ::= arithmetic(B) MATCHES  arithmetic(C). { A = { new BinaryOpNode(B.node, TK_MATCHES, C.node) }; }
cmp_expr(A) ::= arithmetic(B) NOT MATCHES  arithmetic(C). { A = { new NotNode(new BinaryOpNode(B.node, TK_MATCHES, C.node)) }; }
cmp_expr(A) ::= arithmetic(A).

arithmetic(A) ::= arithmetic(B) PLUS arithmetic(C).   { A = { new BinaryOpNode(B.node, TK_PLUS, C.node) }; }
arithmetic(A) ::= arithmetic(B) MINUS arithmetic(C).  { A = { new BinaryOpNode(B.node, TK_MINUS, C.node) }; }
arithmetic(A) ::= arithmetic(B) STAR arithmetic(C).   { A = { new BinaryOpNode(B.node, TK_STAR, C.node) }; }
arithmetic(A) ::= arithmetic(B) SLASH arithmetic(C).  { A = { new BinaryOpNode(B.node, TK_SLASH, C.node) }; }
arithmetic(A) ::= arithmetic(B) MOD arithmetic(C).    { A = { new BinaryOpNode(B.node, TK_MOD, C.node) }; }
arithmetic(A) ::= unary(A).

expr(A) ::= or_expr(A).

unary(A) ::= MINUS unary(B).       { A = { new NegateNode(B.node) }; }
unary(A) ::= term(A).

term(A) ::= TRUE_LITERAL.          { A = { new BoolLiteral(true) }; }
term(A) ::= FALSE_LITERAL.         { A = { new BoolLiteral(false) }; }
term(A) ::= INTEGER_LITERAL(B).    { A = { new IntLiteral(B.integer) }; }
term(A) ::= STRING_LITERAL(B).     { A = { new StringLiteral(B.string) }; }
term(A) ::= SIZE_LITERAL(B).       { A = { new SizeLiteral(B.string) }; }
term(A) ::= DATETIME_LITERAL(B).{
  try
  {
    A = {};
    A.node = new DateTimeLiteral(B.string);
  }
  catch (const std::exception&)
  {
    pCtx->errorCode = FILTER_ERROR_INVALID_LITERAL;
  }
}
term(A) ::= DURATION_LITERAL(B).   { A = { new DurationLiteral(B.string) }; }
term(A) ::= VERSION_LITERAL(B).    { A = { new VersionLiteral(B.string) }; }
term(A) ::= IDENTIFIER(B) LPAREN RPAREN. {
  try
  {
    A = {};
    A.node = new FunctionNode(pCtx, B.string, {});
  }
  catch (const std::invalid_argument& e)
  {
    pCtx->errorCode = FILTER_ERROR_INVALID_ARGUMENT_COUNT;
	pCtx->errorMessage = e.what();
  }
  catch (const std::runtime_error& e)
  {
    pCtx->errorCode = FILTER_ERROR_UNDEFINED_IDENTIFIER;
	pCtx->errorMessage = e.what();
  }
}
term(A) ::= IDENTIFIER(B) LPAREN expr_list(C) RPAREN. {
  try
  {
    A = {};
    A.node = new FunctionNode(pCtx, B.string, C.nodeList);
  }
  catch (const std::invalid_argument& e)
  {
    pCtx->errorCode = FILTER_ERROR_INVALID_ARGUMENT_COUNT;
	pCtx->errorMessage = e.what();
    YYSTYPEDestructor(C);
  }
  catch (const std::runtime_error& e)
  {
    pCtx->errorCode = FILTER_ERROR_UNDEFINED_IDENTIFIER;
	pCtx->errorMessage = e.what();
    YYSTYPEDestructor(C);
  }
}
term(A) ::= IDENTIFIER(B). {
  try
  {
    A = {};
    A.node = new FieldNode(pCtx, B.string);
  }
  catch (const std::exception&)
  {
    pCtx->errorCode = FILTER_ERROR_UNDEFINED_IDENTIFIER;
  }
}
term(A) ::= LPAREN expr(B) RPAREN. { A = B; }

expr_list(A) ::= expr(B). {
  A = {};
  A.nodeList = new std::vector<ExprNode*>{ B.node };
}
expr_list(A) ::= expr_list(B) COMMA expr(C). {
  A = {};
  B.nodeList->push_back(C.node);
  A.nodeList = B.nodeList;
}

</file>

<file path="Winmerge-Src/Src/Common/AccentColor.cpp">
// Copyright (c) 2024 Takashi Sawanaka
// SPDX-License-Identifier: BSL-1.0
/**
 * @file  AccentColor.cpp
 *
 * @brief Implementation of the CAccentColor class
 */

#include "StdAfx.h"
#include "AccentColor.h"
#include "RegKey.h"

CAccentColor::CAccentColor()
	: m_accentColor(CLR_NONE)
	, m_accentColorInactive(CLR_NONE)
	, m_colorPrevalence(false)
{
	Reload();
}

CAccentColor& CAccentColor::Get()
{
	static CAccentColor s_accentColor;
	return s_accentColor;
}

void CAccentColor::Reload()
{
	CRegKeyEx reg;
	if (ERROR_SUCCESS != reg.Open(HKEY_CURRENT_USER, _T("SOFTWARE\\Microsoft\\Windows\\DWM")))
		return;
	m_accentColor = reg.ReadDword(_T("AccentColor"), CLR_NONE);
	if (m_accentColor != CLR_NONE)
		m_accentColor &= 0xffffff;
	m_accentColorInactive = reg.ReadDword(_T("AccentColorInactive"), CLR_NONE);
	if (m_accentColorInactive != CLR_NONE)
		m_accentColorInactive &= 0xffffff;
	m_colorPrevalence = reg.ReadDword(_T("ColorPrevalence"), false);
}
</file>

<file path="Winmerge-Src/Src/Common/AccentColor.h">
// Copyright (c) 2024 Takashi Sawanaka
// SPDX-License-Identifier: BSL-1.0
/**
 * @file  AccentColor.h
 *
 * @brief Declaration file for CAccentColor class
 */

#pragma once

class CAccentColor
{
public:
	CAccentColor();
	COLORREF GetAccentColor() const { return m_accentColor; };
	COLORREF GetAccentColorInactive() const { return m_accentColorInactive; }
	bool GetColorPrevalence() const { return m_colorPrevalence; }
	void Reload();
	static CAccentColor& Get();
private:
	COLORREF m_accentColor;
	COLORREF m_accentColorInactive;
	bool m_colorPrevalence;
};
</file>

<file path="Winmerge-Src/Src/Common/BCMenu.cpp">
//*************************************************************************
// BCMenu.cpp : implementation file
// Version : 3.036
// Date : June 2005
// Author : Brent Corkum
// Email :  corkum@rocscience.com
// Latest Version : http://www.rocscience.com/~corkum/BCMenu.html
// 
// Bug Fixes and portions of code supplied by:
//
// Ben Ashley,Girish Bharadwaj,Jean-Edouard Lachand-Robert,
// Robert Edward Caldecott,Kenny Goers,Leonardo Zide,
// Stefan Kuhr,Reiner Jung,Martin Vladic,Kim Yoo Chul,
// Oz Solomonovich,Tongzhe Cui,Stephane Clog,Warren Stevens,
// Damir Valiulin,David Kinder,Marc Loiry
//
// You are free to use/modify this code but leave this header intact.
// This class is public domain so you are free to use it any of
// your applications (Freeware,Shareware,Commercial). All I ask is
// that you let me know so that if you have a real winner I can
// brag to my buddies that some of my code is in your app. I also
// wouldn't mind if you sent me a copy of your application since I
// like to play with new stuff.
//*************************************************************************

#include "stdafx.h"        // Standard windows header file
#include "BCMenu.h"        // BCMenu class declaration
#include "MergeDarkMode.h" // Dark mode
#include <afxpriv.h>       //SK: makes A2W and other spiffy AFX macros work
#include <../src/mfc/afximpl.h>
#include <cmath>

#pragma comment(lib, "uxtheme.lib")

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

#define BCMENU_GAP 1

bool BCMenu::hicolor_bitmaps=false;

CImageList BCMenu::m_AllImages;
bool BCMenu::m_bHasNotLoadedImages = false;
std::vector<BCMenu::ImageData> BCMenu::m_AllImagesID;
int BCMenu::m_iconX = 16;
int BCMenu::m_iconY = 15;
MARGINS BCMenu::m_marginCheck = { 0 };
MARGINS BCMenu::m_marginSeparator = { 0 };
SIZE BCMenu::m_sizeCheck = { 0 };
SIZE BCMenu::m_sizeSeparator = { 0 };
int BCMenu::m_textBorder = 0;
int BCMenu::m_checkBgWidth = 0;
int BCMenu::m_gutterWidth = 0;
int BCMenu::m_arrowWidth = 0;
COLORREF BCMenu::m_menuTextColor = GetSysColor(COLOR_MENUTEXT);
COLORREF BCMenu::m_menuBgColor = GetSysColor(COLOR_MENU);
HTHEME BCMenu::m_hTheme = nullptr;
bool BCMenu::m_bEnableOwnerDraw = true;

static class GdiplusToken
{
public:
	GdiplusToken() = default;

	~GdiplusToken()
	{
		if (m_token != 0)
			Gdiplus::GdiplusShutdown(m_token);
	}

	void InitGdiplus()
	{
		if (m_token == 0)
		{
			Gdiplus::GdiplusStartupInput gdiplusStartupInput;
			Gdiplus::GdiplusStartup(&m_token, &gdiplusStartupInput, nullptr);
		}
	}

private:
	ULONG_PTR m_token = 0;
} m_gdiplusToken;

// The Representation of a 32 bit color table entry
#pragma pack(push)
#pragma pack(1)
typedef struct ssBGR {
	unsigned char b;
	unsigned char g;
	unsigned char r;
	unsigned char pad;
} sBGR;

typedef sBGR *pBGR;
#pragma pack(pop)


// Returns the DI (Device Independent) bits of the Bitmap
// Here I use 32 bit since it's easy to address in memory and no
// padding of the horizontal lines is required.
static pBGR MyGetDibBits(HDC hdcSrc, HBITMAP hBmpSrc, int nx, int ny)
{
	BITMAPINFO bi;
	int nRes;
	pBGR buf;

	bi.bmiHeader.biSize = sizeof(bi.bmiHeader);
	bi.bmiHeader.biWidth = nx;
	bi.bmiHeader.biHeight = ny;
	bi.bmiHeader.biPlanes = 1;
	bi.bmiHeader.biBitCount = 32;
	bi.bmiHeader.biCompression = BI_RGB;
	bi.bmiHeader.biSizeImage = nx * 4 * ny;
	bi.bmiHeader.biClrUsed = 0;
	bi.bmiHeader.biClrImportant = 0;
	
	buf = (pBGR) malloc(static_cast<size_t>(nx) * 4 * ny);
	nRes = GetDIBits(hdcSrc, hBmpSrc, 0, ny, buf, &bi, DIB_RGB_COLORS);
	if (nRes == 0) {
		free(buf);
		buf = nullptr;
	}
	return buf;
}

static void MySetDibBits(HDC hdcDst, HBITMAP hBmpDst, pBGR pdstBGR, int nx, int ny)
{
	BITMAPINFO bi;

	// Set the new Bitmap
	bi.bmiHeader.biSize = sizeof(bi.bmiHeader);
	bi.bmiHeader.biWidth = nx;
	bi.bmiHeader.biHeight = ny;
	bi.bmiHeader.biPlanes = 1;
	bi.bmiHeader.biBitCount = 32;
	bi.bmiHeader.biCompression = BI_RGB;
	bi.bmiHeader.biSizeImage = nx * 4 * ny;
	bi.bmiHeader.biClrUsed = 0;
	bi.bmiHeader.biClrImportant = 0;
	SetDIBits(hdcDst, hBmpDst, 0, ny, pdstBGR, &bi, DIB_RGB_COLORS);
}

CString BCMenuData::GetString(void)//returns the menu text
//depending on the MFC-Version we are using
{
	CString strText;
	if (m_szMenuText)
    {
		strText = m_szMenuText;
    }
	return strText;
}

CTypedPtrArray<CPtrArray, HMENU> BCMenu::m_AllSubMenus;  // Stores list of all sub-menus

IMPLEMENT_DYNAMIC( BCMenu, CMenu )

/*
===============================================================================
BCMenu::BCMenu()
BCMenu::~BCMenu()
-----------------

Constructor and Destructor.

===============================================================================
*/

BCMenu::BCMenu()
{
	// set the color used for the transparent background in all bitmaps
	m_bitmapBackground=RGB(192,192,192); //gray
	m_bitmapBackgroundFlag=false;
	m_loadmenu=false;
	if (m_hTheme==nullptr && IsThemeActive())
	{
		m_hTheme = OpenThemeData(nullptr, _T("MENU"));
		if (m_hTheme != nullptr)
		{
			const int dpi = CClientDC(CWnd::GetDesktopWindow()).GetDeviceCaps(LOGPIXELSX);
			auto resizeMargins = [dpi](MARGINS& margins)
			{
				margins.cxLeftWidth = MulDiv(margins.cxLeftWidth, dpi, 96);
				margins.cxRightWidth = MulDiv(margins.cxRightWidth, dpi, 96);
				margins.cyTopHeight = MulDiv(margins.cyTopHeight, dpi, 96);
				margins.cyBottomHeight = MulDiv(margins.cyBottomHeight, dpi, 96);
			};
			MARGINS marginCheckBg, marginArrow;	
			GetThemePartSize(m_hTheme, nullptr, MENU_POPUPCHECK, 0, nullptr, TS_TRUE, &m_sizeCheck);
			GetThemeMargins(m_hTheme, nullptr, MENU_POPUPCHECK, 0, TMT_CONTENTMARGINS, nullptr, &m_marginCheck);
			GetThemePartSize(m_hTheme, nullptr, MENU_POPUPSEPARATOR, 0, nullptr, TS_TRUE, &m_sizeSeparator); 
			GetThemeMargins(m_hTheme, nullptr, MENU_POPUPSEPARATOR, 0, TMT_SIZINGMARGINS, nullptr, &m_marginSeparator);
			GetThemeMargins(m_hTheme, nullptr, MENU_POPUPCHECKBACKGROUND, 0, TMT_CONTENTMARGINS, nullptr, &marginCheckBg);
			GetThemeMargins(m_hTheme, nullptr, MENU_POPUPSUBMENU, 0, TMT_CONTENTMARGINS, nullptr, &marginArrow);
			GetThemeInt(m_hTheme, MENU_POPUPBACKGROUND, 0, TMT_BORDERSIZE, &m_textBorder);
			GetThemeColor(m_hTheme, MENU_POPUPITEM, MPI_NORMAL, TMT_TEXTCOLOR, &m_menuTextColor);
			GetThemeColor(m_hTheme, MENU_POPUPBACKGROUND, 0, TMT_FILLCOLOR, &m_menuBgColor);
			for (auto* pmargins : { &m_marginCheck, &m_marginSeparator, &marginCheckBg, &marginArrow })
				resizeMargins(*pmargins);
			m_textBorder = MulDiv(m_textBorder, dpi, 96);
			m_checkBgWidth = m_marginCheck.cxLeftWidth + m_sizeCheck.cx + m_marginCheck.cxRightWidth;
			m_gutterWidth = marginCheckBg.cxLeftWidth + m_checkBgWidth + marginCheckBg.cxRightWidth;
			m_arrowWidth = marginArrow.cxRightWidth;
		}
	}
}


BCMenu::~BCMenu()
{
	BCMenu::DestroyMenu();
}

BCMenuData::~BCMenuData()
{
	delete[] m_szMenuText; //Need not check for nullptr because ANSI X3J16 allows "delete nullptr"
}


void BCMenuData::SetWideString(const wchar_t *szWideString)
{
	delete[] m_szMenuText;//Need not check for nullptr because ANSI X3J16 allows "delete nullptr"
	
	if (szWideString)
    {
		const size_t MenuSiz = wcslen(szWideString) + 1;
		m_szMenuText = new wchar_t[MenuSiz];
		wcscpy_s(m_szMenuText, MenuSiz, szWideString);
    }
	else
		m_szMenuText=nullptr;//set to nullptr so we need not bother about dangling non-nullptr Ptrs
}

void BCMenu::DisableOwnerDraw()
{
	m_bEnableOwnerDraw = false;
	RecreateRadioDotBitmap();
}

void BCMenu::RecreateRadioDotBitmap()
{
	CBitmap* pBitmap = CreateRadioDotBitmap();
	if (afxData.hbmMenuDot)
		DeleteObject(afxData.hbmMenuDot);
	afxData.hbmMenuDot = reinterpret_cast<HBITMAP>(pBitmap->Detach());
	delete pBitmap;
}

bool BCMenu::IsMenu(HMENU submenu)
{
	INT_PTR m;
	INT_PTR numSubMenus = m_AllSubMenus.GetUpperBound();
	for(m=0;m<=numSubMenus;++m){
		if(submenu==m_AllSubMenus[m] || 
		  static_cast<UINT>(reinterpret_cast<uintptr_t>(submenu)) == static_cast<UINT>(reinterpret_cast<uintptr_t>(m_AllSubMenus[m])))
			return true;
	}
	return false;
}

BOOL BCMenu::DestroyMenu()
{
	// Destroy Sub menus:
	INT_PTR m,n;
	INT_PTR numAllSubMenus = m_AllSubMenus.GetUpperBound();
	for(n = numAllSubMenus; n>= 0; n--){
		if(m_AllSubMenus[n]==this->m_hMenu)m_AllSubMenus.RemoveAt(n);
	}
	INT_PTR numSubMenus = m_SubMenus.GetUpperBound();
	for(m = numSubMenus; m >= 0; m--){
		numAllSubMenus = m_AllSubMenus.GetUpperBound();
		for(n = numAllSubMenus; n>= 0; n--){
			if(m_AllSubMenus[n]==m_SubMenus[m])m_AllSubMenus.RemoveAt(n);
		}
		CMenu *ptr=FromHandle(m_SubMenus[m]);
		if(ptr != nullptr){
			bool flag = !!ptr->IsKindOf(RUNTIME_CLASS( BCMenu ));
			if(flag)delete(static_cast<BCMenu *>(ptr));
		}
	}
	m_SubMenus.RemoveAll();
	// Destroy menu data
	INT_PTR numItems = m_MenuList.GetUpperBound();
	for(m = 0; m <= numItems; m++)delete(m_MenuList[m]);
	m_MenuList.RemoveAll();
	// Call base-class implementation last:
	return CMenu::DestroyMenu();
};

/*
==========================================================================
void BCMenu::DrawItem(LPDRAWITEMSTRUCT)
---------------------------------------

  Called by the framework when a particular item needs to be drawn.  We
  override this to draw the menu item in a custom-fashion, including icons
  and the 3D rectangle bar.
  ==========================================================================
*/

void BCMenu::DrawItem (LPDRAWITEMSTRUCT lpDIS)
{
	ASSERT(lpDIS != nullptr);
	LoadImages();
	CDC* pDC = CDC::FromHandle(lpDIS->hDC);
	if((pDC->GetDeviceCaps(RASTERCAPS) & RC_PALETTE) != 0)DrawItem_Win9xNT2000(lpDIS);
	else{
		if (m_hTheme == nullptr || !IsThemeActive())
			DrawItem_Win9xNT2000(lpDIS);
		else
			DrawItem_Theme(lpDIS);
	}
}

void BCMenu::DrawItem_Win9xNT2000 (LPDRAWITEMSTRUCT lpDIS)
{
	ASSERT(lpDIS != nullptr);
	CDC* pDC = CDC::FromHandle(lpDIS->hDC);
	CRect rect;
	UINT state0 = reinterpret_cast<BCMenuData*>(lpDIS->itemData)->nFlags;
	COLORREF clrBack=GetSysColor(COLOR_MENU);
	CBrush brBackground(clrBack);

	if((state0 & MF_SEPARATOR) != 0){
		rect.CopyRect(&lpDIS->rcItem);
		pDC->FillRect (rect,&brBackground);
		rect.top += (rect.Height()>>1);
		pDC->DrawEdge(&rect,EDGE_ETCHED,BF_TOP);
	}
	else{
		CRect rect2;
		bool standardflag = false;
		bool selectedflag = false;
		bool disableflag = false;
		COLORREF crText = GetSysColor(COLOR_MENUTEXT);
		int dy;
		INT_PTR xoffset=-1;
		
		// set some colors
		CPen penBack(PS_SOLID,0,clrBack);
		CBrush brSelect(GetSysColor(COLOR_HIGHLIGHT));
		
		// draw the colored rectangle portion
		
		rect.CopyRect(&lpDIS->rcItem);
		rect2=rect;
		
		// draw the up/down/focused/disabled state
		
		UINT state = lpDIS->itemState;
		CString strText;
		
		if(lpDIS->itemData != NULL){
			BCMenuData *mdata = reinterpret_cast<BCMenuData *>(lpDIS->itemData);
			strText = mdata->GetString();

			xoffset=mdata->global_offset;
			
			if((state&ODS_CHECKED)!=0 && xoffset<0){
			}
			else if(xoffset != -1){
				standardflag=true;
				if((state&ODS_SELECTED)!=0 && (state&ODS_GRAYED)==0)
					selectedflag=true;
				else 
				if((state&ODS_GRAYED)!=0) 
					disableflag=true;
			}
		}
		else{
			strText.Empty();
		}
		
		if((state&ODS_SELECTED)!=0){ // draw the down edges
			
			CPen *pOldPen = pDC->SelectObject (&penBack);
			
			// You need only Text highlight and thats what you get
			
			if(standardflag||selectedflag||disableflag||(state&ODS_CHECKED)!=0)
				rect2.SetRect(rect.left+m_iconX+4+BCMENU_GAP,rect.top,rect.right,rect.bottom);
			pDC->FillRect (rect2,&brSelect);
			
			pDC->SelectObject (pOldPen);
			crText = GetSysColor(COLOR_HIGHLIGHTTEXT);
		}
		else {
			CPen *pOldPen = pDC->SelectObject (&penBack);
			pDC->FillRect (rect,&brBackground);
			pDC->SelectObject (pOldPen);
			
			// draw the up edges	
			pDC->Draw3dRect (rect,clrBack,clrBack);
		}
		
		// draw the text if there is any
		//We have to paint the text only if the image is nonexistant
		
		dy = (rect.Height()-4-m_iconY)/2;
		dy = dy<0 ? 0 : dy;
		
		if(standardflag||selectedflag||disableflag){
			rect2.SetRect(rect.left+1,rect.top+1+dy,rect.left+m_iconX+3,
				rect.top+m_iconY+3+dy);
			pDC->Draw3dRect (rect2,clrBack,clrBack);
			if(disableflag){
				if(!selectedflag){
					CBitmap bitmapstandard;
					GetBitmapFromImageList(pDC,(int)xoffset,bitmapstandard);
					rect2.SetRect(rect.left,rect.top+dy,rect.left+m_iconX+4,
                        rect.top+m_iconY+4+dy);
					pDC->Draw3dRect (rect2,clrBack,clrBack);
					if(hicolor_bitmaps)
						DitherBlt3(pDC,rect.left+2,rect.top+2+dy,m_iconX,m_iconY,
						bitmapstandard,clrBack);
					else
						DitherBlt2(pDC,rect.left+2,rect.top+2+dy,m_iconX,m_iconY,
						bitmapstandard,0,0,clrBack);
				}
			}
			else if(selectedflag){
				pDC->FillRect (rect2,&brBackground);
				rect2.SetRect(rect.left,rect.top+dy,rect.left+m_iconX+4,
					rect.top+m_iconY+4+dy);
				if(state&ODS_CHECKED)
					pDC->Draw3dRect(rect2,GetSysColor(COLOR_3DSHADOW),
					GetSysColor(COLOR_3DHILIGHT));
				else
					pDC->Draw3dRect(rect2,GetSysColor(COLOR_3DHILIGHT),
					GetSysColor(COLOR_3DSHADOW));
				CPoint ptImage(rect.left+2,rect.top+2+dy);
				if(xoffset >= 0) m_AllImages.Draw(pDC,(int)xoffset,ptImage,ILD_TRANSPARENT);
			}
			else{
				if(state&ODS_CHECKED){
					CBrush cbTemp = LightenColor(clrBack, 0.6);
					pDC->FillRect(rect2,&cbTemp);
					rect2.SetRect(rect.left,rect.top+dy,rect.left+m_iconX+4,
                        rect.top+m_iconY+4+dy);
					pDC->Draw3dRect(rect2,GetSysColor(COLOR_3DSHADOW),
					GetSysColor(COLOR_3DHILIGHT));
				}
				else{
					pDC->FillRect (rect2,&brBackground);
					rect2.SetRect(rect.left,rect.top+dy,rect.left+m_iconX+4,
                        rect.top+m_iconY+4+dy);
					pDC->Draw3dRect (rect2,clrBack,clrBack);
				}
				CPoint ptImage(rect.left+2,rect.top+2+dy);
				if(xoffset >= 0) m_AllImages.Draw(pDC,(int)xoffset,ptImage,ILD_TRANSPARENT);
			}
		}
		if(xoffset<0 && (state&ODS_CHECKED)!=0){
			rect2.SetRect(rect.left+1,rect.top+2+dy,rect.left+m_iconX+1,
				rect.top+m_iconY+2+dy);
			CMenuItemInfo info;
			info.fMask = MIIM_CHECKMARKS;
			::GetMenuItemInfo((HMENU)lpDIS->hwndItem,lpDIS->itemID,
				MF_BYCOMMAND, &info);
			if((state&ODS_CHECKED)!=0 || info.hbmpUnchecked!=nullptr) {
				Draw3DCheckmark(pDC, rect2, (state&ODS_SELECTED)!=0,
					(state&ODS_CHECKED)!=0 ? info.hbmpChecked : info.hbmpUnchecked);
			}
		}
		
		//This is needed always so that we can have the space for check marks
		
		rect.left = rect.left + m_iconX + 8 + BCMENU_GAP; 
		
		if(!strText.IsEmpty()){
			
			CRect rectt(rect.left,rect.top-1,rect.right,rect.bottom-1);
			
			//   Find tabs
			
			CString leftStr,rightStr;
			leftStr.Empty();rightStr.Empty();
			int tablocr=strText.ReverseFind(_T('\t'));
			if(tablocr!=-1){
				rightStr=strText.Mid(tablocr+1);
				leftStr=strText.Left(strText.Find(_T('\t')));
				rectt.right-=m_iconX;
			}
			else leftStr=strText;
			
			int iOldMode = pDC->GetBkMode();
			pDC->SetBkMode( TRANSPARENT);
			
			// Draw the text in the correct colour:
			
			UINT nFormat  = DT_LEFT|DT_SINGLELINE|DT_VCENTER;
			UINT nFormatr = DT_RIGHT|DT_SINGLELINE|DT_VCENTER;
			if((lpDIS->itemState & ODS_GRAYED)==0){
				pDC->SetTextColor(crText);
				pDC->DrawText (leftStr,rectt,nFormat);
				if(tablocr!=-1) pDC->DrawText (rightStr,rectt,nFormatr);
			}
			else{
				
				// Draw the disabled text
				if((state & ODS_SELECTED)==0){
					RECT offset = *rectt;
					offset.left+=1;
					offset.right+=1;
					offset.top+=1;
					offset.bottom+=1;
					pDC->SetTextColor(GetSysColor(COLOR_BTNHILIGHT));
					pDC->DrawText(leftStr,&offset, nFormat);
					if(tablocr!=-1) pDC->DrawText (rightStr,&offset,nFormatr);
					pDC->SetTextColor(GetSysColor(COLOR_GRAYTEXT));
					pDC->DrawText(leftStr,rectt, nFormat);
					if(tablocr!=-1) pDC->DrawText (rightStr,rectt,nFormatr);
				}
				else{
					// And the standard Grey text:
					pDC->SetTextColor(clrBack);
					pDC->DrawText(leftStr,rectt, nFormat);
					if(tablocr!=-1) pDC->DrawText (rightStr,rectt,nFormatr);
				}
			}
			pDC->SetBkMode( iOldMode );
		}
	}
}

inline COLORREF BCMenu::LightenColor(COLORREF col,double factor)
{
	if(factor>0.0&&factor<=1.0){
		BYTE red,green,blue,lightred,lightgreen,lightblue;
		red = GetRValue(col);
		green = GetGValue(col);
		blue = GetBValue(col);
		lightred = (BYTE)((factor*(255-red)) + red);
		lightgreen = (BYTE)((factor*(255-green)) + green);
		lightblue = (BYTE)((factor*(255-blue)) + blue);
		col = RGB(lightred,lightgreen,lightblue);
	}
	return col;
}

void BCMenu::DrawItem_Theme(LPDRAWITEMSTRUCT lpDIS)
{
	ASSERT(lpDIS != nullptr);
	CDC* pDC = CDC::FromHandle(lpDIS->hDC);
	HDC hDC = lpDIS->hDC;
	CRect rect(&lpDIS->rcItem);
	UINT state = lpDIS->itemState;
	CRect rectGutter(rect.left, rect.top, rect.left + m_gutterWidth, rect.bottom);

	const int stateId =
		(state & ODS_GRAYED)!=0 ?
			((state & ODS_SELECTED)!=0 ? MPI_DISABLEDHOT : MPI_DISABLED)
		:
			((state & ODS_SELECTED)!=0 ? MPI_HOT : MPI_NORMAL);

	DrawThemeBackground(m_hTheme, hDC, MENU_POPUPBACKGROUND, 0, &rect, nullptr);
	DrawThemeBackground(m_hTheme, hDC, MENU_POPUPGUTTER, 0, &rectGutter, nullptr);
	DrawThemeBackground(m_hTheme, hDC, MENU_POPUPITEM, stateId, &rect, nullptr);
	
	BCMenuData *mdata = reinterpret_cast<BCMenuData*>(lpDIS->itemData);
	if(mdata == nullptr)
		return;

	if ((mdata->nFlags & MF_SEPARATOR)!=0){
		CRect rectSeparator(rectGutter.right + m_marginSeparator.cxLeftWidth,
			rect.top + m_marginSeparator.cyTopHeight,
		    rect.right - m_marginSeparator.cxRightWidth,
			rect.top + m_marginSeparator.cyTopHeight + m_sizeSeparator.cy);
		DrawThemeBackground(m_hTheme, hDC, MENU_POPUPSEPARATOR, 0, &rectSeparator, nullptr);
		return;
	}

	INT_PTR xoffset = mdata->global_offset;
	CString	strText = mdata->GetString();

	int cxSMIcon = GetSystemMetrics(SM_CXSMICON);
	int cySMIcon = GetSystemMetrics(SM_CYSMICON);

	if(xoffset >= 0){
		CImage bitmapstandard;
		GetBitmapFromImageList(pDC,(int)xoffset,bitmapstandard);
		if((state & ODS_GRAYED)!=0)
			GetDisabledBitmap(bitmapstandard);
		m_gdiplusToken.InitGdiplus();
		Gdiplus::Bitmap bm(bitmapstandard.GetWidth(), bitmapstandard.GetHeight(), 
			bitmapstandard.GetPitch(), PixelFormat32bppARGB, (BYTE *)bitmapstandard.GetBits());
		Gdiplus::Graphics dcDst(pDC->m_hDC);
		dcDst.SetInterpolationMode(Gdiplus::InterpolationModeHighQualityBicubic);
		Gdiplus::Rect rcDst(
			static_cast<int>(rect.left + (rectGutter.right - cxSMIcon) / 2.0 + 0.5),
			static_cast<int>(rect.top  + (rect.Height() - cySMIcon) / 2.0 + 0.5),
			cxSMIcon, cySMIcon);
		dcDst.DrawImage(&bm, rcDst, 0, 0, m_iconX, m_iconY, Gdiplus::UnitPixel);
	}
	if(xoffset < 0 && (state&ODS_CHECKED)!=0){
		CMenuItemInfo info;
		info.fMask = MIIM_CHECKMARKS;
		::GetMenuItemInfo((HMENU)lpDIS->hwndItem,lpDIS->itemID,
			MF_BYCOMMAND, &info);
		if((state&ODS_CHECKED)!=0 || (info.hbmpUnchecked != nullptr)) {
			int stateIdCheck = 0;
			if (info.hbmpChecked == nullptr)
				stateIdCheck = (state & ODS_GRAYED)!=0 ? MC_CHECKMARKDISABLED : MC_CHECKMARKNORMAL;
			else
				stateIdCheck = (state & ODS_GRAYED)!=0 ? MC_BULLETDISABLED : MC_BULLETNORMAL;
			int stateIdCheckBk = (state & ODS_GRAYED)!=0 ? MCB_DISABLED : MCB_NORMAL;
			CRect rectCheck(
				rect.left + m_marginCheck.cxLeftWidth,
				rect.top + m_marginCheck.cyTopHeight,
				rect.left + m_marginCheck.cxLeftWidth + m_sizeCheck.cx,
				rect.top + m_marginCheck.cyTopHeight + m_sizeCheck.cy);
			CRect rectCheckBg(rect.left,rect.top,rect.left+m_checkBgWidth,rect.bottom);
			DrawThemeBackground(m_hTheme, hDC, MENU_POPUPCHECKBACKGROUND, stateIdCheckBk, &rectCheckBg, nullptr);
			DrawThemeBackground(m_hTheme, hDC, MENU_POPUPCHECK, stateIdCheck, &rectCheck, nullptr);
		}
	}
	
	if(!strText.IsEmpty()){
		
		CRect rectt(rectGutter.right + m_textBorder, rect.top, rect.right, rect.bottom);
		
		//   Find tabs
		
		CString leftStr,rightStr;
		leftStr.Empty();rightStr.Empty();
		int tablocr=strText.ReverseFind(_T('\t'));
		if(tablocr!=-1){
			rightStr=strText.Mid(tablocr+1);
			leftStr=strText.Left(strText.Find(_T('\t')));
			rectt.right-=cxSMIcon;
		}
		else leftStr=strText;
		
		// Draw the text in the correct colour:
		DWORD nFormat  = DT_LEFT|DT_SINGLELINE|DT_VCENTER;
		DWORD nFormatr = DT_RIGHT|DT_SINGLELINE|DT_VCENTER;
		DrawThemeText(m_hTheme, hDC, MENU_POPUPITEM, stateId, leftStr, leftStr.GetLength(), nFormat, 0, &rectt);
		if(tablocr!=-1) DrawThemeText(m_hTheme, hDC, MENU_POPUPITEM, stateId, rightStr, rightStr.GetLength(), nFormatr, 0, &rectt);
	}
}

bool BCMenu::GetBitmapFromImageList(CDC* pDC,int nIndex,CImage &bmp)
{
	CDC dc;
	dc.CreateCompatibleDC(pDC);
	bmp.Create(m_iconX, -m_iconY, 32, CImage::createAlphaChannel);
	memset(bmp.GetBits(), 0xff, static_cast<size_t>(abs(bmp.GetPitch())) * m_iconY);
	HGDIOBJ pOldBmp = dc.SelectObject(bmp.operator HBITMAP());
	POINT pt = {0};
	SIZE  sz = {m_iconX, m_iconY};

	IMAGELISTDRAWPARAMS drawing;

	drawing.cbSize = IMAGELISTDRAWPARAMS_V3_SIZE;
	drawing.himl = m_AllImages.m_hImageList;
	drawing.i = nIndex;
	drawing.hdcDst = dc.m_hDC;
	drawing.x = pt.x;
	drawing.y = pt.y;
	drawing.cx = sz.cx;
	drawing.cy = sz.cy;
	drawing.xBitmap = pt.x;
	drawing.yBitmap = pt.y;
	drawing.rgbBk = CLR_NONE;
	drawing.rgbFg = CLR_DEFAULT;
	drawing.fStyle = ILD_NORMAL;
	drawing.dwRop = SRCCOPY;

	ImageList_DrawIndirect(&drawing);

	int pitch = bmp.GetPitch();
	BYTE *p = (BYTE *)bmp.GetBits();
	for (int y = 0; y < m_iconY; ++y)
	{
		for (int x = 0; x < m_iconX; ++x)
		{
			if (p[x * 4 + y * pitch + 3] == 0xff)
				p[x * 4 + y * pitch + 3] = 0;
			else
				p[x * 4 + y * pitch + 3] = 0xff;
		}
	}

	dc.SelectObject( pOldBmp );
	return true;
}

bool BCMenu::GetBitmapFromImageList(CDC* pDC,int nIndex,CBitmap &bmp)
{
	CDC dc;
	dc.CreateCompatibleDC(pDC);
	bmp.CreateCompatibleBitmap(pDC,m_iconX,m_iconY);
	CBitmap* pOldBmp = dc.SelectObject(&bmp);
	POINT pt = {0};
	SIZE  sz = {m_iconX, m_iconY};

	IMAGELISTDRAWPARAMS drawing;

	drawing.cbSize = IMAGELISTDRAWPARAMS_V3_SIZE;
	drawing.himl = m_AllImages.m_hImageList;
	drawing.i = nIndex;
	drawing.hdcDst = dc.m_hDC;
	drawing.x = pt.x;
	drawing.y = pt.y;
	drawing.cx = sz.cx;
	drawing.cy = sz.cy;
	drawing.xBitmap = pt.x;
	drawing.yBitmap = pt.y;
	drawing.rgbBk = GetSysColor(COLOR_3DFACE);
	drawing.rgbFg = CLR_DEFAULT;
	drawing.fStyle = ILD_NORMAL;
	drawing.dwRop = SRCCOPY;

	ImageList_DrawIndirect(&drawing);

	dc.SelectObject( pOldBmp );
	return true;
}

/*
==========================================================================
void BCMenu::MeasureItem(LPMEASUREITEMSTRUCT)
---------------------------------------------

  Called by the framework when it wants to know what the width and height
  of our item will be.  To accomplish this we provide the width of the
  icon plus the width of the menu text, and then the height of the icon.
  
	==========================================================================
*/

void BCMenu::MeasureItem( LPMEASUREITEMSTRUCT lpMIS )
{
	UINT state = reinterpret_cast<BCMenuData*>(lpMIS->itemData)->nFlags;
	if((state & MF_SEPARATOR)!=0){
		lpMIS->itemWidth = 0;
		if (m_hTheme != nullptr)
			lpMIS->itemHeight = m_marginSeparator.cyTopHeight + m_sizeSeparator.cy + m_marginSeparator.cyBottomHeight;
		else
			lpMIS->itemHeight = 3;
	}
	else{
		CFont fontMenu;
		NONCLIENTMETRICS nm = { sizeof NONCLIENTMETRICS };
		VERIFY(::SystemParametersInfo(SPI_GETNONCLIENTMETRICS,
			nm.cbSize,&nm,0)); 
		fontMenu.CreateFontIndirect (&nm.lfMenuFont);
		
		// Obtain the width of the text:
		CClientDC dc(AfxGetMainWnd() ? AfxGetMainWnd() : CWnd::GetDesktopWindow());     // Get device context
		CFont* pFont=nullptr;    // Select menu font in...
		
		pFont = dc.SelectObject (&fontMenu);// Select menu font in...
        
		//Get pointer to text SK
		const wchar_t *lpstrText = reinterpret_cast<BCMenuData*>(lpMIS->itemData)->GetWideString();//SK: we use const to prevent misuse
		    
		SIZE size;
		size.cx=size.cy=0;
		
		VERIFY(::GetTextExtentPoint32W(dc.m_hDC,lpstrText,
			lstrlenW(lpstrText),&size)); //SK should also work on 95
		CSize t = CSize(size);
		dc.SelectObject (pFont);  // Select old font in
		
		// Set width and height:
		
		int temp = GetSystemMetrics(SM_CYMENU);
		const int BCMENU_PAD=4;
		lpMIS->itemHeight = temp>m_iconY+BCMENU_PAD ? temp : m_iconY+BCMENU_PAD;
		if (m_hTheme == nullptr)
		{
			lpMIS->itemWidth = m_iconX + BCMENU_PAD + 8 + t.cx;
		}
		else
		{
			lpMIS->itemWidth = m_gutterWidth+m_textBorder+t.cx+m_arrowWidth;
			unsigned menuHeight = static_cast<unsigned>(
				m_sizeCheck.cy + m_marginCheck.cyTopHeight + m_marginCheck.cyBottomHeight);
			if (menuHeight > lpMIS->itemHeight)
				lpMIS->itemHeight = menuHeight;
		}
	}
}

bool BCMenu::AppendODMenu(const wchar_t *lpstrText,UINT nFlags,UINT_PTR nID,
                           int nIconNormal)
{
	// Add the MF_OWNERDRAW flag if not specified:
	if(nID == 0){
		if((nFlags&MF_BYPOSITION)!=0)
			nFlags=MF_SEPARATOR|MakeOwnerDrawFlag()|MF_BYPOSITION;
		else 
			nFlags=MF_SEPARATOR|MakeOwnerDrawFlag();
	}
	else 
	if((nFlags & MF_OWNERDRAW)==0)
		nFlags |= MakeOwnerDrawFlag();
	
	if((nFlags & MF_POPUP)!=0){
		m_AllSubMenus.Add((HMENU)nID);
		m_SubMenus.Add((HMENU)nID);
	}
	
	BCMenuData *mdata = new BCMenuData;
	m_MenuList.Add(mdata);
	mdata->SetWideString(lpstrText);    //SK: modified for dynamic allocation
	
	if(nIconNormal>=0){
		mdata->global_offset = AddToGlobalImageList(nIconNormal,static_cast<int>(nID));
	}
	else mdata->global_offset = GlobalImageListOffset(static_cast<int>(nID));

	mdata->nFlags = nFlags;
	mdata->nID = nID;
	bool returnflag=!!CMenu::AppendMenu(nFlags, nID, MakeItemData(mdata));
	if(m_loadmenu)RemoveTopLevelOwnerDraw();
	return returnflag;
}

bool BCMenu::InsertODMenu(UINT nPosition,wchar_t *lpstrText,UINT nFlags,UINT_PTR nID,
                           int nIconNormal)
{
	if((nFlags & MF_BYPOSITION) == 0){
		UINT iPosition =0;
		BCMenu* pMenu = FindMenuOption(nPosition,iPosition);
		if(pMenu != nullptr){
			return pMenu->InsertODMenu(iPosition,lpstrText,nFlags|MF_BYPOSITION,nID,nIconNormal);
		}
		else return false;
	}
	
	if(nID==0)
		nFlags=MF_SEPARATOR|MakeOwnerDrawFlag()|MF_BYPOSITION;
	else 
	if((nFlags & MF_OWNERDRAW)==0)
		nFlags |= MakeOwnerDrawFlag();

	int menustart=0;

	if((nFlags & MF_POPUP)!=0){
		if(m_loadmenu){
			menustart=GetMenuStart();
			if(nPosition<(UINT)menustart)menustart=0;
		}
		m_AllSubMenus.Add((HMENU)nID);
		m_SubMenus.Add((HMENU)nID);
	}

	//Stephane Clog suggested adding this, believe it or not it's in the help 
	if(nPosition==(UINT)-1)nPosition=GetMenuItemCount();
	
	BCMenuData *mdata = new BCMenuData;
	m_MenuList.InsertAt(nPosition-menustart,mdata);
	mdata->SetWideString(lpstrText);    //SK: modified for dynamic allocation
	
	if(nIconNormal>=0){
		mdata->global_offset = AddToGlobalImageList(nIconNormal, static_cast<int>(nID));
	}
	else mdata->global_offset = GlobalImageListOffset(static_cast<int>(nID));
	mdata->nFlags = nFlags;
	mdata->nID = nID;
	bool returnflag=!!CMenu::InsertMenu(nPosition,nFlags,nID,MakeItemData(mdata));
	if(m_loadmenu)RemoveTopLevelOwnerDraw();
	return returnflag;
}

bool BCMenu::ModifyODMenu(const wchar_t *lpstrText,UINT_PTR nID,int nIconNormal)
{
	UINT nLoc;
	BCMenuData *mdata;
	CArray<BCMenu*,BCMenu*>bcsubs;
	CArray<UINT,UINT&>bclocs;
	
	// Find the old BCMenuData structure:
	BCMenu *psubmenu = FindMenuOption(static_cast<int>(nID),nLoc);
	do{
		if(psubmenu!=nullptr && nLoc!=-1)mdata = psubmenu->m_MenuList[nLoc];
		else{
			// Create a new BCMenuData structure:
			mdata = new BCMenuData;
			m_MenuList.Add(mdata);
		}
		
		ASSERT(mdata != nullptr);
		if(lpstrText != nullptr)
			mdata->SetWideString(lpstrText);  //SK: modified for dynamic allocation
		if(nIconNormal>=0){
			mdata->global_offset = AddToGlobalImageList(nIconNormal, static_cast<int>(nID));
		}
		else mdata->global_offset = GlobalImageListOffset(static_cast<int>(nID));
		mdata->nFlags &= ~(MF_BYPOSITION);
		mdata->nFlags |= MakeOwnerDrawFlag();
		mdata->nID = nID;
		bcsubs.Add(psubmenu);
		bclocs.Add(nLoc);
		if(psubmenu!=nullptr && nLoc!=-1)
			psubmenu = FindAnotherMenuOption(static_cast<int>(nID),nLoc,bcsubs,bclocs);
		else 
			psubmenu=nullptr;
	}while(psubmenu != nullptr);
	return !!CMenu::ModifyMenu(static_cast<UINT>(nID),mdata->nFlags, static_cast<UINT>(nID),MakeItemData(mdata));
}

BCMenuData *BCMenu::NewODMenu(UINT pos,UINT nFlags,UINT_PTR nID,CString string)
{
	BCMenuData *mdata;
	
	mdata = new BCMenuData;
	mdata->SetWideString((LPCTSTR)string);//SK: modified for dynamic allocation
	mdata->nFlags = nFlags;
	mdata->nID = nID;
	
//	if((nFlags & MF_POPUP)!=0)m_AllSubMenus.Add((HMENU)nID);
		
	if ((nFlags&MF_OWNERDRAW)!=0){
		ModifyMenu(pos,nFlags,nID,MakeItemData(mdata));
	}
	else
	if ((nFlags&MF_SEPARATOR)!=0){
		ModifyMenu(pos,nFlags,nID);
	}
	else{
		ModifyMenu(pos,nFlags,nID,mdata->GetString());
	}
	
	return mdata;
};

bool BCMenu::LoadToolbar(UINT nToolBar, CToolBar* pBar)
{
	bool returnflag=false;
	CToolBar barIns;
	CToolBar& bar = pBar ? *pBar : barIns;
	
	if (!pBar)
	{
		CWnd* pWnd = AfxGetMainWnd();
		if (pWnd == nullptr)pWnd = CWnd::GetDesktopWindow();
		bar.Create(pWnd);
	}
	if(pBar || bar.LoadToolBar(nToolBar)){
		returnflag=true;
		for(int i=0;i<bar.GetCount();++i){
			UINT nID = bar.GetItemID(i); 
			if(nID!=0 && GetMenuState(nID, MF_BYCOMMAND)!=0xFFFFFFFF){
				int xoffset=bar.CommandToIndex(nID);
				if(xoffset>=0){
					UINT nStyle;
					int xset;
					bar.GetButtonInfo(xoffset,nID,nStyle,xset);
					if(xset>0)xoffset=xset;
				}
				ModifyODMenu(nullptr, nID, MAKELONG(nToolBar, 0x4000 + xoffset));
			}
		}
	}
	return returnflag;
}

// O.S.
BCMenuData *BCMenu::FindMenuItem(UINT_PTR nID)
{
	BCMenuData *pData = nullptr;
	int i;
	
	for(i = 0; i <= m_MenuList.GetUpperBound(); i++){
		if (m_MenuList[i]->nID == nID){
			pData = m_MenuList[i];
			break;
		}
	}
	if (pData == nullptr){
		UINT loc;
		BCMenu *pMenu = FindMenuOption(static_cast<int>(nID), loc);
		ASSERT (pMenu != this);
		if (loc != -1){
			return pMenu->FindMenuItem(nID);
		}
	}
	return pData;
}


BCMenu *BCMenu::FindAnotherMenuOption(int nId,UINT& nLoc,CArray<BCMenu*,BCMenu*>&bcsubs,
									  CArray<UINT,UINT&>&bclocs)
{
	BCMenu *psubmenu,*pgoodmenu;
	bool foundflag;
	int nummenu = GetMenuItemCount();
	
	for(int i=0;i<nummenu;++i){
#ifdef _CPPRTTI 
		psubmenu=dynamic_cast<BCMenu *>(GetSubMenu(i));
#else
		psubmenu=static_cast<BCMenu *>(GetSubMenu((int)i));
#endif
		if(psubmenu != nullptr){
			pgoodmenu=psubmenu->FindAnotherMenuOption(nId,nLoc,bcsubs,bclocs);
			if(pgoodmenu != nullptr)
				return pgoodmenu;
		}
		else if(nId==(int)GetMenuItemID(i)){
			INT_PTR numsubs=bcsubs.GetSize();
			foundflag=true;
			for(INT_PTR j=0;j<numsubs;++j){
				if(bcsubs[j]==this && bclocs[j]==static_cast<UINT>(i)){
					foundflag=false;
					break;
				}
			}
			if(foundflag){
				nLoc=static_cast<UINT>(i);
				return this;
			}
		}
	}
	nLoc = static_cast<UINT>(-1);
	return nullptr;
}

BCMenu *BCMenu::FindMenuOption(int nId,UINT& nLoc)
{
	BCMenu *psubmenu,*pgoodmenu;
	int nummenu = GetMenuItemCount();
	
	for(int i=0;i<nummenu;++i){
#ifdef _CPPRTTI 
		psubmenu=dynamic_cast<BCMenu *>(GetSubMenu(i));
#else
		psubmenu=static_cast<BCMenu *>(GetSubMenu(i));
#endif
		if(psubmenu != nullptr){
			pgoodmenu=psubmenu->FindMenuOption(nId,nLoc);
			if(pgoodmenu != nullptr)
				return pgoodmenu;
		}
		else if(nId==(int)GetMenuItemID(i)){
			nLoc=i;
			return this;
		}
	}
	nLoc = static_cast<UINT>(-1);
	return nullptr;
}

BCMenuData *BCMenu::FindMenuOption(wchar_t *lpstrText)
{
	BCMenu *psubmenu;
	BCMenuData *pmenulist;
	int nummenu = GetMenuItemCount();
	
	for(int i=0;i<nummenu;++i){
#ifdef _CPPRTTI 
		psubmenu=dynamic_cast<BCMenu *>(GetSubMenu(i));
#else
		psubmenu=static_cast<BCMenu *>(GetSubMenu(i));
#endif
		if(psubmenu != nullptr){
			pmenulist=psubmenu->FindMenuOption(lpstrText);
			if(pmenulist != nullptr)
				return pmenulist;
		}
		else{
			for(int j=0;j<=m_MenuList.GetUpperBound();++j){     
				const wchar_t *szWide;//SK: we use const to prevent misuse of this Ptr
				szWide = m_MenuList[j]->GetWideString ();
				if(szWide != nullptr && wcscmp(lpstrText,szWide)==0)//SK: modified for dynamic allocation
					return m_MenuList[j];
			}
		}
	}
	return nullptr;
}

BOOL BCMenu::LoadMenu(LPCTSTR lpszResourceName)
{
	ASSERT_VALID(this);
	ASSERT(lpszResourceName != nullptr);
	
	// Find the Menu Resource:
	HINSTANCE hInst = AfxFindResourceHandle(lpszResourceName,RT_MENU);
	HRSRC hRsrc = ::FindResource(hInst,lpszResourceName,RT_MENU);
	if (hRsrc == nullptr){
		hInst = nullptr;
		hRsrc = ::FindResource(hInst,lpszResourceName,RT_MENU);
	}
	if(hRsrc == nullptr)
		return FALSE;
	
	// Load the Menu Resource:
	
	HGLOBAL hGlobal = LoadResource(hInst, hRsrc);
	if(hGlobal == nullptr)
		return FALSE;

	// first destroy the menu if we're trying to loadmenu again
	DestroyMenu();

	// Attempt to create us as a menu...
	if(!CMenu::CreateMenu())
		return FALSE;
	
	// Get Item template Header, and calculate offset of MENUITEMTEMPLATES
	
	MENUITEMTEMPLATEHEADER *pTpHdr=
		(MENUITEMTEMPLATEHEADER*)LockResource(hGlobal);
	BYTE* pTp=(BYTE*)pTpHdr + 
		(sizeof(MENUITEMTEMPLATEHEADER) + pTpHdr->offset);
	
	
	// Variables needed during processing of Menu Item Templates:
	
	WORD    dwFlags = 0;              // Flags of the Menu Item
	WORD    dwID  = 0;              // ID of the Menu Item
	CTypedPtrArray<CPtrArray, BCMenu*>  stack;    // Popup menu stack
	CArray<bool,bool>  stackEnd;    // Popup menu stack
	stack.Add(this);                  // Add it to this...
	stackEnd.Add(false);
	
	do{
		// Obtain Flags and (if necessary), the ID...
		memcpy(&dwFlags, pTp, sizeof(WORD));pTp+=sizeof(WORD);// Obtain Flags
		if((dwFlags & MF_POPUP)==0){
			memcpy(&dwID, pTp, sizeof(WORD)); // Obtain ID
			pTp+=sizeof(WORD);
		}
		else dwID = 0;
		
		UINT uFlags = (UINT)dwFlags; // Remove MF_END from the flags that will
		if((uFlags & MF_END) != 0) // be passed to the Append(OD)Menu functions.
			uFlags -= MF_END;
		
		// Obtain Caption (and length)
		
		const size_t CaptionSiz = wcslen((wchar_t *)pTp)+1;
		wchar_t *szCaption=new wchar_t[CaptionSiz];
		wcscpy_s(szCaption, CaptionSiz, reinterpret_cast<wchar_t *>(pTp));
		pTp=&pTp[(wcslen((wchar_t *)pTp)+1)*sizeof(wchar_t)];//modified SK
		
		// Handle popup menus first....
		
		//WideCharToMultiByte
		if((dwFlags & MF_POPUP)!=0){
			if((dwFlags & MF_END)!=0)
				stackEnd.SetAt(stack.GetUpperBound(),true);
			BCMenu* pSubMenu = new BCMenu;
			pSubMenu->CreatePopupMenu();
			
			// Append it to the top of the stack:
			
			stack[stack.GetUpperBound()]->AppendODMenu(szCaption,uFlags,
				(UINT_PTR)pSubMenu->m_hMenu, -1);
			stack.Add(pSubMenu);
			stackEnd.Add(false);
		}
		else {
			stack[stack.GetUpperBound()]->AppendODMenu(szCaption, uFlags,
				dwID, -1);
			if((dwFlags & MF_END)!=0)
				stackEnd.SetAt(stack.GetUpperBound(),true);
			INT_PTR j = stack.GetUpperBound();
			while(j>=0 && stackEnd.GetAt(j)){
				stack.RemoveAt(j);
				stackEnd.RemoveAt(j);
				--j;
			}
		}
		
		delete[] szCaption;
	}while(stack.GetUpperBound() != -1);
	
	int nummenu = GetMenuItemCount();
	for(int i=0;i<nummenu;++i){
		CString str=m_MenuList[i]->GetString();
		if(GetSubMenu(i)){
			m_MenuList[i]->nFlags=MF_POPUP|MF_BYPOSITION;
			ModifyMenu(i,MF_POPUP|MF_BYPOSITION,
				(UINT_PTR)GetSubMenu(i)->m_hMenu,str);
		}
		else{
			m_MenuList[i]->nFlags=MF_STRING|MF_BYPOSITION;
			ModifyMenu(i,MF_STRING|MF_BYPOSITION,m_MenuList[i]->nID,str);
		}
	}

	m_loadmenu=true;
	
	return TRUE;
}

int BCMenu::GetMenuStart(void)
{
	if(!m_loadmenu)return 0;

	CString name,str;
	int menuloc=-1,listloc=-1,menustart=0,i=0;
	INT_PTR nummenulist=m_MenuList.GetSize();
	int nummenu=GetMenuItemCount();

	while(i<nummenu&&menuloc==-1){
		GetMenuString (i, name, MF_BYPOSITION);
		if(name.GetLength()>0){
			for(int j=0;j<nummenulist;++j){
				str=m_MenuList[j]->GetString();
				if(name==str){
					menuloc=i;
					listloc=j;
					break;
				}
			}
		}
		++i;
	}
	if(menuloc>=0&&listloc>=0&&menuloc>=listloc)menustart=menuloc-listloc;
	return menustart;
}

void BCMenu::RemoveTopLevelOwnerDraw(void)
{
	CString str;
	INT_PTR nummenulist=m_MenuList.GetSize();
	int nummenu = GetMenuItemCount();

	int menustart=GetMenuStart();
	for(int i=menustart,j=0;i<nummenu;++i,++j){
		if(j<nummenulist){
			str=m_MenuList[j]->GetString();
			if(GetSubMenu(i)){
				m_MenuList[j]->nFlags=MF_POPUP|MF_BYPOSITION;
				ModifyMenu(i,MF_POPUP|MF_BYPOSITION,
					(UINT_PTR)GetSubMenu(i)->m_hMenu,str);
			}
		}
	}

}

//--------------------------------------------------------------------------
//[18.06.99 rj]
bool BCMenu::GetMenuText(UINT id, CString& string, UINT nFlags/*= MF_BYPOSITION*/)
{
	bool returnflag=false;
	
	if((MF_BYPOSITION&nFlags) != 0){
		INT_PTR numMenuItems = m_MenuList.GetUpperBound();
		if(static_cast<INT_PTR>(id)<=numMenuItems){
			string=m_MenuList[id]->GetString();
			returnflag=true;
		}
	}
	else{
		UINT uiLoc;
		BCMenu* pMenu = FindMenuOption(id,uiLoc);
		if(pMenu != nullptr) 
			returnflag = pMenu->GetMenuText(uiLoc,string);
	}
	return returnflag;
}


void BCMenu::DrawRadioDot(CDC *pDC,int x,int y,COLORREF color)
{
	CRect rcDot(x,y,x+6,y+6);
	CBrush brush(color);
	CPen pen(PS_SOLID,0,color);
	CBrush *pOldBrush=pDC->SelectObject(&brush);
	CPen *pOldPen=pDC->SelectObject(&pen);
	pDC->Ellipse(&rcDot);
	pDC->SelectObject(pOldBrush);
	pDC->SelectObject(pOldPen);
}

void BCMenu::DrawCheckMark(CDC* pDC,int x,int y,COLORREF color,bool narrowflag /*= false*/)
{
	int dp=0;
	CPen penBack(PS_SOLID,0,color);
	CPen *pOldPen = pDC->SelectObject (&penBack);
	if(narrowflag)dp=1;

	pDC->MoveTo(x,y+2);
	pDC->LineTo(x,y+5-dp);
	
	pDC->MoveTo(x+1,y+3);
	pDC->LineTo(x+1,y+6-dp);
	
	pDC->MoveTo(x+2,y+4);
	pDC->LineTo(x+2,y+7-dp);
	
	pDC->MoveTo(x+3,y+3);
	pDC->LineTo(x+3,y+6-dp);
	
	pDC->MoveTo(x+4,y+2);
	pDC->LineTo(x+4,y+5-dp);
	
	pDC->MoveTo(x+5,y+1);
	pDC->LineTo(x+5,y+4-dp);
	
	pDC->MoveTo(x+6,y);
	pDC->LineTo(x+6,y+3-dp);
	
	pDC->SelectObject (pOldPen);
}

BCMenuData *BCMenu::FindMenuList(UINT_PTR nID)
{
	for(int i=0;i<=m_MenuList.GetUpperBound();++i){
		if(m_MenuList[i]->nID==nID && !m_MenuList[i]->syncflag){
			m_MenuList[i]->syncflag=1;
			return m_MenuList[i];
		}
	}
	return nullptr;
}

void BCMenu::InitializeMenuList(int value)
{
	for(int i=0;i<=m_MenuList.GetUpperBound();++i)
		m_MenuList[i]->syncflag=value;
}

void BCMenu::DeleteMenuList(void)
{
	for(int i=0;i<=m_MenuList.GetUpperBound();++i){
		if(m_MenuList[i]->syncflag==0){
			delete m_MenuList[i];
		}
	}
}

void BCMenu::SetMenuItemBitmap(intptr_t xoffset, int pos, unsigned state)
{
	if (m_AllImagesID[xoffset].state == state && m_AllImagesID[xoffset].pBitmap)
	{
		SetMenuItemBitmaps(static_cast<UINT>(pos), MF_BYPOSITION, m_AllImagesID[xoffset].pBitmap.get(), nullptr);
		return;
	}

	const int cxSMIcon = GetSystemMetrics(SM_CXSMICON);
	const int cySMIcon = GetSystemMetrics(SM_CYSMICON);

	LoadImages();

	BYTE* pBits;
	BITMAPINFO bmi{ sizeof(BITMAPINFOHEADER), cxSMIcon, -cySMIcon, 1, 32, BI_RGB };
	CBitmap *pBitmap = new CBitmap();
	HBITMAP hBitmap = CreateDIBSection(nullptr, &bmi, DIB_RGB_COLORS, (void**)&pBits, nullptr, 0);
	pBitmap->Attach(hBitmap);
	CDC dcMem;
	dcMem.CreateCompatibleDC(nullptr);
	CBitmap* pOldBitmap = dcMem.SelectObject(pBitmap);
	CImage bitmapstandard;
	GetBitmapFromImageList(nullptr, (int)xoffset, bitmapstandard);
	if ((state & ODS_GRAYED) != 0)
		GetDisabledBitmap(bitmapstandard);
	m_gdiplusToken.InitGdiplus();
	Gdiplus::Bitmap bm(bitmapstandard.GetWidth(), bitmapstandard.GetHeight(),
		bitmapstandard.GetPitch(), PixelFormat32bppARGB, (BYTE*)bitmapstandard.GetBits());
	Gdiplus::Graphics dcDst(dcMem.m_hDC);
	dcDst.SetInterpolationMode(Gdiplus::InterpolationModeHighQualityBicubic);
	Gdiplus::Rect rcDst(0, 0, cxSMIcon, cySMIcon);
	dcDst.DrawImage(&bm, rcDst, 0, 0, m_iconX, m_iconY, Gdiplus::UnitPixel);
	dcMem.SelectObject(pOldBitmap);
	SetMenuItemBitmaps(static_cast<UINT>(pos), MF_BYPOSITION, pBitmap, nullptr);
	m_AllImagesID[xoffset].pBitmap.reset(pBitmap);
	m_AllImagesID[xoffset].state = state;
}

void BCMenu::SynchronizeMenu(void)
{
	CTypedPtrArray<CPtrArray, BCMenuData*> temp;
	CString string;
	UINT_PTR submenu,nID=0;
	
	InitializeMenuList(0);
	for(int j=0;j<GetMenuItemCount();++j){
		BCMenuData *mdata=nullptr;
		UINT state=GetMenuState(j,MF_BYPOSITION);
		if((state&MF_POPUP)!=0){
			submenu=(UINT_PTR)GetSubMenu(j)->m_hMenu;
			mdata=FindMenuList(submenu);
			GetMenuString(j,string,MF_BYPOSITION);
			if(mdata == nullptr)mdata=NewODMenu(j,
				(state&0xFF)|MF_BYPOSITION|MF_POPUP|MakeOwnerDrawFlag(),submenu,string);
			else if(string.GetLength()>0)
				mdata->SetWideString(string);  //SK: modified for dynamic allocation
		}
		else 
		if((state&MF_SEPARATOR)!=0){
			mdata=FindMenuList(0);
			if(mdata == nullptr)mdata=NewODMenu(j,
				state|MF_BYPOSITION|MF_SEPARATOR|MakeOwnerDrawFlag(),0,_T(""));//SK: modified for Unicode correctness
			else ModifyMenu(j,mdata->nFlags,nID,MakeItemData(mdata));
		}
		else{
			nID=GetMenuItemID(j);
			mdata=FindMenuList(nID);
			GetMenuString(j,string,MF_BYPOSITION);
			if(mdata == nullptr)
				mdata=NewODMenu(j,state|MF_BYPOSITION|MakeOwnerDrawFlag(),nID,string);
			else{
				mdata->nFlags=state|MF_BYPOSITION|MakeOwnerDrawFlag();
				if(string.GetLength()>0)
					mdata->SetWideString(string);//SK: modified for dynamic allocation
				
				ModifyMenu(j,mdata->nFlags,nID,MakeItemData(mdata));
			}
			if(!m_bEnableOwnerDraw && mdata->global_offset >= 0)
				SetMenuItemBitmap(mdata->global_offset,j,state);
		}
		if(mdata != nullptr)temp.Add(mdata);
	}
	DeleteMenuList();
	m_MenuList.RemoveAll();
	m_MenuList.Append(temp);
	temp.RemoveAll(); 
}

void BCMenu::UpdateMenu(CMenu *pmenu)
{
#ifdef _CPPRTTI 
	BCMenu *psubmenu = dynamic_cast<BCMenu *>(pmenu);
#else
	BCMenu *psubmenu = static_cast<BCMenu *>(pmenu);
#endif
	if(psubmenu != nullptr)psubmenu->SynchronizeMenu();
}

LRESULT BCMenu::FindKeyboardShortcut(UINT nChar, UINT nFlags,
                                     CMenu *pMenu)
{
#ifdef _CPPRTTI 
	BCMenu *pBCMenu = dynamic_cast<BCMenu *>(pMenu);
#else
	BCMenu *pBCMenu = static_cast<BCMenu *>(pMenu);
#endif
	if(pBCMenu!=nullptr && (nFlags&MF_POPUP)!=0){
		CString key(_T('&'),2);//SK: modified for Unicode correctness
		key.SetAt(1,(TCHAR)nChar);
		key.MakeLower();
		CString menutext;
		int menusize = pBCMenu->GetMenuItemCount();
		if(menusize!=(pBCMenu->m_MenuList.GetUpperBound()+1))
			pBCMenu->SynchronizeMenu();
		for(int i=0;i<menusize;++i){
			if(pBCMenu->GetMenuText(i,menutext)){
				menutext.MakeLower();
				if(menutext.Find(key)>=0)return MAKELRESULT(i,2);
			}
		}
	}
	return 0;
}

void BCMenu::GetTransparentBitmap(CBitmap &bmp)
{
	CDC ddc;
	COLORREF col,newcol;
	BITMAP BitMap;

	bmp.GetBitmap(&BitMap);
	ddc.CreateCompatibleDC(nullptr);
	CBitmap * pddcOldBmp = ddc.SelectObject(&bmp);

	// use this to get the background color, takes into account color shifting
	CDC ddc2;
	CBitmap bmp2;
	ddc2.CreateCompatibleDC(nullptr);
	bmp2.CreateCompatibleBitmap(&ddc,BitMap.bmWidth,BitMap.bmHeight);
	col=RGB(255,0,255); // Original was RGB(192,192,192)
	CBitmap * pddcOldBmp2 = ddc2.SelectObject(&bmp2);
	CRect rect(0,0,BitMap.bmWidth,BitMap.bmHeight);
	CBrush cbTemp = col;
	ddc2.FillRect(rect, &cbTemp);
	ddc2.SelectObject(pddcOldBmp2);
	newcol=GetSysColor(COLOR_3DFACE);

	pBGR pdstBGR = MyGetDibBits(ddc2.m_hDC,(HBITMAP)bmp.m_hObject,BitMap.bmWidth,BitMap.bmHeight);
	sBGR bgcolBGR = *pdstBGR;
	sBGR newcolBGR = {GetBValue(newcol),GetGValue(newcol), GetRValue(newcol),0};
	pBGR pcurBGR = pdstBGR;

	for(int i=0;i<BitMap.bmWidth;++i){
		for(int j=0;j<BitMap.bmHeight;++j){
			if(*(DWORD *)pcurBGR == *(DWORD *)&bgcolBGR)
				*pcurBGR = newcolBGR;
			pcurBGR++;
		}
	}

	MySetDibBits(ddc2.m_hDC, (HBITMAP)bmp.m_hObject,pdstBGR,BitMap.bmWidth,BitMap.bmHeight);
	free(pdstBGR);

	ddc.SelectObject(pddcOldBmp);
}

void BCMenu::GetDisabledBitmap(CBitmap &bmp,COLORREF background)
{
	CDC ddc;
	COLORREF discol;
	BITMAP BitMap;

	bmp.GetBitmap(&BitMap);
	ddc.CreateCompatibleDC(nullptr);
	CBitmap * pddcOldBmp = ddc.SelectObject(&bmp);

	// use this to get the background color, takes into account color shifting
	CDC ddc2;
	CBitmap bmp2;
	ddc2.CreateCompatibleDC(nullptr);
	bmp2.CreateCompatibleBitmap(&ddc,BitMap.bmWidth,BitMap.bmHeight);
	CBitmap * pddcOldBmp2 = ddc2.SelectObject(&bmp2);
	CRect rect(0,0,BitMap.bmWidth,BitMap.bmHeight);
	CBrush cbTemp = GetSysColor(COLOR_3DFACE);
	ddc2.FillRect(rect, &cbTemp);
	ddc2.SelectObject(pddcOldBmp2);
	discol=GetSysColor(COLOR_BTNSHADOW);

	pBGR pdstBGR = MyGetDibBits(ddc2.m_hDC,(HBITMAP)bmp.m_hObject,BitMap.bmWidth,BitMap.bmHeight);
	sBGR bgcolBGR = *pdstBGR;
	sBGR backgroundBGR = {GetBValue(background),GetGValue(background),GetRValue(background),0};
	pBGR pcurBGR = pdstBGR;

	for(int i=0;i<BitMap.bmWidth;++i){
		for(int j=0;j<BitMap.bmHeight;++j){
			if(*(DWORD *)pcurBGR != *(DWORD *)&bgcolBGR){
				int avgcol = ((DWORD)pcurBGR->r+(DWORD)pcurBGR->g+(DWORD)pcurBGR->b)/3;
				double factor = avgcol/255.0;
				COLORREF newcol = LightenColor(discol,factor);
				sBGR newcolBGR = {GetBValue(newcol),GetGValue(newcol),GetRValue(newcol),0};
				*pcurBGR = newcolBGR;
			}
			else{
				if(background)
					*pcurBGR = backgroundBGR;
			}
			pcurBGR++;
		}
	}

	MySetDibBits(ddc2.m_hDC,(HBITMAP)bmp.m_hObject,pdstBGR,BitMap.bmWidth,BitMap.bmHeight);
	free(pdstBGR);

	ddc.SelectObject(pddcOldBmp);
}

void BCMenu::GetDisabledBitmap(CImage &bmp)
{
	COLORREF discol=GetSysColor(COLOR_BTNSHADOW);
	pBGR pcurBGR = static_cast<pBGR>(bmp.GetBits());

	for(int i=0;i<bmp.GetWidth();++i){
		for(int j=0;j<bmp.GetHeight();++j){
			int avgcol = ((DWORD)pcurBGR->r+(DWORD)pcurBGR->g+(DWORD)pcurBGR->b)/3;
			double factor = avgcol/255.0;
			COLORREF newcol = LightenColor(discol,factor);
			sBGR newcolBGR = {GetBValue(newcol),GetGValue(newcol),GetRValue(newcol),pcurBGR->pad};
			*pcurBGR = newcolBGR;
			pcurBGR++;
		}
	}
}

bool BCMenu::AddBitmapToImageList(CImageList *bmplist,UINT nResourceID)
{
	bool bReturn=false;

	HBITMAP hbmp=LoadSysColorBitmap(nResourceID);
	if(hbmp!=nullptr){
		CBitmap bmp;
		bmp.Attach(hbmp);
		if(bmplist->Add(&bmp,GetBitmapBackground())>=0)bReturn=true;
	}
	else{ // a hicolor bitmap
		CBitmap mybmp;
		VERIFY(mybmp.LoadBitmap(nResourceID));
		if (!mybmp.m_hObject)
			mybmp.CreateBitmap(16, 15, 1, 32, nullptr);
		hicolor_bitmaps=true;
		GetTransparentBitmap(mybmp);
		if(bmplist->Add(&mybmp,GetBitmapBackground())>=0)bReturn=true;
	}
	return bReturn;
}

bool BCMenu::ReplaceBitmapInImageList(CImageList* bmplist, int xoffset, UINT nResourceID)
{
	bool result = AddBitmapToImageList(bmplist, nResourceID);
	const int cnt = bmplist->GetImageCount();
	if (xoffset < cnt - 1)
	{
		bmplist->Copy(xoffset, cnt - 1);
		bmplist->Remove(cnt - 1);
	}
	return result;
}

bool BCMenu::Draw3DCheckmark(CDC *dc, const CRect& rc,
                             bool bSelected, HBITMAP hbmCheck)
{
	CRect rcDest = rc;
	COLORREF col=GetSysColor(COLOR_MENU);
	if(!bSelected)col = LightenColor(col,0.6);
	CBrush cbTemp = col;
	dc->FillRect(rcDest, &cbTemp);
	dc->DrawEdge(&rcDest, BDR_SUNKENOUTER, BF_RECT);
	if (hbmCheck == nullptr)
		DrawCheckMark(dc,rc.left+4,rc.top+4,GetSysColor(COLOR_MENUTEXT));
	else 
		DrawRadioDot(dc,rc.left+5,rc.top+4,GetSysColor(COLOR_MENUTEXT));
	return true;
}

void BCMenu::DitherBlt2(CDC *drawdc, int nXDest, int nYDest, int nWidth, 
                        int nHeight, CBitmap &bmp, int nXSrc, int nYSrc,
						COLORREF bgcolor)
{
	// create a monochrome memory DC
	CDC ddc;
	ddc.CreateCompatibleDC(nullptr);
	CBitmap bwbmp;
	bwbmp.CreateCompatibleBitmap(&ddc, nWidth, nHeight);
	CBitmap * pddcOldBmp = ddc.SelectObject(&bwbmp);
	
	CDC dc;
	dc.CreateCompatibleDC(nullptr);
	CBitmap * pdcOldBmp = dc.SelectObject(&bmp);
	
	// build a mask
	ddc.PatBlt(0, 0, nWidth, nHeight, WHITENESS);
	dc.SetBkColor(GetSysColor(COLOR_BTNFACE));
	ddc.BitBlt(0, 0, nWidth, nHeight, &dc, nXSrc,nYSrc, SRCCOPY);
	dc.SetBkColor(GetSysColor(COLOR_BTNHILIGHT));
	ddc.BitBlt(0, 0, nWidth, nHeight, &dc, nXSrc,nYSrc, SRCPAINT);
	
	// Copy the image from the toolbar into the memory DC
	// and draw it (grayed) back into the toolbar.
	dc.FillSolidRect(0,0, nWidth, nHeight, bgcolor);
	//SK: Looks better on the old shell
	dc.SetBkColor(RGB(0, 0, 0));
	dc.SetTextColor(RGB(255, 255, 255));
	CBrush brHilight(GetSysColor(COLOR_BTNHILIGHT));
	CBrush brShadow(GetSysColor(COLOR_BTNSHADOW));
	CBrush * pOldBrush = dc.SelectObject(&brHilight);
	dc.BitBlt(0,0, nWidth, nHeight, &ddc, 0, 0, 0x00E20746L);
	drawdc->BitBlt(nXDest+1,nYDest+1,nWidth, nHeight, &dc,0,0,SRCCOPY);
	dc.BitBlt(1,1, nWidth, nHeight, &ddc, 0, 0, 0x00E20746L);
	dc.SelectObject(&brShadow);
	dc.BitBlt(0,0, nWidth, nHeight, &ddc, 0, 0, 0x00E20746L);
	drawdc->BitBlt(nXDest,nYDest,nWidth, nHeight, &dc,0,0,SRCCOPY);
	// reset DCs
	ddc.SelectObject(pddcOldBmp);
	dc.SelectObject(pOldBrush);
	dc.SelectObject(pdcOldBmp);
}

void BCMenu::DitherBlt3(CDC *drawdc, int nXDest, int nYDest, int nWidth, 
                        int nHeight, CBitmap &bmp,COLORREF bgcolor)
{
	GetDisabledBitmap(bmp,bgcolor);
	CDC dc;
	dc.CreateCompatibleDC(nullptr);
	CBitmap * pdcOldBmp = dc.SelectObject(&bmp);
	drawdc->BitBlt(nXDest,nYDest,nWidth, nHeight, &dc,0,0,SRCCOPY);
	// reset DCs
	dc.SelectObject(pdcOldBmp);
}

WORD BCMenu::NumBitmapColors(LPBITMAPINFOHEADER lpBitmap)
{
	WORD returnval = 0;

	if ( lpBitmap->biClrUsed != 0){
		returnval=(WORD)lpBitmap->biClrUsed;
	}
	else{
		switch (lpBitmap->biBitCount){
			case 1:
				returnval=2;
				break;
			case 4:
				returnval=16;
				break;
			case 8:
				returnval=256;
				break;
			default:
				returnval=0;
				break;
		}
	}
	return returnval;
}

HBITMAP BCMenu::LoadSysColorBitmap(int nResourceId)
{
	HINSTANCE hInst = 
		AfxFindResourceHandle(MAKEINTRESOURCE(nResourceId),RT_BITMAP);
	HRSRC hRsrc = 
		::FindResource(hInst,MAKEINTRESOURCE(nResourceId),RT_BITMAP);
	if (hRsrc == nullptr){
		hInst = nullptr;
		hRsrc = ::FindResource(hInst,MAKEINTRESOURCE(nResourceId),RT_BITMAP);
	}
	if (hRsrc == nullptr)
		return nullptr;

	// determine how many colors in the bitmap
	HGLOBAL hglb;
	if ((hglb = LoadResource(hInst, hRsrc)) == nullptr)
		return nullptr;
	LPBITMAPINFOHEADER lpBitmap = (LPBITMAPINFOHEADER)LockResource(hglb);
	if (lpBitmap == nullptr)
		return nullptr;
	WORD numcol = NumBitmapColors(lpBitmap);
	::FreeResource(hglb);

	if(numcol!=16)
		return nullptr;

	return ::AfxLoadSysColorBitmap(hInst, hRsrc, FALSE);
}

bool BCMenu::RemoveMenu(UINT uiId,UINT nFlags)
{
	if(MF_BYPOSITION&nFlags){
		UINT uint = GetMenuState(uiId,MF_BYPOSITION);
		if((uint&MF_SEPARATOR)!=0 && (uint&MF_POPUP)==0){
			delete m_MenuList.GetAt(uiId);
			m_MenuList.RemoveAt(uiId);
		}
		else{
			BCMenu* pSubMenu = static_cast<BCMenu*>(GetSubMenu(uiId));
			if(pSubMenu == nullptr){
				UINT uiCommandId = GetMenuItemID(uiId);
				for(int i=0;i<m_MenuList.GetSize(); i++){
					if(m_MenuList[i]->nID==uiCommandId){
						delete m_MenuList.GetAt(i);
						m_MenuList.RemoveAt(i);
						break;
					}
				}
			}
			else{
				INT_PTR numSubMenus = m_SubMenus.GetUpperBound();
				for(INT_PTR m = numSubMenus; m >= 0; m--){
					if(m_SubMenus[m]==pSubMenu->m_hMenu){
						INT_PTR numAllSubMenus = m_AllSubMenus.GetUpperBound();
						for(INT_PTR n = numAllSubMenus; n>= 0; n--){
							if(m_AllSubMenus[n]==m_SubMenus[m])m_AllSubMenus.RemoveAt(n);
						}
						m_SubMenus.RemoveAt(m);
					}
				}
				int num = pSubMenu->GetMenuItemCount();
				int i=0;
				for(i=num-1;i>=0;--i)pSubMenu->RemoveMenu(i,MF_BYPOSITION);
				for(i=(int)m_MenuList.GetUpperBound();i>=0;i--){
					if(m_MenuList[i]->nID==(UINT_PTR)pSubMenu->m_hMenu){
						delete m_MenuList.GetAt(i);
						m_MenuList.RemoveAt(i);
						break;
					}
				}
				delete pSubMenu; 
			}
		}
	}
	else{
		UINT iPosition =0;
		BCMenu* pMenu = FindMenuOption(uiId,iPosition);
		// bug fix RIA 14th September 2000 
		// failed to return correct value on call to remove menu as the item was 
		// removed twice. The second time its not found 
		// so a value of 0 was being returned 
		if(pMenu != nullptr) 
			return pMenu->RemoveMenu(iPosition,MF_BYPOSITION); // added return 
	}
	return !!CMenu::RemoveMenu(uiId,nFlags);
}

bool BCMenu::DeleteMenu(UINT uiId,UINT nFlags)
{
	if((MF_BYPOSITION&nFlags)!=0){
		UINT uint = GetMenuState(uiId,MF_BYPOSITION);
		if((uint&MF_SEPARATOR)!=0 && (uint&MF_POPUP)==0){
			// make sure it's a separator
			INT_PTR menulistsize=m_MenuList.GetSize();	
			if(uiId<(UINT)menulistsize){
				CString str=m_MenuList[uiId]->GetString();
				if(str.IsEmpty()){
					delete m_MenuList.GetAt(uiId);
					m_MenuList.RemoveAt(uiId);
				}
			}
		}
		else{
			BCMenu* pSubMenu = static_cast<BCMenu*>(GetSubMenu(uiId));
			if(pSubMenu == nullptr){
				UINT uiCommandId = GetMenuItemID(uiId);
				for(int i=0;i<m_MenuList.GetSize(); i++){
					if(m_MenuList[i]->nID==uiCommandId){
						delete m_MenuList.GetAt(i);
						m_MenuList.RemoveAt(i);
						break;
					}
				}
			}
			else{
				INT_PTR numSubMenus = m_SubMenus.GetUpperBound();
				for(INT_PTR m = numSubMenus; m >= 0; m--){
					if(m_SubMenus[m]==pSubMenu->m_hMenu){
						INT_PTR numAllSubMenus = m_AllSubMenus.GetUpperBound();
						for(INT_PTR n = numAllSubMenus; n>= 0; n--){
							if(m_AllSubMenus[n]==m_SubMenus[m])m_AllSubMenus.RemoveAt(n);
						}
						m_SubMenus.RemoveAt(m);
					}
				}
				int num = pSubMenu->GetMenuItemCount();
				for(int i=num-1;i>=0;--i)pSubMenu->DeleteMenu(i,MF_BYPOSITION);
				for(INT_PTR i=m_MenuList.GetUpperBound();i>=0;i--){
					if(m_MenuList[i]->nID==(UINT_PTR)pSubMenu->m_hMenu){
						delete m_MenuList.GetAt(i);
						m_MenuList.RemoveAt(i);
						break;
					}
				}
				delete pSubMenu;
			}
		}
	}
	else{
		UINT iPosition =0;
		BCMenu* pMenu = FindMenuOption(uiId,iPosition);
		if(pMenu != nullptr)
			return pMenu->DeleteMenu(iPosition,MF_BYPOSITION);
	}

	return !!CMenu::DeleteMenu(uiId,nFlags);
}

// Larry Antram
bool BCMenu::SetMenuText(UINT id, CString string, UINT nFlags/*= MF_BYPOSITION*/ )
{
	bool returnflag=false;
	
	if((MF_BYPOSITION&nFlags) != 0)
	{
		INT_PTR numMenuItems = m_MenuList.GetUpperBound();
		if(static_cast<INT_PTR>(id)<=numMenuItems){
			m_MenuList[id]->SetWideString((LPCTSTR)string);
			returnflag=true;
		}
	}
	else{
		UINT uiLoc;
		BCMenu* pMenu = FindMenuOption(id,uiLoc);
		if(pMenu != nullptr) 
			returnflag = pMenu->SetMenuText(uiLoc,string);
	}
	return returnflag;
}

int BCMenu::GlobalImageListOffset(int nID)
{
	INT_PTR numcurrent=m_AllImagesID.size();
	int existsloc = -1;
	for(INT_PTR i=0;i<numcurrent;++i){
		if(m_AllImagesID[i].id==nID){
			existsloc=static_cast<int>(i);
			break;
		}
	}
	return existsloc;
}

CBitmap* BCMenu::CreateRadioDotBitmap()
{
	COLORREF textColor = m_menuTextColor;
	COLORREF bkColor = m_menuBgColor;
	if (DarkMode::isEnabled())
	{
		HTHEME hTheme = OpenThemeData(nullptr, _T("DarkMode_ImmersiveStart::Menu"));
		if (hTheme)
		{
			GetThemeColor(hTheme, MENU_POPUPITEM, MPI_NORMAL, TMT_TEXTCOLOR, &textColor);
			GetThemeColor(hTheme, MENU_POPUPBACKGROUND, 0, TMT_FILLCOLOR, &bkColor);
			CloseThemeData(hTheme);
		}
	}
	const BYTE textR = GetRValue(textColor);
	const BYTE textG = GetGValue(textColor);
	const BYTE textB = GetBValue(textColor);
	const BYTE bkR = GetRValue(bkColor);
	const BYTE bkG = GetGValue(bkColor);
	const BYTE bkB = GetBValue(bkColor);
	const int cxSMIcon = GetSystemMetrics(SM_CXSMICON);
	const int cySMIcon = GetSystemMetrics(SM_CYSMICON);
	BYTE* pBits;
	BITMAPINFO bmi{ sizeof(BITMAPINFOHEADER), cxSMIcon, -cySMIcon, 1, 32, BI_RGB };
	CBitmap *pBitmap = new CBitmap();
	HBITMAP hBitmap = CreateDIBSection(nullptr, &bmi, DIB_RGB_COLORS, (void**)&pBits, nullptr, 0);
	pBitmap->Attach(hBitmap);
	CDC dcMem;
	dcMem.CreateCompatibleDC(nullptr);
	CBitmap* pOldBitmap = dcMem.SelectObject(pBitmap);
	CRect rcDot(cxSMIcon/2-cxSMIcon/5,cySMIcon/2-cxSMIcon/5,cxSMIcon/2+cxSMIcon/5,cySMIcon/2+cySMIcon/5);
	DWORD* p = reinterpret_cast<DWORD*>(pBits);
	const int cx = (rcDot.left + rcDot.right ) / 2;
	const int cy = (rcDot.top  + rcDot.bottom) / 2;
	const double r = std::sqrt((cxSMIcon / 5) * (cxSMIcon / 5));
	for (int y = rcDot.top; y < rcDot.bottom; ++y)
	{
		for (int x = rcDot.left; x < rcDot.right; ++x)
		{
			const double d = std::sqrt((x - cx) * (x - cx) + (y - cy) * (y - cy));
			if (d <= r)
			{
				const BYTE alpha =(r - d >= 1.0) ? 255 : static_cast<BYTE>(255.0 * (r - d));
				const BYTE outR = static_cast<BYTE>((textR * alpha + bkR * (255 - alpha)) / 255);
				const BYTE outG = static_cast<BYTE>((textG * alpha + bkG * (255 - alpha)) / 255);
				const BYTE outB = static_cast<BYTE>((textB * alpha + bkB * (255 - alpha)) / 255);
				p[x + y * cxSMIcon] = (0xFF << 24) | (outR << 16) | (outG << 8) | outB;
			}
			else
			{
				p[x + y * cxSMIcon] = (0xFF << 24) | (bkR << 16) | (bkG << 8) | bkB;
			}
		}
	}
	dcMem.SelectObject(pOldBitmap);
	return pBitmap;
}

void BCMenu::LoadImages()
{
	if (!m_bHasNotLoadedImages)
		return;
	HIMAGELIST hImageList = m_AllImages.m_hImageList;
	if(hImageList == nullptr)
		m_AllImages.Create(m_iconX,m_iconY,ILC_COLORDDB|ILC_MASK,1,1);
	std::map<int, std::unique_ptr<CImageList>> mapImageList;
	for (size_t i = 0; i < m_AllImagesID.size(); ++i)
	{
		const int resourceId = m_AllImagesID[i].resourceId;
		if (resourceId != -1)
		{
			if (m_AllImagesID[i].bitmapIndex >= 0)
			{
				if (mapImageList.find(resourceId) == mapImageList.end())
				{
					mapImageList.emplace(resourceId, new CImageList);
					mapImageList[resourceId]->Create(m_iconX, m_iconY, ILC_COLORDDB | ILC_MASK, 1, 1);
					AddBitmapToImageList(mapImageList[resourceId].get(), resourceId);
				}
				HICON hIcon = mapImageList[resourceId]->ExtractIcon(m_AllImagesID[i].bitmapIndex);
				if (static_cast<int>(i) < m_AllImages.GetImageCount())
					m_AllImages.Replace(static_cast<int>(i), hIcon);
				else
					m_AllImages.Add(hIcon);
				DestroyIcon(hIcon);
			}
			else
			{
				ReplaceBitmapInImageList(&m_AllImages, static_cast<int>(i), resourceId);
			}
			m_AllImagesID[i].resourceId = -1;
			m_AllImagesID[i].bitmapIndex = -1;
		}
	}
	m_bHasNotLoadedImages = false;
}

INT_PTR BCMenu::AddToGlobalImageList(int nIconNormal,int nID)
{
	INT_PTR loc = -1;
	INT_PTR numcurrent=m_AllImagesID.size();
	int existsloc = GlobalImageListOffset(nID);
	if(existsloc>=0){
		m_AllImagesID[existsloc].resourceId = (nIconNormal & 0x40000000) ? (nIconNormal & 0xffff) : nIconNormal;
		m_AllImagesID[existsloc].bitmapIndex = (nIconNormal & 0x40000000) ? ((nIconNormal & 0x3fff0000) >> 16) : -1;
		m_AllImagesID[existsloc].pBitmap.reset();
		m_AllImagesID[existsloc].state = 0;
		loc = existsloc;
	}
	else{
		m_AllImagesID.push_back({ nID, 
			(nIconNormal & 0x40000000) ? (nIconNormal & 0xffff) : nIconNormal, 
			(nIconNormal & 0x40000000) ? ((nIconNormal & 0x3fff0000) >> 16) : -1 });
		loc=numcurrent;
	}
	m_bHasNotLoadedImages = true;
	return loc;
}
</file>

<file path="Winmerge-Src/Src/Common/BCMenu.h">
//*************************************************************************
// BCMenu.h : header file
// Version : 3.036
// Date : June 2005
// Author : Brent Corkum
// Email :  corkum@rocscience.com
// Latest Version : http://www.rocscience.com/~corkum/BCMenu.html
// 
// Bug Fixes and portions of code supplied by:
//
// Ben Ashley,Girish Bharadwaj,Jean-Edouard Lachand-Robert,
// Robert Edward Caldecott,Kenny Goers,Leonardo Zide,
// Stefan Kuhr,Reiner Jung,Martin Vladic,Kim Yoo Chul,
// Oz Solomonovich,Tongzhe Cui,Stephane Clog,Warren Stevens,
// Damir Valiulin,David Kinder,Marc Loiry
//
// You are free to use/modify this code but leave this header intact.
// This class is public domain so you are free to use it any of
// your applications (Freeware,Shareware,Commercial). All I ask is
// that you let me know so that if you have a real winner I can
// brag to my buddies that some of my code is in your app. I also
// wouldn't mind if you sent me a copy of your application since I
// like to play with new stuff.
//*************************************************************************

#pragma once

#include <afxtempl.h>

// BCMenuData class. Fill this class structure to define a single menu item:
class BCMenuData
{
	wchar_t *m_szMenuText;
public:
	BCMenuData () {pContext=nullptr;
	nFlags=0;nID=0;syncflag=0;m_szMenuText=nullptr;global_offset=-1;};
	void SetWideString(const wchar_t *szWideString);
	const wchar_t *GetWideString(void) const {return m_szMenuText;};
	~BCMenuData ();
	CString GetString(void);//returns the menu text
	INT_PTR global_offset;
	UINT nFlags,syncflag;
	UINT_PTR nID;
	void *pContext; // used to attach user data
};

struct CMenuItemInfo : public MENUITEMINFO 
{
	CMenuItemInfo() : MENUITEMINFO{ sizeof(MENUITEMINFO) }
	{
	}
};

class BCMenu : public CMenu
{
	DECLARE_DYNAMIC( BCMenu )
public:
	BCMenu(); 
	virtual ~BCMenu();

	static void DisableOwnerDraw();
	static void RecreateRadioDotBitmap();

	// Functions for loading and applying bitmaps to menus (see example application)
	virtual BOOL LoadMenu(LPCTSTR lpszResourceName);
	virtual BOOL LoadMenu(int nResource)
	{
		return BCMenu::LoadMenu(MAKEINTRESOURCE(nResource));
	}

	bool LoadToolbar(UINT nToolBar, CToolBar* pBar = nullptr);
	bool AddBitmapToImageList(CImageList *list,UINT nResourceID);
	bool ReplaceBitmapInImageList(CImageList *list,int xoffset,UINT nResourceID);
	static HBITMAP LoadSysColorBitmap(int nResourceId);
	
	bool AppendMenu(UINT nFlags, UINT_PTR nIDNewItem = 0, const wchar_t* lpszNewItem = nullptr, int nIconNormal = -1)
	{
		return AppendODMenu(lpszNewItem, nFlags, nIDNewItem, nIconNormal);
	}
	bool AppendODMenu(const wchar_t *lpstrText,UINT nFlags = MF_OWNERDRAW,UINT_PTR nID = 0,int nIconNormal = -1);  
	
	// functions for inserting a menu option, use the InsertMenu call (see above define)
	bool InsertMenu(UINT nPosition, UINT nFlags, UINT_PTR nIDNewItem = 0, wchar_t* lpszNewItem = nullptr, int nIconNormal= -1)
	{
		return InsertODMenu(nPosition, lpszNewItem, nFlags, nIDNewItem, nIconNormal);
	}
	bool InsertODMenu(UINT nPosition,wchar_t *lpstrText,UINT nFlags = MF_OWNERDRAW,UINT_PTR nID = 0,int nIconNormal = -1);  

	// functions for modifying a menu option, use the ModifyODMenu call (see above define)
	bool ModifyODMenu(const wchar_t *lpstrText,UINT_PTR nID=0,int nIconNormal=-1);

	// for deleting and removing menu options
	bool	RemoveMenu(UINT uiId,UINT nFlags);
	bool	DeleteMenu(UINT uiId,UINT nFlags);
	
	// Destoying
	virtual BOOL DestroyMenu();

	// function for retrieving and setting a menu options text (use this function
	// because it is ownerdrawn)
	bool GetMenuText(UINT id,CString &string,UINT nFlags = MF_BYPOSITION);
	bool SetMenuText(UINT id,CString string, UINT nFlags = MF_BYPOSITION);

	// Drawing: 
	virtual void DrawItem( LPDRAWITEMSTRUCT);  // Draw an item
	virtual void MeasureItem( LPMEASUREITEMSTRUCT );  // Measure an item

	// Static functions used for handling menu's in the mainframe
	static void UpdateMenu(CMenu *pmenu);
	static bool IsMenu(CMenu *submenu)
	{
		return IsMenu(submenu->m_hMenu);
	}
	static bool IsMenu(HMENU submenu);
	static LRESULT FindKeyboardShortcut(UINT nChar,UINT nFlags,CMenu *pMenu);

	// Customizing:
	// Set icon size
	static void SetIconSize (int width, int height)
	{
		m_iconX = width;
		m_iconY = height;
	}

	// set the color in the bitmaps that is the background transparent color
	void SetBitmapBackground(COLORREF color)
	{
		m_bitmapBackground=color;
		m_bitmapBackgroundFlag=true;
	}
	void UnSetBitmapBackground(void)
	{
		m_bitmapBackgroundFlag=false;
	}

	COLORREF GetBitmapBackground() const { return m_bitmapBackgroundFlag ? m_bitmapBackground : GetSysColor(COLOR_3DFACE); }
	// obsolete functions for setting how menu images are dithered for disabled menu options
	static inline COLORREF LightenColor(COLORREF col,double factor);

public:
	// Miscellaneous Protected Member functions
protected:
	BCMenuData *FindMenuItem(UINT_PTR nID);
	BCMenu *FindMenuOption(int nId,UINT& nLoc);
	BCMenu *FindAnotherMenuOption(int nId,UINT& nLoc,CArray<BCMenu*,BCMenu*>&bcsubs,
								  CArray<UINT,UINT&>&bclocs);
	BCMenuData *FindMenuOption(wchar_t *lpstrText);
	void DrawCheckMark(CDC* pDC,int x,int y,COLORREF color,bool narrowflag=false);
	void DrawRadioDot(CDC *pDC,int x,int y,COLORREF color);
	BCMenuData *NewODMenu(UINT pos,UINT nFlags,UINT_PTR nID,CString string);
	void SetMenuItemBitmap(intptr_t xoffset, int pos, unsigned state);
	void SynchronizeMenu(void);
	void InitializeMenuList(int value);
	void DeleteMenuList(void);
	BCMenuData *FindMenuList(UINT_PTR nID);
	void DrawItem_Win9xNT2000 (LPDRAWITEMSTRUCT lpDIS);
	bool Draw3DCheckmark(CDC *dc, const CRect& rc,bool bSelected,HBITMAP hbmCheck);
	void DrawItem_Theme (LPDRAWITEMSTRUCT lpDIS);
	void DitherBlt2(CDC *drawdc, int nXDest, int nYDest, int nWidth, 
		int nHeight, CBitmap &bmp, int nXSrc, int nYSrc,COLORREF bgcolor);
	void DitherBlt3(CDC *drawdc, int nXDest, int nYDest, int nWidth, 
		int nHeight, CBitmap &bmp,COLORREF bgcolor);
	bool GetBitmapFromImageList(CDC* pDC,int nIndex,CBitmap &bmp);
	bool GetBitmapFromImageList(CDC* pDC,int nIndex,CImage &bmp);
	static WORD NumBitmapColors(LPBITMAPINFOHEADER lpBitmap);
	void RemoveTopLevelOwnerDraw(void);
	int GetMenuStart(void);
	void GetTransparentBitmap(CBitmap &bmp);
	void GetDisabledBitmap(CBitmap &bmp,COLORREF background=0);
	void GetDisabledBitmap(CImage &bmp);
	INT_PTR AddToGlobalImageList(int nIconNormal,int nID);
	int GlobalImageListOffset(int nID);
	void LoadImages();
	inline unsigned MakeOwnerDrawFlag() const { return BCMenu::m_bEnableOwnerDraw ? MF_OWNERDRAW : MF_STRING; }
	inline const tchar_t *MakeItemData(const BCMenuData* mdata) const { return m_bEnableOwnerDraw ? reinterpret_cast<const tchar_t *>(mdata) : mdata->GetWideString(); }
	static CBitmap* CreateRadioDotBitmap();
	
// Member Variables
protected:
	CTypedPtrArray<CPtrArray, BCMenuData*> m_MenuList;  // Stores list of menu items 
	// When loading an owner-drawn menu using a Resource, BCMenu must keep track of
	// the popup menu's that it creates. Warning, this list *MUST* be destroyed
	// last item first :)
	CTypedPtrArray<CPtrArray, HMENU>  m_SubMenus;  // Stores list of sub-menus 
	// Stores a list of all BCMenu's ever created 
	static CTypedPtrArray<CPtrArray, HMENU>  m_AllSubMenus;
	// Global ImageList
	static CImageList m_AllImages;
	struct ImageData { int id; int resourceId; int bitmapIndex; std::unique_ptr<CBitmap> pBitmap; unsigned state; };
	static std::vector<ImageData> m_AllImagesID;
	static bool m_bHasNotLoadedImages;
	// icon size
	static int m_iconX;
	static int m_iconY;
	COLORREF m_bitmapBackground;
	bool m_bitmapBackgroundFlag;
	static bool hicolor_bitmaps;
	bool m_loadmenu;
	static MARGINS m_marginCheck;
	static MARGINS m_marginSeparator;
	static SIZE m_sizeCheck;
	static SIZE m_sizeSeparator;
	static int m_textBorder;
	static int m_checkBgWidth;
	static int m_gutterWidth;
	static int m_arrowWidth;
	static COLORREF m_menuTextColor;
	static COLORREF m_menuBgColor;
	static HTHEME m_hTheme;
	static bool m_bEnableOwnerDraw;
}; 

</file>

<file path="Winmerge-Src/Src/Common/Bitmap.cpp">
/** 
 * @file  Bitmap.cpp
 *
 * @brief Implementation file for Bitmap helper functions.
 *
 */

#include "StdAfx.h"
#include "Bitmap.h"
#include <cmath>
#include <memory>

#ifdef _DEBUG
#define new DEBUG_NEW
#endif


/**
 * @brief Save an area as a bitmap
 * @param pDC [in] The source device context
 * @param rect [in] The rect to be copied
 * @return The bitmap object
 */
CBitmap *CopyRectToBitmap(CDC *pDC, const CRect & rect)
{
	CRect rc = rect;
	CDC dcMem;
	dcMem.CreateCompatibleDC(pDC);
	CBitmap *pBitmap = new CBitmap;
	pBitmap->CreateCompatibleBitmap(pDC, rc.Width(), rc.Height());
	CBitmap *pOldBitmap = dcMem.SelectObject(pBitmap);
	dcMem.BitBlt(0, 0, rc.Width(), rc.Height(), pDC, rc.left, rc.top, SRCCOPY);
	dcMem.SelectObject(pOldBitmap);
	return pBitmap;
}

/**
 * @brief Draw a bitmap image
 * @param pDC [in] The destination device context to draw to
 * @param x [in] The x-coordinate of the upper-left corner of the bitmap
 * @param y [in] The y-coordinate of the upper-left corner of the bitmap
 * @param pBitmap [in] the bitmap to draw
 */
void DrawBitmap(CDC *pDC, int x, int y, CBitmap *pBitmap)
{
	CDC dcMem;
	dcMem.CreateCompatibleDC(pDC);
	BITMAP bm;
	pBitmap->GetBitmap(&bm);
	CBitmap *pOldBitmap = dcMem.SelectObject(pBitmap);
	pDC->BitBlt(x, y, bm.bmWidth, bm.bmHeight, &dcMem, 0, 0, SRCCOPY);
	dcMem.SelectObject(pOldBitmap);
}

/**
 * @brief Duplicate a bitmap and make it dark
 * @param pDC [in] Device context
 * @param pBitmap [in] the bitmap to darken
 * @param radius [in] 
 * @param lighten [in] make bitmap lighten if ligthen is true
 * @return The bitmap object
 */
CBitmap *GetDarkenedBitmap(CDC *pDC, CBitmap *pBitmap, int radius, bool lighten)
{
	CDC dcMem;
	dcMem.CreateCompatibleDC(pDC);
	BITMAP bm;
	pBitmap->GetObject(sizeof(bm), &bm);
	CBitmap *pBitmapDarkened = new CBitmap();
	pBitmapDarkened->CreateCompatibleBitmap(pDC, bm.bmWidth, bm.bmHeight);
	CBitmap *pOldBitmap = dcMem.SelectObject(pBitmapDarkened);
	DrawBitmap(&dcMem, 0, 0, pBitmap);

	BITMAPINFO bi;
	bi.bmiHeader.biSize = sizeof(bi.bmiHeader);
	bi.bmiHeader.biWidth = bm.bmWidth;
	bi.bmiHeader.biHeight = -bm.bmHeight;
	bi.bmiHeader.biPlanes = 1;
	bi.bmiHeader.biBitCount = 32;
	bi.bmiHeader.biCompression = 0;
	bi.bmiHeader.biSizeImage = bm.bmWidth * 4 * bm.bmHeight;
	bi.bmiHeader.biXPelsPerMeter = 0;
	bi.bmiHeader.biYPelsPerMeter = 0;
	bi.bmiHeader.biClrUsed = 0;
	bi.bmiHeader.biClrImportant = 0;

	auto pbuf = std::make_unique<BYTE[]>(bi.bmiHeader.biSizeImage);
	GetDIBits(dcMem.m_hDC, (HBITMAP)*pBitmapDarkened, 0, bm.bmHeight, pbuf.get(), &bi, DIB_RGB_COLORS);

	radius = std::clamp(radius, 0, static_cast<int>((std::min)(bm.bmWidth / 3, bm.bmHeight / 3)));

	if (!lighten)
	{
		auto darkenInner = [&pbuf, &bm](int left, int top, int right, int bottom)
			{
				for (int x = left; x < right; x++)
				{
					double b = 0.85 + (0.10 * sin(acos((double)x / bm.bmWidth*2.0 - 1.0)));
					for (int y = top; y < bottom; y++)
					{
						{
							int i = x * 4 + y * bm.bmWidth * 4;
							pbuf[i] = (BYTE)(pbuf[i] * 0.95);
							pbuf[i + 1] = (BYTE)(pbuf[i + 1] * b);
							pbuf[i + 2] = (BYTE)(pbuf[i + 2] * b);
						}
					}
				}

			};
		auto darkenCorner = [&pbuf, &bm](int left, int top, int right, int bottom, int cx, int cy, int radius)
			{
				auto sqr = [](double x) { return x * x; };
				for (int x = left; x < right; x++)
				{
					const double b = 0.85 + (0.10 * sin(acos((double)x / bm.bmWidth*2.0 - 1.0)));
					for (int y = top; y < bottom; y++)
					{
						int i = x * 4 + y * bm.bmWidth * 4;
						const double dist = std::sqrt(sqr(x - cx) + sqr(y - cy)) - static_cast<double>(radius);
						if (dist < 0)
						{
							pbuf[i] = (BYTE)(pbuf[i] * 0.95);
							pbuf[i + 1] = (BYTE)(pbuf[i + 1] * b);
							pbuf[i + 2] = (BYTE)(pbuf[i + 2] * b);
						}
						else if (dist <= 1.0)
						{
							pbuf[i] = (BYTE)(pbuf[i] * (0.95 + 0.05 * dist));
							pbuf[i + 1] = (BYTE)(pbuf[i + 1] * (0.9 + 0.1 * dist));
							pbuf[i + 2] = (BYTE)(pbuf[i + 2] * (0.9 + 0.1 * dist));
						}
					}
				}
			};
		auto darkenTopBottomEdge = [&pbuf, &bm](int y, int left, int right)
			{
				for (int x = left; x < right; x++)
				{
					int i = x * 4 + y * bm.bmWidth * 4;
					pbuf[i] = (BYTE)(pbuf[i] * 0.95);
					pbuf[i + 1] = (BYTE)(pbuf[i + 1] * 0.9);
					pbuf[i + 2] = (BYTE)(pbuf[i + 2] * 0.9);
				}
			};
		auto darkenLeftRightEdge = [&pbuf, &bm](int x, int top, int bottom)
			{
				for (int y = top; y < bottom; y++)
				{
					int i = x * 4 + y * bm.bmWidth * 4;
					pbuf[i] = (BYTE)(pbuf[i] * 0.95);
					pbuf[i + 1] = (BYTE)(pbuf[i + 1] * 0.85);
					pbuf[i + 2] = (BYTE)(pbuf[i + 2] * 0.85);
				}
			};
		darkenInner(radius, 1, bm.bmWidth - radius, radius);
		darkenInner(radius, bm.bmHeight - radius, bm.bmWidth - radius, bm.bmHeight - 1);
		darkenInner(1, radius, bm.bmWidth - 1, bm.bmHeight - radius);
		darkenCorner(0, 0, radius, radius, radius, radius, radius);
		darkenCorner(bm.bmWidth - radius, 0, bm.bmWidth, radius, bm.bmWidth - radius - 1, radius, radius);
		darkenCorner(0, bm.bmHeight - radius, radius, bm.bmHeight, radius, bm.bmHeight - radius - 1, radius);
		darkenCorner(bm.bmWidth - radius, bm.bmHeight - radius, bm.bmWidth, bm.bmHeight, bm.bmWidth - radius - 1, bm.bmHeight - radius - 1, radius);
		darkenTopBottomEdge(0, radius, bm.bmWidth - radius);
		darkenTopBottomEdge(bm.bmHeight - 1, radius, bm.bmWidth - radius);
		darkenLeftRightEdge(0, radius, bm.bmHeight - radius);
		darkenLeftRightEdge(bm.bmWidth - 1, radius, bm.bmHeight - radius);
	}
	else
	{
		auto lightenInner = [&pbuf, &bm](int left, int top, int right, int bottom)
			{
				for (int x = left; x < right; x++)
				{
					int b = static_cast<int>(12.0 + (20.0 * sin(acos((double)x / bm.bmWidth*2.0 - 1.0))));
					for (int y = top; y < bottom; y++)
					{
						int i = x * 4 + y * bm.bmWidth * 4;
						pbuf[i] = (BYTE)((std::min)(pbuf[i] + 40, 255));
						pbuf[i + 1] = (BYTE)((std::min)(pbuf[i + 1] + b, 255));
						pbuf[i + 2] = (BYTE)((std::min)(pbuf[i + 2] + b, 255));
					}
				}
			};
		auto lightenCorner = [&pbuf, &bm](int left, int top, int right, int bottom, int cx, int cy, int radius)
			{
				auto sqr = [](double x) { return x * x; };
				for (int x = left; x < right; x++)
				{
					int b = static_cast<int>(12.0 + (20.0 * sin(acos((double)x / bm.bmWidth*2.0 - 1.0))));
					for (int y = top; y < bottom; y++)
					{
						int i = x * 4 + y * bm.bmWidth * 4;
						const double dist = std::sqrt(sqr(x - cx) + sqr(y - cy)) - static_cast<double>(radius);
						if (dist < 0)
						{
							pbuf[i] = (BYTE)((std::min)(pbuf[i] + 40, 255));
							pbuf[i + 1] = (BYTE)((std::min)(pbuf[i + 1] + b, 255));
							pbuf[i + 2] = (BYTE)((std::min)(pbuf[i + 2] + b, 255));
						}
						else if (dist <= 1.0)
						{
							pbuf[i] = (BYTE)((std::min)(pbuf[i] + (BYTE)(40 * (1.0 - dist)), 255));
							pbuf[i + 1] = (BYTE)((std::min)(pbuf[i + 1] + (BYTE)(32 * (1.0 - dist)), 255));
							pbuf[i + 2] = (BYTE)((std::min)(pbuf[i + 2] + (BYTE)(32 * (1.0 - dist)), 255));
						}
					}
				}
			};
		auto lightenTopBottomEdge = [&pbuf, &bm](int y, int left, int right)
			{
				for (int x = left; x < right; x++)
				{
					int i = x * 4 + y * bm.bmWidth * 4;
					pbuf[i] = (BYTE)((std::min)(pbuf[i] + 40, 255));
					pbuf[i + 1] = (BYTE)((std::min)(pbuf[i + 1] + 32, 255));
					pbuf[i + 2] = (BYTE)((std::min)(pbuf[i + 2] + 32, 255));
				}
			};
		auto lightenLeftRightEdge = [&pbuf, &bm](int x, int top, int bottom)
			{
				for (int y = top; y < bottom; y++)
				{
					int i = x * 4 + y * bm.bmWidth * 4;
					pbuf[i] = (BYTE)((std::min)(pbuf[i] + 40, 255));
					pbuf[i + 1] = (BYTE)((std::min)(pbuf[i + 1] + 32, 255));
					pbuf[i + 2] = (BYTE)((std::min)(pbuf[i + 2] + 32, 255));
				}
			};
		lightenInner(radius, 1, bm.bmWidth - radius, radius);
		lightenInner(radius, bm.bmHeight - radius, bm.bmWidth - radius, bm.bmHeight - 1);
		lightenInner(1, radius, bm.bmWidth - 1, bm.bmHeight - radius);
		lightenCorner(0, 0, radius, radius, radius, radius, radius);
		lightenCorner(bm.bmWidth - radius, 0, bm.bmWidth, radius, bm.bmWidth - radius - 1, radius, radius);
		lightenCorner(0, bm.bmHeight - radius, radius, bm.bmHeight, radius, bm.bmHeight - radius - 1, radius);
		lightenCorner(bm.bmWidth - radius, bm.bmHeight - radius, bm.bmWidth, bm.bmHeight, bm.bmWidth - radius - 1, bm.bmHeight - radius - 1, radius);
		lightenTopBottomEdge(0, radius, bm.bmWidth - radius);
		lightenTopBottomEdge(bm.bmHeight - 1, radius, bm.bmWidth - radius);
		lightenLeftRightEdge(0, radius, bm.bmHeight - radius);
		lightenLeftRightEdge(bm.bmWidth - 1, radius, bm.bmHeight - radius);
	}

	SetDIBits(dcMem.m_hDC, (HBITMAP)*pBitmapDarkened, 0, bm.bmHeight, pbuf.get(), &bi, DIB_RGB_COLORS);
	dcMem.SelectObject(pOldBitmap);
	return pBitmapDarkened;
}

bool LoadImageFromResource(ATL::CImage& image, const tchar_t *pName, const tchar_t *pType)
{
	HRSRC hrsrc = FindResource(nullptr, pName, pType);
	if (hrsrc == nullptr)
		return false;
	DWORD dwResourceSize = SizeofResource(nullptr, hrsrc);
	HGLOBAL hglbImage = LoadResource(nullptr, hrsrc);
	if (hglbImage == nullptr)
		return false;
	LPVOID pvSourceResourceData = LockResource(hglbImage);
	if (pvSourceResourceData == nullptr)
		return false;
	IStream * pStream = SHCreateMemStream(reinterpret_cast<const BYTE *>(pvSourceResourceData), dwResourceSize);
	if (!pStream)
		return false;
	HRESULT hr = image.Load(pStream);
	pStream->Release();
	if (FAILED(hr))
		return false;
	return true;
}
</file>

<file path="Winmerge-Src/Src/Common/Bitmap.h">
/** 
 * @file  Bitmap.h
 *
 * @brief Declaration file for Bitmap helper functions.
 *
 */
#pragma once

#include "utils/ctchar.h"

class CBitmap;
class CDC;
class CRect;
namespace ATL { class CImage; }

CBitmap *CopyRectToBitmap(CDC *pDC, const CRect & rect);
void DrawBitmap(CDC *pDC, int x, int y, CBitmap *pBitmap);
CBitmap *GetDarkenedBitmap(CDC *pDC, CBitmap *pBitmap, int radius, bool lighten = false);
bool LoadImageFromResource(ATL::CImage& image, const tchar_t *pName, const tchar_t *pType);
</file>

<file path="Winmerge-Src/Src/Common/cio.cpp">
#include "pch.h"
#include "cio.h"
#include "TFile.h"
#include <cerrno>

namespace cio
{
#ifdef _WIN32

int tsopen_s(int* fd, const String& filepath, int oflag, int shflag, int pmode)
{
	return _wsopen_s(fd, TFile(filepath).wpath().c_str(), oflag, shflag, pmode);
}

int tfopen_s(FILE** fp, const String& filepath, const String::value_type* mode)
{
	return _wfopen_s(fp, TFile(filepath).wpath().c_str(), mode);
}

ssize_t read(int fd, void* buf, size_t size)
{
	ssize_t pos = 0;
	while (pos < size)
	{
		unsigned rsize = (size - pos < 0x40000000) ? static_cast<unsigned>(size - pos) : 0x40000000;
		int res32 = _read(fd, reinterpret_cast<char *>(buf) + pos, rsize);
		if (res32 == -1)
			return -1;
		pos += res32;
		if (res32 < rsize)
			break;
	}
	return pos;
}

ssize_t write(int fd, const void* buf, size_t size)
{
	ssize_t pos = 0;
	while (pos < size)
	{
		unsigned wsize = (size - pos < 0x40000000) ? static_cast<unsigned>(size - pos) : 0x40000000;
		int res32 = _write(fd, reinterpret_cast<const char *>(buf) + pos, wsize);
		if (res32 == -1)
			return -1;
		pos += res32;
	}
	return pos;
}

#else

int tsopen_s(int* fd, const String& filepath, int oflag, int shflag, int pmode)
{
	*fd = open(filepath.c_str(), oflag, pmode);
	return errno;
}

int fopen_s(FILE** fp, const String& filepath, const String::value_type* mode)
{
	*fp = fopen(filepath.c_str(), mode);
	return errno;
}

#endif
}
</file>

<file path="Winmerge-Src/Src/Common/cio.h">
#pragma once

#include <cstdio>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#ifdef _WIN32
#include <io.h>
extern "C" int myfstat(int fd, struct _stat64 *buf);
#else
#include <unistd.h>
#endif
#include "UnicodeString.h"

namespace cio
{
	int tsopen_s(int* fd, const String& filepath, int oflag, int shflag, int pmode);
	int tfopen_s(FILE** fp, const String& filepath, const String::value_type* mode);
#ifdef _WIN32
	typedef intptr_t ssize_t;
	typedef struct _stat64 stat;
	constexpr auto read_i = _read;
	constexpr auto write_i = _write;
	ssize_t read(int fd, void* buf, size_t size);
	ssize_t write(int fd, const void* buf, size_t size);
	constexpr auto close = ::_close;
	constexpr auto fstat = ::myfstat;
	constexpr auto pipe = ::_pipe;
#else
#define O_BINARY (0)
#define _SH_DENYNO (0)
#define _S_IREAD  (S_IRUSR | S_IRGRP | S_IROTH)
#define _S_IWRITE (S_IWUSR | S_IWGRP | S_IWOTH)
	typedef struct stat stat;
	inline int read_i(int fd, void* buf, unsigned size) { return (int)::read(fd, buf, size); }
	inline int write_i(int fd, const void* buf, unsigned size) { return (int)::write(fd, buf, size); }
	constexpr auto read = ::read;
	constexpr auto write = ::write;
	constexpr auto close = ::close;
	constexpr auto fstat = ::fstat;
	constexpr auto pipe = ::pipe;
#endif
}
</file>

<file path="Winmerge-Src/Src/Common/ClipBoard.cpp">
/**
 * @file  ClipBoard.cpp
 *
 * @brief ClipBoard helper functions implementations.
 */

#include "pch.h"
#include "ClipBoard.h"
#include <ShlObj.h>

inline CLIPFORMAT GetClipTcharTextFormat() { return (sizeof(tchar_t) == 1 ? CF_TEXT : CF_UNICODETEXT); }

/**
 * @brief Copies string to clipboard.
 * @param [in] text Text to copy to clipboard.
 * @param [in] currentWindowHandle Handle to current window.
 * @return `true` if text copying succeeds, `false` otherwise.
 */
template<>
bool PutToClipboard<HWND>(const String & text, HWND currentWindowHandle)
{
	if (text.empty())
		return false;

	bool bOK = false;
	if (OpenClipboard(currentWindowHandle))
	{
		EmptyClipboard();
		const size_t dataSiz = text.length() + 1;
		HGLOBAL hData = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, dataSiz * sizeof(tchar_t));
		if (hData != nullptr)
		{
			if (tchar_t* pszData = static_cast<tchar_t*>(::GlobalLock(hData)))
			{
				tc::tcslcpy(pszData, dataSiz, text.c_str());
				GlobalUnlock(hData);
			}
			CLIPFORMAT fmt = GetClipTcharTextFormat();
			bOK = SetClipboardData(fmt, hData) != nullptr;
		}
		CloseClipboard();
	}
	return bOK;
}

/**
 * @brief Retrieves the string from clipboard.
 * @param [out] text Text copied from clipboard.
 * @param [in] currentWindowHandle Handle to current window.
 * @return `true` if retrieving the clipboard text succeeds, `false` otherwise.
 */
bool GetFromClipboard(String & text)
{
	bool bSuccess = false;
	if (OpenClipboard(nullptr))
	{
		CLIPFORMAT fmt = GetClipTcharTextFormat();
		HGLOBAL hData = GetClipboardData(fmt);
		if (hData != nullptr)
		{
			tchar_t* pszData = (tchar_t*) GlobalLock(hData);
			if (pszData != nullptr)
			{
				text = pszData;
				GlobalUnlock(hData);
				bSuccess = true;
			}
		}
		CloseClipboard();
	}
	return bSuccess;
}

template<>
void PutFilesToClipboardInternal<HWND>(const String& strPaths, const String& strPathsSepSpc, HWND currentWindowHandle)
{
	// CF_HDROP
	HGLOBAL hDrop = GlobalAlloc(GHND, sizeof(DROPFILES) + sizeof(tchar_t) * strPaths.length());
	if (hDrop == nullptr)
		return;
	if (tchar_t* pDrop = static_cast<tchar_t*>(GlobalLock(hDrop)))
	{
		DROPFILES df = { 0 };
		df.pFiles = sizeof(DROPFILES);
		df.fWide = (sizeof(tchar_t) > 1);
		memcpy(pDrop, &df, sizeof(DROPFILES));
		memcpy((BYTE*)pDrop + sizeof(DROPFILES), (const tchar_t*)strPaths.c_str(), sizeof(tchar_t) * strPaths.length());
		GlobalUnlock(hDrop);
	}

	// CF_DROPEFFECT
	HGLOBAL hDropEffect = GlobalAlloc(GHND, sizeof(DWORD));
	if (hDropEffect == nullptr)
	{
		GlobalFree(hDrop);
		return;
	}
	if (DWORD* p = static_cast<DWORD*>(GlobalLock(hDropEffect)))
	{
		*p = DROPEFFECT_COPY;
		GlobalUnlock(hDropEffect);
	}

	// CF_UNICODETEXT
	HGLOBAL hPathnames = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, sizeof(tchar_t) * (strPathsSepSpc.length() + 1));
	if (hPathnames == nullptr)
	{
		GlobalFree(hDrop);
		GlobalFree(hDropEffect);
		return;
	}
	if (void* pPathnames = GlobalLock(hPathnames))
	{
		memcpy((BYTE*)pPathnames, (const tchar_t*)strPathsSepSpc.c_str(), sizeof(tchar_t) * strPathsSepSpc.length());
		((tchar_t*)pPathnames)[strPathsSepSpc.length()] = 0;
		GlobalUnlock(hPathnames);
	}

	UINT CF_DROPEFFECT = RegisterClipboardFormat(CFSTR_PREFERREDDROPEFFECT);
	if (::OpenClipboard(currentWindowHandle))
	{
		EmptyClipboard();
		SetClipboardData(CF_HDROP, hDrop);
		SetClipboardData(CF_DROPEFFECT, hDropEffect);
		SetClipboardData(GetClipTcharTextFormat(), hPathnames);
		CloseClipboard();
	}
}

</file>

<file path="Winmerge-Src/Src/Common/ClipBoard.h">
/**
 * @file  ClipBoard.h
 *
 * @brief ClipBoard helper functions definitions.
 */
#pragma once

#include "UnicodeString.h"

template<typename WindowHandle>
bool PutToClipboard(const String & text, WindowHandle currentWindowHandle);
bool GetFromClipboard(String & text);
template<typename WindowHandle>
void PutFilesToClipboardInternal(const String& strPaths, const String& strPathsSepSpc, WindowHandle currentWindowHandle);

template<class Container, typename WindowHandle>
void PutFilesToClipboard(const Container& list, WindowHandle currentWindowHandle)
{
	constexpr size_t MaxPathFull = 32767;
	String strPaths, strPathsSepSpc;
	strPaths.reserve(list.size() * MaxPathFull);
	strPathsSepSpc.reserve(list.size() * MaxPathFull);

	for (Container::const_iterator it = list.begin(); it != list.end(); ++it)
	{
		String path = *it;

		strPaths += path;
		strPaths += _T('\0');

		strPathsSepSpc += _T("\"");
		strPathsSepSpc += path;
		strPathsSepSpc += _T("\" ");
	}

	strPaths += _T('\0');
	strPathsSepSpc = strutils::trim_ws_end(strPathsSepSpc);

	PutFilesToClipboardInternal(strPaths, strPathsSepSpc, currentWindowHandle);
}
</file>

<file path="Winmerge-Src/Src/Common/CMoveConstraint.cpp">
/*!
  \file    CMoveConstraint.cpp
  \author  Perry Rapp, Creator, 1998-2004
  \date    Created: 1998
  \date    Edited:  2006-09-23 (Kimmo Varis)

  \brief   Implementation of CMoveConstraint

*/
/* The MIT License
Copyright (c) 2001 Perry Rapp
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/


#include "StdAfx.h"
#include "CMoveConstraint.h"
#include "Win_VersionHelper.h"
#include <afxtempl.h>       // MFC template collection classes
#include <afxext.h> // needed for CFormView

#ifdef _DEBUG
#define new DEBUG_NEW
#endif




namespace prdlg {

// from windowsx.h
#define GetWindowStyle(hwnd) ((DWORD)::GetWindowLong(hwnd, GWL_STYLE))
#define MapWindowRect(hwndFrom, hwndTo, lprc) \
                    MapWindowPoints((hwndFrom), (hwndTo), (POINT *)(lprc), 2)

// from wdj
static RECT getGripRect(HWND hwnd)
{
	RECT rc;
	GetClientRect(hwnd, &rc);
	rc.left = rc.right - GetSystemMetrics(SM_CXVSCROLL);
	rc.top = rc.bottom - GetSystemMetrics(SM_CYHSCROLL);
	return rc;
}

CMoveConstraint::EGRIP CMoveConstraint::c_defGrip = SG_NORMAL;

CMoveConstraint::Constraint::Constraint()
{
	Init();
}
CMoveConstraint::Constraint::Constraint(double fLeftX, double fExpandX, double fAboveY, double fExpandY, HWND hwndChild, CWnd * pWnd)
{
	Init();
	m_fLeftX = fLeftX;
	m_fExpandX = fExpandX;
	m_fAboveY = fAboveY;
	m_fExpandY = fExpandY;
	m_hwndChild = hwndChild;
	m_pWnd = pWnd;
}
void 
CMoveConstraint::Constraint::Init()
{
	m_fLeftX = 0;
	m_fExpandX = 0;
	m_fAboveY = 0;
	m_fExpandY = 0;
	m_hwndChild = nullptr;
	m_pWnd = nullptr;
	// m_rectChildOriginal
	m_hwndParent = nullptr;
}

CMoveConstraint::CMoveConstraint()
: m_hTheme(nullptr)
, m_bSubclassed(false)
, m_oldWndProc(nullptr)
, m_sRegistryValueName(_T("UnnamedWindow"))
, m_sRegistrySubkey(_T("LastWindowPos"))
{
	ClearMostData();
}

bool
CMoveConstraint::InitializeCurrentSize(HWND hwndDlg)
{
	ASSERT(!m_hwndDlg);
	if (!IsWindow(hwndDlg))
		return false;
	m_hwndDlg = hwndDlg;

	GrabCurrentDimensionsAsOriginal(hwndDlg);
	return true;
}

void
CMoveConstraint::GrabCurrentDimensionsAsOriginal(HWND hwndDlg)
{
	// figure original size for resizing code
	GetClientRect(hwndDlg, m_rectDlgOriginal);
	CRect rect;
	GetWindowRect(hwndDlg, &rect);

	// (min/max code)
	// remember original width & heighth in case a disallow function called
	// by default, set minimum size to original size
	m_nOrigX = m_nMinX = rect.Width();
	m_nOrigY = m_nMinY = rect.Height();

	m_bOriginalFetched = true;
}

void
CMoveConstraint::InitializeSpecificSize(HWND /*hwndDlg*/, int nWidth, int nHeight)
{
	// figure original size for resizing code
	m_rectDlgOriginal.left = 0;
	m_rectDlgOriginal.right = nWidth;
	m_rectDlgOriginal.top = 0;
	m_rectDlgOriginal.bottom = nHeight;

	// (min/max code)
	// remember original width & heighth in case a disallow function called
	// by default, set minimum size to original size
	m_nOrigX = m_nMinX = nWidth;
	m_nOrigY = m_nMinY = nHeight;
}

bool
CMoveConstraint::InitializeOriginalSize(HWND hwndDlg)
{
	ASSERT(hwndDlg != nullptr && m_hwndDlg == nullptr);
	m_hwndDlg = hwndDlg;

	return m_nOrigX != 0; // if 0, we didn't get WM_SIZE so we don't know the original size
}

bool
CMoveConstraint::InitializeOriginalSize(CWnd * pParent)
{
	ASSERT(pParent != nullptr);
	return InitializeOriginalSize(pParent->m_hWnd);
}


void
CMoveConstraint::InitializeSpecificSize(CWnd * pDlg, int nWidth, int nHeight)
{
	ASSERT(pDlg != nullptr);
	InitializeSpecificSize(pDlg->m_hWnd, nWidth, nHeight);
}

bool
CMoveConstraint::InitializeCurrentSize(CWnd * pDlg)
{
	ASSERT(pDlg != nullptr);
	return InitializeCurrentSize(pDlg->m_hWnd);
}

void
CMoveConstraint::UpdateSizes()
{
	Resize(m_hwndDlg, SIZE_RESTORED);
}

void
CMoveConstraint::AllowHeightShrink()
{
	m_nMinY = 0;
}
void
CMoveConstraint::AllowWidthShrink()
{
	m_nMinX = 0;
}
void
CMoveConstraint::DisallowHeightGrowth()
{
	m_nMaxY = m_nOrigY;
}
void
CMoveConstraint::DisallowWidthGrowth()
{
	m_nMaxX = m_nOrigX;
}

void
CMoveConstraint::SetMaxSizePixels(int nWidth, int nHeight)
{
	if (nWidth != -1)
		m_nMaxX = nWidth;
	if (nHeight != -1)
		m_nMaxY = nHeight;
}

void
CMoveConstraint::SetMinSizePixels(int nWidth, int nHeight)
{
	if (nWidth != -1)
		m_nMinX = nWidth;
	if (nHeight != -1)
		m_nMinY = nHeight;
}

void
CMoveConstraint::SetMinSizePercent(double fWidth, double fHeight)
{
	if (fWidth >= 0)
		m_nMinX = (int)(fWidth * m_nOrigX);
	if (fHeight >= 0)
		m_nMinY = (int)(fHeight * m_nOrigY);
}

void
CMoveConstraint::SetScrollScale(CFormView * pFormView, double fShrinkWidth, double fShrinkHeight)
{
	m_fShrinkHeight = fShrinkHeight;
	m_fShrinkWidth = fShrinkWidth;
	m_pFormView = pFormView;
	CSize size = pFormView->GetTotalSize();
	m_nOrigScrollX = size.cx;
	m_nOrigScrollY = size.cy;
}

CMoveConstraint::~CMoveConstraint()
{
	ClearMostData();
}


void
CMoveConstraint::ClearMostData()
{
	// clears everything but m_bSubclassed
	// this is called from constructor, OnDestroy, and destructor
	// so it can't assume any numerical variables have sane values
	m_hwndDlg=nullptr;
	// m_rectDlgOriginal
	m_nOrigX=0;
	m_nOrigY=0;
	m_nGrip=c_defGrip;
	m_bOriginalFetched=false;
	m_nMinX=0;
	m_nMinY=0;
	m_nMaxX=0;
	m_nMaxY=0;
	m_nDelayed=0;
	// this specifically does NOT touch m_bSubclassed, as a subclass may still be in use
	m_pFormView=nullptr;
	m_nOrigScrollX=0;
	m_nOrigScrollY=0;
	m_fShrinkWidth=0;
	m_fShrinkHeight=0;
	m_bPropertyPage=false;
	m_bPropertySheet=false;
	m_ConstraintList.clear();
	m_bPersistent=false;
	m_bConstrainNonChildren = false;
}

void
CMoveConstraint::
InitializeChildConstraintData(HWND hwndDlg, Constraint & constraint)
{
	HWND hwndChild = constraint.m_hwndChild;
	ASSERT(IsWindow(hwndChild));
	constraint.m_hwndParent = GetParent(hwndChild);
	if (!m_bConstrainNonChildren && constraint.m_hwndParent != hwndDlg)
	{
		// this is all predicated on the children being real Windows children
		// because of the use of client coordinates in ::SetWindowPos down in Resize() below
		// altho the truth is, the scaling is linear, so it will work with any windows
		// but if you want to do that, you have to call 
		//  m_constraint.ConstrainNonWindows();
		// to suppress this debug ASSERT
		ASSERT(false); // this is not a child of the dialog
	}
	GetWindowRect(hwndChild, constraint.m_rectChildOriginal);
	CWnd * wndParent = CWnd::FromHandle(constraint.m_hwndParent);
	wndParent->ScreenToClient(constraint.m_rectChildOriginal);
}

bool
CMoveConstraint::
Constrain(HWND hwndChild, double fLeftX, double fExpandX, double fAboveY, double fExpandY)
{
	return DoConstrain(0, hwndChild, fLeftX, fExpandX, fAboveY, fExpandY);
}

bool
CMoveConstraint::
DoConstrain(CWnd * pWnd, HWND hwndChild, double fLeftX, double fExpandX, double fAboveY, double fExpandY)
{
	Constraint constraint(fLeftX, fExpandX, fAboveY, fExpandY, hwndChild, pWnd);

	if (m_hwndDlg && IsWindow(m_hwndDlg) && hwndChild != nullptr && IsWindow(hwndChild))
	{
		InitializeChildConstraintData(m_hwndDlg, constraint);
	}
	else
	{
		if (pWnd == nullptr) // only CWnds can be deferred
			return false;
		m_nDelayed++;
	}

	m_ConstraintList.push_back(constraint);
	return true;
}


void
CMoveConstraint::
Constrain(CWnd * pWnd, double fLeftX, double fExpandX, double fAboveY, double fExpandY)
{
	ASSERT(pWnd != nullptr);
	DoConstrain(pWnd, pWnd->m_hWnd, fLeftX, fExpandX, fAboveY, fExpandY);
}

bool
CMoveConstraint::
ConstrainItem(int nId, double fLeftX, double fExpandX, double fAboveY, double fExpandY)
{
	if (m_hwndDlg == nullptr || !IsWindow(m_hwndDlg))
		return false;
	HWND hwnd = GetDlgItem(m_hwndDlg, nId);
	return DoConstrain(0, hwnd, fLeftX, fExpandX, fAboveY, fExpandY);
}

/**
 * This is the window proc callback that works with the CSubclass module.
 */
LRESULT CALLBACK
CMoveConstraint::ConstraintWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	void * data = GetProp(hwnd, _T("CMoveConstraintData"));
	if (!data)
		return DefWindowProc(hwnd, msg, wParam, lParam);
	CMoveConstraint * constraint = reinterpret_cast<CMoveConstraint *>(data);

	LRESULT lresult;
	if (constraint->WindowProc(hwnd, msg, wParam, lParam, &lresult))
		return lresult;

	return CallWindowProc(constraint->m_oldWndProc, hwnd, msg, wParam, lParam);
}
bool
CMoveConstraint::SubclassWnd()
{
	void * data = reinterpret_cast<void *>(this);
	// this will return false if this window/wndproc combination has already
	// been established (subclassed)
	m_oldWndProc = reinterpret_cast<WNDPROC>(GetWindowLongPtr(m_hwndDlg, GWLP_WNDPROC));
	if (SetWindowLongPtr(m_hwndDlg, GWLP_WNDPROC, (__int3264)(LONG_PTR)(CMoveConstraint::ConstraintWndProc)) != 0)
	{
		if (SetProp(m_hwndDlg, _T("CMoveConstraintData"), data))
		{
			m_bSubclassed = true;
		}
		else
		{
			SetWindowLongPtr(m_hwndDlg, GWLP_WNDPROC, (__int3264)(LONG_PTR)(m_oldWndProc));
			m_oldWndProc = nullptr;
		}
	}
	return m_bSubclassed;
}
bool
CMoveConstraint::UnSubclassWnd()
{
	if (!m_bSubclassed)
		return false;
	SetWindowLongPtr(m_hwndDlg, GWLP_WNDPROC, (__int3264)(LONG_PTR)(m_oldWndProc));
	RemoveProp(m_hwndDlg, _T("CMoveConstraintData"));
	m_oldWndProc = nullptr;
	m_bSubclassed = false;
	return true;
}

/**
 * Check if we have any pending constraints not yet added to constraint list
 * because they were set before the dialog was created (so initial sizes 
 * could not yet be captured).
 */
void
CMoveConstraint::CheckDeferredChildren()
{
	if (m_nDelayed == 0)
		return;
	for (auto& constraint : m_ConstraintList)
	{
		if (constraint.m_hwndChild  != nullptr)
			continue;
		ASSERT(constraint.m_pWnd != nullptr);
		if (constraint.m_pWnd->m_hWnd != nullptr)
		{
			constraint.m_hwndChild = constraint.m_pWnd->m_hWnd;
			InitializeChildConstraintData(m_hwndDlg, constraint);
			m_nDelayed--;
		}
	}
}

/**
 * Custom handling for WM_SIZE
 * Apply all resize constraints from the constraint list.
 */
void
CMoveConstraint::Resize(HWND hWnd, UINT nType)
{
// optional - could use BeginDeferWindowPos, DeferWindowPos, EndDeferWindowPos
// 2000/10/07 - haven't tried them
// but I don't think they'd matter because I use SWP_NOREDRAW in the loop

	if (nType == SIZE_MINIMIZED) return;

	if (m_hwndDlg == nullptr && hWnd != nullptr && !m_bOriginalFetched)
	{
		// if early subclass or wndproc
		// grab early dimensions, in case we want them later (eg, property sheet)
		GrabCurrentDimensionsAsOriginal(hWnd);
		return;
	}

	if (m_hwndDlg == nullptr || !IsWindow(m_hwndDlg))
		return;

	CRect rectParentCurrent;
	GetClientRect(m_hwndDlg, rectParentCurrent);

	// compute delta from original size (all fractions based on this)
	int nDeltaWidth = (rectParentCurrent.right - m_rectDlgOriginal.right);
	int nDeltaHeight = (rectParentCurrent.bottom - m_rectDlgOriginal.bottom);

	for (auto& constraint : m_ConstraintList)
	{
		if (constraint.m_hwndChild == nullptr)
			continue;

		CRect rectChildCurrent;
		// get the screen & client coordinates of the child
		::GetWindowRect(constraint.m_hwndChild, &rectChildCurrent);
		CWnd * wndParent = CWnd::FromHandle(constraint.m_hwndParent);
		wndParent->ScreenToClient(&rectChildCurrent);

		int nDelta;

		nDelta = nDeltaWidth;
		rectChildCurrent.left = (int)(nDelta * constraint.m_fLeftX) + constraint.m_rectChildOriginal.left;
		rectChildCurrent.right = (int)(nDelta * (constraint.m_fLeftX + constraint.m_fExpandX)) + constraint.m_rectChildOriginal.right;

		nDelta = nDeltaHeight;
		rectChildCurrent.top = (int)(nDelta * constraint.m_fAboveY) + constraint.m_rectChildOriginal.top;
		rectChildCurrent.bottom = (int)(nDelta * (constraint.m_fAboveY + constraint.m_fExpandY)) + constraint.m_rectChildOriginal.bottom;

		SetWindowPos(constraint.m_hwndChild, nullptr, rectChildCurrent.left, rectChildCurrent.top
			, rectChildCurrent.Width(), rectChildCurrent.Height(), SWP_NOZORDER+SWP_NOREDRAW);
	}

	if (m_pFormView != nullptr)
	{
		// ignore growth
		//if (nDeltaWidth > 0)
		//	nDeltaWidth = 0;
		//if (nDeltaHeight > 0)
		//	nDeltaHeight = 0;
		CSize size;
		size.cx = (int)(m_nOrigScrollX + nDeltaWidth * m_fShrinkWidth);
		size.cy = (int)(m_nOrigScrollY + nDeltaHeight * m_fShrinkHeight);
		m_pFormView->SetScrollSizes(MM_TEXT, size);
	}

	InvalidateRect(m_hwndDlg, nullptr, TRUE);
	UpdateWindow(m_hwndDlg);
}

/**
 * Custom handling for WM_GETMINMAXINFO.
 * Enforce any resizing limitations.
 */
void
CMoveConstraint::OnGetMinMaxInfo(MINMAXINFO* lpMMI)
{
	// views don't get WM_GETMINMAXINFO, but dialogs & frames do
	if (m_hwndDlg == nullptr)
		return;
	if (m_nMinX)
		lpMMI->ptMinTrackSize.x = m_nMinX;
	if (m_nMinY)
		lpMMI->ptMinTrackSize.y = m_nMinY;
	if (m_nMaxX)
		lpMMI->ptMaxTrackSize.x = m_nMaxX;
	if (m_nMaxY)
		lpMMI->ptMaxTrackSize.y = m_nMaxY;
}

bool
CMoveConstraint::PaintGrip()
{
	if (m_nGrip == SG_NONE) return false;
	if (m_hwndDlg == nullptr) return false;
	HWND hw = (m_nGrip == SG_PARENTSTATE) ? GetParent(m_hwndDlg) : m_hwndDlg;
	return !IsZoomed(hw) && !IsIconic(hw);
}

/**
 * Custom handling for WM_NCHITTEST
 * We paint the sizing grip if the mouse is in the lower right hand corner.
 */
bool
CMoveConstraint::OnNcHitTest(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT * plresult)
{
	// views don't get WM_NCHITTEST, but dialogs & frames do
	if (m_hwndDlg == nullptr)
		return false;
	if (m_nMinY == m_nMaxY)
	{
		LRESULT nRet = CallWindowProc(m_oldWndProc, m_hwndDlg, msg, wParam, lParam);
		switch(nRet)
		{
		case HTBOTTOMLEFT:
		case HTTOPLEFT:
			*plresult = HTLEFT;
			return true;
		case HTBOTTOMRIGHT:
		case HTTOPRIGHT:
			*plresult = HTRIGHT;
			return true;
		case HTBOTTOM:
		case HTTOP:
			*plresult = HTBORDER;
			return true;
		}
		return false;
	}
	if (m_nMinX == m_nMaxX)
	{
		LRESULT nRet = CallWindowProc(m_oldWndProc, m_hwndDlg, msg, wParam, lParam);
		switch(nRet)
		{
		case HTBOTTOMLEFT:
		case HTBOTTOMRIGHT:
			*plresult = HTBOTTOM;
			return true;
		case HTTOPLEFT:
		case HTTOPRIGHT:
			*plresult = HTTOP;
			return true;
		case HTLEFT:
		case HTRIGHT:
			*plresult = HTBORDER;
			return true;
		}
		return false;
	}
	if (!PaintGrip())
		return false;

	// check for size grip
	int x = (int)(short)LOWORD(lParam);
	int y = (int)(short)HIWORD(lParam);
	int cx,cy;
	RECT rc = getGripRect(m_hwndDlg);
	MapWindowRect(m_hwndDlg, HWND_DESKTOP, &rc);
	RECT rc2;
	GetWindowRect(m_hwndDlg, &rc2);
	cx = x-rc.left;
	cy = y-rc.top;
	if (0 < cx && 0 < cy && (rc.right - rc.left < cy+cy))
	{
		*plresult = HTBOTTOMRIGHT;
		return true;
	}
	return false;
}

void
CMoveConstraint::OnDestroy()
{
	if (m_bPersistent)
		Persist(true, true);
	UnSubclassWnd();
	// the one variable that CANNOT safely be cleared now is m_bSubclassed
	// because the subclass is almost certainly not yet removed
	// (the subclass calls us to let us do destroy processing, before 
	//  removing itself)
	ClearMostData();
}

/**
 * Custom handling of the TTN_NEEDTEXT notification message
 */
bool
CMoveConstraint::OnTtnNeedText(TOOLTIPTEXT * pTTT, LRESULT * plresult)
{
	UINT_PTR id = pTTT->hdr.idFrom;
	UINT uflags = pTTT->uFlags;
	if (uflags & TTF_IDISHWND)
		id = GetDlgCtrlID((HWND)id);
	tip ti;
	if (m_tips.Lookup(id, ti))
	{
		if (ti.m_nResourceId)
		{
			pTTT->lpszText = MAKEINTRESOURCE(ti.m_nResourceId);
			pTTT->hinst = AfxGetResourceHandle();
		}
		else
		{
			pTTT->lpszText = (tchar_t*)(const tchar_t*)ti.m_sText;
		}
		*plresult = true; // return `true` from original window proc
		return true; // stop processing this message
	}
	return false;
}

/**
 * Main window proc of this subclassing library
 * Set plresult to set the return value of the real window proc which called us.
 * Return true to prevent any further handling of this message.
 */
bool
CMoveConstraint::WindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam, LRESULT * plresult)
{
	if (m_bPropertyPage)
	{
		// pass PSN_SETACTIVE to parent (property sheet)
		if (m_hwndDlg && (WM_NOTIFY == msg) && (PSN_SETACTIVE == (((NMHDR *)lParam)->code)))
		{
			HWND hwndParent = GetParent(m_hwndDlg);
			NMHDR nmhdr = { hwndParent, 0, PSN_SETACTIVE };
			SendMessage(hwndParent, WM_NOTIFY, 0, (LPARAM)&nmhdr);
		}
	}
	if (m_bPropertySheet)
	{
		if ((WM_NOTIFY == msg) && (PSN_SETACTIVE == (((NMHDR *)lParam)->code)))
		{
			CheckDeferredChildren();
		}
	}
	if (WM_GETMINMAXINFO == msg) {
		OnGetMinMaxInfo(reinterpret_cast<LPMINMAXINFO>(lParam));
	} else if (WM_SIZE == msg) { // 2000/03/10 - tried WM_EXITSIZEMOVE - no help for property page problem
		Resize(hWnd, (UINT)wParam /* x & y in lParam */);
	} else if (WM_PAINT == msg && PaintGrip()) {
		CPaintDC dc(CWnd::FromHandle(hWnd));
		RECT rc = getGripRect(hWnd);
		if (IsVista_OrGreater() && m_hTheme == nullptr && IsThemeActive()) {
			m_hTheme = OpenThemeData(hWnd, WC_SCROLLBAR);
		}
		if (m_hTheme != nullptr) {
			DrawThemeBackground(m_hTheme, dc.GetSafeHdc(), SBP_SIZEBOX, 0, &rc, nullptr);
		} else {
			dc.DrawFrameControl(&rc, DFC_SCROLL, DFCS_SCROLLSIZEGRIP);
		}
	} else if (WM_THEMECHANGED == msg) {
		if (m_hTheme != nullptr) {
			CloseThemeData(m_hTheme);
			m_hTheme = nullptr;
		}
		if (m_hTheme == nullptr && IsThemeActive()) {
			m_hTheme = OpenThemeData(hWnd, WC_SCROLLBAR);
		}
	} else if (WM_NCHITTEST == msg && !IsIconic(hWnd) && !IsZoomed(hWnd)) {
		if (OnNcHitTest(msg, wParam, lParam, plresult))
			return true;
	} else if (WM_DESTROY == msg) {
		if (m_hTheme != nullptr) {
			CloseThemeData(m_hTheme);
			m_hTheme = nullptr;
		}
		OnDestroy();
	} else if (msg==WM_NOTIFY && TTN_NEEDTEXT==((NMHDR*)lParam)->code) {
		if (OnTtnNeedText((TOOLTIPTEXT*)lParam, plresult))
			return true;
	}

	return false;
}

/**
 * Save size (& optionally position) in registry
 */
void
CMoveConstraint::LoadPosition(const tchar_t* szKeyName, const tchar_t* szValueName, bool position)
{
	m_sRegistrySubkey = szKeyName;
	LoadPosition(szValueName, position);
}

/**
 * Save size (& optionally position) in registry
 */
void
CMoveConstraint::LoadPosition(const tchar_t* szValueName, bool position)
{
	m_sRegistryValueName = szValueName;
	m_bPersistent=true;
	Persist(false, position);
}

void
CMoveConstraint::Persist(bool saving, bool position)
{
	const tchar_t* szSection = m_sRegistrySubkey;
	if (saving)
	{
		CString str;
		RECT rc;
		GetWindowRect(m_hwndDlg, &rc);
		str.Format(_T("%d,%d,%d,%d"), rc.left, rc.top, rc.right, rc.bottom);
		AfxGetApp()->WriteProfileString(szSection, m_sRegistryValueName, str);
	}
	else
	{
		RECT wprc;
		CString str = AfxGetApp()->GetProfileString(szSection, m_sRegistryValueName);
		GetWindowRect(m_hwndDlg, &wprc);
		if (m_pFormView != nullptr)
			CWnd::FromHandle(m_hwndDlg)->GetParent()->ScreenToClient(&wprc);
		CRect rc;
		int ct=_stscanf_s(str, _T("%d,%d,%d,%d"), &rc.left, &rc.top, &rc.right, &rc.bottom);
		if (ct==4)
		{
			if (position)
			{
				wprc.left = rc.left;
				wprc.top = rc.top;
			}
			int width = rc.Width();
			int height = rc.Height();
			if (m_nMinX && m_nMinX > width)  width = m_nMinX;
			if (m_nMaxX && m_nMaxX < width)  width = m_nMaxX;
			if (m_nMinY && m_nMinY > height) height = m_nMinY;
			if (m_nMaxY && m_nMaxY < height) height = m_nMaxY;
			wprc.right = wprc.left + width;
			wprc.bottom = wprc.top + height;
			SetWindowPos(m_hwndDlg, nullptr, 
				wprc.left, wprc.top, wprc.right - wprc.left, wprc.bottom - wprc.top,
				SWP_NOZORDER | SWP_NOACTIVATE);
		}
	}
}


void
CMoveConstraint::SetTip(int id, const tchar_t* szTip)
{
	tip ti;
	ti.m_sText = szTip;
	m_tips[id] = ti;
}

void
CMoveConstraint::SetTip(int id, int nResourceId)
{
	tip ti;
	ti.m_nResourceId = nResourceId;
	m_tips[id] = ti;
}


} // namespace

</file>

<file path="Winmerge-Src/Src/Common/CMoveConstraint.h">
/*!
  \file    CMoveConstraint.h
  \author  Perry Rapp, Creator, 1998-2004
  \date    Created: 1998
  \date    Edited:  2006-09-23 (Kimmo Varis)

  \brief   Declaration of CMoveConstraint

*/
/* The MIT License
Copyright (c) 2001 Perry Rapp
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
#pragma once

#include <afxtempl.h>

class CFormView;

namespace prdlg {

/*!
  \class CMoveConstraint
  \brief Code to resize controls on a dialog (formview, propertypage)

  HOW TO USE

  (a) add a member variable

	prdlg::CMoveConstraint m_constraint; 

  (b) add (1) Initialize & (2,3,4...) Constrain calls
      (to OnInitDialog for dialogs)
      (to InitialUpdate for views)
      (to OnCreate or OnCreateClient for frames)

  (c) optionally call any Allow or Disallow functions to adjust sizing potential (as in b)

  (d) call SetIsPropertyPage or Sheet if appropriate
       call SetScrollScale (for formview)

  Choose to (e1) Subclass or (e2) call WindowProc

  (e1) call Subclass - can call after Initialize calls
       unless original size is needed, eg FormViews,
		 in which case call Initialize from OnNcCreate

  (e2) override dialog's WindowProc and forward to constraint
    add code to WindowProc (copy following block) before the call to the parent WindowProc
	   use ClassWizard, or add to AFX_VIRTUAL block:
	   virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);

	LRESULT lresult;
	if (m_constraint.WindowProc(m_hWnd, message, wParam, lParam, &lresult))
		return lresult;


   For frames & views, the GetMinMaxInfo is sent to the frame
   so the frame must have a constraint to control min & max

  EXAMPLE USE (in InitDialog)

  m_constraint.InitializeCurrentSize(this);
  m_constraint.ConstrainItem(IDC_EDIT, 0, 1, 0, 1); // fills up all x & y delta
  m_constraint.ConstrainItem(IDC_LABEL, 0, 0, 1, 0); // no expansion, but below 100% of height growth
  m_constraint.SubclassWnd(); // install subclassing

 */

class CMoveConstraint
{
public:
	enum EGRIP { SG_NONE, SG_NORMAL, SG_PARENTSTATE };
private:
	static EGRIP c_defGrip; // class-wide default sizing grip setting

public:
	static void SetDefGrip(EGRIP nDefGrip) { c_defGrip = nDefGrip; }

public:

	// add a MoveConstraint member to dialog or view
	CMoveConstraint();
	~CMoveConstraint();

	bool IsInitalized() { return m_hwndDlg!=nullptr; }

	// THIS IS THE USUAL ONE
	// call from InitDialog (dialogs) or InitialUpdate (views) or OnCreate (frames)
	// if you want the current size of the dialog
	// to be used for scaling the controls
	// fails if IsWindow fails
	bool InitializeCurrentSize(HWND hwndParent);
	bool InitializeCurrentSize(CWnd * pParent);

	// if you want to set, a priori, the size of the dialog to be assumed
	// the controls are scaled for in the template
	// for use when parent is maximized, and we need to know the design size (in pixels)
	// this size is what the initial controls are sized to fit
	void InitializeSpecificSize(HWND hwndParent, int nWidth, int nHeight);
	void InitializeSpecificSize(CWnd * pParent, int nWidth, int nHeight);

	// for FORMVIEWS, who lose their dialog size early
	// fails if no WM_SIZE came thru
	bool InitializeOriginalSize(CWnd * pParent);
	bool InitializeOriginalSize(HWND hwndParent);

	// force an update of controls (laying them out to current size)
	void UpdateSizes();

	// default is no height shrink, no width shrink
	// but allowed height growth & allowed width growth
	void AllowHeightShrink();
	void AllowWidthShrink();
	void DisallowHeightGrowth();
	void DisallowWidthGrowth();
	// if you know exactly how big you want to allow it (in pixels)
	// use -1 to not set an argument
	void SetMaxSizePixels(int nWidth, int nHeight);
	void SetMinSizePixels(int nWidth, int nHeight);
	void SetMinSizePercent(double fWidth, double fHeight);

	// for FORMVIEW, how much to reduce scrollbars when form shrinks
	void SetScrollScale(CFormView * pFormView, double fShrinkWidth, double fShrinkHeight);

	// call for each constrained child window (three equivalent versions for convenience)
	// fails if IsWindow fails (except with CWnd it is just deferred)
	bool Constrain(HWND hwndChild, double fLeftX, double fExpandX, double fAboveY, double fExpandY);
	void Constrain(CWnd * pWnd, double fLeftX, double fExpandX, double fAboveY, double fExpandY);
	bool ConstrainItem(int nId, double fLeftX, double fExpandX, double fAboveY, double fExpandY);

	void SetIsPropertyPage() { m_bPropertyPage = true; SetSizeGrip(SG_NONE); }
	void SetIsPropertySheet() { m_bPropertySheet = true; }
	void SetIsView() { SetSizeGrip(SG_PARENTSTATE); }

	// If you plan to constrain windows that are not your children
	// (eg, grandchildren), call this
	void ConstrainNonChildren() { m_bConstrainNonChildren = true; }

	// embedded windows, such as property pages or formviews, should set the size grip to none
	void SetSizeGrip(EGRIP nGrip) { m_nGrip = nGrip; }
	// either Subclass or call a WindowProc
	bool SubclassWnd();
	bool UnSubclassWnd();

	// call after all constraints established
	// always loads size, may also set position
	void LoadPosition(const tchar_t* szKeyName, const tchar_t* szValueName, bool position);
	void LoadPosition(const tchar_t* szValueName, bool position);
	void Persist(bool saving, bool position);

	// for use when children hadn't been created yet at initialization time
	// so their constraints had to be buffered to be initialized later
	// (this is used by property pages & property sheets automatically, at PSN_SETACTIVE)
	void CheckDeferredChildren();
	int GetDeferredCount() { return m_nDelayed; }

	// see usage section above
	bool WindowProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam, LRESULT * plresult);

// ToolTips
	void SetTip(int id, const tchar_t* szTip);
	void SetTip(int id, int nResourceId);

// Implementation methods
protected:
	struct Constraint;
	void GrabCurrentDimensionsAsOriginal(HWND hwndParent);
	bool DoConstrain(CWnd * pWnd, HWND hwndChild, double fLeftX, double fExpandX, double fAboveY, double fExpandY);
	void InitializeChildConstraintData(HWND hwndParent, Constraint & constraint);
	// handle WM_SIZE
	void Resize(HWND hWnd, UINT nType);
	// handle WM_GETMINMAXINFO
	void OnGetMinMaxInfo(MINMAXINFO* lpMMI );
	// handle WM_NCHITTEST
	bool OnNcHitTest(UINT message, WPARAM wParam, LPARAM lParam, LRESULT * plresult);
	// handle WM_NOTIFY/TTN_NEEDTEXT combination
	bool OnTtnNeedText(TOOLTIPTEXT * pTTT, LRESULT * plresult);
	bool PaintGrip();
	void ClearMostData();
	// handle WM_DESTROY
	void OnDestroy();


	static LRESULT CALLBACK ConstraintWndProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam );
	

// Implementation types
protected:
	struct tip { CString m_sText; int m_nResourceId; tip() : m_nResourceId(0) { } };

	struct Constraint
	{
		double m_fLeftX;
		double m_fExpandX;
		double m_fAboveY;
		double m_fExpandY;
		HWND m_hwndChild;
		CWnd * m_pWnd;
		CRect m_rectChildOriginal;
		HWND m_hwndParent; // normally is the dialog
		Constraint();
		Constraint(double fLeftX, double fExpandX, double fAboveY, double fExpandY, HWND hwndChild, CWnd * pWnd);
		void Init();
	};

	typedef std::list<Constraint> ConstraintList;


// Implementation data
private:
	HWND m_hwndDlg; // parent of controls - could be FormView or PropertyPage or whatever as well
	CRect m_rectDlgOriginal;
	int m_nOrigX;
	int m_nOrigY;
	EGRIP m_nGrip;
	HTHEME m_hTheme;
	bool m_bOriginalFetched;
	int m_nMinX;
	int m_nMinY;
	int m_nMaxX;
	int m_nMaxY;
	int m_nDelayed; // CWnds without HWND
	bool m_bSubclassed;
	WNDPROC m_oldWndProc;
// formview stuff
	CFormView * m_pFormView;
	// formview original scrollbars
	int m_nOrigScrollX;
	int m_nOrigScrollY;
	// formview - how much scrollbars shrink
	double m_fShrinkWidth;
	double m_fShrinkHeight;
	// special handling for PSN_SETACTIVE
	bool m_bPropertyPage;
	bool m_bPropertySheet;
// constraints
	ConstraintList m_ConstraintList;
	bool m_bConstrainNonChildren;
	bool m_bPersistent; // whether to save position to registry
	CString m_sRegistrySubkey; // defaults to _T("LastWindowPos")
	CString m_sRegistryValueName; // should be name of window
// tooltips
	CMap<UINT_PTR, UINT_PTR, tip, tip&> m_tips;
};

} // namespace
</file>

<file path="Winmerge-Src/Src/Common/ColorButton.cpp">
/** 
 * @file  ColorButton.cpp
 *
 * @brief Implementation file for CColorButton
 *
 */

#include "stdafx.h"
#include "ColorButton.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/** 
 * @brief Default constructor setting color to black.
 */
CColorButton::CColorButton()
: m_clrFill(RGB(0, 0, 0))
{
}

/** 
 * @brief Constructor setting initial color
 * @param [in] clfFill Initial color to set.
 */
CColorButton::CColorButton(COLORREF clrFill)
: m_clrFill(clrFill)
{
}

/** 
 * @brief Draws color button
 */
void CColorButton::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct) 
{
	::FillRect(lpDrawItemStruct->hDC, &lpDrawItemStruct->rcItem, CBrush(m_clrFill));
}

/** 
 * @brief Sets new button color
 * @param [in] crlFill New color
 * @param [in] bInvalidate If `true` button is invalidated (causing redraw)
 */
void CColorButton::SetColor(COLORREF clrFill, bool bInvalidate /* = true*/)
{
	m_clrFill = clrFill;
	if (bInvalidate && m_hWnd != nullptr)
		Invalidate();
}
</file>

<file path="Winmerge-Src/Src/Common/ColorButton.h">
/** 
 * @file  ColorButton.h
 *
 * @brief Declaration file for CColorButton class
 */
#pragma once

/** 
 * @brief Button showing currently selected color.
 * This class creates a button that shows currently selected color in its
 * client area. When the button is selected it opens color selection
 * dialog for selecting new color.
 */
class CColorButton : public CButton
{
private:
	COLORREF m_clrFill;

public:
	CColorButton();
	explicit CColorButton(COLORREF clrFill);

	void SetColor(COLORREF clrFill, bool bInvalidate = true);
	COLORREF GetColor() const { return m_clrFill; };
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
};
</file>

<file path="Winmerge-Src/Src/Common/coretools.cpp">
/**
 * @file  coretools.cpp
 *
 * @brief Common routines
 *
 */

#include "pch.h"
#include "coretools.h"

static bool iseolch(char ch)
{
	return ch == '\n' || ch == '\r';
}

size_t linelen(const char *string, size_t maxlen)
{
	const char *q = string + maxlen;
	do
	{
		maxlen = q - string;
	} while (maxlen && iseolch(*--q));
	return maxlen;
}
</file>

<file path="Winmerge-Src/Src/Common/coretools.h">
/**
 * @file  coretools.h
 *
 * @brief Declaration file for Coretools.cpp
 */
#pragma once

size_t linelen(const char *string, size_t maxlen);
</file>

<file path="Winmerge-Src/Src/Common/DebugNew.h">
#ifdef _DEBUG
void* operator new(size_t size, const char *file, int line);
void* operator new[](size_t size, const char *file, int line);
#define DEBUG_NEW new(__FILE__, __LINE__)
#define new DEBUG_NEW
void operator delete(void* p, const char *file, int line);
void operator delete[](void* p, const char *file, int line);
#endif
</file>

<file path="Winmerge-Src/Src/Common/ExConverter.cpp">
/** 
 * @file  ExConverter.cpp
 *
 * @brief Codepage converter using external libraries.
 */

#include "pch.h"
#include "ExConverter.h"
#include <windows.h>
#include <mlang.h>
#include <memory>
#include <list>
#define POCO_NO_UNWINDOWS 1
#include <Poco/Mutex.h>
#include "unicoder.h"

#if !defined(__IMultiLanguage2_INTERFACE_DEFINED__) && !defined(__GNUC__)
#error "IMultiLanguage2 is not defined in mlang.h. Please install latest Platform SDK."
#endif

#if defined(__GNUC__)
const IID IID_IMultiLanguage2 = {0xDCCFC164, 0x2B38, 0x11d2, {0xB7, 0xEC, 0x00, 0xC0, 0x4F, 0x8F, 0x5D, 0x9A}};
#endif 

extern "C" typedef HRESULT (__stdcall *DllGetClassObjectFunc)(const CLSID &, const IID &, void **); 

class CExconverterMLang: public IExconverter {
private:
	IMultiLanguage2 *m_pmlang;
	HMODULE m_hLibMLang;
	DWORD m_mlangcookie;
#ifdef USEUNIVERSALCHARDET
	HMODULE m_hLibCharGuess;
	int (*m_pfnCharGuessInit)(void);
	int (*m_pfnCharGuessDone)(void);
	const char* (*m_pfnGuessChardet)(const char *str);
#endif

public:
	CExconverterMLang()
	: m_pmlang(nullptr)
	, m_hLibMLang(nullptr)
	, m_mlangcookie(0)
	{
	}

	virtual ~CExconverterMLang() override
	{
		if (m_pmlang != nullptr)
			m_pmlang->Release();
		if (m_hLibMLang != nullptr)
			FreeLibrary(m_hLibMLang);
	}

	bool initialize()
	{
		DllGetClassObjectFunc pfnDllGetClassObject = nullptr;
		IClassFactory *pClassFactory = nullptr;

		m_hLibMLang = LoadLibrary(_T("mlang.dll"));
		if (m_hLibMLang != nullptr)
		{
			pfnDllGetClassObject = (DllGetClassObjectFunc)GetProcAddress(m_hLibMLang, "DllGetClassObject");
			if (pfnDllGetClassObject != nullptr)
			{
				HRESULT hr = pfnDllGetClassObject(CLSID_CMultiLanguage, IID_IClassFactory, (void**)&pClassFactory);
				if (pClassFactory != nullptr)
				{
					hr = pClassFactory->CreateInstance(nullptr, IID_IMultiLanguage2, (void**)&m_pmlang);
					if (SUCCEEDED(hr))
					{
						pClassFactory->Release();
						return true;
					}
				}
			}
		}
		if (pClassFactory != nullptr)
			pClassFactory->Release();
		if (m_hLibMLang != nullptr)
		{
			FreeLibrary(m_hLibMLang);
			m_hLibMLang = nullptr;
		}
		return false;
	}

	bool convert(int srcCodepage, int dstCodepage, const unsigned char * src, size_t * srcbytes, unsigned char * dest, size_t * destbytes)
	{
		bool bsucceeded;
#ifdef POCO_ARCH_BIG_ENDIAN
		if (srcCodepage == ucr::CP_UCS2BE)
#else
		if (srcCodepage == ucr::CP_UCS2LE)
#endif
		{
			size_t srcwchars = *srcbytes / sizeof(wchar_t);
			bsucceeded = convertFromUnicode(dstCodepage, (const wchar_t *)src, &srcwchars, (char *)dest, destbytes);
			*srcbytes = srcwchars * sizeof(wchar_t);
		}
		else
		{
			size_t wsize = *srcbytes * 2 + 6;
			auto pbuf = std::make_unique<wchar_t[]>(wsize);
			bsucceeded = convertToUnicode(srcCodepage, (const char *)src, srcbytes, pbuf.get(), &wsize);
			if (!bsucceeded)
			{
				*destbytes = 0;
				return false;
			}
			bsucceeded = convertFromUnicode(dstCodepage, pbuf.get(), &wsize, (char *)dest, destbytes);
		}
		return bsucceeded;
	}

	bool convertFromUnicode(int dstCodepage, const wchar_t * src, size_t * srcchars, char * dest, size_t *destbytes)
	{
		UINT uisrcchars = static_cast<UINT>(*srcchars), uidestbytes = static_cast<UINT>(*destbytes);
		HRESULT hr = m_pmlang->ConvertStringFromUnicode(&m_mlangcookie, dstCodepage, (wchar_t *)src, &uisrcchars, (char *)dest, &uidestbytes);
		*srcchars = uisrcchars;
		*destbytes = uidestbytes;
		return SUCCEEDED(hr) ? true : false;
	}

	bool convertToUnicode(int srcCodepage, const char * src, size_t * srcbytes, wchar_t * dest, size_t *destchars)
	{
		UINT uisrcbytes = static_cast<UINT>(*srcbytes), uidestchars = static_cast<UINT>(*destchars);
		HRESULT hr = m_pmlang->ConvertStringToUnicode(&m_mlangcookie, srcCodepage, (char *)src, &uisrcbytes, dest, &uidestchars);
		*srcbytes = uisrcbytes;
		*destchars = uidestchars;
		if (SUCCEEDED(hr))
			return true;
		if (srcCodepage != ucr::CP_UCS2BE)
			return false;
#ifdef POCO_ARCH_BIG_ENDIAN
		return false;
#else
		// Workaround for the problem that Wine does not support UCS2-BE(1201) as the source code page for IMultiLanguage::ConvertStringToUnicode()
		if (uisrcbytes > 0)
		{
			for (size_t i = 0; i < uisrcbytes - 1; i += 2)
				dest[i >> 1] = (src[i] << 8) + src[i + 1];
			if ((uisrcbytes % 2) == 1)
				memcpy(reinterpret_cast<unsigned char*>(dest) + uisrcbytes - 1, src + uisrcbytes - 1, 1);
		}
		*srcbytes = uisrcbytes;
		*destchars = uisrcbytes;
		return true;
#endif
	}

	void clearCookie()
	{
		m_mlangcookie = 0;
	}

	int detectInputCodepage(int autodetectType, int defcodepage, const char *data, size_t size)
	{
		int codepage;
		IMLangConvertCharset *pcc;
		UINT dstsize;
		UINT srcsize;
		HRESULT hr;

		hr = m_pmlang->CreateConvertCharset(autodetectType, ucr::CP_UCS2LE, MLCONVCHARF_AUTODETECT, &pcc);
		if (FAILED(hr))
			return defcodepage;
		srcsize = static_cast<UINT>(size);
		dstsize = static_cast<UINT>(size * sizeof(wchar_t));
		auto pdst = std::make_unique<unsigned char[]>(size * sizeof(wchar_t));
		SetLastError(0);
		hr = pcc->DoConversion((unsigned char *)data, &srcsize, pdst.get(), &dstsize);
		pcc->GetSourceCodePage((unsigned *)&codepage);
		if (FAILED(hr) || GetLastError() == ERROR_NO_UNICODE_TRANSLATION || codepage == autodetectType)
		{
			int codepagestotry[3] = {0};
			if (codepage == autodetectType)
			{
				if (size < 2 || (data[0] != 0 && data[1] != 0))
				{
					codepagestotry[0] = defcodepage;
					codepagestotry[1] = ucr::CP_UTF_8;
				}
			}
			else
			{
				if (size < 2 || (data[0] != 0 && data[1] != 0))
					codepagestotry[0] = ucr::CP_UTF_8;
			}
			codepage = defcodepage;
			size_t i;
			for (i = 0; i < sizeof(codepagestotry)/sizeof(codepagestotry[0]) - 1; i++)
			{
				if (codepagestotry[i] == 0) break;
				pcc->Initialize(codepagestotry[i], ucr::CP_UCS2LE, 0);
				srcsize = static_cast<UINT>(size);
				dstsize = static_cast<UINT>(size * sizeof(wchar_t));
				SetLastError(0);
				hr = pcc->DoConversion((unsigned char *)data, &srcsize, pdst.get(), &dstsize);
				if (FAILED(hr) || GetLastError() == ERROR_NO_UNICODE_TRANSLATION)
					continue;
				codepage = codepagestotry[i];
				break;
			}
			if (codepagestotry[i] == 0 && (size % 2) == 0)
			{
				// UCS-2
				int lezerocount = 0;
				int lecrorlf = 0;
				int bezerocount = 0;
				int becrorlf = 0;
				for (i = 0; i < size; i += 2)
				{
					if (data[i] == 0)
					{
						bezerocount++;
						if (data[i + 1] == 0x0a || data[i + 1] == 0x0d)
							becrorlf++;
					}
					else if (data[i + 1] == 0)
					{
						lezerocount++;
						if (data[i] == 0x0a || data[i] == 0x0d)
							lecrorlf++;
					}
				}
				if (lezerocount > 0 || bezerocount > 0)
				{
					if ((lecrorlf == 0 && size < 512 || (lecrorlf > 0 && (size / lecrorlf > 1024))) && lezerocount > bezerocount)
						codepage = ucr::CP_UCS2LE;
					else if ((becrorlf == 0 && size < 512 || (becrorlf > 0 && (size / becrorlf > 1024))) && lezerocount < bezerocount)
						codepage = ucr::CP_UCS2BE;
				}
			}
		}
		if (codepage == 20127 || codepage == 65000)
			return defcodepage;
		return codepage;
	}

	std::vector<CodePageInfo> enumCodePages()
	{
		std::vector<CodePageInfo> cpinfo;
		IEnumCodePage *pEnumCodePage = nullptr;
		ULONG ccpInfo;
		HRESULT hr = m_pmlang->EnumCodePages(MIMECONTF_SAVABLE_BROWSER | MIMECONTF_VALID | MIMECONTF_VALID_NLS, 0, &pEnumCodePage);
		if (FAILED(hr))
			return cpinfo;
		auto pcpInfo = std::make_unique<MIMECPINFO[]>(256);
		if (FAILED(pEnumCodePage->Next(256, pcpInfo.get(), &ccpInfo)))
			return cpinfo;

		cpinfo.resize(ccpInfo);
		for (int i = 0; i < (int)ccpInfo; i++)
		{
			cpinfo[i].codepage = pcpInfo[i].uiCodePage;
			cpinfo[i].desc = ucr::toTString(pcpInfo[i].wszDescription);
		}

		return cpinfo;
	}

	bool getCodepageFromCharsetName(const String& sCharsetName, int& codepage)
	{
		MIMECSETINFO charsetInfo;
		BSTR bstrCharsetName = SysAllocString(ucr::toUTF16(sCharsetName).c_str());
		HRESULT hr = m_pmlang->GetCharsetInfo(bstrCharsetName, &charsetInfo);
		SysFreeString(bstrCharsetName);
		if (FAILED(hr))
			return false;
		codepage = charsetInfo.uiInternetEncoding;
		return true;
	}

	bool getCodepageDescription(int codepage, String& sDescription)
	{
		wchar_t szDescription[256];
		HRESULT hr = m_pmlang->GetCodePageDescription(codepage, GetSystemDefaultLangID(), szDescription, sizeof(szDescription)/sizeof(wchar_t));
		if (FAILED(hr))
			return false;

		sDescription = ucr::toTString(szDescription);
		return true;
	}

	bool isValidCodepage(int codepage)
	{
		String sDesc;
		return getCodepageDescription(codepage, sDesc);
	}

	bool getCodePageInfo(int codepage, CodePageInfo *pCodePageInfo)
	{
		MIMECPINFO mcpi = {0};
		HRESULT hr = m_pmlang->GetCodePageInfo(codepage, GetSystemDefaultLangID(), &mcpi);
		if (FAILED(hr))
			return false;
		pCodePageInfo->proportionalFont = ucr::toTString(mcpi.wszProportionalFont);
		pCodePageInfo->fixedWidthFont = ucr::toTString(mcpi.wszFixedWidthFont);
		pCodePageInfo->bGDICharset = mcpi.bGDICharset;
		return true;
	}

};

#ifdef _MSC_VER
__declspec(thread) static IExconverter *m_pexconv = nullptr;
#else
static __thread IExconverter *m_pexconv = nullptr;
#endif
static std::list<std::unique_ptr<IExconverter> > m_exconv_list;
static Poco::FastMutex m_mutex;

IExconverter *Exconverter::getInstance()
{
	if (m_pexconv != nullptr)
	{
		m_pexconv->clearCookie();
		return m_pexconv;
	}
	CExconverterMLang *pexconv = new CExconverterMLang();
	if (!pexconv->initialize())
	{
		delete pexconv;
		return nullptr;
	}
	m_pexconv = pexconv;
	Poco::FastMutex::ScopedLock lock(m_mutex);
	m_exconv_list.emplace_back(m_pexconv);
	return m_pexconv;
}

</file>

<file path="Winmerge-Src/Src/Common/ExConverter.h">
#pragma once

#include "UnicodeString.h"
#include <vector>

struct CodePageInfo
{
	int codepage = 0;
	String desc;
	String proportionalFont;
	String fixedWidthFont;
	char bGDICharset = 0;
};

struct IExconverter
{
	virtual ~IExconverter() {}
	virtual bool initialize() = 0;
	virtual bool convert(int srcCodepage, int dstCodepage, const unsigned char * src, size_t * srcbytes, unsigned char * dest, size_t * destbytes) = 0;
	virtual bool convertFromUnicode(int dstCodepage, const wchar_t * src, size_t * srcchars, char * dest, size_t *destbytes) = 0;
	virtual bool convertToUnicode(int srcCodepage, const char * src, size_t * srcbytes, wchar_t * dest, size_t *destchars) = 0;
	virtual void clearCookie() = 0;
	virtual int detectInputCodepage(int autodetectType, int defcodepage, const char *data, size_t size) = 0;
	virtual std::vector<CodePageInfo> enumCodePages() = 0;
	virtual bool getCodepageFromCharsetName(const String& sCharsetName, int& codepage) = 0;
	virtual bool getCodepageDescription(int codepage, String& sCharsetName) = 0;
	virtual bool isValidCodepage(int codepage) = 0;
	virtual bool getCodePageInfo(int codePage, CodePageInfo *pCodePageInfo) = 0;
};

struct Exconverter
{
	static IExconverter *getInstance();
};
</file>

<file path="Winmerge-Src/Src/Common/IatHook.h">
/* This file is a modified version of IatHook.h from the win32-darkmode project
 * (https://github.com/ysc3839/win32-darkmode)
 * Original file: https://github.com/ysc3839/win32-darkmode/blob/master/win32-darkmode/IatHook.h
 */
// This file contains code from
// https://github.com/stevemk14ebr/PolyHook_2_0/blob/master/sources/IatHook.cpp
// which is licensed under the MIT License.
// See PolyHook_2_0-LICENSE for more information.

#pragma once

#if (NTDDI_VERSION <= NTDDI_WINXP)

typedef struct _IMAGE_DELAYLOAD_DESCRIPTOR {
	union {
		DWORD AllAttributes;
		struct {
			DWORD RvaBased : 1;
			DWORD ReservedAttributes : 31;
		} DUMMYSTRUCTNAME;
	} Attributes;
	DWORD DllNameRVA;
	DWORD ModuleHandleRVA;
	DWORD ImportAddressTableRVA;
	DWORD ImportNameTableRVA;
	DWORD BoundImportAddressTableRVA;
	DWORD UnloadInformationTableRVA;
	DWORD TimeDateStamp;
} IMAGE_DELAYLOAD_DESCRIPTOR, *PIMAGE_DELAYLOAD_DESCRIPTOR;

#endif

template <typename T, typename T1, typename T2>
constexpr T RVA2VA(T1 base, T2 rva)
{
	return reinterpret_cast<T>(reinterpret_cast<ULONG_PTR>(base) + rva);
}

template <typename T>
constexpr T DataDirectoryFromModuleBase(void *moduleBase, size_t entryID)
{
	auto dosHdr = reinterpret_cast<PIMAGE_DOS_HEADER>(moduleBase);
	auto ntHdr = RVA2VA<PIMAGE_NT_HEADERS>(moduleBase, dosHdr->e_lfanew);
	auto dataDir = ntHdr->OptionalHeader.DataDirectory;
	return RVA2VA<T>(moduleBase, dataDir[entryID].VirtualAddress);
}

PIMAGE_THUNK_DATA FindAddressByName(void *moduleBase, PIMAGE_THUNK_DATA impName, PIMAGE_THUNK_DATA impAddr, const char *funcName)
{
	for (; impName->u1.Ordinal; ++impName, ++impAddr)
	{
		if (IMAGE_SNAP_BY_ORDINAL(impName->u1.Ordinal))
			continue;

		auto import = RVA2VA<PIMAGE_IMPORT_BY_NAME>(moduleBase, impName->u1.AddressOfData);
		if (strcmp(reinterpret_cast<char *>(import->Name), funcName) != 0)
			continue;
		return impAddr;
	}
	return nullptr;
}

PIMAGE_THUNK_DATA FindAddressByOrdinal(void *moduleBase, PIMAGE_THUNK_DATA impName, PIMAGE_THUNK_DATA impAddr, uint16_t ordinal)
{
	for (; impName->u1.Ordinal; ++impName, ++impAddr)
	{
		if (IMAGE_SNAP_BY_ORDINAL(impName->u1.Ordinal) && IMAGE_ORDINAL(impName->u1.Ordinal) == ordinal)
			return impAddr;
	}
	return nullptr;
}

PIMAGE_THUNK_DATA FindIatThunkInModule(void *moduleBase, const char *dllName, const char *funcName)
{
	auto imports = DataDirectoryFromModuleBase<PIMAGE_IMPORT_DESCRIPTOR>(moduleBase, IMAGE_DIRECTORY_ENTRY_IMPORT);
	for (; imports->Name; ++imports)
	{
		if (_stricmp(RVA2VA<LPCSTR>(moduleBase, imports->Name), dllName) != 0)
			continue;

		auto origThunk = RVA2VA<PIMAGE_THUNK_DATA>(moduleBase, imports->OriginalFirstThunk);
		auto thunk = RVA2VA<PIMAGE_THUNK_DATA>(moduleBase, imports->FirstThunk);
		return FindAddressByName(moduleBase, origThunk, thunk, funcName);
	}
	return nullptr;
}

PIMAGE_THUNK_DATA FindDelayLoadThunkInModule(void *moduleBase, const char *dllName, const char *funcName)
{
	auto imports = DataDirectoryFromModuleBase<PIMAGE_DELAYLOAD_DESCRIPTOR>(moduleBase, IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT);
	for (; imports->DllNameRVA; ++imports)
	{
		if (_stricmp(RVA2VA<LPCSTR>(moduleBase, imports->DllNameRVA), dllName) != 0)
			continue;

		auto impName = RVA2VA<PIMAGE_THUNK_DATA>(moduleBase, imports->ImportNameTableRVA);
		auto impAddr = RVA2VA<PIMAGE_THUNK_DATA>(moduleBase, imports->ImportAddressTableRVA);
		return FindAddressByName(moduleBase, impName, impAddr, funcName);
	}
	return nullptr;
}

PIMAGE_THUNK_DATA FindDelayLoadThunkInModule(void *moduleBase, const char *dllName, uint16_t ordinal)
{
	auto imports = DataDirectoryFromModuleBase<PIMAGE_DELAYLOAD_DESCRIPTOR>(moduleBase, IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT);
	for (; imports->DllNameRVA; ++imports)
	{
		if (_stricmp(RVA2VA<LPCSTR>(moduleBase, imports->DllNameRVA), dllName) != 0)
			continue;

		auto impName = RVA2VA<PIMAGE_THUNK_DATA>(moduleBase, imports->ImportNameTableRVA);
		auto impAddr = RVA2VA<PIMAGE_THUNK_DATA>(moduleBase, imports->ImportAddressTableRVA);
		return FindAddressByOrdinal(moduleBase, impName, impAddr, ordinal);
	}
	return nullptr;
}
</file>

<file path="Winmerge-Src/Src/Common/IMDITab.h">
#pragma once

#include <afxstr.h>

struct IMDITab
{
	virtual CString GetTooltipString() const = 0;
};

</file>

<file path="Winmerge-Src/Src/Common/IniOptionsMgr.cpp">
/**
 * @file IniOptionsMgr.cpp
 *
 * @brief Implementation of Ini file Options management class.
 *
 */

#include "pch.h"
#include "IniOptionsMgr.h"
#include <windows.h>
#include <process.h>
#include "OptionsMgr.h"

LPCWSTR lpAppName = TEXT("WinMerge");
LPCWSTR lpDefaultSection = TEXT("Defaults");

struct AsyncWriterThreadParams
{
	AsyncWriterThreadParams(const String& name, const varprop::VariantValue& value) : name(name), value(value) {}
	String name;
	varprop::VariantValue value;
};

class CIniOptionsMgr::IOHandler
{
public:
	IOHandler(const String& path) :
		  m_hThread(nullptr)
		, m_hEvent(nullptr)
		, m_dwThreadId(0)
		, m_dwQueueCount(0)
		, m_path(path)
	{
		m_hEvent = CreateEvent(nullptr, TRUE, FALSE, nullptr);
		if (m_hEvent)
		{
			m_hThread = reinterpret_cast<HANDLE>(
				_beginthreadex(nullptr, 0, AsyncWriterThreadProc, this, 0,
					reinterpret_cast<unsigned*>(&m_dwThreadId)));
			WaitForSingleObject(m_hEvent, INFINITE);
			CloseHandle(m_hEvent);
			m_hEvent = nullptr;
		}
	}

	~IOHandler()
	{
		for (;;)
		{
			::PostThreadMessage(m_dwThreadId, WM_QUIT, 0, 0);
			if (WaitForSingleObject(m_hThread, 1) != WAIT_TIMEOUT)
				break;
		}
	}

	std::map<String, String> Load(const String& iniFilePath) const
	{
		std::map<String, String> iniFileKeyValues = ReadIniFile(iniFilePath, lpAppName);

		// after reading the "WinMerge" section try to read the "Defaults" section; overwrite existing entries in "iniFileKeyValues" with the ones from the "Defaults" section
		std::map<String, String> iniFileKeyDefaultValues = ReadIniFile(iniFilePath, lpDefaultSection);
		for (auto& [key, strValue] : iniFileKeyDefaultValues)
			iniFileKeyValues.insert_or_assign(key, strValue);
		return iniFileKeyValues;
	}

	const String& GetPath() const { return m_path; }

	void WriteAsync(const String& name, const varprop::VariantValue& value)
	{
		auto* pParam = new AsyncWriterThreadParams(name, value);
		InterlockedIncrement(&m_dwQueueCount);
		if (!::PostThreadMessage(m_dwThreadId, WM_USER, (WPARAM)pParam, 0))
		{
			delete pParam;
			InterlockedDecrement(&m_dwQueueCount);
		}
	}

	void WriteKeyValue(const String& key, const String& value, const String& filename)
	{
		// https://learn.microsoft.com/en-us/answers/questions/578134/error-in-writeprivateprofilestring-function-when-j
		WritePrivateProfileString(_T("WinMerge"), key.c_str(),
			nullptr, filename.c_str());
		WritePrivateProfileString(_T("WinMerge"), key.c_str(),
			EscapeValue(value).c_str(), filename.c_str());
	}

	int WaitForQueueFlush()
	{
		int retVal = COption::OPT_OK;

		while (InterlockedCompareExchange(&m_dwQueueCount, 0, 0) != 0)
			Sleep(0);

		return retVal;
	}

	int SaveValueToFile(const String& name, const varprop::VariantValue& value)
	{
		BOOL retValReg = TRUE;
		int valType = value.GetType();
		int retVal = COption::OPT_OK;

		if (valType == varprop::VT_STRING)
		{
			String strVal = EscapeValue(value.GetString());
			LPCWSTR text = strVal.c_str();
			// https://learn.microsoft.com/en-us/answers/questions/578134/error-in-writeprivateprofilestring-function-when-j
			WritePrivateProfileString(lpAppName, name.c_str(), nullptr, m_path.c_str());
			retValReg = WritePrivateProfileString(lpAppName, name.c_str(), text, m_path.c_str());
		}
		else if (valType == varprop::VT_INT)
		{
			DWORD dwordVal = value.GetInt();
			String strVal = strutils::to_str(dwordVal);
			LPCWSTR text = strVal.c_str();
			retValReg = WritePrivateProfileString(lpAppName, name.c_str(), text, m_path.c_str());
		}
		else if (valType == varprop::VT_BOOL)
		{
			DWORD dwordVal = value.GetBool() ? 1 : 0;
			String strVal = strutils::to_str(dwordVal);
			LPCWSTR text = strVal.c_str();
			retValReg = WritePrivateProfileString(lpAppName, name.c_str(), text, m_path.c_str());
		}
		else if (valType == varprop::VT_NULL)
		{
			auto [strPath, strValueName] = SplitName(name);
			if (!strValueName.empty())
				retValReg = WritePrivateProfileString(lpAppName, name.c_str(), nullptr, m_path.c_str());
			else
			{
				auto iniFileMap = Load(m_path);
				for (auto& [key, value2] : iniFileMap)
				{
					if (key.find(strPath) == 0 && key.length() > strPath.length() && key[strPath.length()] == '/')
						retValReg = WritePrivateProfileString(lpAppName, key.c_str(), nullptr, m_path.c_str());
				}
			}
		}
		else
		{
			retVal = COption::OPT_UNKNOWN_TYPE;
		}
			
		if (!retValReg)
		{
			retVal = COption::OPT_ERR;
		}
		return retVal;
	}

	static unsigned __stdcall AsyncWriterThreadProc(void *pvThis)
	{
		CIniOptionsMgr::IOHandler *pThis = reinterpret_cast<CIniOptionsMgr::IOHandler *>(pvThis);
		MSG msg;
		BOOL bRet;
		// create message queue
		PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE);
		SetEvent(pThis->m_hEvent);
		while ((bRet = GetMessage(&msg, 0, 0, 0)) != 0)
		{
			auto* pParam = reinterpret_cast<AsyncWriterThreadParams *>(msg.wParam);
			if (msg.message == WM_USER && pParam)
			{
				pThis->SaveValueToFile(pParam->name, pParam->value);
				delete pParam;
				InterlockedDecrement(&pThis->m_dwQueueCount);
			}
		}
		return 0;
	}

private:
	String m_path;
	DWORD m_dwThreadId;
	DWORD m_dwQueueCount;
	HANDLE m_hThread;
	HANDLE m_hEvent;
};

CIniOptionsMgr::CIniOptionsMgr(const String& filePath)
	: m_serializing(true)
	, m_pIOHandler(std::make_unique<IOHandler>(filePath))
{
	m_iniFileKeyValues = m_pIOHandler->Load(filePath);
}

CIniOptionsMgr::~CIniOptionsMgr()
{
	m_pIOHandler.reset();
}

int CIniOptionsMgr::LoadValueFromBuf(const String& strName, const String& textValue, varprop::VariantValue& value)
{
	int retVal = COption::OPT_OK;
	int valType = value.GetType();
	if (valType == varprop::VT_STRING)
	{
		value.SetString(textValue);
		retVal = Set(strName, value);
	}
	else if (valType == varprop::VT_INT)
	{
		tchar_t* endptr = nullptr;
		DWORD val = static_cast<DWORD>(tc::tcstoll(textValue.c_str(), &endptr, 
			(textValue.length() >= 2 && textValue[1] == 'x') ? 16 : 10));
		value.SetInt(static_cast<int>(val));
		retVal = Set(strName, value);
	}
	else if (valType == varprop::VT_BOOL)
	{
		value.SetBool(textValue[0] == '1' ? true : false);
		retVal = Set(strName, value);
	}
	else
		retVal = COption::OPT_WRONG_TYPE;

	return retVal;
}

int CIniOptionsMgr::InitOption(const String& name, const varprop::VariantValue& defaultValue)
{
	// Check type & bail if null
	int valType = defaultValue.GetType();
	if (valType == varprop::VT_NULL)
		return COption::OPT_ERR;

	// If we're not loading & saving options, bail
	if (!m_serializing)
		return AddOption(name, defaultValue);

	// Actually save value into our in-memory options table
	int retVal = AddOption(name, defaultValue);

	// Update registry if successfully saved to in-memory table
	if (retVal == COption::OPT_OK)
	{
		// check if value exist
		bool found = m_iniFileKeyValues.find(name) != m_iniFileKeyValues.end();
		if (found)
		{
			String textValue = m_iniFileKeyValues[name];
			varprop::VariantValue value(defaultValue);
			retVal = LoadValueFromBuf(name, textValue, value);
		}
	}

	return retVal;
}

int CIniOptionsMgr::InitOption(const String& name, const String& defaultValue)
{
	varprop::VariantValue defValue;
	defValue.SetString(defaultValue);
	return InitOption(name, defValue);
}

int CIniOptionsMgr::InitOption(const String& name, const tchar_t* defaultValue)
{
	return InitOption(name, String(defaultValue));
}

int CIniOptionsMgr::InitOption(const String& name, int defaultValue, bool serializable)
{
	varprop::VariantValue defValue;
	int retVal = COption::OPT_OK;

	defValue.SetInt(defaultValue);
	if (serializable)
		retVal = InitOption(name, defValue);
	else
		AddOption(name, defValue);
	return retVal;
}

int CIniOptionsMgr::InitOption(const String& name, bool defaultValue)
{
	varprop::VariantValue defValue;
	defValue.SetBool(defaultValue);
	return InitOption(name, defValue);
}

int CIniOptionsMgr::SaveOption(const String& name)
{
	if (!m_serializing) return COption::OPT_OK;

	varprop::VariantValue value;
	int retVal = COption::OPT_OK;

	value = Get(name);
	int valType = value.GetType();
	if (valType == varprop::VT_NULL)
		retVal = COption::OPT_NOTFOUND;

	if (retVal == COption::OPT_OK)
		m_pIOHandler->WriteAsync(name, value);

	return retVal;
}

/**
 * @brief Set new value for option and save option to file
 */
int CIniOptionsMgr::SaveOption(const String& name, const varprop::VariantValue& value)
{
	int retVal = Set(name, value);
	if (retVal == COption::OPT_OK)
		retVal = SaveOption(name);
	return retVal;
}

/**
 * @brief Set new string value for option and save option to file
 */
int CIniOptionsMgr::SaveOption(const String& name, const String& value)
{
	varprop::VariantValue val;
	val.SetString(value);
	int retVal = Set(name, val);
	if (retVal == COption::OPT_OK)
		retVal = SaveOption(name);
	return retVal;
}

/**
 * @brief Set new string value for option and save option to file
 */
int CIniOptionsMgr::SaveOption(const String& name, const tchar_t* value)
{
	return SaveOption(name, String(value));
}

int CIniOptionsMgr::SaveOption(const String& name, int value)
{
	varprop::VariantValue val;
	val.SetInt(value);
	int retVal = Set(name, val);
	if (retVal == COption::OPT_OK)
		retVal = SaveOption(name);
	return retVal;
}

int CIniOptionsMgr::SaveOption(const String& name, bool value)
{
	varprop::VariantValue val;
	val.SetBool(value);
	int retVal = Set(name, val);
	if (retVal == COption::OPT_OK)
		retVal = SaveOption(name);
	return retVal;
}

int CIniOptionsMgr::RemoveOption(const String& name)
{
	int retVal = COption::OPT_OK;
	auto [strPath, strValueName] = SplitName(name);

	if (!strValueName.empty())
	{
		retVal = COptionsMgr::RemoveOption(name);
	}
	else
	{
		for (auto it = m_optionsMap.begin(); it != m_optionsMap.end(); )
		{
			const String& key = it->first;
			if (key.find(strPath) == 0 && key.length() > strPath.length() && key[strPath.length()] == '/')
			{
				m_iniFileKeyValues.erase(key);
				it = m_optionsMap.erase(it);
			}
			else
				++it;
		}
		retVal = COption::OPT_OK;
	}

	m_pIOHandler->WriteAsync(name, varprop::VariantValue());

	return retVal;
}

int CIniOptionsMgr::FlushOptions()
{
	return m_pIOHandler->WaitForQueueFlush();
}

int CIniOptionsMgr::ExportOptions(const String& filename, const bool bHexColor /*= false*/) const
{
	for (auto& [key, value] : m_iniFileKeyValues)
	{
		if (m_optionsMap.find(key) == m_optionsMap.end())
			m_pIOHandler->WriteKeyValue(key, value, filename);
	}
	return COptionsMgr::ExportOptions(filename, bHexColor);
}

int CIniOptionsMgr::ImportOptions(const String& filename)
{
	int retVal = COptionsMgr::ImportOptions(filename);
	auto iniFileMap = m_pIOHandler->Load(filename);
	for (auto& [key, value] : iniFileMap)
	{
		if (m_optionsMap.find(key) == m_optionsMap.end())
			m_pIOHandler->WriteKeyValue(key, value, m_pIOHandler->GetPath());
	}
	return retVal;
}

</file>

<file path="Winmerge-Src/Src/Common/IniOptionsMgr.h">
/**
 * @file IniOptionsMgr.h
 *
 * @brief Implementation of Ini file Options management class.
 *
 */
#pragma once

#include "OptionsMgr.h"

class COptionsMgr;

/**
 * @brief Ini-based implementation of OptionsMgr interface (q.v.).
 */
class CIniOptionsMgr : public COptionsMgr
{
public:
	explicit CIniOptionsMgr(const String& filePath);
	virtual ~CIniOptionsMgr();
	CIniOptionsMgr(const CIniOptionsMgr&) = delete;
	CIniOptionsMgr& operator=(const CIniOptionsMgr&) = delete;

	virtual int InitOption(const String& name, const varprop::VariantValue& defaultValue) override;
	virtual int InitOption(const String& name, const String& defaultValue) override;
	virtual int InitOption(const String& name, const tchar_t* defaultValue) override;
	virtual int InitOption(const String& name, int defaultValue, bool serializable = true) override;
	virtual int InitOption(const String& name, bool defaultValue) override;

	virtual int SaveOption(const String& name) override;
	virtual int SaveOption(const String& name, const varprop::VariantValue& value) override;
	virtual int SaveOption(const String& name, const String& value) override;
	virtual int SaveOption(const String& name, const tchar_t* value) override;
	virtual int SaveOption(const String& name, int value) override;
	virtual int SaveOption(const String& name, bool value) override;

	virtual int RemoveOption(const String& name) override;

	virtual int FlushOptions() override;

	virtual int ExportOptions(const String& filename, const bool bHexColor=false) const override;
	virtual int ImportOptions(const String& filename) override;

	virtual void SetSerializing(bool serializing = true) override { m_serializing = serializing; }

protected:
	int LoadValueFromBuf(const String& strName, const String& textValue, varprop::VariantValue& value);

private:
	bool m_serializing;
	std::map<String, String> m_iniFileKeyValues;
	class IOHandler;
	std::unique_ptr<IOHandler> m_pIOHandler;
};
</file>

<file path="Winmerge-Src/Src/Common/LanguageSelect.cpp">
/**
 * @file  LanguageSelect.cpp
 *
 * @brief Implements the Language Selection dialog class (which contains the language data)
 */

#include "StdAfx.h"
#include "LanguageSelect.h"
#include "BCMenu.h"
#include "Environment.h"
#include "paths.h"
#include "unicoder.h"
#include "cio.h"

// Escaped character constants in range 0x80-0xFF are interpreted in current codepage
// Using C locale gets us direct mapping to Unicode codepoints
#pragma setlocale("C")

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/** @brief Relative path to WinMerge executable for lang files. */
static const tchar_t szRelativePath[] = _T("Languages");

static wchar_t *EatPrefix(wchar_t *text, const wchar_t *prefix);
static void unslash(std::wstring &s);
static HANDLE NTAPI FindFile(HANDLE h, const tchar_t* path, WIN32_FIND_DATA *fd);

/**
 * @brief A class holding information about language file.
 */
class LangFileInfo
{
public:
	LANGID id; /**< Language ID. */

	static LANGID LangId(const char *lang, const char *sublang);
	
	/**
	 * A constructor taking a language id as parameter.
	 * @param [in] id Language ID to use.
	 */
	explicit LangFileInfo(LANGID id): id(id) { };
	
	explicit LangFileInfo(const tchar_t* path);
	String GetString(LCTYPE type) const;

private:
	struct rg
	{
		LANGID id;
		const char *lang;
	};
	static const struct rg rg[];
};

/**
 * @brief An array holding language IDs and names.
 */
const struct LangFileInfo::rg LangFileInfo::rg[] =
{
	{
		LANG_AFRIKAANS,		"AFRIKAANS\0"
	},
	{
		LANG_ALBANIAN,		"ALBANIAN\0"
	},
	{
		LANG_ARABIC,		"ARABIC\0"						"SAUDI_ARABIA\0"
															"IRAQ\0"
															"EGYPT\0"
															"LIBYA\0"
															"ALGERIA\0"
															"MOROCCO\0"
															"TUNISIA\0"
															"OMAN\0"
															"YEMEN\0"
															"SYRIA\0"
															"JORDAN\0"
															"LEBANON\0"
															"KUWAIT\0"
															"UAE\0"
															"BAHRAIN\0"
															"QATAR\0"
	},
	{
		LANG_ARMENIAN,		"ARMENIAN\0"
	},
	{
		LANG_ASSAMESE,		"ASSAMESE\0"
	},
	{
		LANG_AZERI,			"AZERI\0"						"LATIN\0"
															"CYRILLIC\0"
	},
	{
		LANG_BASQUE,		"BASQUE\0"
	},
	{
		LANG_BELARUSIAN,	"BELARUSIAN\0"
	},
	{
		LANG_BENGALI,		"BENGALI\0"
	},
	{
		LANG_BULGARIAN,		"BULGARIAN\0"
	},
	{
		LANG_CATALAN,		"CATALAN\0"
	},
	{
		LANG_CHINESE,		"CHINESE\0"						"TRADITIONAL\0"
															"SIMPLIFIED\0"
															"HONGKONG\0"
															"SINGAPORE\0"
															"MACAU\0"
	},
	{
		LANG_CORSICAN,		"CORSICAN\0"
	},
	{
		LANG_CROATIAN,		"CROATIAN\0"
	},
	{
		LANG_CZECH,			"CZECH\0"
	},
	{
		LANG_DANISH,		"DANISH\0"
	},
	{
		LANG_DIVEHI,		"DIVEHI\0"
	},
	{
		MAKELANGID(LANG_DUTCH, SUBLANG_DUTCH),				"DUTCH\0"
															"BELGIAN\0"
	},
	{
		LANG_ENGLISH,		"ENGLISH\0"						"US\0"
															"UK\0"
															"AUS\0"
															"CAN\0"
															"NZ\0"
															"EIRE\0"
															"SOUTH_AFRICA\0"
															"JAMAICA\0"
															"CARIBBEAN\0"
															"BELIZE\0"
															"TRINIDAD\0"
															"ZIMBABWE\0"
															"PHILIPPINES\0"
	},
	{
		LANG_ESTONIAN,		"ESTONIAN\0"
	},
	{
		LANG_FAEROESE,		"FAEROESE\0"
	},
	{
		LANG_FARSI,			"FARSI\0"
	},
	{
		LANG_FINNISH,		"FINNISH\0"
	},
	{
		MAKELANGID(LANG_FRENCH, SUBLANG_FRENCH),			"FRENCH\0"
															"BELGIAN\0"
															"CANADIAN\0"
															"SWISS\0"
															"LUXEMBOURG\0"
															"MONACO\0"
	},
	{
		LANG_GALICIAN,		"GALICIAN\0"
	},
	{
		LANG_GEORGIAN,		"GEORGIAN\0"
	},
	{
		MAKELANGID(LANG_GERMAN, SUBLANG_GERMAN),			"GERMAN\0"
															"SWISS\0"
															"AUSTRIAN\0"
															"LUXEMBOURG\0"
															"LIECHTENSTEIN"
	},
	{
		LANG_GREEK,			"GREEK\0"
	},
	{
		LANG_GUJARATI,		"GUJARATI\0"
	},
	{
		LANG_HEBREW,		"HEBREW\0"						"ISRAEL\0"
	},
	{
		LANG_HINDI,			"HINDI\0"
	},
	{
		LANG_HUNGARIAN,		"HUNGARIAN\0"
	},
	{
		LANG_ICELANDIC,		"ICELANDIC\0"
	},
	{
		LANG_INDONESIAN,	"INDONESIAN\0"
	},
	{
		MAKELANGID(LANG_ITALIAN, SUBLANG_ITALIAN),			"ITALIAN\0"
															"SWISS\0"
	},
	{
		LANG_JAPANESE,		"JAPANESE\0"
	},
	{
		LANG_KANNADA,		"KANNADA\0"
	},
	{
		MAKELANGID(LANG_KASHMIRI, SUBLANG_DEFAULT),			"KASHMIRI\0"
															"SASIA\0"
	},
	{
		LANG_KAZAK,			"KAZAK\0"
	},
	{
		LANG_KONKANI,		"KONKANI\0"
	},
	{
		MAKELANGID(LANG_KOREAN, SUBLANG_KOREAN),			"KOREAN\0"
	},
	{
		LANG_KYRGYZ,		"KYRGYZ\0"
	},
	{
		LANG_LATVIAN,		"LATVIAN\0"
	},
	{
		MAKELANGID(LANG_LITHUANIAN, SUBLANG_LITHUANIAN),	"LITHUANIAN\0"
	},
	{
		LANG_MACEDONIAN,	"MACEDONIAN\0"
	},
	{
		LANG_MALAY,			"MALAY\0"						"MALAYSIA\0"
															"BRUNEI_DARUSSALAM\0"
	},
	{
		LANG_MALAYALAM,		"MALAYALAM\0"
	},
	{
		LANG_MANIPURI,		"MANIPURI\0"
	},
	{
		LANG_MARATHI,		"MARATHI\0"
	},
	{
		LANG_MONGOLIAN,		"MONGOLIAN\0"
	},
	{
		MAKELANGID(LANG_NEPALI, SUBLANG_DEFAULT),			"NEPALI\0"
															"INDIA\0"
	},
	{
		LANG_NORWEGIAN,		"NORWEGIAN\0"					"BOKMAL\0"
															"NYNORSK\0"
	},
	{
		LANG_ORIYA,			"ORIYA\0"
	},
	{
		LANG_POLISH,		"POLISH\0"
	},
	{
		MAKELANGID(LANG_PORTUGUESE, SUBLANG_PORTUGUESE),	"PORTUGUESE\0"
															"BRAZILIAN\0"
	},
	{
		LANG_PUNJABI,		"PUNJABI\0"
	},
	{
		LANG_ROMANIAN,		"ROMANIAN\0"
	},
	{
		LANG_RUSSIAN,		"RUSSIAN\0"
	},
	{
		LANG_SANSKRIT,		"SANSKRIT\0"
	},
	{
		MAKELANGID(LANG_SERBIAN, SUBLANG_DEFAULT),			"SERBIAN\0"
															"LATIN\0"
															"CYRILLIC\0"
	},
	{
		LANG_SINDHI,		"SINDHI\0"
	},
	{
		LANG_SINHALESE,		"SINHALESE\0"
	},
	{
		LANG_SLOVAK,		"SLOVAK\0"
	},
	{
		LANG_SLOVENIAN,		"SLOVENIAN\0"
	},
	{
		MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH),			"SPANISH\0"
															"MEXICAN\0"
															"MODERN\0"
															"GUATEMALA\0"
															"COSTA_RICA\0"
															"PANAMA\0"
															"DOMINICAN_REPUBLIC\0"
															"VENEZUELA\0"
															"COLOMBIA\0"
															"PERU\0"
															"ARGENTINA\0"
															"ECUADOR\0"
															"CHILE\0"
															"URUGUAY\0"
															"PARAGUAY\0"
															"BOLIVIA\0"
															"EL_SALVADOR\0"
															"HONDURAS\0"
															"NICARAGUA\0"
															"PUERTO_RICO\0"
	},
	{
		LANG_SWAHILI,		"SWAHILI\0"
	},
	{
		MAKELANGID(LANG_SWEDISH, SUBLANG_SWEDISH),			"SWEDISH\0"
															"FINLAND\0"
	},
	{
		LANG_SYRIAC,		"SYRIAC\0"
	},
	{
		LANG_TAMIL,			"TAMIL\0"						"INDIA\0"
															"SRI_LANKA\0"
	},
	{
		LANG_TATAR,			"TATAR\0"
	},
	{
		LANG_TELUGU,		"TELUGU\0"
	},
	{
		LANG_THAI,			"THAI\0"
	},
	{
		LANG_TURKISH,		"TURKISH\0"
	},
	{
		LANG_UKRAINIAN,		"UKRAINIAN\0"
	},
	{
		LANG_URDU,			"URDU\0"						"PAKISTAN\0"
															"INDIA\0"
	},
	{
		LANG_UZBEK,			"UZBEK\0"						"LATIN\0"
															"CYRILLIC\0"
	},
	{
		LANG_VIETNAMESE,	"VIETNAMESE\0"
	},
};

/**
 * @brief Get a language ID for given language + sublanguage.
 * @param [in] lang Language name.
 * @param [in] sublang Sub language name.
 * @return Language ID.
 */
LANGID LangFileInfo::LangId(const char *lang, const char *sublang)
{
	// binary search the array for passed in lang
	size_t lower = 0;
	size_t upper = std::size(rg);
	while (lower < upper)
	{
		size_t match = (upper + lower) >> 1;
		int cmp = strcmp(rg[match].lang, lang);
		if (cmp >= 0)
			upper = match;
		if (cmp <= 0)
			lower = match + 1;
	}
	if (lower <= upper)
		return 0;
	LANGID baseid = rg[upper].id;
	// figure out sublang
	if ((baseid & ~0x3ff) && *sublang == '\0')
		return baseid;
	LANGID id = PRIMARYLANGID(baseid);
	if (0 == strcmp(sublang, "DEFAULT"))
		return MAKELANGID(id, SUBLANG_DEFAULT);
	const char *sub = rg[upper].lang;
	do
	{
		do
		{
			id += MAKELANGID(0, 1);
		} while (id == baseid);
		sub += strlen(sub) + 1;
		if (0 == strcmp(sublang, sub))
			return id;
	} while (*sub);
	return 0;
}

/**
 * @brief A constructor taking a path to language file as parameter.
 * @param [in] path Full path to the language file.
 */
LangFileInfo::LangFileInfo(const tchar_t* path)
: id(0)
{
	FILE *f;
	if (cio::tfopen_s(&f, path, _T("r,ccs=utf-8")) == 0 && f)
	{
		wchar_t buf[1024 + 1];
		while (fgetws(buf, static_cast<int>(std::size(buf)) - 1, f) != nullptr)
		{
			int i = 0;
			wcscat_s(buf, L"1");
			swscanf_s(buf, L"msgid \" LANG_ENGLISH , SUBLANG_ENGLISH_US \" %d", &i);
			if (i)
			{
				if (fgetws(buf, static_cast<int>(std::size(buf)), f) != nullptr)
				{
					wchar_t *lang = wcsstr(buf, L"LANG_");
					wchar_t *sublang = wcsstr(buf, L"SUBLANG_");
					wchar_t *langNext = nullptr;
					wchar_t *sublangNext = nullptr;
					if (lang && sublang)
					{
						wcstok_s(lang, L",\" \t\r\n", &langNext);
						wcstok_s(sublang, L",\" \t\r\n", &sublangNext);
						lang += std::size("LANG");
						sublang += std::size("SUBLANG");
						if (0 != wcscmp(sublang, L"DEFAULT"))
						{
							sublang = EatPrefix(sublang, lang);
							if (sublang && *sublang)
								sublang = EatPrefix(sublang, L"_");
						}
						if (sublang)
							id = LangId(ucr::toUTF8(lang).c_str(), ucr::toUTF8(sublang).c_str());
					}
				}
				break;
			}
		}
		fclose(f);
	}
}

String LangFileInfo::GetString(LCTYPE type) const
{
	String s;
	if (int cch = GetLocaleInfo(id, type, 0, 0))
	{
		s.resize(cch - 1);
		GetLocaleInfo(id, type, &*s.begin(), cch);
	}
	return s;
}

static HANDLE NTAPI FindFile(HANDLE h, const tchar_t* path, WIN32_FIND_DATA *fd)
{
	if (h == INVALID_HANDLE_VALUE)
	{
		h = FindFirstFile(path, fd);
	}
	else if (fd->dwFileAttributes == INVALID_FILE_ATTRIBUTES || !FindNextFile(h, fd))
	{
		FindClose(h);
		h = INVALID_HANDLE_VALUE;
	}
	return h;
}

/////////////////////////////////////////////////////////////////////////////
// CLanguageSelect dialog

/** @brief Default English language. */
const WORD wSourceLangId = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);

CLanguageSelect::CLanguageSelect()
: m_wCurLanguage(wSourceLangId)
{
	SetThreadLocale(MAKELCID(m_wCurLanguage, SORT_DEFAULT));
}

/**
 * @brief Remove prefix from the string.
 * @param [in] text String from which to jump over prefix.
 * @param [in] prefix Prefix string to jump over.
 * @return String without the prefix.
 * @note Function returns pointer to original string,
 *  it does not allocate a new string.
 */
static wchar_t *EatPrefix(wchar_t *text, const wchar_t *prefix)
{
	if (size_t len = wcslen(prefix))
		if (_memicmp(text, prefix, len * sizeof(wchar_t)) == 0)
			return text + len;
	return 0;
}

/**
 * @brief Convert C style \\nnn, \\r, \\n, \\t etc into their indicated characters.
 * @param [in,out] s String to convert.
 */
static void unslash(std::wstring &s)
{
	wchar_t *p = &*s.begin();
	wchar_t *q = p;
	wchar_t c = {};
	do
	{
		wchar_t *r = q + 1;
		switch (c = *q)
		{
		case '\\':
			switch (c = *r++)
			{
			case 'a':
				c = '\a';
				break;
			case 'b':
				c = '\b';
				break;
			case 'f':
				c = '\f';
				break;
			case 'n':
				c = '\n';
				break;
			case 'r':
				c = '\r';
				break;
			case 't':
				c = '\t';
				break;
			case 'v':
				c = '\v';
				break;
			case 'x':
				*p = (wchar_t)wcstol(r, &q, 16);
				break;
			default:
				*p = (wchar_t)wcstol(r - 1, &q, 8);
				break;
			}
			if (q >= r)
				break;
			[[fallthrough]];
		default:
			*p = c;
			q = r;
		}
		++p;
	} while (c != '\0');
	s.resize(p - 1 - &*s.begin());
}

/**
 * @brief Load language.file
 * @param [in] wLangId 
 * @return `true` on success, `false` otherwise.
 */
bool CLanguageSelect::LoadLanguageFile(LANGID wLangId, bool bShowError /*= false*/)
{
	String strPath = GetFileName(wLangId);
	if (strPath.empty())
		return false;

	wchar_t buf[1024];
	std::wstring *ps = nullptr;
	std::wstring msgctxt;
	std::wstring msgid;
	FILE *f;
	if (cio::tfopen_s(&f, strPath, _T("r,ccs=UTF-8")) != 0)
	{
		if (bShowError)
		{
			String str = _T("Failed to load ") + strPath;
			AfxMessageBox(str.c_str(), MB_ICONSTOP);
		}
		return false;
	}
	ps = nullptr;
	std::wstring format;
	std::wstring msgstr;
	std::wstring directive;
	auto addToMap = [&]() {
		ps = nullptr;
		if (!msgctxt.empty())
			unslash(msgctxt);
		if (!msgid.empty())
			unslash(msgid);
		if (msgstr.empty())
			msgstr = msgid;
		unslash(msgstr);
		if (!msgid.empty())
		{
			if (msgctxt.empty())
				m_map_msgid_to_msgstr.insert_or_assign(msgid, msgstr);
			else
				m_map_msgid_to_msgstr.insert_or_assign(L"\x01\"" + msgctxt + L"\"" + msgid, msgstr);
		}
		msgctxt.erase();
		msgid.erase();
		msgstr.erase();
	};
	while (fgetws(buf, static_cast<int>(std::size(buf)), f) != nullptr)
	{
		if (wchar_t *p1 = EatPrefix(buf, L"#,"))
		{
			format = p1;
			format.erase(0, format.find_first_not_of(L" \t\r\n"));
			format.erase(format.find_last_not_of(L" \t\r\n") + 1);
		}
		else if (wchar_t *p2 = EatPrefix(buf, L"#."))
		{
			directive = p2;
			directive.erase(0, directive.find_first_not_of(L" \t\r\n"));
			directive.erase(directive.find_last_not_of(L" \t\r\n") + 1);
		}
		else if (EatPrefix(buf, L"msgctxt "))
		{
			ps = &msgctxt;
		}
		else if (EatPrefix(buf, L"msgid "))
		{
			ps = &msgid;
		}
		else if (EatPrefix(buf, L"msgstr "))
		{
			ps = &msgstr;
		}
		if (ps != nullptr)
		{
			wchar_t *p = wcschr(buf, '"');
			wchar_t *q = wcsrchr(buf, '"');
			if (std::wstring::size_type n = q - p)
			{
				ps->append(p + 1, n - 1);
			}
			else
			{
				addToMap();
			}
		}
	}
	if (ps != nullptr)
		addToMap();
	fclose(f);
	return true;
}

/**
 * @brief Set UI language.
 * @param [in] wLangId 
 * @return `true` on success, `false` otherwise.
 */
bool CLanguageSelect::SetLanguage(LANGID wLangId, bool bShowError /*= false*/)
{
	if (wLangId == 0)
		return false;
	if (m_wCurLanguage == wLangId)
		return true;
	m_map_msgid_to_msgstr.clear();
	if (wLangId != wSourceLangId)
	{
		if (!LoadLanguageFile(wLangId, bShowError))
			wLangId = wSourceLangId;
	}
	m_wCurLanguage = wLangId;
	SetThreadLocale(MAKELCID(m_wCurLanguage, SORT_DEFAULT));
#ifdef _WIN64
	SetThreadUILanguage(wLangId);
#endif
	return true;
}

/**
 * @brief Get a language file for the specified language ID.
 * This function gets a language file name for the given language ID. Language
 * files are currently named as [languagename].po.
 * @param [in] wLangId Language ID.
 * @return Language filename, or empty string if no file for language found.
 */
String CLanguageSelect::GetFileName(LANGID wLangId) const
{
	String filename;
	String path = paths::ConcatPath(env::GetProgPath(), szRelativePath);
	String pattern = paths::ConcatPath(path, _T("*.po"));
	WIN32_FIND_DATA ff;
	HANDLE h = INVALID_HANDLE_VALUE;
	while ((h = FindFile(h, pattern.c_str(), &ff)) != INVALID_HANDLE_VALUE)
	{
		filename = paths::ConcatPath(path, ff.cFileName);
		LangFileInfo lfi(filename.c_str());
		if (lfi.id == wLangId)
			ff.dwFileAttributes = INVALID_FILE_ATTRIBUTES; // terminate loop
		else
			filename.erase();
	}
	return filename;
}

/////////////////////////////////////////////////////////////////////////////
// CLanguageSelect commands

bool CLanguageSelect::TranslateString(const std::wstring& msgid, std::wstring &s) const
{
	if (m_map_msgid_to_msgstr.find(msgid) != m_map_msgid_to_msgstr.end())
	{
		s = m_map_msgid_to_msgstr.at(msgid);
		return true;
	}
	if (msgid.length() > 2 && msgid[0] == '\x01' && msgid[1] == '"')
	{
		size_t pos = msgid.find('"', 2);
		if (pos != std::wstring::npos)
		{
			s = msgid.substr(pos + 1);
			return true;
		}
	}
	s = msgid;
	return false;
}

bool CLanguageSelect::TranslateString(const std::string& msgid, String& s) const
{
	bool result = TranslateString(std::wstring(msgid.begin(), msgid.end()), s);
	return result;
}

void CLanguageSelect::SetIndicators(CStatusBar &sb, const UINT *rgid, int n) const
{
	HGDIOBJ hf = (HGDIOBJ)sb.SendMessage(WM_GETFONT);
	CClientDC dc(nullptr);
	if (hf != nullptr)
		hf = dc.SelectObject(hf);
	if (n)
		sb.SetIndicators(0, n);
	else
		n = sb.m_nCount;
	int cx = ::GetSystemMetrics(SM_CXSCREEN) / 4;	// default to 1/4 the screen width
	UINT style = SBPS_STRETCH | SBPS_NOBORDERS;		// first pane is stretchy
	for (int i = 0 ; i < n ; ++i)
	{
		UINT id = rgid ? rgid[i] : sb.GetItemID(i);
		if (id >= ID_INDICATOR_EXT)
		{
			String text = LoadString(id);
			int cx1 = dc.GetTextExtent(text.c_str(), static_cast<int>(text.length())).cx;
			sb.SetPaneInfo(i, id, style | SBPS_DISABLED, cx1);
			sb.SetPaneText(i, text.c_str(), FALSE);
		}
		else if (rgid)
		{
			sb.SetPaneInfo(i, 0, style, cx);
		}
		style = 0;
	}
	if (hf != nullptr)
		dc.SelectObject(hf);
	// Send WM_SIZE to get pane rectangles right
	RECT rect;
	sb.GetClientRect(&rect);
	sb.SendMessage(WM_SIZE, 0, MAKELPARAM(rect.right, rect.bottom));
}

void CLanguageSelect::TranslateMenu(HMENU h) const
{
	BCMenu* pBCMenu = dynamic_cast<BCMenu*>(CMenu::FromHandle(h));
	int i = ::GetMenuItemCount(h);
	while (i > 0)
	{
		--i;
		MENUITEMINFO mii = {0};
#if(WINVER >= 0x0500)
		mii.cbSize = sizeof mii - sizeof HBITMAP;
#else
		mii.cbSize = sizeof mii;
#endif
		mii.fMask = MIIM_STATE|MIIM_ID|MIIM_SUBMENU|MIIM_DATA;
		::GetMenuItemInfo(h, i, TRUE, &mii);
		if (mii.hSubMenu)
		{
			TranslateMenu(mii.hSubMenu);
			mii.wID = static_cast<UINT>(reinterpret_cast<uintptr_t>(mii.hSubMenu));
		}
		BCMenuData *pItemData = reinterpret_cast<BCMenuData *>(mii.dwItemData);
		if (pItemData)
		{
			if (LPCWSTR text = pItemData->GetWideString())
			{
				std::wstring s;
				if (TranslateString(text, s))
					pItemData->SetWideString(s.c_str());
			}
		}
		wchar_t text[80];
		if (::GetMenuStringW(h, i, text, static_cast<int>(std::size(text)), MF_BYPOSITION))
		{
			std::wstring s;
			if (TranslateString(text, s))
			{
				if (pBCMenu && !pItemData)
					pBCMenu->SetMenuText(i, s.c_str(), MF_BYPOSITION);
				::ModifyMenuW(h, i, mii.fState | MF_BYPOSITION, mii.wID, s.c_str());
			}
		}
	}
}

void CLanguageSelect::TranslateDialog(HWND h) const
{
	UINT gw = GW_CHILD;
	do
	{
		wchar_t text[512];
		::GetWindowTextW(h, text, static_cast<int>(std::size(text)));
		std::wstring s;
		if (TranslateString(text, s))
			::SetWindowTextW(h, s.c_str());
		h = ::GetWindow(h, gw);
		gw = GW_HWNDNEXT;
	} while (h != nullptr);
}

void CLanguageSelect::RetranslateDialog(HWND h, const tchar_t *name) const
{
	typedef struct
	{
		WORD dlgVer;
		WORD signature;
		DWORD helpID;
		DWORD exStyle;
		DWORD style;
		WORD cDlgItems;
		short x;
		short y;
		short cx;
		short cy;
	} DLGTEMPLATEEX;

	typedef struct
	{
		DWORD helpID;
		DWORD exStyle;
		DWORD style;
		short x;
		short y;
		short cx;
		short cy;
		DWORD id;
	} DLGITEMTEMPLATEEX;

	auto loadDialogResource = [](HMODULE hModule, const tchar_t *name) -> DLGTEMPLATEEX *
	{
		if (HRSRC hFindRes = FindResource(hModule, name, RT_DIALOG))
		{
			if (HGLOBAL hLoadRes = LoadResource(hModule, hFindRes))
			{
				if (LPVOID q = LockResource(hLoadRes))
				{
					return reinterpret_cast<DLGTEMPLATEEX *>(q);
				}
			}
		}
		return nullptr;
	};

	auto skip = [](const WORD* &pw)
	{
		if (*pw == static_cast<WORD>(-1)) pw += 2; else { while (*pw++); };
	};

	auto findFirstDlgItem = [&skip](const DLGTEMPLATEEX *pTemplate) -> const DLGITEMTEMPLATEEX *
	{
		const WORD *pw = reinterpret_cast<const WORD *>(pTemplate) + 13;

		skip(pw); // Skip menu name string or ordinal
		skip(pw); // Skip class name string or ordinal
		while (*pw++);          // Skip caption string
		if (pTemplate->style & DS_SETFONT)
		{
			pw += 3;
			while (*pw++);
		}
		return reinterpret_cast<const DLGITEMTEMPLATEEX *>(
			reinterpret_cast<WORD*>((reinterpret_cast<DWORD_PTR>(pw) + 3) & ~DWORD_PTR(3))); // DWORD align
	};

	auto findNextDlgItem = [&skip](const DLGITEMTEMPLATEEX *pItem) -> const DLGITEMTEMPLATEEX * {
		const WORD *pw = reinterpret_cast<const WORD *>(pItem);
		pw += sizeof(DLGITEMTEMPLATEEX) / sizeof(WORD);

		skip(pw); // Skip class name string or ordinal
		skip(pw);  // Skip text string or ordinal

		WORD cbExtra = *reinterpret_cast<const WORD*>(pw);      // Skip extra data
		pw += 1 + cbExtra / sizeof(WORD);
		return reinterpret_cast<const DLGITEMTEMPLATEEX *>(
			reinterpret_cast<WORD*>((reinterpret_cast<DWORD_PTR>(pw) + 3) & ~DWORD_PTR(3))); // DWORD align
	};

	DLGTEMPLATEEX *pTemplate = nullptr;
	if ((pTemplate = loadDialogResource(AfxGetInstanceHandle(), name)) != nullptr)
	{
		HWND hWndChlid = ::GetWindow(h, GW_CHILD);
		const DLGITEMTEMPLATEEX *pItem = findFirstDlgItem(pTemplate);
		for (int nDlgItems = 0; nDlgItems < pTemplate->cDlgItems; ++nDlgItems)
		{
			const WORD *pw = reinterpret_cast<const WORD *>(pItem);
			pw += sizeof(DLGITEMTEMPLATEEX) / sizeof(WORD);
			skip(pw); // Skip class name string or ordinal

			if (*pw == static_cast<WORD>(-1))     // Skip text string or ordinal
				pw += 2;
			else
			{
				const wchar_t *p = reinterpret_cast<const wchar_t*>(pw);
				::SetWindowTextW(hWndChlid, p);
				while (*pw++);
			}

			hWndChlid = ::GetWindow(hWndChlid, GW_HWNDNEXT);
			pItem = findNextDlgItem(pItem);
		}
	}
	TranslateDialog(h);
}

String CLanguageSelect::LoadString(UINT id) const
{
	String s;
	if (id)
	{
		wchar_t text[1024];
		AfxLoadString(id, text, static_cast<unsigned>(std::size(text)));
		if (!TranslateString(text, s))
			s = text;
	}
	return s;
}

std::wstring CLanguageSelect::LoadDialogCaption(const tchar_t* lpDialogTemplateID) const
{
	std::wstring s;
	if (HINSTANCE hInst = AfxFindResourceHandle(lpDialogTemplateID, RT_DIALOG))
	{
		if (HRSRC hRsrc = FindResource(hInst, lpDialogTemplateID, RT_DIALOG))
		{
			if (LPCWSTR text = (LPCWSTR)LoadResource(hInst, hRsrc))
			{
				// Skip DLGTEMPLATE or DLGTEMPLATEEX
				text += text[1] == 0xFFFF ? 13 : 9;
				// Skip menu name string or ordinal
				if (*text == (const WCHAR)-1)
					text += 2; // WCHARs
				else
					while (*text++);
				// Skip class name string or ordinal
				if (*text == (const WCHAR)-1)
					text += 2; // WCHARs
				else
					while (*text++);
				// Caption string is ahead
				if (!TranslateString(text, s))
					s = text;
			}
		}
	}
	return s;
}

/**
 * @brief Load languages available on disk, and display in list, and select current
 */
std::vector<std::pair<LANGID, String> > CLanguageSelect::GetAvailableLanguages() const
{
	std::vector<std::pair<LANGID, String> > list;
	String path = paths::ConcatPath(env::GetProgPath(), szRelativePath);
	String pattern = paths::ConcatPath(path, _T("*.po"));
	WIN32_FIND_DATA ff;
	HANDLE h = INVALID_HANDLE_VALUE;
	do
	{
		LangFileInfo lfi(wSourceLangId);
		if (h != INVALID_HANDLE_VALUE)
			lfi = LangFileInfo(paths::ConcatPath(path, ff.cFileName).c_str());
		String str;
		str += lfi.GetString(LOCALE_SLANGUAGE);
		str += _T(" - ");
		str += lfi.GetString(LOCALE_SNATIVELANGNAME | LOCALE_USE_CP_ACP);
		str += _T(" (");
		str += lfi.GetString(LOCALE_SNATIVECTRYNAME | LOCALE_USE_CP_ACP);
		str += _T(")");
		str += _T(" - ");
		str += lfi.GetString(LOCALE_SENGLANGUAGE);
		str += _T(" (");
		str += lfi.GetString(LOCALE_SENGCOUNTRY);
		str += _T(")");
		list.emplace_back(lfi.id, str);
	} while ((h = FindFile(h, pattern.c_str(), &ff)) != INVALID_HANDLE_VALUE);
	return list;
}

/**
 * @brief Find DLL entry in lang_map for language for specified locale
 */
static WORD GetLangFromLocale(LCID lcid)
{
	tchar_t buff[8] = {0};
	WORD langID = 0;
	if (GetLocaleInfo(lcid, LOCALE_IDEFAULTLANGUAGE, buff, static_cast<int>(std::size(buff))))
		_stscanf_s(buff, _T("%4hx"), &langID);
	return langID;
}

void CLanguageSelect::InitializeLanguage(WORD langID)
{
	ASSERT(LangFileInfo::LangId("GERMAN", "") == MAKELANGID(LANG_GERMAN, SUBLANG_GERMAN));
	ASSERT(LangFileInfo::LangId("GERMAN", "DEFAULT") == MAKELANGID(LANG_GERMAN, SUBLANG_DEFAULT));
	ASSERT(LangFileInfo::LangId("GERMAN", "SWISS") == MAKELANGID(LANG_GERMAN, SUBLANG_GERMAN_SWISS));
	ASSERT(LangFileInfo::LangId("PORTUGUESE", "") == MAKELANGID(LANG_PORTUGUESE, SUBLANG_PORTUGUESE));
	ASSERT(LangFileInfo::LangId("NORWEGIAN", "BOKMAL") == MAKELANGID(LANG_NORWEGIAN, SUBLANG_NORWEGIAN_BOKMAL));
	ASSERT(LangFileInfo::LangId("NORWEGIAN", "NYNORSK") == MAKELANGID(LANG_NORWEGIAN, SUBLANG_NORWEGIAN_NYNORSK));

	//TRACE(_T("%hs\n"), LangFileInfo::FileName(MAKELANGID(LANG_NORWEGIAN, SUBLANG_NORWEGIAN_BOKMAL)).c_str());
	//TRACE(_T("%hs\n"), LangFileInfo::FileName(MAKELANGID(LANG_PORTUGUESE, SUBLANG_PORTUGUESE)).c_str());
	//TRACE(_T("%hs\n"), LangFileInfo::FileName(MAKELANGID(LANG_GERMAN, SUBLANG_DEFAULT)).c_str());

	if (langID)
	{
		// User has set a language override
		SetLanguage(langID);
		return;
	}
	// User has not specified a language
	// so look in thread locale, user locale, and then system locale for
	// a language that WinMerge supports
	WORD Lang1 = GetLangFromLocale(GetThreadLocale());
	if (SetLanguage(Lang1))
		return;
	WORD Lang2 = GetLangFromLocale(LOCALE_USER_DEFAULT);
	if (Lang2 != Lang1 && SetLanguage(Lang2))
		return;
	WORD Lang3 = GetLangFromLocale(LOCALE_SYSTEM_DEFAULT);
	if (Lang3 != Lang2 && Lang3 != Lang1 && SetLanguage(Lang3))
		return;
}
</file>

<file path="Winmerge-Src/Src/Common/LanguageSelect.h">
/** 
 * @file  LanguageSelect.h
 *
 * @brief Declaration file for CLanguageSelect dialog.
 */
#pragma once

#include <vector>
#include <string>
#include <map>
#include "UnicodeString.h"

/////////////////////////////////////////////////////////////////////////////
// CLanguageSelect class

class CStatusBar;

/**
 * @brief Class for selecting GUI language.
 *
 * Language select dialog shows list of installed GUI languages and
 * allows user to select one for use.
 */
class CLanguageSelect
{
// Construction
public:
	CLanguageSelect();   // standard constructor
	WORD GetLangId() const { return m_wCurLanguage; }
	String GetFileName(LANGID) const;
	void InitializeLanguage(WORD langID);

	bool TranslateString(const std::wstring&, std::wstring&) const;
	bool TranslateString(const std::string&, String&) const;
	void SetIndicators(CStatusBar &, const UINT *, int) const;
	void TranslateMenu(HMENU) const;
	void TranslateDialog(HWND) const;
	void RetranslateDialog(HWND, const tchar_t *name) const;
	String LoadString(UINT) const;
	std::wstring LoadDialogCaption(const tchar_t* lpDialogTemplateID) const;
	std::vector<std::pair<LANGID, String> > GetAvailableLanguages() const;
	bool SetLanguage(LANGID, bool bShowError = false);

// Implementation data
private:
	LANGID m_wCurLanguage;
	std::map<std::wstring, std::wstring> m_map_msgid_to_msgstr;
// Implementation methods
private:
	bool LoadLanguageFile(LANGID, bool bShowError = false);
};
</file>

<file path="Winmerge-Src/Src/Common/lwdisp.c">
/* File:	lwdisp.c - light weight dispatch API
 * Author:	Jochen Tucht 2003/01/09
 *			Copyright (C) 2003 herbert dahm datensysteme GmbH
 *
 * Purpose:	- Create windows scripting objects (scriptlets)
 *			- Invoke methods and access properties
 *			- Implement callback interfaces to be invoked by scriptlets
 *
 * Remarks:	requires Win32
 *			link with oleaut32, shlwapi 4.71
 *
 *			Features not supported by this API include:
 *			- type libraries
 *			- named arguments
 *
 * License:	THIS FILE CONTAINS FREE SOURCE CODE. IT IS PROVIDED *AS IS*, WITHOUT
 *			WARRANTY OF ANY KIND. YOU MAY USE IT AT YOUR OWN RISK, AS LONG AS
 *			YOU KEEP IT IN A SEPARATE FILE AND PRESERVE THIS COMMENT.
 *			CHANGES MUST BE RECORDED IN THE MODIFICATION HISTORY BELOW SO THERE
 *			IS EVIDENCE THAT THE FILE DIFFERS FROM EARLIER RELEASES. THE LEVEL
 *			OF DETAIL IS UP TO YOU. YOU MAY SET THE BY: ENTRY TO "NOBODY@ALL"
 *			IF YOU DON'T WANT TO EXPOSE YOUR NAME. SUBSEQUENT CHANGES MAY BE
 *			REFLECTED BY A SINGLE RECORD CARRYING THE DATE OF THE LATEST CHANGE.
 *

DATE:		BY:					DESCRIPTION:
==========	==================	================================================
2003/01/14	J.Tucht				provide a way to subclass the default LWDispVtbl
2003/03/16	J.Tucht				ensure BSTR arguments are writeable
2003/05/31	J.Tucht				registration of SCT and OCX no longer required
2003/08/05	J.Tucht				change some names for use with MFC
2003/08/31	J.Tucht				avoid wnsprintfW to get away with shlwapi < 5.0
2003/10/05	J.Tucht				allow calls from other threads through HWND
2003/11/04	J.Tucht				more explicit error messages, SEH
2003/11/06	NOBODY@ALL			incredible number of changes for unknown reasons
2003/11/18	Laoran				CreateDispatchBySource : avoid crash if loading dll fails
2003/11/18	Laoran				CreateDispatchBySource, cosmetic : move dll load&object creation after the CLSID search (= less indentations)
2004/01/08  Perry               Updated function comment preceding ReportError
2008/01/22  Kimmo               Changed map argument name to disp_map to not confuse VC6
*/

//#define _WIN32_IE		0x0300
//#define _WIN32_WINNT	0x0400	

#define NONAMELESSUNION		// avoid warning C4201
#define CINTERFACE			// tell gcc this is "C"

struct IShellView;			// avoid MSC warning C4115
struct _RPC_ASYNC_STATE;	// avoid MSC warning C4115

#pragma warning (push)			// prevent "warning C4091: 'typedef ': ignored on left of 'tagGPFIDL_FLAGS' when no variable is declared"
#pragma warning (disable:4091)	// VC bug when using XP enabled toolsets.
#include <shlobj.h>
#pragma warning (pop)
#include <shlwapi.h>
#include <tchar.h>
#include <stdarg.h>
#include <strsafe.h>
#include "lwdisp.h"

/**
* @brief Display or return error message string (from
number)
*
* @param style: if 0, return sysalloc'd string, else
msgbox
*
* Calls FormatMessage to get description of system string.
* If not found, makes a string containing raw number.
* If msgbox (style!=0), then function returns 0.
* If not msgbox (style==0), caller must LocalFree string.
*/
static LPTSTR NTAPI ReportError(HRESULT sc, UINT style)
{
	LPTCH pc = NULL;
	FormatMessage
	(
		FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
		NULL, sc,
		MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),
		(LPTCH)&pc, 0, NULL
	);
	if (pc == NULL)
	{
		FormatMessage
		(
			FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING |
			FORMAT_MESSAGE_ARGUMENT_ARRAY,
			_T("Error 0x%1!lX!"), 0,
			MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),
			(LPTCH)&pc, 0, (va_list *)&sc
		);
	}
	if (style)
	{
		MessageBox(0, pc, 0, style);
		LocalFree(pc);
		pc = NULL;
	}
	return pc;
}

/**
 * @brief build a formatted message string 
 */
static LPTSTR FormatMessageFromString(LPCTSTR format, ...)
{
	LPTCH pc = NULL;
	va_list list;
	va_start(list, format);
	FormatMessage
	(
		FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
		format, 0,
		MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),
		(LPTCH)&pc, 0, &list
	);
	va_end(list);
	return pc;
}

static void mycpyt2w(LPCTSTR tsz, wchar_t * wdest, size_t limit)
{
#ifdef _UNICODE
	StringCchCopyW(wdest, limit, tsz);
#else
	MultiByteToWideChar(CP_ACP, 0, tsz, -1, wdest, (int)limit);
	// always terminate the string
	wdest[limit-1] = 0;
#endif
}

#ifdef _WIN64
LPDISPATCH CreatDispatchBy32BitProxy(LPCTSTR source, LPCWSTR progid)
{
	CLSID clsid;
	VARIANT v[2], ret;
	void *pv = NULL;
	SCODE sc;
	wchar_t wpath[512];

	sc = CLSIDFromProgID(L"WinMerge32BitPluginProxy.Loader", &clsid);
	if (SUCCEEDED(sc))
		sc = CoCreateInstance(&clsid, 0, CLSCTX_LOCAL_SERVER|CLSCTX_ACTIVATE_32_BIT_SERVER, &IID_IDispatch, &pv);
	if (FAILED(sc))
	{
		LPTSTR errorText = ReportError(sc, 0);
		LPTSTR tmp;
		tmp = FormatMessageFromString(_T("Failed to load 32bit plugin(%1):%2\n")
			_T("WinMerge32BitPluginProxy.exe may not be registered.\n")
			_T("Try running the following in an elevated command prompt.\n\n")
			_T("\"{WinMerge installation path}\\WinMerge32BitPluginProxy.exe\" /RegServer"), source, errorText);
		LocalFree(errorText);
		errorText = tmp;
		MessageBox(NULL, errorText, NULL, MB_ICONSTOP|MB_TASKMODAL);
		LocalFree(errorText);
		return NULL;
	}
	VariantInit(&v[0]);
	VariantInit(&v[1]);
	VariantInit(&ret);
	V_VT(&v[1]) = VT_BSTR;
	mycpyt2w(source, wpath, DIMOF(wpath));
	V_BSTR(&v[1]) = SysAllocString(wpath);
	V_VT(&v[0]) = VT_BSTR;
	V_BSTR(&v[0]) = SysAllocString(progid);
	sc = invokeW(pv, &ret, L"Load", opFxn[2], v);
	if (SUCCEEDED(sc))
		pv = V_DISPATCH(&ret);
	VariantClear(&v[0]);
	VariantClear(&v[1]);
	return pv;
}
#endif

LPDISPATCH CreateDispatchBySourceAndCLSID(LPCTSTR source, CLSID *pObjectCLSID)
{
	LPDISPATCH pv = NULL;
	HMODULE hLibrary = LoadLibrary(source);
	if (hLibrary)
	{
		HRESULT (NTAPI*DllGetClassObject)(REFCLSID,REFIID,IClassFactory**)
			= (HRESULT(NTAPI*)(REFCLSID, REFIID, IClassFactory**))GetProcAddress(hLibrary, "DllGetClassObject");
		if (DllGetClassObject)
		{
			SCODE sc;
			IClassFactory *piClassFactory;
			if (SUCCEEDED(sc = DllGetClassObject(pObjectCLSID, &IID_IClassFactory, &piClassFactory)))
			{
				sc = piClassFactory->lpVtbl->CreateInstance(piClassFactory, 0, &IID_IDispatch, &pv);
				piClassFactory->lpVtbl->Release(piClassFactory);
			}
		}
		if (pv == NULL)
			FreeLibrary(hLibrary);
	}
	return pv;
}


/**
 * 
 * @Note We can use this code with unregistered COM DLL
 * For VC++ DLL, we need a custom CComTypeInfoHolder as the default one search the registry
 * For VB DLL, instance can not be shared across thread, one must be created for each thread
 *
 * Don't catch unknown errors in this function, because we want to catch
 * both C++ and C errors, and this is a C file.
 */
LPDISPATCH NTAPI CreateDispatchBySource(LPCTSTR source, LPCWSTR progid)
{
	void *pv = NULL;
	SCODE sc;
	WCHAR wc[320];
	if (source == NULL)
	{
		CLSID clsid;
		if (SUCCEEDED(sc=CLSIDFromProgID(progid, &clsid)))
		{
			sc=CoCreateInstance(&clsid, 0, CLSCTX_ALL, &IID_IDispatch, &pv);
		}
	}
	else if (PathMatchSpec(source, _T("*.ocx")) || PathMatchSpec(source, _T("*.dll")))
	{
		CLSID objectGUID = {0};
		BOOL bGUIDFound = FALSE;

		// search in the interface of the dll for the CLSID of progid
		ITypeLib *piTypeLib;
		mycpyt2w(source, wc, DIMOF(wc));
		if (SUCCEEDED(sc=LoadTypeLib(wc, &piTypeLib)))
		{
			UINT count = piTypeLib->lpVtbl->GetTypeInfoCount(piTypeLib);
			while (SUCCEEDED(sc) && !bGUIDFound && count--)
			{
				ITypeInfo *piTypeInfo;
				if (SUCCEEDED(sc=piTypeLib->lpVtbl->GetTypeInfo(piTypeLib, count, &piTypeInfo)))
				{
					TYPEATTR *pTypeAttr;
					if (SUCCEEDED(sc=piTypeInfo->lpVtbl->GetTypeAttr(piTypeInfo, &pTypeAttr)))
					{
						BSTR bstrName = 0;
						if (SUCCEEDED(sc=piTypeInfo->lpVtbl->GetDocumentation(piTypeInfo, MEMBERID_NIL, &bstrName, 0, 0, 0)))
						{
							if (pTypeAttr->typekind == TKIND_COCLASS && StrCmpIW(bstrName, progid) == 0)
							{
								memcpy(&objectGUID, &pTypeAttr->guid, sizeof(CLSID));
								bGUIDFound = TRUE;
							}
							SysFreeString(bstrName);
						}
						piTypeInfo->lpVtbl->ReleaseTypeAttr(piTypeInfo, pTypeAttr);
					}
					piTypeInfo->lpVtbl->Release(piTypeInfo);
				}
			}
			piTypeLib->lpVtbl->Release(piTypeLib);
		}
	
		if (bGUIDFound)
		{
			// we have found the CLSID, so this is really a COM dll for WinMerge
			// now try to load the dll and to create an instance of the object
#ifdef _WIN64
			{
			HMODULE hLibrary = LoadLibrary(source);
			if (hLibrary == NULL)
			{
				// assume 32bit DLL if failed to load DLL
				pv = CreatDispatchBy32BitProxy(source, progid);
			}
			else
			{
				pv = CreateDispatchBySourceAndCLSID(source, &objectGUID);
				FreeLibrary(hLibrary);
			}
			}
#else
			pv = CreateDispatchBySourceAndCLSID(source, &objectGUID);
#endif
		}
		// don't display an error message if no interface (normal dll)
		if (PathMatchSpec(source, _T("*.dll")) && sc == TYPE_E_CANTLOADLIBRARY)
			sc = 0;
		// don't display an error message if the format is too old
		if (sc == TYPE_E_UNSUPFORMAT)
			sc = 0;
	}
	else 
	{
		BIND_OPTS bind_opts;
		// initialize to official defaults:
		bind_opts.cbStruct = sizeof bind_opts;
		bind_opts.grfFlags = 0;
		bind_opts.grfMode = STGM_READWRITE;
		bind_opts.dwTickCountDeadline = 0;
		// prepend appropriate moniker:
		if (PathMatchSpec(source, _T("*.sct")) 
			|| PathMatchSpec(source, _T("*.wsc")))
			mycpyt2w(_T("script:"), wc, DIMOF(wc));
		else
			mycpyt2w(_T(""), wc, DIMOF(wc));
		size_t len = wcslen(wc);
		mycpyt2w(source, wc + len, DIMOF(wc) - len);

		// I observed that CoGetObject() may internally provoke an access
		// violation and succeed anyway. No idea how to avoid this.
		sc=CoGetObject(wc, &bind_opts, &IID_IDispatch, &pv);
		if (sc == E_NOINTERFACE)
		{
			// give it a second try after opening within associated application:
			SHELLEXECUTEINFO sein;
			sein.cbSize = sizeof sein;
			sein.hwnd = NULL;
			// SEE_MASK_FLAG_DDEWAIT: wait until application is ready to listen
			sein.fMask = SEE_MASK_FLAG_DDEWAIT;
			sein.lpVerb = _T("open");
			sein.lpFile = source;
			sein.lpParameters = NULL;
			sein.lpDirectory = _T(".");
			sein.nShow = SW_SHOWNORMAL;
			if (ShellExecuteEx(&sein))
			{
				sc=CoGetObject(wc, &bind_opts, &IID_IDispatch, &pv);
			}
		}
		// no error if the interface does not exist
		if (sc == MK_E_INTERMEDIATEINTERFACENOTSUPPORTED || sc == E_UNEXPECTED)
			sc = 0;
	}
	if (FAILED(sc))
	{
		// get the error description
		LPTSTR errorText = ReportError(sc, 0);
		if (source)
		{
			// append the source name
			LPTSTR tmp;
			tmp = FormatMessageFromString(_T("%1\n%2"), errorText, source);
			LocalFree(errorText);
			errorText = tmp;
		}
		// report error
		MessageBox(0, errorText, 0, MB_ICONSTOP|MB_TASKMODAL);
		LocalFree(errorText);
		// no valid dispatch
		pv = NULL;
	}
	return (LPDISPATCH)pv;
}

static BOOL NeedsConversion(LPDISPATCH pi, DISPID id, VARIANT *argv, int cArgs)
{
	BOOL bParamByRef = FALSE;
	BOOL bNeedToConv = FALSE;
	int i;

	for (i = 0; i < cArgs; i++)
	{
		if (V_ISBYREF(&argv[i]))
		{
			bParamByRef = TRUE;
			break;
		}
	}
	if (bParamByRef)
	{
		ITypeInfo* pTypeInfo;
		HRESULT hr;

		hr = pi->lpVtbl->GetTypeInfo(pi, 0, 0, &pTypeInfo);
		if (SUCCEEDED(hr))
		{
			FUNCDESC* pFuncDesc = NULL;
			ITypeInfo2* pTypeInfo2 = NULL;
			pTypeInfo->lpVtbl->QueryInterface(pTypeInfo, &IID_ITypeInfo2, &pTypeInfo2);
			if (pTypeInfo2 != NULL)
			{
				UINT nIndex;
				hr = pTypeInfo2->lpVtbl->GetFuncIndexOfMemId(pTypeInfo2, id, INVOKE_FUNC, &nIndex);
				if (SUCCEEDED(hr))
				{
					hr = pTypeInfo->lpVtbl->GetFuncDesc(pTypeInfo, nIndex, &pFuncDesc);
					if (SUCCEEDED(hr))
					{
						if (pFuncDesc->oVft == 0)
							bNeedToConv = TRUE;
						pTypeInfo->lpVtbl->ReleaseFuncDesc(pTypeInfo, pFuncDesc);
					}
				}
				pTypeInfo2->lpVtbl->Release(pTypeInfo2);
			}
			pTypeInfo->lpVtbl->Release(pTypeInfo);
		}
	}
	return bNeedToConv;
}

static void MoveVariantValue(VARIANT* dst, VARIANT* src)
{
	if ((V_VT(dst) & ~VT_BYREF) == VT_BSTR && V_VT(src) == VT_BSTR)
	{
		SysFreeString(*V_BSTRREF(dst));
		*V_BSTRREF(dst) = V_BSTR(src);
		V_VT(src) = VT_EMPTY;
		return;
	}
	VARIANT varTemp;
	VariantInit(&varTemp);
	VariantChangeType(&varTemp, src, 0, (unsigned short)(V_VT(dst) & ~VT_BYREF));
	switch (V_VT(dst) & ~VT_BYREF) {
	case VT_BOOL:
		*V_BOOLREF(dst) = V_BOOL(&varTemp);
		break;
	case VT_I1:
		*V_I2REF(dst) = V_I1(&varTemp);
		break;
	case VT_I2:
		*V_I2REF(dst) = V_I2(&varTemp);
		break;
	case VT_I4:
		*V_I4REF(dst) = V_I4(&varTemp);
		break;
	case VT_R4:
		*V_R4REF(dst) = V_R4(&varTemp);
		break;
	case VT_R8:
		*V_R8REF(dst) = V_R8(&varTemp);
		break;
	case VT_BSTR:
		SysFreeString(*V_BSTRREF(dst));
		*V_BSTRREF(dst) = V_BSTR(&varTemp);
		V_VT(&varTemp) = VT_EMPTY;
		break;
	}
	VariantClear(&varTemp);
}

STDAPI invokeV(LPDISPATCH pi, VARIANT *ret, DISPID id, LPCCH op, VARIANT *argv)
{
	HRESULT sc = E_FAIL;
	DISPID idNamed = DISPID_PROPERTYPUT;
	WORD wFlags = HIBYTE((UINT_PTR)op);
	DISPPARAMS dispparams;
	UINT nArgErr = (UINT)-1;
	EXCEPINFO excepInfo = {0};
	dispparams.cArgs = LOBYTE((UINT_PTR)op);
	dispparams.cNamedArgs = 0;
	dispparams.rgvarg = argv;
	if (wFlags & (DISPATCH_PROPERTYPUT|DISPATCH_PROPERTYPUTREF))
	{
		dispparams.cNamedArgs = 1;
		dispparams.rgdispidNamedArgs = &idNamed;
	}
	if (pi != NULL)
	{
		VARIANT varParams[12] = { 0 };
		VARIANT varData[12] = { 0 };
		BOOL bNeedToConv = NeedsConversion(pi, id, argv, dispparams.cArgs);
		int i;
		if (bNeedToConv)
		{
			for (i = 0; i < (int)dispparams.cArgs; i++)
			{
				VariantInit(&varData[i]);
				VariantCopyInd(&varData[i], &argv[i]);
				V_VARIANTREF(&varParams[i]) = &varData[i];
				V_VT(&varParams[i]) = VT_VARIANT | VT_BYREF;
			}
			dispparams.rgvarg = varParams;
		}
		else
		{
			dispparams.rgvarg = argv;
		}

		sc = pi->lpVtbl->Invoke(pi, id, &IID_NULL, 0, wFlags, &dispparams,
			ret, &excepInfo, &nArgErr);
		if (FAILED(sc))
		{
			if (excepInfo.pfnDeferredFillIn)
			{
				excepInfo.pfnDeferredFillIn(&excepInfo);
			}
			if (excepInfo.bstrDescription)
			{
				MessageBoxW(0, excepInfo.bstrDescription, excepInfo.bstrSource, MB_ICONSTOP|MB_TASKMODAL);
			}
			else
			{
				ReportError(excepInfo.scode == 0 ? sc : excepInfo.scode, MB_ICONSTOP|MB_TASKMODAL);
			}
			SysFreeString(excepInfo.bstrDescription);
			SysFreeString(excepInfo.bstrSource);
			SysFreeString(excepInfo.bstrHelpFile);
		}
		else
		{
			if (bNeedToConv)
			{
				if (V_VT(ret) == (VT_ARRAY | VT_VARIANT))
				{
					long ubound = 0;
					SafeArrayGetUBound(V_ARRAY(ret), 1, &ubound);
					VARIANT* p = NULL;
					int j = ubound;
					SafeArrayAccessData(V_ARRAY(ret), (void**)(&p));
					for (i = 0; i < (int)dispparams.cArgs; i++)
					{
						if (V_ISBYREF(&argv[i]) && j > 0)
							MoveVariantValue(&argv[i], &p[j--]);
						VariantClear(&varParams[i]);
						VariantClear(&varData[i]);
					}
					VARIANT_BOOL bResult = V_BOOL(&p[0]);
					VariantClear(ret);
					V_BOOL(ret) = bResult;
					V_VT(ret) = VT_BOOL;
				}
				else
				{
					for (i = 0; i < (int)dispparams.cArgs; i++)
					{
						if (V_ISBYREF(&argv[i]))
							MoveVariantValue(&argv[i], &varData[i]);
						VariantClear(&varParams[i]);
					}
				}
			}
		}
	}
	while (dispparams.cArgs--)
	{
		VariantClear(dispparams.rgvarg++);
	}
	return sc;
}

HRESULT invokeA(LPDISPATCH pi, VARIANT *ret, DISPID id, LPCCH op, VARIANT *argv)
{
	return invokeV(pi, ret, id, op, argv);
}
HRESULT invokeW(LPDISPATCH pi, VARIANT *ret, LPCOLESTR silent, LPCCH op, VARIANT *argv)
{
	DISPID id = DISPID_UNKNOWN;
	LPOLESTR  name = (LPOLESTR )((UINT_PTR)silent & ~1);
	if (pi != NULL)
	{
		HRESULT sc = pi->lpVtbl->GetIDsOfNames(pi, &IID_NULL, &name, 1, 0, &id);
		if (FAILED(sc))
		{
			if (!((UINT_PTR)silent & 1))
			{
				ReportError(sc, MB_ICONSTOP);
			}
			pi = NULL;
		}
	}
	return invokeV(pi, ret, id, op, argv);
}

STDAPI ValidateArgs(VARIANT *argv, UINT argc, LPCCH pvt)
{
	VARTYPE vt;
	while ((vt = (BYTE)*pvt++) != 0)
	{
		if (argc == 0)
			return DISP_E_BADPARAMCOUNT;
		if (vt == VT_VARIANT)
		{
			VARIANT *ref = argv;
			while (V_VT(ref) == VT_VARIANT + VT_BYREF)
			{
				ref = V_VARIANTREF(ref);
			}
			vt = V_VT(ref);
		}
		if (vt != VT_VARIANT)
		{
			if (V_VT(argv) != vt)
			{
				HRESULT sc = VariantChangeType(argv, argv, 0, vt);
				if (FAILED(sc))
					return sc;
			}
			else if (vt == VT_BSTR)
			{
				// Const strings passed in from Compiled VB may reside in r/o
				// memory. Since B2A() expects BSTR arguments to be writeable,
				// the following code copies short strings to writeable memory.
				// Long strings are assumed to be writeable anyway since they
				// are normally a result of some non-const expression.
				// This is a tradeoff between efficiency and safety.
				// A const string longer than 260 OLECHARs (520 bytes) will
				// provoke an access violation in B2A().
				char buffer[520];
				buffer[0] = '\0';
				UINT length =  SysStringByteLen V_BSTR(argv);
				if (length <= sizeof buffer)
				{
					CopyMemory(buffer, V_BSTR(argv), length);
					SysFreeString V_BSTR(argv);
					V_BSTR(argv) = SysAllocStringByteLen(buffer, length);
				}
			}
		}
		--argc;
		++argv;
	}
	return argc ? DISP_E_BADPARAMCOUNT : S_OK;
}

/** 
 * @brief BSTR to PCH (ANSI) conversion
 * It needs BSTR to be wide (always the case in Windows) 
 *
 * @note THIS METHOD IS BUGGY : IT IS NOT CORRECT TO PUT A CHAR STRING IN A WCHAR BUFFER
 * IN FACT IN PLACE TRANSFORMATION OF WCHAR TO CHAR IS NOT CORRECT
 * the content of bcVal is changed
 */
/*
PCH NTAPI B2A(BSTR bcVal)
{
	static const char empty[] = {0};
	PCH pcVal = (PCH)empty;
	if (bcVal)
	{
		pcVal = ((PCH)bcVal) + 1;
		if (*(PCH)bcVal)
		{
			int cch = lstrlenW(bcVal) + 1;
			WideCharToMultiByte(CP_ACP, 0, bcVal, cch, pcVal, cch, 0, 0);
			// this is buggy : we need to set *bcVal = 0 (so we use pcVal = ((PCH)bcVal) + 2)
			*(PCH)bcVal = 0;
		}
	}
	return pcVal;
}
*/

// FIX B2A BEFORE UNCOMMENTING THIS ONE
/*
LPCTSTR NTAPI B2T(BSTR bcVal)
{
#ifdef _UNICODE
	return bcVal;
#else
	return B2A(bcVal);
#endif
}
*/

STDAPI LWDefProc(PVOID UNUSED_ARG(target), HRESULT UNUSED_ARG(sc),
	VARIANT *UNUSED_ARG(ret), VARIANT *UNUSED_ARG(argv), UINT UNUSED_ARG(argc),
	EXCEPINFO *UNUSED_ARG(e))
{
	return DISP_E_MEMBERNOTFOUND;
}

struct LWDispMap
{
	LWDispFxn pfnProc;
	int count;
	struct LWDispRef ref[1];
};

static STDMETHODIMP QueryInterface(struct LWDispatch *This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void **ppvObject)
{
	if (IsEqualIID(riid, &IID_IUnknown) || IsEqualIID(riid, &IID_IDispatch))
	{
		This -> lpVtbl -> AddRef(This);
		*ppvObject = This;
		return S_OK;
	}
	return E_NOINTERFACE;
}
        
static ULONG STDMETHODCALLTYPE AddRef(struct LWDispatch *This)
{
	return ++This->refc;
}        

static ULONG STDMETHODCALLTYPE Release(struct LWDispatch *This)
{
	ULONG Release = --This->refc;
	if (Release == 0)
	{
		free(This);
	}
	return Release;
}

static STDMETHODIMP GetTypeInfoCount(struct LWDispatch *UNUSED_ARG(This),
					/* [out] */ UINT *UNUSED_ARG(pctinfo))
{
	return E_NOTIMPL;
}

static STDMETHODIMP GetTypeInfo(struct LWDispatch *UNUSED_ARG(This),
					/* [in] */ UINT UNUSED_ARG(iTInfo),
					/* [in] */ LCID UNUSED_ARG(lcid),
					/* [out] */ ITypeInfo **UNUSED_ARG(ppTInfo))
{
	return E_NOTIMPL;
}

static STDMETHODIMP GetIDsOfNames(struct LWDispatch *This,
					/* [in] */ REFIID UNUSED_ARG(riid),
					/* [size_is][in] */ LPOLESTR *rgszNames,
					/* [in] */ UINT UNUSED_ARG(cNames),
					/* [in] */ LCID UNUSED_ARG(lcid),
					/* [size_is][out] */ DISPID *rgDispId)
{
	DISPID dispIdMember = 0;
	for ( ; dispIdMember < This->map->count ; ++dispIdMember)
	{
		if (StrCmpIW(This->map->ref[dispIdMember].pwcName, rgszNames[0]) == 0)
		{
			*rgDispId = dispIdMember;
			return S_OK;
		}
	}
	return DISP_E_MEMBERNOTFOUND;
}

static STDMETHODIMP Invoke(struct LWDispatch *This,
					/* [in] */ DISPID dispIdMember,
					/* [in] */ REFIID UNUSED_ARG(riid),
					/* [in] */ LCID UNUSED_ARG(lcid),
					/* [in] */ WORD wFlags,
					/* [out][in] */ DISPPARAMS *pDispParams,
					/* [out] */ VARIANT *pVarResult,
					/* [out] */ EXCEPINFO *pExcepInfo,
					/* [out] */ UINT *UNUSED_ARG(puArgErr))
{
	// provide a dummy result variable if pVarResult == 0
	VARIANT varEmpty;
	HRESULT sc = dispIdMember < 0 ? dispIdMember : (HRESULT)wFlags;
	if (pDispParams->cNamedArgs >
		((wFlags & (DISPATCH_PROPERTYPUT|DISPATCH_PROPERTYPUTREF)) ? 1U : 0U))
		return DISP_E_NONAMEDARGS;
	VariantInit(&varEmpty);
	sc =
	(
		dispIdMember < 0 ? This->map->pfnProc :
		dispIdMember < This->map->count ? This->map->ref[dispIdMember].pfnProc :
		LWDefProc
	)
	(
		This->target, sc,
		pVarResult ? pVarResult : &varEmpty,
		pDispParams->rgvarg, pDispParams->cArgs,
		pExcepInfo
	);
	VariantClear(&varEmpty);
	return sc;
}

static const struct LWDispVtbl vtbl =
{
	QueryInterface,
	AddRef,
	Release,
	GetTypeInfoCount,
	GetTypeInfo,
	GetIDsOfNames,
	Invoke
};

const struct LWDispVtbl *NTAPI LWDispSubclass(struct LWDispVtbl *lpVtbl)
{
	*lpVtbl = vtbl;
	return &vtbl;
}

IDispatch *NTAPI LWDispatch(void *target, const void *disp_map,
	const struct LWDispVtbl *lpVtbl, struct LWDispatch *This)
{
	if (lpVtbl == NULL)
		lpVtbl = &vtbl;
	if (This == NULL)
		This = (struct LWDispatch *)malloc(sizeof(*This));
	if (This)
	{
		This->lpVtbl = lpVtbl;
		This->target = target;
		This->map = (const struct LWDispMap *)disp_map;
		This->refc = 0;
	}
	return (IDispatch *)This;
}

VARIANT NTAPI LWArg(LPDISPATCH pdispVal)
{
	VARIANT v;
	VariantInit(&v);
	if (pdispVal) (V_VAR(&v,DISPATCH) = pdispVal) -> lpVtbl -> AddRef(pdispVal);
	return v;
}

VARIANT NTAPI LWArgW(LPCWSTR wcVal)
{
	VARIANT v;
	VariantInit(&v);
	V_VAR(&v,BSTR) = SysAllocString(wcVal);
	return v;
}

VARIANT NTAPI LWArgA(LPCSTR cVal)
{
	UINT len = lstrlenA(cVal);
	VARIANT v;
	VariantInit(&v);
	V_VAR(&v,BSTR) = SysAllocStringLen(NULL, len);
	MultiByteToWideChar(CP_ACP, 0, cVal, -1, V_BSTR(&v), len);
	return v;
}

VARIANT NTAPI LWArgV(UINT vt, ...)
{
	VARIANT v;
	va_list list;
	VariantInit(&v);
	va_start(list, vt);
	V_VT(&v) = (VARTYPE)(vt & 0xF0FF);
	CopyMemory(&V_NONE(&v), va_arg(list, void *), (vt & 0x0F00) >> 8);
	va_end(list);
	return v;
}
</file>

<file path="Winmerge-Src/Src/Common/lwdisp.h">
/* File:	lwdisp.h - light weight dispatch API
 * Author:	Jochen Tucht 2003/01/09
 *			Copyright (C) 2003 herbert dahm datensysteme GmbH
 *
 * Declaration file for lwdisp.c
 *
 * Purpose:	- Create windows scripting objects (scriptlets)
 *			- Invoke methods and access properties
 *			- Implement callback interfaces to be invoked by scriptlets
 *
 * License:	THIS FILE CONTAINS FREE SOURCE CODE. IT IS PROVIDED *AS IS*, WITHOUT
 *			WARRANTY OF ANY KIND. YOU MAY USE IT AT YOUR OWN RISK, AS LONG AS
 *			YOU KEEP IT IN A SEPARATE FILE AND PRESERVE THIS COMMENT.
 *			CHANGES MUST BE RECORDED IN THE MODIFICATION HISTORY BELOW SO THERE
 *			IS EVIDENCE THAT THE FILE DIFFERS FROM EARLIER RELEASES. THE LEVEL
 *			OF DETAIL IS UP TO YOU. YOU MAY SET THE BY: ENTRY TO "NOBODY@ALL"
 *			IF YOU DON'T WANT TO EXPOSE YOUR NAME. SUBSEQUENT CHANGES MAY BE
 *			REFLECTED BY A SINGLE RECORD CARRYING THE DATE OF THE LATEST CHANGE.
 *

DATE:		BY:					DESCRIPTION:
==========	==================	================================================
2003/11/28	Laoran 				      header and RCS ID
*/
#pragma once

#ifdef __cplusplus
extern "C"{
#endif 

#ifdef _MSC_VER
#define UNUSED_ARG(ARG) ARG
#elif defined(__GNUC__)
#define UNUSED_ARG(ARG) ARG
#else
#define UNUSED_ARG(ARG)
#endif

// macros for use with ValidateArgs()

// parameter types: by value VTs
#define VTS_I2              "\x02"      // a 'short'
#define VTS_I4              "\x03"      // a 'long'
#define VTS_R4              "\x04"      // a 'float'
#define VTS_R8              "\x05"      // a 'double'
#define VTS_CY              "\x06"      // a 'CY' or 'CY*'
#define VTS_DATE            "\x07"      // a 'DATE'
#define VTS_WBSTR           "\x08"      // an 'LPCOLESTR'
#define VTS_DISPATCH        "\x09"      // an 'IDispatch*'
#define VTS_SCODE           "\x0A"      // an 'SCODE'
#define VTS_BOOL            "\x0B"      // a 'BOOL'
#define VTS_VARIANT         "\x0C"      // a 'const VARIANT&' or 'VARIANT*'
#define VTS_UNKNOWN         "\x0D"      // an 'IUnknown*'
#if defined(_UNICODE) || defined(OLE2ANSI)
	#define VTS_BSTR            VTS_WBSTR// an 'LPCOLESTR'
	#define VT_BSTRT            VT_BSTR
#else
	#define VTS_BSTR            "\x0E"  // an 'LPCSTR'
	#define VT_BSTRA            14
	#define VT_BSTRT            VT_BSTRA
#endif
#ifndef VTS_UI1
#define VTS_UI1             "\x0F"      // a 'BYTE'
#endif

// parameter types: by reference VTs
#define VTS_PI2             "\x42"      // a 'short*'
#define VTS_PI4             "\x43"      // a 'long*'
#define VTS_PR4             "\x44"      // a 'float*'
#define VTS_PR8             "\x45"      // a 'double*'
#define VTS_PCY             "\x46"      // a 'CY*'
#define VTS_PDATE           "\x47"      // a 'DATE*'
#define VTS_PBSTR           "\x48"      // a 'BSTR*'
#define VTS_PDISPATCH       "\x49"      // an 'IDispatch**'
#define VTS_PSCODE          "\x4A"      // an 'SCODE*'
#define VTS_PBOOL           "\x4B"      // a 'VARIANT_BOOL*'
#define VTS_PVARIANT        "\x4C"      // a 'VARIANT*'
#define VTS_PUNKNOWN        "\x4D"      // an 'IUnknown**'

// special VT_ and VTS_ values
#define VTS_NONE            NULL        // used for members with 0 params

// macros for use with wsprintfA(), wsprintfW()

#ifdef _UNICODE
#define WVA_TSTR L"%s"
#define AVA_TSTR "%S"
#define TVA_BSTR L"%s"
#else
#define WVA_TSTR L"%S"
#define AVA_TSTR "%s"
#define TVA_BSTR "%S"
#endif

// misc. macros

#define DIMOF(a) (sizeof(a)/sizeof(*a))


/**
 * @param source : if 0, create an object of the class registered as *progid*
 * @param progid : if 0, create an object from file *source*
 * If both source and progid defined, ask *source* to create an object of class *progid*
 */
LPDISPATCH NTAPI CreateDispatchBySource(LPCTSTR source, LPCWSTR progid);

/**
 * @brief invoke helper (__stdcall)
 *
 * @note Free all variants passed to it (except ByRef ones) 
 */
STDAPI invokeV(LPDISPATCH, VARIANT *, DISPID, LPCCH, VARIANT *);
/**
 * @brief invoke helper (by ordinal)
 *
 * @note Free all variants passed to it (except ByRef ones) 
 */
STDAPIV invokeA(LPDISPATCH, VARIANT *, DISPID, LPCCH, VARIANT *);
/**
 * @brief invoke helper (by function name)
 *
 * @note Free all variants passed to it (except ByRef ones) 
 */
STDAPIV invokeW(LPDISPATCH, VARIANT *, LPCOLESTR, LPCCH, VARIANT *);

// macros for use with invoke*()
#define opFxn &((PCH)(DISPATCH_METHOD<<8))
#define opPut &((PCH)(DISPATCH_PROPERTYPUT<<8))
#define opGet &((PCH)(DISPATCH_PROPERTYGET<<8))
#define opSet &((PCH)(DISPATCH_PROPERTYPUTREF<<8))

// ::invokeW(piDispatch, LODD(Foo), ...) will fail silently if the interface
// lacks the requested method or property
#define LODD(NAME) ((BSTR)((PCH)L###NAME+1))

// convert given arguments to requested types
STDAPI ValidateArgs(VARIANT *argv, UINT argc, LPCCH pvt);

// in place conversion of BSTR to LPCCH
// IN PLACE TRANSFORMATION OF WCHAR TO CHAR IS NOT CORRECT
/*
PCH NTAPI B2A(BSTR);
LPCTSTR NTAPI B2T(BSTR);
*/

// callback interface related declarations

typedef HRESULT(NTAPI*LWDispFxn)
		(PVOID, HRESULT, VARIANT *, VARIANT *, UINT, EXCEPINFO *);

STDAPI	LWDefProc
		(PVOID, HRESULT, VARIANT *, VARIANT *, UINT, EXCEPINFO *);

struct LWDispRef
{
	LPCWSTR pwcName;
	LWDispFxn pfnProc;
};

struct LWDispatch;

struct LWDispVtbl
{
	HRESULT(STDMETHODCALLTYPE*QueryInterface)( 
		struct LWDispatch *This,
		/* [in] */ REFIID riid,
		/* [iid_is][out] */ void **ppvObject);
	ULONG(STDMETHODCALLTYPE*AddRef)(struct LWDispatch *This);
	ULONG(STDMETHODCALLTYPE*Release)(struct LWDispatch *This);
	HRESULT(STDMETHODCALLTYPE*GetTypeInfoCount)( 
		struct LWDispatch *This,
		/* [out] */ UINT *pctinfo);
	HRESULT(STDMETHODCALLTYPE*GetTypeInfo)( 
		struct LWDispatch *This,
		/* [in] */ UINT iTInfo,
		/* [in] */ LCID lcid,
		/* [out] */ ITypeInfo **ppTInfo);
	HRESULT(STDMETHODCALLTYPE*GetIDsOfNames)( 
		struct LWDispatch *This,
		/* [in] */ REFIID riid,
		/* [size_is][in] */ LPOLESTR *rgszNames,
		/* [in] */ UINT cNames,
		/* [in] */ LCID lcid,
		/* [size_is][out] */ DISPID *rgDispId);
	HRESULT(STDMETHODCALLTYPE*Invoke)( 
		struct LWDispatch *This,
		/* [in] */ DISPID dispIdMember,
		/* [in] */ REFIID riid,
		/* [in] */ LCID lcid,
		/* [in] */ WORD wFlags,
		/* [out][in] */ DISPPARAMS *pDispParams,
		/* [out] */ VARIANT *pVarResult,
		/* [out] */ EXCEPINFO *pExcepInfo,
		/* [out] */ UINT *puArgErr);
};

struct LWDispatch
{
	const struct LWDispVtbl *lpVtbl;
	void *target;
	const struct LWDispMap *map;
	ULONG refc;
};

const struct LWDispVtbl *NTAPI LWDispSubclass(struct LWDispVtbl *);

IDispatch *NTAPI LWDispatch(void *target, const void *disp_map,
							const struct LWDispVtbl *, struct LWDispatch *);

// functions to build VARIANT arguments from various data types

// LWArg for objects
VARIANT NTAPI LWArg(LPDISPATCH);

// LWArg for wide and ansi character strings
VARIANT NTAPI LWArgW(LPCWSTR);
VARIANT NTAPI LWArgA(LPCSTR);

#ifdef _UNICODE
#define LWArgT LWArgW
#else
#define LWArgT LWArgA
#endif
// Generic LWArg for everything that does not involve dynamic allocation or
// reference counting. Use LWVT macro to compute the UINT argument.

VARIANT NTAPI LWArgV(UINT, ...);
#define LWVT(t) (sizeof(V_##t((VARIANT*)0)) << 8 | VT_##t)

// assign variant type and data in one statement
#define V_VAR(r,t) V_VT(r)=VT_##t,V_##t(r)

#ifdef __cplusplus
}
#endif 

#ifdef __cplusplus

// LWDispMap implementation macros for C++

#define	DISPMAP_FXN(NAME) \
	HRESULT *_##NAME, NAME(HRESULT, VARIANT *, VARIANT *, UINT, EXCEPINFO *); \
	static HRESULT NTAPI NAME##_(PVOID p, HRESULT sc, VARIANT *ret, VARIANT *argv, UINT argc, EXCEPINFO *e) \
	{ return ((P*)p)->NAME(sc, ret, argv, argc, e); }

#define	DISPMAP_REF(NAME) {L###NAME,NAME##_}

#define DISPMAP(T) \
	enum {COUNT = (sizeof(P) - sizeof(T)) / sizeof(HRESULT*)}; \
	static const struct\
	{ \
		LWDispFxn pfnProc; \
		int count; \
		struct LWDispRef ref[COUNT]; \
	} map =

// VARIANT derivative to hold a result value

struct LWRet: public VARIANT
{
	LWRet() {VariantInit(this);}
~	LWRet() {VariantClear(this);}
};

#else

// Sorry, no extra support for plain old C...

#endif
</file>

<file path="Winmerge-Src/Src/Common/MDITabBar.cpp">
/**
 * @file  MDITabBar.cpp
 *
 * @brief Implementation of the MDITabBar class
 */

#include "StdAfx.h"
#include "MDITabBar.h"
#include "IMDITab.h"
#include "cecolor.h"
#include "RoundedRectWithShadow.h"
#include "MergeDarkMode.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

constexpr int RR_RADIUS = 3;
constexpr int RR_PADDING = 3;
constexpr int RR_SHADOWWIDTH = 3;

/////////////////////////////////////////////////////////////////////////////
// CMDITabBar

IMPLEMENT_DYNAMIC(CMyTabCtrl, CTabCtrl)

BEGIN_MESSAGE_MAP(CMyTabCtrl, CTabCtrl)
	//{{AFX_MSG_MAP(CMyTabCtrl)
	ON_WM_MBUTTONDOWN()
	ON_WM_CONTEXTMENU()
	ON_WM_PAINT()
	ON_WM_ERASEBKGND()
	ON_NOTIFY_REFLECT_EX(TCN_SELCHANGE, OnSelchange)
	ON_WM_DRAWITEM_REFLECT()
	ON_WM_MOUSEMOVE()
	ON_WM_MOUSELEAVE()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEWHEEL()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

IMPLEMENT_DYNAMIC(CMDITabBar, CControlBar)

BEGIN_MESSAGE_MAP(CMDITabBar, CControlBar)
	//{{AFX_MSG_MAP(CMDITabBar)
	ON_WM_SIZE()
	ON_WM_NCHITTEST()
	ON_WM_ERASEBKGND()
	ON_WM_PAINT()
	ON_WM_NCMOUSEMOVE()
	ON_WM_NCMOUSELEAVE()
	ON_WM_NCLBUTTONDBLCLK()
	ON_WM_NCLBUTTONDOWN()
	ON_WM_NCLBUTTONUP()
	ON_WM_NCRBUTTONDOWN()
	ON_WM_NCRBUTTONUP()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

static int determineIconSize()
{
	return GetSystemMetrics(SM_CXSMICON);
}

BOOL CMyTabCtrl::Create(CMDIFrameWnd* pMainFrame, CWnd* pParent)
{
	if (!CTabCtrl::Create(WS_CHILD | WS_VISIBLE | TCS_OWNERDRAWFIXED, CRect(0, 0, 0, 0), pParent, 0))
		return FALSE;

	m_pMainFrame = pMainFrame;
	m_tooltips.Create(m_pMainFrame, TTS_NOPREFIX);
	m_tooltips.AddTool(this, _T(""));
	if (HWND hSelf = GetSafeHwnd())
		DarkMode::setTabCtrlUpDownSubclass(hSelf);

	if (HWND hTip = m_tooltips.GetSafeHwnd())
		DarkMode::setDarkTooltips(hTip);

	return TRUE;
}

/**
 * @brief Called before messages are translated.
 * Passes a mouse message to the ToolTip control for processing.
 * @param [in] pMsg Points to an MSG structure that contains the message to be chcecked
 */
BOOL CMyTabCtrl::PreTranslateMessage(MSG* pMsg)
{
	if (pMsg->message == WM_MOUSEMOVE)
		m_tooltips.RelayEvent(pMsg);

	// Call the parent method.
	return __super::PreTranslateMessage(pMsg);
}

void CMyTabCtrl::SetActive(bool bActive)
{
	CTitleBarHelper::ReloadAccentColor();
	m_bActive = bActive;
}

/**
 * @brief Activate the specific tab by index.
 * @param nTabIndex [in] Tab index to activate
 */
void CMyTabCtrl::ActivateTab(int nTabIndex)
{
	if (nTabIndex < 0 || nTabIndex >= GetItemCount())
		return;

	SetCurSel(nTabIndex);

	// Notify tab selection changed
	NMHDR nmhdr = {0};
	nmhdr.hwndFrom = GetSafeHwnd();
	nmhdr.idFrom = GetDlgCtrlID();
	nmhdr.code = TCN_SELCHANGE;
	GetParent()->SendMessage(WM_NOTIFY, nmhdr.idFrom, reinterpret_cast<LPARAM>(&nmhdr));
}

static inline COLORREF getTextColor()
{
	return GetSysColor(COLOR_WINDOWTEXT);
}

COLORREF CMyTabCtrl::GetBackColor() const
{
	const COLORREF clr = GetSysColor(COLOR_3DFACE);
	if (!m_bOnTitleBar)
		return clr;
	return CTitleBarHelper::GetBackColor(m_bActive);
}

static inline bool IsHighContrastEnabled()

{
	HIGHCONTRAST hc = { sizeof(HIGHCONTRAST) };
	SystemParametersInfo(SPI_GETHIGHCONTRAST, sizeof(hc), &hc, 0);
	return (hc.dwFlags & HCF_HIGHCONTRASTON) != 0;
}

void CMyTabCtrl::OnPaint() 
{
	CPaintDC dc(this);
	dc.SelectObject(GetFont());

	DRAWITEMSTRUCT dis;
	dis.hDC = dc.GetSafeHdc();

	CRect rcClient;
	GetClientRect(&rcClient);

	const int nCount = GetItemCount();
	if (nCount == 0)
	{
		const COLORREF winTitleTextColor = m_bOnTitleBar ?
			CTitleBarHelper::GetTextColor(m_bActive) : getTextColor();
		dc.SetTextColor(winTitleTextColor);
		TCHAR szBuf[256];
		AfxGetMainWnd()->GetWindowText(szBuf, sizeof(szBuf) / sizeof(szBuf[0]));
		dc.DrawText(szBuf, -1, &rcClient, DT_LEFT | DT_VCENTER | DT_SINGLELINE);
	}

	int nCurSel = GetCurSel();
	for (int i = nCount - 1; i >= 0; --i)
	{
		GetItemRect(i, &dis.rcItem);
		dis.itemID = i;
		dis.rcItem.top = rcClient.top;
		dis.rcItem.bottom = rcClient.bottom;
		dis.itemState = (i != nCurSel) ? 0 : ODS_SELECTED;
		DrawItem(&dis);
	}
}

BOOL CMyTabCtrl::OnEraseBkgnd(CDC* pDC)
{
	CRect rClient;
	GetClientRect(rClient);
	pDC->FillSolidRect(rClient, GetBackColor());
	return TRUE;
}

/** 
 * @brief Called when tab selection is changed.
 */
BOOL CMyTabCtrl::OnSelchange(NMHDR* pNMHDR, LRESULT* pResult)
{
	TC_ITEM tci;
	tci.mask = TCIF_PARAM;
	GetItem(GetCurSel(), &tci);
	m_bInSelchange = true;
	m_pMainFrame->MDIActivate(FromHandle((HWND)tci.lParam));
	m_bInSelchange = false;

	return TRUE;
}

/**
 * @brief Show context menu and handle user selection.
 */
void CMyTabCtrl::OnContextMenu(CWnd *pWnd, CPoint point)
{
	CPoint ptClient = point;
	ScreenToClient(&ptClient);
	int index = GetItemIndexFromPoint(ptClient);
	if (index < 0)
		return;

	TCITEM tci;
	tci.mask = TCIF_PARAM;
	GetItem(index, &tci);
	CWnd* pMDIChild = FromHandle((HWND)tci.lParam);
	m_pMainFrame->MDIActivate(pMDIChild);
	CMenu* pPopup = pMDIChild->GetSystemMenu(FALSE);
	if (pPopup == nullptr) return;
	MENUITEMINFO mii = { sizeof MENUITEMINFO };
	if (!pPopup->GetMenuItemInfo(ID_CLOSE_OTHER_TABS, &mii, FALSE))
	{
		pPopup->AppendMenu(MF_SEPARATOR, 0, _T(""));
		pPopup->AppendMenu(MF_STRING, ID_TABBAR_AUTO_MAXWIDTH, _T(""));
		pPopup->AppendMenu(MF_SEPARATOR, 0, _T(""));
		pPopup->AppendMenu(MF_STRING, ID_CLOSE_OTHER_TABS, _T(""));
		pPopup->AppendMenu(MF_STRING, ID_CLOSE_RIGHT_TABS, _T(""));
		pPopup->AppendMenu(MF_STRING, ID_CLOSE_LEFT_TABS, _T(""));
	}
	pPopup->ModifyMenu(ID_TABBAR_AUTO_MAXWIDTH, MF_BYCOMMAND, ID_TABBAR_AUTO_MAXWIDTH, _("Enable &Auto Max Width").c_str());
	pPopup->ModifyMenu(ID_CLOSE_OTHER_TABS, MF_BYCOMMAND, ID_CLOSE_OTHER_TABS, _("Close &Other Tabs").c_str());
	pPopup->ModifyMenu(ID_CLOSE_RIGHT_TABS, MF_BYCOMMAND, ID_CLOSE_RIGHT_TABS, _("Close R&ight Tabs").c_str());
	pPopup->ModifyMenu(ID_CLOSE_LEFT_TABS, MF_BYCOMMAND, ID_CLOSE_LEFT_TABS, _("Close &Left Tabs").c_str());

	pPopup->CheckMenuItem(ID_TABBAR_AUTO_MAXWIDTH, m_bAutoMaxWidth ? MF_CHECKED : MF_UNCHECKED);
	// invoke context menu
	int command = pPopup->TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON | TPM_RETURNCMD, point.x, point.y,
		this);
	switch (command)
	{
	case ID_CLOSE_OTHER_TABS:
	case ID_CLOSE_RIGHT_TABS:
	case ID_CLOSE_LEFT_TABS: {
		int curcel = GetCurSel();
		int n = GetItemCount();
		TCITEM tci1;
		tci1.mask = TCIF_PARAM;
		for (int i = n - 1; i >= 0; --i)
		{
			if ((command == ID_CLOSE_OTHER_TABS && i == curcel) ||
				(command == ID_CLOSE_RIGHT_TABS && i <= curcel) ||
				(command == ID_CLOSE_LEFT_TABS  && i >= curcel))
				continue;
			GetItem(i, &tci1);
			CWnd* pMDIChild1 = FromHandle((HWND)tci1.lParam);
			pMDIChild1->SendMessage(WM_SYSCOMMAND, SC_CLOSE);
		}
		break;
	}
	case ID_TABBAR_AUTO_MAXWIDTH:
		m_bAutoMaxWidth = !m_bAutoMaxWidth;
		UpdateTabs();
		break;
	default:
		pMDIChild->SendMessage(WM_SYSCOMMAND, command);
	}
}

/**
 * @brief synchronize the tabs with all mdi client windows.
 */
void CMyTabCtrl::UpdateTabs()
{
	Invalidate();

	HWND hWndMDIActive = m_pMainFrame->MDIGetActive()->GetSafeHwnd();

	CMap<HWND, HWND, int, int> MDIFrameList;
	if (hWndMDIActive != nullptr) {
		for (CWnd *pFrame = m_pMainFrame->MDIGetActive()->GetParent()->GetTopWindow(); pFrame; pFrame = pFrame->GetNextWindow())
			MDIFrameList[pFrame->m_hWnd] = -1;
	}

	// Associate MDIFrameList with the index of the tab
	TC_ITEM tci;
	int item;
	for (item = GetItemCount() - 1; item >= 0 ; item--)
	{
		int dummy;
		tci.mask = TCIF_PARAM;
		GetItem(item, &tci);
		if (MDIFrameList.Lookup((HWND)tci.lParam, dummy))
		{
			MDIFrameList[(HWND)tci.lParam] = item;
			if (!m_bInSelchange && hWndMDIActive == (HWND)tci.lParam)
				SetCurSel(item);
		}
	}

	int nMaxTitleLength;
	if (m_bAutoMaxWidth)
		nMaxTitleLength = static_cast<int>(MDITABBAR_MAXTITLELENGTH - (MDIFrameList.GetCount() - 1) * 6);
	else
		nMaxTitleLength = MDITABBAR_MAXTITLELENGTH;
	if (nMaxTitleLength < MDITABBAR_MINTITLELENGTH)
		nMaxTitleLength = MDITABBAR_MINTITLELENGTH;

	// Update or insert tabs
	for (POSITION pos = MDIFrameList.GetStartPosition(); pos != nullptr; )
	{
		HWND hFrameWnd;
//~		int item;
		MDIFrameList.GetNextAssoc(pos, hFrameWnd, item);

		CString strTitle;
		CDocument *pDoc = ((CFrameWnd *)FromHandle(hFrameWnd))->GetActiveDocument();
		if (pDoc != nullptr)
			strTitle = pDoc->GetTitle();
		else
			FromHandle(hFrameWnd)->GetWindowText(strTitle);

		if (strTitle.GetLength() > nMaxTitleLength)
			strTitle = strTitle.Left(nMaxTitleLength - 3) + _T("...");

		// Escape the '&' to prevent it from being removed and underlining the next character in the string.
		strTitle.Replace(_T("&"), _T("&&"));

		if (item == -1)
		{
			tci.mask = TCIF_PARAM | TCIF_TEXT;
			tci.pszText = strTitle.LockBuffer();
			tci.lParam = (LPARAM)hFrameWnd;
			InsertItem(GetItemCount(), &tci);
			if (GetItemCount() == 1)
				m_pMainFrame->RecalcLayout();
			if (!m_bInSelchange && hWndMDIActive == (HWND)tci.lParam)
				SetCurSel(item);
		}
		else
		{
			TCHAR szText[256];
			szText[0] = '\0';
			tci.pszText = szText;
			tci.cchTextMax = static_cast<int>(std::size(szText));
			tci.mask = TCIF_TEXT;
			GetItem(item, &tci);
			if (tci.pszText && strTitle.Compare(tci.pszText) != 0)
			{
				tci.pszText = strTitle.LockBuffer();
				SetItem(item, &tci);
			}
		}
	}

	// Delete tabs
	for (item = GetItemCount() - 1; item >= 0 ; item--)
	{
		int dummy;
		tci.mask = TCIF_PARAM;
		GetItem(item, &tci);
		if (!MDIFrameList.Lookup((HWND)tci.lParam, dummy))
		{
			DeleteItem(item);
			if (GetItemCount() == 0)
				m_pMainFrame->RecalcLayout();
		}
	}

	m_nTooltipTabItemIndex = -1;
}

/**
 * @brief Called when middle mouse button is pressed.
 * This function closes the tab when the middle mouse button is pressed.
 */
void CMyTabCtrl::OnMButtonDown(UINT nFlags, CPoint point)
{
	int index = GetItemIndexFromPoint(point);
	if (index < 0)
		return;

	TCITEM tci;
	tci.mask = TCIF_PARAM;
	GetItem(index, &tci);
	CWnd* pMDIChild = FromHandle((HWND)tci.lParam);
	pMDIChild->SendMessage(WM_SYSCOMMAND, SC_CLOSE);
}

void CMyTabCtrl::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct)
{
	TCHAR            szBuf[256];
	TCITEM           item;
	LPDRAWITEMSTRUCT lpDraw = (LPDRAWITEMSTRUCT)lpDrawItemStruct;

	item.mask       = TCIF_TEXT | TCIF_PARAM;
	item.pszText    = szBuf;
	item.cchTextMax = sizeof(szBuf) / sizeof(TCHAR);
	GetItem(lpDraw->itemID, &item);

	const int lpx = ::GetDeviceCaps(lpDraw->hDC, LOGPIXELSX);
	auto pointToPixel = [lpx](int point) { return MulDiv(point, lpx, 72); };
	const int r = pointToPixel(RR_RADIUS);
	const int pd = pointToPixel(RR_PADDING);
	const int sw = pointToPixel(RR_SHADOWWIDTH);

	CRect rc = lpDraw->rcItem;
	if (lpDraw->itemState & ODS_SELECTED)
	{
		const COLORREF clrShadow = CEColor::GetIntermediateColor(GetSysColor(COLOR_3DSHADOW), GetBackColor(), 0.5f);
		if (IsHighContrastEnabled())
		{
			DrawRoundedRectWithShadow(lpDraw->hDC, rc.left + sw, rc.top + sw - 1, rc.Width() - sw * 2, rc.Height() - rc.top - sw * 2 + 2, r, sw,
				GetSysColor(COLOR_HIGHLIGHT), clrShadow, GetBackColor());
			SetTextColor(lpDraw->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
		}
		else
		{
			DrawRoundedRectWithShadow(lpDraw->hDC, rc.left + sw, rc.top + sw - 1, rc.Width() - sw * 2, rc.Height() - sw * 2 + 2, r, sw,
				GetSysColor(COLOR_3DHIGHLIGHT), clrShadow, GetBackColor());
			SetTextColor(lpDraw->hDC, getTextColor());
		}
	}
	else
	{
		const COLORREF txtclr = m_bOnTitleBar ?
			CTitleBarHelper::GetTextColor(m_bActive) : GetSysColor(COLOR_BTNTEXT);
		SetTextColor(lpDraw->hDC, txtclr);
	}
	CSize iconsize(determineIconSize(), determineIconSize());
	rc.left += sw + pd + iconsize.cx;
	SetBkMode(lpDraw->hDC, TRANSPARENT);
	HWND hwndFrame = reinterpret_cast<HWND>(item.lParam);
	if (::IsWindow(hwndFrame))
	{
		HICON hIcon = (HICON)::SendMessage(hwndFrame, WM_GETICON, ICON_SMALL2, 0);
		if (hIcon == nullptr)
			hIcon = (HICON)GetClassLongPtr(hwndFrame, GCLP_HICONSM);
		if (hIcon != nullptr)
			DrawIconEx(lpDraw->hDC, rc.left - iconsize.cx, rc.top + (rc.Height() - iconsize.cy) / 2, hIcon, iconsize.cx, iconsize.cy, 0, nullptr, DI_NORMAL);
	}
	rc.left += pd;
	rc.right -= pd;
	DrawText(lpDraw->hDC, szBuf, -1, &rc, DT_LEFT | DT_VCENTER | DT_SINGLELINE);

	int nItem = GetItemIndexFromPoint(m_rcCurrentCloseButtom.CenterPoint());
	if (static_cast<UINT>(nItem) == lpDraw->itemID)
	{
		CPoint pt;
		GetCursorPos(&pt);
		ScreenToClient(&pt);
		CRect rc1 = GetCloseButtonRect(nItem);
		DrawFrameControl(lpDraw->hDC, &rc1, DFC_CAPTION, 
			DFCS_CAPTIONCLOSE | DFCS_FLAT | (rc1.PtInRect(pt) ? DFCS_HOT : 0) |
			((m_bCloseButtonDown && rc1.PtInRect(pt)) ? DFCS_PUSHED : 0));
	}
}

void CMyTabCtrl::OnMouseMove(UINT nFlags, CPoint point)
{
	int nTabItemIndex = GetItemIndexFromPoint(point);
	CRect rc = GetCloseButtonRect(nTabItemIndex);
	if (rc != m_rcCurrentCloseButtom)
	{
		InvalidateRect(&rc);
		InvalidateRect(&m_rcCurrentCloseButtom);
	}
	m_rcCurrentCloseButtom = rc;
	if (!m_bMouseTracking)
	{
		TRACKMOUSEEVENT tme = { sizeof TRACKMOUSEEVENT };
		tme.dwFlags = TME_LEAVE;
		tme.hwndTrack = m_hWnd;
		TrackMouseEvent(&tme);
		m_bMouseTracking = true;
	}
	if (m_nDraggingTabItemIndex >= 0 && nTabItemIndex >= 0 && m_nDraggingTabItemIndex != nTabItemIndex)
	{
		CRect rectDraggingTab, rectDest;
		GetItemRect(m_nDraggingTabItemIndex, &rectDraggingTab);
		GetItemRect(nTabItemIndex, &rectDest);
		rectDest.right = rectDest.left + rectDraggingTab.Width();
		if (rectDest.PtInRect(point))
		{
			SwapTabs(m_nDraggingTabItemIndex, nTabItemIndex);
			m_nDraggingTabItemIndex = nTabItemIndex;
			m_rcCurrentCloseButtom = GetCloseButtonRect(nTabItemIndex);
			Invalidate();
		}
	}

	if (nTabItemIndex != m_nTooltipTabItemIndex)
		UpdateToolTips(nTabItemIndex);
}

void CMyTabCtrl::OnMouseLeave()
{
	TRACKMOUSEEVENT tme = { sizeof(TRACKMOUSEEVENT) };
	tme.dwFlags = TME_LEAVE | TME_CANCEL;
	tme.hwndTrack = m_hWnd;
	TrackMouseEvent(&tme);
	m_bMouseTracking = false;
	InvalidateRect(&m_rcCurrentCloseButtom);
	m_rcCurrentCloseButtom = CRect();
	m_bCloseButtonDown = false;
}

void CMyTabCtrl::OnLButtonDown(UINT nFlags, CPoint point)
{
	m_bCloseButtonDown = !!m_rcCurrentCloseButtom.PtInRect(point);
	InvalidateRect(m_rcCurrentCloseButtom);
	if (!m_bCloseButtonDown)
	{
		if (DragDetect(point))
		{
			m_nDraggingTabItemIndex = GetItemIndexFromPoint(point);
			SetCapture();
		}
		CWnd::OnLButtonDown(nFlags, point);
	}
}

void CMyTabCtrl::OnLButtonUp(UINT nFlags, CPoint point)
{
	if (m_nDraggingTabItemIndex >= 0)
	{
		m_nDraggingTabItemIndex = -1;
		ReleaseCapture();
	}
	else
	{
		if (m_bCloseButtonDown && m_rcCurrentCloseButtom.PtInRect(point))
			OnMButtonDown(nFlags, point);
		InvalidateRect(m_rcCurrentCloseButtom);
		m_bCloseButtonDown = false;
	}
	CWnd::OnLButtonUp(nFlags, point);
}

BOOL CMyTabCtrl::OnMouseWheel(UINT nFlags, short zDelta, CPoint point)
{
	// Rotating the mouse wheel while dragging: No action performed
	if (m_nDraggingTabItemIndex >= 0)
		return TRUE;

	// "Scroll forward" is wheel rotation towards the user
	const bool bIsScrollForward = zDelta < 0;

	const int nLastTabIndex = GetItemCount() - 1;

	// SHIFT + MOUSEWHEEL (UP/DOWN): Switches to the previous/next tab WITHOUT wraparound
	if (nFlags & MK_SHIFT)
	{
		int nSwitchToTabIndex = GetCurSel() + (bIsScrollForward ? 1 : -1);
		if (nSwitchToTabIndex < 0 || nSwitchToTabIndex > nLastTabIndex)
			return TRUE;

		ActivateTab(nSwitchToTabIndex);
	}

	// Otherwise, scroll the tab bar
	else
	{
		CRect rectTabCtrl, rectLastTab;
		GetClientRect(&rectTabCtrl);
		GetItemRect(nLastTabIndex, &rectLastTab);

		// Get index of the first visible tab
		CPoint pt(rectTabCtrl.left + 10, rectTabCtrl.Height() / 2);
		int nFirstVisibleTabIndex = GetItemIndexFromPoint(pt);

		if (nFirstVisibleTabIndex < 1 && rectLastTab.right < rectTabCtrl.right)  // No overflow
			return TRUE;

		// Get the width of the up/down control
		// This area may hide parts of the last tab and needs to be excluded
		CWnd* pUpDownCtrl = FindWindowEx(GetSafeHwnd(), nullptr, L"msctls_updown32", nullptr);
		if (!pUpDownCtrl)	// No up/down control also means no overflow
			return TRUE;

		CRect rectUpDownCtrl;
		pUpDownCtrl->GetWindowRect(&rectUpDownCtrl);

		// Scroll forward as long as the last tab is hidden; scroll backward till the first tab
		int nScrollTabIndex = nFirstVisibleTabIndex;
		if ((rectTabCtrl.right - rectLastTab.right) < rectUpDownCtrl.Width() || !bIsScrollForward)
		{
			nScrollTabIndex += (bIsScrollForward ? 1 : -1);
			if (nScrollTabIndex < 0 || nScrollTabIndex > nLastTabIndex)
				return TRUE;

			// Scroll tabs
			SendMessage(WM_HSCROLL, MAKEWPARAM(SB_THUMBPOSITION, nScrollTabIndex), 0);
		}
	}

	return TRUE;
}

CRect CMyTabCtrl::GetCloseButtonRect(int nItem)
{
	CClientDC dc(this);
	const int lpx = dc.GetDeviceCaps(LOGPIXELSX);
	auto pointToPixel = [lpx](int point) { return MulDiv(point, lpx, 72); };
	const int pd = pointToPixel(RR_PADDING);
	const int sw = pointToPixel(RR_SHADOWWIDTH);
	CRect rc, rcClient;
	CSize size(determineIconSize(), determineIconSize());
	GetClientRect(&rcClient);
	GetItemRect(nItem, &rc);
	rc.left = rc.right - size.cx - sw - pd;
	rc.right = rc.left + size.cx;
	int y = (rcClient.top + rcClient.bottom) / 2;
	rc.top = y - size.cy / 2 + 1;
	rc.bottom = rc.top + size.cy;
	return rc;
}

int CMyTabCtrl::GetItemIndexFromPoint(CPoint point) const
{
	TCHITTESTINFO hit;
	hit.pt = point;
	return HitTest(&hit);
}

void CMyTabCtrl::SwapTabs(int nIndexA, int nIndexB)
{
	TC_ITEM tciA = {0}, tciB = {0};
	TCHAR szTextA[256], szTextB[256];
	int nCurSel = GetCurSel();

	tciA.cchTextMax = sizeof(szTextA)/sizeof(szTextA[0]);
	tciB.cchTextMax = sizeof(szTextB)/sizeof(szTextB[0]);
	tciA.pszText = szTextA;
	tciB.pszText = szTextB;
	tciA.mask = tciB.mask = TCIF_PARAM | TCIF_TEXT;

	GetItem(nIndexA, &tciA);
	GetItem(nIndexB, &tciB);

	std::swap(tciA, tciB);

	SetItem(nIndexB, &tciB);
	SetItem(nIndexA, &tciA);

	if (nCurSel == nIndexA)
		SetCurSel(nIndexB);
	if (nCurSel == nIndexB)
		SetCurSel(nIndexA);
}

/**
 * @brief Get the maximum length of the title.
 */
int CMyTabCtrl::GetMaxTitleLength() const
{
	int nMaxTitleLength = m_bAutoMaxWidth ? static_cast<int>(MDITABBAR_MAXTITLELENGTH - (GetItemCount() - 1) * 6) : MDITABBAR_MAXTITLELENGTH;
	if (nMaxTitleLength < MDITABBAR_MINTITLELENGTH)
		nMaxTitleLength = MDITABBAR_MINTITLELENGTH;

	return nMaxTitleLength;
}

/**
 * @brief Update tooltip text.
 * @param [in] nTabItemIndex Index of the tab displaying tooltip.
 */
void CMyTabCtrl::UpdateToolTips(int nTabItemIndex)
{
	TC_ITEM tci;
	tci.mask = TCIF_PARAM;
	GetItem(nTabItemIndex, &tci);

	if (!m_pMainFrame)
		return;
	CMDIChildWnd* pActiveWnd = m_pMainFrame->MDIGetActive();
	if (!pActiveWnd)
		return;
	CWnd* pParentWnd = pActiveWnd->GetParent();
	if (!pParentWnd)
		return;

	for (CWnd* pFrame = pParentWnd->GetTopWindow(); pFrame; pFrame = pFrame->GetNextWindow())
	{
		if (reinterpret_cast<HWND>(tci.lParam) == pFrame->m_hWnd)
		{
			HWND hFrameWnd = pFrame->m_hWnd;
			CString strTitle, strTooltip;
			CFrameWnd* pFrameWnd = (CFrameWnd*)FromHandle(hFrameWnd);
			CDocument* pDoc = pFrameWnd->GetActiveDocument();
			IMDITab* pITabBar = nullptr;
			if (pDoc != nullptr)
			{
				strTitle = pDoc->GetTitle();
				pITabBar = dynamic_cast<IMDITab*>(pDoc);
			}
			else
			{
				pFrameWnd->GetWindowText(strTitle);
				pITabBar = dynamic_cast<IMDITab*>(pFrameWnd);
			}
			strTooltip = pITabBar ? pITabBar->GetTooltipString() : _T("");

			if (strTooltip == strTitle && strTitle.GetLength() <= GetMaxTitleLength())
				strTooltip.Empty();

			constexpr size_t MAX_TIP_TEXT_LENGTH = 1024;
			if (strTooltip.GetLength() > MAX_TIP_TEXT_LENGTH)
				strTooltip.Truncate(MAX_TIP_TEXT_LENGTH);

			m_tooltips.UpdateTipText(strTooltip, this);
			CRect rc;
			GetClientRect(&rc);
			m_tooltips.SetMaxTipWidth(rc.Width() * 60 / 100);
			m_nTooltipTabItemIndex = nTabItemIndex;
			return;
		}
	}
}

BOOL CMDITabBar::Update(bool bOnTitleBar, bool bMaximized)
{
	m_bOnTitleBar = bOnTitleBar;
	m_titleBar.SetMaximized(bMaximized);
	m_tabCtrl.SetOnTitleBar(bOnTitleBar);
	return true;
}

void CMDITabBar::UpdateActive(bool bActive)
{
	if (m_tabCtrl.GetActive() != bActive)
	{
		m_tabCtrl.SetActive(bActive);
		Invalidate();
	}
}

/** 
 * @brief Create tab bar.
 * @param pParentWnd [in] main frame window pointer
 */
BOOL CMDITabBar::Create(CMDIFrameWnd* pMainFrame)
{
	m_dwStyle = CBRS_TOP;

	m_titleBar.Init(this);

	CWnd::Create(nullptr, nullptr, WS_CHILD | WS_VISIBLE, CRect(0, 0, 0, 0), pMainFrame, AFX_IDW_CONTROLBAR_LAST - 1);

	if (!m_tabCtrl.Create(pMainFrame, this))
		return FALSE;

	CClientDC dc(this);
	const int lpx = dc.GetDeviceCaps(LOGPIXELSX);
	auto pointToPixel = [lpx](int point) { return MulDiv(point, lpx, 72); };
	const int pd = pointToPixel(RR_PADDING);
	const int sw = pointToPixel(RR_SHADOWWIDTH);
	m_tabCtrl.SetPadding(CSize(sw + pd * 2 + determineIconSize() / 2, sw + pd));

	NONCLIENTMETRICS ncm = { sizeof NONCLIENTMETRICS };
	SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof NONCLIENTMETRICS, &ncm, 0);
	m_font.CreateFontIndirect(&ncm.lfMenuFont);
	m_tabCtrl.SetFont(&m_font);

	return TRUE;
}

/**
 * @brief Get tab item index from point
 */
int CMDITabBar::GetItemIndexFromPoint(CPoint point, bool bRelatively) const
{
	if (bRelatively)
	{
		CRect rcTabCtrl;
		m_tabCtrl.GetClientRect(&rcTabCtrl);

		m_tabCtrl.ScreenToClient(&point);
		point.y = rcTabCtrl.Height() / 2;
	}

	TCHITTESTINFO hit;
	hit.pt = point;
	return m_tabCtrl.HitTest(&hit);
}

/**
 * @brief Forward mouse events to the tab control if needed.
 */
bool CMDITabBar::ForwardMouseEventToTabCtrlIfNeeded(CPoint& point, UINT message)
{
	if (!(m_bOnTitleBar && m_titleBar.GetMaximized()))
		return false;

	int nItemHitTest = GetItemIndexFromPoint(point, true);
	if (nItemHitTest == -1)
		return false;

	CRect rcHitItem;
	m_tabCtrl.GetItemRect(nItemHitTest, &rcHitItem);
	m_tabCtrl.ScreenToClient(&point);

	if (point.y <= rcHitItem.top)
		point.y = rcHitItem.top + 1;
	else if (point.y >= rcHitItem.bottom)
		point.y = rcHitItem.bottom - 1;

	switch (message)
	{
	case WM_LBUTTONDOWN:
	case WM_LBUTTONUP:
		m_tabCtrl.SendMessage(message, MK_LBUTTON, MAKELPARAM(point.x, point.y));
		break;
	case WM_CONTEXTMENU:
		m_tabCtrl.SendMessage(WM_CONTEXTMENU, (WPARAM)m_tabCtrl.m_hWnd, MAKELPARAM(point.x, point.y));
		break;
	default:
		break;
	}

	return true;
}

/** 
 * @brief This method calculates the horizontal size of a control bar.
 */
CSize CMDITabBar::CalcFixedLayout(BOOL bStretch, BOOL bHorz)
{
	if (!m_bOnTitleBar && m_tabCtrl.GetItemCount() == 0)
		return CSize(SHRT_MAX, 0);
	
	TEXTMETRIC tm;
	CClientDC dc(this);
	CFont *pOldFont = dc.SelectObject(&m_font);
	dc.GetTextMetrics(&tm);
	dc.SelectObject(pOldFont);

	const int lpx = dc.GetDeviceCaps(LOGPIXELSX);
	auto pointToPixel = [lpx](int point) { return MulDiv(point, lpx, 72); };
	const int pd = pointToPixel(RR_PADDING);
	const int sw = pointToPixel(RR_SHADOWWIDTH);
	int my = m_bOnTitleBar ? (m_titleBar.GetTopMargin() + 2) : 0;
	CSize size(SHRT_MAX, my + tm.tmHeight + (sw + pd) * 2);
	return size;
}

LRESULT CMDITabBar::OnNcHitTest(CPoint point)
{
	if (!m_bOnTitleBar)
		return __super::OnNcHitTest(point);
	return m_titleBar.OnNcHitTest(point);
}

void CMDITabBar::OnNcMouseMove(UINT nHitTest, CPoint point)
{
	m_titleBar.OnNcMouseMove(nHitTest, point);
}

void CMDITabBar::OnNcMouseLeave()
{
	m_titleBar.OnNcMouseLeave();
}

void CMDITabBar::OnNcLButtonDblClk(UINT nHitTest, CPoint point)
{
	m_titleBar.OnNcLButtonDblClk(nHitTest, point);
}

void CMDITabBar::OnNcLButtonDown(UINT nHitTest, CPoint point)
{
	if (ForwardMouseEventToTabCtrlIfNeeded(point, WM_LBUTTONDOWN))
		return;
	m_titleBar.OnNcLButtonDown(nHitTest, point);
}

void CMDITabBar::OnNcLButtonUp(UINT nHitTest, CPoint point)
{
	if (ForwardMouseEventToTabCtrlIfNeeded(point, WM_LBUTTONUP))
		return;
	m_titleBar.OnNcLButtonUp(nHitTest, point);
}

void CMDITabBar::OnNcRButtonDown(UINT nHitTest, CPoint point)
{
	m_titleBar.OnNcRButtonDown(nHitTest, point);
}

void CMDITabBar::OnNcRButtonUp(UINT nHitTest, CPoint point)
{
	if (ForwardMouseEventToTabCtrlIfNeeded(point, WM_CONTEXTMENU))
		return;
	m_titleBar.OnNcRButtonUp(nHitTest, point);
}

void CMDITabBar::OnSize(UINT nType, int cx, int cy)
{
	__super::OnSize(nType, cx, cy);
	m_titleBar.SetSize(cx, cy);
	if (m_tabCtrl.m_hWnd)
	{
		const int leftMargin = m_bOnTitleBar ? m_titleBar.GetLeftMargin() : 0;
		const int rightMargin = m_bOnTitleBar ? m_titleBar.GetRightMargin() : 0;
		const int topMargin = ((m_titleBar.GetMaximized() && m_bOnTitleBar) ? m_titleBar.GetTopMargin() : 0) + (m_bOnTitleBar ? 1 : 0);
		const int bottomMargin = m_bOnTitleBar ? 1 : 0;
		CSize size{ 0, cy - topMargin - bottomMargin };
		m_tabCtrl.MoveWindow(leftMargin, topMargin, cx - leftMargin - rightMargin, cy - topMargin - bottomMargin, true);
		m_tabCtrl.SetItemSize(size);
	}
}

BOOL CMDITabBar::OnEraseBkgnd(CDC* pDC)
{
	CRect rClient;
	GetClientRect(rClient);
	pDC->FillSolidRect(rClient, m_tabCtrl.GetBackColor());
	return TRUE;
}

void CMDITabBar::OnPaint()
{
	if (!m_bOnTitleBar)
		return __super::OnPaint();
	CPaintDC dc(this);
	m_titleBar.DrawIcon(AfxGetMainWnd(), dc, m_tabCtrl.GetActive());
	m_titleBar.DrawButtons(dc, CTitleBarHelper::GetTextColor(m_tabCtrl.GetActive()), m_tabCtrl.GetBackColor());
}
</file>

<file path="Winmerge-Src/Src/Common/MDITabBar.h">
/** 
 * @file  MDITabBar.h
 *
 * @brief Declaration file for MDITabBar
 *
 */
#pragma once

#include "TitleBarHelper.h"

class CMyTabCtrl : public CTabCtrl
{
	enum { MDITABBAR_MINTITLELENGTH = 8, MDITABBAR_MAXTITLELENGTH = 64 };

	DECLARE_DYNAMIC(CMyTabCtrl)
public:
	CMyTabCtrl()
		: m_bMouseTracking(false)
		, m_bAutoMaxWidth(true)
		, m_pMainFrame(nullptr)
		, m_bCloseButtonDown(false)
		, m_nDraggingTabItemIndex(-1)
		, m_bInSelchange(false)
		, m_nTooltipTabItemIndex(-1)
		, m_bOnTitleBar(false)
		, m_bActive(false)
	{}

protected:
	bool m_bInSelchange;
	bool  m_bAutoMaxWidth;
	bool m_bMouseTracking;
	bool m_bCloseButtonDown;
	bool m_bOnTitleBar;
	bool m_bActive;
	CRect m_rcCurrentCloseButtom;
	int   m_nDraggingTabItemIndex;
	int   m_nTooltipTabItemIndex;	/**< Index of the tab displaying tooltip */
	CMDIFrameWnd *m_pMainFrame;
	CToolTipCtrl m_tooltips;		/**< Tooltip for the tab */

public:
	BOOL Create(CMDIFrameWnd* pMainFrame, CWnd* pParent);
	bool GetAutoMaxWidth() const { return m_bAutoMaxWidth; }
	void SetAutoMaxWidth(bool bAutoMaxWidth) { m_bAutoMaxWidth = bAutoMaxWidth; }
	void UpdateTabs();
	void SetOnTitleBar(bool onTitleBar) { m_bOnTitleBar = onTitleBar; }
	bool GetActive() const { return m_bActive; }
	void SetActive(bool bActive);
	void ActivateTab(int nTabIndex);
	COLORREF GetBackColor() const;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMyTabCtrl)
	//}}AFX_VIRTUAL
// Implementation
public:
	virtual ~CMyTabCtrl() {}

// Generated message map functions
protected:
	virtual BOOL PreTranslateMessage(MSG* pMsg);

	//{{AFX_MSG(CMyTabCtrl)
	afx_msg void OnPaint();
	afx_msg BOOL OnEraseBkgnd(CDC *pDC);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnMButtonDown(UINT nFlags, CPoint point);
	afx_msg BOOL OnSelchange(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnMouseLeave();
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg BOOL OnMouseWheel(UINT nFlags, short zDelta, CPoint point);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

	CRect GetCloseButtonRect(int nItem);
	int GetItemIndexFromPoint(CPoint pt) const;
	void SwapTabs(int nIndexA, int nIndexB);
	int GetMaxTitleLength() const;
	void UpdateToolTips(int index);
};

/**
 * @brief Class for Tab bar.
 */
class CMDITabBar : public CControlBar
{
	DECLARE_DYNAMIC(CMDITabBar)

private:

	bool m_bOnTitleBar;
	CMyTabCtrl m_tabCtrl;
	CFont m_font;
	CTitleBarHelper m_titleBar;

public:
	CMDITabBar()
		: m_bOnTitleBar(true)
	{}
	virtual ~CMDITabBar() {}
	BOOL Update(bool bOnTitleBar, bool bMaxmized);
	void UpdateActive(bool bActive);
	BOOL Create(CMDIFrameWnd* pParentWnd);
	void UpdateTabs() { m_tabCtrl.UpdateTabs(); }
	bool GetAutoMaxWidth() const { return m_tabCtrl.GetAutoMaxWidth(); }
	void SetAutoMaxWidth(bool bAutoMaxWidth) { m_tabCtrl.SetAutoMaxWidth(bAutoMaxWidth); }
	int GetItemCount() const { return m_tabCtrl.GetItemCount(); }
	int GetItemIndexFromPoint(CPoint point, bool bRelatively) const;
	bool ForwardMouseEventToTabCtrlIfNeeded(CPoint& point, UINT message);

	virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler) {}
	virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz);

protected:

	//{{AFX_MSG(CMDITabBar)
	afx_msg LRESULT OnNcHitTest(CPoint point);
	afx_msg void OnNcMouseMove(UINT nHitTest, CPoint point);
	afx_msg void OnNcMouseLeave();
	afx_msg void OnNcLButtonDblClk(UINT nHitTest, CPoint point);
	afx_msg void OnNcLButtonDown(UINT nHitTest, CPoint point);
	afx_msg void OnNcLButtonUp(UINT nHitTest, CPoint point);
	afx_msg void OnNcRButtonDown(UINT nHitTest, CPoint point);
	afx_msg void OnNcRButtonUp(UINT nHitTest, CPoint point);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnPaint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
};
</file>

<file path="Winmerge-Src/Src/Common/memdc.h">
#pragma once

//////////////////////////////////////////////////
// CMemDC - memory DC
//
// Author: Keith Rule
// Email:  keithr@europa.com
// Copyright 1996-2002, Keith Rule
//
// You may freely use or modify this code provided this
// Copyright is included in all derived versions.
//
// History - 10/3/97 Fixed scrolling bug.
//                   Added print support. - KR
//
//           11/3/99 Fixed most common complaint. Added
//                   background color fill. - KR
//
//           11/3/99 Added support for mapping modes other than
//                   MM_TEXT as suggested by Lee Sang Hun. - KR
//
//           02/11/02 Added support for CScrollView as supplied
//                    by Gary Kirkham. - KR
//
// This class implements a memory Device Context which allows
// flicker free drawing.

class CMyMemDC : public CDC {
private:	
	CBitmap		m_bitmap;		// Offscreen bitmap
	CBitmap*	m_oldBitmap;	// bitmap originally found in CMemDC
	CDC*		m_pDC;			// Saves CDC passed in constructor
	CRect		m_rect;			// Rectangle of drawing area.
	bool		m_bMemDC;		// `true` if CDC really is a Memory DC.
public:
	
	explicit CMyMemDC(CDC* pDC, const CRect* pRect = nullptr) : CDC()
	{
		ASSERT(pDC != nullptr); 

		// Some initialization
		m_pDC = pDC;
		m_oldBitmap = nullptr;
		m_bMemDC = !pDC->IsPrinting();

		// Get the rectangle to draw
		if (pRect == nullptr) {
			pDC->GetClipBox(&m_rect);
		} else {
			m_rect = *pRect;
		}

		if (m_bMemDC) {
			// Create a Memory DC
			CreateCompatibleDC(pDC);
			pDC->LPtoDP(&m_rect);

			m_bitmap.CreateCompatibleBitmap(pDC, m_rect.Width(), m_rect.Height());
			m_oldBitmap = SelectObject(&m_bitmap);

			SetMapMode(pDC->GetMapMode());

			SetWindowExt(pDC->GetWindowExt());
			SetViewportExt(pDC->GetViewportExt());

			pDC->DPtoLP(&m_rect);
			SetWindowOrg(m_rect.left, m_rect.top);
		} else {
			// Make a copy of the relevant parts of the current DC for printing
			m_bPrinting = pDC->m_bPrinting;
			m_hDC       = pDC->m_hDC;
			m_hAttribDC = pDC->m_hAttribDC;
		}

		// Fill background 
		FillSolidRect(m_rect, pDC->GetBkColor());
	}
	
	~CMyMemDC()	
	{		
		if (m_bMemDC) {
			// Copy the offscreen bitmap onto the screen.
			m_pDC->BitBlt(m_rect.left, m_rect.top, m_rect.Width(), m_rect.Height(),
				this, m_rect.left, m_rect.top, SRCCOPY);			
			
			//Swap back the original bitmap.
			SelectObject(m_oldBitmap);		
		} else {
			// All we need to do is replace the DC with an illegal value,
			// this keeps us from accidently deleting the handles associated with
			// the CDC that was passed to the constructor.			
			m_hDC = m_hAttribDC = nullptr;
		}	
	}
	
	// Allow usage as a pointer	
	CMyMemDC* operator->() 
	{
		return this;
	}	

	// Allow usage as a pointer	
	operator CMyMemDC*() 
	{
		return this;
	}
};
</file>

<file path="Winmerge-Src/Src/Common/MessageBoxDialog.h">
/*
 *	Extended MFC message boxes -- Version 1.1a
 *	Copyright (c) 2004 Michael P. Mehl. All rights reserved.
 *
 *	The contents of this file are subject to the Mozilla Public License
 *	Version 1.1a (the "License"); you may not use this file except in
 *	compliance with the License. You may obtain a copy of the License at 
 *	http://www.mozilla.org/MPL/.
 *
 *	Software distributed under the License is distributed on an "AS IS" basis,
 *	WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 *	for the specific language governing rights and limitations under the
 *	License. 
 *
 *	The Original Code is Copyright (c) 2004 Michael P. Mehl. All rights
 *	reserved. The Initial Developer of the Original Code is Michael P. Mehl
 *	<michael.mehl@web.de>.
 *
 *	Alternatively, the contents of this file may be used under the terms of
 *	the GNU Lesser General Public License Version 2.1 (the "LGPL License"),
 *	in which case the provisions of LGPL License are applicable instead of
 *	those above. If you wish to allow use of your version of this file only
 *	under the terms of the LGPL License and not to allow others to use your
 *	version of this file under the MPL, indicate your decision by deleting
 *	the provisions above and replace them with the notice and other provisions
 *	required by the LGPL License. If you do not delete the provisions above,
 *	a recipient may use your version of this file under either the MPL or
 *	the LGPL License.
 */

#pragma once

#include "resource.h"
#include "UnicodeString.h"
#include <vector>

//////////////////////////////////////////////////////////////////////////////
// Message box style definitions (mostly taken from WinUser.h).

#ifndef MB_CANCELTRYCONTINUE
#define MB_CANCELTRYCONTINUE		0x00000006L	// Standard for Win 5.x.
#endif

#define MB_CONTINUEABORT			0x00000007L	// Additional style.
#define MB_SKIPSKIPALLCANCEL		0x00000008L	// Additional style.
#define MB_IGNOREIGNOREALLCANCEL	0x00000009L	// Additional style.

#define MB_DONT_DISPLAY_AGAIN		0x01000000L	// Additional style.
#define MB_DONT_ASK_AGAIN			0x02000000L	// Additional style.
#define MB_YES_TO_ALL				0x04000000L	// Additional style.
#define MB_NO_TO_ALL				0x08000000L	// Additional style.

#define MB_DEFAULT_CHECKED			0x10000000L // Additional style.
#define MB_RIGHT_ALIGN				0x20000000L	// Additional style.
#define MB_NO_SOUND					0x40000000L	// Additional style.

#define MB_MODELESS					0x80000000L	// Additional style.

#define MB_DEFBUTTON5				0x00000400L	// Additional style.
#define MB_DEFBUTTON6				0x00000500L	// Additional style.

//////////////////////////////////////////////////////////////////////////////
// Dialog element IDs.

#ifndef IDTRYAGAIN
#define IDTRYAGAIN					10			// Standard for Win 5.x.
#endif

#ifndef IDCONTINUE
#define IDCONTINUE					11			// Standard for Win 5.x.
#endif

#define IDYESTOALL					14			// Additional element.
#define IDNOTOALL					15			// Additional element.
#define IDSKIP						16			// Additional element.
#define IDSKIPALL					17			// Additional element.
#define IDIGNOREALL					18			// Additional element.
#define IDCHECKBOX					19			// Additional element.

//////////////////////////////////////////////////////////////////////////////
// Name of the registry section for storing the message box results.

#define REGISTRY_SECTION_MESSAGEBOX	_T("MessageBoxes")

//////////////////////////////////////////////////////////////////////////////
// Class definition.

class CMessageBoxDialog : public CDialog
{

	DECLARE_DYNAMIC(CMessageBoxDialog)

public:

	//////////////////////////////////////////////////////////////////////////
	// Constructors and destructors of the class.

	// Constructor of the class for direct providing of the message strings.
	CMessageBoxDialog ( CWnd* pParent, CString strMessage, 
		CString strTitle = _T(""), UINT nStyle = MB_OK, UINT nHelp = 0, const CString& strRegistryKey = _T("") );

	// Constructor of the class for loading the strings from the resources.
	CMessageBoxDialog ( CWnd* pParent, UINT nMessageID, UINT nTitleID = 0,
		UINT nStyle = MB_OK, UINT nHelp = 0, const CString& strRegistryKey = _T("") );

	// Default destructor of the class.
	virtual ~CMessageBoxDialog ( );

	enum { IDD = IDD_MESSAGE_BOX };

public:

	//////////////////////////////////////////////////////////////////////////
	// Methods for setting and retrieving dialog options.

	// Method for setting the style of the message box.
	void SetStyle ( UINT nStyle );

	// Method for retrieving the style of the message box.
	UINT GetStyle ( );

	// Methods for setting the message to be displayed in the message box.
	void SetMessage ( LPCTSTR strMessage );
	void SetMessage ( UINT nMessageID );

	// Method for retrieving the message to be displayed in the message box.
	const String &GetMessage ( );

	// Methods for setting the title to be displayed in the message box.
	void SetTitle ( LPCTSTR strTitle );
	void SetTitle ( UINT nTitleID );

	// Method for retrieving the title to be displayed in the message box.
	const String &GetTitle ( );

	// Methods for setting the icon to be displayed in the message box.
	void SetMessageIcon ( HICON hIcon );
	void SetMessageIcon ( UINT nIconID );

	// Method for retrieving the icon to be displayed in the message box.
	HICON GetMessageIcon ( );

	// Method for setting a timeout.
	void SetTimeout ( UINT nSeconds, bool bDisabled = false );

	// Method for retrieving the seconds for the timeout.
	UINT GetTimeoutSeconds ( );

	// Method for retrieving whether a timeout is disabled.
	bool GetTimeoutDisabled ( );

	// Method for retrieving the former result of the message box from the registry.
	int GetFormerResult();
	// Method for storing the former result of the message box to the registry.
	int SetFormerResult(int nResult);

public:

	//////////////////////////////////////////////////////////////////////////
	// Methods for handling the stored states.

	// Method for resetting the message boxes stored in the registry.
	static void ResetMessageBoxes ( );
	static CString GenerateRegistryKey (UINT nMessageID, UINT nHelpID);

public:

	//////////////////////////////////////////////////////////////////////////
	// Methods for handling common window functions.

	// Method for displaying the dialog.
	virtual INT_PTR DoModal ( );

	// Method for closing the dialog.
	void EndDialog ( int nResult );

	// Method for initializing the dialog.
	virtual BOOL OnInitDialog ( );

	// Method for handling command messages.
	virtual BOOL OnCmdMsg ( UINT nID, int nCode, void* pExtra,
		AFX_CMDHANDLERINFO* pHandlerInfo );

	// Method for handling messages before dispatching them.
	virtual BOOL PreTranslateMessage ( MSG* pMsg );

	// Method for handling a timer event.
	afx_msg void OnTimer ( UINT_PTR nIDEvent );
	afx_msg BOOL OnEraseBkgnd( CDC* pDC );
	afx_msg HBRUSH OnCtlColor( CDC* pDC, CWnd* pWnd, UINT nCtlColor );

protected:

	//////////////////////////////////////////////////////////////////////////
	// Other methods for handling common window functions.

	// Method for handling window messages.
	virtual BOOL OnWndMsg ( UINT message, WPARAM wParam, LPARAM lParam,
		LRESULT* pResult );

	DECLARE_MESSAGE_MAP()

private:

	//////////////////////////////////////////////////////////////////////////
	// Private member variables of this dialog.

	String		m_strMessage;		// Message to be displayed.
	String		m_strTitle;			// Title to be used.
	UINT		m_nStyle;			// Style of the message box.
	UINT		m_nHelp;			// Help context of the message box.

	HICON		m_hIcon;			// Icon to be displayed in the dialog.

	UINT		m_nTimeoutSeconds;	// Seconds for a timeout.
	bool		m_bTimeoutDisabled;	// Flag whether the timeout is disabled.
	UINT_PTR	m_nTimeoutTimer;	// Timer for the timeout.

	CString		m_strRegistryKey;	// Entry for storing the result in the
									// registry, if the MB_DONT_DISPLAY_AGAIN
									// or MB_DONT_ASK_AGAIN flag is given.
	CFont       m_font;
	CFont       m_fontMainInstruction;
	COLORREF    m_clrMainInstructionFont;

private:

	//////////////////////////////////////////////////////////////////////////
	// Control handling types and variables.

	typedef struct tagMSGBOXBTN
	{
		UINT	nID;				// ID of a dialog button.
		UINT	nTitle;				// ID of the title string resource.
	} MSGBOXBTN;

    std::vector<MSGBOXBTN> m_aButtons;
									// List of all buttons in the dialog.

	int			m_nDefaultButton;	// ID of the default button.
	int			m_nEscapeButton;	// ID of the escape button.

	CStatic		m_stcIcon;			// Static control for the icon.
	CStatic		m_stcMessage;		// Static control for the message.
	CToolTipCtrl	m_tooltips;

private:

	//////////////////////////////////////////////////////////////////////////
	// Size handling variables.

	CSize		m_sDialogUnit;		// Variable for the size of a dialog unit.
	CSize		m_sIcon;			// Variable for the size of the icon.
	CSize		m_sMessage;			// Variable for the size of the message.
	CSize		m_sCheckbox;		// Variable for the size of the checkbox.
	CSize		m_sButton;			// Variable for the size of a button.

private:

	//////////////////////////////////////////////////////////////////////////
	// Helper methods.
	
	// Method for generating the registry key.
	CString	GenerateRegistryKey ( );

	// Method for adding a button to the list of buttons.
	void AddButton ( UINT nID, UINT nTitle, bool bIsDefault = false,
		bool bIsEscape = false );

	// Methods for converting a dialog units to a pixel values.
	int XDialogUnitToPixel ( int x );
	int YDialogUnitToPixel ( int y );

	// Method for parsing the given style.
	void ParseStyle ( );

	// Method for creating the icon control.
	void CreateIconControl ( );

	// Method for creating the message control.
	void CreateMessageControl ( );

	// Method for creating the checkbox control.
	void CreateCheckboxControl ( );

	// Method for creating the button controls.
	void CreateButtonControls ( );

	// Method for defining the layout of the dialog.
	void DefineLayout ( );

};
</file>

<file path="Winmerge-Src/Src/Common/multiformatText.cpp">
/////////////////////////////////////////////////////////////////////////////
//    WinMerge:  an interactive diff/merge utility
//    Copyright (C) 1997-2000  Thingamahoochie Software
//    Author: Dean Grimm
//    SPDX-License-Identifier: GPL-2.0-or-later
/////////////////////////////////////////////////////////////////////////////
/**
 * @file multiformatText.cpp
 *
 * @brief Implementation of class storageForPlugins
 *
 * @date  Created: 2003-11-24
 */ 

#include "pch.h"
#define NOMINMAX
#include "multiformatText.h"
#include <algorithm>
#include <cstring>
#include <cassert>
#include <memory>
#include <Poco/SharedMemory.h>
#include <Poco/FileStream.h>
#include <Poco/ByteOrder.h>
#include <Poco/Buffer.h>
#include <Poco/Exception.h>
#include "unicoder.h"
#include "ExConverter.h"
#include "paths.h"
#include "UniFile.h"
#include "codepage_detect.h"
#include "Environment.h"
#include "TFile.h"
#include "Logger.h"

using Poco::SharedMemory;
using Poco::FileOutputStream;
using Poco::ByteOrder;
using Poco::Exception;
using Poco::Buffer;

////////////////////////////////////////////////////////////////////////////////

static void *GetVariantArrayData(VARIANT& array, unsigned& size)
{
	char * parrayData;
	SafeArrayAccessData(array.parray, (void**)&parrayData);
	LONG ubound, lbound;
	SafeArrayGetLBound(array.parray, 1, &lbound);
	SafeArrayGetUBound(array.parray, 1, &ubound);
	size = ubound - lbound;
	return parrayData;
}

void storageForPlugins::Initialize()
{
	SysFreeString(m_bstr);
	m_bstr = nullptr;
	VariantClear(&m_array);
	m_tempFilenameDst.clear();
}

void storageForPlugins::SetDataFileAnsi(const String& filename, bool bOverwrite /*= false*/) 
{
	FileTextEncoding encoding;
	encoding.SetUnicoding(ucr::NONE);
	encoding.SetCodepage(ucr::getDefaultCodepage());
	SetDataFileEncoding(filename, encoding, bOverwrite); 
}
void storageForPlugins::SetDataFileEncoding(const String& filename, const FileTextEncoding& encoding, bool bOverwrite /*= false*/)
{
	m_filename = filename;
	m_nChangedValid = 0;
	m_nChanged = 0;
	if (encoding.m_unicoding != ucr::NONE && encoding.m_unicoding != ucr::UTF8)
		m_bOriginalIsUnicode = m_bCurrentIsUnicode = true;
	else
		m_bOriginalIsUnicode = m_bCurrentIsUnicode = false;
	m_bCurrentIsFile = true;
	m_bOverwriteSourceFile = bOverwrite;
	m_codepage = encoding.m_codepage;
	m_nBomSize = encoding.m_bom ? ucr::getBomSize(encoding.m_unicoding) : 0;
	Initialize();
}
void storageForPlugins::SetDataFileUnknown(const String& filename, bool bOverwrite /*= false*/) 
{
	FileTextEncoding encoding = codepage_detect::Guess(filename, 1);
	SetDataFileEncoding(filename, encoding, bOverwrite);
}

const tchar_t *storageForPlugins::GetDestFileName()
{
	if (m_tempFilenameDst.empty())
	{
		m_tempFilenameDst = env::GetTemporaryFileName(env::GetTemporaryPath(), _T ("_WM"));
		if (!m_tempFileExtensionDst.empty())
		{
			String tempFilenameDstNew = m_tempFilenameDst + m_tempFileExtensionDst;
			try
			{
				TFile(m_tempFilenameDst).renameTo(tempFilenameDstNew);
				m_tempFilenameDst = std::move(tempFilenameDstNew);
			}
			catch (Exception& e)
			{
				RootLogger::Error(e.displayText());
			}
		}
	}
	return m_tempFilenameDst.c_str();
}


void storageForPlugins::ValidateNewFile()
{
	// changed data are : file, nChanged
	// nChanged passed as pointer so already upToDate
	// now update file
	if (m_nChangedValid == m_nChanged)
	{
		// plugin succeeded, but nothing changed, just delete the new file
		try
		{
			TFile(m_tempFilenameDst).remove();
		}
		catch (Exception& e)
		{
			RootLogger::Error(e.displayText());
		}
		// we may reuse the temp filename
		// tempFilenameDst.Empty();
	}
	else
	{
		m_nChangedValid = m_nChanged;
		if (m_bOverwriteSourceFile)
		{
			try
			{
				TFile(m_filename).remove();
				TFile(m_tempFilenameDst).renameTo(m_filename);
			}
			catch (Exception& e)
			{
				RootLogger::Error(e.displayText());
			}
		}
		else
		{
			// do not delete the original file name
			m_filename = m_tempFilenameDst;
			// for next transformation, we may overwrite/delete the source file
			m_bOverwriteSourceFile = true;
		}
		m_tempFilenameDst.erase();
	}
}
void storageForPlugins::ValidateNewBuffer()
{
	// changed data are : buffer, nChanged
	// passed as pointers so already upToDate
	m_nChangedValid = m_nChanged;
}

////////////////////////////////////////////////////////////////////////////////

void storageForPlugins::ValidateInternal(bool bNewIsFile, bool bNewIsUnicode)
{
	assert (m_bCurrentIsFile != bNewIsFile || m_bCurrentIsUnicode != bNewIsUnicode);

	// if we create a file, we remove the remaining previous file 
	if (bNewIsFile)
	{
		if (m_bOverwriteSourceFile)
		{
			try
			{
				TFile(m_filename).remove();
				TFile(m_tempFilenameDst).renameTo(m_filename);
			}
			catch (...)
			{
			}
		}
		else
		{
			// do not delete the original file name
			m_filename = m_tempFilenameDst;
			// for next transformation, we may overwrite/delete the source file
			m_bOverwriteSourceFile = true;
		}
		m_tempFilenameDst.erase();
	}

	// old memory structures are freed
	if (!m_bCurrentIsFile)
		// except if the old data have been in situ replaced by new ones
		if (bNewIsFile || m_bCurrentIsUnicode != bNewIsUnicode)
		{
			if (m_bCurrentIsUnicode)
			{
				SysFreeString(m_bstr);
				m_bstr = nullptr;
			}
			else
				VariantClear(&m_array);
		}

	m_bCurrentIsUnicode = bNewIsUnicode;
	m_bCurrentIsFile = bNewIsFile;
	if (bNewIsUnicode)
	{
		m_codepage = ucr::CP_UCS2LE;
		m_nBomSize = 2;	
	}
	else
	{
		m_codepage = ucr::getDefaultCodepage();
		m_nBomSize = 0;
	}
}

const tchar_t *storageForPlugins::GetDataFileUnicode()
{
	if (m_bCurrentIsFile && m_bCurrentIsUnicode)
		return m_filename.c_str();

	unsigned nchars;
	char * pchar = nullptr;

	try
	{
		{
			std::unique_ptr<SharedMemory> pshmIn;
			// Get source data
			if (m_bCurrentIsFile)
			{
				// Init filedata struct and open file as memory mapped (in file)
				TFile fileIn(m_filename);
				try
				{
					pshmIn.reset(new SharedMemory(fileIn, SharedMemory::AM_READ));
					pchar = pshmIn->begin() + m_nBomSize;
					nchars = static_cast<unsigned>(pshmIn->end() - pchar);
				}
				catch (...)
				{
					if (!fileIn.isDevice() && fileIn.getSize() > 0)
						return nullptr;
					pchar = "";
					nchars = 0;
				}			
			}
			else
			{
				if (m_bCurrentIsUnicode)
				{
					pchar = (char *)m_bstr;
					nchars = SysStringLen(m_bstr) * sizeof(wchar_t);
				}
				else
				{
					pchar = (char *)GetVariantArrayData(m_array, nchars);
				}
			}

			// Compute the dest size (in bytes)
			int textForeseenSize = nchars * sizeof(wchar_t) + 6; // from unicoder.cpp maketstring
			int textRealSize = textForeseenSize;

			// Init filedata struct and open file as memory mapped (out file)
			GetDestFileName();

			TFile fileOut(m_tempFilenameDst);
			fileOut.setSize(textForeseenSize + 2);
			int bom_bytes = 0;
			{
				SharedMemory shmOut(fileOut, SharedMemory::AM_WRITE);
				bom_bytes = ucr::writeBom(shmOut.begin(), ucr::UCS2LE);
				// to UCS-2 conversion, from unicoder.cpp maketstring
				bool lossy;
				textRealSize = ucr::CrossConvert(pchar, nchars, (char *)shmOut.begin()+bom_bytes, textForeseenSize-1, m_codepage, ucr::CP_UCS2LE, &lossy);
			}
			// size may have changed
			fileOut.setSize(textRealSize + bom_bytes);

			// Release pointers to source data
			if (!m_bCurrentIsFile && !m_bCurrentIsUnicode)
				SafeArrayUnaccessData(m_array.parray);

			if ((textRealSize == 0) && (textForeseenSize > 0))
			{
				// conversion error
				try { TFile(m_tempFilenameDst).remove(); } catch (...) {}
				return nullptr;
			}
		}
		ValidateInternal(true, true);
		return m_filename.c_str();
	}
	catch (...)
	{
		return nullptr;
	}
}


BSTR * storageForPlugins::GetDataBufferUnicode()
{
	if (!m_bCurrentIsFile && m_bCurrentIsUnicode)
		return &m_bstr;

	unsigned nchars;
	char * pchar;

	try
	{
		{
			std::unique_ptr<SharedMemory> pshmIn;
			// Get source data
			if (m_bCurrentIsFile) 
			{
				// Init filedata struct and open file as memory mapped (in file)
				TFile fileIn(m_filename);
				try
				{
					pshmIn.reset(new SharedMemory(fileIn, SharedMemory::AM_READ));

					pchar = pshmIn->begin() + m_nBomSize;
					nchars = static_cast<unsigned>(pshmIn->end() - pchar);
				}
				catch (...)
				{
					if (!fileIn.isDevice() && fileIn.getSize() > 0)
						return nullptr;
					pchar = "";
					nchars = 0;
				}			
			}
			else
			{
				pchar = (char *)GetVariantArrayData(m_array, nchars);
			}

			// Compute the dest size (in bytes)
			int textForeseenSize = nchars * sizeof(wchar_t) + 6; // from unicoder.cpp maketstring
			int textRealSize = textForeseenSize;

			// allocate the memory
			auto tempBSTR = std::make_unique<wchar_t[]>(textForeseenSize);

			// fill in the data
			wchar_t * pbstrBuffer = tempBSTR.get();
			bool bAllocSuccess = (pbstrBuffer != nullptr);
			if (bAllocSuccess)
			{
				// to UCS-2 conversion, from unicoder.cpp maketstring
				bool lossy;
				textRealSize = ucr::CrossConvert(pchar, nchars, (char *)pbstrBuffer, textForeseenSize-1, m_codepage, ucr::CP_UCS2LE, &lossy);
				SysFreeString(m_bstr);
				m_bstr = SysAllocStringLen(tempBSTR.get(), textRealSize / sizeof(wchar_t));
				if (m_bstr == nullptr)
					bAllocSuccess = false;
			}

			// Release pointers to source data
			if (!m_bCurrentIsFile && !m_bCurrentIsUnicode)
				SafeArrayUnaccessData(m_array.parray);

			if (!bAllocSuccess)
				return nullptr;
		}
		ValidateInternal(false, true);
		return &m_bstr;
	}
	catch (...)
	{
		return nullptr;
	}
}

const tchar_t *storageForPlugins::GetDataFileAnsi()
{
	if (m_bCurrentIsFile && !m_bCurrentIsUnicode)
		return m_filename.c_str();

	unsigned nchars;
	char * pchar = nullptr;

	try
	{
		{
			std::unique_ptr<SharedMemory> pshmIn;
			// Get source data
			if (m_bCurrentIsFile)
			{
				// Init filedata struct and open file as memory mapped (in file)
				TFile fileIn(m_filename);
				try
				{
					pshmIn.reset(new SharedMemory(fileIn, SharedMemory::AM_READ));

					pchar = pshmIn->begin()+m_nBomSize; // pass the BOM
					nchars = static_cast<unsigned>(pshmIn->end() - pchar);
				}
				catch (...)
				{
					if (!fileIn.isDevice() && fileIn.getSize() > 0)
						return nullptr;
					pchar = "";
					nchars = 0;
				}
			}
			else 
			{
				if (m_bCurrentIsUnicode)
				{
					pchar  = (char *)m_bstr;
					nchars = SysStringLen(m_bstr) * sizeof(wchar_t);
				}
				else
				{
					pchar = (char *)GetVariantArrayData(m_array, nchars);
				}
			}

			// Compute the dest size (in bytes)
			int textForeseenSize = nchars; 
			if (m_bCurrentIsUnicode)
				textForeseenSize = nchars * 3; // from unicoder.cpp convertToBuffer
			int textRealSize = textForeseenSize;

			// Init filedata struct and open file as memory mapped (out file)
			GetDestFileName();
			TFile fileOut(m_tempFilenameDst);
			fileOut.setSize(textForeseenSize);
			if (textForeseenSize > 0)
			{
				SharedMemory shmOut(fileOut, SharedMemory::AM_WRITE);

				if (m_bCurrentIsUnicode)
				{
					// UCS-2 to Ansi conversion, from unicoder.cpp convertToBuffer
					bool lossy;
					textRealSize = ucr::CrossConvert(pchar, nchars, (char *)shmOut.begin(), textForeseenSize, m_codepage, ucr::getDefaultCodepage(), &lossy);
				}
				else
				{
					std::memcpy(shmOut.begin(), pchar, nchars);
				}
			}
			// size may have changed
			fileOut.setSize(textRealSize);

			// Release pointers to source data
			if (!m_bCurrentIsFile && !m_bCurrentIsUnicode)
				SafeArrayUnaccessData(m_array.parray);

			if ((textRealSize == 0) && (textForeseenSize > 0))
			{
				// conversion error
				try { TFile(m_tempFilenameDst).remove(); } catch (...) {}
				return nullptr;
			}
		}
		ValidateInternal(true, false);
		return m_filename.c_str();
	}
	catch (...)
	{
		return nullptr;
	}
}


VARIANT * storageForPlugins::GetDataBufferAnsi()
{
	if (!m_bCurrentIsFile && !m_bCurrentIsUnicode)
		return &m_array;

	unsigned nchars;
	char * pchar;

	try
	{
		{
			std::unique_ptr<SharedMemory> pshmIn;
			// Get source data
			if (m_bCurrentIsFile) 
			{
				// Init filedata struct and open file as memory mapped (in file)
				TFile fileIn(m_filename);
				pshmIn.reset(new SharedMemory(fileIn, SharedMemory::AM_READ));

				pchar = pshmIn->begin() + m_nBomSize;
				nchars = static_cast<unsigned>(pshmIn->end() - pchar);
			}
			else
			{
				pchar  = (char *)m_bstr;
				nchars = SysStringLen(m_bstr) * sizeof(wchar_t);
			}

			// Compute the dest size (in bytes)
			int textForeseenSize = nchars; 
			if (m_bCurrentIsUnicode)
				textForeseenSize = nchars * 3; // from unicoder.cpp convertToBuffer
			int textRealSize = textForeseenSize;

			// allocate the memory
			SAFEARRAYBOUND rgsabound = {static_cast<ULONG>(textForeseenSize), 0};
			m_array.vt = VT_UI1 | VT_ARRAY;
			m_array.parray = SafeArrayCreate(VT_UI1, 1, &rgsabound);
			char * parrayData;
			SafeArrayAccessData(m_array.parray, (void**)&parrayData);

			// fill in the data
			if (m_bCurrentIsUnicode)
			{
				// to Ansi conversion, from unicoder.cpp convertToBuffer
				bool lossy;
				textRealSize = ucr::CrossConvert(pchar, nchars, (char *)parrayData, textForeseenSize, m_codepage, ucr::getDefaultCodepage(), &lossy);
			}
			else
			{
				std::memcpy(parrayData, pchar, nchars);
			}
			// size may have changed
			SafeArrayUnaccessData(m_array.parray);
			SAFEARRAYBOUND rgsaboundnew = {static_cast<ULONG>(textRealSize), 0};
			SafeArrayRedim(m_array.parray, &rgsaboundnew);
		}
		ValidateInternal(false, false);
		return &m_array;
	}
	catch (...)
	{
		return nullptr;
	}
}

template<typename T, bool flipbytes>
inline const T *findNextLine(const T *pstart, const T *pend)
{
	for (const T *p = pstart; p < pend; ++p)
	{
		int ch = flipbytes ? ByteOrder::flipBytes(*p) : *p;
		if (ch == '\n')
			return p + 1;
		else if (ch == '\r')
		{
			if (p + 1 < pend && *(p + 1) == (flipbytes ? ByteOrder::flipBytes('\n') : '\n'))
				return p + 2;
			else
				return p + 1;
		}
	}
	return pend;
}

static const char *findNextLine(ucr::UNICODESET unicoding, const char *pstart, const char *pend)
{
	switch (unicoding)
	{
	case ucr::UCS2LE:
		return (const char *)findNextLine<unsigned short, false>((const unsigned short *)pstart, (const unsigned short *)pend);
	case ucr::UCS2BE:
		return (const char *)findNextLine<unsigned short, true>((const unsigned short *)pstart, (const unsigned short *)pend);
	default:
		return findNextLine<char, false>(pstart, pend);
	}
}

bool AnyCodepageToUTF8(int codepage, const String& filepath, const String& filepathDst, int & nFileChanged, bool bWriteBOM)
{
	UniMemFile ufile;
	if (!ufile.OpenReadOnly(filepath))
		return true;
	ufile.ReadBom();
	ucr::UNICODESET unicoding = ufile.GetUnicoding();
	// Finished with examing file contents
	ufile.Close();

	TFile fileIn(filepath);
	try
	{
		// Init filedataIn struct and open file as memory mapped (input)
		SharedMemory shmIn(fileIn, SharedMemory::AM_READ);

		IExconverter *pexconv = Exconverter::getInstance();

		char * pszBuf = shmIn.begin();
		size_t nBufSize = shmIn.end() - shmIn.begin();
		size_t nSizeOldBOM = 0;
		switch (unicoding)
		{
		case ucr::UTF8:
			nSizeOldBOM = 3;
			break;
		case ucr::UCS2LE:
		case ucr::UCS2BE:
			nSizeOldBOM = 2;
			break;
		}

		const size_t minbufsize = 128 * 1024;

		// create the destination file
		FileOutputStream fout(ucr::toUTF8(filepathDst), std::ios::out|std::ios::binary|std::ios::trunc);
		Buffer<char> obuf(minbufsize);
		int64_t pos = nSizeOldBOM;

		// write BOM
		if (bWriteBOM)
		{
			char bom[4];
			fout.write(bom, ucr::writeBom(bom, ucr::UTF8));
		}

		// write data
		for (;;)
		{
			size_t srcbytes = findNextLine(unicoding, pszBuf + pos + minbufsize, pszBuf + nBufSize) - (pszBuf + pos);
			if (srcbytes == 0)
				break;
			if (srcbytes * 3 > obuf.size())
				obuf.resize(srcbytes * 3 * 2, false);
			size_t destbytes = obuf.size();
			if (pexconv != nullptr)
			{
				size_t srcbytes2 = srcbytes;
				if (!pexconv->convert(codepage, ucr::CP_UTF_8, (const unsigned char *)pszBuf+pos, &srcbytes2, (unsigned char *)obuf.begin(), &destbytes))
					throw "failed to convert file contents to utf-8";
			}
			else
			{
				bool lossy = false;
				destbytes = ucr::CrossConvert((const char *)pszBuf+pos, static_cast<unsigned>(srcbytes), obuf.begin(), static_cast<unsigned>(destbytes), codepage, ucr::CP_UTF_8, &lossy);
			}
			fout.write(obuf.begin(), destbytes);
			pos += srcbytes;
		}

		nFileChanged ++;
		return true;
	}
	catch (...)
	{
		if (fileIn.getSize() == 0)
			return true;
		return false;
	}
}

</file>

<file path="Winmerge-Src/Src/Common/multiformatText.h">
/** 
 * @file  multiformatText.h
 *
 * @brief Declaration file for class storageForPlugins
 *
 * @date  Created: 2003-11-24
 */
#pragma once

#include "UnicodeString.h"
#include "unicoder.h"
#include "FileTextEncoding.h"
#include <windows.h>
#include <oleauto.h>

/**
 * @brief Storage for data to be processed by plugins. May return data
 * as file or buffer, as ansi or unicode. 
 * First you must load some file into the object. "data" is the content of this
 * file. May be text text (then you may convert ansi<->unicode), or anything.
 * Final save : for text, the format ansi/unicode is the same as the original file.
 *
 * @todo : export final save as UTF-8 for unicode optimization (avoid save+reload the file)
 */
class storageForPlugins
{
public:
	storageForPlugins()
	: m_bstr(nullptr)
	, m_bOriginalIsUnicode(false)
	, m_bCurrentIsUnicode(false)
	, m_bCurrentIsFile(false)
	, m_bOverwriteSourceFile(false)
	, m_nChangedValid(0)
	, m_bError(false)
	, m_codepage(0)
	, m_nBomSize(0)
	, m_nChanged(0)
	{
		VariantInit(&m_array);
	}

	~storageForPlugins()
	{
		if (!m_tempFilenameDst.empty()) // "!m_tempFilenameDst" means "never"
			::DeleteFile(m_tempFilenameDst.c_str());
		if (m_bstr != nullptr)
			SysFreeString(m_bstr);
		VariantClear(&m_array);
	}

	/// Get data as unicode buffer (BSTR)
	BSTR * GetDataBufferUnicode();
	/// Get data as ansi buffer (safearray of unsigned char)
	VARIANT * GetDataBufferAnsi();
	/// Get data as file (saved as UCS-2 with BOM)
	const tchar_t *GetDataFileUnicode();
	/// Get data as file (saved as Ansi)
	const tchar_t *GetDataFileAnsi();
	/// Get a temporary filename, to be used to save the transformed data 
	const tchar_t *GetDestFileName();
	/// validation for data retrieved by GetDataFileAnsi/GetDataFileUnicode
	void ValidateNewFile();
	/// validation for data retrieved by GetDataBufferAnsi/GetDataBufferUnicode
	void ValidateNewBuffer();

	/// Initial load
	void SetDataFileUnknown(const String& filename, bool bOverwrite = false);
	/// Set codepage to use for ANSI<->UNICODE conversions
	void SetCodepage(int code) { m_codepage = code; };
	/// Initial load
	void SetDataFileAnsi(const String& filename, bool bOverwrite = false);
	/// Initial load
	void SetDataFileEncoding(const String& filename, const FileTextEncoding& encoding, bool bOverwrite = false);
	/// Final save, same format as the original file
	bool SaveAsFile(String & filename)
	{
		const tchar_t *newFilename;
		if (m_bOriginalIsUnicode)
			newFilename = GetDataFileUnicode();
		else
			newFilename = GetDataFileAnsi();
		if (newFilename == nullptr)
		{
			GetLastValidFile(filename);
			return false;
		}
		filename = newFilename;
		return true;
	}
	/// Get the last valid file after an error
	/// Warning : the format may be different from the original one
	void GetLastValidFile(String & filename)
	{
		if (!m_tempFilenameDst.empty())
			::DeleteFile(m_tempFilenameDst.c_str());
		m_tempFilenameDst.erase();
		filename = this->m_filename;
	}

	/// return number of transformation until now
	int & GetNChanged() { return m_nChanged; };
	/// return number of valid transformation until now
	int & GetNChangedValid() { return m_nChangedValid; }
	/// return format of original data
	bool GetOriginalMode() const { return m_bOriginalIsUnicode; }
	const String GetDestFileExtension() const { return m_tempFileExtensionDst; }
	void SetDestFileExtension(const String& ext) { if (!ext.empty() && ext.back() != '/') m_tempFileExtensionDst = ext; }

private:
	void Initialize();
	void ValidateInternal(bool bNewIsFile, bool bNewIsUnicode);

// Implementation data
private:
	// original data mode ANSI/UNICODE
	bool m_bOriginalIsUnicode;

	// current format of data : BUFFER/FILE, ANSI/UNICODE
	bool m_bCurrentIsUnicode;
	bool m_bCurrentIsFile;
	// can we overwrite the current file (different from original file when nChangedValid>=1)
	bool m_bOverwriteSourceFile;	
	// number of valid transformation since load
	int m_nChangedValid;
	// data storage when mode is BUFFER UNICODE
	BSTR m_bstr;
	// data storage when mode is BUFFER ANSI
	VARIANT m_array;
	// data storage when mode is FILE
	String m_filename;
	// error during conversion ?
	bool m_bError;
	// codepage for ANSI mode
	int m_codepage;
	// BOM size
	int m_nBomSize;

	// temporary number of transformations, transformed by caller
	int m_nChanged;
	// temporary destination filename
	String m_tempFilenameDst;
	// temporary destination file extension
	String m_tempFileExtensionDst;
};


// other conversion functions

/// Convert file to UTF-8 (for diffutils)
bool AnyCodepageToUTF8(int codepage, const String& filepath, const String& filepathDst, int & nFileChanged, bool bWriteBOM);
</file>

<file path="Winmerge-Src/Src/Common/OptionsMgr.cpp">
/** 
 * @file OptionsMgr.cpp
 *
 * @brief Implementation of Options management classes
 *
 */


/* The MIT License
Copyright (c) 2004-2009 Kimmo Varis
Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files
(the "Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:
The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

#include "pch.h"
#include "OptionsMgr.h"
#include "UniFile.h"
#include <algorithm>
#include <cassert>
#include <windows.h>

constexpr int MAX_PATH_FULL = 32767;

static bool GetAsInt(const String& str, int & val);

varprop::VariantValue COptionsMgr::m_emptyValue;

/**
 * @brief Default constructor.
 */
COption::COption() = default;

/**
 * @brief Copy constructor.
 * @param [in] option Object to copy.
 */
COption::COption(const COption& option)
: m_strName(option.m_strName)
, m_value(option.m_value)
, m_valueDef(option.m_valueDef)
{
}

/**
 * @brief Assignment operator override.
 * @param [in] option Object to copy.
 * @return Copy of given object.
 */
COption& COption::operator=(const COption& option)
{
	if (this != &option)
	{
		m_strName = option.m_strName;
		m_value = option.m_value;
		m_valueDef = option.m_valueDef;
	}
	return *this;
}

/**
 * @brief Set name, value and default value for option
 * @param [in] name Name of option with full path ("Settings/AutomaticRescan")
 * @param [in] defaultValue Default value for option. This value
 * is restored for otion when Reset() is run.
 * @sa COption::Reset()
 */
int COption::Init(const String& name, const varprop::VariantValue& defaultValue)
{
	int retVal = COption::OPT_OK;

	m_strName = name;
	if (m_strName.empty())
		return OPT_ERR;

	// Dont' check type here since we are initing it!
	varprop::VT_TYPE inType = defaultValue.GetType();

	switch (inType)
	{
	case varprop::VT_NULL:
		retVal = OPT_UNKNOWN_TYPE;
		break;
	case varprop::VT_BOOL:
		m_value.SetBool(defaultValue.GetBool());
		m_valueDef.SetBool(defaultValue.GetBool());
		break;
	case varprop::VT_INT:
		m_value.SetInt(defaultValue.GetInt());
		m_valueDef.SetInt(defaultValue.GetInt());
		break;
	case varprop::VT_FLOAT:
		m_value.SetFloat(defaultValue.GetFloat());
		m_valueDef.SetFloat(defaultValue.GetFloat());
		break;
	case varprop::VT_STRING:
		m_value.SetString(defaultValue.GetString());
		m_valueDef.SetString(defaultValue.GetString());
		break;
	case varprop::VT_TIME:
		m_value.SetTime(defaultValue.GetTime());
		m_valueDef.SetTime(defaultValue.GetTime());
		break;
	default:
		retVal = OPT_UNKNOWN_TYPE;
	}
	return retVal;
}

/**
 * @brief Convert string to integer.
 * @param [in] str String to convert.
 * @param [out] val Converted integer.
 * @return true if conversion succeeded, false otherwise.
 */
static bool GetAsInt(const String& str, int & val)
{
	if (str.empty())
		return false;
	const size_t len = str.length();

	val = 0;
	for (int i = 0; i < (int)len; ++i)
	{
		int ch = (int)str[i];
		if (ch < '0' || ch > '9')
			return false;
		val *= 10;
		val += ch - '0';
	}
	return true;
}

/**
 * @brief Convert integer value to desired type.
 * @param [in, out] value Value to convert.
 * @param [in] nType Type to convert to.
 * @return true if conversion succeeded, false otherwise.
 * @note Only supports converting to boolean at the moment.
 * @todo Add other conversions (string?).
  */
bool COption::ConvertInteger(varprop::VariantValue & value, varprop::VT_TYPE nType)
{
	int ivalue = value.GetInt();

	switch(nType)
	{
	case varprop::VT_BOOL:
		// Convert integer to boolean
		{
			if (ivalue > 0)
			{
				value.SetBool(true);
				return true;
			}
			else
			{
				value.SetBool(false);
				return true;
			}
		}
	}
	return false;
}

/**
 * @brief Convert string value to desired type.
 * @param [in, out] value Value to convert.
 * @param [in] nType Type to convert to.
 * @return true if conversion succeeded, false otherwise.
 * @note Only supports converting to integer and boolean at the moment.
 * @todo Add other conversions (float?).
  */
bool COption::ConvertString(varprop::VariantValue & value, varprop::VT_TYPE nType)
{
	String svalue = value.GetString();
	switch(nType)
	{
	case varprop::VT_INT:
		// Convert string to integer
		{
			int val=0;
			if (!GetAsInt(svalue, val))
				return false;
			value.SetInt(val);
			return true;
		}
	case varprop::VT_BOOL:
		// Convert string to boolean
		{
			svalue = strutils::makelower(svalue);
			if (svalue == _T("1") || svalue == _T("yes")
				|| svalue == _T("true"))
			{
				value.SetBool(true);
				return true;
			}
			if (svalue == _T("0") || svalue == _T("no")
				|| svalue == _T("false"))
			{
				value.SetBool(false);
				return true;
			}
			return false;
		}
	}
	return false;
}

/**
 * @brief Convert value to desired type.
 * @param [in, out] value Value to convert.
 * @param [in] nType Type to convert to.
 * @return true if conversion succeeded, false otherwise.
 * @note Currently converts only strings and integers.
 * @todo Add other conversions.
 */
bool COption::ConvertType(varprop::VariantValue & value, varprop::VT_TYPE nType)
{
	if (value.GetType() == varprop::VT_STRING)
		return ConvertString(value, nType);
	if (value.GetType() == varprop::VT_INT)
		return ConvertInteger(value, nType);
	return false;
}

/**
 * @brief Set option value.
 * 
 * Set new value for option. If automatic conversion is not allowed,
 * type of value must match to type set when option was initialised.
 * @param [in] value New value to set.
 * @param [in] allowConversion Is automatic type conversion allowed?
 * @sa COption::Init()
 */
int COption::Set(const varprop::VariantValue& value, bool allowConversion)
{
	int retVal = COption::OPT_OK;

	// Check that type matches
	varprop::VT_TYPE inType = value.GetType();
	if (value.GetType() != m_value.GetType())
	{
		if (allowConversion)
		{
			varprop::VariantValue val(value);
			if (ConvertType(val, m_value.GetType()))
				return Set(val);
		}
		return COption::OPT_WRONG_TYPE;
	}

	switch (inType)
	{
	case varprop::VT_NULL:
		retVal = OPT_UNKNOWN_TYPE;
		break;
	case varprop::VT_BOOL:
		m_value.SetBool(value.GetBool());
		break;
	case varprop::VT_INT:
		m_value.SetInt(value.GetInt());
		break;
	case varprop::VT_FLOAT:
		m_value.SetFloat(value.GetFloat());
		break;
	case varprop::VT_STRING:
		m_value.SetString(value.GetString());
		break;
	case varprop::VT_TIME:
		m_value.SetTime(value.GetTime());
		break;
	default:
		retVal = OPT_UNKNOWN_TYPE;
	}
	return retVal;
}

/**
 * @brief Change default value for option.
 *
 * Set new value for option default value.  If automatic conversion is not
 * allowed, type of value must match to type set when option was initialised.
 * @param [in] defaultValue New default value.
 * @sa COption::Init()
 */
int COption::SetDefault(const varprop::VariantValue& defaultValue)
{
	int retVal = COption::OPT_OK;

	// Check that type matches
	varprop::VT_TYPE inType = defaultValue.GetType();
	if (inType != m_valueDef.GetType())
	{
		return COption::OPT_WRONG_TYPE;
	}

	switch (inType)
	{
	case varprop::VT_NULL:
		retVal = OPT_UNKNOWN_TYPE;
		break;
	case varprop::VT_BOOL:
		m_valueDef.SetBool(defaultValue.GetBool());
		break;
	case varprop::VT_INT:
		m_valueDef.SetInt(defaultValue.GetInt());
		break;
	case varprop::VT_FLOAT:
		m_valueDef.SetFloat(defaultValue.GetFloat());
		break;
	case varprop::VT_STRING:
		m_valueDef.SetString(defaultValue.GetString());
		break;
	case varprop::VT_TIME:
		m_valueDef.SetTime(defaultValue.GetTime());
		break;
	default:
		retVal = OPT_UNKNOWN_TYPE;
	}
	return retVal;
}

/**
 * @brief Reset option's value to default value.
 */
void COption::Reset()
{
	switch (m_value.GetType())
	{
	case varprop::VT_BOOL:
		m_value.SetBool(m_valueDef.GetBool());
		break;
	case varprop::VT_INT:
		m_value.SetInt(m_valueDef.GetInt());
		break;
	case varprop::VT_FLOAT:
		m_value.SetFloat(m_valueDef.GetFloat());
		break;
	case varprop::VT_STRING:
		m_value.SetString(m_valueDef.GetString());
		break;
	case varprop::VT_TIME:
		m_value.SetTime(m_valueDef.GetTime());
		break;
	case varprop::VT_NULL:
		// Do nothing for VT_NULL
		break;
	default:
		// Do nothing for unknown types
		break;
	}
}

/**
 * @brief Add new option to list.
 * @param [in] name Option's name.
 * @param [in] defaultValue Option's initial and default value.
 */
int COptionsMgr::AddOption(const String& name, const varprop::VariantValue& defaultValue)
{
	COption tmpOption;
	int retVal = tmpOption.Init(name, defaultValue);
	if (retVal == COption::OPT_OK)
		m_optionsMap.insert_or_assign(name, tmpOption);

	return retVal;
}

int COptionsMgr::InitOption(const String& name, int defaultValue, int minValue, int maxValue, bool serializable)
{
	int retVal = InitOption(name, defaultValue, serializable);
	if (retVal == COption::OPT_OK)
	{
		int ival = GetInt(name);
		if (ival < minValue || ival > maxValue)
			Reset(name);
	}
	return retVal;
}

/**
 * @brief Get option value from list by name.
 * @param [in] name Name of the option to get.
 * @return Option's value as variant type.
 */
const varprop::VariantValue& COptionsMgr::Get(const String& name) const
{
	OptionsMap::const_iterator found = m_optionsMap.find(name);
	if (found != m_optionsMap.end())
	{
		return found->second.Get();
	}
	return m_emptyValue;
}

/**
 * @brief Return string option value.
 * @param [in] name Option's name.
 */
const String& COptionsMgr::GetString(const String& name) const
{
	return Get(name).GetString();
}

/**
 * @brief Return integer option value.
 * @param [in] name Option's name.
 */
int COptionsMgr::GetInt(const String& name) const
{
	return Get(name).GetInt();
}

/**
 * @brief Return boolean option value
 * @param [in] name Option's name.
 */
bool COptionsMgr::GetBool(const String& name) const
{
	return Get(name).GetBool();
}

/**
 * @brief Set new value for option.
 * @param [in] name Option's name.
 * @param [in] value Option's new value.
 */
int COptionsMgr::Set(const String& name, const varprop::VariantValue& value)
{
	int retVal = COption::OPT_OK;

	OptionsMap::const_iterator found = m_optionsMap.find(name);
	if (found != m_optionsMap.end())
	{
		// Allow automatic conversion so we don't bother callsites about this!
		COption tmpOption = found->second;
		retVal = tmpOption.Set(value, true);
		if (retVal == COption::OPT_OK)
			m_optionsMap.insert_or_assign(name, tmpOption);
	}
	else
	{
		retVal = COption::OPT_NOTFOUND;
	}
	return retVal;
}

/**
 * @brief Set new value for boolean option.
 * @param [in] name Option's name.
 * @param [in] value Option's new value.
 */
int COptionsMgr::Set(const String& name, bool value)
{
	varprop::VariantValue valx;
	valx.SetBool(value);
	return Set(name, valx);
}

/**
 * @brief Set new value for integer option.
 * @param [in] name Option's name.
 * @param [in] value Option's new value.
 */
int COptionsMgr::Set(const String& name, int value)
{
	varprop::VariantValue valx;
	valx.SetInt(value);
	return Set(name, valx);
}

/**
 * @brief Set new value for string option.
 * @param [in] name Option's name.
 * @param [in] value Option's new value.
 */
int COptionsMgr::Set(const String& name, const String& value)
{
	varprop::VariantValue valx;
	valx.SetString(value);
	return Set(name, valx);
}

/**
 * @brief Set new value for string option.
 * @param [in] name Option's name.
 * @param [in] value Option's new value.
 */
int COptionsMgr::Set(const String& name, const tchar_t *value)
{
	return Set(name, String(value));
}

/**
 * @brief Type-convert and forward to SaveOption(String, int)
 * @param [in] name Option's name.
 * @param [in] value Option's new value.
 */
int COptionsMgr::SaveOption(const String& name, unsigned value)
{
	int xvalue = value;
	return SaveOption(name, xvalue);
}

/**
 * @brief Remove option from options list.
 * @param [in] name Name of the option to remove.
 */
int COptionsMgr::RemoveOption(const String& name)
{
	int retVal = COption::OPT_OK;

	OptionsMap::const_iterator found = m_optionsMap.find(name);
	if (found != m_optionsMap.end())
	{
		size_t nr_removed = m_optionsMap.erase(name);
		if (nr_removed == 0)
			retVal = COption::OPT_NOTFOUND;
	}
	else
		retVal = COption::OPT_NOTFOUND;

	return retVal;
}

/**
 * @brief Reset option value to default.
 * @param [in] name Name of the option to reset.
 */
int COptionsMgr::Reset(const String& name)
{
	int retVal = COption::OPT_OK;

	OptionsMap::const_iterator found = m_optionsMap.find(name);
	if (found != m_optionsMap.end())
	{
		COption tmpOption = found->second;
		tmpOption.Reset();
		m_optionsMap.insert_or_assign(name, tmpOption);
	}
	else
	{
		retVal = COption::OPT_NOTFOUND;
	}
	return retVal;
}

/**
 * @brief Return default string value.
 * @param [in] name Option's name.
 * @param [out] value Option's default value.
 */
int COptionsMgr::GetDefault(const String& name, String & value) const
{
	int retVal = COption::OPT_OK;

	OptionsMap::const_iterator found = m_optionsMap.find(name);
	if (found != m_optionsMap.end())
	{
		varprop::VariantValue val = found->second.GetDefault();
		if (val.IsString())
			value = val.GetString();
		else
			retVal = COption::OPT_WRONG_TYPE;
	}
	else
	{
		retVal = COption::OPT_NOTFOUND;
	}
	return retVal;
}

/**
 * @brief Return default number value
 * @param [in] name Option's name.
 * @param [out] value Option's default value.
 */
int COptionsMgr::GetDefault(const String& name, unsigned & value) const
{
	int retVal = COption::OPT_OK;

	OptionsMap::const_iterator found = m_optionsMap.find(name);
	if (found != m_optionsMap.end())
	{
		varprop::VariantValue val = found->second.GetDefault();
		if (val.IsInt())
			value = val.GetInt();
		else
			retVal = COption::OPT_WRONG_TYPE;
	}
	else
	{
		retVal = COption::OPT_NOTFOUND;
	}
	return retVal;
}

/**
 * @brief Return default boolean value
 * @param [in] name Option's name.
 * @param [out] value Option's default value.
 */
int COptionsMgr::GetDefault(const String& name, bool & value) const
{
	int retVal = COption::OPT_OK;

	OptionsMap::const_iterator found = m_optionsMap.find(name);
	if (found != m_optionsMap.end())
	{
		varprop::VariantValue val = found->second.GetDefault();
		if (val.IsBool())
			value = val.GetBool();
		else
			retVal = COption::OPT_WRONG_TYPE;
	}
	else
	{
		retVal = COption::OPT_NOTFOUND;
	}
	return retVal;
}

String COptionsMgr::ExpandShortName(const String& shortname) const
{
	int nmatched = 0;
	String matchedkey;
	for (const auto& it : m_optionsMap)
	{
		if (it.first.find(shortname) != String::npos)
		{
			matchedkey = it.first;
			++nmatched;
		}
	}
	return (nmatched == 1) ? matchedkey : _T("");
}

/**
 * @brief Export options to file.
 *
 * This function enumerates through our options storage and saves
 * every option name and value to file.
 *
 * @param [in] filename Filename where optios are written.
 * @return
 * - COption::OPT_OK when succeeds
 * - COption::OPT_ERR when writing to the file fails
 */
int COptionsMgr::ExportOptions(const String& filename, const bool bHexColor /*= false*/) const
{
	int retVal = COption::OPT_OK;
	OptionsMap::const_iterator optIter = m_optionsMap.begin();
	while (optIter != m_optionsMap.end() && retVal == COption::OPT_OK)
	{
		const String name(optIter->first);
		String strVal, strType;
		varprop::VariantValue value = optIter->second.Get();
		if (value.GetType() == varprop::VT_BOOL)
		{
			strType = _T("bool");
			if (value.GetBool())
				strVal = _T("1");
			else
				strVal = _T("0");
		}
		else if (value.GetType() == varprop::VT_INT)
		{
			strType = _T("int");
			if ( bHexColor && (strutils::makelower(name).find(String(_T("color"))) != std::string::npos) )
				strVal = strutils::format(_T("0x%06x"), value.GetInt());
			else
				strVal = strutils::to_str(value.GetInt());
		}
		else if (value.GetType() == varprop::VT_STRING)
		{
			strType = _T("string");
			strVal = EscapeValue(value.GetString());
		}

		// https://learn.microsoft.com/en-us/answers/questions/578134/error-in-writeprivateprofilestring-function-when-j
		bool bRet = !!WritePrivateProfileString(_T("WinMerge"), name.c_str(),
				nullptr, filename.c_str());
		if (!bRet)
			retVal = COption::OPT_ERR;
		bRet = !!WritePrivateProfileString(_T("WinMerge"), name.c_str(),
				strVal.c_str(), filename.c_str());
		if (!bRet)
			retVal = COption::OPT_ERR;
		bRet = !!WritePrivateProfileString(_T("WinMerge.TypeInfo"), name.c_str(),
				strType.c_str(), filename.c_str());
		if (!bRet)
			retVal = COption::OPT_ERR;
		++optIter;
	}
	return retVal;
}

/**
 * @brief Import options from file.
 *
 * This function reads options values and names from given file and
 * updates values to our options storage. If valuename does not exist
 * already in options storage its is not created.
 *
 * @param [in] filename Filename where optios are written.
 * @return
 * - COption::OPT_OK when succeeds
 * - COption::OPT_NOTFOUND if file wasn't found or didn't contain values
 */
int COptionsMgr::ImportOptions(const String& filename)
{
	int retVal = COption::OPT_OK;
	auto oleTranslateColor = [](unsigned color) -> unsigned { return ((color & 0xffffff00) == 0x80000000) ? GetSysColor(color & 0x000000ff) : color; };

	// Query keys - returns NUL separated strings
	auto iniFileKeyValues = ReadIniFile(filename, _T("WinMerge"));
	if (iniFileKeyValues.empty())
		return COption::OPT_NOTFOUND;

	for (auto& [key, strValue] : iniFileKeyValues)
	{
		varprop::VariantValue value = Get(key);

		if (value.GetType() == varprop::VT_BOOL)
		{
			value.SetBool(tc::ttoi(strValue.c_str()) != 0);
		}
		else if (value.GetType() == varprop::VT_INT)
		{
			tchar_t* endptr = nullptr;
			unsigned uval = static_cast<unsigned>(tc::tcstoll(strValue.c_str(), &endptr,
				(strValue.length() >= 2 && strValue[1] == 'x') ? 16 : 10));
			int intVal = static_cast<int>(uval);
			if (strutils::makelower(key).find(String(_T("color"))) != std::string::npos)
				intVal = static_cast<int>(oleTranslateColor(static_cast<unsigned>(intVal)));
			value.SetInt(intVal);
		}
		else if (value.GetType() == varprop::VT_STRING)
		{
			value.SetString(strValue);
		}

		if (value.GetType() != varprop::VT_NULL)
			SaveOption(key, value);
	}
	FlushOptions();
	return retVal;
}

String COptionsMgr::EscapeValue(const String& text)
{
	String text2;
	for (size_t i = 0; i < text.length(); ++i)
	{
		tchar_t ch = text[i];
		if (ch == '\0' || ch == '\x1b' || ch == '\r' || ch == '\n')
		{
			text2 += '\x1b';
			text2 += ch + '@';
		}
		else
			text2 += ch;
	}
	return text2;
}

String COptionsMgr::UnescapeValue(const String& text)
{
	if (text.find('\x1b') == String::npos)
		return text;
	String text2;
	for (size_t i = 0; i < text.length(); ++i)
	{
		if (text[i] == '\x1b' && i < text.length() - 1)
		{
			++i;
			text2 += text[i] - '@';
		}
		else
			text2 += text[i];
	}
	return text2;
}

/**
 * @brief Split option name to path (in registry) and
 * valuename (in registry).
 *
 * Option names are given as "full path", e.g. "Settings/AutomaticRescan".
 * This function splits that to path "Settings/" and valuename
 * "AutomaticRescan".
 * @param [in] strName Option name
 * @param [out] srPath Path (key) in registry
 * @param [out] strValue Value in registry
 */
std::pair<String, String> COptionsMgr::SplitName(const String& strName)
{
	String strValue, strPath;
	size_t pos = strName.rfind('/');
	if (pos != String::npos)
	{
		size_t len = strName.length();
		strValue = strName.substr(pos + 1, len - pos - 1); //Right(len - pos - 1);
		strPath = strName.substr(0, pos);  //Left(pos);
	}
	else
	{
		strValue = strName;
		strPath.erase();
	}
	return { strPath, strValue };
}

std::map<String, String> COptionsMgr::ReadIniFile(const String& filename, const String& section)
{
	std::map<String, String> iniFileKeyValues;
	UniMemFile file;
	if (!file.OpenReadOnly(filename))
		return {};
	file.ReadBom();
	String line, eol;
	bool lossy = false;
	bool inTargetSection = false;
	while (file.ReadString(line, eol, &lossy))
	{
		auto itBegin = std::find_if(line.begin(), line.end(), [](int ch) {
			return !tc::istspace(static_cast<wint_t>(ch)); });

		// Skip empty lines or lines starting with a comment
		if (itBegin == line.end() || *itBegin == ';')
			continue;

		if (*itBegin == '[' && line.back() == ']')
		{
			// section
			String currentSection = line.substr(itBegin - line.begin() + 1, line.end() - itBegin - 2);
			inTargetSection = (currentSection == section);
			continue;
		}

		if (!inTargetSection)
			continue;
		
		std::size_t equalsPos = line.find('=');
		if (equalsPos == String::npos)
			continue;
		
		iniFileKeyValues.insert_or_assign(
			/* key */line.substr(itBegin - line.begin(), equalsPos - (itBegin - line.begin())),
			/* value */ UnescapeValue(line.substr(equalsPos + 1)));
	}
	file.Close();
	return iniFileKeyValues;
}

</file>

<file path="Winmerge-Src/Src/Common/OptionsMgr.h">
/** 
 * @file OptionsMgr.h
 *
 * @brief Interface for Options management classes
 *
 */

/* The MIT License
Copyright (c) 2004-2009 Kimmo Varis
Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files
(the "Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:
The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

#pragma once

#include <map>
#include <vector>
#include "UnicodeString.h"
#include "varprop.h"

/**
 * @brief Class to store option name, value and default value.
 */
class COption
{
public:
	/**
	* @brief Return values for functions.
	*/
	enum
	{
		OPT_OK				= 0, /**< All good. */
		OPT_ERR				= 1, /**< General error. */
		OPT_WRONG_TYPE		= 2, /**< Option type was wrong. */
		OPT_UNKNOWN_TYPE	= 3, /**< Given option type is not known. */
		OPT_NOTFOUND		= 4, /**< Option name not found. */
	};

	COption();
	COption(const COption& option);

	COption& operator=(const COption& option);

	int Init(const String& name, const varprop::VariantValue& defaultVal);
	const varprop::VariantValue& Get() const;
	const varprop::VariantValue& GetDefault() const;
	int Set(const varprop::VariantValue& value, bool allowConversion = false);
	int SetDefault(const varprop::VariantValue& defaultValue); 
	void Reset();

protected:
	bool ConvertInteger(varprop::VariantValue & value, varprop::VT_TYPE nType);
	bool ConvertString(varprop::VariantValue & value, varprop::VT_TYPE nType);
	bool ConvertType(varprop::VariantValue & value, varprop::VT_TYPE nType);

private:
	String m_strName; /**< Option's name. */
	varprop::VariantValue m_value; /**< Option's current value. */
	varprop::VariantValue m_valueDef; /**< Option's default value. */
};

/**
 * @brief Return option value.
 * @return Value as Variant type.
 */
inline const varprop::VariantValue& COption::Get() const
{
	return m_value;
}

/**
 * @brief Return option default value.
 * @return Default value as varian type.
 */
inline const varprop::VariantValue& COption::GetDefault() const
{
	return m_valueDef;
}

typedef std::map<String, COption> OptionsMap;

/**
 * @brief Class to store list of options.
 * This class holds a list of all options (known to application). Options
 * are accessed by their name.
 *
 * Option must be first initialized before it can be read/set. Initialization
 * is done with InitOption() method.
 */
class COptionsMgr
{
public:
	virtual ~COptionsMgr() {}
	int AddOption(const String& name, const varprop::VariantValue& defaultValue);
	const varprop::VariantValue& Get(const String& name) const;
	const String& GetString(const String& name) const;
	int GetInt(const String& name) const;
	bool GetBool(const String& name) const;
	int Set(const String& name, const varprop::VariantValue& value);
	int Set(const String& name, const String& value);
	int Set(const String& name, const tchar_t *value);
	int Set(const String& name, bool value);
	int Set(const String& name, int value);
	int Reset(const String& name);
	int GetDefault(const String& name, String & value) const;
	int GetDefault(const String& name, unsigned & value) const;
	int GetDefault(const String& name, bool & value) const;
	template <typename T> T GetDefault(const String& name) const { T v; GetDefault(name, v); return v; }
	template <template<typename T, typename = std::allocator<T>> class Container = std::vector>
	Container<String> GetNameList() const
	{
		Container<String> nameList;
		for (const auto& e : m_optionsMap)
			nameList.push_back(e.first);
		return nameList;
	}
	String ExpandShortName(const String & shortname) const;

	virtual int InitOption(const String& name, const varprop::VariantValue& defaultValue) = 0;
	virtual int InitOption(const String& name, const String& defaultValue) = 0;
	virtual int InitOption(const String& name, const tchar_t *defaultValue) = 0;
	virtual int InitOption(const String& name, int defaultValue, bool serializable = true) = 0;
	virtual int InitOption(const String& name, int defaultValue, int minValue, int maxValue, bool serializable = true);
	virtual int InitOption(const String& name, bool defaultValue) = 0;

	virtual int SaveOption(const String& name) = 0;
	virtual int SaveOption(const String& name, const varprop::VariantValue& value) = 0;
	virtual int SaveOption(const String& name, const String& value) = 0;
	virtual int SaveOption(const String& name, const tchar_t *value) = 0;
	virtual int SaveOption(const String& name, int value) = 0;
	virtual int SaveOption(const String& name, bool value) = 0;
	virtual int SaveOption(const String& name, unsigned value);

	virtual int RemoveOption(const String& name);

	virtual int FlushOptions() = 0;

	virtual int ExportOptions(const String& filename, const bool bHexColor=false) const;
	virtual int ImportOptions(const String& filename);
	
	virtual void SetSerializing(bool serializing=true) = 0;

protected:
	static String EscapeValue(const String& text);
	static String UnescapeValue(const String& text);
	static std::pair<String, String> SplitName(const String& strName);
	static std::map<String, String> ReadIniFile(const String& filename, const String& section);

	OptionsMap m_optionsMap; /**< Map where options are stored. */

private:
	static varprop::VariantValue m_emptyValue;
};
</file>

<file path="Winmerge-Src/Src/Common/PidlContainer.cpp">
/////////////////////////////////////////////////////////////////////////////
//	  WinMerge:  an interactive diff/merge utility
//	  Copyright (C) 1997-2000  Thingamahoochie Software
//	  Author: Dean Grimm
//	  SPDX-License-Identifier: GPL-2.0-or-later
/////////////////////////////////////////////////////////////////////////////
/** 
 * @file  PidlContainer.cpp
 *
 * @brief Main implementation file for CPidlContainer
 */

#include "pch.h"
#include "PidlContainer.h"
#pragma warning (push)			// prevent "warning C4091: 'typedef ': ignored on left of 'tagGPFIDL_FLAGS' when no variable is declared"
#pragma warning (disable:4091)	// VC bug when using XP enabled toolsets.
#include <shlobj.h>
#pragma warning (pop)
#include <comdef.h>

CPidlContainer::~CPidlContainer()
{
	IMallocPtr m_pMalloc;
	if (FAILED(SHGetMalloc(&m_pMalloc)))
	{
		// can't do anything but return
		return;
	}
	// free memory allocated for pidls
	for (PidlContainer::iterator iter = m_container.begin(); iter != m_container.end(); ++iter)
	{
		m_pMalloc->Free(*iter);
	}
}

LPCITEMIDLIST* CPidlContainer::GetList() const
{
	if (m_container.empty())
		return nullptr;
	return const_cast<LPCITEMIDLIST*>(&m_container[0]);
}
</file>

<file path="Winmerge-Src/Src/Common/PidlContainer.h">
/////////////////////////////////////////////////////////////////////////////
//	  WinMerge:  an interactive diff/merge utility
//	  Copyright (C) 1997  Dean P. Grimm
//	  SPDX-License-Identifier: GPL-2.0-or-later
/////////////////////////////////////////////////////////////////////////////
/**
 *	@file PidlContainer.h
 *
 *	@brief Declaration of class CPidlContainer
 */ 
#pragma once

#include <ShTypes.h>
#include <vector>

/**
 * @brief Container for LPITEMIDLIST items
 *
 * When showing shell context menu we need to collect pidls for items.
 * This class simplifies this task.
 * Items are stored in vector. Memory allocated for pidls are freed in destructor.
 * You can add items and then query container size and pointer to 
 * LPCITEMIDLIST needed by IContextMenu::GetUIObjectOf
 */
class CPidlContainer
{
public:
	/**
	 * @brief Destructor
	 *
	 * Frees memory allocated for pidls using IMalloc interface
	 */
	~CPidlContainer();

	/**
	 * @brief Adds item to container
	 *
	 * @param[in]	pidl	item to add
	 */
	void Add(LPITEMIDLIST pidl) { m_container.push_back(pidl); } 

	/**
	 * @brief Returns pointer to array of LPCITEMIDLIST items
	 *
	 * @return Pointer to array of LPCITEMIDLIST items.
	 *		   May be invalidated by Add()
	 */
	LPCITEMIDLIST* GetList() const;

	/**
	 * @brief Returns number of items in container
	 *
	 * @return Number of items in container
	 */
	size_t Size() const { return m_container.size(); }

private:
	typedef std::vector<LPITEMIDLIST> PidlContainer;
	PidlContainer m_container; /**< stores items */
};
</file>

<file path="Winmerge-Src/Src/Common/PreferencesDlg.cpp">
/** 
 * @file PreferencesDlg.cpp
 *
 * @brief Implementation file for CPreferencesDlg
 *
 * @note This code originates from AbstractSpoon / TodoList
 * (http://www.abstractspoon.com/) but is modified to use in
 * WinMerge.
 */

#include "StdAfx.h"
#include "PreferencesDlg.h"
#include "resource.h"
#include "UnicodeString.h"
#include "OptionsDef.h"
#include "OptionsMgr.h"
#include "SyntaxColors.h"
#include "Merge.h"
#include "paths.h"
#include "FileOrFolderSelect.h"
#include "OptionsSyntaxColors.h"
#include "LineFiltersList.h"
#include "SubstitutionFiltersList.h"
#include "Constants.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CPreferencesDlg dialog

const tchar_t PATHDELIM = '>';

CPreferencesDlg::CPreferencesDlg(COptionsMgr *regOptions, SyntaxColors *colors,
		UINT nMenuID /*= 0*/, CWnd* pParent /*= nullptr*/)   // standard constructor
: CTrDialog(IDD_PREFERENCES, pParent)
, m_pOptionsMgr(regOptions)
, m_pSyntaxColorsOrg(colors)
, m_pSyntaxColors(new SyntaxColors(colors))
, m_pageGeneral(regOptions)
, m_pageCompare(regOptions)
, m_pageMessageBoxes(regOptions)
, m_pageColorSchemes(regOptions)
, m_pageMergeColors(regOptions)
, m_pageTextColors(regOptions, m_pSyntaxColors.get())
, m_pageSyntaxColors(regOptions, m_pSyntaxColors.get())
, m_pageMarkerColors(regOptions, m_pSyntaxColors.get())
, m_pageDirColors(regOptions)
, m_pageSysColors(regOptions)
, m_pageArchive(regOptions)
, m_pageCodepage(regOptions)
, m_pageEditor(regOptions)
, m_pageEditorCompareMerge(regOptions)
, m_pageEditorSyntax(regOptions)
, m_pageProject(regOptions)
, m_pageSystem(regOptions)
, m_pageBackups(regOptions)
, m_pageShell(regOptions)
, m_pageCompareFolder(regOptions)
, m_pageCompareTable(regOptions)
, m_pageCompareBinary(regOptions)
, m_pageCompareImage(regOptions)
, m_pageCompareWebPage(regOptions)
{
	UNREFERENCED_PARAMETER(nMenuID);
}

CPreferencesDlg::~CPreferencesDlg()
{
}

void CPreferencesDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPreferencesDlg)
	DDX_Control(pDX, IDC_TREEOPT_PAGES, m_tcPages);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CPreferencesDlg, CTrDialog)
	//{{AFX_MSG_MAP(CPreferencesDlg)
	ON_WM_SIZE()
	ON_COMMAND(ID_HELP, OnHelpButton)
	ON_BN_CLICKED(IDC_TREEOPT_HELP, OnHelpButton)
	ON_NOTIFY(TVN_SELCHANGED, IDC_TREEOPT_PAGES, OnSelchangedPages)
	ON_BN_CLICKED(IDC_TREEOPT_IMPORT, OnImportButton)
	ON_BN_CLICKED(IDC_TREEOPT_EXPORT, OnExportButton)
	ON_MESSAGE(WM_APP + IDC_COLOR_SCHEMES, OnColorSchemeChanged)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPreferencesDlg message handlers

BOOL CPreferencesDlg::OnInitDialog() 
{
	CTrDialog::OnInitDialog();

	m_tcPages.SetIndent(0);

	// Second parameter is 'path', page's parent page(s) and caption.
	// '>' is used as path separator.
	// For example "General" creates top-level "General" page
	// and "General>Colors" creates "Colors" sub-page for "General"
	AddPage(&m_pageGeneral, IDS_OPTIONSPG_GENERAL);
	AddPage(&m_pageCompare, IDS_OPTIONSPG_COMPARE, IDS_OPTIONSPG_GENCOMPARE);
	AddPage(&m_pageCompareFolder, IDS_OPTIONSPG_COMPARE, IDS_OPTIONSPG_FOLDERCOMPARE);
	AddPage(&m_pageCompareTable, IDS_OPTIONSPG_COMPARE, IDS_OPTIONSPG_TABLECOMPARE);
	AddPage(&m_pageCompareBinary, IDS_OPTIONSPG_COMPARE, IDS_OPTIONSPG_BINARYCOMPARE);
	AddPage(&m_pageCompareImage, IDS_OPTIONSPG_COMPARE, IDS_OPTIONSPG_IMAGECOMPARE);
	AddPage(&m_pageCompareWebPage, IDS_OPTIONSPG_COMPARE, IDS_OPTIONSPG_WEBPAGECOMPARE);
	AddPage(&m_pageMessageBoxes, IDS_OPTIONSPG_MESSAGEBOXES);
	AddPage(&m_pageEditor, IDS_OPTIONSPG_EDITOR, IDS_OPTIONSPG_GENEDITOR);
	AddPage(&m_pageEditorCompareMerge, IDS_OPTIONSPG_EDITOR, IDS_OPTIONSPG_EDITOR_COMPAREMERGE);
	AddPage(&m_pageEditorSyntax, IDS_OPTIONSPG_EDITOR, IDS_OPTIONSPG_EDITOR_SYNTAX);
	AddPage(&m_pageColorSchemes, IDS_OPTIONSPG_COLORS, IDS_OPTIONSPG_COLOR_SCHEMES);
	AddPage(&m_pageMergeColors, IDS_OPTIONSPG_COLORS, IDS_OPTIONSPG_MERGECOLORS);
	AddPage(&m_pageSyntaxColors, IDS_OPTIONSPG_COLORS, IDS_OPTIONSPG_SYNTAXCOLORS);
	AddPage(&m_pageTextColors, IDS_OPTIONSPG_COLORS, IDS_OPTIONSPG_TEXTCOLORS);
	AddPage(&m_pageMarkerColors, IDS_OPTIONSPG_COLORS, IDS_OPTIONSPG_MARKERCOLORS);
	AddPage(&m_pageDirColors, IDS_OPTIONSPG_COLORS, IDS_OPTIONSPG_DIRCOLORS);
	AddPage(&m_pageSysColors, IDS_OPTIONSPG_COLORS, IDS_OPTIONSPG_SYSCOLORS);
	AddPage(&m_pageArchive, IDS_OPTIONSPG_ARCHIVE);
	AddPage(&m_pageProject, IDS_OPTIONSPG_PROJECT);
	AddPage(&m_pageSystem, IDS_OPTIONSPG_SYSTEM);
	AddPage(&m_pageBackups, IDS_OPTIONSPG_BACKUPS);
	AddPage(&m_pageCodepage, IDS_OPTIONSPG_CODEPAGE);
	AddPage(&m_pageShell, IDS_OPTIONSPG_SHELL);

	ReadOptions();
	
	CRect rPPHost;
	GetDlgItem(IDC_TREEOPT_HOSTFRAME)->GetWindowRect(rPPHost);
	ScreenToClient(rPPHost);

	if (m_pphost.Create(rPPHost, this))
		SetActivePage(AfxGetApp()->GetProfileInt(_T("Settings"), _T("OptStartPage"), 0));
 
	// setup handler for resizing this dialog	
	m_constraint.InitializeCurrentSize(this);
	m_constraint.SubclassWnd(); // install subclassing
	m_constraint.LoadPosition(_T("ResizeableDialogs"), _T("OptionsDlg"), false); // persist size via registry
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CPreferencesDlg::OnOK()
{
	CDialog::OnOK();
	m_pphost.OnOK();

	SaveOptions();

	AfxGetApp()->WriteProfileInt(_T("Settings"), _T("OptStartPage"), m_pphost.GetActiveIndex());
}

void CPreferencesDlg::OnSize(UINT nType, int cx, int cy)
{
	CWnd::OnSize(nType, cx, cy);

	if (CWnd *pPPHostWnd = GetDlgItem(IDC_TREEOPT_HOSTFRAME))
	{
		CRect rPPHost;
		pPPHostWnd->GetWindowRect(rPPHost);
		ScreenToClient(rPPHost);
		m_pphost.MoveWindow(&rPPHost);
	}
}
	
void CPreferencesDlg::OnHelpButton() 
{
	theApp.ShowHelp(OptionsHelpLocation);
}

void CPreferencesDlg::AddPage(CPropertyPage* pPage, UINT nResourceID)
{
	String sPath = theApp.LoadString(nResourceID);
	AddPage(pPage, sPath.c_str());
}

void CPreferencesDlg::AddPage(CPropertyPage* pPage, UINT nTopHeading, UINT nSubHeading)
{
	String sPath = theApp.LoadString(nTopHeading);
	sPath += _T(">");
	sPath += theApp.LoadString(nSubHeading);
	AddPage(pPage, sPath.c_str());
}

void CPreferencesDlg::AddPage(CPropertyPage* pPage, const tchar_t* szPath)
{
	if (m_pphost.AddPage(pPage))
	{
		CString sPath(szPath);
		HTREEITEM htiParent = TVI_ROOT; // default
		int nFind = sPath.Find(PATHDELIM);

		while (nFind != -1)
		{
			CString sParent = sPath.Left(nFind);
			sPath = sPath.Mid(nFind + 1);

			// see if parent already exists
			HTREEITEM htiParentParent = htiParent;
			htiParent = m_tcPages.GetChildItem(htiParentParent);

			while (htiParent != nullptr)
			{
				if (sParent.CompareNoCase(m_tcPages.GetItemText(htiParent)) == 0)
					break;

				htiParent = m_tcPages.GetNextItem(htiParent, TVGN_NEXT);
			}

			if (htiParent == nullptr)
				htiParent = m_tcPages.InsertItem(sParent, htiParentParent);

			nFind = sPath.Find(PATHDELIM);
		}

		HTREEITEM hti = m_tcPages.InsertItem(sPath, htiParent); // whatever's left
		m_tcPages.EnsureVisible(hti);

		// map both ways
		m_tcPages.SetItemData(hti, static_cast<DWORD_PTR>(reinterpret_cast<uintptr_t>(pPage)));
		m_mapPP2HTI[(void*)pPage] = (void*)hti;
	}
}

void CPreferencesDlg::OnSelchangedPages(NMHDR* pNMHDR, LRESULT* pResult) 
{
	UNREFERENCED_PARAMETER(pNMHDR);
	HTREEITEM htiSel = m_tcPages.GetSelectedItem();

	while (m_tcPages.ItemHasChildren(htiSel))
		htiSel = m_tcPages.GetChildItem(htiSel);

	CPropertyPage* pPage = (CPropertyPage*)m_tcPages.GetItemData(htiSel);
	ASSERT (pPage != nullptr);

	if (pPage != nullptr)
	{
		m_pphost.SetActivePage(pPage, false);

		// update caption
		String sCaption = strutils::format_string1(_("Options (%1)"), (const tchar_t*)GetItemPath(htiSel));
		SetWindowText(sCaption.c_str());
	}

	m_tcPages.SetFocus();
	
	*pResult = 0;
}

void CPreferencesDlg::SetActivePage(int nPage)
{
	m_pphost.SetActivePage(nPage, false);

	// synchronize tree
	CPropertyPage* pPage = m_pphost.GetActivePage();
	HTREEITEM hti = nullptr;

	if (m_mapPP2HTI.Lookup(pPage, (void*&)hti) && hti != nullptr)
		m_tcPages.SelectItem(hti);
}

CString CPreferencesDlg::GetItemPath(HTREEITEM hti)
{
	CString sPath = m_tcPages.GetItemText(hti);

	hti = m_tcPages.GetParentItem(hti);
	while (hti != nullptr)
	{
		sPath = m_tcPages.GetItemText(hti) + _T(" > ") + sPath;
		hti = m_tcPages.GetParentItem(hti);
	}

	return sPath;
}

/**
 * @brief Read options from storage to UI controls.
 * @param [in] bUpdate If `true` UpdateData() is called
 */
void CPreferencesDlg::ReadOptions(bool bUpdate)
{
	m_pageGeneral.ReadOptions();
	m_pageColorSchemes.ReadOptions();
	m_pageMergeColors.ReadOptions();
	m_pageTextColors.ReadOptions();
	m_pageSyntaxColors.ReadOptions();
	m_pageMarkerColors.ReadOptions();
	m_pageDirColors.ReadOptions();
	m_pageSysColors.ReadOptions();
	m_pageSystem.ReadOptions();
	m_pageCompare.ReadOptions();
	m_pageCompareFolder.ReadOptions();
	m_pageCompareTable.ReadOptions();
	m_pageCompareBinary.ReadOptions();
	m_pageCompareImage.ReadOptions();
	m_pageCompareWebPage.ReadOptions();
	m_pageMessageBoxes.ReadOptions();
	m_pageEditor.ReadOptions();
	m_pageEditorCompareMerge.ReadOptions();
	m_pageEditorSyntax.ReadOptions();
	m_pageCodepage.ReadOptions();
	m_pageArchive.ReadOptions();
	m_pageProject.ReadOptions();
	m_pageBackups.ReadOptions();
	m_pageShell.ReadOptions();

	if (bUpdate)
	{
		SafeUpdatePage(&m_pageGeneral, false);
		SafeUpdatePage(&m_pageColorSchemes, false);
		SafeUpdatePage(&m_pageMergeColors, false);
		SafeUpdatePage(&m_pageTextColors, false);
		SafeUpdatePage(&m_pageSyntaxColors, false);
		SafeUpdatePage(&m_pageMarkerColors, false);
		SafeUpdatePage(&m_pageDirColors, false);
		SafeUpdatePage(&m_pageSysColors, false);
		SafeUpdatePage(&m_pageSystem, false);
		SafeUpdatePage(&m_pageCompare, false);
		SafeUpdatePage(&m_pageCompareFolder, false);
		SafeUpdatePage(&m_pageCompareTable, false);
		SafeUpdatePage(&m_pageCompareBinary, false);
		SafeUpdatePage(&m_pageCompareImage, false);
		SafeUpdatePage(&m_pageMessageBoxes, false);
		SafeUpdatePage(&m_pageEditor, false);
		SafeUpdatePage(&m_pageEditorCompareMerge, false);
		SafeUpdatePage(&m_pageEditorSyntax, false);
		SafeUpdatePage(&m_pageCodepage, false);
		SafeUpdatePage(&m_pageArchive, false);
		SafeUpdatePage(&m_pageProject, false);
		SafeUpdatePage(&m_pageBackups, false);
		SafeUpdatePage(&m_pageShell, false);
	}
}

/**
 * @brief Write options from UI to storage.
 */
void CPreferencesDlg::SaveOptions()
{
	m_pageGeneral.WriteOptions();
	m_pageSystem.WriteOptions();
	m_pageCompare.WriteOptions();
	m_pageCompareFolder.WriteOptions();
	m_pageCompareTable.WriteOptions();
	m_pageCompareBinary.WriteOptions();
	m_pageCompareImage.WriteOptions();
	m_pageCompareWebPage.WriteOptions();
	m_pageMessageBoxes.WriteOptions();
	m_pageEditor.WriteOptions();
	m_pageEditorCompareMerge.WriteOptions();
	m_pageEditorSyntax.WriteOptions();
	m_pageColorSchemes.WriteOptions();
	m_pageMergeColors.WriteOptions();
	m_pageTextColors.WriteOptions();
	m_pageSyntaxColors.WriteOptions();
	m_pageMarkerColors.WriteOptions();
	m_pageDirColors.WriteOptions();
	m_pageSysColors.WriteOptions();
	m_pageCodepage.WriteOptions();
	m_pageArchive.WriteOptions();
	m_pageProject.WriteOptions();
	m_pageBackups.WriteOptions();
	m_pageShell.WriteOptions();
	m_pSyntaxColorsOrg->Clone(m_pSyntaxColors.get());
}

/**
 * @brief Imports options from file.
 */
void CPreferencesDlg::OnImportButton()
{
	String s;
	if (SelectFile(GetSafeHwnd(), s, true, nullptr, _("Select file for import"), _("Options files (*.ini)|*.ini|All Files (*.*)|*.*||")))
	{
		if (m_pOptionsMgr->ImportOptions(s) == COption::OPT_OK)
		{
			Options::SyntaxColors::Load(m_pOptionsMgr, m_pSyntaxColors.get());
			theApp.m_pLineFilters->Initialize(GetOptionsMgr());
			theApp.m_pSubstitutionFiltersList->Initialize(GetOptionsMgr());

			ReadOptions(true);
			LangMessageBox(IDS_OPT_IMPORT_DONE, MB_ICONINFORMATION);
		}
		else
			LangMessageBox(IDS_OPT_IMPORT_ERR, MB_ICONWARNING);
	}
}

/**
 * @brief Exports options to file.
 */
void CPreferencesDlg::OnExportButton()
{
	String settingsFile;
	if (SelectFile(GetSafeHwnd(), settingsFile, false, nullptr, _("Select file for export"),
		_("Options files (*.ini)|*.ini|All Files (*.*)|*.*||")))
	{
		// Add settings file extension if it is missing
		// So we allow 'filename.otherext' but add extension for 'filename'
		if (paths::FindExtension(settingsFile).empty())
			settingsFile += _T(".ini");

		// Save all new settings before exporting
		m_pphost.UpdatePagesData();
		SaveOptions();

		if (m_pOptionsMgr->ExportOptions(settingsFile, true) == COption::OPT_OK)
			LangMessageBox(IDS_OPT_EXPORT_DONE, MB_ICONINFORMATION);
		else
			LangMessageBox(IDS_OPT_EXPORT_ERR, MB_ICONWARNING);
	}
}

LRESULT CPreferencesDlg::OnColorSchemeChanged(WPARAM wParams, LPARAM lParam)
{
	Options::SyntaxColors::Load(m_pOptionsMgr, m_pSyntaxColors.get());
	ReadOptions(true);
	EnableDlgItem(IDCANCEL, false);
	return 0;
}

/**
 * @brief Do a safe UpdateData call for propertypage.
 * This function does safe UpdateData call for given propertypage. As it is,
 * all propertypages may not have been yet initialized properly, so we must
 * have some care when calling updateData for them.
 * @param [in] pPage Propertypage to update.
 * @param bSaveAndValidate UpdateData direction parameter.
 */
void CPreferencesDlg::SafeUpdatePage(CPropertyPage* pPage, bool bSaveAndValidate)
{
	if (pPage->GetSafeHwnd() != nullptr)
		pPage->UpdateData(bSaveAndValidate);
}
</file>

<file path="Winmerge-Src/Src/Common/PreferencesDlg.h">
/** 
 * @file  PreferencesDlg.h
 *
 * @brief Declaration of CPreferencesDlg class
 *
 * @note This code originates from AbstractSpoon / TodoList
 * (http://www.abstractspoon.com/) but is modified to use in
 * WinMerge.
 */
#pragma once

#include "TrDialogs.h"
#include "PropGeneral.h"
#include "PropCompare.h"
#include "PropMessageBoxes.h"
#include "PropEditor.h"
#include "PropEditorCompareMerge.h"
#include "PropEditorSyntax.h"
#include "PropRegistry.h"
#include "PropColorSchemes.h"
#include "PropMergeColors.h"
#include "PropTextColors.h"
#include "PropSyntaxColors.h"
#include "PropMarkerColors.h"
#include "PropDirColors.h"
#include "PropSysColors.h"
#include "PropCodepage.h"
#include "PropArchive.h"
#include "PropProject.h"
#include "PropBackups.h"
#include "PropShell.h"
#include "PropCompareFolder.h"
#include "PropCompareTable.h"
#include "PropCompareBinary.h"
#include "PropCompareImage.h"
#include "PropCompareWebPage.h"

#include "PropertyPageHost.h"
#include "CMoveConstraint.h"

class COptionsMgr;
class SyntaxColors;

/////////////////////////////////////////////////////////////////////////////
// CPreferencesDlg dialog

class CPreferencesDlg : public CTrDialog
{
// Construction
public:
	//CPreferencesDlg(UINT nMenuID = 0, CWnd* pParent = nullptr);   // standard constructor
	CPreferencesDlg(COptionsMgr *optionsMgr, SyntaxColors *colors,
		UINT nMenuID = 0, CWnd* pParent = nullptr);   // standard constructor
	virtual ~CPreferencesDlg();

private:
	COptionsMgr *m_pOptionsMgr;
	std::unique_ptr<SyntaxColors> m_pSyntaxColors;
	SyntaxColors* m_pSyntaxColorsOrg;
	prdlg::CMoveConstraint m_constraint; /**< Resizes dialog controls when dialog resized */

protected:
// Dialog Data
	//{{AFX_DATA(CPreferencesDlg)
	CTreeCtrl m_tcPages;
	//}}AFX_DATA

	CPropertyPageHost m_pphost;
	
	PropGeneral m_pageGeneral;
	PropCompare m_pageCompare;
	PropMessageBoxes m_pageMessageBoxes;
	PropEditor m_pageEditor;
	PropEditorCompareMerge m_pageEditorCompareMerge;
	PropEditorSyntax m_pageEditorSyntax;
	PropRegistry m_pageSystem;
	PropCodepage m_pageCodepage;
	PropColorSchemes m_pageColorSchemes;
	PropMergeColors m_pageMergeColors;
	PropTextColors m_pageTextColors;
	PropSyntaxColors m_pageSyntaxColors;
	PropMarkerColors m_pageMarkerColors;
	PropDirColors m_pageDirColors;
	PropSysColors m_pageSysColors;
	PropArchive m_pageArchive;
	PropProject m_pageProject;
	PropBackups m_pageBackups;
	PropShell m_pageShell;
	PropCompareFolder m_pageCompareFolder;
	PropCompareTable m_pageCompareTable;
	PropCompareBinary m_pageCompareBinary;
	PropCompareImage m_pageCompareImage;
	PropCompareWebPage m_pageCompareWebPage;

	CMapPtrToPtr m_mapPP2HTI;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPreferencesDlg)
	public:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL
	virtual void OnOK();

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CPreferencesDlg)
	virtual BOOL OnInitDialog() override;
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnHelpButton();
	afx_msg void OnImportButton();
	afx_msg void OnExportButton();
	afx_msg LRESULT OnColorSchemeChanged(WPARAM wParam, LPARAM lParam);
	afx_msg void OnSelchangedPages(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	void AddPage(CPropertyPage* pPage, UINT nResourceID);
	void AddPage(CPropertyPage* pPage, const tchar_t* szPath);
	void AddPage(CPropertyPage* pPage, UINT nTopHeading, UINT nSubHeading);
	void SetActivePage(int nPage);
	CString GetItemPath(HTREEITEM hti);
	void ReadOptions(bool bUpdate = false);
	void SaveOptions();
	void SafeUpdatePage(CPropertyPage* pPage, bool bSaveAndValidate);
};
</file>

<file path="Winmerge-Src/Src/Common/PropertyPageHost.cpp">
/** 
 * @file PropertyPageHost.cpp
 *
 * @brief Implementation file for CPropertypageHost
 *
 * @note This code originates from AbstractSpoon / TodoList
 * (http://www.abstractspoon.com/) but is modified to use in
 * WinMerge.
 */

#include "StdAfx.h"
#include "PropertyPageHost.h"

#ifdef _WIN64
#	include <../src/mfc/occimpl.h>
#else // _WIN64
#	include <afxocc.h>
#endif // _WIN64

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CPropertyPageHost

CPropertyPageHost::CPropertyPageHost() : m_nSelIndex(-1)
{
}

CPropertyPageHost::~CPropertyPageHost()
{
}


BEGIN_MESSAGE_MAP(CPropertyPageHost, CWnd)
	//{{AFX_MSG_MAP(CPropertyPageHost)
	ON_WM_SIZE()
	ON_WM_ERASEBKGND()
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
	ON_MESSAGE(PSM_GETCURRENTPAGEHWND, OnGetCurrentPageHwnd)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CPropertyPageHost message handlers

BOOL CPropertyPageHost::Create(UINT nRefCtrlID, CWnd* pParent, UINT uCtrlID)
{
	ASSERT_VALID(pParent);

	if (pParent == nullptr || !::IsWindow(*pParent))
		return FALSE;

	CWnd* pRefCtrl = pParent->GetDlgItem(nRefCtrlID);

	ASSERT_VALID(pRefCtrl);

	if (pRefCtrl == nullptr || !::IsWindow(*pRefCtrl))
		return FALSE;

	CRect rHost;
	pRefCtrl->GetWindowRect(rHost);
	pParent->ScreenToClient(rHost);

	if (Create(rHost, pParent, uCtrlID))
	{
		// move us after nRefCtrlID in the z-order
		SetWindowPos(pRefCtrl, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
		return TRUE;
	}

	return FALSE;
}

BOOL CPropertyPageHost::Create(LPRECT lpRect, CWnd* pParent, UINT uCtrlID)
{
	ASSERT_VALID(pParent);

	if (pParent == nullptr || !::IsWindow(*pParent))
		return FALSE;

	if (!m_aPages.GetSize())
		return FALSE;

	if (!CWnd::Create(nullptr, nullptr, WS_CHILD | WS_VISIBLE, *lpRect, pParent, uCtrlID))
		return FALSE;

	// create the first page
	return SetActivePage(0);
}

int CPropertyPageHost::GetActiveIndex()
{
	return m_nSelIndex;
}

CPropertyPage* CPropertyPageHost::GetActivePage()
{
	if (m_nSelIndex < 0)
		return nullptr;

	CPropertyPage* pPage = m_aPages[m_nSelIndex].pPage;

	if (pPage == nullptr || pPage->GetSafeHwnd() == nullptr)
		return nullptr;

	return pPage;
}

LRESULT CPropertyPageHost::OnGetCurrentPageHwnd(WPARAM wParam, LPARAM lParam)
{
	CWnd* pActive = GetActivePage();

	return pActive ? (LRESULT)pActive->GetSafeHwnd() : NULL;
}

bool CPropertyPageHost::SetActivePage(int nIndex, bool bAndFocus /*= true*/)
{
	if (nIndex < 0 || nIndex >= m_aPages.GetSize())
		return false;

	CPropertyPage* pPage = m_aPages[nIndex].pPage;

	if (pPage == nullptr)
		return false;

	CWnd* pFocus = GetFocus();

	if (pPage->GetSafeHwnd() == nullptr && !pPage->Create(pPage->m_psp.pszTemplate, this))
		return false;

	// make sure we can into/out of the page
	pPage->ModifyStyleEx(0, WS_EX_CONTROLPARENT | DS_CONTROL);

	// make sure the page is a child and modify it if necessary
	pPage->ModifyStyle(WS_POPUPWINDOW | WS_OVERLAPPEDWINDOW, 0);

	if (!(pPage->GetStyle() & WS_CHILD))
	{
		pPage->ModifyStyle(0, WS_CHILD);
		pPage->SetParent(this);
		ASSERT (pPage->GetParent() == this);
	}


	CRect rClient;
	GetClientRect(rClient);

	pPage->SetParent(this);
	pPage->MoveWindow(rClient);

	if (m_nSelIndex != -1)
	{
		CPropertyPage* pPage1 = GetActivePage();
		ASSERT (pPage1 != nullptr);

		if (pPage1 != nullptr)
		{
			pPage1->ShowWindow(SW_HIDE);
			pPage1->OnKillActive();
		}
	}

	pPage->OnSetActive();
	pPage->ShowWindow(SW_SHOW);

	// move the focus to the first dlg ctrl
	if (bAndFocus)
	{
		CWnd* pCtrl = pPage->GetNextDlgTabItem(nullptr);

		if (pCtrl != nullptr)
			pCtrl->SetFocus();
	}
	else if (pFocus)
		pFocus->SetFocus();

	m_nSelIndex = nIndex;
	return true;
}

bool CPropertyPageHost::SetActivePage(CPropertyPage* pPage, bool bAndFocus /*= true*/)
{
	return SetActivePage(FindPage(pPage));
}

bool CPropertyPageHost::AddPage(CPropertyPage* pPage, const tchar_t* szTitle /*= nullptr*/, DWORD dwItemData /*= 0*/)
{
	if (pPage == nullptr || !pPage->IsKindOf(RUNTIME_CLASS(CPropertyPage)))
		return false;

	if (FindPage(pPage) == -1)
	{
		PAGEITEM pi(pPage, szTitle, dwItemData);
		int nPage = (int) m_aPages.Add(pi);

		if (szTitle != nullptr)
		{
			pPage->m_psp.pszTitle = m_aPages[nPage].sTitle; // the final string address
			pPage->m_psp.dwFlags |= PSP_USETITLE;
		}
	}

	return true;
}

int CPropertyPageHost::FindPage(CPropertyPage* pPage)
{
	int nPage = (int) m_aPages.GetSize();

	while (nPage--)
	{
		if (m_aPages[nPage].pPage == pPage)
			break;
	}

	return nPage;
}

BOOL CPropertyPageHost::PreTranslateMessage(MSG* pMsg) 
{
	CWnd* pActive = GetActivePage();

	if (pActive != nullptr)
	{
		if (pActive->PreTranslateMessage(pMsg))
			return TRUE;
		
		else if (pActive->IsDialogMessage(pMsg)) 
			return TRUE;
	}
	
	return FALSE;
}

// unfortunately there is a bug in MFC that can cause an infinite loop
// when the property page is hosting an OLE control so we fix
// it by providing a replacement to the buggy code
BOOL COccManager::IsDialogMessage(CWnd* pWndDlg, LPMSG lpMsg)
{
	UINT uMsg = lpMsg->message;

	if (((uMsg >= WM_KEYFIRST) && (uMsg <= WM_KEYLAST)) ||
		((uMsg >= WM_MOUSEFIRST) && (uMsg <= WM_MOUSELAST)))
	{
		CWnd* pWndCtrl = CWnd::GetFocus();

		// Walk up the parent chain, until we find an OLE control.
		while ((pWndCtrl != nullptr) && (pWndCtrl->m_pCtrlSite == nullptr) &&
			(pWndCtrl->GetParent() != pWndDlg))
		{
			pWndCtrl = pWndCtrl->GetParent();
		}

		// let the control attempt to translate the message
		if (pWndCtrl != nullptr && pWndCtrl->m_pCtrlSite != nullptr &&
			pWndCtrl->m_pCtrlSite->m_pActiveObject != nullptr &&
			pWndCtrl->m_pCtrlSite->m_pActiveObject->TranslateAccelerator(lpMsg) == S_OK)
		{
			return TRUE;
		}

		// handle CTRLINFO_EATS_RETURN and CTRLINFO_EATS_ESCAPE flags
		if ((uMsg == WM_KEYUP || uMsg == WM_KEYDOWN || uMsg == WM_CHAR) &&
			pWndCtrl != nullptr && pWndCtrl->m_pCtrlSite != nullptr &&
			((LOWORD(lpMsg->wParam) == VK_RETURN &&
			 (pWndCtrl->m_pCtrlSite->m_ctlInfo.dwFlags & CTRLINFO_EATS_RETURN)) ||
			(LOWORD(lpMsg->wParam) == VK_ESCAPE &&
			 (pWndCtrl->m_pCtrlSite->m_ctlInfo.dwFlags & CTRLINFO_EATS_ESCAPE))))
		{
			return FALSE;
		}
	}

	// else simple default
	// because this is where the MFC bug existed
	return ::IsDialogMessage(pWndDlg->GetSafeHwnd(), lpMsg);
}

void CPropertyPageHost::OnSize(UINT nType, int cx, int cy) 
{
	CWnd::OnSize(nType, cx, cy);
	
	// resize active page
	if (m_nSelIndex != -1)
	{
		CPropertyPage* pPage = GetActivePage();
		ASSERT (pPage != nullptr);

		if (pPage != nullptr)
			pPage->MoveWindow(0, 0, cx, cy, TRUE);
	}
}

BOOL CPropertyPageHost::OnEraseBkgnd(CDC* pDC) 
{
	return TRUE;
}

void CPropertyPageHost::OnOK()
{
	int nPage = (int) m_aPages.GetSize();

	while (nPage--)
	{
		CPropertyPage* pPage = m_aPages[nPage].pPage;

		if (pPage!= nullptr && pPage->GetSafeHwnd() != nullptr)
		{
			pPage->UpdateData();
			pPage->OnOK();
		}
	}
}

/**
 * @brief Update all PropertyPages.
 */
void CPropertyPageHost::UpdatePagesData()
{
	int nPage = (int) m_aPages.GetSize();

	while (nPage--)
	{
		CPropertyPage* pPage = m_aPages[nPage].pPage;

		if (pPage!= nullptr && pPage->GetSafeHwnd()!= nullptr)
		{
			pPage->UpdateData();
		}
	}
}

int CPropertyPageHost::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	// *************************************************************************
	// EXTREMELY IMPORTANT
	// set these styles because otherwise propsheet
	// goes into infinite loop when focus changes
	ModifyStyle(0, DS_CONTROL, 0);
	ModifyStyleEx(0, WS_EX_CONTROLPARENT);
	// *************************************************************************
	
	return 0;
}

CString CPropertyPageHost::GetPageTitle(int nIndex)
{
	if (nIndex < 0 || nIndex > m_aPages.GetSize())
		return _T("");

	return m_aPages[nIndex].sTitle;
}

DWORD CPropertyPageHost::GetPageItemData(int nIndex)
{
	if (nIndex < 0 || nIndex > m_aPages.GetSize())
		return 0;

	return m_aPages[nIndex].dwItemData;
}

CPropertyPage* CPropertyPageHost::GetPage(int nIndex)
{
	if (nIndex < 0 || nIndex > m_aPages.GetSize())
		return nullptr;

	return m_aPages[nIndex].pPage;
}

CPropertyPage* CPropertyPageHost::FindPage(DWORD dwItemData)
{
	int nPage = (int) m_aPages.GetSize();

	while (nPage--)
	{
		if (dwItemData && dwItemData == m_aPages[nPage].dwItemData)
			return m_aPages[nPage].pPage;
	}

	return nullptr;
}
</file>

<file path="Winmerge-Src/Src/Common/PropertyPageHost.h">
/** 
 * @file  PropertyPageHost.h
 *
 * @brief Declaration of CPropertyPageHost class
 *
 * @note This code originates from AbstractSpoon / TodoList
 * (http://www.abstractspoon.com/) but is modified to use in
 * WinMerge.
 */
#pragma once

#include <afxtempl.h>

/////////////////////////////////////////////////////////////////////////////
// CPropertyPageHost window

struct PAGEITEM
{
	PAGEITEM(CPropertyPage* _pPage = nullptr, const tchar_t* szTitle = nullptr, DWORD dwData = 0) : 
			pPage(_pPage), sTitle(szTitle), dwItemData(dwData) {}

	CPropertyPage* pPage;
	CString sTitle;
	DWORD dwItemData;
};

class CPropertyPageHost : public CWnd
{
// Construction
public:
	CPropertyPageHost();

	BOOL Create(LPRECT lpRect, CWnd* pParent, UINT uCtrlID = AFX_IDW_PANE_FIRST);
	BOOL Create(UINT nRefCtrlID, CWnd* pParent, UINT uCtrlID = AFX_IDW_PANE_FIRST);
	void OnOK();
	void UpdatePagesData();
	
	int GetActiveIndex();
	CPropertyPage* GetActivePage();
	bool AddPage(CPropertyPage* pPage, const tchar_t* szTitle = nullptr, DWORD dwItemData = 0);
	bool SetActivePage(int nIndex, bool bAndFocus = true);
	bool SetActivePage(CPropertyPage* pPage, bool bAndFocus = true);
	int GetPageCount() { return (int) m_aPages.GetSize(); }
	CString GetPageTitle(int nIndex);
	DWORD GetPageItemData(int nIndex);
	CPropertyPage* GetPage(int nIndex);
	CPropertyPage* FindPage(DWORD dwItemData);

protected:
	CArray<PAGEITEM, PAGEITEM&> m_aPages;
	int m_nSelIndex;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPropertyPageHost)
	public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CPropertyPageHost();

	// Generated message map functions
protected:
	//{{AFX_MSG(CPropertyPageHost)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	afx_msg LRESULT OnGetCurrentPageHwnd(WPARAM wParam, LPARAM lParam);
	DECLARE_MESSAGE_MAP()

protected:
	int FindPage(CPropertyPage* pPage);

};
</file>

<file path="Winmerge-Src/Src/Common/RegKey.cpp">
/** 
 * @file  RegKey.cpp
 *
 * @brief Implementation of CRegKeyEx C++ wrapper class for reading Windows registry
 */

#include "pch.h"
#define NOMINMAX
#include "RegKey.h"
#include <windows.h>
#include <cassert>
#include <strsafe.h>
#include "UnicodeString.h"

/**
 * @brief Default constructor.
 */
CRegKeyEx::CRegKeyEx()
: m_hKey(nullptr)
{
}

/**
 * @brief Default destructor.
 */
CRegKeyEx::~CRegKeyEx()
{
	Close();
}

/**
 * @brief Closes the key.
 */
void CRegKeyEx::Close()
{
	if (m_hKey != nullptr) 
	{
		RegCloseKey(m_hKey);
		m_hKey = nullptr;
	}
}

/**
 * @brief Opens or creates a key in given path.
 * @param [in] hKeyRoot Root key to open, HKLM, HKCU..
 * @param [in] pszPath Path to actual registry key to access.
 * @return ERROR_SUCCESS or error value.
 */
LONG CRegKeyEx::Open(HKEY hKeyRoot, const tchar_t* pszPath)
{
	return OpenWithAccess(hKeyRoot, pszPath, KEY_ALL_ACCESS);
}

/**
 * @brief Opens or creates a key in given path with access control.
 * @param [in] hKeyRoot Root key to open, HKLM, HKCU..
 * @param [in] pszPath Path to actual registry key to access.
 * @param [in] regsam Registry access parameter.
 * @return ERROR_SUCCESS or error value.
 */
LONG CRegKeyEx::OpenWithAccess(HKEY hKeyRoot, const tchar_t* pszPath, REGSAM regsam)
{
	DWORD dw;

	Close();
	m_sPath = pszPath;

	return RegCreateKeyEx(hKeyRoot, pszPath, 0L, nullptr,
		REG_OPTION_NON_VOLATILE, regsam, nullptr, 
		&m_hKey, &dw);
}

/**
 * @brief Opens key in given path.
 * @param [in] hKeyRoot Root key to open, HKLM, HKCU..
 * @param [in] pszPath Path to actual registry key to access.
 * @param [in] regsam Registry access parameter.
 * @return ERROR_SUCCESS or error value.
 */
LONG CRegKeyEx::OpenNoCreateWithAccess(HKEY hKeyRoot, const tchar_t* pszPath, REGSAM regsam)
{
	Close();

	m_sPath = pszPath;

	return RegOpenKeyEx (hKeyRoot, pszPath, 0L, regsam, &m_hKey);
}

/**
 * @brief Opens registry key from HKEY_LOCAL_MACHINE for reading.
 * @param [in] key Path to actual registry key to access.
 * @return true on success, false otherwise.
 */
bool CRegKeyEx::QueryRegMachine(const tchar_t* key)
{
	return OpenNoCreateWithAccess(HKEY_LOCAL_MACHINE, key, KEY_QUERY_VALUE) == ERROR_SUCCESS;
}

/**
 * @brief Opens registry key from HKEY_CURRENT_USER for reading.
 * @param [in] key Path to actual registry key to access.
 * @return true on success, false otherwise.
 */
bool CRegKeyEx::QueryRegUser(const tchar_t* key)
{
	return OpenNoCreateWithAccess(HKEY_CURRENT_USER, key, KEY_QUERY_VALUE) == ERROR_SUCCESS;
}

/**
 * @brief Write DWORD value to registry.
 * @param [in] pszKey Path to actual registry key to access.
 * @param [in] dwVal Value to write.
 * @return ERROR_SUCCESS on success, or error value.
 */
LONG CRegKeyEx::WriteDword(const tchar_t* pszKey, DWORD dwVal)
{
	assert(m_hKey != nullptr);
	assert(pszKey != nullptr);
	return RegSetValueEx(m_hKey, pszKey, 0L, REG_DWORD,
		(const LPBYTE) &dwVal, sizeof(DWORD));
}

/**
 * @brief Write `bool` value to registry.
 * @param [in] pszKey Path to actual registry key to access.
 * @param [in] bVal Value to write.
 * @return ERROR_SUCCESS on success, or error value.
 */
LONG CRegKeyEx::WriteBool(const tchar_t* pszKey, bool bVal)
{
	assert(m_hKey != nullptr);
	assert(pszKey != nullptr);
	DWORD dwVal = (DWORD)bVal; 
	return RegSetValueEx(m_hKey, pszKey, 0L, REG_DWORD,
		(const LPBYTE) &dwVal, sizeof(DWORD));
}

/**
 * @brief Write float value to registry.
 * @param [in] pszKey Path to actual registry key to access.
 * @param [in] fVal Value to write.
 * @return ERROR_SUCCESS on success, or error value.
 */
LONG CRegKeyEx::WriteFloat(const tchar_t* pszKey, float fVal)
{
	assert(m_hKey != nullptr);
	assert(pszKey != nullptr);
	String s = strutils::to_str(fVal);
	return RegSetValueEx(m_hKey, pszKey, 0L, REG_SZ,
		(const LPBYTE) s.c_str(), static_cast<DWORD>((s.length() + 1))*sizeof(tchar_t) );
}

/**
 * @brief Write string value to registry.
 * @param [in] pszKey Path to actual registry key to access.
 * @param [in] pszData Value to write.
 * @return ERROR_SUCCESS on success, or error value.
 */
LONG CRegKeyEx::WriteString(const tchar_t* pszKey, const tchar_t* pszData)
{
	assert(m_hKey != nullptr);
	assert(pszKey != nullptr);
	assert(pszData != nullptr);

	return RegSetValueEx(m_hKey, pszKey, 0L, REG_SZ,
		(const LPBYTE) pszData, static_cast<DWORD>(tc::tcslen(pszData)+ 1)*sizeof(tchar_t));
}

/**
 * @brief Read DWORD value from registry.
 * @param [in] pszKey Path to actual registry key to access.
 * @param [in] defval Default value to return if reading fails.
 * @return Read DWORD value.
 */
DWORD CRegKeyEx::ReadDword(const tchar_t* pszKey, DWORD defval)
{
	assert(m_hKey != nullptr);
	assert(pszKey != nullptr);

	DWORD dwType;
	DWORD dwSize = sizeof (DWORD);
	DWORD dwDest;

	LONG lRet = RegQueryValueEx (m_hKey, (tchar_t*) pszKey, nullptr, 
		&dwType, (LPBYTE) &dwDest, &dwSize);

	if (lRet == ERROR_SUCCESS)
		return dwDest;
	else
		return defval;
}

/**
 * @brief Read LONG value from registry.
 * @param [in] pszKey Path to actual registry key to access.
 * @param [in] defval Default value to return if reading fails.
 * @return Read LONG value.
 */
LONG CRegKeyEx::ReadLong(const tchar_t* pszKey, LONG defval)
{
	return (LONG)ReadDword(pszKey, (DWORD)defval);
}

/**
 * @brief Read UINT value from registry.
 * @param [in] pszKey Path to actual registry key to access.
 * @param [in] defval Default value to return if reading fails.
 * @return Read UINT value.
 */
UINT CRegKeyEx::ReadUint(const tchar_t* pszKey, UINT defval)
{
	return (UINT)ReadDword(pszKey, (DWORD)defval);
}

/**
 * @brief Read UINT value from registry.
 * @param [in] pszKey Path to actual registry key to access.
 * @param [in] defval Default value to return if reading fails.
 * @return Read UINT value.
 */
UINT CRegKeyEx::ReadInt(const tchar_t* pszKey, int defval)
{
	return (int)ReadDword(pszKey, (DWORD)defval);
}

/**
 * @brief Read short int value from registry.
 * @param [in] pszKey Path to actual registry key to access.
 * @param [in] defval Default value to return if reading fails.
 * @return Read short int value.
 */
short int CRegKeyEx::ReadShort(const tchar_t* pszKey, short int defval)
{
	return (short int)ReadDword(pszKey, (DWORD)defval);
}

/**
 * @brief Read BYTE value from registry.
 * @param [in] pszKey Path to actual registry key to access.
 * @param [in] defval Default value to return if reading fails.
 * @return Read BYTE value.
 */
BYTE CRegKeyEx::ReadByte(const tchar_t* pszKey, BYTE defval)
{
	return (BYTE)ReadDword(pszKey, (DWORD)defval);
}

/**
 * @brief Read float value from registry.
 * @param [in] pszKey Path to actual registry key to access.
 * @param [in] defval Default value to return if reading fails.
 * @return Read float value.
 */
float CRegKeyEx::ReadFloat(const tchar_t* pszKey, float defval)
{
	assert(m_hKey != nullptr);
	assert(pszKey != nullptr);

	DWORD dwType;
	DWORD dwSize = 100;
	tchar_t  string[100];

	LONG lReturn = RegQueryValueEx(m_hKey, (tchar_t*) pszKey, nullptr,
		&dwType, (LPBYTE) string, &dwSize);

	if (lReturn == ERROR_SUCCESS)
		return (float)tc::tcstod(string, nullptr);
	else
		return defval;
}

/**
 * @brief Read `bool` value from registry.
 * @param [in] pszKey Path to actual registry key to access.
 * @param [in] defval Default value to return if reading fails.
 * @return Read `bool` value.
 */
bool CRegKeyEx::ReadBool(const tchar_t* pszKey, bool defval)
{
	assert(m_hKey != nullptr);
	assert(pszKey != nullptr);

	DWORD dwType;
	DWORD dwSize = sizeof(DWORD);
	DWORD dwDest;

	LONG lRet = RegQueryValueEx(m_hKey, (tchar_t*) pszKey, nullptr, 
		&dwType, (LPBYTE) &dwDest, &dwSize);

	if (lRet == ERROR_SUCCESS)
		return (dwDest!=(DWORD)0);
	else
		return defval;
}

/**
 * @brief Read String value from registry.
 * @param [in] pszKey Path to actual registry key to access.
 * @param [in] defval Default value to return if reading fails.
 * @return Read String value.
 */
String CRegKeyEx::ReadString (const tchar_t* pszKey, const tchar_t* defval)
{
	assert(m_hKey != nullptr);
	assert(pszKey != nullptr);

	DWORD dwType;
	DWORD dwSize = 0;
	String retString;

	// Get size of the string
	LONG lReturn = RegQueryValueEx(m_hKey, (tchar_t*) pszKey, nullptr,
		&dwType, nullptr, &dwSize);

	if (lReturn == ERROR_SUCCESS)
	{
		retString.resize(dwSize/sizeof(tchar_t));
		lReturn = RegQueryValueEx(m_hKey, (tchar_t*) pszKey, nullptr,
			&dwType, (LPBYTE) retString.data(), &dwSize);
		retString.resize(dwSize/sizeof(tchar_t)-1);
	}
	if (lReturn == ERROR_SUCCESS)
		return retString;
	else
		return defval;
}

/**
 * @brief Read char table from registry.
 * @param [in] pszKey Path to actual registry key to access.
 * @param [in] pData Pointer to char table where value is written to.
 * @param [in] dwLen Size of pData table in bytes.
 * @param [in] defval Default value to return if reading fails.
 */
void CRegKeyEx::ReadChars (const tchar_t* pszKey, tchar_t* pData, DWORD dwLen, const tchar_t* defval)
{
	assert(m_hKey != nullptr);
	assert(pszKey != nullptr);

	DWORD dwType;
	DWORD len = dwLen;

	LONG ret = RegQueryValueEx (m_hKey, (tchar_t*) pszKey, nullptr,
		&dwType, (LPBYTE)pData, &len);
	if (ret != ERROR_SUCCESS)
		StringCchCopy(pData, dwLen, defval);
}
</file>

<file path="Winmerge-Src/Src/Common/RegKey.h">
/** 
 * @file  RegKey.h
 *
 * @brief Declaration of CRegKeyEx C++ wrapper class for reading Windows registry
 */
#pragma once

#include <windows.h>
#include "UnicodeString.h"

/**
 * @brief Class for reading/writing registry.
 */
class CRegKeyEx
{

// Construction
public:
	CRegKeyEx();
	~CRegKeyEx();

// Operations
public:
	void Close();
	LONG Open(HKEY hKeyRoot, const tchar_t* pszPath);
	LONG OpenWithAccess(HKEY hKeyRoot, const tchar_t* pszPath, REGSAM regsam);
	LONG OpenNoCreateWithAccess(HKEY hKeyRoot, const tchar_t* pszPath, REGSAM regsam);
	bool QueryRegMachine(const tchar_t* key);
	bool QueryRegUser(const tchar_t* key);

	LONG WriteDword (const tchar_t* pszKey, DWORD dwVal);
	LONG WriteString (const tchar_t* pszKey, const tchar_t* pszVal);
	LONG WriteBool (const tchar_t* pszKey, bool bVal);
	LONG WriteFloat (const tchar_t* pszKey, float fVal);

	DWORD ReadDword (const tchar_t* pszKey, DWORD defval);
	float ReadFloat (const tchar_t* pszKey, float defval);
	bool ReadBool(const tchar_t* pszKey, bool defval);
	LONG ReadLong (const tchar_t* pszKey, LONG defval);
	UINT ReadUint (const tchar_t* pszKey, UINT defval);
	UINT ReadInt (const tchar_t* pszKey, int defval);
	short int ReadShort (const tchar_t* pszKey, short int defval);
	BYTE ReadByte (const tchar_t* pszKey, BYTE defval);
	String ReadString (const tchar_t* pszKey, const tchar_t* defval);
	void ReadChars (const tchar_t* pszKey, tchar_t* pData, DWORD dwLength, const tchar_t* defval);

protected:
	HKEY m_hKey; /**< Open key (HKLM, HKCU, etc). */
	String m_sPath; /**< Path to actual key to open. */
};
</file>

<file path="Winmerge-Src/Src/Common/RegOptionsMgr.cpp">
/**
 * @file RegOptionsMgr.cpp
 *
 * @brief Implementation of Registry Options management class.
 *
 */

#include "pch.h"
#include "RegOptionsMgr.h"
#include <windows.h>
#include <process.h>
#include <Shlwapi.h>
#include "OptionsMgr.h"

struct AsyncWriterThreadParams
{
	AsyncWriterThreadParams(const String& name, const varprop::VariantValue& value) : name(name), value(value) {}
	String name;
	varprop::VariantValue value;
};

class CRegOptionsMgr::IOHandler
{
public:
	IOHandler(const String& path) :
		m_bCloseHandle(false)
		, m_hThread(nullptr)
		, m_hEvent(nullptr)
		, m_dwThreadId(0)
		, m_dwQueueCount(0)
	{
		InitializeCriticalSection(&m_cs);
		m_hEvent = CreateEvent(nullptr, TRUE, FALSE, nullptr);
		if (m_hEvent)
		{
			m_hThread = reinterpret_cast<HANDLE>(
				_beginthreadex(nullptr, 0, AsyncWriterThreadProc, this, 0,
					reinterpret_cast<unsigned*>(&m_dwThreadId)));
			WaitForSingleObject(m_hEvent, INFINITE);
			CloseHandle(m_hEvent);
			m_hEvent = nullptr;
		}
		SetRegRootKey(path);
	}

	~IOHandler()
	{
		for (;;)
		{
			PostThreadMessage(m_dwThreadId, WM_QUIT, 0, 0);
			if (WaitForSingleObject(m_hThread, 1) != WAIT_TIMEOUT)
				break;
		}
		DeleteCriticalSection(&m_cs);
	}

	void WriteAsync(const String& name, const varprop::VariantValue& value)
	{
		auto* pParam = new AsyncWriterThreadParams(name, value);
		InterlockedIncrement(&m_dwQueueCount);
		if (!::PostThreadMessage(m_dwThreadId, WM_USER, (WPARAM)pParam, 0))
		{
			delete pParam;
			InterlockedDecrement(&m_dwQueueCount);
		}
	}

	HKEY OpenKey(const String& strPath, bool bAlwaysCreate)
	{
		String strRegPath(m_registryRoot);
		strRegPath += strPath;
		HKEY hKey = nullptr;
		if (m_hKeys.find(strPath) == m_hKeys.end())
		{
			DWORD action = 0;
			LONG retValReg;
			if (bAlwaysCreate)
			{
				retValReg = RegCreateKeyEx(HKEY_CURRENT_USER, strRegPath.c_str(),
					0, nullptr, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, nullptr,
					&hKey, &action);
			}
			else
			{
				retValReg = RegOpenKeyEx(HKEY_CURRENT_USER, strRegPath.c_str(),
					0, KEY_ALL_ACCESS, &hKey);
			}
			if (retValReg != ERROR_SUCCESS)
				return nullptr;

			m_hKeys[strPath] = hKey;
		}
		else
		{
			hKey = m_hKeys[strPath];
		}
		return hKey;
	}

	void CloseKey(HKEY hKey, const String& strPath)
	{
		if (m_bCloseHandle)
		{
			if (hKey)
				RegCloseKey(hKey);
			m_hKeys.erase(strPath);
		}
	}

	void CloseKeys()
	{
		EnterCriticalSection(&m_cs);
		for (auto& pair : m_hKeys)
			RegCloseKey(pair.second);
		m_hKeys.clear();
		LeaveCriticalSection(&m_cs);
	}

	/**
	 * @brief Save value to registry.
	 *
	 * Saves one value to registry to key previously opened. Type of
	 * value is determined from given value parameter.
	 * @param [in] hKey Handle to open registry key
	 * @param [in] strValueName Name of value to write
	 * @param [in] value value to write to registry value
	 * @todo Handles only string and integer types
	 */
	int SaveValueToReg(HKEY hKey, const String& strValueName,
		const varprop::VariantValue& value)
	{
		LONG retValReg = 0;
		int valType = value.GetType();
		int retVal = COption::OPT_OK;

		if (valType == varprop::VT_STRING)
		{
			String strVal = value.GetString();
			if (strVal.length() > 0)
			{
				retValReg = RegSetValueEx(hKey, strValueName.c_str(), 0, REG_SZ,
						(LPBYTE)strVal.c_str(), (DWORD)(strVal.length() + 1) * sizeof(tchar_t));
			}
			else
			{
				tchar_t str[1] = {0};
				retValReg = RegSetValueEx(hKey, strValueName.c_str(), 0, REG_SZ,
						(LPBYTE)&str, 1 * sizeof(tchar_t));
			}
		}
		else if (valType == varprop::VT_INT)
		{
			DWORD dwordVal = value.GetInt();
			retValReg = RegSetValueEx(hKey, strValueName.c_str(), 0, REG_DWORD,
					(LPBYTE)&dwordVal, sizeof(DWORD));
		}
		else if (valType == varprop::VT_BOOL)
		{
			DWORD dwordVal = value.GetBool() ? 1 : 0;
			retValReg = RegSetValueEx(hKey, strValueName.c_str(), 0, REG_DWORD,
					(LPBYTE)&dwordVal, sizeof(DWORD));
		}
		else
		{
			retVal = COption::OPT_UNKNOWN_TYPE;
		}
			
		if (retValReg != ERROR_SUCCESS)
		{
			retVal = COption::OPT_ERR;
		}
		return retVal;
	}

	LONG Read(const String& name, std::vector<unsigned char>& dataBuf, DWORD& type)
	{
		// Figure out registry path, for saving value
		auto [strPath, strValueName] = SplitName(name);

		// Open key.
		EnterCriticalSection(&m_cs);
		HKEY hKey = OpenKey(strPath, false);

		// Check previous value
		// This just checks if the value exists, LoadValueFromReg() below actually
		// loads the value.
		if (dataBuf.size() < 256)
			dataBuf.resize(256);
		type = 0;
		DWORD size = static_cast<DWORD>(dataBuf.size());
		LONG retValReg;
		if (hKey)
		{
			dataBuf[0] = 0;
			retValReg = RegQueryValueEx(hKey, strValueName.c_str(),
				0, &type, dataBuf.data(), &size);
		}
		else
			retValReg = ERROR_FILE_NOT_FOUND;

		// Value didn't exist. Do nothing
		if (retValReg == ERROR_FILE_NOT_FOUND)
		{
		}
		// Value already exists so read it.
		else if (retValReg == ERROR_SUCCESS)
		{
		}
		else if (retValReg == ERROR_MORE_DATA)
		{
			dataBuf.resize(size);
			retValReg = RegQueryValueEx(hKey, strValueName.c_str(),
				0, &type, dataBuf.data(), &size);
		}

		CloseKey(hKey, strPath);
		LeaveCriticalSection(&m_cs);
		return retValReg;
	}

	int Remove(const String& name)
	{
		int retVal = COption::OPT_OK;
		auto [strPath, strValueName] = SplitName(name);

		while (InterlockedCompareExchange(&m_dwQueueCount, 0, 0) != 0)
			Sleep(0);

		EnterCriticalSection(&m_cs);
		HKEY hKey = OpenKey(strPath, true);
		if (strValueName.empty())
	#ifdef _WIN64
			RegDeleteTree(hKey, nullptr);
	#else
			SHDeleteKey(hKey, nullptr);
	#endif
		else
			RegDeleteValue(hKey, strValueName.c_str());
		CloseKey(hKey, strPath);
		LeaveCriticalSection(&m_cs);

		return retVal;
	}

	int WaitForQueueFlush()
	{
		int retVal = COption::OPT_OK;

		while (InterlockedCompareExchange(&m_dwQueueCount, 0, 0) != 0)
			Sleep(0);

		return retVal;
	}

	int ExportAllUnloadedValues(const String& filename, const OptionsMap& optionsMap) const
	{
		HKEY hKey = nullptr;
		if (RegOpenKeyEx(HKEY_CURRENT_USER, m_registryRoot.c_str(), 0, KEY_READ, &hKey) != ERROR_SUCCESS)
			return COption::OPT_ERR;
		int retVal = ExportAllUnloadedValues(hKey, _T(""), filename, optionsMap);
		RegCloseKey(hKey);
		return retVal;
	}

	int ExportAllUnloadedValues(HKEY hKey, const String& strPath, const String& filename, const OptionsMap& optionsMap) const
	{
		DWORD dwIndex = 0;
		tchar_t szValueName[MAX_PATH];
		std::vector<BYTE> data(MAX_PATH);
		for (;;)
		{
			DWORD dwType;
			DWORD cbValueName = MAX_PATH;
			DWORD cbData = static_cast<DWORD>(data.size());
			LSTATUS result = RegEnumValue(hKey, dwIndex, szValueName, &cbValueName, nullptr, &dwType, data.data(), &cbData);
			if (result == ERROR_MORE_DATA)
			{
				cbValueName = MAX_PATH;
				cbData *= 2;
				data.resize(cbData);
				result = RegEnumValue(hKey, dwIndex, szValueName, &cbValueName, nullptr, &dwType, data.data(), &cbData);
			}
			if (result == ERROR_SUCCESS)
			{
				String strName = strPath + _T("/") + szValueName;
				if (optionsMap.find(strName) == optionsMap.end())
				{
					varprop::VariantValue value;
					switch (dwType)
					{
					case REG_DWORD:
						WritePrivateProfileString(_T("WinMerge"), strName.c_str(),
							strutils::to_str(*(reinterpret_cast<int*>(data.data()))).c_str(), filename.c_str());
						WritePrivateProfileString(_T("WinMerge.TypeInfo"), strName.c_str(),
								_T("int"), filename.c_str());
						break;
					case REG_SZ:
						// https://learn.microsoft.com/en-us/answers/questions/578134/error-in-writeprivateprofilestring-function-when-j
						WritePrivateProfileString(_T("WinMerge"), strName.c_str(),
							nullptr, filename.c_str());
						WritePrivateProfileString(_T("WinMerge"), strName.c_str(),
							EscapeValue(reinterpret_cast<tchar_t*>(data.data())).c_str(), filename.c_str());
						WritePrivateProfileString(_T("WinMerge.TypeInfo"), strName.c_str(),
								_T("string"), filename.c_str());
						break;
					default:
						break;
					}
				}
				dwIndex++;
			}
			else if (result == ERROR_NO_MORE_ITEMS)
			{
				break;
			}
			else
			{
				return COption::OPT_ERR;
			}
		}

		dwIndex = 0;
		tchar_t szSubKey[MAX_PATH];
		DWORD cbSubKey = MAX_PATH;
		for (;;)
		{
			LSTATUS result = RegEnumKeyEx(hKey, dwIndex, szSubKey, &cbSubKey, nullptr, nullptr, nullptr, nullptr);
			if (result == ERROR_SUCCESS)
			{
				HKEY hSubKey = nullptr;
				if (RegOpenKeyEx(hKey, szSubKey, 0, KEY_READ, &hSubKey) == ERROR_SUCCESS)
				{
					int retVal = ExportAllUnloadedValues(hSubKey, strPath.empty() ? szSubKey : strPath + _T("\\") + szSubKey, filename, optionsMap);
					RegCloseKey(hSubKey);
					if (retVal != COption::OPT_OK)
						return retVal;
				}
				dwIndex++;
				cbSubKey = MAX_PATH;
			}
			else if (result == ERROR_NO_MORE_ITEMS)
			{
				break;
			}
			else
			{
				return COption::OPT_ERR;
			}
		}
		return COption::OPT_OK;
	}

	int ImportAllUnloadedValues(const String& filename, OptionsMap& optionsMap)
	{
		auto iniFileKeyValues = ReadIniFile(filename, _T("WinMerge"));
		auto iniFileKeyTypes = ReadIniFile(filename, _T("WinMerge.TypeInfo"));
		for (const auto& [key, strValue] : iniFileKeyValues)
		{
			if (optionsMap.find(key) == optionsMap.end() &&
				iniFileKeyTypes.find(key) != iniFileKeyTypes.end())
			{
				auto [strPath, strValueName] = SplitName(key);
				HKEY hKey = OpenKey(strPath, true);
				if (hKey)
				{
					varprop::VariantValue value;
					String strType = iniFileKeyTypes[key];
					if (tc::tcsicmp(strType.c_str(), _T("bool")) == 0)
						value.SetBool(tc::ttoi(strValue.c_str()) != 0);
					else if (tc::tcsicmp(strType.c_str(), _T("int")) == 0)
					{
						tchar_t* endptr = nullptr;
						unsigned uval = static_cast<unsigned>(tc::tcstoll(strValue.c_str(), &endptr,
							(strValue.length() >= 2 && strValue[1] == 'x') ? 16 : 10));
						value.SetInt(static_cast<int>(uval));
					}
					else if (tc::tcsicmp(strType.c_str(), _T("string")) == 0)
						value.SetString(strValue);
					SaveValueToReg(hKey, strValueName, value);
					CloseKey(hKey, strPath);
				}
			}
		}
		return COption::OPT_OK;
	}

	/**
	 * @brief Set registry root path for options.
	 *
	 * Sets path used as root path when loading/saving options. Paths
	 * given to other functions are relative to this path.
	 */
	int SetRegRootKey(const String& key)
	{
		String keyname(key);
		HKEY hKey = nullptr;
		DWORD action = 0;
		int retVal = COption::OPT_OK;

		size_t ind = keyname.find(_T("Software"));
		if (ind != 0)
			keyname.insert(0, _T("Software\\"));
		
		m_registryRoot = std::move(keyname);

		LONG retValReg =  RegCreateKeyEx(HKEY_CURRENT_USER, m_registryRoot.c_str(), 0, nullptr,
			REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, nullptr, &hKey, &action);

		if (retValReg == ERROR_SUCCESS)
		{
			if (action == REG_CREATED_NEW_KEY)
			{
				// TODO: At least log message..?
			}
			RegCloseKey(hKey);
		}
		else
		{
			retVal = COption::OPT_ERR;
		}

		return retVal;
	}

	static unsigned __stdcall AsyncWriterThreadProc(void *pvThis)
	{
		CRegOptionsMgr::IOHandler *pThis = reinterpret_cast<CRegOptionsMgr::IOHandler *>(pvThis);
		MSG msg;
		BOOL bRet;
		// create message queue
		PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE);
		SetEvent(pThis->m_hEvent);
		while ((bRet = GetMessage(&msg, 0, 0, 0)) != 0)
		{
			auto* pParam = reinterpret_cast<AsyncWriterThreadParams *>(msg.wParam);
			if (msg.message == WM_USER && pParam)
			{
				auto [strPath, strValueName] = COptionsMgr::SplitName(pParam->name);
				EnterCriticalSection(&pThis->m_cs);
				HKEY hKey = pThis->OpenKey(strPath, true);
				pThis->SaveValueToReg(hKey, strValueName, pParam->value);
				pThis->CloseKey(hKey, strPath);
				LeaveCriticalSection(&pThis->m_cs);
				delete pParam;
				InterlockedDecrement(&pThis->m_dwQueueCount);
			}
		}
		return 0;
	}

private:
	String m_registryRoot; /**< Registry path where to store options. */
	bool m_bCloseHandle;
	std::map<String, HKEY> m_hKeys;
	CRITICAL_SECTION m_cs;
	DWORD m_dwThreadId;
	DWORD m_dwQueueCount;
	HANDLE m_hThread;
	HANDLE m_hEvent;
};

CRegOptionsMgr::CRegOptionsMgr(const String& path)
	: m_serializing(true)
	, m_pIOHandler(std::make_unique<IOHandler>(path))
{
}

CRegOptionsMgr::~CRegOptionsMgr()
{
	m_pIOHandler.reset();
}

int CRegOptionsMgr::LoadValueFromBuf(const String& strName, unsigned type, const unsigned char* data, varprop::VariantValue& value)
{
	int retVal = COption::OPT_OK;
	int valType = value.GetType();
	if (type == REG_SZ && valType == varprop::VT_STRING )
	{
		value.SetString((tchar_t *)&data[0]);
		retVal = Set(strName, value);
	}
	else if (type == REG_DWORD)
	{
		if (valType == varprop::VT_INT)
		{
			DWORD dwordValue;
			CopyMemory(&dwordValue, &data[0], sizeof(DWORD));
			value.SetInt(dwordValue);
			retVal = Set(strName, value);
		}
		else if (valType == varprop::VT_BOOL)
		{
			DWORD dwordValue;
			CopyMemory(&dwordValue, &data[0], sizeof(DWORD));
			value.SetBool(dwordValue > 0 ? true : false);
			retVal = Set(strName, value);
		}
		else
			retVal = COption::OPT_WRONG_TYPE;
	}
	else
		retVal = COption::OPT_WRONG_TYPE;

	return retVal;
}

/**
 * @brief Init and add new option.
 *
 * Adds new option to list of options. Sets value to default value.
 * If option does not exist in registry, saves with default value.
 */
int CRegOptionsMgr::InitOption(const String& name, const varprop::VariantValue& defaultValue)
{
	// Check type & bail if null
	int valType = defaultValue.GetType();
	if (valType == varprop::VT_NULL)
		return COption::OPT_ERR;

	// If we're not loading & saving options, bail
	if (!m_serializing)
		return AddOption(name, defaultValue);

	// Actually save value into our in-memory options table
	int retVal = AddOption(name, defaultValue);
	if (retVal == COption::OPT_OK)
	{
		DWORD type = 0;
		std::vector<unsigned char> dataBuf(256);
		if (m_pIOHandler->Read(name, dataBuf, type) == ERROR_SUCCESS)
		{
			varprop::VariantValue value(defaultValue);
			retVal = LoadValueFromBuf(name, type, dataBuf.data(), value);
		}
	}

	return retVal;
}

/**
 * @brief Init and add new string option.
 *
 * Adds new option to list of options. Sets value to default value.
 * If option does not exist in registry, saves with default value.
 */
int CRegOptionsMgr::InitOption(const String& name, const String& defaultValue)
{
	varprop::VariantValue defValue;
	defValue.SetString(defaultValue);
	return InitOption(name, defValue);
}

int CRegOptionsMgr::InitOption(const String& name, const tchar_t *defaultValue)
{
	return InitOption(name, String(defaultValue));
}

/**
 * @brief Init and add new int option.
 *
 * Adds new option to list of options. Sets value to default value.
 * If option does not exist in registry, saves with default value.
 */
int CRegOptionsMgr::InitOption(const String& name, int defaultValue, bool serializable)
{
	varprop::VariantValue defValue;
	int retVal = COption::OPT_OK;

	defValue.SetInt(defaultValue);
	if (serializable)
		retVal = InitOption(name, defValue);
	else
		AddOption(name, defValue);
	return retVal;
}

/**
 * @brief Init and add new boolean option.
 *
 * Adds new option to list of options. Sets value to default value.
 * If option does not exist in registry, saves with default value.
 */
int CRegOptionsMgr::InitOption(const String& name, bool defaultValue)
{
	varprop::VariantValue defValue;
	defValue.SetBool(defaultValue);
	return InitOption(name, defValue);
}

/**
 * @brief Save option to registry
 * @note Currently handles only integer and string options!
 */
int CRegOptionsMgr::SaveOption(const String& name)
{
	if (!m_serializing) return COption::OPT_OK;

	varprop::VariantValue value;
	int retVal = COption::OPT_OK;

	value = Get(name);
	int valType = value.GetType();
	if (valType == varprop::VT_NULL)
		retVal = COption::OPT_NOTFOUND;

	if (retVal == COption::OPT_OK)
		m_pIOHandler->WriteAsync(name, value);

	return retVal;
}

/**
 * @brief Set new value for option and save option to registry
 */
int CRegOptionsMgr::SaveOption(const String& name, const varprop::VariantValue& value)
{
	int retVal = Set(name, value);
	if (retVal == COption::OPT_OK)
		retVal = SaveOption(name);
	return retVal;
}

/**
 * @brief Set new string value for option and save option to registry
 */
int CRegOptionsMgr::SaveOption(const String& name, const String& value)
{
	varprop::VariantValue val;
	val.SetString(value);
	int retVal = Set(name, val);
	if (retVal == COption::OPT_OK)
		retVal = SaveOption(name);
	return retVal;
}

/**
 * @brief Set new string value for option and save option to registry
 */
int CRegOptionsMgr::SaveOption(const String& name, const tchar_t *value)
{
	return SaveOption(name, String(value));
}

/**
 * @brief Set new integer value for option and save option to registry
 */
int CRegOptionsMgr::SaveOption(const String& name, int value)
{
	varprop::VariantValue val;
	val.SetInt(value);
	int retVal = Set(name, val);
	if (retVal == COption::OPT_OK)
		retVal = SaveOption(name);
	return retVal;
}

/**
 * @brief Set new boolean value for option and save option to registry
 */
int CRegOptionsMgr::SaveOption(const String& name, bool value)
{
	varprop::VariantValue val;
	val.SetBool(value);
	int retVal = Set(name, val);
	if (retVal == COption::OPT_OK)
		retVal = SaveOption(name);
	return retVal;
}

int CRegOptionsMgr::RemoveOption(const String& name)
{
	int retVal = COption::OPT_OK;
	auto [strPath, strValueName] = SplitName(name);

	if (!strValueName.empty())
	{
		retVal = COptionsMgr::RemoveOption(name);
	}
	else
	{
		for (auto it = m_optionsMap.begin(); it != m_optionsMap.end(); )
		{
			const String& key = it->first;
			if (key.find(strPath) == 0 && key.length() > strPath.length() && key[strPath.length()] == '/')
				it = m_optionsMap.erase(it);
			else
				++it;
		}
		retVal = COption::OPT_OK;
	}

	m_pIOHandler->Remove(name);

	return retVal;
}

int CRegOptionsMgr::FlushOptions()
{
	return m_pIOHandler->WaitForQueueFlush();
}

int CRegOptionsMgr::ExportOptions(const String& filename, const bool bHexColor /*= false*/) const
{
	int retVal = m_pIOHandler->ExportAllUnloadedValues(filename, m_optionsMap);
	if (retVal == COption::OPT_OK)
		retVal = COptionsMgr::ExportOptions(filename, bHexColor);
	return retVal;
}

int CRegOptionsMgr::ImportOptions(const String& filename)
{
	int retVal = m_pIOHandler->ImportAllUnloadedValues(filename, m_optionsMap);
	if (retVal == COption::OPT_OK)
		retVal = COptionsMgr::ImportOptions(filename);
	return retVal;
}

void CRegOptionsMgr::CloseKeys()
{
	m_pIOHandler->CloseKeys();
}

</file>

<file path="Winmerge-Src/Src/Common/RegOptionsMgr.h">
/**
 * @file RegOptionsMgr.h
 *
 * @brief Declaration for Registry options class.
 *
 */
#pragma once

#include "OptionsMgr.h"

class COptionsMgr;

/**
 * @brief Registry-based implementation of OptionsMgr interface (q.v.).
 */
class CRegOptionsMgr : public COptionsMgr
{
public:
	explicit CRegOptionsMgr(const String& path);
	virtual ~CRegOptionsMgr();
	CRegOptionsMgr(const CRegOptionsMgr&) = delete;
	CRegOptionsMgr& operator=(const CRegOptionsMgr&) = delete;

	void CloseKeys();

	virtual int InitOption(const String& name, const varprop::VariantValue& defaultValue) override;
	virtual int InitOption(const String& name, const String& defaultValue) override;
	virtual int InitOption(const String& name, const tchar_t* defaultValue) override;
	virtual int InitOption(const String& name, int defaultValue, bool serializable = true) override;
	virtual int InitOption(const String& name, bool defaultValue) override;

	virtual int SaveOption(const String& name) override;
	virtual int SaveOption(const String& name, const varprop::VariantValue& value) override;
	virtual int SaveOption(const String& name, const String& value) override;
	virtual int SaveOption(const String& name, const tchar_t* value) override;
	virtual int SaveOption(const String& name, int value) override;
	virtual int SaveOption(const String& name, bool value) override;

	virtual int RemoveOption(const String& name) override;

	virtual int FlushOptions() override;

	virtual int ExportOptions(const String& filename, const bool bHexColor=false) const override;
	virtual int ImportOptions(const String& filename) override;

	virtual void SetSerializing(bool serializing = true) override { m_serializing = serializing; }

protected:
	int LoadValueFromBuf(const String& strName, unsigned type, const unsigned char* data, varprop::VariantValue& value);

private:
	bool m_serializing;
	class IOHandler;
	std::unique_ptr<IOHandler> m_pIOHandler;
};
</file>

<file path="Winmerge-Src/Src/Common/RoundedRectWithShadow.cpp">
// Copyright (c) 2024 Takashi Sawanaka
// SPDX-License-Identifier: BSL-1.0
/** 
 * @file  RoundedRectWithShadow.cpp
 *
 * @brief Provides functions to draw rounded rectangles with shadows in a Win32 GDI context.
 *
 */
#include "StdAfx.h"
#include <cmath>
#include <algorithm>

struct RoundedRectWithShadow
{
	using dibcolor_t = unsigned int;

	RoundedRectWithShadow(int left, int top, int width, int height, int radius, int shadowWidth,
		COLORREF colorRoundedRect, COLORREF colorShadow, COLORREF colorBackground)
		: m_left(left)
		, m_top(top)
		, m_width(width)
		, m_height(height)
		, m_radius(radius)
		, m_shadowWidth(shadowWidth)
		, m_colorRoundedRect(COLORREFtoDIBColor_t(colorRoundedRect))
		, m_colorShadow(COLORREFtoDIBColor_t(colorShadow))
		, m_colorBackground(COLORREFtoDIBColor_t(colorBackground))
		, m_leftCircleCenterX(left + radius)
		, m_topCircleCenterY(top + radius)
		, m_rightCircleCenterX(left + width - radius)
		, m_bottomCircleCenterY(top + height - radius)
	{
	}

	static inline double sqr(double x) { return x * x; }

	static double distance(double x1, double y1, double x2, double y2)
	{
		return std::sqrt(sqr(x1 - x2) + sqr(y1 - y2));
	}

	static dibcolor_t COLORREFtoDIBColor_t(COLORREF color)
	{
		const BYTE r = GetRValue(color);
		const BYTE g = GetGValue(color);
		const BYTE b = GetBValue(color);
		return (r << 16) | (g << 8) | b;
	}

	static dibcolor_t interpolateColor(dibcolor_t color1, dibcolor_t color2, double t)
	{
		const unsigned char r1 = (color1 >> 16) & 0xff;
		const unsigned char g1 = (color1 >> 8) & 0xff;
		const unsigned char b1 = (color1) & 0xff;

		const unsigned char r2 = (color2 >> 16) & 0xff;
		const unsigned char g2 = (color2 >> 8) & 0xff;
		const unsigned char b2 = (color2) & 0xff;

		const unsigned char r = static_cast<unsigned char>(r1 + t * (r2 - r1));
		const unsigned char g = static_cast<unsigned char>(g1 + t * (g2 - g1));
		const unsigned char b = static_cast<unsigned char>(b1 + t * (b2 - b1));

		return (r << 16) | (g << 8) | b;
	}

	dibcolor_t getColor(int x, int y) const
	{
		if ((m_leftCircleCenterX <= x && x < m_rightCircleCenterX &&
			m_top <= y && y < m_top + m_height) ||
			(m_left <= x && x < m_left + m_width &&
				m_topCircleCenterY <= y && y < m_bottomCircleCenterY))
		{
			return m_colorRoundedRect;
		}

		double min_distance = (std::numeric_limits<double>::max)();
		if (y < m_top)
		{
			if (m_leftCircleCenterX <= x && x < m_rightCircleCenterX)
				min_distance = m_top - y;
		}
		else if (y > m_top + m_height)
		{
			if (m_leftCircleCenterX <= x && x < m_rightCircleCenterX)
				min_distance = y - (m_top + m_height) + 1;
		}
		else if (x < m_left)
		{
			if (m_topCircleCenterY <= y && y < m_bottomCircleCenterY)
				min_distance = m_left - x;
		}
		else if (x > m_left + m_width)
		{
			if (m_topCircleCenterY <= y && y < m_bottomCircleCenterY)
				min_distance = x - (m_left + m_width) + 1;
		}

		if (min_distance == (std::numeric_limits<double>::max)())
		{
			const double cx = (x < (m_left + m_left + m_width) / 2) ? m_leftCircleCenterX : m_rightCircleCenterX - 1;
			const double cy = (y < (m_top + m_top + m_height) / 2) ? m_topCircleCenterY : m_bottomCircleCenterY - 1;
			const double dist = distance(x, y, cx, cy);
			if (dist <= m_radius)
				return m_colorRoundedRect;
			min_distance = (std::min)(min_distance, dist - m_radius);
		}

		if (min_distance < 1.0)
			return interpolateColor(m_colorRoundedRect, m_shadowWidth == 0 ? m_colorBackground : m_colorShadow, min_distance);
		if (min_distance > m_shadowWidth)
			return m_colorBackground;
		const double t = std::sqrt(1.0 - sqr((min_distance - 1.0) / m_shadowWidth - 1.0));
		return interpolateColor(m_colorShadow, m_colorBackground, t);
	}

	void DrawPartialRoundedRectWithShadow(void* pBits, int pleft, int ptop, int pwidth, int pheight)
	{
		if (pleft < m_left - m_shadowWidth || pleft + pwidth > m_left + m_width + m_shadowWidth)
			return;
		if (ptop < m_top - m_shadowWidth || ptop + pheight > m_top + m_height + m_shadowWidth)
			return;
		const int left = m_left;
		const int top = m_top;
		const int shadowWidth = m_shadowWidth;
		const int pitch = m_width + m_shadowWidth * 2;
		if (m_left + m_radius <= pleft && pleft + pwidth <= m_left + m_width - m_radius)
		{
			for (int y = ptop; y < ptop + pheight; y++)
			{
				dibcolor_t color = getColor(pleft, y);
				for (int x = pleft; x < pleft + pwidth; x++)
					((dibcolor_t*)pBits)[(y - (top - shadowWidth)) * pitch + (x - (left - shadowWidth))] = color;
			}
		}
		else if (m_top + m_radius <= ptop && ptop + pheight <= m_top + m_height - m_radius)
		{
			for (int x = pleft; x < pleft + pwidth; x++)
			{
				dibcolor_t color = getColor(x, ptop);
				for (int y = ptop; y < ptop + pheight; y++)
					((dibcolor_t*)pBits)[(y - (top - shadowWidth)) * pitch + (x - (left - shadowWidth))] = color;
			}
		}
		else
		{
			for (int y = ptop; y < ptop + pheight; y++)
			{
				for (int x = pleft; x < pleft + pwidth; x++)
				{
					dibcolor_t color = getColor(x, y);
					((dibcolor_t*)pBits)[(y - (top - shadowWidth)) * pitch + (x - (left - shadowWidth))] = color;
				}
			}
		}
	}

	int m_left;
	int m_top;
	int m_width;
	int m_height;
	int m_radius;
	int m_shadowWidth;
	int m_leftCircleCenterX;
	int m_topCircleCenterY;
	int m_rightCircleCenterX;
	int m_bottomCircleCenterY;
	dibcolor_t m_colorRoundedRect;
	dibcolor_t m_colorShadow;
	dibcolor_t m_colorBackground;
};

void DrawRoundedRectWithShadow(HDC hdc, int left, int top, int width, int height, int radius, int shadowWidth,
	COLORREF roundedRectColor, COLORREF shadowColor, COLORREF backgroundColor)
{
	RoundedRectWithShadow rr(left, top, width, height, radius, shadowWidth, roundedRectColor, shadowColor, backgroundColor);

	HDC hdcMem = CreateCompatibleDC(hdc);
	if (!hdcMem)
		return;
	BITMAPINFO bmi{ sizeof(BITMAPINFOHEADER), width + shadowWidth * 2, -(height + shadowWidth * 2), 1, 32, BI_RGB };
	RoundedRectWithShadow::dibcolor_t* pBits;
	HBITMAP memBitmap = CreateDIBSection(hdcMem, &bmi, DIB_RGB_COLORS, (void**)&pBits, nullptr, 0);
	if (memBitmap)
	{
		HBITMAP oldBitmap = (HBITMAP)SelectObject(hdcMem, memBitmap);

		std::fill_n(pBits, (width + shadowWidth * 2) * (height + shadowWidth * 2), rr.COLORREFtoDIBColor_t(roundedRectColor));

		// Draw the shadow on the top side
		rr.DrawPartialRoundedRectWithShadow(pBits, left + radius, top - shadowWidth, width - 2 * radius, shadowWidth);
		// Draw the shadow on the bottom side
		rr.DrawPartialRoundedRectWithShadow(pBits, left + radius, top + height, width - 2 * radius, shadowWidth);
		// Draw the shadow on the left side
		rr.DrawPartialRoundedRectWithShadow(pBits, left - shadowWidth, top + radius, shadowWidth, height - 2 * radius);
		// Draw the shadow on the right side
		rr.DrawPartialRoundedRectWithShadow(pBits, left + width, top + radius, shadowWidth, height - 2 * radius);
		// Draw the top-left rounded corner and shadow
		rr.DrawPartialRoundedRectWithShadow(pBits, left - shadowWidth, top - shadowWidth, shadowWidth + radius, shadowWidth + radius);
		// Draw the top-right rounded corner and shadow
		rr.DrawPartialRoundedRectWithShadow(pBits, left + width - radius, top - shadowWidth, shadowWidth + radius, shadowWidth + radius);
		// Draw the bottom-left rounded corner and shadow
		rr.DrawPartialRoundedRectWithShadow(pBits, left - shadowWidth, top + height - radius, shadowWidth + radius, shadowWidth + radius);
		// Draw the bottom-right rounded corner and shadow
		rr.DrawPartialRoundedRectWithShadow(pBits, left + width - radius, top + height - radius, shadowWidth + radius, shadowWidth + radius);

		BitBlt(hdc, left - shadowWidth, top - shadowWidth, width + 2 * shadowWidth, height + 2 * shadowWidth, hdcMem, 0, 0, SRCCOPY);

		SelectObject(hdcMem, oldBitmap);
		DeleteObject(memBitmap);
	}

	DeleteDC(hdcMem);
}
</file>

<file path="Winmerge-Src/Src/Common/RoundedRectWithShadow.h">
/** 
 * @file  RoundedRectWithShadow.h
 *
 * @brief Provides functions to draw rounded rectangles with shadows in a Win32 GDI context.
 *
 */
#pragma once

void DrawRoundedRectWithShadow(HDC hdc, int left, int top, int width, int height, int radius, int shadowWidth, COLORREF roundedRectColor, COLORREF shadowColor, COLORREF backgroundColor);
inline void DrawRoundedRect(HDC hdc, int left, int top, int width, int height, int radius, COLORREF roundedRectColor, COLORREF backgroundColor)
{
	DrawRoundedRectWithShadow(hdc, left, top, width, height, radius, 0, roundedRectColor, backgroundColor, backgroundColor);
}

</file>

<file path="Winmerge-Src/Src/Common/scbarcf.cpp">
/////////////////////////////////////////////////////////////////////////
//
// CSizingControlBarCF          Version 2.44
// 
// Created: Dec 21, 1998        Last Modified: March 31, 2002
//
// See the official site at www.datamekanix.com for documentation and
// the latest news.
//
/////////////////////////////////////////////////////////////////////////
// Copyright (C) 1998-2002 by Cristi Posea. All rights reserved.
//
// This code is free for personal and commercial use, providing this 
// notice remains intact in the source files and all eventual changes are
// clearly marked with comments.
//
// You must obtain the author's consent before you can include this code
// in a software library.
//
// No warrantee of any kind, express or implied, is included with this
// software; use at your own risk, responsibility for damages (if any) to
// anyone resulting from the use of this software rests entirely with the
// user.
//
// Send bug reports, bug fixes, enhancements, requests, flames, etc. to
// cristi@datamekanix.com or post them at the message board at the site.
/////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "scbarcf.h"
#include "RoundedRectWithShadow.h"

/////////////////////////////////////////////////////////////////////////
// CSizingControlBarCF

IMPLEMENT_DYNAMIC(CSizingControlBarCF, baseCSizingControlBarCF);

int CALLBACK EnumFontFamProc(ENUMLOGFONT* lpelf,
                             NEWTEXTMETRIC* lpntm,
                             int FontType,
                             LPARAM lParam)
{
    UNUSED_ALWAYS(lpelf);
    UNUSED_ALWAYS(lpntm);
    UNUSED_ALWAYS(FontType);
    UNUSED_ALWAYS(lParam);

    return 0;
}
 
CSizingControlBarCF::CSizingControlBarCF()
{
    m_bActive = false;

    CDC dc;
    dc.CreateCompatibleDC(nullptr);

    m_sFontFace = (::EnumFontFamilies(dc.m_hDC,
        _T("Tahoma"), (FONTENUMPROC) EnumFontFamProc, 0) == 0) ?
        _T("Tahoma") : _T("Arial");
}

BEGIN_MESSAGE_MAP(CSizingControlBarCF, baseCSizingControlBarCF)
    //{{AFX_MSG_MAP(CSizingControlBarCF)
    //}}AFX_MSG_MAP
    ON_MESSAGE(WM_SETTEXT, OnSetText)
END_MESSAGE_MAP()

void CSizingControlBarCF::OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler)
{
    __super::OnUpdateCmdUI(pTarget, bDisableIfNoHndler);

    if (!HasGripper())
        return;

    bool bNeedPaint = false;

    CWnd* pFocus = GetFocus();
    bool bActiveOld = m_bActive;

    m_bActive = (pFocus && pFocus->GetSafeHwnd() && IsChild(pFocus));

    if (m_bActive != bActiveOld)
        bNeedPaint = true;

    if (bNeedPaint)
        SendMessage(WM_NCPAINT);
}

void CSizingControlBarCF::NcPaintGripper(CDC* pDC, const CRect& rcClient)
{
    if (!HasGripper())
        return;

    // compute the caption rectangle
    bool bHorz = IsHorzDocked();
    CRect rcGrip = rcClient;
    const int lpx = pDC->GetDeviceCaps(LOGPIXELSX);
    auto pointToPixel = [lpx](double point) { return static_cast<int>(point * lpx / 72); };
    CRect rcBtn(m_biHide.ptOrg, CSize(pointToPixel(m_biHide.dblBoxSize), pointToPixel(m_biHide.dblBoxSize)));
    if (bHorz)
    {   // right side gripper
        rcGrip.left -= pointToPixel(m_dblGripper + 0.75);
        rcGrip.right = rcGrip.left + pointToPixel(8.25);
		rcGrip.top = rcBtn.bottom + pointToPixel(2.25);
    }
    else
    {   // gripper at top
        rcGrip.top -= pointToPixel(m_dblGripper + 0.75);
        rcGrip.bottom = rcGrip.top + pointToPixel(8.25);
        rcGrip.right = rcBtn.left - pointToPixel(2.25);
    }
    rcGrip.InflateRect(bHorz ? pointToPixel(0.75) : 0, bHorz ? 0 : pointToPixel(0.75));

    // draw the caption background
    //CBrush br;
    const COLORREF clrCptn = m_bActive ?
        ::GetSysColor(COLOR_GRADIENTACTIVECAPTION) :
        ::GetSysColor(COLOR_GRADIENTINACTIVECAPTION);
    const COLORREF clrBack = ::GetSysColor(COLOR_3DFACE);
    const int radius = pointToPixel(2.25);
    DrawRoundedRect(pDC->m_hDC, rcGrip.left, rcGrip.top, rcGrip.Width(), rcGrip.Height(), radius, clrCptn, clrBack);

    // draw the caption text - first select a font
    CFont font;
    LOGFONT lf;
    bool bFont = !!font.CreatePointFont(85/*8.5 points*/, m_sFontFace);
    if (bFont)
    {
        // get the text color
        COLORREF clrCptnText = m_bActive ?
            ::GetSysColor(COLOR_CAPTIONTEXT) :
            ::GetSysColor(COLOR_INACTIVECAPTIONTEXT);

        int nOldBkMode = pDC->SetBkMode(TRANSPARENT);
        COLORREF clrOldText = pDC->SetTextColor(clrCptnText);

        if (bHorz)
        {
            // rotate text 90 degrees CCW if horizontally docked
            font.GetLogFont(&lf);
            font.DeleteObject();
            lf.lfEscapement = 900;
            font.CreateFontIndirect(&lf);
        }
        
        CFont* pOldFont = pDC->SelectObject(&font);
        CString sTitle;
        GetWindowText(sTitle);

        CPoint ptOrg = bHorz ?
            CPoint(rcGrip.left - pointToPixel(0.75), rcGrip.bottom - pointToPixel(2.25)) :
            CPoint(rcGrip.left + pointToPixel(2.25), rcGrip.top - pointToPixel(0.75));

        pDC->ExtTextOut(ptOrg.x, ptOrg.y,
            ETO_CLIPPED, rcGrip, sTitle, nullptr);

        pDC->SelectObject(pOldFont);
        pDC->SetBkMode(nOldBkMode);
        pDC->SetTextColor(clrOldText);
    }

    // draw the button
    m_biHide.Paint(pDC);
}

LRESULT CSizingControlBarCF::OnSetText(WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = __super::OnSetText(wParam, lParam);

    SendMessage(WM_NCPAINT);

    return lResult;
}
</file>

<file path="Winmerge-Src/Src/Common/scbarcf.h">
/////////////////////////////////////////////////////////////////////////
//
// CSizingControlBarCF          Version 2.44
// 
// Created: Dec 21, 1998        Last Modified: March 31, 2002
//
// See the official site at www.datamekanix.com for documentation and
// the latest news.
//
/////////////////////////////////////////////////////////////////////////
// Copyright (C) 1998-2002 by Cristi Posea. All rights reserved.
//
// This code is free for personal and commercial use, providing this 
// notice remains intact in the source files and all eventual changes are
// clearly marked with comments.
//
// You must obtain the author's consent before you can include this code
// in a software library.
//
// No warrantee of any kind, express or implied, is included with this
// software; use at your own risk, responsibility for damages (if any) to
// anyone resulting from the use of this software rests entirely with the
// user.
//
// Send bug reports, bug fixes, enhancements, requests, flames, etc. to
// cristi@datamekanix.com or post them at the message board at the site.
/////////////////////////////////////////////////////////////////////////
#pragma once
// scbarcf.h : header file
//

/////////////////////////////////////////////////////////////////////////
// CSizingControlBarCF

#ifndef baseCSizingControlBarCF
#define baseCSizingControlBarCF CSizingControlBarG
#endif

class CSizingControlBarCF : public baseCSizingControlBarCF
{
    DECLARE_DYNAMIC(CSizingControlBarCF)

// Construction
public:
    CSizingControlBarCF();

// Overridables
    virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler) override;

// Implementation
protected:
    // implementation helpers
    virtual void NcPaintGripper(CDC* pDC, const CRect& rcClient) override;

protected:
    bool    m_bActive; // a child has focus
    CString m_sFontFace;

// Generated message map functions
protected:
    //{{AFX_MSG(CSizingControlBarCF)
    //}}AFX_MSG
    afx_msg LRESULT OnSetText(WPARAM wParam, LPARAM lParam);

    DECLARE_MESSAGE_MAP()
};

</file>

<file path="Winmerge-Src/Src/Common/scbarg.cpp">
/////////////////////////////////////////////////////////////////////////
//
// CSizingControlBarG           Version 2.44
// 
// Created: Jan 24, 1998        Last Modified: March 31, 2002
//
// See the official site at www.datamekanix.com for documentation and
// the latest news.
//
/////////////////////////////////////////////////////////////////////////
// Copyright (C) 1998-2002 by Cristi Posea. All rights reserved.
//
// This code is free for personal and commercial use, providing this 
// notice remains intact in the source files and all eventual changes are
// clearly marked with comments.
//
// You must obtain the author's consent before you can include this code
// in a software library.
//
// No warrantee of any kind, express or implied, is included with this
// software; use at your own risk, responsibility for damages (if any) to
// anyone resulting from the use of this software rests entirely with the
// user.
//
// Send bug reports, bug fixes, enhancements, requests, flames, etc. to
// cristi@datamekanix.com or post them at the message board at the site.
/////////////////////////////////////////////////////////////////////////

// sizecbar.cpp : implementation file
//

#include "StdAfx.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////
// CSizingControlBarG

IMPLEMENT_DYNAMIC(CSizingControlBarG, baseCSizingControlBarG);

CSizingControlBarG::CSizingControlBarG()
{
}

CSizingControlBarG::~CSizingControlBarG()
{
}

BEGIN_MESSAGE_MAP(CSizingControlBarG, baseCSizingControlBarG)
    //{{AFX_MSG_MAP(CSizingControlBarG)
    ON_WM_NCLBUTTONUP()
    ON_WM_NCHITTEST()
    //}}AFX_MSG_MAP
    ON_MESSAGE(WM_SETTEXT, OnSetText)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////
// CSizingControlBarG message handlers

/////////////////////////////////////////////////////////////////////////
// Mouse Handling
//

void CSizingControlBarG::OnNcLButtonUp(UINT nHitTest, CPoint point)
{
    if (nHitTest == HTCLOSE)
        m_pDockSite->ShowControlBar(this, FALSE, FALSE); // hide

    __super::OnNcLButtonUp(nHitTest, point);
}

void CSizingControlBarG::NcCalcClient(LPRECT pRc, UINT nDockBarID)
{
    CRect rcBar(pRc); // save the bar rect
    // subtract edges
    __super::NcCalcClient(pRc, nDockBarID);

    if (!HasGripper())
        return;

    CRect rc(pRc); // the client rect as calculated by the base class

    bool bHorz = (nDockBarID == AFX_IDW_DOCKBAR_TOP) ||
                 (nDockBarID == AFX_IDW_DOCKBAR_BOTTOM);

    const int lpx = CClientDC(this).GetDeviceCaps(LOGPIXELSX);
    auto pointToPixel = [lpx](double point) { return static_cast<int>(point * lpx / 72); };

    if (bHorz)
        rc.DeflateRect(pointToPixel(m_dblGripper), 0, 0, 0);
    else
        rc.DeflateRect(0, pointToPixel(m_dblGripper), 0, 0);

    // set position for the "x" (hide bar) button
    CPoint ptOrgBtn;
    if (bHorz)
        ptOrgBtn = CPoint(rc.left - pointToPixel(9.75), rc.top);
    else
        ptOrgBtn = CPoint(rc.right - pointToPixel(9.0), rc.top - pointToPixel(9.75));

    m_biHide.Move(ptOrgBtn - rcBar.TopLeft());

    *pRc = rc;
}

void CSizingControlBarG::NcPaintGripper(CDC* pDC, const CRect& rcClient)
{
    if (!HasGripper())
        return;

    // paints a simple "two raised lines" gripper
    // override this if you want a more sophisticated gripper
    const int lpx = pDC->GetDeviceCaps(LOGPIXELSX);
    auto pointToPixel = [lpx](double point) { return static_cast<int>(point * lpx / 72); };
    CRect gripper = rcClient;
    CRect rcbtn(m_biHide.ptOrg, CSize(pointToPixel(m_biHide.dblBoxSize), pointToPixel(m_biHide.dblBoxSize)));
    bool bHorz = IsHorzDocked();

    gripper.DeflateRect(1, 1);
    if (bHorz)
    {   // gripper at left
        gripper.left -= pointToPixel(m_dblGripper);
        gripper.right = gripper.left + pointToPixel(2.25);
        gripper.top = rcbtn.bottom + pointToPixel(2.25);
    }
    else
    {   // gripper at top
        gripper.top -= pointToPixel(m_dblGripper);
        gripper.bottom = gripper.top + pointToPixel(2.25);
        gripper.right = rcbtn.left - pointToPixel(2.25);
    }

    pDC->Draw3dRect(gripper, ::GetSysColor(COLOR_BTNHIGHLIGHT),
        ::GetSysColor(COLOR_BTNSHADOW));

    gripper.OffsetRect(bHorz ? pointToPixel(2.25) : 0, bHorz ? 0 : pointToPixel(2.25));

    pDC->Draw3dRect(gripper, ::GetSysColor(COLOR_BTNHIGHLIGHT),
        ::GetSysColor(COLOR_BTNSHADOW));

    m_biHide.Paint(pDC);
}

LRESULT CSizingControlBarG::OnNcHitTest(CPoint point)
{
    CRect rcBar;
    GetWindowRect(rcBar);

    LRESULT nRet = __super::OnNcHitTest(point);
    if (nRet != HTCLIENT)
        return nRet;

    const int lpx = CClientDC(this).GetDeviceCaps(LOGPIXELSX);
    auto pointToPixel = [lpx](double point) { return static_cast<int>(point * lpx / 72); };
    CRect rc(m_biHide.ptOrg, CSize(pointToPixel(m_biHide.dblBoxSize), pointToPixel(m_biHide.dblBoxSize)));
    rc.OffsetRect(rcBar.TopLeft());
    if (rc.PtInRect(point))
        return HTCLOSE;

    return HTCLIENT;
}

/////////////////////////////////////////////////////////////////////////
// CSizingControlBarG implementation helpers

void CSizingControlBarG::OnUpdateCmdUI(CFrameWnd* pTarget,
                                      BOOL bDisableIfNoHndler)
{
    UNUSED_ALWAYS(bDisableIfNoHndler);
    UNUSED_ALWAYS(pTarget);

    if (!HasGripper())
        return;

    bool bNeedPaint = false;

    CPoint pt;
    ::GetCursorPos(&pt);
    bool bHit = (OnNcHitTest(pt) == HTCLOSE);
    bool bLButtonDown = (::GetKeyState(VK_LBUTTON) < 0);

    bool bWasPushed = m_biHide.bPushed;
    m_biHide.bPushed = bHit && bLButtonDown;

    bool bWasRaised = m_biHide.bRaised;
    m_biHide.bRaised = bHit && !bLButtonDown;

    bNeedPaint |= (m_biHide.bPushed ^ bWasPushed) ||
                  (m_biHide.bRaised ^ bWasRaised);

    if (bNeedPaint)
        SendMessage(WM_NCPAINT);
}

/////////////////////////////////////////////////////////////////////////
// CSCBButton

CSCBButton::CSCBButton()
{
    bRaised = false;
    bPushed = false;
}

void CSCBButton::Paint(CDC* pDC)
{
    const int lpx = pDC->GetDeviceCaps(LOGPIXELSX);
    auto pointToPixel = [lpx](double point) { return static_cast<int>(point * lpx / 72); };
    CRect rc(ptOrg, CSize(pointToPixel(dblBoxSize), pointToPixel(dblBoxSize)));

    if (bPushed)
        pDC->Draw3dRect(rc, ::GetSysColor(COLOR_BTNSHADOW),
            ::GetSysColor(COLOR_BTNHIGHLIGHT));
    else
        if (bRaised)
            pDC->Draw3dRect(rc, ::GetSysColor(COLOR_BTNHIGHLIGHT),
                ::GetSysColor(COLOR_BTNSHADOW));

    COLORREF clrOldTextColor = pDC->GetTextColor();
    pDC->SetTextColor(::GetSysColor(COLOR_BTNTEXT));
    int nPrevBkMode = pDC->SetBkMode(TRANSPARENT);
    CFont font;
    font.CreatePointFont(60/*6 points*/, _T("Marlett"));
    CFont* oldfont = pDC->SelectObject(&font);

    pDC->TextOut(ptOrg.x + pointToPixel(1.5), ptOrg.y + pointToPixel(1.5), CString(_T("r"))); // x-like

    pDC->SelectObject(oldfont);
    pDC->SetBkMode(nPrevBkMode);
    pDC->SetTextColor(clrOldTextColor);
}

bool CSizingControlBarG::HasGripper() const
{
#if defined(_SCB_MINIFRAME_CAPTION) || !defined(_SCB_REPLACE_MINIFRAME)
    // if the miniframe has a caption, don't display the gripper
    if (IsFloating())
        return false;
#endif //_SCB_MINIFRAME_CAPTION

    return true;
}
</file>

<file path="Winmerge-Src/Src/Common/scbarg.h">
/////////////////////////////////////////////////////////////////////////
//
// CSizingControlBarG           Version 2.44
//
// Created: Jan 24, 1998        Last Modified: March 31, 2002
//
// See the official site at www.datamekanix.com for documentation and
// the latest news.
//
/////////////////////////////////////////////////////////////////////////
// Copyright (C) 1998-2002 by Cristi Posea. All rights reserved.
//
// This code is free for personal and commercial use, providing this 
// notice remains intact in the source files and all eventual changes are
// clearly marked with comments.
//
// You must obtain the author's consent before you can include this code
// in a software library.
//
// No warrantee of any kind, express or implied, is included with this
// software; use at your own risk, responsibility for damages (if any) to
// anyone resulting from the use of this software rests entirely with the
// user.
//
// Send bug reports, bug fixes, enhancements, requests, flames, etc. to
// cristi@datamekanix.com or post them at the message board at the site.
/////////////////////////////////////////////////////////////////////////
#pragma once

/////////////////////////////////////////////////////////////////////////
// CSCBButton (button info) helper class

class CSCBButton
{
public:
    CSCBButton();

    void Move(CPoint ptTo) {ptOrg = ptTo; };
    void Paint(CDC* pDC);

    bool    bPushed;
    bool    bRaised;
    const double  dblBoxSize = 8.25;
    CPoint  ptOrg;
};

/////////////////////////////////////////////////////////////////////////
// CSizingControlBar control bar

#ifndef baseCSizingControlBarG
#define baseCSizingControlBarG CSizingControlBar
#endif

class CSizingControlBarG : public baseCSizingControlBarG
{
    DECLARE_DYNAMIC(CSizingControlBarG);

// Construction
public:
    CSizingControlBarG();

// Attributes
public:
    virtual bool HasGripper() const;

// Operations
public:

// Overridables
    virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler) override;

// Overrides
public:
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CSizingControlBarG)
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CSizingControlBarG();
    
protected:
    // implementation helpers
    virtual void NcPaintGripper(CDC* pDC, const CRect& rcClient) override;
    virtual void NcCalcClient(LPRECT pRc, UINT nDockBarID) override;

protected:
    const double m_dblGripper = 9.0;

    CSCBButton m_biHide;

// Generated message map functions
protected:
    //{{AFX_MSG(CSizingControlBarG)
    afx_msg LRESULT OnNcHitTest(CPoint point);
    afx_msg void OnNcLButtonUp(UINT nHitTest, CPoint point);
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
};
</file>

<file path="Winmerge-Src/Src/Common/Shell.cpp">
#include "pch.h"
#include "Shell.h"
#include "UnicodeString.h"
#include "paths.h"
#include <windows.h>

namespace shell
{

void Open(const tchar_t * szFile)
{
	ShellExecute(::GetDesktopWindow(), _T("open"), szFile, 0, 0, SW_SHOWNORMAL);
}

void Edit(const tchar_t * szFile)
{
	HINSTANCE rtn = ShellExecute(::GetDesktopWindow(), _T("edit"), szFile, 0, 0, SW_SHOWNORMAL);
	if (reinterpret_cast<uintptr_t>(rtn) == SE_ERR_NOASSOC)
		rtn = ShellExecute(::GetDesktopWindow(), _T("open"), szFile, 0, 0, SW_SHOWNORMAL);
	if (reinterpret_cast<uintptr_t>(rtn) == SE_ERR_NOASSOC)
		OpenWith(szFile);
}

void OpenWith(const tchar_t * szFile)
{
	tchar_t sysdir[MAX_PATH]{};
	if (!GetSystemDirectory(sysdir, MAX_PATH)) return;
	String arg = String(_T("shell32.dll,OpenAs_RunDLL ")) + szFile;
	ShellExecute(::GetDesktopWindow(), 0, _T("RUNDLL32.EXE"), arg.c_str(), sysdir, SW_SHOWNORMAL);
}

/**
 * @brief Open file, if it exists, else open url
 */
void OpenFileOrUrl(const tchar_t * szFile, const tchar_t * szUrl)
{
	if (paths::DoesPathExist(szFile) == paths::IS_EXISTING_FILE)
		ShellExecute(nullptr, _T("open"), _T("notepad.exe"), szFile, nullptr, SW_SHOWNORMAL);
	else
		Open(szUrl);
}

/**
 * @brief Open parent folder
 */
void OpenParentFolder(const tchar_t * szFile)
{
	String param = _T("/select,\"") + String(szFile) + _T("\"");
	ShellExecute(nullptr, _T("open"), _T("explorer.exe"), param.c_str(), nullptr, SW_SHOWNORMAL);
}

}
</file>

<file path="Winmerge-Src/Src/Common/Shell.h">
#pragma once

#include "UnicodeString.h"

namespace shell
{
	void Open(const tchar_t * szFile);
	void Edit(const tchar_t * szFile);
	void OpenWith(const tchar_t * szFile);
	void OpenFileOrUrl(const tchar_t * szFile, const tchar_t * szUrl);
	void OpenParentFolder(const tchar_t * szFile);
}
</file>

<file path="Winmerge-Src/Src/Common/ShellContextMenu.cpp">
/////////////////////////////////////////////////////////////////////////////
//	  WinMerge:  an interactive diff/merge utility
//	  Copyright (C) 1997-2000  Thingamahoochie Software
//	  Author: Dean Grimm
//	  SPDX-License-Identifier: GPL-2.0-or-later
/////////////////////////////////////////////////////////////////////////////
/** 
 * @file  ShellContextMenu.cpp
 *
 * @brief Main implementation file for CShellContextMenu
 */

#include "pch.h"
#include "ShellContextMenu.h"
#include "PidlContainer.h"
#include <Shlwapi.h>

CShellContextMenu::CShellContextMenu(UINT cmdFirst, UINT cmdLast)
: m_pPreferredMenu(nullptr)
, m_pShellContextMenu2(nullptr)
, m_pShellContextMenu3(nullptr)
, m_hShellContextMenu(nullptr)
, m_cmdFirst(cmdFirst)
, m_cmdLast(cmdLast)
{
}

CShellContextMenu::~CShellContextMenu()
{
	if (::IsMenu(m_hShellContextMenu))
	{
		::DestroyMenu(m_hShellContextMenu);
	}
}

void CShellContextMenu::Initialize()
{
	if (!::IsMenu(m_hShellContextMenu)) // first call or menu was destroyed by parent after it was added as submenu
	{
		m_hShellContextMenu = CreatePopupMenu();
	}
	m_files.clear();
}

void CShellContextMenu::AddItem(const std::wstring& fullpath)
{
	m_files.insert(m_files.end(), fullpath);
}

void CShellContextMenu::AddItem(const std::wstring& path,
								const std::wstring& filename)
{
	AddItem(path + L"\\" + filename);
}

HMENU CShellContextMenu::GetHMENU() const
{
	return ::IsMenu(m_hShellContextMenu) ? m_hShellContextMenu : nullptr;
}

bool CShellContextMenu::HandleMenuMessage(UINT message, WPARAM wParam, LPARAM lParam, LRESULT& retval)
{
	//HRESULT hr = E_FAIL;
	switch (message)
	{
	case WM_DRAWITEM:
	case WM_INITMENUPOPUP:
	case WM_MEASUREITEM:
		if (m_pShellContextMenu3 != nullptr)
		{
			if (FAILED(/*hr = */m_pShellContextMenu3->HandleMenuMsg(message, wParam, lParam/*, &retval*/)))
			{
				//TRACE(_T("HandleMenuMsg(%x) failed with error: %lx\n"), message, hr);
				//if (message == WM_DRAWITEM)
				//{
				//	  LPDRAWITEMSTRUCT lpDrawItem = (LPDRAWITEMSTRUCT) lParam;
				//	  (HMENU)hMenu = (HMENU)lpDrawItem->hwndItem;
				//	  TRACE(_T("  hMenu == 0x%p\n"), hMenu);
				//}
				//assert(false);
			}
		}
		else if (m_pShellContextMenu2 != nullptr)
		{
			if (FAILED(/*hr = */m_pShellContextMenu2->HandleMenuMsg(message, wParam, lParam)))
			{
				//TRACE(_T("HandleMenuMsg(%x) failed with error: %lx\n"), message, hr);
				//assert(false);
			}
		}
		// indicate that we've processed the message
		retval = (message == WM_INITMENUPOPUP) ? 0 : TRUE;
		return true;
	case WM_MENUCHAR:
		if (m_pShellContextMenu3 != nullptr)
		{
			retval = 0;
			if (FAILED(/*hr = */m_pShellContextMenu3->HandleMenuMsg2(message, wParam, lParam, &retval)))
			{
				//TRACE(_T("HandleMenuMsg2(%x) failed with error: %lx\n"), message, hr);
				//assert(false);
			}
			return true;
		}
	}
	return false;
}

static HRESULT _stdcall dfmCallback(IShellFolder* /*psf*/, HWND /*hwnd*/, IDataObject* /*pdtobj*/, UINT uMsg, WPARAM /*wParam*/, LPARAM /*lParam*/)
{
	switch (uMsg)
	{
	case DFM_MERGECONTEXTMENU:
		return S_OK;
	case DFM_INVOKECOMMAND:
	case DFM_INVOKECOMMANDEX:
	case DFM_GETDEFSTATICID: // Required for Windows 7 to pick a default
		return S_FALSE;
	}
	return E_NOTIMPL;
}

bool CShellContextMenu::QueryShellContextMenu()
{
	//HRESULT hr = E_FAIL;
	IShellFolderPtr pDesktop;
	if (FAILED(/*hr = */SHGetDesktopFolder(&pDesktop)))
		return false;

	CPidlContainer pidls;

	for (FilenamesContainer::const_iterator iter = m_files.begin(); iter != m_files.end(); ++iter)
	{
		const std::wstring& path = *iter;
		LPITEMIDLIST pidl;
		if (FAILED(/*hr = */pDesktop->ParseDisplayName(nullptr,				   // hwnd
												   nullptr,					   // pbc
												   const_cast<wchar_t *>(path.c_str()),	// pszDisplayName
												   nullptr,					   // pchEaten
												   &pidl,					   // ppidl
												   nullptr					   // pdwAttributes
												   )))
		{
			return false;
		}
		pidls.Add(pidl);
	} // for (FilenamesContainer::const_iterator iter = m_files.begin(); iter != m_files.end(); ++iter)
	
	if (0 == pidls.Size()) // no items to show menu for
	{
		return false;
	}

	// The following was created with reference to https://github.com/stefankueng/grepWin/blob/main/src/ShellContextMenu.cpp.
	HKEY ahkeys[16]{};
	int nKeys = 0;
	const std::wstring& path = m_files.front();
	nKeys += RegOpenKey(HKEY_CLASSES_ROOT, L"*", &ahkeys[nKeys]) == ERROR_SUCCESS ? 1 : 0;
	nKeys += RegOpenKey(HKEY_CLASSES_ROOT, L"AllFileSystemObjects", &ahkeys[nKeys]) == ERROR_SUCCESS ? 1 : 0;
	if (PathIsDirectory(path.c_str()))
	{
		nKeys += RegOpenKey(HKEY_CLASSES_ROOT, L"Folder", &ahkeys[nKeys]) == ERROR_SUCCESS ? 1 : 0;
		nKeys += RegOpenKey(HKEY_CLASSES_ROOT, L"Directory", &ahkeys[nKeys]) == ERROR_SUCCESS ? 1 : 0;
	}
	HKEY hkey;
	const wchar_t* ext = PathFindExtension(path.c_str());
	if (ext && *ext == '.' && RegOpenKey(HKEY_CLASSES_ROOT, ext, &hkey) == ERROR_SUCCESS)
	{
		wchar_t buf[MAX_PATH] = { 0 };
		DWORD dwSize = MAX_PATH;
		if (RegQueryValueEx(hkey, L"", nullptr, nullptr, reinterpret_cast<LPBYTE>(buf), &dwSize) == ERROR_SUCCESS)
			nKeys += RegOpenKey(HKEY_CLASSES_ROOT, buf, &ahkeys[nKeys]) == ERROR_SUCCESS ? 1 : 0;
		RegCloseKey(hkey);
	}

	IContextMenuPtr pCMenu1;
	HRESULT hr = CDefFolderMenu_Create2(nullptr, nullptr,
		static_cast<unsigned>(pidls.Size()),
		pidls.GetList(), pDesktop, dfmCallback, nKeys, ahkeys, &pCMenu1);

	for (int i = 0; i < nKeys; ++i)
		RegCloseKey(ahkeys[i]);

	if (FAILED(hr))
	{
		return false;
	}

	m_pPreferredMenu = pCMenu1;

	IContextMenu2Ptr pCMenu2(pCMenu1);
	if (pCMenu2 != nullptr)
	{
		m_pPreferredMenu = pCMenu2;
	}

	IContextMenu3Ptr pCMenu3(pCMenu1);
	if (pCMenu3 != nullptr)
	{
		m_pPreferredMenu = pCMenu3;
	}

	assert(::IsMenu(m_hShellContextMenu));
	if (FAILED(/*hr = */m_pPreferredMenu->QueryContextMenu(m_hShellContextMenu,
													   0,
													   m_cmdFirst,
													   m_cmdLast,
													   CMF_EXPLORE | CMF_CANRENAME)))
	{
		return false;
	}

	m_pShellContextMenu2 = std::move(pCMenu2);
	m_pShellContextMenu3 = std::move(pCMenu3);

	return true;
}

bool CShellContextMenu::InvokeCommand(UINT nCmd, HWND hWnd)
{
	if (nCmd >= m_cmdFirst && nCmd <= m_cmdLast)
	{
		CMINVOKECOMMANDINFO ici = {sizeof(CMINVOKECOMMANDINFO)};

		ici.hwnd = hWnd;
		nCmd -= m_cmdFirst; // adjust command id
		ici.lpVerb = MAKEINTRESOURCEA(nCmd);
		ici.nShow = SW_SHOWNORMAL;

		HRESULT hr = m_pPreferredMenu->InvokeCommand(&ici);
		assert(SUCCEEDED(hr));
		return SUCCEEDED(hr);
	}
	else 
	{
		return false;
	}
}

bool CShellContextMenu::RequeryShellContextMenu()
{
	assert(::IsMenu(m_hShellContextMenu));
	while (::GetMenuItemCount(m_hShellContextMenu) > 0)
	{
		::DeleteMenu(m_hShellContextMenu, 0, MF_BYPOSITION);
	}
	assert(::GetMenuItemCount(m_hShellContextMenu) == 0);

	return QueryShellContextMenu();
}

void CShellContextMenu::ReleaseShellContextMenu()
{
	m_pShellContextMenu2 = nullptr;
	m_pShellContextMenu3 = nullptr;
	m_pPreferredMenu = nullptr;
}
</file>

<file path="Winmerge-Src/Src/Common/ShellContextMenu.h">
/////////////////////////////////////////////////////////////////////////////
//	  WinMerge:  an interactive diff/merge utility
//	  Copyright (C) 1997  Dean P. Grimm
//	  SPDX-License-Identifier: GPL-2.0-or-later
/////////////////////////////////////////////////////////////////////////////
/**
 *	@file ShellContextMenu.h
 *
 *	@brief Declaration of class CShellContextMenu
 */ 
#pragma once

#pragma warning (push)			// prevent "warning C4091: 'typedef ': ignored on left of 'tagGPFIDL_FLAGS' when no variable is declared"
#pragma warning (disable:4091)	// VC bug when using XP enabled toolsets.
#include <shlobj.h>
#pragma warning (pop)
#include <comdef.h>
#include <list>

struct __declspec(uuid("000214e4-0000-0000-c000-000000000046")) IContextMenu;
struct __declspec(uuid("000214f4-0000-0000-c000-000000000046")) IContextMenu2;
struct __declspec(uuid("bcfce0a0-ec17-11d0-8d10-00a0c90f2719")) IContextMenu3;

_COM_SMARTPTR_TYPEDEF(IContextMenu, __uuidof(IContextMenu));
_COM_SMARTPTR_TYPEDEF(IContextMenu2, __uuidof(IContextMenu2));
_COM_SMARTPTR_TYPEDEF(IContextMenu3, __uuidof(IContextMenu3));

/**
 * @brief Explorer's context menu
 *
 * Allows to query shell context menu for a group of files
 *
 * Usage:
 * <ol>
 * <li>Initialize menu by calling Initialize().
 *	   This should be called each time user wants to show menu - i.e. user does not have to create 
 *	   new instance of CShellContextMenu each time, just needs to call Initialize().
 * <li>Add files using AddItem().</li>
 * <li>Call RequeryShellContextMenu().
 *	   If you have several CShellContextMenu objects for different groups of files and want to show context menu 
 *	   for these groups in turns you should call RequeryShellContextMenu() for appropriate object before menu is shown.
 *	   You can call RequeryShellContextMenu() in WM_INITMENUPOPUP message handler.
 *	   This is probably a "feature" of Windows Shell, but without it menus won't work correctly.</li>
 * <li>Show popup menu via TrackPopupMenu[Ex]() with TPM_RETURNCMD flag using handle that is returned by GetHMENU().
 *	   Handle WM_INITMENUPOPUP, WM_DRAWITEM, WM_MEASUREITEM and WM_MENUCHAR in window procedure of the menu owner 
 *	   and pass them to HandleMenuMessage().</li>
 * <li>Call InvokeCommand() with nCmd returned by TrackPopupMenu[Ex]().</li>
 * </ol>
 *
 * @note Current implementation can successfully query context menu from the shell only if all the files are in the same folder.
 *		 This is checked in QueryShellContextMenu() so caller can simply add items and check return value of RequeryShellContextMenu()
 */
class CShellContextMenu
{
public:
	/**
	 * @brief Constructor
	 *
	 * @param[in]	cmdFirst	minimum value for a menu item identifier
	 * @param[in]	cmdLast		maximum value for a menu item identifier
	 *
	 * @pre		cmdFirst < cmdLast <= 0xffff
	 * @pre		[cmdFirst, cmdLast] range should not intersect with available command IDs
	 */
	CShellContextMenu(UINT cmdFirst, UINT cmdLast);

	/**
	 * @brief Destructor
	 */
	~CShellContextMenu();

	/**
	 * @brief Initializes menu
	 *
	 * Should be called each time menu is going to be shown.
	 * Initializes m_hShellContextMenu and clears all previously added items.
	 */
	void Initialize();

	/**
	 * @brief	Adds a file to a group of files for which shell context menu is queried
	 *
	 * @param[in]	fullpath	Full path to file to set to item.
	 */
	void AddItem(const std::wstring& fullpath);

	/**
	 * @brief	Adds a file to a group of files for which shell context menu is queried
	 *
	 * @param[in]	path		path to file, including all but file name
	 * @param[in]	filename	file name without path
	 */
	void AddItem(const std::wstring& path,
				 const std::wstring& filename);

	/**
	 * @brief	Returns HMENU handle to context menu
	 *
	 * Menu is created by CShellContextMenu using CreatePopupMenu()
	 *
	 * @return	Handle to shell context menu.
	 *			Menu is created in constructor and does not normally change when requesting context menu via RequeryShellContextMenu()
	 *			It may though change if destroyed by someone. In this case it should be recreated in RequeryShellContextMenu()
	 *
	 * @retval	nullptr	If handle is destroyed by parent menu, but not yet recreated by RequeryShellContextMenu()
	 */
	HMENU GetHMENU() const;

	/**
	 * @brief	Clears current menu and queries context menu from the shell
	 *
	 * @retval	true	Context menu is queried successfully. User can track menu using handle returned by GetHMENU()
	 * @retval	false	Failed to query context menu
	 */
	bool RequeryShellContextMenu();

	/**
	 * @brief	Forwards certain messages to context menu so it works properly
	 *
	 * Handles WM_INITMENUPOPUP, WM_DRAWITEM, WM_MEASUREITEM and WM_MENUCHAR messages
	 *
	 * @param[in]		message		Message to handle
	 * @param[in]		wParam		Additional message-specific information
	 * @param[in]		lParam		Additional message-specific information
	 * @param[out]		retval		Value returned by message handler
	 *
	 * @retval	true	message was handled
	 * @retval	false	message was not handled
	 */
	bool HandleMenuMessage(UINT message, WPARAM wParam, LPARAM lParam, LRESULT& retval);

	/**
	 * @brief	Handles selected menu command
	 *
	 * @param[in]	nCmd	Menu item identifier returned by TrackPopupMenu[Ex]()
	 * @param[in]	hWnd	Handle to the window that owns popup menu ( window handle passed to TrackPopupMenu[Ex]() )
	 *
	 * @retval	true	Everything is OK
	 * @retval	false	Something failed
	 */
	bool InvokeCommand(UINT nCmd, HWND hWnd);

	void ReleaseShellContextMenu();

private:
	/**
	 * @brief	Queries context menu from the shell
	 *
	 * Initializes \ref m_pPreferredMenu, \ref m_pShellContextMenu2, \ref m_pShellContextMenu3 and \ref m_hShellContextMenu
	 * that are used later for showing menu and handling commands
	 *
	 * @retval	true	Menu is queried successfully
	 * @retval	false	Failed to query context menu
	 */
	bool QueryShellContextMenu();

private:
	typedef std::list<std::wstring> FilenamesContainer;

	FilenamesContainer m_files; /**< List of files to show context menu for */

	LPCONTEXTMENU m_pPreferredMenu; /**< Shell context menu for group of files. 
										 Points either to IContextMenu, IContextMenu2 or IContextMenu3 interface, 
										 the highest available. Used to process command in InvokeCommand() */
	IContextMenu2Ptr m_pShellContextMenu2; /**< IContextMenu2 interface of current preferred context menu */
	IContextMenu3Ptr m_pShellContextMenu3; /**< IContextMenu3 interface of current preferred context menu */

	HMENU m_hShellContextMenu; /**< HMENU handle of shell context menu for group of files */

	const UINT m_cmdFirst; /**< minimum value for a menu item identifier */
	const UINT m_cmdLast; /**< maximum value for a menu item identifier */
};
</file>

<file path="Winmerge-Src/Src/Common/ShellFileOperations.cpp">
// SPDX-License-Identifier: GPL-2.0-or-later
/**
 * @file  ShellFileOperations.cpp
 *
 * @brief Implementation of ShellFileOperations class.
 */

#include "pch.h"
#include "ShellFileOperations.h"
#include <windows.h>
#include <vector>
#include <shellAPI.h>
#pragma warning (push)			// prevent "warning C4091: 'typedef ': ignored on left of 'tagGPFIDL_FLAGS' when no variable is declared"
#pragma warning (disable:4091)	// VC bug when using XP enabled toolsets.
#include <shlobj.h>
#pragma warning (pop)
#include <shlobj.h>
#include <comip.h>
#include "UnicodeString.h"
#include "paths.h"
#include "TFile.h"

using std::vector;
typedef _com_ptr_t<_com_IIID<IFileOperation, &__uuidof(IFileOperation)>> IFileOperationPtr;
typedef _com_ptr_t<_com_IIID<IShellItem, &__uuidof(IShellItem)>> IShellItemPtr;

/**
 * @brief Constructor.
 */
ShellFileOperations::ShellFileOperations()
 : m_bOneToOneMapping(false)
 , m_function(0)
 , m_flags(0)
 , m_parentWindow(nullptr)
 , m_isCanceled(false)
{
}

/**
 * @brief Add source- and destination paths.
 * @param [in] source Source path.
 * @param [in] destination Destination path.
 */
void ShellFileOperations::AddSourceAndDestination(const String &source,
		const String &destination)
{
	m_sources.push_back(source);
	m_destinations.push_back(destination);
}

/**
 * @brief Add source path.
 * @param [in] source Source path.
 */
void ShellFileOperations::AddSource(const String &source)
{
	m_sources.push_back(source);
	m_bOneToOneMapping = false;
}

/**
 * @brief Add destination path.
 * @param [in] destination Destination path.
 */
void ShellFileOperations::SetDestination(const String &destination)
{
	m_destinations.push_back(destination);
	m_bOneToOneMapping = false;
}

/**
 * @brief Get a path list as C string with NULLs.
 * This function returns C-string with NULLs between paths and two NULLs
 * at the end of the paths. As the ShellFileOp() requires.
 * @param [in] source If true, return source paths, else return destination
 *   paths.
 * @param [out] string of the paths.
 */
vector<tchar_t> ShellFileOperations::GetPathList(bool source) const
{
	vector<tchar_t> paths;
	const size_t len = CountStringSize(source);
	paths.resize(len, 0);

	vector<String>::const_iterator iter;
	vector<String>::const_iterator end;
	if (source)
	{
		iter = m_sources.begin();
		end = m_sources.end();
	}
	else
	{
		iter = m_destinations.begin();
		end = m_destinations.end();
	}

	size_t ind = 0;
	while (iter != end)
	{
		const size_t slen = (*iter).length();
		memcpy(&paths[ind], (*iter).c_str(), slen * sizeof(tchar_t));
		ind += slen;
		ind++; // NUL between strings
		++iter;
	}
	return paths;
}

/**
 * @brief Calculate length of the C-string required for paths.
 * @param [in] source If true calculate source paths, else calculate
 *   destination paths.
 * @return Length of the string.
 */
size_t ShellFileOperations::CountStringSize(bool source) const
{
	vector<String>::const_iterator iter;
	vector<String>::const_iterator end;
	if (source)
	{
		iter = m_sources.begin();
		end = m_sources.end();
	}
	else
	{
		iter = m_destinations.begin();
		end = m_destinations.end();
	}

	size_t size = 0;
	while (iter != end)
	{
		size += (*iter).length() * sizeof(tchar_t);
		size += sizeof(tchar_t); // NUL between strings
		++iter;
	}
	size += 2; // Two zeros at end of the string
	return size;
}

/**
 * @brief Set the operation, flags and parent window.
 * @param [in] operation Operation to run (copy/move/delete/rename).
 * @param [in] flags Flags related to the operation.
 * @param [in] parentWindow Window getting notifications.
 */
void ShellFileOperations::SetOperation(UINT operation, FILEOP_FLAGS flags,
		HWND parentWindow /*= nullptr*/)
{
	m_function = operation;
	m_flags = flags;
	m_parentWindow = parentWindow;
}

/**
 * @brief Run the file operation(s).
 * This method runs the filesystem operation(s) added earlier.
 * @return true if succeeds and user did not cancel, false otherwise.
 */
bool ShellFileOperations::Run()
{
	if (m_function == 0)
		return false; // Operation not set!

	HRESULT hr;
	IFileOperationPtr pFileOperation;
	if (FAILED(hr = pFileOperation.CreateInstance(CLSID_FileOperation, nullptr, CLSCTX_ALL)))
	{
		vector<tchar_t> destStr;
		vector<tchar_t> sourceStr = GetPathList(true);
		if (m_function != FO_DELETE)
			destStr = GetPathList(false);

		SHFILEOPSTRUCT fileop = {m_parentWindow, m_function, &sourceStr[0],
			m_function != FO_DELETE ? &destStr[0] : nullptr, m_flags, FALSE, 0, 0};
		int ret = SHFileOperation(&fileop);

		if (ret == 0x75 || fileop.fAnyOperationsAborted) // DE_OPCANCELLED
			m_isCanceled = true;

		bool anyAborted = !!fileop.fAnyOperationsAborted;

		// SHFileOperation returns 0 when succeeds
		if (ret == 0 && !anyAborted)
			return true;
		return false;
	}

	auto CreateShellItemParseDisplayName = [](const String& path, IShellItem **psi)
	{
		HRESULT hr;
		PIDLIST_ABSOLUTE pidl;
		if (FAILED(hr = SHParseDisplayName(path.c_str(), nullptr, &pidl, 0, nullptr)))
		{
			tchar_t szShortPath[32768] = {};
			if (GetShortPathName(TFile(path).wpath().c_str(), szShortPath, sizeof(szShortPath) / sizeof(szShortPath[0])) == 0)
			{
				hr = E_FAIL;
			}
			else
			{
				String shortPath = szShortPath;
				strutils::replace(shortPath, _T("\\\\?\\UNC\\"), _T("\\\\"));
				strutils::replace(shortPath, _T("\\\\?\\"), _T(""));
				hr = SHParseDisplayName(shortPath.c_str(), nullptr, &pidl, 0, nullptr);
			}
		}
		if (SUCCEEDED(hr))
		{
			hr = SHCreateShellItem(nullptr, nullptr, pidl, psi);
			ILFree(pidl);
		}
		return hr;
	};

	pFileOperation->SetOperationFlags(m_flags & ~FOF_MULTIDESTFILES);

	auto itsrc = m_sources.begin();
	auto itdst = m_destinations.begin();

	while (itsrc != m_sources.end() || itdst != m_destinations.end())
	{
		IShellItemPtr pShellItemSrc;
		IShellItemPtr pShellItemDst;
		String dstFileName;
		if (itsrc != m_sources.end())
		{
			if (FAILED(CreateShellItemParseDisplayName(*itsrc, &pShellItemSrc)))
				return false;
			++itsrc;
		}
		if (itdst != m_destinations.end())
		{
			String parent = paths::GetParentPath(*itdst);
			if (FAILED(CreateShellItemParseDisplayName(parent, &pShellItemDst)))
			{
				TFile(parent).createDirectories();
				if (FAILED(CreateShellItemParseDisplayName(parent, &pShellItemDst)))
					return false;
			}
			dstFileName = paths::FindFileName(*itdst);
			++itdst;
		}
		switch (m_function)
		{
		case FO_COPY:
			hr = pFileOperation->CopyItem(pShellItemSrc, pShellItemDst, dstFileName.c_str(), nullptr);
			break;
		case FO_MOVE:
			hr = pFileOperation->MoveItem(pShellItemSrc, pShellItemDst, dstFileName.c_str(), nullptr);
			break;
		case FO_DELETE:
			hr = pFileOperation->DeleteItem(pShellItemSrc, nullptr);
			break;
		case FO_RENAME:
			hr = pFileOperation->RenameItem(pShellItemSrc, dstFileName.c_str(), nullptr);
			break;
		}
		if (FAILED(hr))
			return false;
	}
	hr = pFileOperation->PerformOperations();
	BOOL fAnyOperationsAborted = FALSE;
	pFileOperation->GetAnyOperationsAborted(&fAnyOperationsAborted);
	m_isCanceled = fAnyOperationsAborted;
	return SUCCEEDED(hr) && !fAnyOperationsAborted;
}

/**
 * @brief Reset the class.
 */
void ShellFileOperations::Reset()
{
	m_bOneToOneMapping = false;
	m_function = 0;
	m_flags = 0;
	m_parentWindow = nullptr;
	m_isCanceled = false;

	m_sources.clear();
	m_destinations.clear();
}
</file>

<file path="Winmerge-Src/Src/Common/ShellFileOperations.h">
// SPDX-License-Identifier: GPL-2.0-or-later
/**
 * @file  ShellFileOperations.h
 *
 * @brief Declaration file for ShellFileOperations class.
 */
#pragma once

#include <vector>
#include <windows.h>
#include <ShellAPI.h>
#include "UnicodeString.h"

/**
 * @brief A wrapper class for SHFileOperation().
 * This class offers easier way to use SHFileOperation(). User can just add
 * paths without needing to care about adding correct amount of NULLs.
 */
class ShellFileOperations
{
public:
	ShellFileOperations();

	void AddSourceAndDestination(const String &source, const String &destination);
	void AddSource(const String &source);
	void SetDestination(const String &destination);
	void SetOperation(UINT operation, FILEOP_FLAGS flags, HWND parentWindow = nullptr);
	bool Run();
	bool IsCanceled() const;
	void Reset();

protected:
	std::vector<tchar_t> GetPathList(bool source) const;
	size_t CountStringSize(bool source) const;

private:
	std::vector<String> m_sources; /**< Source paths. */
	std::vector<String> m_destinations; /**< Destination paths. */
	UINT m_function; /**< Operation used, copy, move, rename or delete. */
	FILEOP_FLAGS m_flags; /**< Flags for the operation. */
	HWND m_parentWindow; /**< Parent window getting notifications. */
	bool m_bOneToOneMapping; /**< Same amount of sources and destinations? */
	bool m_isCanceled; /**< Did user cancel the operation? */
};

/**
 * @brief Did the user cancel the operation?
 * @return true if the operation was canceled by the user.
 */
inline bool ShellFileOperations::IsCanceled() const
{
	return m_isCanceled;
}

</file>

<file path="Winmerge-Src/Src/Common/sizecbar.h">
/////////////////////////////////////////////////////////////////////////
//
// CSizingControlBar            Version 2.44
//
// Created: Jan 24, 1998        Last Modified: March 31, 2002
//
// See the official site at www.datamekanix.com for documentation and
// the latest news.
//
/////////////////////////////////////////////////////////////////////////
// Copyright (C) 1998-2002 by Cristi Posea. All rights reserved.
//
// This code is free for personal and commercial use, providing this 
// notice remains intact in the source files and all eventual changes are
// clearly marked with comments.
//
// You must obtain the author's consent before you can include this code
// in a software library.
//
// No warrantee of any kind, express or implied, is included with this
// software; use at your own risk, responsibility for damages (if any) to
// anyone resulting from the use of this software rests entirely with the
// user.
//
// Send bug reports, bug fixes, enhancements, requests, flames, etc. to
// cristi@datamekanix.com or post them at the message board at the site.
/////////////////////////////////////////////////////////////////////////
#pragma once

#include <afxpriv.h>    // for CDockContext
#include <afxtempl.h>   // for CTypedPtrArray

#if defined(_SCB_MINIFRAME_CAPTION) && !defined(_SCB_REPLACE_MINIFRAME)
    #error "_SCB_MINIFRAME_CAPTION requires _SCB_REPLACE_MINIFRAME"
#endif

/////////////////////////////////////////////////////////////////////////
// CSCBDockBar dummy class for access to protected members

class CSCBDockBar : public CDockBar
{
    friend class CSizingControlBar;
};

/////////////////////////////////////////////////////////////////////////
// CSizingControlBar control bar styles

#define SCBS_EDGELEFT       0x00000001
#define SCBS_EDGERIGHT      0x00000002
#define SCBS_EDGETOP        0x00000004
#define SCBS_EDGEBOTTOM     0x00000008
#define SCBS_EDGEALL        0x0000000F
#define SCBS_SHOWEDGES      0x00000010
#define SCBS_SIZECHILD      0x00000020

/////////////////////////////////////////////////////////////////////////
// CSizingControlBar control bar

#ifndef baseCSizingControlBar
#define baseCSizingControlBar CControlBar
#endif

class CSizingControlBar;
typedef CTypedPtrArray <CPtrArray, CSizingControlBar*> CSCBArray;

class CSizingControlBar : public baseCSizingControlBar
{
    DECLARE_DYNAMIC(CSizingControlBar);

// Construction
public:
    CSizingControlBar();

    virtual BOOL Create(LPCTSTR lpszWindowName, CWnd* pParentWnd,
        UINT nID, DWORD dwStyle = WS_CHILD | WS_VISIBLE | CBRS_TOP);

// Attributes
public:
    bool IsFloating() const;
    bool IsHorzDocked() const;
    bool IsVertDocked() const;
    bool IsSideTracking() const;
    bool GetSCBStyle() const {return (m_dwSCBStyle != 0);}

// Operations
public:
#if defined(_SCB_REPLACE_MINIFRAME) && !defined(_SCB_MINIFRAME_CAPTION)
    void EnableDocking(DWORD dwDockStyle);
#endif
    virtual void LoadState(LPCTSTR lpszProfileName);
    virtual void SaveState(LPCTSTR lpszProfileName);
    static void GlobalLoadState(CFrameWnd* pFrame, LPCTSTR lpszProfileName);
    static void GlobalSaveState(CFrameWnd* pFrame, LPCTSTR lpszProfileName);
    void SetSCBStyle(DWORD dwSCBStyle)
        {m_dwSCBStyle = (dwSCBStyle & ~SCBS_EDGEALL);}

// Overridables
    virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);

// Overrides
public:
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CSizingControlBar)
    public:
    virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz);
    virtual CSize CalcDynamicLayout(int nLength, DWORD dwMode);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CSizingControlBar();
    
protected:
    // implementation helpers
    UINT GetEdgeHTCode(int nEdge);
    bool GetEdgeRect(const CRect& rcWnd, UINT nHitTest, CRect& rcEdge);
    virtual void StartTracking(UINT nHitTest, CPoint point);
    virtual void StopTracking();
    virtual void OnTrackUpdateSize(CPoint& point);
    virtual void OnTrackInvertTracker();
    virtual void NcPaintGripper(CDC* pDC, const CRect& rcClient);
    virtual void NcCalcClient(LPRECT pRc, UINT nDockBarID);

    virtual void AlignControlBars();
    void GetRowInfo(int& nFirst, int& nLast, int& nThis);
    void GetRowSizingBars(CSCBArray& arrSCBars);
    void GetRowSizingBars(CSCBArray& arrSCBars, int& nThis);
    bool NegotiateSpace(int nLengthTotal, bool bHorz);

protected:
    DWORD   m_dwSCBStyle = 0;
    UINT    m_htEdge = 0;

    CSize   m_szHorz = CSize(120, 200);
    CSize   m_szVert = CSize(120, 200);
    CSize   m_szFloat = CSize(120, 200);
    CSize   m_szMinHorz = CSize(33, 32);
    CSize   m_szMinVert = CSize(33, 32);
    CSize   m_szMinFloat = CSize(37, 32);
    int     m_nTrackPosMin = 0;
    int     m_nTrackPosMax = 0;
    int     m_nTrackPosOld = 0;
    int     m_nTrackEdgeOfs = 0;
    bool    m_bTracking = false;
    bool    m_bKeepSize = false;
    bool    m_bParentSizing = false;
    bool    m_bDragShowContent = false;
    UINT    m_nDockBarID = 0;
    int     m_cxEdge = 5;

// Generated message map functions
protected:
    //{{AFX_MSG(CSizingControlBar)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnNcPaint();
    afx_msg void OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS* lpncsp);
    afx_msg LRESULT OnNcHitTest(CPoint point);
    afx_msg void OnCaptureChanged(CWnd *pWnd);
    afx_msg void OnSettingChange(UINT uFlags, LPCTSTR lpszSection);
    afx_msg void OnSysColorChange();
    afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
    afx_msg void OnMouseMove(UINT nFlags, CPoint point);
    afx_msg void OnNcLButtonDown(UINT nHitTest, CPoint point);
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
    afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnWindowPosChanging(WINDOWPOS* lpwndpos);
    afx_msg void OnPaint();
    afx_msg void OnClose();
    afx_msg void OnSize(UINT nType, int cx, int cy);
    //}}AFX_MSG
    afx_msg LRESULT OnSetText(WPARAM wParam, LPARAM lParam);

    DECLARE_MESSAGE_MAP()

#ifdef _SCB_REPLACE_MINIFRAME
    friend class CSCBMiniDockFrameWnd;
#endif //_SCB_REPLACE_MINIFRAME
};

#ifdef _SCB_REPLACE_MINIFRAME
#ifndef _SCB_MINIFRAME_CAPTION
/////////////////////////////////////////////////////////////////////////
// CSCBDockContext dockcontext

class CSCBDockContext : public CDockContext
{
public:
// Construction
    explicit CSCBDockContext(CControlBar* pBar) : CDockContext(pBar) {}

// Drag Operations
    virtual void StartDrag(CPoint pt);
};
#endif //_SCB_MINIFRAME_CAPTION

/////////////////////////////////////////////////////////////////////////
// CSCBMiniDockFrameWnd miniframe

#ifndef baseCSCBMiniDockFrameWnd
#define baseCSCBMiniDockFrameWnd CMiniDockFrameWnd
#endif

class CSCBMiniDockFrameWnd : public baseCSCBMiniDockFrameWnd
{
    DECLARE_DYNCREATE(CSCBMiniDockFrameWnd)

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CSCBMiniDockFrameWnd)
    public:
    virtual BOOL Create(CWnd* pParent, DWORD dwBarStyle);
    //}}AFX_VIRTUAL

// Implementation
public:
    CSizingControlBar* GetSizingControlBar();

    //{{AFX_MSG(CSCBMiniDockFrameWnd)
    afx_msg void OnNcLButtonDown(UINT nHitTest, CPoint point);
    afx_msg void OnGetMinMaxInfo(MINMAXINFO* lpMMI);
    afx_msg void OnWindowPosChanging(WINDOWPOS* lpwndpos);
    afx_msg void OnSize(UINT nType, int cx, int cy);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};
#endif //_SCB_REPLACE_MINIFRAME
</file>

<file path="Winmerge-Src/Src/Common/SortHeaderCtrl.cpp">
/**
 *  @file SortHeaderCtrl.cpp
 *
 *  @brief Implementation of CSortHeaderCtrl
 */ 

#include "StdAfx.h"
#include "SortHeaderCtrl.h"

/////////////////////////////////////////////////////////////////////////////
// CSortHeaderCtrl

IMPLEMENT_DYNAMIC(CSortHeaderCtrl, CHeaderCtrl)

BEGIN_MESSAGE_MAP(CSortHeaderCtrl, CHeaderCtrl)
	//{{AFX_MSG_MAP(CSortHeaderCtrl)
	ON_WM_PAINT()
	ON_WM_ERASEBKGND()
	ON_WM_MOUSEMOVE()
	ON_WM_MOUSELEAVE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CSortHeaderCtrl::CSortHeaderCtrl() : m_bSortAsc(true), m_nSortCol(-1), m_bMouseTracking(false), m_nTrackingPane(-1)
{
}

CSortHeaderCtrl::~CSortHeaderCtrl()
{
}

int CSortHeaderCtrl::SetSortImage(int nCol, bool bAsc)
{
	int nPrevCol = m_nSortCol;

	m_nSortCol = nCol;
	m_bSortAsc = bAsc;

	HD_ITEM hditem;

	hditem.mask = HDI_FORMAT;

	// Clear HDF_SORTDOWN and HDF_SORTUP flag in all columns.
	int i;
	for (i = 0; i < this->GetItemCount(); i++)
	{
		GetItem( i, &hditem );
		if (hditem.fmt & (HDF_SORTDOWN | HDF_SORTUP))
		{
			hditem.fmt &= ~(HDF_SORTUP | HDF_SORTDOWN);
			SetItem( i, &hditem );
		}
	}

	GetItem( nCol, &hditem );

	// We can use HDF_SORTUP and HDF_SORTDOWN flag to draw a sort arrow on the header.
	hditem.fmt &= ~(HDF_SORTUP | HDF_SORTDOWN);
	hditem.fmt |= bAsc ? HDF_SORTUP : HDF_SORTDOWN;
	SetItem( nCol, &hditem );

	// Invalidate header control so that it gets redrawn
	Invalidate();

	return nPrevCol;
}

BOOL CSortHeaderCtrl::OnEraseBkgnd(CDC* pDC)
{
	CRect rcClient;
	GetClientRect(rcClient);
	pDC->FillSolidRect(rcClient, GetSysColor(COLOR_3DHIGHLIGHT));
	return TRUE;
}

static void DrawSortArrow(CDC& dc, bool up, int cx, int cy)
{
	const int lpx = dc.GetDeviceCaps(LOGPIXELSX);
	auto pointToPixelF = [lpx](float point) { return point * lpx / 72.f; };
	const int arrowWidth = static_cast<int>(pointToPixelF(2.25));
	Gdiplus::Graphics graphics(dc.m_hDC);
	graphics.SetSmoothingMode(Gdiplus::SmoothingModeAntiAlias);
	Gdiplus::Color penColor;
	penColor.SetFromCOLORREF(GetSysColor(COLOR_BTNTEXT));
	Gdiplus::Pen pen(penColor, pointToPixelF(0.75));
	Gdiplus::Point points[3];
	if (up)
	{
		points[0] = Gdiplus::Point(cx - arrowWidth, cy + arrowWidth);
		points[1] = Gdiplus::Point(cx, cy);
		points[2] = Gdiplus::Point(cx + arrowWidth, cy + arrowWidth);
	}
	else
	{
		points[0] = Gdiplus::Point(cx - arrowWidth, cy);
		points[1] = Gdiplus::Point(cx, cy + arrowWidth);
		points[2] = Gdiplus::Point(cx + arrowWidth, cy);
	}
	graphics.DrawLines(&pen, points, 3);
}

void CSortHeaderCtrl::OnPaint()
{
	CPaintDC dc(this);
	CPen pen;
	pen.CreatePen(PS_SOLID, 1, GetSysColor(COLOR_3DFACE));
	CPen* pOldPen = dc.SelectObject(&pen);
	dc.SelectObject(GetFont());
	dc.SetTextColor(GetSysColor(COLOR_BTNTEXT));
	dc.SetBkMode(TRANSPARENT);
	const int nItems = this->GetItemCount();
	for (int i = 0; i < nItems; ++i)
	{
		TCHAR buf[256]{};
		HDITEM hi;
		hi.mask = HDI_TEXT | HDI_FORMAT;
		hi.pszText = buf;
		hi.cchTextMax = sizeof(buf) / sizeof(buf[0]);
		GetItem(i, &hi);
		CRect rc;
		GetItemRect(i, &rc);
		dc.FillSolidRect(&rc, GetSysColor(
			m_nTrackingPane == i ? COLOR_3DFACE : COLOR_3DHIGHLIGHT));
		dc.DrawText(hi.pszText, &rc, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
		dc.MoveTo(rc.right - 1, rc.top);
		dc.LineTo(rc.right - 1, rc.bottom);
		if ((hi.fmt & (HDF_SORTDOWN | HDF_SORTUP)) != 0)
			DrawSortArrow(dc, (hi.fmt & HDF_SORTUP) != 0, (rc.left + rc.right) / 2, rc.top);
	}
	dc.SelectObject(pOldPen);
	pen.DeleteObject();
}

void CSortHeaderCtrl::OnMouseMove(UINT nFlags, CPoint point)
{
	if ((nFlags & MK_LBUTTON) == 0)
	{
		if (!m_bMouseTracking)
		{
			TRACKMOUSEEVENT tme = { sizeof TRACKMOUSEEVENT, TME_LEAVE, m_hWnd };
			TrackMouseEvent(&tme);
			m_bMouseTracking = true;
		}
		HDHITTESTINFO hhti;
		GetCursorPos(&hhti.pt);
		ScreenToClient(&hhti.pt);
		HitTest(&hhti);
		for (int pane : {hhti.iItem, m_nTrackingPane})
		{
			if (pane >= 0)
			{
				CRect rcPart;
				GetItemRect(pane, rcPart);
				InvalidateRect(&rcPart, false);
			}
		}
		m_nTrackingPane = hhti.iItem;
	}
	__super::OnMouseMove(nFlags, point);
}

void CSortHeaderCtrl::OnMouseLeave()
{
	TRACKMOUSEEVENT tme = { sizeof(TRACKMOUSEEVENT), TME_LEAVE | TME_CANCEL, m_hWnd };
	TrackMouseEvent(&tme);
	m_bMouseTracking = false;
	if (m_nTrackingPane >= 0)
	{
		CRect rcPart;
		GetItemRect(m_nTrackingPane, rcPart);
		InvalidateRect(&rcPart, false);
	}
	m_nTrackingPane = -1;
}
</file>

<file path="Winmerge-Src/Src/Common/SortHeaderCtrl.h">
/**
 *  @file SortHeaderCtrl.h
 *
 *  @brief Declaration of CSortHeaderCtrl
 */ 
#pragma once

/////////////////////////////////////////////////////////////////////////////
// CSortHeaderCtrl

class CSortHeaderCtrl : public CHeaderCtrl
{
	DECLARE_DYNAMIC(CSortHeaderCtrl)

// Construction
public:
	CSortHeaderCtrl();

// Attributes
protected:
	int 	m_nSortCol;
	bool	m_bSortAsc;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSortHeaderCtrl)
	//}}AFX_VIRTUAL

	virtual int 	SetSortImage(int nCol, bool bAsc);

// Implementation
public:
	virtual ~CSortHeaderCtrl();

// Generated message map functions
protected:
	//{{AFX_MSG(CSortHeaderCtrl)
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnPaint();
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnMouseLeave();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

	bool m_bMouseTracking;
	int m_nTrackingPane;
};
</file>

<file path="Winmerge-Src/Src/Common/SplitterWndEx.cpp">
//////////////////////////////////////////////////////////////////////
/** 
 * @file  SplitterWndEx.cpp
 *
 * @brief Implementation file for CSplitterWndEx
 *
 */
//
//////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include <vector>
#include "SplitterWndEx.h"
#include "cecolor.h"
#include "MergeDarkMode.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

BEGIN_MESSAGE_MAP(CSplitterWndEx, CSplitterWnd)
	//{{AFX_MSG_MAP(CSplitterWndEx)
	ON_WM_HSCROLL()
	ON_WM_VSCROLL()
	ON_WM_SIZE()
	ON_WM_SETTINGCHANGE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CSplitterWndEx, CSplitterWnd)

CSplitterWndEx::CSplitterWndEx()
{
	m_bBarLocked = false;
	m_bResizePanes = false;
	m_bAutoResizePanes = false;
	m_bHideBorders = false;
}

CSplitterWndEx::~CSplitterWndEx()
{

}

int CSplitterWndEx::HitTest(CPoint pt) const
{
	if (m_bBarLocked)
		return 0;
	return CSplitterWnd::HitTest(pt);
}

BOOL CSplitterWndEx::CreateScrollBarCtrl(DWORD dwStyle, UINT nID)
{
	BOOL bResult = CSplitterWnd::CreateScrollBarCtrl(dwStyle, nID);
	auto pBar = static_cast<CScrollBar*>(GetDlgItem(nID));
	if (pBar != nullptr && pBar->GetSafeHwnd())
	{
		DarkMode::setDarkScrollBar(pBar->GetSafeHwnd());
		pBar->Invalidate();
	}
	return bResult;
}

CScrollBar* CSplitterWndEx::GetScrollBarCtrl(CWnd* pWnd, int nBar) const
{
	UINT nID = pWnd->GetDlgCtrlID();
	//IdFromRowCol(row, col);
	if (nID < AFX_IDW_PANE_FIRST || nID > AFX_IDW_PANE_LAST)
		return nullptr;            // not a standard pane ID

	// appropriate PANE id - look for sibling (splitter, or just frame)
	UINT nIDScroll;
	if (nBar == SB_HORZ)
		nIDScroll = AFX_IDW_HSCROLL_FIRST + (nID - AFX_IDW_PANE_FIRST) % 16;
	else
		nIDScroll = AFX_IDW_VSCROLL_FIRST + (nID - AFX_IDW_PANE_FIRST) / 16;

	// return shared scroll bars that are immediate children of splitter
	return (CScrollBar*)GetDlgItem(nIDScroll);
}

void CSplitterWndEx::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar *pScrollBar)
{
  // Ignore scroll events sent directly to the splitter (i.e. not from a
  // scroll bar)
  if (pScrollBar == nullptr)
    return;
	// maintain original synchronization functionality (all panes above the scrollbar)
	CSplitterWnd::OnHScroll(nSBCode, nPos, pScrollBar);

	// only sync if shared horizontal bars
	if((GetScrollStyle()&WS_HSCROLL) == 0)
		return;

	// enhance with proportional horizontal scroll synchronization
	ASSERT(pScrollBar != nullptr);
	int curCol = ::GetDlgCtrlID(pScrollBar->m_hWnd) - AFX_IDW_HSCROLL_FIRST;
	ASSERT(curCol >= 0 && curCol < m_nMaxCols);

	ASSERT(m_nRows > 0);

	// broadcast to all panes (other horizontal scrollbars and other panes)
	for (int col = 0; col < m_nCols; col++)
	{
		// for current column, already handled in base OnHScroll
		if(col==curCol)
			continue;

		CScrollBar* curBar = GetScrollBarCtrl(GetPane(0, col), SB_HORZ);
		int newPos = min(pScrollBar->GetScrollPos(), curBar->GetScrollLimit());

		// Set the scrollbar info using SetScrollInfo(), limited to 2.000.000.000 characters,
		// better than the 32.768 characters (signed short) of SendMessage(WM_HSCROLL,...) 
		SCROLLINFO si;
		si.nPos = newPos;
		si.nTrackPos = newPos;
		si.fMask = SIF_POS | SIF_TRACKPOS;
		curBar->SetScrollInfo(&si, FALSE);

		// iterate through all rows
		for (int row = 0; row < m_nRows; row++)
		{
			// repaint all rows
			GetPane(row, col)->SendMessage(WM_HSCROLL,
				MAKELONG(SB_THUMBPOSITION, newPos), (LPARAM)curBar->m_hWnd);
		}
	}

}


void CSplitterWndEx::OnVScroll(UINT nSBCode, UINT nPos, CScrollBar *pScrollBar)
{
  // Ignore scroll events sent directly to the splitter (i.e. not from a
  // scroll bar)
  if (pScrollBar == nullptr)
    return;

	// only sync if shared vertical bars
	if((GetScrollStyle()&WS_VSCROLL) == 0)
		return;

	// maintain original synchronization functionality (all panes left from the scrollbar)
	CSplitterWnd::OnVScroll(nSBCode, nPos, pScrollBar);

	// enhance with proportional vertical scroll synchronization
	ASSERT(pScrollBar != nullptr);
	int curRow = ::GetDlgCtrlID(pScrollBar->m_hWnd) - AFX_IDW_VSCROLL_FIRST;
	ASSERT(curRow >= 0 && curRow < m_nMaxRows);

	ASSERT(m_nCols > 0);
	const int oldLimit = pScrollBar->GetScrollLimit();

	// broadcast to all panes (other vertical scrollbars and other panes)
	for (int row = 0; row < m_nRows; row++)
	{
		// for current row, already handled in base OnHScroll
		if(row==curRow)
			continue;

		CScrollBar* curBar = GetScrollBarCtrl(GetPane(row, 0), SB_VERT);
		double temp = ((double) pScrollBar->GetScrollPos()) * curBar->GetScrollLimit() + oldLimit/2;
		int newPos = (int) (temp/oldLimit);

		// Set the scrollbar info using SetScrollInfo(), limited to 2.000.000.000 characters,
		// better than the 32.768 characters (signed short) of SendMessage(WM_HSCROLL,...) 
		SCROLLINFO si;
		si.nPos = newPos;
		si.nTrackPos = newPos;
		si.fMask = SIF_POS | SIF_TRACKPOS;
		curBar->SetScrollInfo(&si, FALSE);

		// iterate through all columns
		for (int col = 0; col < m_nCols; col++)
		{
			// repaint all columns
			GetPane(row, col)->SendMessage(WM_VSCROLL,
				MAKELONG(SB_THUMBPOSITION, newPos), (LPARAM)curBar->m_hWnd);
		}
	}

}

static void initializeRatios(std::vector<int>& ratios, int n)
{
	ratios.clear();
	for (int sum = 0, i = 0; i < n; ++i)
	{
		ratios.push_back((i + 1) * 10000 / n - sum);
		sum = (i + 1) * 10000 / n;
	}
}

static void updateRatios(CSplitterWnd& wnd, int pane, int newpos, std::vector<int>& ratios, bool horizontal)
{
	const int n = horizontal ? wnd.GetColumnCount(): wnd.GetRowCount();
	if (static_cast<size_t>(n) != ratios.size())
		initializeRatios(ratios, n);

	int sum = 0;
	std::vector<int> sizes(n);
	for (int i = 0 ; i < n; i++)
	{
		int min;
		if (horizontal)
			wnd.GetColumnInfo(i, sizes[i], min);
		else
			wnd.GetRowInfo(i, sizes[i], min);
		sum += sizes[i];
	}
	int sumratio = 0;
	int i;
	for (i = 0; i < pane; i++)
	{
		ratios[i] = sizes[i] * 10000 / sum;
		sumratio += ratios[i];
	}
	ratios[i] = newpos * 10000 / sum - sumratio;
	sumratio += ratios[i];
	++i;
	for (; i < n - 1; i++)
	{
		if (ratios[i] + sumratio > 10000)
			ratios[i] = 10000 - sumratio;
		sumratio += ratios[i];
	}
	ratios[n - 1] = 10000 - sumratio;
}

void CSplitterWndEx::EqualizeRows() 
{
	if (m_nRows < 2)
		return;

	if (static_cast<size_t>(m_nRows) != m_rowRatios.size())
		initializeRatios(m_rowRatios, m_nRows);

	int i;
	int sum = 0;
	int hmin = 0;
	for (i = 0 ; i < m_nRows ; i++)
	{
		int h;
		GetRowInfo(i, h, hmin);
		sum += h;
	}
	if (sum > 0)
	{
		int remain = sum;
		for (i = 0 ; i < m_nRows-1 ; i++)
		{
			const int height = m_rowRatios[i] * sum / 10000;
			SetRowInfo(i, height, hmin);
			remain -= height;
		}
		SetRowInfo(i, remain, hmin);
		CSplitterWnd::RecalcLayout();
	}
}

void CSplitterWndEx::EqualizeCols() 
{
	if (m_nCols < 2)
		return;

	if (static_cast<size_t>(m_nCols) != m_colRatios.size())
		initializeRatios(m_colRatios, m_nCols);

	int i;
	int sum = 0;
	int hmin = 0;

	for (i = 0 ; i < m_nCols ; i++)
	{
		int v;
		GetColumnInfo(i, v, hmin);
		sum += v;
	}

	// Sum is negative if WinMerge started minimized.
	if (sum > 0)
	{
		int remain = sum;
		for (i = 0 ; i < m_nCols-1 ; i++)
		{
			const int width = m_colRatios[i] * sum / 10000;
			SetColumnInfo(i, width, hmin);
			remain -= width;
		}
		SetColumnInfo(i, remain, hmin);
		CSplitterWnd::RecalcLayout();
	}
}

void CSplitterWndEx::RecalcLayout()
{
	if (m_nCols == 2 && m_bAutoResizePanes)
	{
		// If WinMerge spans multiple monitors, split the panes on the monitor split.
		CRect vSplitterWndRect;
		GetWindowRect(vSplitterWndRect);
		HMONITOR hLeftMonitor = MonitorFromPoint(vSplitterWndRect.TopLeft(), MONITOR_DEFAULTTONEAREST);
		HMONITOR hRightMonitor = MonitorFromPoint(CPoint(vSplitterWndRect.right, vSplitterWndRect.top), MONITOR_DEFAULTTONEAREST);

		bool bSplitPanesInHalf = true;
		if (hLeftMonitor != hRightMonitor)
		{
			MONITORINFO info{ sizeof(MONITORINFO) };
			GetMonitorInfo(hLeftMonitor, &info);

			int iDesiredWidthOfLeftPane = info.rcMonitor.right - vSplitterWndRect.left;
			int iDesiredWidthOfRightPane = vSplitterWndRect.right - info.rcMonitor.right;

			// Edge case - don't split if either pane would be less than 100 pixels.
			if (iDesiredWidthOfLeftPane > 100 && iDesiredWidthOfRightPane > 100)
			{
				bSplitPanesInHalf = false;
				SetColumnInfo(0, iDesiredWidthOfLeftPane, 0);
				SetColumnInfo(1, iDesiredWidthOfRightPane, 0);
			}
		}
		
		// If we don't want to split panes across monitors, just split them in half.
		// We want to do this so that if the window used to be split across monitors,
		// but now occupies only a single monitor, then the panes are updated correctly.
		if (bSplitPanesInHalf)
		{
			EqualizeCols();
		}
	}

	CSplitterWnd::RecalcLayout();
}

void CSplitterWndEx::TrackRowSize(int y, int row)
{
	__super::TrackRowSize(y, row);
	updateRatios(*this, row, y, m_rowRatios, false);
}

void CSplitterWndEx::TrackColumnSize(int x, int col)
{
	__super::TrackColumnSize(x, col);
	updateRatios(*this, col, x, m_colRatios, true);
}

// Override GetActivePane() because CSplitterWnd::GetActivePane() does not take into account the case of nested Splitter Windows.
CWnd* CSplitterWndEx::GetActivePane(int* pRow, int* pCol)
{
	ASSERT_VALID(this);

	// attempt to use active view of frame window
	CWnd* pView = NULL;
	CFrameWnd* pFrameWnd = EnsureParentFrame();
	pView = pFrameWnd ? pFrameWnd->GetActiveView() : nullptr;

	// failing that, use the current focus
	if (pView == NULL)
		pView = GetFocus();

	CWnd* pActiveView = pView;
	if (pView)
	{
		while (pView && pView->GetParent() != this)
			pView = pView->GetParent();
	}

	// make sure the pane is a child pane of the splitter
	if (pView != NULL && !IsChildPane(pView, pRow, pCol))
		pActiveView = NULL;

	return pActiveView;
}

void CSplitterWndEx::OnSize(UINT nType, int cx, int cy) 
{
	CSplitterWnd::OnSize(nType, cx, cy);

	// and resize the panes 
	if (m_bResizePanes)
	{
		if (m_nCols == 2 && m_bAutoResizePanes)
		{
			RecalcLayout();
			EqualizeRows();
		}
		else
		{
			EqualizeCols();
			EqualizeRows();
		}
	}
}

void CSplitterWndEx::OnSettingChange(UINT uFlags, LPCTSTR lpszSection)
{
	if (WinMergeDarkMode::IsImmersiveColorSet(lpszSection))
		DarkMode::setChildCtrlsTheme(GetSafeHwnd());
	__super::OnSettingChange(uFlags, lpszSection);
}

void CSplitterWndEx::FlipSplit()
{
	int nRows = m_nCols, nCols = m_nRows;
	std::vector<CWnd *> pColPanes(nCols);
	std::vector<CWnd *> pRowPanes(nRows);

	bool bHasVScroll = !!m_bHasHScroll;
	bool bHasHScroll = !!m_bHasVScroll;

	CScrollBar *pBar;
	int pane;
	for (pane = 1; pane < nRows; pane++)
	{
		pRowPanes[pane] = GetDlgItem(IdFromRowCol( 0, pane ));
		pBar = pRowPanes[pane]->GetScrollBarCtrl(SB_HORZ);
		if (pBar != nullptr)
			pBar->ShowWindow(SW_HIDE);
		pBar = pRowPanes[pane]->GetScrollBarCtrl(SB_VERT);
		if (pBar != nullptr)
			pBar->ShowWindow(SW_HIDE);
	}
	for (pane = 1; pane < nCols; pane++)
	{
		pColPanes[pane] = GetDlgItem(IdFromRowCol( pane, 0 ));
		pBar = pColPanes[pane]->GetScrollBarCtrl(SB_HORZ);
		if (pBar != nullptr)
			pBar->ShowWindow(SW_HIDE);
		pBar = pColPanes[pane]->GetScrollBarCtrl(SB_VERT);
		if (pBar != nullptr)
			pBar->ShowWindow(SW_HIDE);
	}

	m_nMaxCols = m_nCols = nCols;
	m_nMaxRows = m_nRows = nRows;

	CRowColInfo* pTmp = m_pColInfo;
	m_pColInfo = m_pRowInfo;
	m_pRowInfo = pTmp;

	for (pane = 1; pane < nRows; pane++)
		pRowPanes[pane]->SetDlgCtrlID( IdFromRowCol( pane, 0 ));
	for (pane = 1; pane < nCols; pane++)
		pColPanes[pane]->SetDlgCtrlID( IdFromRowCol( 0, pane ));

	SetScrollStyle(0);
	SetScrollStyle(
		(bHasVScroll ? WS_VSCROLL : 0) | 
		(bHasHScroll ? WS_HSCROLL : 0));

	RecalcLayout();

	EqualizeCols();
	EqualizeRows();

}

void CSplitterWndEx::OnDrawSplitter(CDC* pDC, ESplitType nType, const CRect& rectArg)
{
	if (nType == splitBorder && pDC != nullptr && !m_bHideBorders)
	{
		CRect rect = rectArg;
		COLORREF clrShadow  = GetSysColor(COLOR_BTNSHADOW);
		COLORREF clrFace    = GetSysColor(COLOR_BTNFACE);
		COLORREF clrShadow2 = CEColor::GetIntermediateColor(clrFace, clrShadow, 0.9f);
		COLORREF clrShadow3 = CEColor::GetIntermediateColor(clrFace, clrShadow2, 0.5f);
		COLORREF clrShadow4 = CEColor::GetIntermediateColor(clrFace, clrShadow3, 0.5f);
		COLORREF clrShadow5 = CEColor::GetIntermediateColor(clrFace, clrShadow4, 0.5f);
		pDC->Draw3dRect(rect, clrShadow5, clrShadow4);
		rect.InflateRect(-1, -1);
		pDC->Draw3dRect(rect, clrShadow3, clrShadow2);
		return;
	}
	return CSplitterWnd::OnDrawSplitter(pDC, nType, rectArg);
}
</file>

<file path="Winmerge-Src/Src/Common/SplitterWndEx.h">
/** 
 * @file  SplitterWndEx.h
 *
 * @brief Declaration of CSplitterWndEx class
 */
#pragma once

#include <vector>

class CSplitterWndEx : public CSplitterWnd  
{
	DECLARE_DYNCREATE(CSplitterWndEx)

public:
	CSplitterWndEx();
	virtual ~CSplitterWndEx();
	void LockBar(bool bState=true){m_bBarLocked=bState;};
	void ResizablePanes(bool bState=true){m_bResizePanes=bState;};
	void AutoResizePanes(bool bState=true){m_bAutoResizePanes=bState;};
	void HideBorders(bool bHide)
	{
		m_cxBorder = m_cyBorder = bHide ? 0 : 2;
		m_bHideBorders = bHide;
	}
	void FlipSplit();

	int HitTest(CPoint pt) const;

	void EqualizeRows(); 
	void EqualizeCols(); 

	virtual void RecalcLayout() override;
	virtual void TrackRowSize(int y, int row) override;
	virtual void TrackColumnSize(int x, int col) override;
	virtual CWnd* GetActivePane(int* pRow = NULL, int* pCol = NULL) override;

	CScrollBar* GetScrollBarCtrl(CWnd* pWnd, int nBar) const;

private:
	bool m_bBarLocked;
	bool m_bResizePanes;
	bool m_bAutoResizePanes;
	bool m_bHideBorders;
	std::vector<int> m_rowRatios;
	std::vector<int> m_colRatios;

	BOOL CreateScrollBarCtrl(DWORD dwStyle, UINT nID) override;

protected:
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnSettingChange(UINT uFlags, LPCTSTR lpszSection);
	virtual void OnDrawSplitter(CDC* pDC, ESplitType nType, const CRect& rect);
	DECLARE_MESSAGE_MAP()
};
</file>

<file path="Winmerge-Src/Src/Common/SuperComboBox.cpp">
// CSuperComboBox.cpp : implementation file
//

#include "StdAfx.h"
#include "SuperComboBox.h"
#include <vector>
#include "DropHandler.h"

// Wrap placement new to avoid the need to temporarily #undef new
template<typename T>
T &placement_cast(void *p)
{
	return *new(p) T;
}

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

#define DEF_MAXSIZE		20	// default maximum items to retain in each SuperComboBox


/////////////////////////////////////////////////////////////////////////////
// CSuperComboBox

HIMAGELIST CSuperComboBox::m_himlSystem = nullptr;

CSuperComboBox::CSuperComboBox()
	: m_pDropHandler(nullptr)
	, m_bInEditchange(false)
	, m_bDoComplete(false)
	, m_bAutoComplete(false)
	, m_bHasImageList(false)
	, m_bComboBoxEx(false)
	, m_bExtendedFileNames(false)
	, m_bCanBeEmpty(false)
	, m_nMaxItems(DEF_MAXSIZE)
{


	// Initialize OLE libraries if not yet initialized
	m_bMustUninitOLE = false;
	_AFX_THREAD_STATE* pState = AfxGetThreadState();
	if (!pState->m_bNeedTerm)
	{
		SCODE sc = ::OleInitialize(nullptr);
		if (FAILED(sc))
			AfxMessageBox(_T("OLE initialization failed. Make sure that the OLE libraries are the correct version"));
		else
			m_bMustUninitOLE = true;
	}
}

CSuperComboBox::~CSuperComboBox()
{
	// Uninitialize OLE support
	if (m_bMustUninitOLE)
		::OleUninitialize();
}

BEGIN_MESSAGE_MAP(CSuperComboBox, CComboBoxEx)
	//{{AFX_MSG_MAP(CSuperComboBox)
	ON_CONTROL_REFLECT_EX(CBN_EDITCHANGE, OnEditchange)
	ON_CONTROL_REFLECT_EX(CBN_SETFOCUS, OnSetfocus)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_WM_DRAWITEM()
	ON_NOTIFY_REFLECT(CBEN_GETDISPINFO, OnGetDispInfo)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSuperComboBox message handlers

void CSuperComboBox::PreSubclassWindow()
{
	__super::PreSubclassWindow();
	m_pDropHandler = new DropHandler(std::bind(&CSuperComboBox::OnDropFiles, this, std::placeholders::_1));
	RegisterDragDrop(m_hWnd, m_pDropHandler);
	
	TCHAR szClassName[256];
	GetClassName(m_hWnd, szClassName, sizeof(szClassName)/sizeof(szClassName[0]));
	if (lstrcmpi(_T("ComboBoxEx32"), szClassName) == 0)
		m_bComboBoxEx = true;
}

/**
 * @brief Sets additional state for handling Extended Length file names.
 */
void CSuperComboBox::SetFileControlStates(bool bCanBeEmpty /*= false*/, int nMaxItems /*= -1*/)
{
	ASSERT(m_bComboBoxEx);

	m_bExtendedFileNames = true;
	m_bCanBeEmpty = bCanBeEmpty;
	if (nMaxItems > 0)
		m_nMaxItems = nMaxItems;
}

/**
 * @brief Adds a string to the list box of a combo box
 * @param lpszItem Pointer to the null-terminated string that is to be added. 
 */
int CSuperComboBox::AddString(LPCTSTR lpszItem)
{
	return InsertString(GetCount(), lpszItem);
}

/**
 * @brief Inserts a string into the list box of a combo box.
 * @param nIndex The zero-based index to the position in the list box that receives the string.
 * @param lpszItem Pointer to the null-terminated string that is to be added. 
 */
int CSuperComboBox::InsertString(int nIndex, LPCTSTR lpszItem)
{
	if (m_bComboBoxEx)
	{
		CString sShortName;		// scoped to remain valid for calling __super::InsertItem()
		if (m_bExtendedFileNames)
		{
			if (nIndex >= static_cast<int>(m_sFullStateText.size()))
				m_sFullStateText.resize(nIndex + 10);
			sShortName = m_sFullStateText[nIndex] = lpszItem;

			const int nPartLen = 72;
			if (sShortName.GetLength() > (nPartLen*2+8)) 
			{
				if (sShortName.Left(4) == _T("\\\\?\\"))
					sShortName.Delete(0, 4);
				else
				if (sShortName.Left(8) == _T("\\\\?\\UNC\\"))
					sShortName.Delete(1, 6);
				CString sL = sShortName.Left(nPartLen);
				int nL = sL.ReverseFind(_T('\\'));
				if (nL > 0) sL = sL.Left(nL+1);

				CString sR = sShortName.Right(nPartLen);
				int nR = sR.Find(_T('\\'));
				if (nR > 0) sR = sR.Right(sR.GetLength() - nR);

				sShortName = sL + _T(" ... ") + sR;
				lpszItem = (LPCTSTR)sShortName;
			}
		}
		COMBOBOXEXITEM cbitem = {0};
		cbitem.mask = CBEIF_TEXT |
			(m_bHasImageList ? CBEIF_IMAGE|CBEIF_SELECTEDIMAGE : 0);
		cbitem.pszText = (LPTSTR)lpszItem;
		cbitem.cchTextMax = (int)_tcslen(lpszItem);
		cbitem.iItem = nIndex;
		cbitem.iImage = I_IMAGECALLBACK;
		cbitem.iSelectedImage = I_IMAGECALLBACK;
		return __super::InsertItem(&cbitem);
	}
	else
	{
		return CComboBox::InsertString(nIndex, lpszItem);
	}
}

int CSuperComboBox::DeleteString(int nIndex)
{
	if (m_bComboBoxEx && m_bExtendedFileNames &&
	    nIndex >= 0 && nIndex < static_cast<int>(m_sFullStateText.size()))
	{
		m_sFullStateText.erase(m_sFullStateText.begin() + nIndex);
	}
	return __super::DeleteString(nIndex);
}

int CSuperComboBox::FindString(int nStartAfter, LPCTSTR lpszString) const
{
	
	if (m_bComboBoxEx)
	{
		ASSERT(m_bExtendedFileNames);
		CString sSearchString = lpszString;
		int nSearchStringLen = sSearchString.GetLength();
		if (nSearchStringLen <= 0)
			return CB_ERR;
		int nLimit = static_cast<int>(m_sFullStateText.size());
		for (int i = nStartAfter+1; i < nLimit; i++)
		{
			CString sListString = m_sFullStateText[i];
			int nListStringLen = sListString.GetLength();
			if (nSearchStringLen <= nListStringLen && sSearchString.CompareNoCase(sListString.Left(nSearchStringLen))==0)
				return i;
		}
		return CB_ERR;
	}
	else
	{
		return CComboBox::FindString(nStartAfter, lpszString);
	}
}

/**
 * @brief Gets the system image list and attaches the image list to a combo box control.
 */
bool CSuperComboBox::AttachSystemImageList()
{
	ASSERT(m_bComboBoxEx);
	if (m_himlSystem==nullptr)
	{
		SHFILEINFO sfi = {0};
		m_himlSystem = (HIMAGELIST)SHGetFileInfo(_T(""), 0, 
			&sfi, sizeof(sfi), SHGFI_SMALLICON | SHGFI_SYSICONINDEX);
		if (m_himlSystem==nullptr)
			return false;
	}
	SetImageList(CImageList::FromHandle(m_himlSystem));
	m_bHasImageList = true;
	return true;
}

void CSuperComboBox::LoadState(LPCTSTR szRegSubKey)
{
	ResetContent();

	int cnt = AfxGetApp()->GetProfileInt(szRegSubKey, _T("Count"), 0);
	int idx = 0;
	for (int i=0; i < cnt && idx < m_nMaxItems; i++)
	{
		CString s,s2;
		s2.Format(_T("Item_%d"), i);
		s = AfxGetApp()->GetProfileString(szRegSubKey, s2);
		if (FindStringExact(-1, s) == CB_ERR && !s.IsEmpty())
		{
			AddString(s);
			idx++;
		}
	}
	if (idx > 0)
	{
		bool bIsEmpty = (m_bCanBeEmpty ? (AfxGetApp()->GetProfileInt(szRegSubKey, _T("Empty"), FALSE) == TRUE) : false);
		if (bIsEmpty)
		{
			SetCurSel(-1);
		}
		else
		{
			SetCurSel(0);
			if (m_bExtendedFileNames)
				GetEditCtrl()->SetWindowText(m_sFullStateText[0]);
		}
	}
}

void CSuperComboBox::GetLBText(int nIndex, CString &rString) const
{
	ASSERT(::IsWindow(m_hWnd));

	if (m_bExtendedFileNames)
	{
		rString = m_sFullStateText[nIndex];
	}
	else
	{
		__super::GetLBText(nIndex, rString.GetBufferSetLength(GetLBTextLen(nIndex)));
		rString.ReleaseBuffer();
	}
}

int CSuperComboBox::GetLBTextLen(int nIndex) const
{
	if (m_bExtendedFileNames)
	{
		return m_sFullStateText[nIndex].GetLength();
	}
	else
	{
		return __super::GetLBTextLen(nIndex);
	}
}

/** 
 * @brief Saves strings in combobox.
 * This function saves strings in combobox, in editbox and in dropdown.
 * Whitespace characters are stripped from begin and end of the strings
 * before saving. Empty strings are not saved. So strings which have only
 * whitespace characters aren't save either.
 * @param [in] szRegSubKey Registry subkey where to save strings.
 * @param [in] bCanBeEmpty
 * @param [in] nMaxItems Max number of strings to save.
 */
void CSuperComboBox::SaveState(LPCTSTR szRegSubKey)
{
	CString strItem;
	if (m_bComboBoxEx)
		GetEditCtrl()->GetWindowText(strItem);
	else
		GetWindowText(strItem);
	strItem.TrimLeft();
	strItem.TrimRight();

	int idx = 0;
	if (!strItem.IsEmpty())
	{
		AfxGetApp()->WriteProfileString(szRegSubKey, _T("Item_0"), strItem);
		idx=1;
	}

	int cnt = GetCount();
	for (int i=0; i < cnt && idx < m_nMaxItems; i++)
	{		
		CString s;
		GetLBText(i, s);
		s.TrimLeft();
		s.TrimRight();
		if (s != strItem && !s.IsEmpty())
		{
			CString s2;
			s2.Format(_T("Item_%d"), idx);
			AfxGetApp()->WriteProfileString(szRegSubKey, s2, s);
			idx++;
		}
	}
	AfxGetApp()->WriteProfileInt(szRegSubKey, _T("Count"), idx);
	
	if (m_bCanBeEmpty)
		AfxGetApp()->WriteProfileInt(szRegSubKey, _T("Empty"), strItem.IsEmpty());
}

void CSuperComboBox::ClearState(LPCTSTR szRegSubKey)
{
	AfxGetApp()->WriteProfileString(szRegSubKey, nullptr, nullptr);
}

BOOL CSuperComboBox::OnEditchange()
{
	if (m_bHasImageList)
	{
		// Trigger a WM_WINDOWPOSCHANGING to help the client area receive an update trough WM_DRAWITEM
		SetWindowPos(NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_NOREDRAW | SWP_NOACTIVATE);
	}

	// bail if not auto completing 
	if (!m_bDoComplete) 
		return FALSE;
	
	int length = GetWindowTextLength();

	// bail if no text
	if (length <= 0) 
		return FALSE;
	
	if (m_bInEditchange)
		return FALSE;
	m_bInEditchange = true;

	// Get the text in the edit box
	CString s;
	GetWindowText(s);
	
	// get the current selection
	DWORD sel = GetEditSel();
	int start = (short)LOWORD(sel), end = (short)HIWORD(sel);
	
	// look for the string that is prefixed by the typed text
	int idx = FindString(-1, s);
	if (idx != CB_ERR)
	{
		// set the new string
		CString strNew;
		GetLBText(idx, strNew);
		SetWindowText(strNew);
	}
	
	// select the text after our typing
	if (sel == CB_ERR || end >= length)
	{
		start = length;
		end = -1;
	}

	// get the caret back in the right spot
	if (m_bComboBoxEx)
		GetEditCtrl()->SetSel(start, end);
	else
		CComboBox::SetEditSel(start, end);  

	m_bInEditchange = false;

	return FALSE;
}

BOOL CSuperComboBox::OnSetfocus()
{
	if (m_bHasImageList)
		GetEditCtrl()->SetModify(FALSE);

	return FALSE;
}

BOOL CSuperComboBox::PreTranslateMessage(MSG* pMsg)
{
    if (pMsg->message == WM_KEYDOWN)
    {
		int nVirtKey = (int) pMsg->wParam;
		// If Shift+Del pressed when dropdown is open, delete selected item
		// from dropdown list
		if (GetAsyncKeyState(VK_SHIFT))
		{
			if (GetDroppedState() && nVirtKey == VK_DELETE)
			{
				int cursel = GetCurSel();
				if (cursel != CB_ERR)
				{
					DeleteString(cursel);
					if (cursel >= GetCount())
						cursel = GetCount() - 1;
					if (cursel >= 0)
						SetCurSel(cursel);
				}
				return FALSE; // No need to further handle this message
			}
		}
		if (m_bAutoComplete)
		{
			m_bDoComplete = true;

			if (nVirtKey == VK_DELETE || nVirtKey == VK_BACK)
					m_bDoComplete = false;
		}
    }

    return __super::PreTranslateMessage(pMsg);
}

void CSuperComboBox::SetAutoComplete(INT nSource)
{
	switch (nSource)
	{
		case AUTO_COMPLETE_DISABLED:
			m_bAutoComplete = false;
			break;

		case AUTO_COMPLETE_FILE_SYSTEM:
		{
			// Disable the build-in auto-completion and use the Windows
			// shell functionality.
			m_bAutoComplete = false;

			// ComboBox's edit control is always 1001.
			CWnd *pWnd = m_bComboBoxEx ? this->GetEditCtrl() : GetDlgItem(1001);
			ASSERT(pWnd != nullptr);
			SHAutoComplete(pWnd->m_hWnd, SHACF_FILESYSTEM);
			break;
		}

		case AUTO_COMPLETE_RECENTLY_USED:
			m_bAutoComplete = true;
			break;

		default:
			ASSERT(!"Unknown AutoComplete source.");
			m_bAutoComplete = false;
	}
}

void CSuperComboBox::ResetContent()
{
	if (m_bExtendedFileNames)
	{
		m_sFullStateText.resize(m_nMaxItems);
		for (int i = 0; i < m_nMaxItems; i++)
		{
			m_sFullStateText[i].Empty();
		}
	}
	__super::ResetContent();
}

int CSuperComboBox::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (__super::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	m_pDropHandler = new DropHandler(std::bind(&CSuperComboBox::OnDropFiles, this, std::placeholders::_1));
	RegisterDragDrop(m_hWnd, m_pDropHandler);
	return 0;
}

void CSuperComboBox::OnDestroy(void)
{
	if (m_pDropHandler != nullptr)
		RevokeDragDrop(m_hWnd);
}

/////////////////////////////////////////////////////////////////////////////
//
//	OnDropFiles code from CDropEdit
//	Copyright 1997 Chris Losinger
//
//	shortcut expansion code modified from :
//	CShortcut, 1996 Rob Warner
//
void CSuperComboBox::OnDropFiles(const std::vector<String>& files)
{
	GetParent()->SendMessage(WM_COMMAND, GetDlgCtrlID() +
		(CBN_EDITUPDATE << 16), (LPARAM)m_hWnd);
	SetWindowText(files[0].c_str());
	GetParent()->SendMessage(WM_COMMAND, GetDlgCtrlID() +
		(CBN_EDITCHANGE << 16), (LPARAM)m_hWnd);
}

static DWORD WINAPI SHGetFileInfoThread(LPVOID pParam)
{
	CString &sPath = reinterpret_cast<CString &>(pParam);
	SHFILEINFO sfi = {0};
	// If SHGetFileInfo() fails, intentionally leave sfi.iIcon as 0 (indicating
	// a file of inspecific type) so as to not obstruct CBEIF_DI_SETITEM logic.
	if (!sPath.IsEmpty())
	{
		if (SUCCEEDED(CoInitialize(nullptr)))
		{
			SHGetFileInfo(sPath, 0, &sfi, sizeof(sfi), SHGFI_SYSICONINDEX);
			CoUninitialize();
		}
	}
	sPath.~CString();
	return sfi.iIcon;
}

static int GetFileTypeIconIndex(LPVOID pParam)
{
	CString &sText = reinterpret_cast<CString &>(pParam);
	DWORD dwIconIndex = 0;
	bool isNetworkDrive = false;
	if (sText.GetLength() >= 2 && (sText[1] == L'\\'))
	{
		if (sText.GetLength() > 4 && sText.Left(4) == L"\\\\?\\")
			if (sText.GetLength() > 8 && sText.Left(8) == L"\\\\?\\UNC\\")
				isNetworkDrive = true;
			else
				isNetworkDrive = false;	// Just a Long File Name indicator
		else
			isNetworkDrive = true;
	}
	else
	if (sText.GetLength() >= 3 && GetDriveType(sText.Left(3)) == DRIVE_REMOTE)
		isNetworkDrive = true;	// Drive letter, but mapped to Remote UNC device.

	// Unless execution drops into the final else block,
	// SHGetFileInfoThread() takes ownership of, and will eventually trash sText
	if (!isNetworkDrive)
	{
		dwIconIndex = SHGetFileInfoThread(pParam);
	}
	else
	if (HANDLE hThread = CreateThread(nullptr, 0, SHGetFileInfoThread, pParam, 0, nullptr))
	{
		// The path is a network path. 
		// Try to get the index of a system image list icon, with 1-sec timeout.

		DWORD dwResult = WaitForSingleObject(hThread, 1000);
		if (dwResult == WAIT_OBJECT_0)
		{
			GetExitCodeThread(hThread, &dwIconIndex);
		}
		CloseHandle(hThread);
	}
	else
	{
		// Ownership of sText was retained, so trash it here
		sText.~CString();
	}
	return static_cast<int>(dwIconIndex);
}

void CSuperComboBox::OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct)
{
	if ((lpDrawItemStruct->itemState & ODS_COMBOBOXEDIT) != 0 && m_bHasImageList)
	{
		LPVOID pvText;
		CString &sText = placement_cast<CString>(&pvText);
		CEdit *const pEdit = GetEditCtrl();
		if (!pEdit->GetModify() || GetFocus() != pEdit)
			GetWindowText(sText);
		int iIcon = GetFileTypeIconIndex(pvText);
		ImageList_DrawEx(m_himlSystem, iIcon, lpDrawItemStruct->hDC,
			lpDrawItemStruct->rcItem.left, lpDrawItemStruct->rcItem.top,
			0, 0, GetSysColor(COLOR_WINDOW), CLR_NONE, ILD_NORMAL);
		return;
	}
	__super::OnDrawItem(nIDCtl, lpDrawItemStruct);
}

/**
 * @brief A message handler for CBEN_GETDISPINFO message
 */
void CSuperComboBox::OnGetDispInfo(NMHDR *pNotifyStruct, LRESULT *pResult)
{
	NMCOMBOBOXEX *pDispInfo = (NMCOMBOBOXEX *)pNotifyStruct;
	if (pDispInfo && pDispInfo->ceItem.pszText && m_bHasImageList)
	{
		pDispInfo->ceItem.mask |= CBEIF_DI_SETITEM;
		LPVOID pvText;
		GetLBText(static_cast<int>(pDispInfo->ceItem.iItem), placement_cast<CString>(&pvText));
		int iIcon = GetFileTypeIconIndex(pvText);
		pDispInfo->ceItem.iImage = iIcon;
		pDispInfo->ceItem.iSelectedImage = iIcon;
	}
	*pResult = 0;
}
</file>

<file path="Winmerge-Src/Src/Common/SuperComboBox.h">
#pragma once

// SuperComboBox.h : header file
//

#include <vector>
#include "UnicodeString.h"

class DropHandler;

/////////////////////////////////////////////////////////////////////////////
// CSuperComboBox window

class CSuperComboBox : public CComboBoxEx
{
// Construction
public:
	CSuperComboBox();
	virtual ~CSuperComboBox();

// Attributes
protected:
	bool m_bInEditchange;
	bool m_bAutoComplete;
	bool m_bDoComplete;
	bool m_bHasImageList;

	int m_nMaxItems;
	bool m_bComboBoxEx;
	bool m_bExtendedFileNames;
	bool m_bCanBeEmpty;

	bool m_bMustUninitOLE;
	static HIMAGELIST m_himlSystem;

	DropHandler *m_pDropHandler;

	std::vector<CString> m_sFullStateText;

public:

	enum
	{
		AUTO_COMPLETE_DISABLED		= 0,
		AUTO_COMPLETE_FILE_SYSTEM,
		AUTO_COMPLETE_RECENTLY_USED
	};

// Operations
	void SetAutoComplete(INT nSource);

public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSuperComboBox)
	public:
    virtual BOOL PreTranslateMessage(MSG* pMsg);
    //}}AFX_VIRTUAL

// Implementation
public:
	void SetFileControlStates(bool bCanBeEmpty = false, int nMaxItems = -1);
	void SaveState(LPCTSTR szRegSubKey);
	void LoadState(LPCTSTR szRegSubKey);
	static void ClearState(LPCTSTR szRegSubKey);
	bool AttachSystemImageList();
	int AddString(LPCTSTR lpszItem);
	int InsertString(int nIndex, LPCTSTR lpszItem);
	int DeleteString(int nIndex);
	int FindString(int nStartAfter, LPCTSTR lpszString) const;
	int GetLBTextLen(int nIndex) const;
	void GetLBText(int nIndex, CString &rString) const;

	// Generated message map functions
protected:
	void ResetContent();

	virtual void PreSubclassWindow();

	//{{AFX_MSG(CSuperComboBox)
	afx_msg BOOL OnEditchange();
	afx_msg BOOL OnSetfocus();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDropFiles(const std::vector<String>& files);
	afx_msg void OnGetDispInfo(NMHDR *pNotifyStruct, LRESULT *pResult);
	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
	afx_msg void OnDestroy();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};
</file>

<file path="Winmerge-Src/Src/Common/SysColorHook.cpp">
/**
 * @file  SysColorHook.cpp
 *
 * @brief Provides functionality to hook the GetSysColor() API and return custom colors.
 */
// SPDX-License-Identifier: MIT
#include "stdafx.h"
#include "SysColorHook.h"
#include "MergeDarkMode.h"

#if defined(_DARKMODELIB_EXTERNAL_IATHOOK) || !defined(USE_DARKMODELIB)
#include "IatHook.h"
#else
extern PIMAGE_THUNK_DATA FindAddressByName(void* moduleBase, PIMAGE_THUNK_DATA impName, PIMAGE_THUNK_DATA impAddr, const char* funcName);
extern PIMAGE_THUNK_DATA FindAddressByOrdinal(void* moduleBase, PIMAGE_THUNK_DATA impName, PIMAGE_THUNK_DATA impAddr, uint16_t ordinal);
extern PIMAGE_THUNK_DATA FindIatThunkInModule(void* moduleBase, const char* dllName, const char* funcName);
extern PIMAGE_THUNK_DATA FindDelayLoadThunkInModule(void* moduleBase, const char* dllName, const char* funcName);
extern PIMAGE_THUNK_DATA FindDelayLoadThunkInModule(void* moduleBase, const char* dllName, uint16_t ordinal);
#endif

using fnGetSysColor = DWORD(WINAPI*)(int nIndex);
using fnGetSysColorBrush = HBRUSH(WINAPI*)(int nIndex);

struct SysColor
{
	DWORD color;
	HBRUSH brush;
	bool isCustom;
} g_syscolor[COLOR_MENUBAR + 1];

static fnGetSysColor g_orgGetSysColor;
static fnGetSysColorBrush g_orgGetSysColorBrush;

namespace SysColorHook
{

DWORD __stdcall MyGetSysColor(int nIndex)
{
	if (nIndex < 0 || nIndex >= static_cast<int>(std::size(g_syscolor)))
		return 0;
	return g_syscolor[nIndex].color;
}

HBRUSH __stdcall MyGetSysColorBrush(int nIndex)
{
	if (nIndex < 0 || nIndex >= static_cast<int>(std::size(g_syscolor)))
		return 0;
	return g_syscolor[nIndex].brush;
}

bool IsCustomSysColor(int nIndex)
{
	if (nIndex < 0 || nIndex >= static_cast<int>(std::size(g_syscolor)))
		return false;
	return g_syscolor[nIndex].isCustom;
}

size_t GetSysColorCount()
{
	return std::size(g_syscolor);
}

unsigned GetOrgSysColor(int nIndex)
{
	if (!g_orgGetSysColor)
		return GetSysColor(nIndex);
	return g_orgGetSysColor(nIndex);
}

uintptr_t ReplaceFunction(IMAGE_THUNK_DATA* addr, uintptr_t newFunction)
{
	DWORD oldProtect;
	if (!VirtualProtect(addr, sizeof(IMAGE_THUNK_DATA), PAGE_READWRITE, &oldProtect))
		return 0;
	uintptr_t oldFunction = addr->u1.Function;
	addr->u1.Function = newFunction;
	VirtualProtect(addr, sizeof(IMAGE_THUNK_DATA), oldProtect, &oldProtect);
	return oldFunction;
}

void Init()
{
	auto getSysColor = (g_orgGetSysColor ? g_orgGetSysColor : GetSysColor);
	auto getSysColorBrush = (g_orgGetSysColorBrush ? g_orgGetSysColorBrush : GetSysColorBrush);
	for (int i = 0; i < static_cast<int>(std::size(g_syscolor)); ++i)
	{
		if (g_syscolor[i].isCustom)
			DeleteObject(g_syscolor[i].brush);
		g_syscolor[i].color = getSysColor(i);
		g_syscolor[i].brush = getSysColorBrush(i);
		g_syscolor[i].isCustom = false;
	}
}

bool Hook(void* moduleBase)
{
	auto addrGetSysColor = FindIatThunkInModule(moduleBase, "user32.dll", "GetSysColor");
	auto addrGetSysColorBrush = FindIatThunkInModule(moduleBase, "user32.dll", "GetSysColorBrush");
	if (!addrGetSysColor || !addrGetSysColorBrush)
		return false;
	auto orgGetSysColor = reinterpret_cast<fnGetSysColor>(ReplaceFunction(addrGetSysColor, reinterpret_cast<uintptr_t>(static_cast<fnGetSysColor>(MyGetSysColor))));
	if (!g_orgGetSysColor)
		g_orgGetSysColor = orgGetSysColor;
	auto orgGetSysColorBrush = reinterpret_cast<fnGetSysColorBrush>(ReplaceFunction(addrGetSysColorBrush, reinterpret_cast<uintptr_t>(static_cast<fnGetSysColorBrush>(MyGetSysColorBrush))));
	if (!g_orgGetSysColorBrush)
		g_orgGetSysColorBrush = orgGetSysColorBrush;
	return true;
}

void Unhook(void* moduleBase)
{
	if (!g_orgGetSysColor)
		return;
	auto addrGetSysColor = FindIatThunkInModule(moduleBase, "user32.dll", "GetSysColor");
	auto addrGetSysColorBrush = FindIatThunkInModule(moduleBase, "user32.dll", "GetSysColorBrush");
	if (!addrGetSysColor || !addrGetSysColorBrush)
		return;
	ReplaceFunction(addrGetSysColor, reinterpret_cast<uintptr_t>(static_cast<fnGetSysColor>(g_orgGetSysColor)));
	ReplaceFunction(addrGetSysColorBrush, reinterpret_cast<uintptr_t>(static_cast<fnGetSysColorBrush>(g_orgGetSysColorBrush)));
	g_orgGetSysColor = nullptr;
	g_orgGetSysColorBrush = nullptr;
}

void SetSysColor(int nIndex, unsigned color)
{
	if (nIndex < 0 || nIndex >= static_cast<int>(std::size(g_syscolor)))
		return;
	if (g_syscolor[nIndex].color == color)
		return;
	if (g_syscolor[nIndex].isCustom)
		DeleteObject(g_syscolor[nIndex].brush);
	g_syscolor[nIndex].brush = CreateSolidBrush(color);
	g_syscolor[nIndex].color = color;
	g_syscolor[nIndex].isCustom = true;
}

void Deserialize(const String& colorsStr, COLORREF* colors)
{
	auto sysColorMapping = strutils::split(colorsStr, ',');
	for (auto&& sysColorEntry : sysColorMapping)
	{
		auto pair = strutils::split(sysColorEntry, ':');
		if (pair.size() == 2)
		{
			const int index = tc::ttoi(String(pair[0].data(), pair[0].length()).c_str());
			tchar_t* endptr = nullptr;
			const String colorStr = String(pair[1].data(), pair[1].length());
			unsigned color = static_cast<unsigned>(tc::tcstoll(colorStr.c_str(), &endptr,
				(colorStr.length() >= 2 && colorStr[1] == 'x') ? 16 : 10));
			if (colors)
			{
				if (index >= 0 && index < static_cast<int>(std::size(g_syscolor)))
					colors[index] = color;
			}
			else
				SysColorHook::SetSysColor(index, color);
		}
	}
}

String Serialize()
{
	std::vector<String> sysColorMapping;
	const int count = static_cast<int>(SysColorHook::GetSysColorCount());
	for (int i = 0; i < count; ++i)
	{
		if (g_syscolor[i].isCustom)
			sysColorMapping.push_back(strutils::format(_T("%d:0x%08x"), i, g_syscolor[i].color));
	}
	return strutils::join(sysColorMapping.begin(), sysColorMapping.end(), _T(","));
}

}


</file>

<file path="Winmerge-Src/Src/Common/SysColorHook.h">
/**
 * @file  SysColorHook.h
 *
 * @brief Provides functionality to hook the GetSysColor() API and return custom colors.
 */
#pragma once

namespace SysColorHook
{
void Init();
bool Hook(void* moduleBase);
void Unhook(void* moduleBase);
void SetSysColor(int nIndex, unsigned color);
unsigned GetOrgSysColor(int nIndex);
bool IsCustomSysColor(int nIndex);
size_t GetSysColorCount();
void Deserialize(const String& colorStr, COLORREF* colors = nullptr);
String Serialize();

}
</file>

<file path="Winmerge-Src/Src/Common/unicoder.cpp">
/**
 *  @file   unicoder.cpp
 *  @author Perry Rapp, Creator, 2003-2006
 *  @date   Created: 2003-10
 *  @date   Edited:  2006-02-20 (Perry Rapp)
 *
 *  @brief  Implementation of utility unicode conversion routines
 */

/* The MIT License
Copyright (c) 2003 Perry Rapp
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

#include "pch.h"
#include "unicoder.h"
#include <windows.h>
#include <cassert>
#include <memory>
#include <Poco/UnicodeConverter.h>
#include "UnicodeString.h"
#include "ExConverter.h"

using Poco::UnicodeConverter;

namespace ucr
{

// store the default codepage as specified by user in options
static int f_nDefaultCodepage = GetACP();


# pragma warning(push)          // Saves the current warning state.
# pragma warning(disable:4244)  // Temporarily disables warning 4244: "conversion from 'int' to 'char', possible loss of data"
/**
 * @brief Convert unicode codepoint to UTF-8 byte string
 *
 * utf8 must be a 7+ byte buffer
 * returns length of byte string written
 * Does not zero-terminate!
 */
int Ucs4_to_Utf8(unsigned unich, unsigned char * utf8)
{
	if (unich <= 0x7f)
	{
		utf8[0] = (unsigned char)unich;
		return 1;
	}
	else if (unich <= 0x7ff)
	{
		utf8[0] = 0xc0 + (unich >> 6);
		utf8[1] = 0x80 + (unich & 0x3f);
		return 2;
	}
	else if (unich <= 0xffff)
	{
		utf8[0] = 0xe0 + (unich >> 12);
		utf8[1] = 0x80 + ((unich >> 6) & 0x3f);
		utf8[2] = 0x80 + (unich & 0x3f);
		return 3;
	}
	else if (unich <= 0x1fffff)
	{
		utf8[0] = 0xf0 + (unich >> 18);
		utf8[1] = 0x80 + ((unich >> 12) & 0x3f);
		utf8[2] = 0x80 + ((unich >> 6) & 0x3f);
		utf8[3] = 0x80 + (unich & 0x3f);
		return 4;
	}
	else if (unich <= 0x3ffffff)
	{
		utf8[0] = 0xf8 + (unich >> 24);
		utf8[1] = 0x80 + ((unich >> 18) & 0x3f);
		utf8[2] = 0x80 + ((unich >> 12) & 0x3f);
		utf8[3] = 0x80 + ((unich >> 6) & 0x3f);
		utf8[4] = 0x80 + (unich & 0x3f);
		return 5;
	}
	else if (unich <= 0x7fffffff)
	{
		utf8[0] = 0xfc + (unich >> 30);
		utf8[1] = 0x80 + ((unich >> 24) & 0x3f);
		utf8[2] = 0x80 + ((unich >> 18) & 0x3f);
		utf8[3] = 0x80 + ((unich >> 12) & 0x3f);
		utf8[4] = 0x80 + ((unich >> 6) & 0x3f);
		utf8[5] = 0x80 + (unich & 0x3f);
		return 6;
	}
	else
	{
		// Invalid Unicode codepoint (high bit was set)
		// TODO: What do we do ?
		utf8[0] = '?';
		return 1;
	}
}
# pragma warning(pop)           // Restores the warning state.

/**
 * @brief Gets a length of UTF-8 character in bytes.
 * @param [in] ch The character for which to get the length.
 * @return Byte length of UTF-8 character, -1 if invalid.
 */
int Utf8len_fromLeadByte(unsigned char ch)
{
	if (ch < 0x80) return 1;
	if (ch < 0xC0) return -1;
	if (ch < 0xE0) return 2;
	if (ch < 0xF0) return 3;
	if (ch < 0xF8) return 4;
	if (ch < 0xFC) return 5;
	if (ch < 0xFE) return 6;
	return -1;
}

/**
 * @brief return #bytes required to represent Unicode codepoint as UTF-8
 */
int Utf8len_fromCodepoint(unsigned ch)
{
	if (ch <= 0x7F) return 1;
	if (ch <= 0x7FF) return 2;
	if (ch <= 0xFFFF) return 3;
	if (ch <= 0x1FFFFF) return 4;
	if (ch <= 0x3FFFFFF) return 5;
	if (ch <= 0x7FFFFFFF) return 6;
	return -1;
}

/**
 * @brief How many chars in this UTF-8 string ?
 *
 * @param size size argument as filemapping are not 0 terminated
 *
 * @bug Fails for files larger than 2gigs
 */
size_t stringlen_of_utf8(const char* text, size_t size)
{
	size_t len = 0;
	for (size_t i = 0; i < size;)
	{
		int chlen = Utf8len_fromLeadByte(text[i]);
		if (chlen < 1) chlen = 1;
		i += chlen;
		len ++;
	}
	return len;
}

/**
 * @brief Read UTF-8 character and return as Unicode
 */
unsigned GetUtf8Char(unsigned char * str)
{
	/* test short cases first, as probably much more common */
	if (!(*str & 0x80 && *str & 0x40))
	{
		return str[0];
	}
	if (!(*str & 0x20))
	{
		unsigned ch = ((str[0] & 0x1F) << 6)
				+ (str[1] & 0x3F);
		return ch;
	}
	if (!(*str & 0x10))
	{
		unsigned ch = ((str[0] & 0x0f) << 12)
				+ ((str[1] & 0x3F) << 6)
				+ (str[2] & 0x3F);
		return ch;
	}
	if (!(*str & 0x08))
	{
		unsigned ch = ((str[0] & 0x0F) << 18)
				+ ((str[1] & 0x3F) << 12)
				+ ((str[2] & 0x3F) << 6)
				+ (str[3] & 0x3F);
		return ch;
	}
	if (!(*str & 0x04))
	{
		unsigned ch = ((str[0] & 0x0F) << 24)
				+ ((str[1] & 0x3F) << 18)
				+ ((str[2] & 0x3F) << 12)
				+ ((str[3] & 0x3F) << 6)
				+ (str[4] & 0x3F);
		return ch;
	}
	else
	{
		unsigned ch = ((str[0] & 0x0F) << 30)
				+ ((str[1] & 0x3F) << 24)
				+ ((str[2] & 0x3F) << 18)
				+ ((str[3] & 0x3F) << 12)
				+ ((str[4] & 0x3F) << 6)
				+ (str[5] & 0x3F);
		return ch;
	}
}


# pragma warning(push)          // Saves the current warning state.
# pragma warning(disable:4244)  // Temporarily disables warning 4244: "conversion from 'int' to 'char', possible loss of data"
/**
 * @brief Write unicode codepoint u out as UTF-8 to lpd, and advance lpd
 *
 * Returns number of bytes written (or -1 for error, in which case it writes '?')
 */
int to_utf8_advance(unsigned u, unsigned char * &lpd)
{
	if (u < 0x80)
	{
		*lpd++ = u;
		return 1;
	}
	else if (u < 0x800)
	{
		*lpd++ = 0xC0 + (u >> 6);
		*lpd++ = 0x80 + (u & 0x3F);
		return 2;
	}
	else if (u < 0x10000)
	{
		*lpd++ = 0xE0 + (u >> 12);
		*lpd++ = 0x80 + ((u >> 6) & 0x3F);
		*lpd++ = 0x80 + (u & 0x3F);
		return 3;
	}
	else if (u < 0x200000)
	{
		*lpd++ = 0xF0 + (u >> 18);
		*lpd++ = 0x80 + ((u >> 12) & 0x3F);
		*lpd++ = 0x80 + ((u >> 6) & 0x3F);
		*lpd++ = 0x80 + (u & 0x3F);
		return 4;
	}
	else if (u < 0x4000000)
	{
		*lpd++ = 0xF8 + (u >> 24);
		*lpd++ = 0x80 + ((u >> 18) & 0x3F);
		*lpd++ = 0x80 + ((u >> 12) & 0x3F);
		*lpd++ = 0x80 + ((u >> 6) & 0x3F);
		*lpd++ = 0x80 + (u & 0x3F);
		return 5;
	}
	else if (u < 0x80000000)
	{
		*lpd++ = 0xFC + (u >> 30);
		*lpd++ = 0x80 + ((u >> 24) & 0x3F);
		*lpd++ = 0x80 + ((u >> 18) & 0x3F);
		*lpd++ = 0x80 + ((u >> 12) & 0x3F);
		*lpd++ = 0x80 + ((u >> 6) & 0x3F);
		*lpd++ = 0x80 + (u & 0x3F);
		return 6;
	}
	else
	{
		*lpd++ = '?';
		return 1;
	}
}
# pragma warning(pop)           // Restores the warning state.

/**
 * @brief convert character passed (Unicode codepoint) to a tchar_t (set lossy flag if imperfect conversion)
 */
void maketchar(String & ch, unsigned unich, bool & lossy)
{
	// NB: Windows always draws in CP_ACP, not CP_THREAD_ACP, so we must use CP_ACP as an internal codepage

	maketchar(ch, unich, lossy, CP_ACP);
}

/**
 * @brief convert character passed (Unicode codepoint) to a tchar_t (set lossy flag if imperfect conversion)
 */
void maketchar(String & ch, unsigned unich, bool & lossy, unsigned codepage)
{
#ifdef _UNICODE
	if (unich < 0x10000)
	{
		ch = static_cast<tchar_t>(unich);
		return;
	}
	else if (unich < 0x110000)
	{
		ch = static_cast<tchar_t>(((unich - 0x10000)/0x400 + 0xd800));
		ch += static_cast<tchar_t>(((unich % 0x400) + 0xdc00));
		return;
	}
	lossy = true;
	ch = '?';
	return;
#else
	if (unich < 0x80)
	{
		ch = (tchar_t)unich;
		return;
	}
	wchar_t wch = (wchar_t)unich;
	if (!lossy)
	{
		// So far it isn't lossy, so try for lossless conversion
		char outch[3] = {0};
		BOOL defaulted = FALSE;
		DWORD flags = WC_NO_BEST_FIT_CHARS;
		if (WideCharToMultiByte(codepage, flags, &wch, 1, outch, sizeof(outch), nullptr, &defaulted)
				&& !defaulted)
		{
			ch = outch;
			return;
		}
		lossy = true;
	}
	// already lossy, so make our best shot
	DWORD flags = WC_COMPOSITECHECK + WC_DISCARDNS + WC_SEPCHARS + WC_DEFAULtchar_t;
	tchar_t outbuff[16];
	int n = WideCharToMultiByte(codepage, flags, &wch, 1, outbuff, sizeof(outbuff) - 1, nullptr, nullptr);
	if (n > 0)
	{
		outbuff[n] = 0;
		ch = outbuff;
		return;
	}
	ch = _T("?");
#endif
}

/**
 * @brief convert 8-bit character input to Unicode codepoint and return it
 */
unsigned byteToUnicode(unsigned char ch)
{
	// NB: Windows always draws in CP_ACP, not CP_THREAD_ACP, so we must use CP_ACP as an internal codepage
	return byteToUnicode(ch, CP_ACP);
}

/**
 * @brief convert 8-bit character input to Unicode codepoint and return it
 */
unsigned byteToUnicode(unsigned char ch, unsigned codepage)
{

	if (ch < 0x80)
		return ch;

	DWORD flags = 0;
	wchar_t wbuff;
	int n = MultiByteToWideChar(codepage, flags, (const char*) & ch, 1, &wbuff, 1);
	if (n > 0)
		return wbuff;
	else
		return '?';
}

/**
 * @brief Return encoding used for tchar_t & String
 */
void getInternalEncoding(UNICODESET * unicoding, int * codepage)
{
#ifdef _UNICODE
	*unicoding = UCS2LE;
	*codepage = CP_UCS2LE;
#else
	// NB: Windows always draws in CP_ACP, not CP_THREAD_ACP, so we must use CP_ACP as an internal codepage
	*unicoding = NONE;
	*codepage = CP_ACP;
#endif
}

/**
 * @brief Write appropriate BOM (Unicode byte order marker)
 * returns #bytes written
 */
int writeBom(void* dest, UNICODESET unicoding)
{
	unsigned char * lpd = reinterpret_cast<unsigned char *>(dest);
	// write Unicode byte order marker (BOM)
	if (unicoding == UCS2LE)
	{
		*lpd++ = 0xFF;
		*lpd++ = 0xFE;
		return 2;
	}
	else if (unicoding == UCS2BE)
	{
		*lpd++ = 0xFE;
		*lpd++ = 0xFF;
		return 2;
	}
	else if (unicoding == UTF8)
	{
		*lpd++ = 0xEF;
		*lpd++ = 0xBB;
		*lpd++ = 0xBF;
		return 3;
	}
	return 0;
}

int getBomSize(UNICODESET unicoding)
{
	if (unicoding == UCS2LE)
		return 2;
	else if (unicoding == UCS2BE)
		return 2;
	else if (unicoding == UTF8)
		return 3;
	return 0;
}

/**
 * @brief Extract character from pointer, handling UCS-2 codesets
 *  This does not handle MBCS or UTF-8 codepages correctly!
 *  Client should not use this except for Unicode or SBCS codepages.
 */
unsigned get_unicode_char(unsigned char * ptr, UNICODESET codeset, int codepage)
{
	unsigned ch;
	switch (codeset)
	{
	case UCS2LE:
		ch = *((WORD *)ptr);
		break;
	case UCS2BE:
		ch = (ptr[0] << 8) + ptr[1];
		break;
	default:
		// TODO: How do we recognize valid codepage ?
		// if not, use byteToUnicode(*ptr)
		ch = byteToUnicode(*ptr, codepage);
	}
	return ch;
}

/**
 * @brief Convert series of bytes (8-bit chars) to tchar_ts.
 *
 * @param [out] str String returned.
 * @param [in] lpd Original byte array to convert.
 * @param [in] len Length of the original byte array.
 * @param [in] codepage Codepage used.
 * @param [out] lossy Was conversion lossy?
 * @return true if conversion succeeds, false otherwise.
 * @todo This doesn't inform the caller whether translation was lossy
 *  In fact, this doesn't even know. Probably going to have to make
 *  two passes, the first with MB_ERR_INVALID_CHARS. Ugh. :(
 */
bool maketstring(String & str, const char* lpd, size_t len, int codepage, bool * lossy)
{
	if (!len)
	{
		str.clear();
		return true;
	}

	int defcodepage = getDefaultCodepage();
	
	// 0 is a valid value (CP_ACP)!
	if (codepage == -1)
		codepage = defcodepage;

#ifdef UNICODE
	// Convert input to Unicode, using specified codepage
	// tchar_t is wchar_t, so convert into String (str)
	DWORD flags = MB_ERR_INVALID_CHARS;
	size_t wlen = len * 2 + 6;
	assert(wlen < INT_MAX);

	try
	{
		str.resize(wlen);
	}
	catch (std::bad_alloc&)
	{
		// Not enough memory - exit
		return false;
	}

	LPWSTR wbuff = &*str.begin();
	if (codepage == CP_ACP || IsValidCodePage(codepage))
	{
		int n = MultiByteToWideChar(codepage, flags, lpd, static_cast<int>(len), wbuff, static_cast<int>(wlen - 1));
		if (n)
		{
			/*
			NB: MultiByteToWideChar is documented as only zero-terminating
			if input was zero-terminated, but it appears that it can
			zero-terminate even if input wasn't.
			So we check if it zero-terminated and adjust count accordingly.
			*/
			//>2007-01-11 jtuc: We must preserve an embedded zero even if it is
			// the last input character. As we don't expect MultiByteToWideChar to
			// add a zero that does not originate from the input string, it is a
			// good idea to ASSERT that the assumption holds.
			if (wbuff[n-1] == 0 && lpd[len-1] != 0)
			{
				//assert(false);
				*lossy = true;
				--n;
			}
			try
			{
				str.resize(n);
			}
			catch (std::bad_alloc&)
			{
				// Not enough memory - exit
				return false;
			}
			return true;
		}
		else
		{
			if (GetLastError() == ERROR_INVALID_FLAGS)
			{
				n = MultiByteToWideChar(codepage, 0, lpd, static_cast<int>(len), wbuff, static_cast<int>(wlen-1));
				if (n)
				{
					/* NB: MultiByteToWideChar is documented as only zero-terminating 
					if input was zero-terminated, but it appears that it can 
					zero-terminate even if input wasn't.
					So we check if it zero-terminated and adjust count accordingly.
					*/
					if (wbuff[n-1] == 0 && lpd[len-1] != 0)
					{
						//assert(false);
						*lossy = true;
						--n;
					}
					try
					{
						str.resize(n);
					}
					catch (std::bad_alloc&)
					{
						// Not enough memory - exit
						return false;
					}
					return true;
				}
			}
			if (GetLastError() == ERROR_NO_UNICODE_TRANSLATION)
			{
				*lossy = true;
				flags = 0;
				// wlen & wbuff are still fine
				n = MultiByteToWideChar(codepage, flags, lpd, static_cast<int>(len), wbuff, static_cast<int>(wlen-1));
				if (n)
				{
					try
					{
						str.resize(n);
					}
					catch (std::bad_alloc&)
					{
						// Not enough memory - exit
						return false;
					}
					return true;
				}
			}
			str = _T("?");
			return true;
		}
	}
	else
	{
		IExconverter *pexconv = Exconverter::getInstance();
		if (pexconv != nullptr)
		{
			size_t n = wlen;
			if (pexconv->convertToUnicode(codepage, lpd, &len, wbuff, &n))
			{
				try
				{
					str.resize(n);
				}
				catch (std::bad_alloc&)
				{
					// Not enough memory - exit
					return false;
				}
				return true;
			}
			else
			{
				*lossy = true;
				str = _T("?");
			}
			return true;
		}
		else
		{
			*lossy = true;
			str = _T("?");
		}
		return true;
	}

#else
	int dstcodepage = IsValidCodePage(defcodepage) ? defcodepage : GetACP();

	if (EqualCodepages(codepage, dstcodepage))
	{
		// trivial case, they want the bytes in the file interpreted in our current codepage
		// Only caveat is that input (lpd) is not zero-terminated
		str = String(lpd, len);
		return true;
	}

	if (codepage == CP_ACP || IsValidCodePage(codepage))
	{
		str = CrossConvertToStringA(lpd, len, codepage, dstcodepage, lossy);
		if (*lossy)
			str = _T("?");
		return true;
	}
	else
	{
		IExconverter *pexconv = Exconverter::getInstance();
		if (pexconv != nullptr)
		{		
			size_t n = len * 6 + 6;
			try
			{
				str.resize(n);
			}
			catch (std::bad_alloc&)
			{
				// Not enough memory - exit
				return false;
			}
			char *buff = &*str.begin();
			pexconv->convert(codepage, dstcodepage, (const unsigned char *)lpd, &len, (unsigned char *)buff, &n);
			if (n)
			{
				try
				{
					str.resize(n);
				}
				catch (std::bad_alloc&)
				{
					// Not enough memory - exit
					return false;
				}
			}
			else
				str = _T("?");
		}
		else
			str = _T("?");		
		return true;
	}
#endif
}

/**
 * @brief (ANSI build only) Convert from one 8 bit codepage to another
 */
#ifndef UNICODE
String CrossConvertToStringA(const char* src, unsigned srclen, int cpin, int cpout, bool * lossy)
{
	int wlen = srclen * 2 + 6;
	int clen = wlen * 2 + 6;
	String str;
	str.resize(clen);
	char* cbuff = &*str.begin();
	int nbytes = CrossConvert(src, srclen, cbuff, clen, cpin, cpout, lossy);
	str.resize(nbytes);
	return str;
}
#endif

/**
 * @brief Convert from one 8-bit codepage to another
 *
 * destsize must be at least 2
 */
int CrossConvert(const char* src, unsigned srclen, char* dest, unsigned destsize, int cpin, int cpout, bool * lossy)
{
	assert(destsize > 1);

	// Convert input to Unicode, using specified codepage
	DWORD flags = 0;
	int wlen = srclen * 2 + 6;
	auto wbuff = std::make_unique<wchar_t[]>(wlen);
	int n;
	if (cpin == CP_UCS2LE)
	{
		if (srclen == -1)
			srclen = static_cast<unsigned>(wcslen((wchar_t *)src) * sizeof(wchar_t));
		memcpy(wbuff.get(), src, srclen);
		n = srclen / sizeof(wchar_t);
	}
	else if (cpin == CP_UCS2BE)
	{
		if (srclen == -1)
			srclen = static_cast<unsigned>(wcslen((wchar_t *)src) * sizeof(wchar_t));
		_swab((char *)src, (char *)wbuff.get(), srclen);
		n = srclen / sizeof(wchar_t);
	}
	else
	{
		n = MultiByteToWideChar(cpin, flags, (const char*)src, srclen, wbuff.get(), wlen - 1);
		if (!n)
		{
			int nsyserr = ::GetLastError();
			dest[0] = '?';
			return 1;
		}
	}
	/*
	NB: MultiByteToWideChar is documented as only zero-terminating
	if input was zero-terminated, but it appears that it can
	zero-terminate even if input wasn't.
	So we check if it zero-terminated and adjust count accordingly.
	*/
	if (wbuff[n-1] == 0)
		--n;
	wbuff[n] = 0; // zero-terminate string

	// Now convert to tchar_t (which means defcodepage)
	flags = WC_NO_BEST_FIT_CHARS; // TODO: Think about this
	BOOL defaulted = FALSE;
	BOOL * pdefaulted = &defaulted;
	if (cpout == CP_UTF8)
	{
		flags = 0;
		pdefaulted = nullptr;
	}
	if (cpout == CP_UCS2LE)
	{
		memcpy(dest, wbuff.get(), n * sizeof(wchar_t));
		n = n * sizeof(wchar_t);
		dest[n] = 0;
		dest[n + 1] = 0;
	}
	else if (cpout == CP_UCS2BE)
	{
		_swab((char *)wbuff.get(), dest, n * sizeof(wchar_t));
		n = n * sizeof(wchar_t);
		dest[n] = 0;
		dest[n + 1] = 0;
	}
	else
	{
		n = WideCharToMultiByte(cpout, flags, wbuff.get(), n, dest, destsize - 1, nullptr, pdefaulted);
		if (!n)
		{
			int nsyserr = ::GetLastError();
		}
		dest[n] = 0;
	}
	if (lossy)
		*lossy = !!defaulted;
	return n;
}

/**
 * @brief Buffer constructor.
 * The constructor creates buffer with given size.
 * @param [in] initialSize Buffer's size.
 */
buffer::buffer(size_t initialSize)
{
	size = 0;
	capacity = initialSize;
	ptr = (unsigned char *)calloc(capacity, 1);
}

/**
 * @brief Buffer destructor.
 * Frees the reserved buffer.
 */
buffer::~buffer()
{
	free(ptr);
}

/**
 * @brief Resize the buffer.
 * @param [in] newSize New size of the buffer.
 */
void buffer::resize(size_t newSize)
{
	if (capacity < newSize)
	{
		unsigned char *tmp = static_cast<unsigned char *>(realloc(ptr, newSize));
		if (tmp == nullptr)
			throw std::bad_alloc();
		capacity = newSize;
		ptr = tmp;
	}
}

unsigned char *convertTtoUTF8(buffer * buf, const tchar_t *src, int srcbytes/* = -1*/)
{
	bool bSucceeded;
#ifdef _UNICODE
	bSucceeded = convert(CP_UCS2LE, 
		(unsigned char *)src, (int)((srcbytes < 0) ? wcslen((const wchar_t *)src) * sizeof(wchar_t) : srcbytes),
		CP_UTF8, buf);
#else
	bSucceeded = convert(GetACP(),	
		(unsigned char *)src, (int)((srcbytes < 0) ? strlen((const char *)src) : srcbytes),
		CP_UTF8, buf);
#endif
	if (!bSucceeded)
		*((unsigned char *)buf->ptr) = 0;
	return buf->ptr;
}

unsigned char *convertTtoUTF8(const tchar_t *src, int srcbytes/* = -1*/)
{
	buffer buf(256);
	convertTtoUTF8(&buf, src, srcbytes);
	return (unsigned char *)_strdup((const char *)buf.ptr);
}

tchar_t *convertUTF8toT(buffer * buf, const char *src, int srcbytes/* = -1*/)
{
	bool bSucceeded;
#ifdef _UNICODE
	bSucceeded = convert(CP_UTF8,
		(const unsigned char *)src, (int)((srcbytes < 0) ? strlen((const char *)src) : srcbytes),
		CP_UCS2LE, buf);
#else
	bSucceeded = convert(CP_UTF8,
		(const unsigned char *)src, (int)((srcbytes < 0) ? strlen((const char *)src) : srcbytes),
		GetACP(), buf);
#endif
	if (!bSucceeded)
		*((tchar_t *)buf->ptr) = 0;
	return (tchar_t *)buf->ptr;
}

tchar_t *convertUTF8toT(const char *src, int srcbytes/* = -1*/)
{
	buffer buf(256);
	convertUTF8toT(&buf, src, srcbytes);
	return (tchar_t *)tc::tcsdup((const tchar_t*)buf.ptr);
}

void dealloc(void *ptr)
{
	free(ptr);
}

String toTString(const std::wstring& str)
{
#ifdef UNICODE
	return str;
#else
	return toThreadCP(str);
#endif
}

String toTString(const std::string& str)
{
#ifdef UNICODE
	std::wstring wstr;
	UnicodeConverter::toUTF16(str, wstr);
	return wstr;
#else
	const char *p = convertUTF8toT(str.c_str(), str.length());
	std::string astr = p;
	dealloc((void *)p);
	return astr;
#endif
}

String toTStringFromACP(const std::string& str)
{
#ifndef UNICODE
	return str;
#else
	String retval;
	bool lossy = false;
	maketstring(retval, str.c_str(), str.length(), GetACP(), &lossy);
	return retval;
#endif
}

void toUTF16(const String& tstr, std::wstring& wstr)
{
#ifdef UNICODE
	wstr = tstr;
#else
	UnicodeConverter::toUTF16(tstr, wstr);
#endif
}

std::string toUTF8(const String& tstr)
{
	std::string u8str;
	toUTF8(tstr, u8str);
	return u8str;
}

void toUTF8(const String& tstr, std::string& u8str)
{
#ifdef _UNICODE
	const size_t len = tstr.length();
	u8str.resize(len * 3);

	if (len == 0)
		return;

	char *p = &u8str[0];
	for (size_t i = 0; i < len; ++i)
	{
		unsigned uc = tstr[i];
		if (uc >= 0xd800 && uc < 0xdc00)
		{
			if (++i != len)
			{
				wchar_t uc2 = tstr[i];
				uc = ((uc & 0x3ff) << 10) + (uc2 & 0x3ff) + 0x10000;
			}
		}
		p += Ucs4_to_Utf8(uc, reinterpret_cast<unsigned char *>(p));
	}
	u8str.resize(p - &u8str[0]);
#else
	const char *p = (const char *)convertTtoUTF8(tstr.c_str(), tstr.length());
	u8str = p;
	dealloc((void *)p);
#endif
}

bool convert(int codepage1, const unsigned char * src, int srcbytes, int codepage2, buffer * dest)
{
	UNICODESET unicoding[2];
	int codepage[2] = {codepage1, codepage2};

	int i;
	for (i = 0; i < 2; i++)
	{
		switch (codepage[i])
		{
		case CP_UCS2LE:
			unicoding[i] = UCS2LE; break;
		case CP_UCS2BE:
			unicoding[i] = UCS2BE; break;
		case CP_UTF8:
			unicoding[i] = UTF8; break;
		default:
			unicoding[i] = NONE; break;
		}
	}

	return convert(unicoding[0], codepage1, src, srcbytes, unicoding[1], codepage2, dest);
}

/**
 * @brief Convert from one text encoding to another; return false if any lossing conversions
 */
bool convert(UNICODESET unicoding1, int codepage1, const unsigned char * src, size_t srcbytes, UNICODESET unicoding2, int codepage2, buffer * dest)
{
	if (unicoding1 == unicoding2 && (unicoding1 || EqualCodepages(codepage1, codepage2)))
	{
		// simple byte copy
		dest->resize(srcbytes + 2);
		CopyMemory(dest->ptr, src, srcbytes);
		dest->ptr[srcbytes] = 0;
		dest->ptr[srcbytes+1] = 0;
		dest->size = srcbytes;
		return true;
	}
	if ((unicoding1 == UCS2LE && unicoding2 == UCS2BE)
			|| (unicoding1 == UCS2BE && unicoding2 == UCS2LE))
	{
		// simple byte swap
		dest->resize(srcbytes + 2);
		for (size_t i = 0; i < srcbytes; i += 2)
		{
			// Byte-swap into destination
			uint16_t c = *(const uint16_t*)(src + i);
			*(uint16_t*)(dest->ptr + i) = ((c << 8) | (c >> 8));
		}
		dest->ptr[srcbytes] = 0;
		dest->ptr[srcbytes+1] = 0;
		dest->size = srcbytes;
		return true;
	}
	if (unicoding1 != UCS2LE && unicoding2 != UCS2LE)
	{
		// Break problem into two simpler pieces by converting through UCS-2LE
		buffer intermed(dest->capacity + 2);
		bool step1 = convert(unicoding1, codepage1, src, srcbytes, UCS2LE, 0, &intermed);
		bool step2 = convert(UCS2LE, 0, intermed.ptr, intermed.size, unicoding2, codepage2, dest);
		return step1 && step2;
	}
	if (unicoding1 == UCS2LE)
	{
		// From UCS-2LE to 8-bit (or UTF-8)

		// WideCharToMultiByte: lpDefaultChar & lpUsedDefaultChar must be `nullptr` when using UTF-8

		int destcp = (unicoding2 == UTF8 ? CP_UTF8 : codepage2);
		if (destcp == CP_ACP || IsValidCodePage(destcp))
		{
			DWORD flags = 0;
			int bytes = WideCharToMultiByte(destcp, flags, (LPCWSTR)src, static_cast<int>(srcbytes/2), 0, 0, nullptr, nullptr);
			dest->resize(bytes + 2);
			int losses = 0;
			bytes = WideCharToMultiByte(destcp, flags, (LPCWSTR)src, static_cast<int>(srcbytes/2), (char *)dest->ptr, static_cast<int>(dest->capacity), nullptr, nullptr);
			dest->ptr[bytes] = 0;
			dest->ptr[bytes+1] = 0;
			dest->size = bytes;
			return losses==0;
		}
		else
		{
			size_t srcsize = srcbytes / 2;
			size_t dstsize = srcbytes * 6; 
			dest->resize(dstsize + 2);
			IExconverter *pexconv = Exconverter::getInstance();
			if (pexconv != nullptr)
			{
				bool result = pexconv->convertFromUnicode(destcp, (LPWSTR)src, &srcsize, (char *)dest->ptr, &dstsize);
				dest->ptr[dstsize] = 0;
				dest->ptr[dstsize+1] = 0;
				dest->size = dstsize;
				return result;
			}
			else
				return false;
		}
	}
	else
	{
		// From 8-bit (or UTF-8) to UCS-2LE
		int srccp = (unicoding1 == UTF8 ? CP_UTF8 : codepage1);
		if (srccp == CP_ACP || IsValidCodePage(srccp))
		{
			DWORD flags = 0;
			int wchars = MultiByteToWideChar(srccp, flags, (LPCSTR)src, static_cast<int>(srcbytes), 0, 0);
			dest->resize((wchars + 1) *2);
			wchars = MultiByteToWideChar(srccp, flags, (LPCSTR)src, static_cast<int>(srcbytes), (LPWSTR)dest->ptr, static_cast<int>(dest->capacity/2));
			dest->ptr[wchars * 2] = 0;
			dest->ptr[wchars * 2 + 1] = 0;
			dest->size = wchars * 2;
			return true;
		}
		else
		{
			size_t srcsize = srcbytes;
			size_t dstsize = srcbytes; 
			dest->resize((srcbytes + 1) * sizeof(wchar_t));
			IExconverter *pexconv = Exconverter::getInstance();
			if (pexconv != nullptr)
			{
				bool result = pexconv->convertToUnicode(srccp, (LPCSTR)src, &srcsize, (LPWSTR)dest->ptr, &dstsize);
				dest->ptr[dstsize * sizeof(wchar_t)] = 0;
				dest->ptr[dstsize * sizeof(wchar_t) + 1] = 0;
				dest->size = dstsize * sizeof(wchar_t);
				return result;
			}
			else
				return false;
		}
	}
}

/**
 * @brief Convert from Unicode to Ansi using given codepage.
 * @param [in] from String to convert.
 * @param [in] codepage Codepage to use in conversion.
 * @param [out] to Ansi string.
 */
static void convert(const std::wstring& from, unsigned codepage, std::string& to)
{
	int len = WideCharToMultiByte(codepage, 0, from.c_str(), static_cast<int>(from.length()), 0, 0, 0, 0);
	if (len)
	{
		to.resize(len);
		WideCharToMultiByte(codepage, 0, from.c_str(), static_cast<int>(from.length()), &to[0], static_cast<int>(len), nullptr, nullptr);
	}
	else
	{
		to.clear();
	}
}

/**
 * @brief Convert from Unicode to Ansi using system codepage.
 * This function converts Unicode string to ansi string using system codepage.
 * This conversion function should be used when converting strings containing
 * paths. As paths are handled by the system and are not file content.
 * @param [in] str String to convert.
 * @return Ansi string.
 */
std::string toSystemCP(const std::string& str)
{
	return str;
}

std::string toSystemCP(const std::wstring& str)
{
	std::string to;
	convert(str, CP_ACP, to);
	return to;
}

/**
 * @brief Convert from Unicode to Ansi using thread codepage.
 * This function converts Unicode string to ansi string using thread codepage.
 * Thread codepage is practically the codepage WinMerge is using internally.
 * @param [in] str String to convert.
 * @return Ansi string.
 */
std::string toThreadCP(const std::string& str)
{
	return str;
}

std::string toThreadCP(const std::wstring& str)
{
	std::string to;
	convert(str, CP_THREAD_ACP, to);
	return to;
}

// Algorithm originally from:
// TortoiseMerge - a Diff/Patch program
// Copyright (C) 2007 - TortoiseSVN
/**
 * @brief Check for invalid UTF-8 bytes in buffer.
 * This function checks if there are invalid UTF-8 bytes in the given buffer.
 * If such bytes are found, caller knows this buffer is not valid UTF-8 file.
 * @param [in] pBuffer Pointer to begin of the buffer.
 * @param [in] size Size of the buffer in bytes.
 * @return true if invalid bytes found, false otherwise.
 */
bool CheckForInvalidUtf8(const char* pBuffer, size_t size)
{
	bool bUTF8 = false;
	for (unsigned char* pb = (unsigned char*)pBuffer, *end = pb + size; pb < end;)
	{
		unsigned c = *pb++;
		
		if (!(c & 0x80)) continue;
		
		if ((c >= 0xF5) || (c == 0xC0) || (c == 0xC1))
			return true;

		uint32_t v = 0x80808000; //1st 0-byte covers scenario if no any next "if" fired at all

		if ((c & 0xE0) == 0xC0)
		{
			if (pb == end)
				return true;
			*reinterpret_cast<unsigned char*>(&v) = *pb++;
		}
		else if ((c & 0xF0) == 0xE0)
		{
			if (pb > end - 2)
				return true;
			*reinterpret_cast<uint16_t*>(&v) = *reinterpret_cast<uint16_t*>(pb);
			pb += 2;
		}
		else if ((c & 0xF8) == 0xF0)
		{
			if (pb > end - 3)
				return true;
			static_assert(sizeof(char) == sizeof(uint8_t), "unexpected char-size");

			*reinterpret_cast<uint16_t*>(&v) = *reinterpret_cast<uint16_t*>(pb);
			reinterpret_cast<uint8_t*>(&v)[2] = pb[2];
			pb += 3;
		}

		if ((v & (0xC0C0C0C0)) != 0x80808080)
			return true;
		bUTF8 = true;
	}
	return !bUTF8;
}

/**
 * @brief Determine encoding from byte buffer.
 * @param [in] pBuffer Pointer to the begin of the buffer.
 * @param [in] size Size of the buffer.
 * @param [out] pBom Returns true if buffer had BOM bytes, false otherwise.
 * @return One of UNICODESET values as encoding.
 * EF BB BF UTF-8
 * FF FE UTF-16, little endian
 * FE FF UTF-16, big endian
 * FF FE 00 00 UTF-32, little endian
 * 00 00 FE FF UTF-32, big-endian
 */
UNICODESET DetermineEncoding(const unsigned char *pBuffer, uint64_t size, bool * pBom)
{
	UNICODESET unicoding = NONE;
	*pBom = false;

	if (size >= 2)
	{
		if (pBuffer[0] == 0xFF && pBuffer[1] == 0xFE)
		{
			unicoding = UCS2LE; //UNI little endian
			*pBom = true;
		}
		else if (pBuffer[0] == 0xFE && pBuffer[1] == 0xFF)
		{
			unicoding = UCS2BE; //UNI big endian
			*pBom = true;
		}
	}
	if (size >= 3)
	{
		if (pBuffer[0] == 0xEF && pBuffer[1] == 0xBB && pBuffer[2] == 0xBF)
		{
			unicoding = UTF8;
			*pBom = true;
		}
	}
	if (size >= 4)
	{
		if (pBuffer[0] == 0xFF && pBuffer[1] == 0xFE &&
				pBuffer[2] == 0x00 && pBuffer[3] == 0x00)
		{
			unicoding = UCS4LE; //UTF-32, little endian
			*pBom = true;
		}
		else if (pBuffer[0] == 0x00 && pBuffer[1] == 0x00 &&
				pBuffer[2] == 0xFE && pBuffer[3] == 0xFF)
		{
			unicoding = UCS4BE; //UTF-32, big endian
			*pBom = true;
		}
	}

	return unicoding;
}

/**
 * @brief Change any special codepage constants into real codepage numbers
 */
static int NormalizeCodepage(int cp)
{
	if (cp == CP_THREAD_ACP) // should only happen on Win2000+
	{
		tchar_t buff[32];
		if (GetLocaleInfo(GetThreadLocale(), LOCALE_IDEFAULTANSICODEPAGE, buff, sizeof(buff) / sizeof(buff[0])))
			cp = tc::ttol(buff);
		else
			// a valid codepage is better than no codepage
			cp = GetACP();
	}
	if (cp == CP_ACP) cp = GetACP();
	if (cp == CP_OEMCP) cp = GetOEMCP();
	return cp;
}

/**
 * @brief Compare two codepages for equality
 */
bool EqualCodepages(int cp1, int cp2)
{
	return (cp1 == cp2)
			|| (NormalizeCodepage(cp1) == NormalizeCodepage(cp2));
}

int getDefaultCodepage()
{
	return f_nDefaultCodepage;
}

void setDefaultCodepage(int cp)
{
	f_nDefaultCodepage = cp;
}

} // namespace ucr

</file>

<file path="Winmerge-Src/Src/Common/unicoder.h">
/**
 *  @file   unicoder.h
 *  @author Perry Rapp, Creator, 2003-2004
 *  @date   Created: 2003-10
 *  @date   Edited:  2006-02-20 (Perry Rapp)
 *
 *  @brief  Declaration of utility unicode conversion routines
 */
#pragma once

#include "UnicodeString.h"

namespace ucr
{

/**
 * @brief A simple buffer struct.
 */
struct buffer
{
	unsigned char * ptr; /**< Pointer to a buffer. */
	size_t capacity; /**< Buffer's size in bytes. */
	size_t size; /**< Size of the data in the buffer, <= capacity. */

	explicit buffer(size_t initialSize);
	~buffer();
	void resize(size_t newSize);
};

enum
{
	CP_UTF_8  = 65001,
	CP_UCS2LE = 1200,
	CP_UCS2BE = 1201,
#ifdef _UNICODE
	CP_TCHAR = CP_UCS2LE
#else
	CP_TCHAR = 0
#endif
};

/** @brief Known Unicode encodings. */
enum UNICODESET : char
{
	NONE = 0,  /**< No unicode. */
	UCS2LE,    /**< UCS-2 / UTF-16 little endian. */
	UCS2BE,    /**< UCS-2 / UTF-16 big endian. */
	UTF8,      /**< UTF-8. */
	UCS4LE,    /**< UTF-32 little endian */
	UCS4BE,    /**< UTF-32 big-endian */
};

int Ucs4_to_Utf8(unsigned unich, unsigned char * utf8);
int Utf8len_fromLeadByte(unsigned char ch);
int Utf8len_fromCodepoint(unsigned ch);
/**
 * @brief How many bytes will it take to write string as UTF-8 ?
 *
 * @param size size argument as filemapping are not 0 terminated
 *
 * @bug Fails for files larger than 2gigs
 */
template <typename C>
size_t Utf8len_of_string(const C* text, size_t size)
{
	size_t len = 0;
	for (size_t i = 0; i < size; ++i)
	{
		int chlen = Utf8len_fromCodepoint(text[i]);
		if (chlen < 1) chlen = 1;
		len += chlen;
	}
	return len;
}
size_t stringlen_of_utf8(const char* text, size_t size);
unsigned GetUtf8Char(unsigned char * str);
int to_utf8_advance(unsigned u, unsigned char * &lpd);
void maketchar(String & ch, unsigned unich, bool & lossy);
int writeBom(void* dest, UNICODESET unicoding);
int getBomSize(UNICODESET unicoding);
unsigned get_unicode_char(unsigned char * ptr, UNICODESET unicoding, int codepage=0);
bool maketstring(String & line, const char* lpd, size_t len, int codepage, bool * lossy);
void maketchar(String & ch, unsigned unich, bool & lossy, unsigned codepage);
unsigned byteToUnicode(unsigned char ch);
unsigned byteToUnicode(unsigned char ch, unsigned codepage);
void getInternalEncoding(UNICODESET * unicoding, int * codepage);

// generic function to do all conversions
bool convert(UNICODESET unicoding1, int codepage1, const unsigned char * src, size_t srcbytes, UNICODESET unicoding2, int codepage2, buffer * dest);
bool convert(int codepage1, const unsigned char * src, int srcbytes, int codepage2, buffer * dest);

unsigned char *convertTtoUTF8(buffer * dest, const tchar_t *src, int srcbytes = -1);
unsigned char *convertTtoUTF8(const tchar_t *src, int srcbytes = -1);
tchar_t *convertUTF8toT(buffer * dest, const char* src, int srcbytes = -1);
tchar_t *convertUTF8toT(const char* src, int srcbytes = -1);
void dealloc(void *ptr);

String toTString(const std::wstring& str);
String toTString(const std::string& str);
String toTStringFromACP(const std::string& str);
void toUTF16(const String& tstr, std::wstring& wstr);
inline std::wstring toUTF16(const String& tstr)
{
#ifdef UNICODE
	return tstr;
#else
	std::wstring wstr;
	toUTF16(tstr, wstr);
	return wstr;
#endif
}

void toUTF8(const String& tstr, std::string& u8str);
std::string toUTF8(const String& tstr);
std::string toSystemCP(const std::string& str);
std::string toSystemCP(const std::wstring& str);
std::string toThreadCP(const std::string& str);
std::string toThreadCP(const std::wstring& str);

int CrossConvert(const char* src, unsigned srclen, char* dest, unsigned destsize, int cpin, int cpout, bool * lossy);
#ifndef UNICODE
String CrossConvertToStringA(const char* src, unsigned srclen, int cpin, int cpout, bool * lossy);
#endif

bool CheckForInvalidUtf8(const char *pBuffer, size_t size);

UNICODESET DetermineEncoding(const unsigned char *pBuffer, uint64_t size, bool * pBom);

int getDefaultCodepage();
void setDefaultCodepage(int cp);

bool EqualCodepages(int cp1, int cp2);

} // namespace ucr
</file>

<file path="Winmerge-Src/Src/Common/UnicodeString.cpp">
// SPDX-License-Identifier: GPL-2.0-or-later
/** 
 * @file  UnicodeString.cpp
 *
 * @brief String utilities.
 */

// String formatting code originally from Paul Senzee:
// http://www.senzee5.com/2006/05/c-formatting-stdstring.html

#include "pch.h"
#include "UnicodeString.h"
#include <cstdarg>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cerrno>
#include <vector>

namespace strutils
{

/**
 * @brief Convert a string to lower case string.
 * @param [in] str String to convert to lower case.
 * @return Lower case string.
 */
String makelower(const String &str)
{
	String ret(str);
	String::size_type i = 0;
	for (i = 0; i < ret.length(); i++)
		ret[i] = tc::totlower(ret[i]);
	return ret;
}

/**
 * @brief Convert a string to upper case string.
 * @param [in] str String to convert to upper case.
 * @return upper case string.
 */
String makeupper(const String &str)
{
	String ret(str);
	String::size_type i = 0;
	for (i = 0; i < ret.length(); i++)
		ret[i] = tc::totupper(ret[i]);
	return ret;
}

String strip_hot_key(const String& str)
{
	String str2 = str;
	auto it = str2.find(_T("(&"));
	if (it != String::npos)
		str2.erase(it, it + 2);
	strutils::replace(str2, _T("&"), _T(""));
	return str2;
}

tchar_t from_charstr(const String& str)
{
	tchar_t ch = 0;
	String str2 = strutils::makelower(str);
	strutils::replace(str2, _T("-"), _T(""));
	if (str2 == _T("\\a") || str2 == _T("bel"))
		ch = '\a';
	else if (str2 == _T("\\b") || str2 == _T("bs"))
		ch = '\b';
	else if (str2 == _T("\\f") || str2 == _T("ff"))
		ch = '\f';
	else if (str2 == _T("\\n") || str2 == _T("lf"))
		ch = '\n';
	else if (str2 == _T("\\r") || str2 == _T("cr"))
		ch = '\r';
	else if (str2 == _T("\\t") || str2 == _T("tab"))
		ch = '\t';
	else if (str2 == _T("\\v") || str2 == _T("vt"))
		ch = '\v';
	else if (str2 == _T("\\'") || str2 == _T("sq") || str2 == _T("singlequote"))
		ch = '\'';
	else if (str2 == _T("\\\"") || str2 == _T("dq") || str2 == _T("doublequote"))
		ch = '"';
	else if (str2.find(_T("\\x"), 0) == 0 || str2.find(_T("0x"), 0) == 0)
	{
		tchar_t *pend = nullptr;
		ch = static_cast<tchar_t>(tc::tcstol(str2.substr(2).c_str(), &pend, 16));
	}
	else
		ch = str.c_str()[0];
	return ch;
}

String to_charstr(tchar_t ch)
{
	if (iscntrl(ch))
		return strutils::format(_T("\\x%02x"), ch);
	return String(1, ch);
}

String to_regex(const String& text)
{
	String ret;
	for (auto ch : text)
	{
		switch (ch)
		{
		case '\\': ret += _T("\\\\"); break;
		case '*':  ret += _T("\\*");  break;
		case '+':  ret += _T("\\+");  break;
		case '?':  ret += _T("\\?");  break;
		case '|':  ret += _T("\\|");  break;
		case '.':  ret += _T("\\.");  break;
		case '^':  ret += _T("\\^");  break;
		case '$':  ret += _T("\\$");  break;
		case '(':  ret += _T("\\(");  break;
		case ')':  ret += _T("\\)");  break;
		case '[':  ret += _T("\\[");  break;
		case ']':  ret += _T("\\]");  break;
		case '\t': ret += _T("\\t");  break;
		case '\n': ret += _T("\\n");  break;
		case '\r': ret += _T("\\r");  break;
		case '\a': ret += _T("\\a");  break;
		default:  ret += ch; break;
		}
	}
	return ret;
}

/**
 * @brief Replace a string inside a string with another string.
 * This function searches for a string inside another string an if found,
 * replaces it with another string. Function can replace several instances
 * of the string inside one string.
 * @param [in,out] target A string containing another string to replace.
 * @param [in] find A string to search and replace with another (@p replace).
 * @param [in] replace A string used to replace original (@p find).
 */
void replace(String &target, const String &find, const String &replace)
{
	const String::size_type find_len = find.length();
	const String::size_type replace_len = replace.length();
	String::size_type pos = 0;
	while ((pos = target.find(find, pos)) != String::npos)
	{
		target.replace(pos, find_len, replace);
		pos += replace_len;
	}
}

/**
 * @brief Replace the characters that matche characters specified in its arguments
 * @param [in,out] str - A string containing another string to replace.
 * @param [in] chars - characters to search for
 * @param [in] rep - String to replace
 */
void replace_chars(String& str, const tchar_t* chars, const tchar_t *rep)
{
	String::size_type pos = 0;
	size_t replen = tc::tcslen(rep);
	while ((pos = str.find_first_of(chars, pos)) != std::string::npos)
	{
		std::string::size_type posend = str.find_first_not_of(chars, pos);
		if (posend != String::npos)
			str.replace(pos, posend - pos, rep);
		else
			str.replace(pos, str.length() - pos, rep);
		pos += replen;
	}
}

/**
 * @brief Compare two strings ignoring the character casing.
 * @param [in] str1 First string to compare.
 * @param [in] str2 Second string to compare.
 * @return As strcmp(), 0 if strings match.
 */
int compare_nocase(const String &str1, const String &str2)
{
	return tc::tcsicoll(str1.c_str(), str2.c_str());
}

/**
 * @brief Compare two strings ignoring the character casing. 
 *        Digits in the strings are considered as numerical content rather than text.
 * @param [in] str1 First string to compare.
 * @param [in] str2 Second string to compare.
 * @return As strcmp(), 0 if strings match.
 */
int compare_logical(const String& str1, const String& str2)
{
	return tc::tcscmplogical(str1.c_str(), str2.c_str());
}

/**
 * @brief Trims whitespace chars from begin and end of the string.
 * @param [in] str the original string.
 * @return Trimmed string.
 */
String trim_ws(const String & str)
{
	if (str.empty())
		return str;

	String result(str);
	String::iterator it = result.begin();
	while (it != result.end() && tc::istspace(*it))
		++it;
	
	if (it != result.begin())
		result.erase(result.begin(), it);

	if (result.empty())
		return result;

	it = result.end() - 1;
	while (it != result.begin() && tc::istspace(*it))
		--it;

	if (it != result.end() - 1)
		result.erase(it + 1, result.end());
	return result;
}

/**
 * @brief Trims whitespace chars from begin of the string.
 * @param [in] str the original string.
 * @return Trimmed string.
 */
String trim_ws_begin(const String & str)
{
	if (str.empty())
		return str;

	String result(str);
	String::iterator it = result.begin();
	while (it != result.end() && tc::istspace(*it))
		++it;
	
	if (it != result.begin())
		result.erase(result.begin(), it);
	return result;
}

/**
 * @brief Trims whitespace chars from end of the string.
 * @param [in] str the original string.
 * @return Trimmed string.
 */
String trim_ws_end(const String & str)
{
	if (str.empty())
		return str;

	String result(str);
	String::reverse_iterator it = result.rbegin();
	while (it != result.rend() && tc::istspace(*it))
		++it;

	if (it != result.rbegin())
		result.erase(it.base(), result.end());
	return result;
}

String format_arg_list(const tchar_t *fmt, va_list args)
{
	if (fmt == nullptr)
		return _T("");
	int result = -1;
	int length = 256;
	std::vector<tchar_t> buffer(length, 0);
	while (result == -1)
	{
		result = tc::vsntprintf_s(&buffer[0], length, _TRUNCATE, fmt, args);
		length *= 2;
		buffer.resize(length, 0);
	}
	String s(&buffer[0]);
	return s;
}

/**
 * @brief printf()-style formatting for STL string.
 * Use this function to format String:s in printf() style.
 */
String format_varg(const tchar_t *fmt, ...)
{
	va_list args;
	va_start(args, fmt);
	String s = format_arg_list(fmt, args);
	va_end(args);
	return s;
}

String format_strings(const String& fmt, const String *args[], size_t nargs)
{
	String str;
	str.reserve(fmt.length() * 2);
	String::const_iterator it;
	for (it = fmt.begin(); it != fmt.end(); ++it)
	{
		if (*it == '%')
		{
			++it;
			if (it == fmt.end())
				break;
			int n = *it - '0';
			if (n > 0 && static_cast<unsigned int>(n) <= nargs)
				str += *args[n - 1];
			else
				str += *it;
		}
		else
		{
			str += *it;
		}
	}
	return str;
}

String format_string1(const String& fmt, const String& arg1)
{
	const String* args[] = {&arg1};
	return format_strings(fmt, args, 1);
}

String format_string2(const String& fmt, const String& arg1, const String& arg2)
{
	const String* args[] = {&arg1, &arg2};
	return format_strings(fmt, args, 2);
}

/**
 * @brief Output the converted string according to the printf()-style formatting.
 * @param [in] fmt printf()-style formatting.
 * @param [in] arg1 Value of "%1" of fmt.
 * @param [in] arg2 Value of "%2" of fmt.
 * @param [in] arg3 Value of "%3" of fmt.
 * @return Formatted output string.
 */
String format_string3(const String& fmt, const String& arg1, const String& arg2, const String& arg3)
{
	const String* args[] = { &arg1, &arg2, &arg3 };
	return format_strings(fmt, args, 3);
}

}
</file>

<file path="Winmerge-Src/Src/Common/UnicodeString.h">
// SPDX-License-Identifier: GPL-2.0-or-later
/** 
 * @file UnicodeString.h
 *
 * @brief Unicode string based on std::wstring.
 *
 */
#pragma once

#include <string>
#include <string_view>
#include "../Externals/crystaledit/editlib/utils/ctchar.h"

using namespace std::string_literals;

typedef std::basic_string<tchar_t> String;
typedef std::basic_string_view<tchar_t> StringView;

namespace strutils
{
String makelower(const String &str);
String makeupper(const String &str);

String strip_hot_key(const String& str);

tchar_t from_charstr(const String& str);
String to_charstr(tchar_t ch);
String to_regex(const String& text);

void replace(String &target, const String &find, const String &replace);
void replace_chars(String& str, const tchar_t* chars, const tchar_t* rep);

// Comparing
int compare_nocase(const String &str1, const String &str2);
int compare_logical(const String& str1, const String& str2);

// Trimming
String trim_ws(const String & str);
String trim_ws_begin(const String & str);
String trim_ws_end(const String & str);

// Formatting
String format_arg_list(const tchar_t *fmt, va_list args);
String format_varg(const tchar_t *fmt, ...);
namespace detail
{
	template <typename T> inline T arg(T value) { return value; }
	template <typename T> inline T const * arg(std::basic_string<T> const & value) { return value.c_str(); }
}
template <typename ... Args>
inline String format(tchar_t const * const fmt, Args const & ... args)
{
	return format_varg(fmt, detail::arg(args) ...);
}
template <typename ... Args>
inline String format(String const & fmt, Args const & ... args)
{
	return format_varg(fmt.c_str(), detail::arg(args) ...);
}
String format_strings(const String& fmt, const String *args[], size_t nargs);
String format_string1(const String& fmt, const String& arg1);
String format_string2(const String& fmt, const String& arg1, const String& arg2);
String format_string3(const String& fmt, const String& arg1, const String& arg2, const String& arg3);

template <class InputIterator>
String join(const InputIterator& begin, const InputIterator& end, const String& delim)
{
	size_t sum = 0, delim_len = delim.length();
	for (InputIterator it = begin; it != end; ++it)
	{
		if (sum != 0) sum += delim_len;
		sum += (*it).length();
	}
	String result;
	result.reserve(sum);
	for (InputIterator it = begin; it != end; ++it)
	{
		if (it != begin) result.append(delim);
		result += *it;
	}
	return result;
}

template <class Formatter, class InputIterator>
String join(const InputIterator& begin, const InputIterator& end, const String& delim, Formatter func)
{
	String result;
	for (InputIterator it = begin; it != end; ++it)
	{
		if (it != begin) result.append(delim);
		result += func(*it);
	}
	return result;
}

template<class T = std::vector<StringView>>
T split(StringView str, tchar_t delim)
{
	T result;
	size_t start = 0;
	for (size_t i = 0; i < str.size(); i++)
	{
		if (str[i] == delim)
		{
			result.emplace_back(str.data() + start, i - start);
			start = i + 1;
		}
	}
	result.emplace_back(str.data() + start, str.size() - start);
	return result;
}


inline String to_str(int val) { return strutils::format(_T("%d"), val); }
inline String to_str(unsigned val) { return strutils::format(_T("%u"), val); }
inline String to_str(long val) { return strutils::format(_T("%ld"), val); }
inline String to_str(unsigned long val) { return strutils::format(_T("%lu"), val); }
inline String to_str(long long val) { return strutils::format(_T("%I64d"), val); }
inline String to_str(unsigned long long val) { return strutils::format(_T("%I64u"), val); }
inline String to_str(float val) { return strutils::format(_T("%f"), val); }
inline String to_str(double val) { return strutils::format(_T("%f"), val); }
inline String to_str(const StringView& val) { return { val.data(), val.size() }; }

}
</file>

<file path="Winmerge-Src/Src/Common/UniFile.cpp">
/**
 *  @file   UniFile.cpp
 *  @author Perry Rapp, Creator, 2003-2006
 *  @author Kimmo Varis, 2004-2006
 *  @date   Created: 2003-10
 *  @date   Edited:  2006-12-07 (Kimmo Varis)
 *
 *  @brief Implementation of Unicode enabled file classes.
 *  Classes include memory-mapped reader class and Stdio replacement class.
 */

/* The MIT License
Copyright (c) 2003 Perry Rapp
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

#include "pch.h"
#include "UniFile.h"
#include <cstdio>
#include <cassert>
#include <memory>
#include <Poco/SharedMemory.h>
#include <Poco/Exception.h>
#include "UnicodeString.h"
#include "unicoder.h"
#include "paths.h" // paths::GetLongbPath()
#include "TFile.h"
#include "cio.h"
#include <windows.h>

using Poco::SharedMemory;
using Poco::Exception;

static void Append(String &strBuffer, const tchar_t *pchTail, size_t cchTail,
		size_t cchBufferMin = 1024);

/**
 * @brief The constructor.
 */
UniFile::UniError::UniError()
{
	ClearError();
}

/////////////
// UniLocalFile
/////////////

/** @brief Create disconnected UniLocalFile, but with name */
UniLocalFile::UniLocalFile()
{
	Clear();
}

/** @brief Reset all variables to empty */
void UniLocalFile::Clear()
{
	m_statusFetched = 0;
	m_lineno = -1;
	m_filesize = 0;
	m_filepath.clear();
	m_filename.clear();
	m_charsize = 1;
	m_codepage = ucr::getDefaultCodepage();
	m_txtstats.clear();
	m_unicoding = ucr::NONE;
	m_bom = false;
	m_bUnicodingChecked = false;
	m_bUnicode = false;
}

/**
 * @brief Get file status into member variables
 *
 * Reads file's status (size and full path).
 * @return true on success, false on failure.
 * @note Function sets filesize member to zero, and status as read
 * also when failing. That is needed so caller doesn't need to waste
 * time checking if file already exists (and ignores return value).
 */
bool UniLocalFile::DoGetFileStatus()
{
	m_statusFetched = -1;
	m_lastError.ClearError();

	m_filepath = paths::GetLongPath(m_filepath);

	try
	{
		m_filesize = TFile(m_filepath).getSize();
		if (m_filesize == 0)
		{
			// if m_filesize equals zero, the file size is really zero or the file is a symbolic link.
			// use GetCompressedFileSize() to get the file size of the symbolic link target whether the file is symbolic link or not.
			// if the file is not symbolic link, GetCompressedFileSize() will return zero.
			// NOTE: GetCompressedFileSize() returns error for pre-W2K windows versions
			DWORD dwFileSizeLow, dwFileSizeHigh;
			
			dwFileSizeLow = GetCompressedFileSize(TFile(m_filepath).wpath().c_str(), &dwFileSizeHigh);
			if (GetLastError() == 0)
				m_filesize = ((int64_t)dwFileSizeHigh << 32) + dwFileSizeLow;
		}
		m_statusFetched = 1;

		return true;
	}
	catch (Exception& e)
	{
		m_filesize = 0;
		m_statusFetched = 1; // Yep, done for this file still
		LastErrorCustom(ucr::toTString(e.displayText()));
		return false;
	}
}

/**
 * @brief Checks if the file is an unicode file.
 * This function Checks if the file is recognized unicode file. This detection
 * includes reading possible BOM bytes and trying to detect UTF-8 files
 * without BOM bytes.
 * @return true if file is an unicode file, false otherwise.
 */
bool UniLocalFile::IsUnicode()
{
	if (!m_bUnicodingChecked)
		m_bUnicode = ReadBom();
	return m_bUnicode;
}

/** @brief Record a custom error */
void UniLocalFile::LastErrorCustom(const String& desc)
{
	m_lastError.ClearError();

	m_lastError.desc = desc;
}

/////////////
// UniMemFile
/////////////

UniMemFile::UniMemFile()
		: m_hMapping(nullptr)
		, m_base(nullptr)
		, m_data(nullptr)
		, m_current(nullptr)
{
}

void UniMemFile::Close()
{
	Clear();
	m_base = nullptr;
	m_data = nullptr;
	m_current = nullptr;
	if (m_hMapping != nullptr)
	{
		delete m_hMapping;
		m_hMapping = nullptr;
	}
}

/** @brief Get file status into member variables */
bool UniMemFile::GetFileStatus()
{
	if (!IsOpen()) return false;
	return DoGetFileStatus();
}

/** @brief Open file for generic read-only access */
bool UniMemFile::OpenReadOnly(const String& filename)
{
	return Open(filename, AM_READ);
}

/** @brief Open file for generic read-write access */
bool UniMemFile::Open(const String& filename)
{
	return Open(filename, AM_WRITE);
}

/** @brief Open file with specified arguments */
bool UniMemFile::Open(const String& filename, AccessMode mode)
{
	// We use an internal workhorse to make it easy to close on any error
	if (!DoOpen(filename, mode))
	{
		Close();
		return false;
	}
	return true;
}

/** @brief Internal implementation of Open */
bool UniMemFile::DoOpen(const String& filename, AccessMode mode)
{
	Close();

	m_filename = filename;
	m_filepath = m_filename; // TODO: Make canonical ?

	try
	{
		TFile file(filename);
		try
		{
			m_hMapping = new SharedMemory(file, static_cast<SharedMemory::AccessMode>(mode));
		}
		catch (Exception&)
		{
			if (file.getSize() == 0)
			{
				m_lineno = 0;
				return true;
			}
			throw;
		}
	}
	catch (Exception& e)
	{
		LastErrorCustom(ucr::toTString(e.displayText()));
		m_hMapping = nullptr;
		return false;
	}

	m_lineno = 0; // GetFileStatus requires file be "open", which means nonnegative line number
	if (!GetFileStatus())
		return false;
	m_lineno = -1;

#ifndef _WIN64
	unsigned sizehi = (unsigned)(m_filesize >> 32);
	unsigned sizelo = (unsigned)(m_filesize & 0xFFFFFFFF);

	if (sizehi || sizelo > 0x7FFFFFFF)
	{
		LastErrorCustom(_T("UniMemFile cannot handle files over 2 gigabytes"));
		return false;
	}
#endif

	if (m_filesize == 0)
	{
		// Allow opening empty file, but memory mapping doesn't work on such
		// m_base and m_current are 0 from the Close call above
		// so ReadString will correctly return empty EOF immediately
		m_lineno = 0;
		return true;
	}

	m_base = reinterpret_cast<unsigned char *>(m_hMapping->begin());
	m_data = m_base;
	m_current = m_base;
	m_lineno = 0;

	return true;
}

/**
 * @brief Check for Unicode BOM (byte order mark) at start of file
 *
 * @note This code only checks for UCS-2LE, UCS-2BE, and UTF-8 BOMs (no UCS-4).
 */
bool UniMemFile::ReadBom()
{
	if (!IsOpen())
		return false;

	unsigned char * lpByte = m_base;
	m_charsize = 1;
	bool unicode = true;
	bool bom = false;

	m_unicoding = ucr::DetermineEncoding(lpByte, m_filesize, &bom);
	switch (m_unicoding)
	{
	case ucr::UCS2LE:
		m_codepage = ucr::CP_UCS2LE;
		m_charsize = 2;
		m_data = lpByte + 2;
		break;
	case ucr::UCS2BE:
		m_codepage = ucr::CP_UCS2BE;
		m_charsize = 2;
		m_data = lpByte + 2;
		break;
	case ucr::UTF8:
		m_codepage = ucr::CP_UTF_8;
		m_data = lpByte + (bom ? 3 : 0);
		break;
	default:
		m_data = m_base;
		unicode = false;
		break;
	}

	m_bom = bom;
	m_current = m_data;
	m_bUnicodingChecked = true;
	return unicode;
}

/**
 * @brief Read one (DOS or UNIX or Mac) line. Do not include eol chars.
 * @param [out] line Line read.
 * @param [out] lossy `true` if there were lossy encoding.
 * @return `true` if there is more lines to read, `false` when last line is read.
 */
bool UniMemFile::ReadString(String & line, bool * lossy)
{
	String eol;
	return ReadString(line, eol, lossy);
}

bool UniMemFile::ReadStringAll(String& text)
{
	text.clear();
	text.reserve(static_cast<size_t>(m_filesize));

	String tmp, eol;
	bool lossy = false, lossytmp = false, last;
	do
	{
		last = ReadString(tmp, eol, &lossytmp);
		text += tmp;
		text += eol;
		if (lossytmp)
			lossy = true;
	} while (last);
	return lossy;
}

/**
 * @brief Append characters to string.
 * This function appends characters to the string. The storage for the string
 * is grown exponentially to avoid unnecessary allocations and copying.
 * @param [in, out] strBuffer A string to which new characters are appended.
 * @param [in] ccHead Index in the string where new chars are appended.
 * @param [in] pchTail Characters to append.
 * @param [in] cchTail Amount of characters to append.
 * @param [in] cchBufferMin Minimum size for the buffer.
 * @return New length of the string.
 */
static void Append(String &strBuffer, const tchar_t *pchTail,
		size_t cchTail, size_t cchBufferMin)
{
	size_t cchBuffer = strBuffer.capacity();
	size_t cchHead = strBuffer.length();
	size_t cchLength = cchHead + cchTail;
	while (cchBuffer < cchLength)
	{
		assert((cchBufferMin & cchBufferMin - 1) == 0); // must be a power of 2
		cchBuffer &= ~(cchBufferMin - 1); // truncate to a multiple of cchBufferMin
		cchBuffer += cchBuffer;
		if (cchBuffer < cchBufferMin)
			cchBuffer = cchBufferMin;
	}
	strBuffer.reserve(cchBuffer);
	strBuffer.append(pchTail, cchTail);
}

/**
 * @brief Record occurrence of binary zero to stats
 */
static void RecordZero(UniFile::txtstats & txstats, size_t offset)
{
	++txstats.nzeros;
}

/**
 * @brief Read one (DOS or UNIX or Mac) line.
 * @param [out] line Line read.
 * @param [out] eol EOL bytes read (if any).
 * @param [out] lossy `true` if there were lossy encoding.
 * @return true if there is more lines to read, false when last line is read.
 */
bool UniMemFile::ReadString(String & line, String & eol, bool * lossy)
{
	line.clear();
	eol.clear();
	const tchar_t * pchLine = (const tchar_t *)m_current;
	
	// shortcut methods in case file is in the same encoding as our Strings

#ifdef _UNICODE
	if (m_unicoding == ucr::UCS2LE)
	{
		int cchLine = 0;
		// If there aren't any wchars left in the file, return `false` to indicate EOF
		if (m_current - m_base + 1 >= m_filesize)
			return false;
		// Loop through wchars, watching for eol chars or zero
		while (m_current - m_base + 1 < m_filesize)
		{
			wchar_t wch = *(wchar_t *)m_current;
			size_t wch_offset = (m_current - m_base);
			m_current += 2;
			if (wch == '\n' || wch == '\r')
			{
				eol += wch;
				if (wch == '\r')
				{
					if (m_current - m_base + 1 < m_filesize && *(wchar_t *)m_current == '\n')
					{
						eol += '\n';
						m_current += 2;
						++m_txtstats.ncrlfs;
					}
					else
					{
						++m_txtstats.ncrs;
					}
				}
				else
				{
					++m_txtstats.nlfs;
				}
				++m_lineno;
				line.assign(pchLine, cchLine);
				return true;
			}
			if (!wch)
			{
				RecordZero(m_txtstats, wch_offset);
			}
			++cchLine;
		}
		line.assign(pchLine, cchLine);
		return true;
	}
#else
	if (m_unicoding == ucr::NONE && ucr::EqualCodepages(m_codepage, GetACP()))
	{
		int cchLine = 0;
		// If there aren't any bytes left in the file, return `false` to indicate EOF
		if (m_current - m_base >= m_filesize)
			return false;
		// Loop through chars, watching for eol chars or zero
		while (m_current - m_base < m_filesize)
		{
			char ch = *m_current;
			size_t ch_offset = (m_current - m_base);
			++m_current;
			if (ch == '\n' || ch == '\r')
			{
				eol += ch;
				if (ch == '\r')
				{
					if (m_current - m_base < m_filesize && *m_current == '\n')
					{
						eol += '\n';
						++m_current;
						++m_txtstats.ncrlfs;
					}
					else
					{
						++m_txtstats.ncrs;
					}
				}
				else
				{
					++m_txtstats.nlfs;
				}
				++m_lineno;
				line.assign(pchLine, cchLine);
				return true;
			}
			if (!ch)
			{
				RecordZero(m_txtstats, ch_offset);
			}
			++cchLine;
		}
		line.assign(pchLine, cchLine);
		return true;
	}
#endif

	if (m_current - m_base + (m_charsize - 1) >= m_filesize)
		return false;

	// Handle 8-bit strings in line chunks because of multibyte codings (eg, 936)
	if (m_unicoding == ucr::NONE)
	{
		bool eof = true;
		unsigned char *eolptr = nullptr;
		for (eolptr = m_current; (eolptr - m_base + (m_charsize - 1) < m_filesize); ++eolptr)
		{
			if (*eolptr == '\n' || *eolptr == '\r')
			{
				eof = false;
				break;
			}
			
			if (*eolptr == '\x00')
			{
				size_t offset = (eolptr - m_base);
				RecordZero(m_txtstats, offset);
			}
		}
		bool success = ucr::maketstring(line, (const char *)m_current, eolptr-m_current, m_codepage, lossy);
		if (!success)
		{
			return false;
		}
		if (lossy && *lossy)
			++m_txtstats.nlosses;
		if (!eof)
		{
			eol += (tchar_t) * eolptr;
			++m_lineno;
			if (*eolptr == '\r')
			{
				if (eolptr - m_base + m_charsize + (m_charsize - 1) < m_filesize && eolptr[1] == '\n')
				{
					eol += '\n';
					++m_txtstats.ncrlfs;
				}
				else
					++m_txtstats.ncrs;
			}
			else
				++m_txtstats.nlfs;
		}
		m_current = eolptr + eol.length();
		// TODO: What do we do if save was lossy ?
		return !eof;
	}

	while (m_current - m_base + (m_charsize - 1) < m_filesize)
	{
		unsigned ch = 0;
		int  utf8len = 0;
		bool doneline = false;

		if (m_unicoding == ucr::UTF8)
		{
			// check for end in middle of UTF-8 character
			utf8len = ucr::Utf8len_fromLeadByte(*m_current);
			if (m_current - m_base + utf8len > m_filesize)
			{
				ch = '?';
				m_current = m_base + m_filesize;
				doneline = true;
			}
			// Handle bad UTF-8 or UTF-8 outside of UCS-2
			// (Convert bad bytes individually to '?'
			else if (utf8len < 1 || utf8len > 4)
			{
				ch = '?';
				utf8len = 1;
			}
			else
			{
				ch = ucr::GetUtf8Char(m_current);
			}
		}
		else
		{
			ch = ucr::get_unicode_char(m_current, (ucr::UNICODESET)m_unicoding, m_codepage);
		}
		// convert from Unicode codepoint to tchar_t string
		// could be multicharacter if decomposition took place, for example
		bool lossy1 = false; // try to avoid lossy conversion
		String sch;
		ucr::maketchar(sch, ch, lossy1);
		if (lossy1)
			++m_txtstats.nlosses;
		if (sch.length() >= 1)
			ch = sch[0];
		else
			ch = 0;


		if (ch == '\r')
		{
			eol = _T("\r");
			doneline = true;
			bool crlf = false;
			// check for crlf pair
			if (m_current - m_base + 2 * m_charsize - 1 < m_filesize)
			{
				// For UTF-8, this ch1 will be wrong if character is non-ASCII
				// but we only check it against \n here, so it doesn't matter
				unsigned ch1 = ucr::get_unicode_char(m_current + m_charsize, (ucr::UNICODESET)m_unicoding);
				if (ch1 == '\n')
				{
					crlf = true;
				}
			}
			if (crlf)
			{
				eol = _T("\r\n");
				++m_txtstats.ncrlfs;
				// advance an extra character to skip the following lf
				m_current += m_charsize;
			}
			else
			{
				++m_txtstats.ncrs;
			}
		}
		else if (ch == '\n')
		{
			eol = _T("\n");
			doneline = true;
			++m_txtstats.nlfs;
		}
		else if (!ch)
		{
			size_t offset = (m_current - m_base);
			RecordZero(m_txtstats, offset);
		}
		// always advance to next character
		if (m_unicoding == ucr::UTF8)
		{
			m_current += utf8len;
		}
		else
		{
			m_current += m_charsize;
		}
		if (doneline)
		{
			if (!eol.empty())
				++m_lineno;
			return true;
		}
		Append(line, sch.c_str(), sch.length());
	}
	return true;
}

/**
 * @brief Write one line (doing any needed conversions)
 */
bool UniMemFile::WriteString(const String & line)
{
	assert(false); // unimplemented -- currently cannot write to a UniMemFile!
	return false;
}

/////////////
// UniStdioFile
/////////////

UniStdioFile::UniStdioFile()
		: m_fp(nullptr)
		, m_data(0)
		, m_ucrbuff(128)
{
}

UniStdioFile::~UniStdioFile()
{
	Close();
}

void UniStdioFile::Close()
{
	if (IsOpen())
	{
		fclose(m_fp);
		m_fp = nullptr;
	}
	m_statusFetched = 0;
	m_filesize = 0;
	// preserve m_filepath
	// preserve m_filename
	m_data = 0;
	m_lineno = -1;
	// preserve m_unicoding
	// preserve m_charsize
	// preserve m_codepage
	m_txtstats.clear();
}

/** @brief Get file status into member variables */
bool UniStdioFile::GetFileStatus()
{
	if (IsOpen()) return false; // unfortunately we'll hit our lock

	return DoGetFileStatus();
}

bool UniStdioFile::OpenReadOnly(const String& filename)
{
	return Open(filename, _T("rb"));
}
bool UniStdioFile::OpenCreate(const String& filename)
{
	return Open(filename, _T("w+b"));
}
bool UniStdioFile::OpenCreateUtf8(const String& filename)
{
	if (!OpenCreate(filename))
		return false;
	SetUnicoding(ucr::UTF8);
	return true;

}
bool UniStdioFile::Open(const String& filename, const String& mode)
{
	if (!DoOpen(filename, mode))
	{
		Close();
		return false;
	}
	return true;
}

bool UniStdioFile::DoOpen(const String& filename, const String& mode)
{
	Close();

	m_filepath = filename;
	m_filename = filename; // TODO: Make canonical ?

	// Fails if file doesn't exist (when we are creating new file)
	// But we don't care since size is set to 0 anyway.
	GetFileStatus();

	if (cio::tfopen_s(&m_fp, m_filepath, mode.c_str()) != 0)
		return false;

#ifndef _WIN64
	unsigned sizehi = (unsigned)(m_filesize >> 32);

	if (sizehi)
	{
		// TODO: We could do this in MSC_VER 7+ I think

		LastErrorCustom(_T("UniStdioFile cannot handle files over 4 gigabytes"));
		return false;
	}
#endif

	m_lineno = 0;
	return true;
}

bool UniStdioFile::SetVBuf(int mode, size_t size)
{
	if (!IsOpen())
		return false;
	return setvbuf(m_fp, NULL, mode, size) == 0;
}

/** @brief Record a custom error */
void UniStdioFile::LastErrorCustom(const String& desc)
{
	m_lastError.ClearError();

	m_lastError.desc = desc;
}

/**
 * @brief Check for Unicode BOM (byte order mark) at start of file
 *
 * @note This code only checks for UCS-2LE, UCS-2BE, and UTF-8 BOMs (no UCS-4).
 */
bool UniStdioFile::ReadBom()
{
	if (!IsOpen())
		return false;

	fseek(m_fp, 0, SEEK_SET);

	// Read 8 KB at max for get enough data determining UTF-8 without BOM.
	const size_t max_size = 8 * 1024;
	unsigned char buff[max_size];

	size_t bytes = fread(buff, 1, max_size, m_fp);
	m_charsize = 1;
	bool unicode = true;
	bool bom = false;

	m_unicoding = ucr::DetermineEncoding(buff, bytes, &bom);
	switch (m_unicoding)
	{
	case ucr::UCS2LE:
		m_codepage = ucr::CP_UCS2LE;
		m_charsize = 2;
		m_data = 2;
		break;
	case ucr::UCS2BE:
		m_codepage = ucr::CP_UCS2BE;
		m_charsize = 2;
		m_data = 2;
		break;
	case ucr::UTF8:
		m_codepage = ucr::CP_UTF_8;
		m_data = bom ? 3 : 0;
		break;
	default:
		m_data = 0;
		unicode = false;
		break;
	}

	fseek(m_fp, (long)m_data, SEEK_SET);
	m_bom = bom;
	return unicode;
}

bool UniStdioFile::ReadString(String & line, bool * lossy)
{
	assert(false); // unimplemented -- currently cannot read from a UniStdioFile!
	return false;
}

bool UniStdioFile::ReadString(String & line, String & eol, bool * lossy)
{
	assert(false); // unimplemented -- currently cannot read from a UniStdioFile!
	return false;
}

bool UniStdioFile::ReadStringAll(String & line)
{
	assert(false); // unimplemented -- currently cannot read from a UniStdioFile!
	return false;
}

/** @brief Write BOM (byte order mark) if Unicode file */
int UniStdioFile::WriteBom()
{
	if (m_unicoding == ucr::UCS2LE && m_bom)
	{
		unsigned char bom[] = "\xFF\xFE";
		fseek(m_fp, 0, SEEK_SET);
		fwrite(bom, 1, 2, m_fp);
		m_data = 2;
	}
	else if (m_unicoding == ucr::UCS2BE && m_bom)
	{
		unsigned char bom[] = "\xFE\xFF";
		fseek(m_fp, 0, SEEK_SET);
		fwrite(bom, 1, 2, m_fp);
		m_data = 2;
	}
	else if (m_unicoding == ucr::UTF8 && m_bom)
	{
		unsigned char bom[] = "\xEF\xBB\xBF";
		fseek(m_fp, 0, SEEK_SET);
		fwrite(bom, 1, 3, m_fp);
		m_data = 3;
	}
	else
	{
		m_data = 0;
	}
	return (int)m_data;
}

/**
 * @brief Write one line (doing any needed conversions)
 */
bool UniStdioFile::WriteString(const String & line)
{
	// shortcut the easy cases
#ifdef _UNICODE
	if (m_unicoding == ucr::UCS2LE)
#else
	if (m_unicoding == ucr::NONE && ucr::EqualCodepages(m_codepage, GetACP()))
#endif
	{
		size_t bytes = line.length() * sizeof(tchar_t);
		size_t wbytes = fwrite(line.c_str(), 1, bytes, m_fp);
		if (wbytes != bytes)
			return false;
		return true;
	}

	ucr::UNICODESET unicoding1 = ucr::NONE;
	int codepage1 = 0;
	ucr::getInternalEncoding(&unicoding1, &codepage1); // What String & tchar_ts represent
	const unsigned char * src = (const unsigned char *)line.c_str();
	size_t srcbytes = line.length() * sizeof(tchar_t);
	bool lossy = ucr::convert(unicoding1, codepage1, src, srcbytes, (ucr::UNICODESET)m_unicoding, m_codepage, &m_ucrbuff);
	// TODO: What to do about lossy conversion ?
	size_t wbytes = fwrite(m_ucrbuff.ptr, 1, m_ucrbuff.size, m_fp);
	if (wbytes != m_ucrbuff.size)
		return false;
	return true;
}

int64_t UniStdioFile::GetPosition() const
{
	if (!IsOpen()) return 0;
	return ftell(m_fp);
}
</file>

<file path="Winmerge-Src/Src/Common/UniFile.h">
/**
 *  @file   UniFile.h
 *  @author Perry Rapp, Creator, 2003-2006
 *  @date   Created: 2003-10
 *  @date   Edited:  2006-02-20 (Perry Rapp)
 *
 *  @brief  Declaration of Unicode file classes.
 */
#pragma once

#include "unicoder.h"
#include <cstdio>

namespace Poco { class SharedMemory; }

/**
 * @brief Interface to file classes in this module
 */
class UniFile
{
public:

	/**
	 * @brief A struct for error message or error code.
	 */
	struct UniError
	{
		String desc; // valid if apiname empty

		UniError();
		bool HasError() const;
		void ClearError();
		const String& GetError() const;
	};

	virtual ~UniFile() { }
	virtual bool OpenReadOnly(const String& filename) = 0;
	virtual void Close() = 0;
	virtual bool IsOpen() const = 0;

	virtual String GetFullyQualifiedPath() const = 0;
	virtual const UniError & GetLastUniError() const = 0;

	virtual bool IsUnicode() = 0;
	virtual bool ReadBom() = 0;
	virtual bool HasBom() const = 0;
	virtual void SetBom(bool bom) = 0;

	virtual ucr::UNICODESET GetUnicoding() const = 0;
	virtual void SetUnicoding(ucr::UNICODESET unicoding) = 0;
	virtual int GetCodepage() const = 0;
	virtual void SetCodepage(int codepage) = 0;

public:
	virtual bool ReadString(String & line, bool * lossy) = 0;
	virtual bool ReadString(String & line, String & eol, bool * lossy) = 0;
	virtual bool ReadStringAll(String & line) = 0;
	virtual int GetLineNumber() const = 0;
	virtual int64_t GetPosition() const = 0;
	virtual bool WriteString(const String & line) = 0;

	struct txtstats
	{
		int ncrs;
		int nlfs;
		int ncrlfs;
		int nzeros;
		int nlosses;
		txtstats() { clear(); }
		void clear() { ncrs = nlfs = ncrlfs = nzeros = nlosses = 0; }
	};
	virtual const txtstats & GetTxtStats() const = 0;
};

/**
 * @brief Check if there is error.
 * @return true if there is an error.
 */
inline bool UniFile::UniError::HasError() const
{
	return !desc.empty();
}

/**
 * @brief Clears the existing error.
 */
inline void UniFile::UniError::ClearError()
{
	desc.clear();
}

/**
 * @brief Get the error string.
 * @return Error string.
 */
inline const String& UniFile::UniError::GetError() const
{
	return desc;
}

/**
 * @brief Local file access code used by both UniMemFile and UniStdioFile
 *
 * This class lacks an actual handle to a file
 */
class UniLocalFile : public UniFile
{
public:
	UniLocalFile();
	void Clear();

	virtual String GetFullyQualifiedPath() const override { return m_filepath; }
	virtual const UniError & GetLastUniError() const override { return m_lastError; }

	virtual ucr::UNICODESET GetUnicoding() const override { return m_unicoding; }
	virtual void SetUnicoding(ucr::UNICODESET unicoding) override { m_unicoding = unicoding; }
	virtual int GetCodepage() const override { return m_codepage; }
	virtual void SetCodepage(int codepage) override { 
		m_codepage = codepage;
		switch (m_codepage)
		{
		case ucr::CP_UCS2LE:
			m_unicoding = ucr::UCS2LE;
			m_charsize = 2;
			break;
		case ucr::CP_UCS2BE:
			m_unicoding = ucr::UCS2BE;
			m_charsize = 2;
			break;
		case ucr::CP_UTF_8:
			m_charsize = 1;
			m_unicoding = ucr::UTF8;
			break;
		default:
			m_charsize = 1;
			m_unicoding = ucr::NONE;
			break;
		}
	}

	virtual int GetLineNumber() const override { return m_lineno; }
	virtual const txtstats & GetTxtStats() const override { return m_txtstats; }
	virtual int64_t GetFileSize() const{ return m_filesize; }

	bool IsUnicode() override;

protected:
	virtual bool DoGetFileStatus();
	virtual void LastErrorCustom(const String& desc);

protected:
	int m_statusFetched; // 0 not fetched, -1 error, +1 success
	int m_lineno; // current 0-based line of m_current
	int64_t m_filesize;
	String m_filepath;
	String m_filename;
	UniError m_lastError;
	int m_charsize; // 2 for UCS-2, else 1
	int m_codepage; // only valid if m_unicoding==ucr::NONE;
	txtstats m_txtstats;
	ucr::UNICODESET m_unicoding;
	bool m_bom; /**< Did the file have a BOM when reading? */
	bool m_bUnicodingChecked; /**< Has unicoding been checked for the file? */
	bool m_bUnicode; /**< Is the file unicode file? */
};

/**
 * @brief Memory-Mapped disk file (read-only access)
 */
class UniMemFile : public UniLocalFile
{
public:
	enum AccessMode
	{
		AM_READ = 0,
		AM_WRITE
	};

	UniMemFile();
	virtual ~UniMemFile() { Close(); }

	virtual bool GetFileStatus();

	virtual bool OpenReadOnly(const String& filename) override;
	virtual bool Open(const String& filename);
	virtual bool Open(const String& filename, AccessMode mode);
	void Close() override;
	virtual bool IsOpen() const override;

	virtual bool ReadBom() override;
	virtual bool HasBom() const override;
	virtual void SetBom(bool bom) override;

public:
	virtual bool ReadString(String & line, bool * lossy) override;
	virtual bool ReadString(String & line, String & eol, bool * lossy) override;
	virtual bool ReadStringAll(String & line) override;
	virtual int64_t GetPosition() const override { return m_current - m_base; }
	virtual bool WriteString(const String & line) override;
	unsigned char* GetBase() const { return m_base; }

// Implementation methods
protected:
	virtual bool DoOpen(const String& filename, AccessMode mode);

// Implementation data
private:
	Poco::SharedMemory *m_hMapping;
	unsigned char *m_base; // points to base of mapping
	unsigned char *m_data; // similar to m_base, but after BOM if any
	unsigned char *m_current; // current location in file
};

/** @brief Is it currently attached to a file ? */
inline bool UniMemFile::IsOpen() const
{
	// We don't test the handle here, because we allow "opening" empty file
	// but memory-mapping doesn't work on that, so that uses a special state
	// of no handle, but linenumber of 0
	return m_lineno >= 0;
}

/**
 * @brief Returns if file has a BOM bytes.
 * @return true if file has BOM bytes, false otherwise.
 */
inline bool UniMemFile::HasBom() const
{
	return m_bom;
}

/**
 * @brief Sets if file has BOM or not.
 * @param [in] true to have a BOM in file, false to not to have.
 */
inline void UniMemFile::SetBom(bool bom)
{
	m_bom = bom;
}

/**
 * @brief Regular buffered file (write-only access)
 * (ReadString methods have never been implemented,
 *  because UniMemFile above is good for reading)
 */
class UniStdioFile : public UniLocalFile
{
public:
	UniStdioFile();
	~UniStdioFile();

	virtual bool GetFileStatus();

	virtual bool OpenReadOnly(const String& filename) override;
	virtual bool OpenCreate(const String& filename);
	virtual bool OpenCreateUtf8(const String& filename);
	virtual bool Open(const String& filename, const String& mode);
	virtual bool SetVBuf(int mode, size_t size);
	void Close() override;

	virtual bool IsOpen() const override;

	virtual bool ReadBom() override;
	virtual bool HasBom() const override;
	virtual void SetBom(bool bom) override;

protected:
	virtual bool ReadString(String & line, bool * lossy) override;
	virtual bool ReadString(String & line, String & eol, bool * lossy) override;
	virtual bool ReadStringAll(String & line) override;

public:
	virtual int64_t GetPosition() const override;

	virtual int WriteBom();
	virtual bool WriteString(const String & line) override;

// Implementation methods
protected:
	virtual bool DoOpen(const String& filename, const String& mode);
	virtual void LastErrorCustom(const String& desc) override;

// Implementation data
private:
	FILE * m_fp;
	int64_t m_data; // offset after any initial BOM
	ucr::buffer m_ucrbuff;
};

/** @brief Is it currently attached to a file ? */
inline bool UniStdioFile::IsOpen() const
{
	return m_fp != 0;
}

/**
 * @brief Returns if file has a BOM bytes.
 * @return true if file has BOM bytes, false otherwise.
 */
inline bool UniStdioFile::HasBom() const
{
	return m_bom;
}

/**
 * @brief Sets if file has BOM or not.
 * @param [in] true to have a BOM in file, false to not to have.
 */
inline void UniStdioFile::SetBom(bool bom)
{
	m_bom = bom;
}


</file>

<file path="Winmerge-Src/Src/Common/ValidatingEdit.cpp">
/** 
 * @file  ValidatingEdit.cpp
 *
 * @brief Implementation file for CValidatingEdit
 *
 */
#include "stdafx.h"
#include "ValidatingEdit.h"

IMPLEMENT_DYNAMIC(CValidatingEdit, CEdit)

#define ID_VALIDATE_TIMER 1001
#define ID_UPDATE_TIMER 1002
#define VALIDATE_DELAY_MS 700
#define UPDATE_DELAY_MS 200


static COLORREF getDefaultErrorColor()
{
	const COLORREF sysBk = GetSysColor(COLOR_WINDOW);
	if ((GetRValue(sysBk) + GetGValue(sysBk) + GetBValue(sysBk)) / 3 < 128)
		return RGB(80, 40, 40);
	return RGB(255, 200, 200);
}

CValidatingEdit::CValidatingEdit()
	: m_hasError(false)
	, m_errorColor(getDefaultErrorColor())
	, m_errorBrush(m_errorColor)
	, m_toolItem{}
{
}

CValidatingEdit::~CValidatingEdit()
{
	m_errorBrush.DeleteObject();
}

BEGIN_MESSAGE_MAP(CValidatingEdit, CEdit)
	ON_WM_CTLCOLOR_REFLECT()
	ON_WM_KILLFOCUS()
	ON_WM_TIMER()
END_MESSAGE_MAP()

void CValidatingEdit::SetBackColor(COLORREF color)
{
	m_errorColor = color;
	m_errorBrush.DeleteObject();
	m_errorBrush.CreateSolidBrush(m_errorColor);
}

void CValidatingEdit::Validate()
{
	CString text;
	GetWindowText(text);

	const CString prevErrorMessage = m_errorMessage;
	m_hasError = false;
	m_errorMessage.Empty();

	if (m_validator)
	{
		CString msg;
		if (!m_validator(text, msg))
		{
			m_hasError = true;
			m_errorMessage = msg;
		}
	}
	if (prevErrorMessage != m_errorMessage)
	{
		KillTimer(ID_UPDATE_TIMER);
		SetTimer(ID_UPDATE_TIMER, UPDATE_DELAY_MS, nullptr);
	}

	Invalidate();
}

HBRUSH CValidatingEdit::CtlColor(CDC* pDC, UINT /*nCtlColor*/)
{
	if (m_hasError)
	{
		pDC->SetTextColor(GetSysColor(COLOR_WINDOWTEXT));
		pDC->SetBkColor(m_errorColor);
		return (HBRUSH)m_errorBrush.GetSafeHandle();
	}
	return nullptr;
}

BOOL CValidatingEdit::PreTranslateMessage(MSG* pMsg)
{
	if (m_toolTip.m_hWnd)
		m_toolTip.RelayEvent(pMsg);
	return CEdit::PreTranslateMessage(pMsg);
}

void CValidatingEdit::OnKillFocus(CWnd* pNewWnd)
{
	CEdit::OnKillFocus(pNewWnd);
	Validate();
}

void CValidatingEdit::OnEnChange()
{
	if (!m_hWnd)
		return;
	KillTimer(ID_VALIDATE_TIMER);
	SetTimer(ID_VALIDATE_TIMER, VALIDATE_DELAY_MS, nullptr);
}

void CValidatingEdit::OnTimer(UINT_PTR nIDEvent)
{
	if (nIDEvent == ID_VALIDATE_TIMER)
	{
		KillTimer(ID_VALIDATE_TIMER);
		Validate();
		return;
	}
	if (nIDEvent == ID_UPDATE_TIMER)
	{
		KillTimer(ID_UPDATE_TIMER);

		if (m_hasError)
		{
			CRect rc;
			GetWindowRect(&rc);

			if (!m_toolTip.GetSafeHwnd())
			{
				m_toolTip.Create(this, TTS_NOPREFIX | TTS_BALLOON | TTS_ALWAYSTIP);
				m_toolItem.cbSize = sizeof(TOOLINFO);
				m_toolItem.uFlags = TTF_TRACK | TTF_ABSOLUTE;
				m_toolItem.hwnd = m_hWnd;
				m_toolItem.uId = 1;
				m_toolItem.lpszText = _T("");
				m_toolTip.SendMessage(TTM_ADDTOOL, 0, (LPARAM)&m_toolItem);
				m_toolTip.SetMaxTipWidth(rc.Width());
			}

			m_toolItem.lpszText = (LPTSTR)(LPCTSTR)m_errorMessage;
			m_toolTip.SetToolInfo(&m_toolItem);

			POINT pt{ rc.left, rc.bottom };
			m_toolTip.SendMessage(TTM_TRACKPOSITION, 0, (LPARAM)MAKELONG(pt.x, pt.y));

			m_toolTip.SendMessage(TTM_TRACKACTIVATE, TRUE, (LPARAM)&m_toolItem);
		}
		else
		{
			if (m_toolTip.GetSafeHwnd())
			{
				m_toolTip.UpdateTipText(_T(""), this);
				m_toolTip.SendMessage(TTM_TRACKACTIVATE, FALSE, (LPARAM)&m_toolItem);
			}
		}
		return;
	}
	CEdit::OnTimer(nIDEvent);
}

</file>

<file path="Winmerge-Src/Src/Common/ValidatingEdit.h">
/** 
 * @file  ValidatingEdit.h
 *
 * @brief Declaration file for CValidatingEdit class
 */
#pragma once

class CValidatingEdit : public CEdit
{
	DECLARE_DYNAMIC(CValidatingEdit);
public:

	CValidatingEdit();
	virtual ~CValidatingEdit();

	std::function<bool(const CString&, CString&)> m_validator;

	void SetBackColor(COLORREF color);
	void Validate();
	void OnEnChange();

protected:
	DECLARE_MESSAGE_MAP()

	afx_msg HBRUSH CtlColor(CDC* pDC, UINT nCtlColor);
	afx_msg BOOL PreTranslateMessage(MSG* pMsg);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnTimer(UINT_PTR nIDEvent);

	CToolTipCtrl m_toolTip;
	bool m_hasError;
	COLORREF m_errorColor;
	CString m_errorMessage;
	CBrush m_errorBrush;
	TOOLINFO m_toolItem;
};
</file>

<file path="Winmerge-Src/Src/Common/varprop.cpp">
/**
 *  @file varprop.cpp
 *
 *  @brief Implementation of generic named property classes
 */ 

#include "pch.h"
#include "varprop.h"
#include <cassert>

namespace varprop
{
/**
 * @brief Default constructor.
 */
VariantValue::VariantValue()
: m_vtype(VT_NULL), m_bvalue(false), m_ivalue(0), m_fvalue(0),
  m_tvalue(0)
{
}

/**
 * @brief Copy constructor.
 * @param [in] value Object to copy.
 */
VariantValue::VariantValue(const VariantValue &value)
	: m_vtype(value.m_vtype)
	, m_bvalue(value.m_bvalue)
	, m_ivalue(value.m_ivalue)
	, m_fvalue(value.m_fvalue)
	, m_tvalue(value.m_tvalue)
	, m_svalue(value.m_svalue)
{
}

/**
 * @brief Assignment operator override.
 * @param [in] Object to copy.
 * @return Copy of given object.
 */
VariantValue& VariantValue::operator=(const VariantValue& value)
{
	if (this != &value)
	{
		m_vtype = value.m_vtype;
		m_bvalue = value.m_bvalue;
		m_ivalue = value.m_ivalue;
		m_fvalue = value.m_fvalue;
		m_svalue = value.m_svalue;
		m_tvalue = value.m_tvalue;
	}
	return *this;
}

/**
 * @brief Set boolean value.
 * @param [in] v Boolean value to set.
 */
void VariantValue::SetBool(bool v)
{
	Clear();
	m_vtype = VT_BOOL;
	m_bvalue = v;
}

/**
 * @brief Set integer value.
 * @param [in] v Integer value to set.
 */
void VariantValue::SetInt(int v)
{ 
	Clear();
	m_vtype = VT_INT;
	m_ivalue = v;
}

/**
 * @brief Set floating point value.
 * @param [in] v Floating point value to set.
 */
void VariantValue::SetFloat(double v)
{
	Clear();
	m_vtype = VT_FLOAT;
	m_fvalue = v;
}

/**
 * @brief Set string value.
 * @param [in] sz String value to set. Can be a `nullptr`.
 */
void VariantValue::SetString(const tchar_t *sz)
{
	Clear();
	m_vtype = VT_STRING;
	if (sz != nullptr)
		m_svalue = sz;
}

/**
 * @brief Set string value.
 * @param [in] sz String value to set.
 */
void VariantValue::SetString(const String& sz)
{
	m_svalue = sz;
	m_vtype = VT_STRING;
}

/**
 * @brief Set time value.
 * @param [in] v Time value to set.
 */
void VariantValue::SetTime(time_t v)
{
	Clear();
	m_vtype = VT_TIME;
	m_tvalue = v;
}

/**
 * @brief Clear variant's value (reset to defaults).
 */
void VariantValue::Clear()
{
	m_vtype = VT_NULL;
	m_bvalue = false;
	m_ivalue = 0;
	m_fvalue = 0;
	m_svalue.erase();
	m_tvalue = 0;
}

/**
 * @brief Get boolean value.
 * @return Boolean value.
 */
bool VariantValue::GetBool() const
{
	assert(m_vtype == VT_BOOL);
	return m_bvalue;
}

/**
 * @brief Get integer value.
 * @return Integer value.
 */
int VariantValue::GetInt() const
{
	assert(m_vtype == VT_INT);
	return m_ivalue;
}

/**
 * @brief Get floating point value.
 * @return Floating point value.
 */
double VariantValue::GetFloat() const
{
	assert(m_vtype == VT_FLOAT);
	return m_fvalue;
}

/**
 * @brief Get string value.
 * @return String value.
 */
const String& VariantValue::GetString() const
{
	assert(m_vtype == VT_STRING);
	return m_svalue;
}

/**
 * @brief Get time value.
 * @return Time value.
 */
time_t VariantValue::GetTime() const
{
	assert(m_vtype == VT_TIME);
	return m_tvalue;
}

} // namespace
</file>

<file path="Winmerge-Src/Src/Common/varprop.h">
/**
 *  @file varprop.h
 *
 *  @brief Declaration of generic named property classes
 */ 
#pragma once

#include <ctime>
#include "UnicodeString.h"

namespace varprop
{

/**
 * @brief Types that variant type can contain.
 */
typedef enum
{
	VT_NULL,     /**< No type */
	VT_BOOL,     /**< Boolean type */
	VT_INT,      /**< Integer type */
	VT_FLOAT,    /**< Floating point type */
	VT_STRING,   /**< String type */
	VT_TIME      /**< Time type */
} VT_TYPE;

/**
 * @brief A variant class.
 * This class can hold several base types. Type is set when the value is set.
 * @todo Add function to get/set string values as UTF-8 string - to avoid
 *  conversions in call sites.
 */
class VariantValue
{
public:
	VariantValue();
	VariantValue(const VariantValue &value);
	VariantValue& operator=(const VariantValue& value);

	bool IsBool() const { return m_vtype == VT_BOOL; }
	bool IsInt() const { return m_vtype == VT_INT; }
	bool IsFloat() const { return m_vtype == VT_FLOAT; }
	bool IsString() const { return m_vtype == VT_STRING; }
	bool IsTime() const { return m_vtype == VT_TIME; }
	VT_TYPE GetType() const { return m_vtype; }

	void SetBool(bool v);
	void SetInt(int v);
	void SetFloat(double v);
	void SetString(const tchar_t *sz);
	void SetString(const String& sz);
	void SetTime(time_t v);

	void Clear();

	bool GetBool() const;
	int GetInt() const;
	double GetFloat() const;
	const String& GetString() const;
	time_t GetTime() const;

private:
	VT_TYPE m_vtype;  /**< Type of the variant. */
	bool m_bvalue;    /**< Boolean value of the variant. */
	int m_ivalue;     /**< Integer value of the variant. */
	double m_fvalue;  /**< Floating point value of the variant. */
	String m_svalue;  /**< String value of the variant. */
	time_t m_tvalue;  /**< Time value of the variant. */
};

} // namespace
</file>

<file path="Winmerge-Src/Src/Common/VersionInfo.cpp">
/**
 *  @file VersionInfo.cpp
 *
 *  @brief Implementation of CVersionInfo class
 */ 

#include "pch.h"
#include "VersionInfo.h"
#include <windows.h>
#include <cstdio>
#include <cassert>
#include <strsafe.h>
#include "UnicodeString.h"

/** 
 * @brief Structure used to store language and codepage.
 */
struct LANGUAGEANDCODEPAGE
{
	WORD wLanguage;
	WORD wCodePage;
};

/** 
 * @brief Constructor for asking only numeric version info.
 * This constructor creates instance that only reads version numbers,
 * not several strings there are. This saves some time.
 * @param [in] bVersionOnly If `true` only version numbers are read.
 */
CVersionInfo::CVersionInfo(bool bVersionOnly)
: m_wLanguage(0)
, m_bVersionOnly(bVersionOnly)
, m_bDllVersion(false)
{
	GetVersionInfo();
}

/** 
 * @brief Constructor for asking version infor when language is known.
 * This constructor creates instance which gets version-info matching
 * given language-ID. There can be several different language-codepage
 * combinations, but we use first version info block that matches the
 * given language. So even if codepage isn't correct, we get correct
 * version information.
 * @param [in] wLanguage Language-ID for which the version info is wanted.
 */
CVersionInfo::CVersionInfo(WORD wLanguage)
: m_wLanguage(wLanguage)
, m_bVersionOnly(false)
, m_bDllVersion(false)
{
	GetVersionInfo();
}

/** 
 * @brief Constructor.
 * @param [in] szFileToVersion Filename to read version from.
 * @param [in] bDllVersion If `true` queries DLL version.
 */
CVersionInfo::CVersionInfo(const tchar_t* szFileToVersion, 
						   bool bDllVersion)
: m_wLanguage(0)
, m_bVersionOnly(false)
, m_bDllVersion(bDllVersion)
{
	if (szFileToVersion != nullptr)
		m_strFileName = szFileToVersion;
	GetVersionInfo();
}

/** 
 * @brief Constructor.
 * @param [in] szFileToVersion Filename to read version from.
 * @param [in] szLanguage Language for version.
 * @param [in] szCodePage Codepage for version.
 */
CVersionInfo::CVersionInfo(const tchar_t* szFileToVersion /* = nullptr*/, 
						   const tchar_t* szLanguage /* = nullptr*/,
						   const tchar_t* szCodepage /* = nullptr*/)
: m_wLanguage(0)
, m_bVersionOnly(false)
, m_bDllVersion(false)
{
	if (szFileToVersion != nullptr)
		m_strFileName = szFileToVersion;
	if (szLanguage != nullptr)
		m_strLanguage = szLanguage;
	if (szCodepage != nullptr)
		m_strCodepage = szCodepage;
	GetVersionInfo();
}

/** 
 * @brief Constructor for asking version number from known module.
 * @param [in] hModule Handle to module for version info.
 */
CVersionInfo::CVersionInfo(HINSTANCE hModule)
: m_wLanguage(0)
, m_bVersionOnly(false)
, m_bDllVersion(false)
{
	tchar_t szFileName[MAX_PATH];
	GetModuleFileName(hModule, szFileName, MAX_PATH);
	m_strFileName = szFileName;
	GetVersionInfo();
}

/** 
 * @brief Format version string from numbers.
 * Version number consists of four WORD (16-bit) numbers. This function
 * formats those numbers to string, where numbers are separated by
 * dots. If the last number is zero it is not printed.
 * @param [in] First two (most significant) numbers for version number.
 * @param [in] Last two numbers for version number.
 * @return Formatted version string.
 */
static String MakeVersionString(DWORD hi, DWORD lo)
{
	tchar_t ver[50];
	if (LOWORD(lo) == 0)
	{
		StringCchPrintf(ver, std::size(ver) - 1, _T("%d.%d.%d"), HIWORD(hi),
				LOWORD(hi), HIWORD(lo));
	}
	else
	{
		StringCchPrintf(ver, std::size(ver) - 1, _T("%d.%d.%d.%d"), HIWORD(hi),
				LOWORD(hi), HIWORD(lo), LOWORD(lo));
	}
	String sver(ver);
	return sver;
}

/** 
 * @brief Return numeric product's version number.
 * This function returns version number given as a number in version info.
 * @return Product's version number as string.
 */
String CVersionInfo::GetFixedProductVersion()
{
	if (!m_bVersionFound)
		return _T("");
	return MakeVersionString(m_FixedFileInfo.dwProductVersionMS
		, m_FixedFileInfo.dwProductVersionLS);
}

/** 
 * @brief Return numeric file's version number.
 * This function returns version number given as a number in version info.
 * @return File's version number as string.
 */
String CVersionInfo::GetFixedFileVersion()
{
	if (!m_bVersionFound)
		return _T("");
	return MakeVersionString(m_FixedFileInfo.dwFileVersionMS
		, m_FixedFileInfo.dwFileVersionLS);
}

/** 
 * @brief Return numeric file's version number.
 * This function returns version number given as two DWORDs.
 * @param [out] versionMS High DWORD for version number.
 * @param [out] versionLS Low DWORD for version number.
 * @return `true` if version info was found, `false` otherwise.
 */
bool CVersionInfo::GetFixedFileVersion(unsigned& versionMS, unsigned& versionLS)
{
	if (m_bVersionFound)
	{
		versionMS = m_FixedFileInfo.dwFileVersionMS;
		versionLS = m_FixedFileInfo.dwFileVersionLS;
		return true;
	}
	return false;
}

/** 
 * @brief Read version info from file.
 * This function reads version information from file's version resource
 * to member variables.
 */
void CVersionInfo::GetVersionInfo()
{
	ZeroMemory(&m_FixedFileInfo, sizeof(m_FixedFileInfo));
	ZeroMemory(&m_dvi, sizeof(m_dvi));

	DWORD dwVerHnd = 0;			// An 'ignored' parameter, always '0'
	tchar_t szFileName[MAX_PATH];

	if (m_strFileName.empty())
	{
		::GetModuleFileName(nullptr, szFileName, MAX_PATH);
		m_strFileName = szFileName;
	}
	else
		StringCchCopy(szFileName, MAX_PATH, m_strFileName.c_str());
	
	DWORD dwVerInfoSize = ::GetFileVersionInfoSize(szFileName, &dwVerHnd);
	if (dwVerInfoSize)
	{
		m_bVersionFound = true;
		m_pVffInfo.reset(new BYTE[dwVerInfoSize]);
		if (::GetFileVersionInfo(szFileName, 0, dwVerInfoSize, m_pVffInfo.get()))
		{
			GetFixedVersionInfo();
			if (!m_bVersionOnly)
				QueryStrings();
		}
	}

	if (m_bDllVersion)
	{
		if (HINSTANCE hinstDll = ::LoadLibrary(szFileName))
		{
			DLLGETVERSIONPROC DllGetVersion = (DLLGETVERSIONPROC) 
					::GetProcAddress(hinstDll, "DllGetVersion");
			if (DllGetVersion)
			{
				m_dvi.cbSize = sizeof(m_dvi);
				if (FAILED(DllGetVersion(&m_dvi)))
				{
					m_dvi.cbSize = 0;
				}
			}
			::FreeLibrary(hinstDll);
		}
	}
}

/** 
 * @brief Read strings from version info data.
 */
void CVersionInfo::QueryStrings()
{
	if (m_wLanguage != 0)
	{
		WORD codepage;
		GetCodepageForLanguage(m_wLanguage, codepage);
		tchar_t temp[20];
		StringCchPrintf(temp, std::size(temp) - 1, _T("%04x"), m_wLanguage);
		m_strLanguage = temp;
		StringCchPrintf(temp, std::size(temp) - 1, _T("%04x"), codepage);
		m_strCodepage = temp;
	}
	else if (m_strLanguage.empty()
		|| m_strCodepage.empty())
	{
		LANGUAGEANDCODEPAGE *lpTranslate;
		DWORD langLen;
		if (!!VerQueryValue((LPVOID)m_pVffInfo.get(),
				_T("\\VarFileInfo\\Translation"),
				(LPVOID *)&lpTranslate, (UINT *)&langLen))
		{
			tchar_t temp[20];
			StringCchPrintf(temp, std::size(temp) - 1, _T("%4.4X"),
					lpTranslate[0].wLanguage);
			m_strLanguage = temp;
			StringCchPrintf(temp, std::size(temp) - 1, _T("%4.4X"),
					lpTranslate[0].wCodePage);
			m_strCodepage = temp;
		}
	}
	QueryValue(_T("CompanyName"), m_strCompanyName);
	QueryValue(_T("FileDescription"), m_strFileDescription);
	QueryValue(_T("FileVersion"), m_strFileVersion); 
	QueryValue(_T("InternalName"), m_strInternalName); 
	QueryValue(_T("LegalCopyright"), m_strLegalCopyright); 
	QueryValue(_T("OriginalFilename"), m_strOriginalFilename); 
	QueryValue(_T("ProductName"), m_strProductName); 
	QueryValue(_T("ProductVersion"), m_strProductVersion); 
	QueryValue(_T("Comments"), m_strComments);
	QueryValue(_T("SpecialBuild"), m_strSpecialBuild);
	QueryValue(_T("PrivateBuild"), m_strPrivateBuild);
}

/** 
 * @brief Read value from version info data.
 * @param [in] szId Name of value/string to read.
 * @param [out] Value read.
 */
void CVersionInfo::QueryValue(const tchar_t* szId, String& s)
{
	assert(m_pVffInfo != nullptr);
	tchar_t* lpVersion;			// String pointer to 'version' text
	UINT    uVersionLen;
	bool    bRetCode;

	tchar_t szSelector[256];
	StringCchPrintf(szSelector, std::size(szSelector) - 1,
			_T("\\StringFileInfo\\%s%s\\%s"),
			m_strLanguage.c_str(), m_strCodepage.c_str(), szId);
	bRetCode = !!VerQueryValue((LPVOID)m_pVffInfo.get(),
		szSelector,
		(LPVOID *)&lpVersion,
		&uVersionLen);
	
	if (bRetCode)
	{
		s = lpVersion;
		if (!s.empty())
			s = strutils::trim_ws(s);
	}
	else
		s.clear();
}

/** 
 * @brief Read numeric version information.
 */
void CVersionInfo::GetFixedVersionInfo()
{
	VS_FIXEDFILEINFO * pffi;
	UINT len = sizeof(*pffi);
	bool bRetCode = !!VerQueryValue(
		(LPVOID)m_pVffInfo.get(), _T("\\"), (LPVOID *)&pffi, &len);
	if (bRetCode)
		m_FixedFileInfo = *pffi;
	else
		m_FixedFileInfo = { 0 };
	m_dvi.dwMajorVersion = HIWORD(m_FixedFileInfo.dwFileVersionMS);
	m_dvi.dwMinorVersion = LOWORD(m_FixedFileInfo.dwFileVersionMS);
	m_dvi.dwBuildNumber = HIWORD(m_FixedFileInfo.dwFileVersionLS);
}

/** 
 * @brief Get codepage for given language.
 * This function finds codepage value for given language from version info.
 * That is, we have certain combinations of language-codepage in version info.
 * This function tells which codepage exists with given language, so we can
 * find existing version info data.
 * @param [in] wLanguage Language ID for which we need matching codepage.
 * @param [out] wCodePage Found codepage.
 * @return `true` if language was found from version info block.
 */
bool CVersionInfo::GetCodepageForLanguage(WORD wLanguage, WORD & wCodePage)
{
	LANGUAGEANDCODEPAGE *lpTranslate;
	UINT cbTranslate;
	// Read the list of languages and code pages.

	VerQueryValue((LPVOID)m_pVffInfo.get(), 
				_T("\\VarFileInfo\\Translation"),
				(LPVOID*)&lpTranslate,
				&cbTranslate);

	// Read the file description for each language and code page.

	const int nLangCount = cbTranslate / sizeof(LANGUAGEANDCODEPAGE);
	int i = 0;
	bool bFound = false;
	while (!bFound && i < nLangCount)
	{
		if (lpTranslate[i].wLanguage == wLanguage)
		{
			wCodePage = lpTranslate[i].wCodePage;
			bFound = true;
		}
		else
			++i;
	}
	return bFound;
}
</file>

<file path="Winmerge-Src/Src/Common/VersionInfo.h">
/**
 *  @file VersionInfo.h
 *
 *  @brief Declaration of CVersionInfo class
 */ 
#pragma once

#include <shlwapi.h>
#include <memory>
#include "UnicodeString.h"

/**
 * @brief Class providing access to version information of a file.
 * This class reads version information block from a file. Version information
 * consists of version numbers, copyright, descriptions etc. Since that is
 * many strings to read, there is constructor taking `bool` parameter and
 * only reading version numbers. That constructor is suggested to be used
 * if string information is not needed.
 */
class CVersionInfo
{
private:
	VS_FIXEDFILEINFO m_FixedFileInfo; /**< Fixed file information */
	std::unique_ptr<BYTE[]> m_pVffInfo; /**< Pointer to version information block */
	bool m_bVersionOnly; /**< Ask version numbers only */
	bool m_bDllVersion; /**< Dll file version is being queried */
	WORD m_wLanguage; /**< Language-ID to use (if given) */
	bool m_bVersionFound; /**< Was version info found from file? */

	String m_strFileName;
	String m_strLanguage;
	String m_strCodepage;
	String m_strCompanyName;
	String m_strFileDescription;
	String m_strFileVersion;
	String m_strInternalName; 
	String m_strLegalCopyright; 
	String m_strOriginalFilename; 
	String m_strProductName; 
	String m_strProductVersion; 
	String m_strComments;
	String m_strSpecialBuild;
	String m_strPrivateBuild;

public:
	explicit CVersionInfo(bool bVersionOnly);
	explicit CVersionInfo(WORD wLanguage);
	CVersionInfo(const tchar_t* szFileToVersion,
				   bool bDllVersion);
	CVersionInfo(const tchar_t* szFileToVersion = nullptr,
				   const tchar_t* szLanguage = nullptr,
				   const tchar_t* szCodepage = nullptr);
	explicit CVersionInfo(HINSTANCE hModule);
	const String& GetFileVersion() const;
	const String& GetCompanyName() const;
	const String& GetFileDescription() const;
	const String& GetInternalName() const;
	const String& GetFullFileName() const;
	const String& GetLegalCopyright() const;
	const String& GetOriginalFilename() const;
	const String& GetProductVersion() const;
	const String& GetComments() const;
	const String& GetSpecialBuild() const;
	const String& GetPrivateBuild() const;
	String GetFixedProductVersion();
	String GetFixedFileVersion();
	DLLVERSIONINFO m_dvi;
	bool GetFixedFileVersion(unsigned& versionMS, unsigned& versionLS);

protected:
	void GetVersionInfo();
	void GetFixedVersionInfo();
	void QueryStrings();
	void QueryValue(const tchar_t* szId, String& s);
	bool GetCodepageForLanguage(WORD wLanguage, WORD & wCodePage);
};

/** 
 * @brief Return file version string.
 * @return File version as string.
 */
inline const String& CVersionInfo::GetFileVersion() const
{
	return m_strFileVersion;
}

/** 
 * @brief Return private build value.
 * @return Private build number as string.
 */
inline const String& CVersionInfo::GetPrivateBuild() const
{
	return m_strPrivateBuild;
}

/** 
 * @brief Return special build value.
 * @return Special build number as string.
 */
inline const String& CVersionInfo::GetSpecialBuild() const
{
	return m_strSpecialBuild;
}

/** 
 * @brief Return company name.
 * @return Company name.
 */
inline const String& CVersionInfo::GetCompanyName() const
{
	return m_strCompanyName;
}

/** 
 * @brief Return file description string.
 * @return File description string.
 */
inline const String& CVersionInfo::GetFileDescription() const
{
	return m_strFileDescription;
}

/** 
 * @brief Return internal name.
 * @return Internal name.
 */
inline const String& CVersionInfo::GetInternalName() const
{
	return m_strInternalName;
}

/** 
 * @brief Return full file name.
 * @return full file name.
 */
inline const String& CVersionInfo::GetFullFileName() const
{
	return m_strFileName;
}

/** 
 * @brief Return copyright info.
 * @return Copyright info.
 */
inline const String& CVersionInfo::GetLegalCopyright() const
{
	return m_strLegalCopyright;
}

/** 
 * @brief Return original filename.
 * @return Original filename.
 */
inline const String& CVersionInfo::GetOriginalFilename() const
{
	return m_strOriginalFilename;
}

/** 
 * @brief Return product's version number.
 * @return Product's version number as string.
 */
inline const String& CVersionInfo::GetProductVersion() const
{
	return m_strProductVersion;
}

/** 
 * @brief Return comment string.
 * @return Comment string.
 */
inline const String& CVersionInfo::GetComments() const
{
	return m_strComments;
}

</file>

<file path="Winmerge-Src/Src/res/Merge.rc2">
//
// MERGE.RC2 - resources Microsoft Visual C++ does not edit directly
//

#ifdef APSTUDIO_INVOKED
	#error this file is not editable by Microsoft Visual C++
#endif //APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
// Add manually edited resources here...
#include "..\Merge2.rc"
#include "..\Externals\crystaledit\editlib\editres.rc"
/////////////////////////////////////////////////////////////////////////////
</file>

<file path="Winmerge-Src/Src/res/mg_cur.cur">
